code,complexity,tags,code_length
"from math import sqrt a, v = map(int, input().split()) l, d, w = map(int, input().split()) def findt(u, v, a, dist): front = (v*v-u*u)/(2*a) if front > dist: return (sqrt(u*u+2*a*dist)-u)/a return (v-u)/a + (dist-front)/v def solve(a, v, l, d, w): if v <= w or 2*a*d <= w*w: return findt(0, v, a, l) after = findt(w, v, a, l-d) peak = sqrt(a*d + w*w/2) if peak > v: travel = (v*v-w*w/2)/a before = (2*v-w)/a + (d-travel)/v else: before = (2*peak-w)/a return before + after print(f'{solve(a, v, l, d, w):.8f}')",constant,"['implementation', 'math']",509
"from math import * a, vm = map(int, input().split()) l, d, vd = map(int, input().split()) if vm <= vd or sqrt(2 * a * d) <= vd: if vm ** 2 / (2 * a) >= l: ans = sqrt(2 * l / a) else: ans = vm / a + (l - vm ** 2 / (2 * a)) / vm else: s1 = (vm ** 2 - vd ** 2) / (2 * a) if s1 >= (l - d): ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a) else: ans = (vm - vd) / a + (l - d - s1) / vm v1 = sqrt((2 * a * d + vd ** 2) / 2) if v1 <= vm: ans = ans + v1 / a + (v1 - vd) / a else: s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a) ans = ans + vm / a + (vm - vd) / a + s1 / vm print('%.12f' % ans)",constant,"['implementation', 'math']",614
"import os import sys from io import BytesIO, IOBase import heapq as h from bisect import bisect_left, bisect_right import time from types import GeneratorType BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): import os self.os = os self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: self.os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from collections import defaultdict as dd, deque as dq, Counter as dc import string from math import sqrt def getInts(): return [int(s) for s in input().split()] def getInt(): return int(input()) def getStrs(): return [s for s in input().split()] def getStr(): return input() def listStr(): return list(input()) def getMat(n): return [getInts() for _ in range(n)] def isInt(s): return '0' <= s[0] <= '9' MOD = 10**9 + 7 def t_from_s_a_u(s,a,u): re",constant,"['implementation', 'math']",1999
"from math import * a, vm = map(int, input().split()) l, d, vd = map(int, input().split()) if vm <= vd or sqrt(2 * a * d) <= vd: if vm ** 2 / (2 * a) >= l: ans = sqrt(2 * l / a) else: ans = vm / a + (l - vm ** 2 / (2 * a)) / vm else: s1 = (vm ** 2 - vd ** 2) / (2 * a) if s1 >= (l - d): ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a) else: ans = (vm - vd) / a + (l - d - s1) / vm v1 = sqrt((2 * a * d + vd ** 2) / 2) if v1 <= vm: ans = ans + v1 / a + (v1 - vd) / a else: s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a) ans = ans + vm / a + (vm - vd) / a + s1 / vm print('%.12f' % ans)",constant,"['implementation', 'math']",614
"from math import * a,v=list(map(int,input().split())) l,d,w=list(map(int,input().split())) if v>w: s1=w**2/2/a if d<=s1: s=min(v**2/2/a,l) t=sqrt(2*s/a)+(l-s)/v else: t=sqrt(2*s1/a) s2=min((d-s1)/2,(v**2-w**2)/(2*a)) if s2==(d-s1)/2: t+=2*(sqrt(2*(s1+s2)/a)-sqrt(2*s1/a)) else: t+=2*(v-w)/a+(d-s1-2*s2)/v s3=min((v**2-w**2)/2/a,l-d) t+=sqrt(2*(s3+s1)/a)-sqrt(2*s1/a)+(l-d-s3)/v else: s=min(v**2/2/a,l) t=sqrt(2*s/a)+(l-s)/v print(t)",constant,"['implementation', 'math']",432
"import math SPACE = ' ' def get_data(file_name): result = list() state = 0 data = list() try: for line in open(file_name, 'r').readlines(): line = line.strip() if state == 0: if line == 'Input': data = list() state = 1 elif line == 'Answer': state = 2 elif state == 1: data += list(map(int, line.split(SPACE))) state = 11 elif state == 11: data += list(map(int, line.split(SPACE))) state = 0 elif state == 2: data.append(float(line)) result.append(data) state = 0 except FileNotFoundError: print(f'File {file_name} not found.') return result def time(d=None, v=None, v0=0, steady=False): if steady: return d / v if d is None: return (v - v0) / ACCEL if v is None: v = vel(d=d, v0=v0) return (2 * d) / (v + v0) def dist(t=None, v=None, v0=0, steady=False): if steady: return v * t if t is None: return (pow(v, 2) - pow(v0, 2)) / (2 * ACCEL) return (1 / 2) * (v + v0) * t def vel(d=None, t=None, v0=0, steady=False): if steady: return d / t if d is None: return t * ACCEL - v0 return pow(2 * d * ACCEL + v0 ** 2, 1 / 2) def can_ignore_sign(v, w, d): return v <= w or d <= dist(v=w) def ignore_sign(v, w, l): dmax = dist(v=v) if l <= dmax: return time(d=l) return time(v=v) + time(d=l - dmax, v=v, steady=True) def get_time(a, v, l, d, w): global ACCEL ACCEL = a if can_ignore_sign(v, w, d): return ignore_sign(v, w, l) tmax, dmax = time(v=v), dist(v=v) tlim_max, dlim_max = time(v=v, v0=w), dist(v=v, v0=w) if dmax + dlim_max <= d: res = tmax + time(d=d - dmax - dlim_max, v=v, steady=True) + tlim_max else: res = time(v=w) + time(v=vel(d=(d - dist(v=w)) / 2, v0=w), v0=w) * 2 x = d + dist(v=v) - dist(v=w) if x >= l: res += time(d=l - d, v0=w) return res return res + time(v=v, v0=w) + time(d=l - x, v=v, steady=True) if __name__ == '__main__': a, v = map(int, input().split()) l, d, w = map(int, input().split()) print(get_time(a, v, l, d, w))",constant,"['implementation', 'math']",1843
"import math def getdt(): return map(int, input().split()) def calc(v0, v, a, x): t = (v - v0) / a x0 = v0 * t + 0.5 * a * t * t if x0 >= x: return (x, (math.sqrt(v0 * v0 + 2 * a * x) - v0) / a) return (x0, t) def go(v0, v, a, x): x0, t = calc(v0, v, a, x) return t + (x - x0) / v a, v = getdt() l, d, w = getdt() if w > v: w = v x, t = calc(0, w, a, d) if x == d: print(go(0, v, a, l)) else: print(t + go(w, v, a, (d - x) * 0.5) * 2 + go(w, v, a, l - d))",constant,"['implementation', 'math']",454
"import math def getdt(): return map(int,input().split()) def calc(v0,v,a,x): t = (v - v0)/a x0 = v0 * t + 0.5*a*t*t if x0>=x: return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a) return (x0,t) def go(v0,v,a,x): x0,t = calc(v0,v,a,x) return t + (x-x0)/v a,v = getdt() l,d,w = getdt() if w>v: w = v x,t = calc(0,w,a,d) if x==d: print(go(0,v,a,l)) else: print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",constant,"['implementation', 'math']",389
"a, v = list(map(int, input().split("" ""))) l, d, w = list(map(int, input().split("" ""))) if(v <= w or w * w > 2 * a * d): if(v * v > 2 * a * l): print((2 * l / a) ** 0.5) else: print(l / v + v / 2 / a) else: u = (w * w / 2 + a * d) ** 0.5 if(u > v): m = v / a + (v - w) / a + (d - (v * v / 2 / a) - (v * v - w * w) / 2 / a) / v else: m = (2 * u - w) / a if(v * v > 2 * a * (l - d + w * w / 2 / a)): print(m - w / a + (2 * (l - d + (w * w / 2 / a)) / a) ** 0.5) else: print(m - w / a + (l - d + w * w / 2 / a) / v + v / 2 / a)",constant,"['implementation', 'math']",523
"import decimal decimal.getcontext().prec = 100 a, v = map(decimal.Decimal, input().split()) l, d, w = map(decimal.Decimal, input().split()) def DecimalPow(a, b): return decimal.Decimal(a) ** decimal.Decimal(b) def getLastT(v1, dist): t1 = (v - v1) / a d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2) if d1 >= dist: return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a t2 = (dist - d1) / v return t1 + t2 if w >= v: t1 = v / a if decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2)) <= l: t2 = (l - decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2))) / v else: t1 = (decimal.Decimal(2) * l / a) ** decimal.Decimal(0.5) t2 = 0 t = t1 + t2 print('{t:.5f}'.format(t = t)) elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d: t = getLastT(0, l) print('{t:.5f}'.format(t = t)) elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d: t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5) t1 = w / a + t2 t3 = getLastT(w, l - d) t = t1 + t2 + t3 print('{t:.5f}'.format(t = t)) else: t1 = v / a t3 = (v - w) / a t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v t4 = getLastT(w, l - d) t = t1 + t2 + t3 + t4 print('{t:.5f}'.format(t = t))",constant,"['implementation', 'math']",1423
"import decimal decimal.getcontext().prec = 100 a, v = map(decimal.Decimal, input().split()) l, d, w = map(decimal.Decimal, input().split()) def DecimalPow(a, b): return decimal.Decimal(a) ** decimal.Decimal(b) def getLastT(v1, dist): t1 = (v - v1) / a d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2) if d1 >= dist: return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a t2 = (dist - d1) / v return t1 + t2 if w >= v: t = getLastT(0, l) print('{t:.5f}'.format(t = t)) elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d: t = getLastT(0, l) print('{t:.5f}'.format(t = t)) elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d: t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5) t1 = w / a + t2 t3 = getLastT(w, l - d) t = t1 + t2 + t3 print('{t:.5f}'.format(t = t)) else: t1 = v / a t3 = (v - w) / a t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v t4 = getLastT(w, l - d) t = t1 + t2 + t3 + t4 print('{t:.5f}'.format(t = t))",constant,"['implementation', 'math']",1216
"import sys def time_distance(v0, a, d): return (-v0 + (v0**2 + 2*a*d)**0.5)/a def time_accelerating(v0, v1, a): return (v1 - v0)/a def time_speed(v, d): return d/v def distance_travelled(v0, t, a): return v0*t + (a/2)*t**2 def main(): a, v = map(int,sys.stdin.readline().strip().split()) l, d, w = map(int,sys.stdin.readline().strip().split()) time = 0 time_to_d = time_distance(0, a, d) time_to_v = time_accelerating(0, v, a) if (v if time_to_v <= time_to_d else time_to_d * a) <= w: acceleration_time = time_to_v acceleration_distance = distance_travelled(0, acceleration_time, a) if acceleration_distance >= l: time = time_distance(0, a, l) else: time = acceleration_time time += time_speed(v, l - acceleration_distance) else: if time_to_v <= time_to_d: acceleration_time = time_to_v acceleration_distance = distance_travelled(0, acceleration_time, a) deceleration_time = time_accelerating(v, w, -a) deceleration_distance = distance_travelled(v, deceleration_time, -a) if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d: acceleration_time = time_accelerating(0, w, a) acceleration_distance = distance_travelled(0, acceleration_time, a) remaining_distance = d - acceleration_distance delta_time = time_distance(w, a, remaining_distance/2) time = acceleration_time + 2*delta_time else: time = time_to_v time += time_speed(v, d - deceleration_distance - acceleration_distance) time += deceleration_time acceleration_time = time_accelerating(w, v, a) acceleration_distance = distance_travelled(w, acceleration_time, a) if acceleration_distance >= l - d: time += time_distance(w, a, l - d) else: time += acceleration_time time += time_speed(v, l - (d + acceleration_distance)) sys.stdout.write('{0:.5f}'.format(time) + '\n') if __name__ == '__main__': main()",constant,"['implementation', 'math']",1783
"a,v=map(int,input().split()) l,d,w=map(int,input().split()) t=0 def gett(a,b,c): delta=b**2-4*a*c t1=(-b+delta**(1/2))/(2*a) t2=(-b-delta**(1/2))/(2*a) if min(t1,t2)>0: return min(t1,t2) else: return max(t1,t2) if 2*a*d<=w*w or v<=w: if 2*a*l<=v*v: t=(2*l/a)**(1/2) else: t=l/v+v/a/2 else: tmp=d-1/2*v*v/a+1/2*(v-w)**2/a-v*(v-w)/a if tmp<=0: tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a) if tmp2>=0: t=tmp2/v+(v-w)/a+2*gett(a,2*w,w*w/(2*a)-d)+w/a else: t=gett(a/2,w,d-l)+2*gett(a,2*w,w*w/(2*a)-d)+w/a else: tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a) if tmp2>=0: t=tmp2/v+(v-w)/a+(2*v-w)/a+tmp/v else: t=gett(a/2,w,d-l)+(2*v-w)/a+tmp/v print(""%.12f"" %(t))",constant,"['implementation', 'math']",637
"import math def getdt(): return map(int,input().split()) def calc(v0,v,a,x): t = (v - v0)/a x0 = v0 * t + 0.5*a*t*t if x0>=x: return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a) return (x0,t) def go(v0,v,a,x): x0,t = calc(v0,v,a,x) return t + (x-x0)/v a,v = getdt() l,d,w = getdt() if w>v: w = v x,t = calc(0,w,a,d) if x==d: print(go(0,v,a,l)) else: print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",constant,"['implementation', 'math']",389
"def func(u,v,a,l): if (v**2-u**2)>=2*a*l: return ((u**2+2*a*l)**(1/2)-u)/a else: t1=(v-u)/a t2=(l-(u*t1+a*t1*t1/2))/v return t1+t2 def efficient(v,a,w,d): if 2*v*v-w*w<=2*a*d: t1=v/a t2=(v-w)/a t3=(d-0.5*a*t1*t1-v*t2+0.5*a*t2*t2)/v return t1+t2+t3 else: bound=((2*a*d+w*w)/2)**0.5 t1=bound/a t2=(bound-w)/a t3=func(0,w,a,d) return t1+t2 return min(t1+t2,t3) def main(): string1=input() string2=input() arr1=string1.split("" "") arr2=string2.split("" "") a=int(arr1[0]) v=int(arr1[1]) l=int(arr2[0]) d=int(arr2[1]) w=int(arr2[2]) if 2*a*d<=w**2 or v<=w: t1=func(0,v,a,l) print(""%.8f""%(t1)) else: t1=efficient(v,a,w,d) t2=func(w,v,a,l-d) print(""%.8f""%(t1+t2)) main()",constant,"['implementation', 'math']",660
"from math import sqrt a, v = map(int, input().split()) l, d, w = map(int, input().split()) w = min(v, w) lowtime = (v - w) / a lowdist = v * lowtime - a * lowtime**2 / 2 startdist = v**2 / (2 * a) if startdist + lowdist <= d: ans = v / a + (d - startdist - lowdist) / v + lowtime elif w**2 <= 2 * d * a: u = sqrt(a * d + w**2 / 2) ans = (2 * u - w) / a else: ans = sqrt(2 * d / a) w = ans * a hightime = (v - w) / a highdist = w * hightime + a * hightime**2 / 2 if highdist <= l - d: ans += hightime + (l - d - highdist) / v else: disc = sqrt(w**2 + 2 * a * (l - d)) ans += (disc - w) / a print('%.7f' % ans)",constant,"['implementation', 'math']",608
"from math import sqrt def dist(speed, time): return speed * time + a * time**2 / 2 def travelTime(distance, speed): tAll = (- speed + sqrt(speed**2 + 2 * distance * a)) / a tMax = (v - speed) / a if tMax >= tAll: return tAll else: return tMax + (distance - dist(speed, tMax)) / v a, v = map(int, input().split()) l, d, w = map(int, input().split()) if v <= w: print(travelTime(l, 0)) else: tw = w / a dw = dist(0, tw) if dw >= d: print(travelTime(l, 0)) else: print(tw + 2 * travelTime((d - dw) / 2, w) + travelTime(l - d, w))",constant,"['implementation', 'math']",526
def f(n): return n + n//2 n = int(input()) print(f(n)),constant,"['math', 'number theory']",54
n = int(input()) print(3*(n//2)),constant,"['math', 'number theory']",32
"import sys def input(): return sys.stdin.readline().strip() def iinput(): return int(input()) def rinput(): return map(int, sys.stdin.readline().strip().split()) def get_list(): return list(map(int, sys.stdin.readline().strip().split())) n=iinput() print(3*n//2)",constant,"['math', 'number theory']",262
"x= int(input("""")) print(int((x/2)*3))",constant,"['math', 'number theory']",37
a = int(input()) print((a // 2) * 3),constant,"['math', 'number theory']",36
n = int(input()) print(3*n//2),constant,"['math', 'number theory']",30
n = int(input()) print(n//2+n),constant,"['math', 'number theory']",30
n=int(input()) g=n//2 print(g+n),constant,"['math', 'number theory']",32
n=int(input()) print(n+(n//2)),constant,"['math', 'number theory']",30
n = int(input()) print(int(3 * n / 2)),constant,"['math', 'number theory']",38
n = int(input()) print(int(3 * n / 2)),constant,"['math', 'number theory']",38
n=int(input()) a=(n//2)*3 print(a),constant,"['math', 'number theory']",34
if __name__ == '__main__': n = int(input()) num = n + n//2 print(num),constant,"['math', 'number theory']",69
n = int(input()) print(n + n // 2),constant,"['math', 'number theory']",34
n = int(input()) print((n*3)//2),constant,"['math', 'number theory']",32
n = int(input()) n = n + n//2 print(n),constant,"['math', 'number theory']",38
print(int(input())//2*3),constant,"['math', 'number theory']",24
i = int(input()) print(int(i/2) * 3),constant,"['math', 'number theory']",36
"def luck(n): if n % 4 == 0 or n % 7 == 0: return True while n > 0: tmp = n % 10 n = int(n / 10) if tmp != 4 and tmp != 7: return False return True def lucky(n): if luck(n): return ""YES"" for x in range(1, n + 1): if n % x == 0 and luck(x): return ""YES"" return ""NO"" n = int(input()) print(lucky(n))",constant,"['brute force', 'number theory']",296
"n = int(input()) lucky = [""1"",""2"",""3"",""5"",""6"",""8"",""9"",""0""] ye = False for i in range(1,n+1): luck=True for char in str(i): if char in lucky: luck = False break if luck == True and n % i == 0: print(""YES"") ye = True break else: continue if ye != True: print(""NO"")",constant,"['brute force', 'number theory']",262
"n = int(input()) m = ''.join(set(list(str(n)))) if m == '47' or m == '74' or m == '4' or m == '7': print('YES') else: if n %4 == 0 or n %7== 0 or n %74== 0 or n %47== 0: print('YES') else: print(""NO"")",constant,"['brute force', 'number theory']",200
"def check(num): l = list(str(num)) l = list(dict.fromkeys(l)) if l==['4', '7'] or l==['7', '4'] or l==['4'] or l==['7']: return True else: return False lucky = False n = int(input()) for i in range(3, n+1): if n%i==0 and check(i): lucky=True print(""YES"" if lucky else ""NO"")",constant,"['brute force', 'number theory']",273
"details=[4,7,44,77,444,777,47,74,447,774,474,747,477] n=int(input()) f=0 for i in details: if n%i==0: f=1 break if f: print(""YES"") else: print(""NO"")",constant,"['brute force', 'number theory']",148
"n = int(input()) print([""YES"", ""NO""][all(n % i for i in [4, 7, 47, 744, 477])])",constant,"['brute force', 'number theory']",79
"n=int(input()) l=[4,7,47,74,44,77,447,444,474,777,747,744,477] c=0 for i in range(len(l)): if n%l[i]==0: c=1 break if c==1: print(""YES"") else: print(""NO"")",constant,"['brute force', 'number theory']",154
"n = int(input()) l = [4,7,47,74,444,447,474,477,747,744,774,777] for i in l: if n % i == 0: print('YES') break else: pass else: print('NO')",constant,"['brute force', 'number theory']",139
"import math def islucky(x): digits = set(list(str(x))) return (len(digits) == 2 and (""4"" in digits and ""7"" in digits)) or (len(digits) == 1 and (""4"" in digits or ""7"" in digits)) a = int(input()) lucky = islucky(a) for i in range(2, math.ceil(math.sqrt(a))+1): if a % i == 0: if islucky(i) or islucky(a // i): lucky = True break print(""YES"" if lucky else ""NO"")",constant,"['brute force', 'number theory']",359
"a=int(input()) b=str(a) c=[] for i in range(2,a+1): if(a%i==0): c.append(i) l=0 for j in c: r=str(j) t=len(r) o=0 for p in r: if(p==""4"" or p==""7""): o=o+1 if(o==t): l=l+1 if(l>0): print(""YES"") else: print(""NO"")",constant,"['brute force', 'number theory']",209
"n = int(input()) k = set(""47"") p = False for i in range(1, n+1): if n%i == 0: if set(str(i)) <= k: p = bool(set(str(i))) break if p == True: print(""YES"") else: print(""NO"")",constant,"['brute force', 'number theory']",171
"n=int(input()) s=[4,7,44,77,47,74,444,777,477,447,744,474,747,774] t=0 for i in s: if n%i==0: print(""YES"") t=1 break if t==0: print(""NO"")",constant,"['brute force', 'number theory']",137
"import math def lucky(x): return (list(set(list(str(x)))) in [[""4""],[""7""],[""4"",""7""],[""7"",""4""]]) a = int(input()) true = False for i in range(1, math.ceil(math.sqrt(a))+1): if a % i == 0: if lucky(i) or lucky(a//i): true = True break print(""YES"" if true else ""NO"")",constant,"['brute force', 'number theory']",263
"n=int(input()) c=0 lst=[4,7,47,74,447,474,744,477,747,774] if n in lst: print(""YES"") else: for i in lst: if n%i==0: print(""YES"") c=c+1 break else: continue if c==0: print(""NO"")",constant,"['brute force', 'number theory']",176
"import itertools def q121a_v2(): good_num_arr = generate_47_arr() num = int(input()) for element in good_num_arr: if(num % element == 0): print(""YES"") return print(""NO"") def generate_47_arr(): arr = [] for digits in range(1, 4): arr += itertools.product(""47"", repeat=digits) for i in range(len(arr)): arr[i] = int("""".join(list(arr[i]))) arr.append(4444444444) return arr q121a_v2()",constant,"['brute force', 'number theory']",381
"def luckynumber(n): a=[] for i in range(4,n+1): r=i c=0 while(r>0): x=r%10 if x!=4 and x!=7: c=1 break r=r//10 if c==0: a.append(i) return a n=int(input()) a=luckynumber(n) for i in a: if n==i or n%i==0: print(""YES"") break else: print(""NO"")",constant,"['brute force', 'number theory']",240
"s=int(input()) t=len(str(s)) L=['4','7'] import copy for i in range(t): L1=copy.deepcopy(L) for m in L: L1.append(m+'4') L1.append(m+'7') L=L1 L0=list(map(int,L)) sum=0 for i in range(len(L0)): if s%L0[i]==0: sum=sum+1 if sum>0: print('YES') else: print('NO')",constant,"['brute force', 'number theory']",259
"n=int(input()) li=[] for i in range(1,n+1): if n%i==0: li.append(i) p=0 for t in li: l=[m for m in str(t)] if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}: p+=1 if p>0: print('YES') else: print('NO')",constant,"['brute force', 'number theory']",206
"s=int(input()) u=True for i in [4,7,47,74,447,474,477,747,774]: if s%i==0: u=False print(""YES"") break if u: print(""NO"")",constant,"['brute force', 'number theory']",119
"n = int(input()) print('0','0',n)",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",33
"n = int(input()) f0= 0 f1 = 1 li = [0,1] for i in range(45): t = f1 f1 += f0 f0 = t li.append(f1) x = [] for i in range(3): for i in range(len(li)-1, -1, -1): if li[i] <= n: n -= li[i] x.append(li[i]) break if n == 0: print(*x, sep = "" "") else: print(""I'm too stupid to solve this problem"")",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",290
"n = int(input()) print(0, 0, n)",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",31
"a = [0,1] n = int(input()) i=2 r=0 while r<n: r = a[i-1]+a[i-2] a.append(r) i+=1 l = len(a)-1 if n>3: print(a[l-4],a[l-3],a[l-1]) elif n==3: print(1,1,1) elif n==2: print(0,1,1) elif n==1: print(0,0,1) elif n==0: print(0,0,0)",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",225
"import sys,os,io,time,copy if os.path.exists('input.txt'): sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') import math def main(): n=int(input()) print(0,0,n) main()",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",189
"x = int(input()) print(0,0,x)",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",29
"n = int(input()) print(""0 0 {}"".format(n))",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",42
"n = int(input()) print(0, 0, n)",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",31
"print(0, 0, input())",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",20
"fib = [0]*100 fib[1] = 1 for i in range(2, 100): fib[i] = fib[i-1] + fib[i-2] n = int(input()) if (n in fib): if (n == 0): print(0, 0, 0) elif (n == 1): print(0, 0, 1) else: print(0, fib[fib.index(n)-2], fib[fib.index(n)-1]) else: print(""I'm too stupid to solve this problem"")",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",276
"n = int(input()) if n==0: print(*[0,0,0]) elif n==1: print(*[0,0,1]) else: prev2 = 0 prev1 = 1 prev = 1 while prev!=n: curr = prev+prev1 prev2 = prev1 prev1 = prev prev = curr print(*[0,prev2,prev1])",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",199
"n = int(input()) fib = [0,1] for x in range(1,200): z = fib[x] + fib[x-1] if z <= n: fib.append(z) else: break fib = fib[::-1] lis = [] for y in range(len(fib)): if fib[y] <= n: if (sum(lis) + fib[y]) <= n: if len(lis) < 3: lis.append(fib[y]) if sum(lis) == n: if len(lis) == 1: lis.append(0) lis.append(0) print(*lis) elif len(lis) == 2: lis.append(0) print(*lis) else: print(*lis) else: print(""I'm too stupid to solve this problem"")",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",434
"n=int(input()) print(""0"",""0"",n)",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",31
"import sys,math from collections import deque,defaultdict import operator as op from functools import reduce I=sys.stdin.readline def ii(): return int(I().strip()) def li(): return list(map(int,I().strip().split())) def mi(): return map(int,I().strip().split()) def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def gcd(x, y): while y: x, y = y, x % y return x def valid(row,col,rows,cols,rcross,lcross): return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0 def div(n): tmp=[] for i in range(2,int(n**.5)+1): if n%i==0: cnt=0 while(n%i==0): n=n//i cnt+=1 tmp.append((i,cnt)) if n>1: tmp.append((n,1)) return tmp def isPrime(n): if n<=1: return False elif n<=2: return True else: flag=True for i in range(2,int(n**.5)+1): if n%i==0: flag=False break return flag def s(b): ans=[] while b>0: tmp=b%10 ans.append(tmp) b=b//10 return ans def main(): n=ii() print(n,0,0) if __name__ == '__main__': main()",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",1019
"n = int(input()) if n == 0: print(0, 0, 0) else: a, b = 0, 1 while a + b != n: a, b = b, a + b print(0, a, b)",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",109
"ser = [0, 1] def fib(n): i = 1 while i < n: ser.append(i) i = ser[-1] + ser[-2] if i != n: return -1 else: return len(ser) n = int(input()) a, b, c = 0, 0, 0 ans = 1 if n == 0: ans = 1 elif n == 1: a = 1 elif n == 2: a = 1 b = 1 elif n == 3: a = 1 b = 1 c = 1 else: ans = fib(n) if ans != -1: a = ser[ans-2] b = ser[ans-2] c = ser[ans-3] if ans != -1: print(a, b, c) else: print(""I'm too stupid to solve this problem"")",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",418
"n = int(input()) print(n, 0, 0)",constant,"['brute force', 'constructive algorithms', 'implementation', 'number theory']",31
n=int(input()) if n<=2: print(n) else: if n%2!=0: print(n*(n-1)*(n-2)) elif n%3==0: print((n-1)*(n-2)*(n-3)) else: print(n*(n-1)*(n-3)),constant,['number theory'],135
n = int(input()) print(n if n < 3 else ((n - 1) * (n * (n - 2) if n & 1 else (n - 3) * (n if n % 3 else n - 2)))),constant,['number theory'],113
n=int(input()) if(n<3): print(n) else: if(n%2!=0): print(n*(n-1)*(n-2)) elif(n%3==0): print((n-1)*(n-2)*(n-3)) else: print(n*(n-1)*(n-3)),constant,['number theory'],137
"def gcd(a,b): if b==0: return a else: return gcd(b,a%b) if __name__ == ""__main__"": n = int(input()) ans = 0 if n==1: ans = 1 elif n==2: ans = 2 else: if n%2!=0: ans = n*(n-1)*(n-2) else: if gcd(n,(n-3)) ==1: ans = n*(n-1)*(n-3) else: ans = (n-1)*(n-2)*(n-3) print(ans)",constant,['number theory'],268
n=int(input()) if n<3: print(n) else: if n%2!=0: print(n*(n-1)*(n-2)) else: if n==6: print(60) elif n%3==0: print((n-1)*(n-2)*(n-3)) else: print(n*(n-1)*(n-3)),constant,['number theory'],159
n = int(input()) ans = 1 if n == 1: ans = 1 elif n == 2: ans = 2 elif n == 3: ans = 6 elif n%2 == 0: if n%3 == 0: ans = (n-1)*(n-2)*(n-3) else: ans = n*(n-1)*(n-3) else: ans = n*(n-1)*(n-2) print(ans),constant,['number theory'],200
def Solve(n): if n <=2: return n elif n % 6== 0: return (n -1)*(n -2)*(n - 3) elif n % 2 == 0: return n * (n - 1) * (n - 3) else: return n * (n - 1) * (n - 2) n = int(input()) print(Solve(n)),constant,['number theory'],191
n=int(input()) if n==1 or n==2 : print(n) elif n%2!=0 : m=n*(n-1)*(n-2) print(m) elif n%3!=0 : m=n*(n-1)*(n-3) print(m) else : m=(n-1)*(n-2)*(n-3) print(m),constant,['number theory'],155
"import math n=int(input()) if(n==4): print(12) elif(n<=2): print(n) else: if(n%2==0): a=n*(n-1)*(n-3) if(n%3==0): a=a//3 b=n*(n-1)*(n-2) b=b//2 print(max(a,b,(n-1)*(n-2)*(n-3))) else: print(n*(n-1)*(n-2))",constant,['number theory'],204
n = int(input()) ans = 0 if n==1: print(1) exit() if n==2: print(2) exit() if n==3: print(6) exit() if n%2==0: if n%3==0: ans=(n-1)*(n-2)*(n-3) else: ans=n*(n-1)*(n-3) else: ans=n*(n-1)*(n-2) print(ans),constant,['number theory'],202
"def NOD(a, b): while b != 0: a %= b y = a a = b b = y return(a) def NOK(a, b): i = (a*b) // NOD(a, b) return(i) n = int(input()) maxnok = 0 x = 40 for i in range(max(1, n-x), n+1): for j in range(max(1, i-x), i+1): for f in range(max(1, j-x), j+1): nokk = NOK(NOK(i,j), f) if maxnok < nokk: maxnok = nokk delit = [] delit.append(i) delit.append(j) delit.append(f) print(maxnok)",constant,['number theory'],377
"import math n = int(input()) m = 0 for i in range(min(100,n)): for ii in range(min(100,n)): for iii in range(min(100,n)): i1 = n-i ii1 = n-ii iii1 = n-iii r1 = (i1*ii1)//math.gcd(i1,ii1) r2 = (r1*iii1)//math.gcd(iii1,r1) m = max(m,r2) print(m)",constant,['number theory'],243
"import sys from functools import lru_cache, cmp_to_key from heapq import merge, heapify, heappop, heappush from math import * from collections import defaultdict as dd, deque, Counter as C from itertools import combinations as comb, permutations as perm from bisect import bisect_left as bl, bisect_right as br, bisect from time import perf_counter from fractions import Fraction import copy import time starttime = time.time() mod = int(pow(10, 9) + 7) mod2 = 998244353 def data(): return sys.stdin.readline().strip() def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end) def L(): return list(sp()) def sl(): return list(ssp()) def sp(): return map(int, data().split()) def ssp(): return map(str, data().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)] try: sys.stdin = open(""input.txt"", ""r"") except: pass def pmat(A): for ele in A: print(*ele,end=""\n"") x=L()[0] if x<=2: print(x) exit() if x%2: n=x lcm=n*(n-1)//gcd(n,n-1) lcm=lcm*(n-2)//gcd(lcm,n-2) print(lcm) else: ans=1 for n1 in range(max(1,x-50),x+1): for n2 in range(max(1,x-50),x+1): for n3 in range(max(1,x-50),x+1): lcm=(n1*n2)//(gcd(n1,n2)) lcm=(lcm*n3)//gcd(lcm,n3) ans=max(ans,lcm) print(ans) endtime = time.time()",constant,['number theory'],1267
n=int(input()) if(n<3): print(n) exit(0) if n%2==1: print(n*(n-1)*(n-2)) else: g=0; if n%3==0: g=n-2 else:g=n; print((n-1)*(n-3)*(g)),constant,['number theory'],133
"n = int(input("""")) if n==1 or n==2: print(n) elif n&1: print((n)*(n-1)*(n-2)) else: if n%3==0: print((n-2)*(n-1)*(n-3)) else : print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3),(n*(n-1)*(n-2))/2))",constant,['number theory'],189
"'' import math def check(n): if n==1: return 1 if n==2: return 2 if n==3: return 6 if n&1: return ((n-1)*(n-2)*(n)) if math.gcd(n,n-3)==1: return (n*(n-1)*(n-3)) else: return ((n-1)*(n-2)*(n-3)) n =int(input()) print(check(n))",constant,['number theory'],226
"for _ in range(int(input())): a, b = map(int, input().split()) result = 0 while min(a, b)!=0: x = max(a, b) y = min(a, b) a = x b = y result+=a//b a%=b print(result)",constant,"['math', 'number theory']",165
"for _ in range(int(input())): a,b = map(int, input().split()) c = 0 while (a!=0 and b!=0): if (a>b) : c+= a//b a = a%b elif (b>a): c+= b//a b = b%a else : c+=1 break print(c)",constant,"['math', 'number theory']",174
"def f(a, b): global ans maks = max(a, b) mins = min(a, b) ans += (maks//mins) if (mins == 1): return ans else: if (maks % mins == 0): return ans else: return f(maks%mins, mins) for i in range(int(input())): a, b = list(map(int, input().split())) ans = 0 print(f(a, b))",constant,"['math', 'number theory']",268
"for _ in range(int(input())): n,m = sorted(map(int,input().split())) count = 0 while n> 0: count+= m//n m = m%n n,m = sorted([n,m]) print(count)",constant,"['math', 'number theory']",144
"def solve(a, b): m = max(a, b) n = min(a, b) if n == 0: return 0 if m == n: return 1 elif m % n == 0: return m // n k = m // n return k + solve(n, m - n * k) for _ in range(int(input())): a, b = map(int, input().split()) print(solve(a, b))",constant,"['math', 'number theory']",239
"for x in range(int(input())): a,b = map(int,input().split()) if a > b or a == b:c,d = a,b else:c,d = b,a e = [0] def fun(c,d): e[0] += c // d f = d d = c % d c = f if f > 0 and d > 0: fun(c,d) fun(c,d) print(e[0])",constant,"['math', 'number theory']",213
"from sys import stdin def read_lines(sep=' ', input_type=None): _lines = stdin.readlines() cast = input_type is not None lines = [] for line in _lines: line = line[:-1].split(sep) if cast: line = [input_type(x) for x in line] lines.append(line) return lines import collections def numz(a,b): if a and b: if b > a: a,b=b,a d,m = divmod(a,b) return d + numz(b,m) else: return 0 if __name__ == '__main__': lines = read_lines(input_type=int) lines = lines[1:] for line in lines: print(numz(*line))",constant,"['math', 'number theory']",493
t = int(input()) ans = '' for j in range(t): ab = input().split() a = int(ab[0]) b = int(ab[1]) k = 0 while a > 0 and b > 0: if a >= b: k += a // b a %= b else: k += (b // a) b %= a ans += str(k) + '\n' print(ans),constant,"['math', 'number theory']",213
"import math n=int(input()) for _ in range(n): a,b=map(int,input().split()) ans=0 while a>0 and b>0: if a>=b: ans+=a//b a=a%b else: ans+=b//a b=b%a print(ans)",constant,"['math', 'number theory']",157
"for _ in range(int(input())): a,b=map(int,input().split()) ans=int(0) while a and b: a,b=min(a,b),max(a,b) ans,b=ans+b//a,b%a print(ans)",constant,"['math', 'number theory']",136
"def max1(a,b): if a>=b: return a,b else: return b,a def minus(a,b): p=a//b cnt=p return b,(a-(b*cnt)),cnt n=int(input()) for _ in range(n): a,b=input().split() a=int(a) b=int(b) cnt=0 while a>0 and b>0: a,b=max1(a,b) a,b,p=minus(a,b) cnt+=p print(cnt)",constant,"['math', 'number theory']",251
"n=input() n1=int(n) c=[] for i in range(0,n1): z4=0 p,q=input().split() a=int(p) b=int(q) while a!=0 and b!=0: z1=z3=0 if a<=b: z=(b/a) z1=int(z) b=b-(z1*a) if b<=a and b!=0: z2=a/b z3=int(z2) a=a-(z3*b) z4=z4+z1+z3 c.append(z4) l=len(c) for j in range(0,l): print(c[j])",constant,"['math', 'number theory']",270
"def substraction(a,b): if a==0 or b==0: return 0 else: if a>b: count=a//b return substraction(a%b,b)+count else: count = b//a return substraction(a,b%a)+count t=int(input()) lst=[] res=[] for i in range(0,t): lst=[int(i) for i in input().split()] ele=substraction(lst[0],lst[1]) res.append(ele) for i in range(0,t): print(res[i])",constant,"['math', 'number theory']",329
"import sys if __name__=='__main__': numCases = int(sys.stdin.readline()) for i in range(numCases): a, b = sys.stdin.readline().split() a = int(a) b = int(b) total = 0 largerNum = max(a,b) smallerNum = min(a,b) while True: div = int(largerNum/smallerNum) total += div rem = int(largerNum%(smallerNum*div)) if rem == 0: break else: largerNum = smallerNum smallerNum = rem print(total)",constant,"['math', 'number theory']",382
"def operations(a, b): less = min(a, b) more = max(a, b) ops = 0 while less > 0 and more > 0: ops += more // less more -= less * (more // less) less, more = more, less return ops n = int(input()) for i in range(n): a, b = map(int, input().split()) print(operations(a, b))",constant,"['math', 'number theory']",270
"import sys def num_ops(low, high): if high % low == 0: return high // low else: return (high // low) + num_ops(high % low, low) def main(): n = int(sys.stdin.readline().strip()) for _ in range(n): low, high = [int(i) for i in sys.stdin.readline().strip().split()] print(num_ops(low, high)) if __name__ == '__main__': main()",constant,"['math', 'number theory']",323
"n=int(input()) for i in range(n): a,b = map( int, input().split() ) if a>b: a,b=b,a ans=0 while a>0: ans+=b//a b%=a a,b=b,a print(ans)",constant,"['math', 'number theory']",134
"cases = int(input()) while cases: cases -= 1 a, b = map(int, input().split()) ans = 0 while a > 0 and b > 0: if a < b: a, b = b, a ans += a//b a = a % b print(ans)",constant,"['math', 'number theory']",163
"from collections import Counter import copy def solve(): a,b=list(map(int,input().split())) count=0 if a==b: return 1 while a!=0 and b!=0: if a<b: count+=(b//a) b-=a*(b//a) else: count+=a//b a-=b*(a//b) return count for i in range(int(input())): print(solve())",constant,"['math', 'number theory']",260
n = int(input()) if n > 0: print(n) else: n = n * -1 x = n % 10 y = (n // 10) % 10 if x > y: print(-(n // 10)) else: print(-((n // 100)* 10 + x)),constant,"['implementation', 'number theory']",145
"from collections import defaultdict import bisect from itertools import accumulate, count import os import sys import math from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def input(): return sys.stdin.readline().rstrip(""\r\n"") s=input() neg=0 if int(s)<0: neg=1 ans1 = """" s=int(s) s=abs(s) s=str(s) ans2 = """" for i in range(0, len(s)): if i == len(s)-2: ans1 += s[i] elif i == len(s)-1: ans2 += s[i] else: ans1 += s[i] ans2 += s[i] if neg==0: print(s) else: if str(min(int(ans1), int(ans2)))==""0"": print(0) else: print(""-""+str(min(int(ans1), int(ans2))))",constant,"['implementation', 'number theory']",1830
"n=input();print(max(map(int,(n,n[:-1],n[:-2]+n[-1]))))",constant,"['implementation', 'number theory']",54
"n=int(input()) if n>-1: print(n) else: n=str(n) x=int(n[:len(n)-1]) y=int(n[:len(n)-2]+n[-1]) print(max(x,y))",constant,"['implementation', 'number theory']",109
"import math n = int(input()) if n>0: print(n) else: l = list(str(n)) last = l[0:len(l)-1] second = l[0:len(l)-2] second+=l[-1] lR = """".join(last) sR = """".join(second) print(max(eval(lR),eval(sR)))",constant,"['implementation', 'number theory']",196
"n=int(input()) if n >= 0: print(n) else: a = int(n / 10) b=int(n/100)*10 - abs(n)%10 print(max(a,b))",constant,"['implementation', 'number theory']",100
n = int(input()) if(n>=0): print(n) exit() else: n=str(abs(n)) n1=int(n[:len(n)-1]) temp=n[len(n)-1] n2=n[:len(n)-2] n2=int(n2+temp) if(n1<=n2): if(n1!=0): print('-'+str(n1)) else: print(0) else: if(n2!=0): print('-'+str(n2)) else: print(0),constant,"['implementation', 'number theory']",240
"s=input() n=len(s) if(s[0]=='-'): if(s[n-1]<s[n-2]): s=s[::-1] s=s.replace(s[1],"""",1) s=s[::-1] else: s=s[::-1] s=s.replace(s[0],"""",1) s=s[::-1] if(s==""-0""): print(""0"") else: print(s) else: print(s)",constant,"['implementation', 'number theory']",198
n=int(input()) l=list(str(n)) if n>=0: print(n) else: if int(l[-1])>int(l[-2]): l.pop(-1) else: l.pop(-2) print(int(''.join(l))),constant,"['implementation', 'number theory']",128
"n=int(input()) a=str(n) m=len(a) b=int(a[0:m-1]) c=int(a[0:m-2]+a[-1]) d=max(n,b,c) print(d)",constant,"['implementation', 'number theory']",92
"r=input() t1=int(r) t2=int(r[:len(r)-1]) t3=int(r[:len(r)-2]+r[-1]) print(max(t1,t2,t3))",constant,"['implementation', 'number theory']",88
"n=int(input()) if n>=0: print(n) else: a=str(n) a=a[1::] if len(a)>2: a=a[::-1][1::][::-1] num1=int(a) a=str(n) a=a[1::] b=a[::-1] p1=b[0] p2=b[2::] p=p1+p2 p=p[::-1] num2=int(p) small=min(num1,num2) print(-1*small) elif len(a)==2: m=a[0] n=a[1] small=min(int(m),int(n)) print(-1*small)",constant,"['implementation', 'number theory']",286
"n=int(input()) if(n>=0): print(n) else: n=abs(n) rem=n%10 n1=n//10 n2=n1//10 n2=n2*10+rem k=min(n1,n2) print(-1*k)",constant,"['implementation', 'number theory']",114
"n=int(input()) m=str(n) print(max(int(m),int(m[:-2]+m[-1:]),int(m[:-1])))",constant,"['implementation', 'number theory']",73
"s = input() if int(s) < 0: k = int(s)/10 m = s[:len(s)-2]+s[-1] print(max(int(k),int(m))) else: print(s)",constant,"['implementation', 'number theory']",104
money=input() initi=money if int(money)<0: lst_dig=money[-1] lsec_dig=money[-2] if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-2] else:money=money[:-2]+money[-1] print(int(money)) else: lst_dig=money[-1] lsec_dig=money[-2] if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-1] else:money=money[:-2]+money[-2] if int(initi)>=int(money): print(initi) else: print(money),constant,"['implementation', 'number theory']",377
"n=input() if int(n)>0: print(n) elif -9<=int(n)<=0: print(0) else: a=(-int(n))//10 b=((-int(n))//100)*10+int(n[-1]) print(max(-a,-b))",constant,"['implementation', 'number theory']",133
n=int(input()) if(n>=0): print(n) else: if((n*-1)//10==0): print(0) else: n*=-1 y=n//10 z=n%10 x=y//10 x*=10; x+=z; x*=-1 y*=-1 if(x>=y): print(x) else: print(y),constant,"['implementation', 'number theory']",161
a=int(input()) if a>0: print(a) else: a=a-2*a k=a//10 b=a%10 c=(a//100)*10+b if k<c: if k!=0: print('-%d' %k) else: print(k) else: if c!=0: print('-%d' %c) else: print(c),constant,"['implementation', 'number theory']",170
"n,m=map(int,input().split()) a=0 while m:a+=n//m;n,m=m,n%m print(a)",constant,"['math', 'number theory']",67
"def resistors(a,b): ans=0 while b: ans+=a//b a,b=b,a%b return ans a,b=map(int,input().strip().split()) print(resistors(a,b))",constant,"['math', 'number theory']",124
"import sys from functools import lru_cache, cmp_to_key from heapq import merge, heapify, heappop, heappush from math import * from collections import defaultdict as dd, deque, Counter as C from itertools import combinations as comb, permutations as perm from bisect import bisect_left as bl, bisect_right as br, bisect from time import perf_counter from fractions import Fraction import copy import time starttime = time.time() mod = int(pow(10, 9) + 7) mod2 = 998244353 def data(): return sys.stdin.readline().strip() def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end) def L(): return list(sp()) def sl(): return list(ssp()) def sp(): return map(int, data().split()) def ssp(): return map(str, data().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)] try: sys.stdin = open(""input.txt"", ""r"") except: pass def pmat(A): for ele in A: print(*ele,end=""\n"") def seive(): prime=[1 for i in range(10**6+1)] prime[0]=0 prime[1]=0 for i in range(10**6+1): if(prime[i]): for j in range(2*i,10**6+1,i): prime[j]=0 return prime a,b=L() def rec(a,b): if b==1: return a if a>b: return a//b+rec(b,a%b) else: return rec(b,a) print(rec(a,b)) endtime = time.time()",constant,"['math', 'number theory']",1236
"a,b = map(int,input().split()) ans = 0 if(a > b): ans += int(a//b) a = a%b while(b!=0): ans += int(a//b) a,b = b,a%b print(ans)",constant,"['math', 'number theory']",127
"a,b=map(int,input().split()) ans=0 while a and b: ans+=a//b a,b=b,a%b print(ans)",constant,"['math', 'number theory']",80
"n, m = map(int, input().split()) s = 0 while m: s += n // m n, m = m, n % m print(s)",constant,"['math', 'number theory']",84
"import math a, b = map(int, input().split()) if a % b == 0: print(int(a/b)) else: c = 0 while b: c += a//b temp = a a = b b = temp % b print(c)",constant,"['math', 'number theory']",143
"a, b = map(int, input().split(' ')) res = 0 temp = 0 if a%b == 0: print(int(a/b)) else: while b!=0: res += a//b a%=b temp = a a = b b = temp print(res)",constant,"['math', 'number theory']",151
"n, m = map(int, input().split()) a = 0 while m: a += n//m n, m = m, n % m print(a)",constant,"['math', 'number theory']",82
"from sys import stdin,stdout,setrecursionlimit stdin.readline def mp(): return list(map(int, stdin.readline().strip().split())) def it():return int(stdin.readline().strip()) from collections import defaultdict as dd,Counter as C,deque from math import ceil,gcd,sqrt,factorial,log2,floor from bisect import bisect_right as br,bisect_left as bl import heapq def solve(a,b): if a == 0: return 0 return b//a + solve(b%a,a) print(solve(*mp()))",constant,"['math', 'number theory']",438
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest INF=999999999999999999999999 alphabets=""abcdefghijklmnopqrstuvwxyz"" class SortedList: def __init__(self, iterable=[], _load=200): values = sorted(iterable) self._len = _len = len(values) self._load = _load self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)] self._list_lens = [len(_list) for _list in _lists] self._mins = [_list[0] for _list in _lists] self._fen_tree = [] self._rebuild = True def _fen_build(self): self._fen_tree[:] = self._list_lens _fen_tree = self._fen_tree for i in range(len(_fen_tree)): if i | i + 1 < len(_fen_tree): _fen_tree[i | i + 1] += _fen_tree[i] self._rebuild = False def _fen_update(self, index, value): if not self._rebuild: _fen_tree = self._fen_tree while index < len(_fen_tree): _fen_tree[index] += value index |= index + 1 def _fen_query(self, end): if self._rebuild: self._fen_build() _fen_tree = self._fen_tree x = 0 while end: x += _fen_tree[end - 1] end &= end - 1 return x def _fen_findkth(self, k): _list_lens = self._list_lens if k < _list_lens[0]: return 0, k if k >= self._len - _list_lens[-1]: return len(_list_lens) - 1, k + _list_lens[-1] - self._len if self._rebuild: self._fen_build() _fen_tree = self._fen_tree idx = -1 for d in reversed(range(len(_fen_tree).bit_length())): right_idx = idx + (1 << d) if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]: idx = right_idx k -= _fen_",constant,"['math', 'number theory']",2000
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest INF=999999999999999999999999 alphabets=""abcdefghijklmnopqrstuvwxyz"" class SortedList: def __init__(self, iterable=[], _load=200): values = sorted(iterable) self._len = _len = len(values) self._load = _load self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)] self._list_lens = [len(_list) for _list in _lists] self._mins = [_list[0] for _list in _lists] self._fen_tree = [] self._rebuild = True def _fen_build(self): self._fen_tree[:] = self._list_lens _fen_tree = self._fen_tree for i in range(len(_fen_tree)): if i | i + 1 < len(_fen_tree): _fen_tree[i | i + 1] += _fen_tree[i] self._rebuild = False def _fen_update(self, index, value): if not self._rebuild: _fen_tree = self._fen_tree while index < len(_fen_tree): _fen_tree[index] += value index |= index + 1 def _fen_query(self, end): if self._rebuild: self._fen_build() _fen_tree = self._fen_tree x = 0 while end: x += _fen_tree[end - 1] end &= end - 1 return x def _fen_findkth(self, k): _list_lens = self._list_lens if k < _list_lens[0]: return 0, k if k >= self._len - _list_lens[-1]: return len(_list_lens) - 1, k + _list_lens[-1] - self._len if self._rebuild: self._fen_build() _fen_tree = self._fen_tree idx = -1 for d in reversed(range(len(_fen_tree).bit_length())): right_idx = idx + (1 << d) if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]: idx = right_idx k -= _fen_",constant,"['math', 'number theory']",2000
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest INF=999999999999999999999999 alphabets=""abcdefghijklmnopqrstuvwxyz"" class SortedList: def __init__(self, iterable=[], _load=200): values = sorted(iterable) self._len = _len = len(values) self._load = _load self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)] self._list_lens = [len(_list) for _list in _lists] self._mins = [_list[0] for _list in _lists] self._fen_tree = [] self._rebuild = True def _fen_build(self): self._fen_tree[:] = self._list_lens _fen_tree = self._fen_tree for i in range(len(_fen_tree)): if i | i + 1 < len(_fen_tree): _fen_tree[i | i + 1] += _fen_tree[i] self._rebuild = False def _fen_update(self, index, value): if not self._rebuild: _fen_tree = self._fen_tree while index < len(_fen_tree): _fen_tree[index] += value index |= index + 1 def _fen_query(self, end): if self._rebuild: self._fen_build() _fen_tree = self._fen_tree x = 0 while end: x += _fen_tree[end - 1] end &= end - 1 return x def _fen_findkth(self, k): _list_lens = self._list_lens if k < _list_lens[0]: return 0, k if k >= self._len - _list_lens[-1]: return len(_list_lens) - 1, k + _list_lens[-1] - self._len if self._rebuild: self._fen_build() _fen_tree = self._fen_tree idx = -1 for d in reversed(range(len(_fen_tree).bit_length())): right_idx = idx + (1 << d) if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]: idx = right_idx k -= _fen_",constant,"['math', 'number theory']",2000
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def input(): return sys.stdin.readline().rstrip(""\r\n"") def getint(): return int(input()) def getints(): return list(map(int, input().split())) def getint1(): return list(map(lambda x: int(x) - 1, input().split())) def main(): a,b = getints() print(result(a,b)) def result(a,b): if a==0 or b==0: return 0 if a>b: return a//b+result(a%b,b) else: return b//a+result(b%a,a) if __name__ == ""__main__"": main()",constant,"['math', 'number theory']",1749
"def prime(n): if n < 2: return False elif n % 2 == 0 and n != 2: return False for j in range(3, int(pow(n, 0.5) + 1), 2): if n % j == 0: return False return True n = int(input()) for j in range(2, int(n / 2) + 1): if prime(j) == False and prime(n - j) == False: print(j, n - j) break",constant,"['math', 'number theory']",283
"def primecheck(x): cnt=0 for i in range(2,x//2 +1): if x%i == 0: cnt+=1 break if cnt : return 1 else: return 0 n = int(input()) for i in range(4,n): if primecheck(i) == 1 and primecheck(n-i) == 1: print(str(i) + "" ""+ str(n-i)) break",constant,"['math', 'number theory']",232
"import sys def is_prime(x): return all(x%i for i in range(2, int(x**.5)+1)) t = int(sys.stdin.read().strip()) for i in range(4, t//2+1): if not is_prime(i) and not is_prime(t-i): print(i, t-i, sep=' ') break",constant,"['math', 'number theory']",207
"import bisect import collections import copy import functools import heapq import itertools import math import random import re import sys import time import string from time import time_ns from typing import List sys.setrecursionlimit(99999) def II():return int(sys.stdin.readline().strip()) def IIs():return list(map(int,sys.stdin.readline().strip().split())) def SI():return sys.stdin.readline().strip() n=II() if n&1: print(9,n-9) else: print(8,n-8)",constant,"['math', 'number theory']",453
n=int(input()) print('4 %s'%(n-4) if n%2==0 else '9 %s'%(n-9)),constant,"['math', 'number theory']",62
"def is_prime(num): if num > 1: for i in range(2, num): if (num % i) == 0: return False else: return True else: return False n = int(input()) temp = 0 first = 0 second = 0 if n % 2 == 0: temp = int(n/2) first = temp second = n - temp while is_prime(first) or is_prime(second): first -= 1 second += 1 if first + second == n and (not is_prime(first) and not is_prime(second)): break else: temp = int(n / 2) first = temp second = n - first while is_prime(first) or is_prime(second): first -= 1 second += 1 if first + second == n and (not is_prime(first) and not is_prime(second)): break print(first,end="" "") print(second)",constant,"['math', 'number theory']",617
"i=int(input()) d=i%2+8;print(d,i-d)",constant,"['math', 'number theory']",35
"n=int(input()); if n % 2 == 0: print((n-4),"" 4"") else: print((n-9),"" 9"")",constant,"['math', 'number theory']",72
"def isPrime(n): for i in range(2,int(n**0.5)+1): if n%i==0: return False n=int(input());d=0 if n%2==0: print('4 '+str(n-4)) else: i=4 while i<=int(n//2)+1: k=n-i if isPrime(k)==False: print(str(i)+' '+str(k)) break i+=2",constant,"['math', 'number theory']",219
n=int(input());print('4 '+str(n-4) if n%2==0 else '9 '+str(n-9)),constant,"['math', 'number theory']",64
"n=int(input()) if n%2==0: print(4,n-4) else: print(9,n-9)",constant,"['math', 'number theory']",57
"n = int(input()) if n % 2 == 0 : print(4 , n - 4) else: print(9 , n - 9)",constant,"['math', 'number theory']",72
"n = int(input()) if n%2==0: a = n - 8 print(a,8) else: a = n-9 print(a,9)",constant,"['math', 'number theory']",73
"from math import * n = int(input()) if n%2==0: print(n-8,n-(n-8)) else: print((n-9),n-(n-9))",constant,"['math', 'number theory']",92
"def Is_prime(n): for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True n = int(input()) for i in range(2, 100): if not Is_prime(i) and not Is_prime(n - i): print(i, n - i) break",constant,"['math', 'number theory']",201
"def iscomposite(value): for i in range(2,value): if(value%i==0): return '1' else: return '0' n=int(input()) for i in range(4,n): a=i b=n-i if(iscomposite(a)=='1' and iscomposite(b)=='1'): print(a,b) break else: continue",constant,"['math', 'number theory']",219
"k = 1000001 a = [True] * k a[0] = a[1] = False for i in range(k): if a[i]: j = 2 * i while j < k: a[j] = False j += i n = int(input()) for i in range(4, n): if not a[i] and not a[n-i]: print(i, n-i) exit()",constant,"['math', 'number theory']",205
"k = 1000001 a = [True] * k a[0] = a[1] = False for i in range(k): if a[i]: for j in range(2*i, k, i): a[j] = False n = int(input()) for i in range(4, n): if not a[i] and not a[n-i]: print(i, n-i) exit()",constant,"['math', 'number theory']",202
"def resheto(a): numbers = list(range(0, a + 1)) primes = set() for k in range(2, a + 1): if numbers[k] != 0: primes.add(k) for j in range(2 * k, a + 1, k): numbers[j] = 0 return primes all_primes = resheto(10**6) n = int(input()) for i in range(2, n): if i not in all_primes and (n - i) not in all_primes: print(i, n - i) break",constant,"['math', 'number theory']",327
"l,r=map(int,input().split()) j=r-l+1 if j==3: if l%2==0: print(l,l+1,l+2) else: print(-1) elif j>3: if l%2==0:print(l,l+1,l+2) else:print(l+1,l+2,l+3) else:print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",165
"l,r=map(int,input().split()) j=r-l+1 if j==3: if l%2==0: print(l,l+1,l+2) else: print(-1) elif j>3: if l%2==0:print(l,l+1,l+2) else:print(l+1,l+2,l+3) else:print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",165
"l,r = list(map(int,input().split())) f = 0 def gcd(a,b): if b == 0: return a return gcd(b,a%b) for a in range(l,r+1): for b in range(a+1,r+1): for c in range(b+1,r+1): if (gcd(a,b) == 1) and (gcd(b,c) == 1) and (gcd(a,c)!=1): print(a,b,c) f = 1 break if f == 1: break if f == 1: break else: print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",300
"import sys input = sys.stdin.readline x,y = map(int, input().split()) if y-x<2: print(-1) elif x%2 != 0 and y-x==2: print(-1) elif x%2==0: print(x, x+1, x+2) else: print(x+1, x+2, x+3)",constant,"['brute force', 'implementation', 'math', 'number theory']",184
"x,y=map(int,input().strip().split()) if(abs(x-y)<2): print(-1) else: k=[] for i in range(x,y+1): if(i%2==0): k.append(i) if(i+1<y): k.append(i+1) k.append(i+2) break if(len(k)==3): print("" "".join(str(t) for t in k)) else: print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",231
"l, r = map(int, input().split()) if r - l + 1 < 3: print(-1) exit() if l % 2 == 0: print(l, l+1, l+2) exit() if r - l + 1 > 3: print(l+1, l+2, l+3) exit() print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",164
"import sys, collections, math, itertools, random, bisect INF = sys.maxsize def get_ints(): return map(int, sys.stdin.readline().strip().split()) def get_array(): return list(map(int, sys.stdin.readline().strip().split())) def input(): return sys.stdin.readline().strip() mod = 1000000007 l,r = get_ints() if r-l < 2: print(-1) elif l%2 == 0: print(l, l+1, l+2) elif r-l > 2: print(l+1, l+2, l+3) else: print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",411
"import os import sys from io import BytesIO, IOBase import math as M import itertools as ITR from collections import defaultdict as D from collections import Counter as C from collections import deque as Q import threading from functools import lru_cache, reduce from functools import cmp_to_key as CMP from bisect import bisect_left as BL from bisect import bisect_right as BR import random as R import string import cmath, time enum = enumerate start_time = time.time() MOD = 1_00_00_00_007 MA = float(""inf"") MI = float(""-inf"") di8 = ((1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)) di4 = ((1, 0), (0, 1), (-1, 0), (0, -1)) def increase_stack(): sys.setrecursionlimit(2 ** 32 // 2 - 1) threading.stack_size(1 << 27) def binary(n): return bin(n)[2:] def decimal(s): return int(s, 2) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return p def maxfactor(n): q = [] for i in range(1, int(n ** 0.5) + 1): if n % i == 0: q.append(i) if q: return q[-1] def factors(n): q = [] for i in range(1, int(n ** 0.5) + 1): if n % i == 0: q.append(i) q.append(n // i) return list(sorted(list(set(q)))) def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3, int(M.sqrt(n)) + 1, 2): while n % i == 0: l.append(i) n = n / i if n > 2: l.append(int(n)) l.sort() return l def isPrime(n): if n == 1: return False else: root = int(n ** 0.5) root += 1 for i in range(2, root): if n % i == 0: return False return True def seive(n): a = [] prime = [True for i in range(n + 1)] p = 2 while p * p <= n: if prime[p] == True: for i in range(p ** 2, n + 1, p): prime[i] = False p = p + 1 for p in range(2, n + 1): if prime[p]: a.append(p) prime[0] = prime[1] = False return a, prime def maxPrimeFactors(n): maxPrime = -1 while n % 2 == 0: maxPrime = 2 n >>= 1 for i in range(3, int(M.sqrt(n)) + 1, 2): while n % i == 0: maxPrime = i n = n / i if n > 2: maxPrime = n return int(maxPrime) def countchar(s, i): c = 0 ch = s[i] for i in range(i, len(s)): if s[i] == ch: c += 1 els",constant,"['brute force', 'implementation', 'math', 'number theory']",1999
"l,r = map(int,input().split()) if l%2: l+=1 if r-l<2: print(-1) else: print(l,l+1,l+2)",constant,"['brute force', 'implementation', 'math', 'number theory']",86
"l,r=map(int,input().split(' ')) def gcd(a ,b): if(b==0):return a return gcd(b,a%b) for a in range(l,r+1): for b in range(a+1,r+1): for c in range(b+1,r+1): if(gcd(a,b)==1 and gcd(b,c)==1 and gcd(a,c)!=1): print(a,b,c) exit() print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",234
"l,r=map(int,input().split()) if(l%2==0 and r-l>1): print(l,l+1,l+2,end="" "") elif(l%2!=0 and r-l>2): print(l+1,l+2,l+3,end="" "") else: print(""-1"")",constant,"['brute force', 'implementation', 'math', 'number theory']",144
"l,r=input().split("" "") l,r=int(l),int(r) if (l % 2 != 0): l+=1 if (l + 2 > r): print(-1); else: print(l,l+1,l+2)",constant,"['brute force', 'implementation', 'math', 'number theory']",112
"l,r=input().split("" "") l,r=int(l),int(r) a,b,c=l,l+1,l+2 if (l % 2 != 0): a,b,c=a+1,b+1,c+1 if (c > r): print(-1) else: print(a,b,c)",constant,"['brute force', 'implementation', 'math', 'number theory']",132
"from math import gcd import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def func(l,r): if l==1: l+=1 if r-l<2: return -1 if l&1: if r-l>2: l+=1 return '{} {} {}'.format(l,l+1,l+2) else: if gcd(l,l+2)!=1: return '{} {} {}'.format(l,l+1,l+2) return -1 return '{} {} {}'.format(l, l + 1, l + 2) def main(): l,r=map(int,input().split()) print(func(l,r)) return if __name__ == '__main__': main()",constant,"['brute force', 'implementation', 'math', 'number theory']",1736
"from math import gcd import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""right"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\right\n"") def func(left:int, right:int): if left == 1: left += 1 if right - left < 2: return -1 if left & 1: if right - left > 2: left += 1 return '{} {} {}'.format(left, left + 1, left + 2) else: if gcd(left, left + 2) != 1: return '{} {} {}'.format(left, left + 1, left + 2) return -1 return '{} {} {}'.format(left, left + 1, left + 2) def main(): left, right = map(int, input().split()) print(func(left, right)) return if __name__ == '__main__': main()",constant,"['brute force', 'implementation', 'math', 'number theory']",1871
"import math l, r = (map(int, input().split())) a = l if a % 2: a += 1 if a + 2 > r: print(-1) else: print(a, a + 1, a + 2)",constant,"['brute force', 'implementation', 'math', 'number theory']",122
"a,b=map(int,input().split()) if max(a,b)-min(a,b) +1<=2: print(-1) elif max(a,b)-min(a,b) +1==3: if a % 2==1 and b %2==1: print(-1) else: print(min(a,b),min(a,b)+1,min(a,b)+2) else: ans=0 for i in range(a,b+1): if i%2==0: ans=i break print(ans,ans+1,ans+2)",constant,"['brute force', 'implementation', 'math', 'number theory']",256
"l,r = [int(x) for x in input().split()] if l==r or l+1==r: print(-1) elif l%2==0: print(l,l+1,l+2) elif l%2!=0 and r-l+1>3: print(l+1,l+2,l+3) else: print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",158
"l, r = map(int, input().split()) if r == l + 1 or r == l: print(-1) elif l%2 == 0: print(l, l+1, l+2) elif abs(r - l) >= 3: print(l+1, l+2, l+3) else: print(-1)",constant,"['brute force', 'implementation', 'math', 'number theory']",160
n = int(input()) if n == 1: print(5) else: print(25),constant,['number theory'],52
print('25'),constant,['number theory'],11
n = int(input()) print(25),constant,['number theory'],26
input() print(25),constant,['number theory'],17
a = int(input()) print(25),constant,['number theory'],26
n=int(input()) print('25'),constant,['number theory'],26
n = int(input()) if n==1: print(5) else: print(25),constant,['number theory'],50
n = int(input()) if n>=2: print(25),constant,['number theory'],35
n = int(input()) print(25),constant,['number theory'],26
"l = list(sorted(list(map(int,input().split())))) if min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2): print(""Yes"") else: print(""No"")",constant,"['brute force', 'constructive algorithms']",195
"def solve(): k = [int(x) for x in input().split(' ')] k.sort() if min(k) == 1: return ""YES"" elif k.count(2) >= 2: return ""YES"" elif k.count(3) == 3: return ""YES"" elif k == [2, 4, 4]: return ""YES"" return ""NO"" print(solve())",constant,"['brute force', 'constructive algorithms']",222
"k1, k2, k3 = sorted(map(int, input().split())) if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \ or (k1 == 2 and k2 == 4 and k3 == 4): print(""YES"") else: print(""NO"")",constant,"['brute force', 'constructive algorithms']",190
"k1, k2, k3 = sorted(map(int, input().split())) if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \ or (k1 == 2 and k2 == 4 and k3 == 4): print(""YES"") else: print(""NO"")",constant,"['brute force', 'constructive algorithms']",190
"import sys readline = sys.stdin.readline k = list(map(int, readline().split())) ans = 'NO' if min(k) == 1 or k.count(2) >= 2 or k.count(3) >= 3 or (k.count(4) == 2 and k.count(2) == 1): ans = 'YES' print(ans)",constant,"['brute force', 'constructive algorithms']",208
"import sys,math,itertools from collections import Counter,deque,defaultdict from bisect import bisect_left,bisect_right from heapq import heappop,heappush,heapify from copy import deepcopy mod = 10**9+7 INF = float('inf') def inp(): return int(sys.stdin.readline()) def inpl(): return list(map(int, sys.stdin.readline().split())) def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split())) def inps(): return sys.stdin.readline() def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x]) def err(x): print(x); exit() k = inpl(); k.sort() if k.count(1) >= 1 or k.count(2) >= 2 or k.count(3) >= 3 or k == [2,4,4]: print('YES') else: print('NO')",constant,"['brute force', 'constructive algorithms']",667
"def divisors(M): d=[] i=1 while M>=i**2: if M%i==0: d.append(i) if i**2!=M: d.append(M//i) i=i+1 return d def popcount(x): x = x - ((x >> 1) & 0x55555555) x = (x & 0x33333333) + ((x >> 2) & 0x33333333) x = (x + (x >> 4)) & 0x0f0f0f0f x = x + (x >> 8) x = x + (x >> 16) return x & 0x0000007f def eratosthenes(n): res=[0 for i in range(n+1)] prime=set([]) for i in range(2,n+1): if not res[i]: prime.add(i) for j in range(1,n//i+1): res[i*j]=1 return prime def factorization(n): res=[] for p in prime: if n%p==0: while n%p==0: n//=p res.append(p) if n!=1: res.append(n) return res def euler_phi(n): res = n for x in range(2,n+1): if x ** 2 > n: break if n%x==0: res = res//x * (x-1) while n%x==0: n //= x if n!=1: res = res//n * (n-1) return res def ind(b,n): res=0 while n%b==0: res+=1 n//=b return res def isPrimeMR(n): d = n - 1 d = d // (d & -d) L = [2, 3, 5, 7, 11, 13, 17] for a in L: t = d y = pow(a, t, n) if y == 1: continue while y != n - 1: y = (y * y) % n if y == 1 or t == n - 1: return 0 t <<= 1 return 1 def findFactorRho(n): from math import gcd m = 1 << n.bit_length() // 8 for c in range(1, 99): f = lambda x: (x * x + c) % n y, r, q, g = 2, 1, 1, 1 while g == 1: x = y for i in range(r): y = f(y) k = 0 while k < r and g == 1: ys = y for i in range(min(m, r - k)): y = f(y) q = q * abs(x - y) % n g = gcd(q, n) k += m r <<= 1 if g == n: g = 1 while g == 1: ys = f(ys) g = gcd(abs(x - ys), n) if g < n: if isPrimeMR(g): return g elif isPrimeMR(n // g): return n // g return findFactorRho(g) def primeFactor(n): i = 2 ret = {} rhoFlg = 0 while i*i <= n: k = 0 while n % i == 0: n //= i k += 1 if k: ret[i] = k i += 1 + i % 2 if i == 101 and n >= 2 ** 20: while n > 1: if isPrimeMR(n): ret[n], n = 1, 1 else: rhoFlg = 1 j = findFactorRho(n) k = 0 while n % j == 0: n //= j k += 1 ret[j] = k if n > 1: ret[n] = 1 if rhoFlg: ret = {x: ret[x] for x in sorted(ret)} return ret def divisors(n): res = [1] prime = primeFactor(n) for p in prime: newres = [] for d in res: for j in range(prime[",constant,"['brute force', 'constructive algorithms']",2000
"import math,sys,bisect,heapq from collections import defaultdict,Counter,deque from itertools import groupby,accumulate from functools import lru_cache int1 = lambda x: int(x) - 1 input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__ aj = lambda: list(map(int, input().split())) def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)] def Y(c): print([""NO"",""YES""][c]) def y(c): print([""no"",""yes""][c]) def Yy(c): print([""No"",""Yes""][c]) def fun(A): for i in range(len(A)): if A[i] == 0: return i return 1 dp = [0]*10 A = aj();A.sort() k1,k2,k3 = A for i in range(0,10,k1): dp[i] = 1 for i in range(fun(dp),10,k2): dp[i] = 1 for i in range(fun(dp),10,k3): dp[i] = 1 Y(0 not in dp)",constant,"['brute force', 'constructive algorithms']",715
"import sys,os,io import math,bisect,operator inf,mod = float('inf'),10**9+7 from itertools import groupby,accumulate from heapq import heapify,heappop,heappush from collections import deque,Counter,defaultdict input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__ Neo = lambda : list(map(int,input().split())) A = sorted(Neo()) B = [0]*100 for i in A: j = 0 for c in range(100): if B[c] == 0: j = c break while j < 100: B[j] = 1 j += i if B.count(0) == 0: print('YES') else: print('NO')",constant,"['brute force', 'constructive algorithms']",501
"k1,k2,k3=map(int,input().split()) a=[k1,k2,k3];a=sorted(a) dp=[0]*5001;dp[0]=1 i=0 while i<=5000: if dp[i]==0 and i+a[0]<=5000: while i+a[0]<=5000: dp[i]=1 i=i+a[0] else:i+=1 i=0 while i<=5000: if dp[i]==0 and i+a[1]<=5000: while i+a[1]<=5000: dp[i]=1 i=i+a[1] else:i+=1 i=0 while i<=5000: if dp[i]==0 and i+a[2]<=5000: while i+a[2]<=5000: dp[i]=1 i=i+a[2] else:i+=1 dp=dp[:2002] if dp.count(0)==0:print(""YES"") else:print(""NO"")",constant,"['brute force', 'constructive algorithms']",427
"k1,k2,k3=map(int,input().split()) a=[k1,k2,k3];a=sorted(a) if a[0]==1 or a.count(2)>=2 or a.count(3)==3:print(""YES"") elif a.count(4)==2 and a.count(2)==1:print(""YES"") else:print(""NO"")",constant,"['brute force', 'constructive algorithms']",183
"k1,k2,k3=map(int,input().split()) fl=0 for i1 in range(5): for i2 in range(5): for i3 in range(5): flak=1 for i in range(8): if (i-i1)%k1==0 or (i-i2)%k2==0 or (i-i3)%k3==0: continue else: flak=0 if flak==1: fl=1 if fl==1: print(""YES"") else: print(""NO"")",constant,"['brute force', 'constructive algorithms']",253
"import sys input = sys.stdin.buffer.readline from itertools import permutations k = list(map(int,input().split())) worked = 0 for k1,k2,k3 in permutations(k): worked2 = 1 for t in range(10000): if not (t % k1 == 0 or t % k2 == 1 or t % k3 == 2): worked2 = 0 if worked2: worked = 1 break if worked: print(""YES"") else: print(""NO"")",constant,"['brute force', 'constructive algorithms']",328
"a = list(map(int,input().split())) if a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2): print(""YES"") else: print(""NO"")",constant,"['brute force', 'constructive algorithms']",154
"k1,k2,k3 = map(int, input().strip().split(' ')) l=[k1,k2,k3] if min(k1,k2,k3)==1: print('yes') elif l.count(2)>=2: print('yes') elif l.count(3)==3: print('yes') elif l.count(4)==2 and l.count(2)==1: print('yes') else: print('no')",constant,"['brute force', 'constructive algorithms']",229
"l=list(map(int,input().split())) l.sort() x1=l[0] x2=l[1] x3=l[2] if l[0]==1 or (l[0]==2 and l[1]==4 and l[2]==4) or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==2): print(""YES"") else: print(""NO"")",constant,"['brute force', 'constructive algorithms']",207
"import sys import math import collections import heapq input=sys.stdin.readline k1,k2,k3=(int(i) for i in input().split()) l=[k1,k2,k3] if(1 in l): print(""YES"") elif(l.count(2)>=2): print(""YES"") elif(l.count(3)==3): print(""YES"") elif(sorted(l)==[2,4,4]): print(""YES"") else: print(""NO"")",constant,"['brute force', 'constructive algorithms']",285
"l=list(map(int,input().split())) s1,s2,s3,s4=0,0,0,0 for i in l: if i==1: s1+=1 if i==2: s2+=1 if i==3: s3+=1 if i==4: s4+=1 if s3>2 or s2>1 or s1>0 or (s4==2 and s2==1): print(""YES"") else: print(""NO"")",constant,"['brute force', 'constructive algorithms']",201
"A,B=map(int,input().split()) x,y,z=map(int,input().split()) summ=0 y1=0 b1=0 y1=(x*2)+y b1=y+(3*z) summ=0 if y1>A: summ+=y1-A if b1>B: summ+=b1-B print(summ)",constant,['implementation'],157
"a , b = list(map(int, input().split())) x, y, z = list(map(int, input().split())) ans = 0 p = a - ((x*2) + y) q = b - ((z*3) + y) if (p < 0 and q < 0): print(abs(p) + abs(q)) elif (p < 0): print(abs(p)) elif (q < 0): print(abs(q)) else: print(0)",constant,['implementation'],245
"A,B = map(int, input().split()) x,y,z = map(int, input().split()) A1 = 2*x + y - A B1 = 3*z + y - B final = 0 if A1 > 0: final = final + A1 if B1 > 0: final = final + B1 print(final)",constant,['implementation'],182
"a,b=map(int,input().split()) x,y,z=map(int,input().split()) if a < x*2+y: ry=x*2+y-a else: ry=0 if b < y+z*3: rb=y+z*3-b else: rb=0 print(ry+rb)",constant,['implementation'],144
"yellow,blue = map(int,input().split()) x,y,z = map(int,input().split()) ry = x*2+y rb =z*3+y r1,r2 = 0,0 if ry-yellow < 0: r1 = 0 else: r1 = ry-yellow if rb - blue < 0: r2 = 0 else: r2 = rb-blue print(r1+r2)",constant,['implementation'],207
"h,b = map(int,input().split()) x,y,z = map(int,input().split()) print(max(0,2*x+y-h)+max(0,3*z+y-b))",constant,['implementation'],100
"a, b = map(int, input().split()) x, y, z = map(int, input().split()) print(max((0,2*x+y-a))+max((0,3*z+y-b)))",constant,['implementation'],109
"yellow, blue = map(int, input().split()) y, g, b = map(int, input().split()) count = 0 yt = y * 2 + g bt = g + b * 3 yc = yellow - yt if yc < 0: count += abs(yc) bc = blue - bt if bc < 0: count += abs(bc) print(count)",constant,['implementation'],217
"a,b = map(int,input().split()) x,y,z=map(int,input().split()) r = 0 yellow = 2*x blue = 3*z green = y if a > yellow: a -= yellow else: r += abs(a-yellow) a=0 if b > blue: b -= blue else: r += abs(b-blue) b=0 if a > green: a-= green else: r += abs(a-green) if b > green: b-=green else: r += abs(b-green) print(r)",constant,['implementation'],311
"a,d=map(int,input().split()) y,g,b=map(int,input().split()) m=y*2+g n=b*3+g c=0 if(m>a): c+=m-a if(n>d): c+=n-d print(c)",constant,['implementation'],120
"import sys sys.setrecursionlimit(10**5) int1 = lambda x: int(x)-1 p2D = lambda x: print(*x, sep=""\n"") def II(): return int(sys.stdin.buffer.readline()) def MI(): return map(int, sys.stdin.buffer.readline().split()) def LI(): return list(map(int, sys.stdin.buffer.readline().split())) def LLI(rows_number): return [LI() for _ in range(rows_number)] def BI(): return sys.stdin.buffer.readline().rstrip() def SI(): return sys.stdin.buffer.readline().rstrip().decode() inf = 10**16 md = 10**9+7 a,b=MI() x,y,z=MI() yel=x*2+y bul=y+z*3 print(max(0,yel-a)+max(0,bul-b))",constant,['implementation'],563
"a,b = map(int, input().split()) x, y, z = map(int, input().split()) ans = max(0, 2*x+y-a)+max(0, 3*z+y-b) print(ans)",constant,['implementation'],116
"A, B = map(int, input().split()) x, y, z = map(int, input().split()) nA = 2*x+y nB = 3*z+y r = 0 if nA > A: r += nA-A if nB > B: r += nB-B print(r)",constant,['implementation'],147
"a, b = map(int, input().split()) x, y, z = map(int, input().split()) needa = 2 * x + y needb = y + 3 * z print(max(0, needa - a) + max(0, needb - b))",constant,['implementation'],149
"R=lambda:map(int,input().split()) a,b=R() x,y,z=R() print(max(0,2*x+y-a)+max(0,y+3*z-b))",constant,['implementation'],88
"def main(): A,B = list(map(int, input().strip().split())) yellow,green,blue = list(map(int, input().strip().split())) yelreq = 0 blureq = 0 yelreq = 2*yellow yelreq += green blureq += green blureq += 3*blue reqs = 0 if A<yelreq: reqs += yelreq - A if B<blureq: reqs += blureq - B print(reqs) main()",constant,['implementation'],298
"def req_num(a, b, x, y, z): req_a = (x * 2) + y req_b = (z * 3) + y if (req_a - a) <= 0: ans_a = 0 else: ans_a = req_a - a if (req_b - b) <= 0: ans_b = 0 else: ans_b = req_b - b return ans_a + ans_b a, b = list(map(int, input().strip().split())) x, y, z = list(map(int, input().strip().split())) print(req_num(a, b, x, y, z))",constant,['implementation'],325
"yellow, blue = map(int, input().split()) x, y, z = map(int, input().split()) answer1 = x*2+y-yellow answer2 = z*3+y - blue if answer1 > 0: if answer2 > 0: print(answer1+answer2) else: print(answer1) else: if answer2 > 0: print(answer2) else: print(0)",constant,['implementation'],250
"a,b=map(int,input().split()) x,y,z=map(int,input().split()) yell=2*x+y blue=y+3*z res=max(0,yell-a)+max(0,blue-b) print(res)",constant,['implementation'],124
"n, m = int(input()), int(input()) value = False for j in range(n + 1): if pow(2, j) > m: value = True break if value: print(m) else: print(m % pow(2, n))",constant,"['implementation', 'math']",153
n=int(input()) m=int(input()) print(m%(1<<n)),constant,"['implementation', 'math']",45
"n, m = int(input()), int(input()) value = False for j in range(n + 1): if pow(2, j) > m: value = True break if value: print(m) else: print(m % pow(2, n))",constant,"['implementation', 'math']",153
n = int(input()) m = int(input()) if(n<=26): print(m%(2**n)) else: print(m),constant,"['implementation', 'math']",75
"def Fast_power(x , y): res = 1 while y > 0 : if (y % 2 != 0): res = res * x y = y // 2 x = x * x return res n = int(input()) m = int(input()) if n <= 40 : print(m % Fast_power(2 , n)) else: print(m)",constant,"['implementation', 'math']",198
"def power(x , y): res = 1 while y > 0 : if y % 2 != 0 : res = res * x y //= 2 x *= x return res n = int(input()) m = int(input()) if n <= 40 : print(m % power(2 , n)) else: print(m)",constant,"['implementation', 'math']",181
n=int(input()) m=int(input()) if n>(m+1)/2: print(m) else: print(int(m%(2**n))),constant,"['implementation', 'math']",79
n = int(input()) m = int(input()) print(m % (2**n )),constant,"['implementation', 'math']",52
n = int(input()) m = int(input()) r = 1 for power in range(n): r *= 2 if r > m: print(m) break else: if r == m: print(0) else: print(m % r),constant,"['implementation', 'math']",139
"n=int(input()) m=int(input()) print(m%(pow(2,n)))",constant,"['implementation', 'math']",49
"n = int(input()) m = int(input()) print(m % pow(2, n))",constant,"['implementation', 'math']",54
"n, m = int(input()), int(input()) print(m % (2 ** n) if n < 30 else m)",constant,"['implementation', 'math']",70
"n,m = int(input()),int(input()) if n < 27: print(m%2**n) else: print(m)",constant,"['implementation', 'math']",71
n=int(input()) m=int(input()) print(m%2**n),constant,"['implementation', 'math']",43
"import math t=1 while t: t-=1 n=int(input()) m=int(input()) if(n>=27): print(m) else: print(m%(pow(2,n)))",constant,"['implementation', 'math']",105
n = int(input()) m = int(input()) print(m%2**n),constant,"['implementation', 'math']",47
"from sys import stdin, stdout n = int(stdin.readline()) m = int(stdin.readline()) stdout.write(str(m%(1<<n)))",constant,"['implementation', 'math']",109
"from sys import stdin def read_lines(sep=' ', input_type=None): _lines = stdin.readlines() cast = input_type is not None lines = [] for line in _lines: line = line[:-1].split(sep) if cast: line = [input_type(x) for x in line] lines.append(line) return lines import math if __name__ == '__main__': lines = read_lines(input_type=int) n,m = lines[0][0], lines[1][0] if n <= math.log2(m): print(m % (2**n)) else: print(m)",constant,"['implementation', 'math']",417
"n, pos, l, r=map(int, input().split()) if l==1 and r==n: print(0) elif l==1 and r!=n: print(abs(pos-r)+1) elif l!=1 and r==n: print(abs(pos-l)+1) else: print(r-l+2+min(abs(pos-l), abs(pos-r)))",constant,['implementation'],192
"n, pos, l, r = map(int, input().split()) result = abs(pos - l) + r - l + 2 if (l == 1): if (abs(pos - r) + 1 < result): result = abs(pos - r) + 1 if (r == n): if (abs(pos - l) + 1 < result): result = abs(pos - l) + 1 if (l == 1 and r == n): result = 0 if (abs(pos - r) + r - l + 2 < result): result = abs(pos - r) + r - l + 2 print(result)",constant,['implementation'],339
"n,pos,l,r=map(int,input().split()) if l==1 and r==n: print(0) elif l==1: print(abs(pos-r)+1) elif r==n: print(abs(pos-l)+1) else: print(min(abs(pos-l),abs(pos-r))+abs(l-r)+2)",constant,['implementation'],174
"import math n,pos,l,r = map(int, input().strip().split(' ')) if l==1 and r==n: print(0) elif l==1: if pos==r: print(1) elif pos>r: print(pos-r+1) elif pos<r: print(r-pos+1) elif r==n: if pos==l: print(1) elif pos<l: print(l-pos+1) else: print(pos-l+1) else: if pos>=l and pos<=r: if pos-l<r-pos: print(2+pos-l+r-l) else: print(2+r-l+r-pos) else: if pos>r: print(pos-r+2+r-l) else: print(l-pos+2+r-l)",constant,['implementation'],399
"import sys import math input = sys.stdin.readline for _ in range(1): n,pos,l,r = map(int,input().split()) if l == 1 and r == n: print(0) continue if l != 1 and r != n: ans = min(abs(l-pos),abs(r-pos))+2+abs(r-l) else: if l == 1: ans = abs(pos-r)+1 else: ans = abs(pos-l)+1 print(ans)",constant,['implementation'],283
"n,pos,l,r = map(int, input().split()) dl,dr = abs(pos-l) + 1, abs(pos-r) + 1 print(dr*(r<n) if l==1 else dl if r==n else min(dl,dr)+r-l+1)",constant,['implementation'],138
"n,p,l,r = map(int,input().split()) if l == 1 and r == n: print(0) elif l==1: print(abs(p-r)+1) elif r == n: print(abs(p - l) + 1) else: print(min(abs(p-r),abs(p - l))+r-l+2)",constant,['implementation'],173
"def main(): n, pos, l, r=tuple(map(int,input().split())) time=0 if l!=1 and r!=n: if abs(pos-l)<abs(pos-r): time+=abs(pos-l)+abs(l-r)+2 else: time+=abs(pos-r)+abs(l-r)+2 elif l==1 and r!=n: time+=abs(pos-r)+1 elif r==n and l!=1: time+=abs(pos-l)+1 else: time+=0 print(time) if __name__=='__main__': main()",constant,['implementation'],305
"n, p, l, r = map(int, input().split()) if l == 1 and r == n: print(0) elif l == 1: print(abs(p-r) + 1) elif r == n: print(abs(p-l) + 1) else: print(min(abs(p-l), abs(p-r)) + r - l + 2)",constant,['implementation'],184
"from collections import deque as de import math from sys import stdin, stdout import re from collections import Counter as cnt from functools import reduce from itertools import groupby as gb from bisect import bisect_left as bl, bisect_right as br def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def decimalToBinary(n): return bin(n).replace(""0b"", """") def binarytodecimal(n): return int(n,2) def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def getProduct(n): product = 1 while (n != 0): product = product * (n % 10) n = n // 10 return product def lcm(x,y): lcm = (x*y)//math.gcd(x,y) return lcm def isPowerOfTwo(n): return (math.ceil(Log2(n)) == math.floor(Log2(n))); def checkisap(list): d=list[1]-list[0] for i in range(2,len(list)): temp=list[i]-list[i-1] if temp !=d: return False return True def ceildiv(x,y): return (x+y-1)//y def di():return map(int, input().split()) def ii():return int(input()) def li():return list(map(int, input().split(",constant,['implementation'],1999
"n, pos, a, b = map(int,input().split()) lf, rf = a - 1, n - b if lf == rf == 0: print(""0"") elif lf == 0: print(abs(pos-b)+1) elif rf == 0: print(abs(pos-a)+1) else: cl = abs(a-pos) + 1 cr = abs(b-pos) + 1 xn = abs(a-b) + 1 if cl < cr: print(cl+xn) else: print(cr+xn)",constant,['implementation'],266
"n, pos, l, r = map(int,input().split()) step, dif = 0, lambda a, b : abs(a - b) if dif(pos, l) < dif(pos, r): if l != 1: step += dif(pos, l) + 1 pos = l if r != n: step += dif(pos, r) + 1 else: if r != n: step += dif(pos, r) + 1 pos = r if l != 1: step += dif(pos, l) + 1 print(step)",constant,['implementation'],283
"from sys import stdin, stdout nmbr = lambda: int(input()) lst = lambda: list(map(int, input().split())) for _ in range(1): n, cur, l, r=lst() if l==1 and r==n: print(0) elif l==1 and r!=n: print(abs(r-cur)+1) elif r==n and l!=1: print(abs(cur-l)+1) else: disa=abs(l-cur) disb=abs(r-cur) ans=min(disa, disb) + (r-l) +2 print(ans)",constant,['implementation'],328
"x=list(map(int,input().split())) pos=x[1] n=x[0] l=x[2] r=x[3] step=0 if pos<l : step=l-pos+1 if r< n : step+=r-l+1 elif pos>r: step=pos-r+1 if l> 1 : step+=r-l+1 else: if l>1 and n>r: step+=min(pos-l,r-pos)+r-l+2 elif l==1 and n>r: step=r-pos+1 elif l>1 and n==r: step+=pos-l+1 else: step=0 print(step)",constant,['implementation'],303
"x=list(map(int,input().split())) pos=x[1] n=x[0] l=x[2] r=x[3] step=0 if pos<l : step=l-pos+1 if r< n : step+=r-l+1 elif pos>r: step=pos-r+1 if l> 1 : step+=r-l+1 else: if l>1 and n>r: step+=min(pos-l,r-pos)+r-l+2 elif l==1 and n>r: step=r-pos+1 elif l>1 and n==r: step+=pos-l+1 else: step=0 print(step)",constant,['implementation'],303
"n,pos,l,r = map(int,input().split()) if(r-l+1 == n): print(0) exit(0) if(pos>l and pos<r): if(n>r and l>1): x = pos-l+1+r-l+1 y = r-pos+1+r-l+1 ans = min(x,y) else: if(n==r): ans = pos-l+1 elif(l==1): ans = r-pos+1 elif(pos>=r): if(n>r): ans = pos-r+1 else: ans = 0 if(l>1): ans+=r-l+1 elif(pos<=l): if(l>1): ans = l-pos+1 else: ans = 0 if(n>r): ans+=r-l+1 print(ans)",constant,['implementation'],367
n=int(input()) print((n//2)+1),constant,['math'],30
n=int(input()) print(int(n/2+1)),constant,['math'],32
import math num=int(input()) k=math.ceil(num/2) if num%2==0: print(k+1) else: print(k),constant,['math'],86
n=int(input()) print(int(n/2)+1),constant,['math'],32
n = int(input()) print(n//2 + 1),constant,['math'],32
n=int(input()) print(int(n/2)+1),constant,['math'],32
n = int(input()) print(n//2+1),constant,['math'],30
print(int(input()) // 2 + 1),constant,['math'],28
print((int(input()))//2+1),constant,['math'],26
"from math import * from cmath import * from itertools import * from decimal import * from fractions import * from sys import * from types import CodeType, new_class n = int(input()) print(n//2+1)",constant,['math'],195
n = int(input()) print(n // 2 + 1),constant,['math'],34
n=int(input()) print(n//2+1),constant,['math'],28
n = int(input()) ans = 1+n//2 print(ans),constant,['math'],40
n=int(input()) print((n//2)+1),constant,['math'],30
n = int(input()) print((n//2)+1),constant,['math'],32
print(int(input())//2 + 1),constant,['math'],26
x=int(input()) d=x//2 print(d+1),constant,['math'],32
n=int(input()) print((n+2)//2),constant,['math'],30
"k, n, s, p = map(int, input().split()) L = (n - 1) // s + 1 L *= k print((L - 1) // p + 1)",constant,['math'],90
"k,n,s,p = map(int,input().split()) print(int((int((n+s-1)/s)*k+p-1)/p))",constant,['math'],71
"import math k,n,s,p = input().split() k = int(k) n = int(n) s = int(s) p = int(p) sheet_for_each_person = math.ceil(n/s) total_sheets_required = k*sheet_for_each_person no_of_packs = math.ceil( total_sheets_required/p ) print(no_of_packs)",constant,['math'],238
"from math import * k,n,s,p = map(int,input().split()) sheetsforone = ceil(n/s) sheetsfork = sheetsforone*k packs = ceil(sheetsfork/p) print(int(packs))",constant,['math'],151
"k, n, s, p = map(int, input().split()) sheets = (n + s - 1) // s print((sheets * k + p - 1) // p)",constant,['math'],97
"from sys import stdin,stdout from math import ceil nmbr = lambda: int(stdin.readline()) lst = lambda: list(map(int, stdin.readline().split())) for _ in range(1): k,n,s,p=lst() spp=ceil(n/s) tots=spp*k print(ceil(tots/p))",constant,['math'],220
"from math import ceil def paper(a,b,c,d): return ceil((a*(ceil(b/c)))/d) a,b,c,d=map(int,input().strip().split()) print(paper(a,b,c,d))",constant,['math'],135
"from math import ceil k, n, s, p = map(int, input().split()) n_sheets = ceil(n / s)* k n_p = ceil(n_sheets / p) print(n_p)",constant,['math'],122
"from math import * from cmath import * from itertools import * from decimal import * from fractions import * from sys import * from types import CodeType, new_class k, n, s, p = map(int, input().split()) print((k*(n//s + (n%s != 0))) // p + ((k*(n//s + (n%s != 0))) % p != 0))",constant,['math'],276
"k, n, s, p = map(int, input().split()) print(((n + s - 1) // s * k + p - 1) // p)",constant,['math'],81
"k,n,s,p=map(int,input().split()) a=n//s if(n%s!=0): a+=1 q=k*a m=q//p if(q%p!=0): m+=1 print(m)",constant,['math'],95
"k,n,s,p = map(int, input().split()) q = (n+s-1)//s ans = (q*k+p-1)//p print(ans)",constant,['math'],80
import math def solve(): words = input().split() people = int(words[0]) planes_each = int(words[1]) per = int(words[2]) sheets = int(words[3]) sheets_per_person = math.ceil(planes_each/per) needed = sheets_per_person*people packs = math.ceil(needed/sheets) print(packs) solve(),constant,['math'],277
"k,n,s,p=map(int,input().split()) c=(n//s) if n%s==0 else (n//s)+1 print((c*k)//p if (c*k)%p==0 else ((c*k)//p)+1)",constant,['math'],113
"k,n,s,p = map(int,input().split()) x = (n+s-1)//s x *= k print((x+p-1)//p)",constant,['math'],74
"k,n,s,p=map(int,input().split(' ')) if (1*n)%s==0: need=(1*n)//s if need==0 and k%p==0: print(k//p) elif (k*need)%p==0: print((k*need)//p) else: print(((k*need)//p)+1) else: need=((1*n)//s)+1 if need==0 and k%p==0: print(k//p) elif (k*need)%p==0: print((k*need)//p) else: print(((k*need)//p)+1)",constant,['math'],294
"k, n, s, p = map(int, input().split()) paper_person = (n + s -1)//s total_needed = paper_person * k ans = (total_needed+p-1)//p print(ans)",constant,['math'],138
"import math k, n, s, p = map(int, input().split()) sheets = math.ceil(n/s) * k print(math.ceil(sheets/p))",constant,['math'],105
"import math k,n,s,p=[int(x) for x in input().split()] x=math.ceil(n/s) y=math.ceil(x*k/p) print(y)",constant,['math'],98
"from sys import stdin,stdout nmbr = lambda: int(stdin.readline()) lst = lambda: list(map(int, stdin.readline().split())) def fn(p): turns=b[p]//14 a=b.copy();sm=0 a[p]=0 for i in range(1,15): a[(p+i)%14]+=turns rem=b[p]%14 for i in range(p+1,p+rem+1,1): a[(i%14)]+=1 for i in range(14): if a[i]&1==0: sm+=a[i] return sm for _ in range(1): b=lst() ans=0 for i in range(14): if b[i]!=0:ans=max(ans,fn(i)) print(ans)",constant,"['brute force', 'implementation']",413
"if __name__ == '__main__': a = [int(i) for i in input().split()] mx = -1 for i in range(14): b = a.copy() if a[i]: b[i], d, ans = 0, i + 1, 0 r = (a[i] + d) // 14 l = (a[i] + d) % 14 if d + a[i] < 14: ans = sum([j + 1 for j in a[d:d + a[i]] if not (j + 1) % 2]) else: for j in range(14): b[j] += r if d > l: for j in range(l, d): b[j] -= 1 else: for j in range(d, d + abs(d - l)): b[j] += 1 ans = sum([p for p in b if not p % 2]) mx = max(mx, ans) print(mx)",constant,"['brute force', 'implementation']",457
"A = list(map(int, input().split())) ans = 0 for i in range(14): if A[i] == 0: continue B = A+A B[i+14] = 0 q, r = divmod(B[i], 14) for j in range(1, 15): if j <= r: B[i+j] += (q+1) else: B[i+j] += q temp = 0 for j in range(i+1, i+15): if B[j]%2 == 0: temp += B[j] ans = max(ans, temp) print(ans)",constant,"['brute force', 'implementation']",295
"a = list(map(int, input().split())) n = len(a) k = [i for i in a] lst = [] for i in range(n): p = k[i]%n ans = 0 a = k[i+1:] + k[:i+1] a[-1] = 0 for j in range(n): if (a[j] + 1 + int(k[i]//n))%2 == 0 and j < p: ans += a[j] + 1 + int(k[i]//n) elif (a[j] + int(k[i]//n))%2 == 0 and j >= p: ans += a[j] + int(k[i]//n) lst.append(ans) print(max(lst))",constant,"['brute force', 'implementation']",346
"import os import sys from io import BytesIO ,IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans def",constant,"['brute force', 'implementation']",1999
"from copy import copy a = list(map(int, input().split())) ans = 0 for i in range(14): b = copy(a) b[i] = 0 for j in range(1, 14 + 1): b[(i + j) % 14] += (a[i] - 1) // 14 + ((a[i] - 1) % 14 + 1 > j - 1) ans = max(ans, sum(el * (el % 2 == 0) for el in b)) print(ans)",constant,"['brute force', 'implementation']",264
"stones = list(map(int,input().split())) initial_sum = 0 def even_sum(arr): temp_sum = 0 for each in arr: if(each%2 == 0): temp_sum += each return temp_sum initial_sum = even_sum(stones) dup_sum = initial_sum for i in range(14): duplicate = list(stones) temp = stones[i] duplicate[i] = 0 j = i for each in range(14): duplicate[each] += temp//14 temp = temp%14 while temp > 0 : if( j == 13): j = -1 j += 1 duplicate[j] += 1 temp -= 1 ts = even_sum(duplicate) if(ts > initial_sum ): initial_sum = ts print(initial_sum)",constant,"['brute force', 'implementation']",515
"l = list(map(int,input().split())) n = 0 m=-1 while(n<14): c=0 g = l.copy() div = l[n]//14 h = l[n]%14 i = n+1 sum = div*14 g[n]=0 while(sum): if i==14: i=0 g[i]+=div sum-=div i+=1 i = n+1 while(h): if i==14: i=0 g[i]+=1 h-=1 i+=1 for j in g: if j%2==0: c+=j m = max(c,m) n+=1 print(m)",constant,"['brute force', 'implementation']",285
"a=list(map(int,input().split())) mr=0 for t in range(14): b=list(a) m=b[t] k=t i=1 b[k]=0 while(m>0): if(m//14==0): b[(k+i)%14]+=1 m-=1 i+=1 else: q=m//14 for c in range(14): b[c]+=q m-=14*q p=sum([ x for x in b if x%2==0 ]) mr=max(p,mr) print(mr)",constant,"['brute force', 'implementation']",247
"l=list(map(int,input().split())) ans=0 for i in range(14): a=[] m=0 a.extend(l) c=a[i]//14 d=a[i]%14 a[i]=0 j=1 while(j<=d): k=(i+j)%14 a[k]+=1 j+=1 for j in range(14): a[j]+=c if a[j]%2==0: m+=a[j] ans=max(ans, m) print(ans)",constant,"['brute force', 'implementation']",225
"import os import sys from io import BytesIO, IOBase from collections import * from itertools import * from functools import * from math import * BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") A = [int(n) for n in input().split()] N = len(A) dp = [0] * N for i in range(N): B = A.copy() each = B[i] // N curr = B[i] B[i] = 0 for j in range(N): B[j] += each for j in range(1, (curr - each * N) + 1): B[(i + j) % N] += 1 for M in B: if M % 2 == 0: dp[i] += M print(max(dp))",constant,"['brute force', 'implementation']",1768
"grid = list(map(int,input().split())) max_res = 0 for i in range(14): g_c = grid.copy() Amount = g_c[i]//14 Amount_r = g_c[i]%14 if(Amount > 0): for j in range(14): if i != (i+j+1)%14: g_c[(i+j+1)%14]+=Amount g_c[i]-=Amount if Amount_r > 0: for j in range(14): if Amount_r > 0: if i != (i+j+1)%14: g_c[(i+j+1)%14]+=1 Amount_r-=1 g_c[i]-=1 else: break res = 0 for i in range(14): if g_c[i] % 2 ==0: res+=g_c[i] max_res = max(max_res,res) print(max_res)",constant,"['brute force', 'implementation']",451
"a=list(map(int, input().split())) h=0 for i in range(14): b=a[:] if i==13: j=0 else: j=i+1 if a[i]>0: c=0 t=b[i]%14 x=b[i]//14 b[i]=0 for i in range(14): b[i]+=x while t>0: b[j]+=1 j+=1 if j==14: j=0 t-=1 for i in range(14): if b[i]%2==0: c+=b[i] if c>h: h=c print(h)",constant,"['brute force', 'implementation']",267
"import math v = [int(x) for x in input().split()] n = len(v) val = 0 for i in range(n): a = v[i] // n arr = v.copy() arr[i] = 0 for j in range(n): arr[j] += a b = v[i] % n k = i + 1 l = 0 while l < b: if k > n - 1: k = 0 arr[k] += 1 k += 1 l += 1 count = 0 for j in range(n): if arr[j] % 2 == 0: count += arr[j] val = max(val, count) print(val)",constant,"['brute force', 'implementation']",344
"def f(a, ind): if a[ind] == 0: return -1 k = a[ind] // 14 x = a[ind] % 14 b = a[:] b[ind] = 0 for j in range(14): b[j] += k for j in range(ind + 1, ind + x + 1): j1 = j % 14 b[j1] += 1 res = 0 for j in range(14): if b[j] % 2 == 0: res += b[j] return res a = list(map(int, input().split())) ans = 0 for i in range(14): cur = f(a, i) ans = max(ans, cur) print(ans)",constant,"['brute force', 'implementation']",362
"def score(l): return sum(x*(x%2 == 0) for x in l) res = 0 ns = list(map(int, input().split())) for i in range(14): l = list(ns) for j in range(13): l[(i+1+j) % 14] += l[i]//14 + (1 if (j+1) <= l[i]%14 else 0) l[i] = l[i]//14 res = max(res, score(l)) print(res)",constant,"['brute force', 'implementation']",260
"xs = [int(x) for x in input().split()] res = 0 for i in range(14): newxs = xs[:] newxs[i] = 0 for j in range(14): newxs[j] += xs[i] // 14 for j in range(xs[i] % 14): newxs[(i + 1 + j) % 14] += 1 res = max(res, sum(val for val in newxs if val % 2 == 0)) print(res)",constant,"['brute force', 'implementation']",263
"b = list(map(int, input().split())) n = 14 ans = 0 for i in range(n): a = b.copy() if a[i] == 0: continue x = a[i] a[i] = 0 full = x // n xex = x % n for j in range(n): a[j] += full for j in range(xex): a[(i + j + 1) % n] += 1 pot = 0 for j in a: if j % 2 == 0: pot += j ans = max(ans, pot) print(ans)",constant,"['brute force', 'implementation']",301
"a = list(map(int, input().split())) ans = 0 for i in range(len(a)): x = a[i] b = [j for j in a] b[i] = 0 for j in range(len(a)): b[j] += x // 14 for j in range(1, x % 14 + 1): b[(i + j) % 14] += 1 ans_now = 0 for j in b: if j % 2 == 0: ans_now += j ans = max(ans_now, ans) print(ans)",constant,"['brute force', 'implementation']",283
import sys n=int(input()) if n==0: print(0) sys.exit() if (n+1)%2==0: print((n+1)//2) else: print(n+1),constant,['math'],102
"import os import sys from math import * from collections import * from bisect import * from io import BytesIO, IOBase def vsInput(): sys.stdin = open(""input.txt"", ""r"") sys.stdout = open(""output.txt"", ""w"") BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") ALPHA = ""abcdefghijklmnopqrstuvwxyz/"" M = 1000000007 EPS = 1e-6 def Ceil(a, b): return a // b + int(a % b > 0) def value(): return tuple(map(int, input().split())) def array(): return [int(i) for i in input().split()] def Int(): return int(input()) def Str(): return input() def arrayS(): return [i for i in input().split()] n = int(input()) if n == 0: print(0) else: print(n // 2 + 1 if n % 2 != 0 else n + 1)",constant,['math'],1960
"a=input() b=int(a)+1 if b==1 : print(""0"") elif b%2==0 : print(b//2) elif b%2!=0 : print(b)",constant,['math'],90
n = int(input()) if n == 0: print(0) else: if n % 2 == 0: print(n+1) else: print((n+1)//2),constant,['math'],90
n = int(input()) + 1 if n == 1: print(0) exit() print(n if n % 2 else n // 2),constant,['math'],77
n = int(input())+1 print(0 if not (n-1) else n//2 if not n&1 else n),constant,['math'],68
n=int(input()) if(n==0): print(0) elif(n%2!=0): print((n+1)//2) else: print(n+1),constant,['math'],80
n = int(input()) n+=1 if n==1: print(0) elif n%2==0: print(n//2) elif n%2!=0 and n!=1: print(n),constant,['math'],95
n=int(input()) n+=1 if(n==1):print(0) elif n%2==0:print(n//2) else :print(n),constant,['math'],76
n=int(input())+1 if n<2: print(0) elif n%2==0: print(n//2) else: print(n),constant,['math'],73
n = int(input()) if n == 0: print(0) else: if n % 2 == 0: print(n+1) else: print((n+1)//2),constant,['math'],90
n=int(input())+1 if n==1: print(0) elif n%2: print(n) else: print(n//2),constant,['math'],71
n = int(input()) + 1 if n == 1: print(0) else: if n % 2: print(n) else: print(n // 2),constant,['math'],85
n = int(input()) if n==0: print(0) elif n%2==1: print((n+1)//2) else: print(n+1),constant,['math'],80
n = int(input()) if n % 2 == 1: print((n + 2) // 2) elif n > 0: print(n + 1) else: print(0),constant,['math'],91
from sys import stdin n = int(stdin.readline()) + 1 if n == 1: print(0) else: print(n//2 if n%2 == 0 else n),constant,['math'],108
n=int(input()) n+=1 if n%2==0 or n==1: print(n//2) else: print(n),constant,['math'],65
"from collections import deque as de import math from collections import Counter as cnt from functools import reduce from typing import MutableMapping from itertools import groupby as gb from fractions import Fraction as fr def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def decimalToBinary(n): return bin(n).replace(""0b"", """") def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def isPowerOfTwo(n): return (math.ceil(Log2(n)) == math.floor(Log2(n))); def ceildiv(x,y): return (x+y-1)//y n=int(input()) if n==0: print(0) else: if (n+1)%2: print(n+1) else: print((n+1)//2)",constant,['math'],1617
"lst = [] ans = {'purple' : 'Power', 'green' : 'Time', 'blue': 'Space', ""orange"" : ""Soul"", ""red"" : ""Reality"", ""yellow"" : ""Mind""} for i in range(int(input())): lst.append(input()) a = [] for i in ans.keys(): if i not in lst: a.append(ans[i]) print(len(a)) for i in a: print(i)",constant,['implementation'],274
"dic = {'purple':'Power', 'green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'} n = int(input()) a = [] for i in range(n): a.append(input()) print(6-len(a)) for i in dic: if i not in a: print(dic[i])",constant,['implementation'],223
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"",""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""} i = int(input()) l = [] for x in range(i): d.pop(input()) print(len(d)) for i in d.values() : print(i)",constant,['implementation'],206
"n=int(input()) d={""purple"":""Power"",""green"":""Time"",""blue"":""Space"",""orange"":""Soul"",""red"":""Reality"",""yellow"":""Mind""} l=[] for i in range(n): s=input() l.append(s) print(6-n) for i in d: if i not in l: print(d[i])",constant,['implementation'],209
"n=int(input()) s=['Power','Time','Space','Soul','Reality','Mind'] for _ in range(n): i=input() if(i=='purple'): s.remove('Power') elif(i=='green'): s.remove('Time') elif(i=='blue'): s.remove('Space') elif(i=='orange'): s.remove('Soul') elif(i=='red'): s.remove('Reality') elif(i=='yellow'): s.remove('Mind') print(len(s)) for i in range(len(s)): print(s[i])",constant,['implementation'],357
"my_list = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""yellow"":""Mind"", ""red"":""Reality""} n = int(input()) for i in range(n): my_list.pop(input()) print(len(my_list)) for i in my_list: print(my_list[i])",constant,['implementation'],224
"kol = int(input()) dic = {'purple': 'Power', 'green': 'Time', 'blue': 'Space', 'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'} r = [] g = [] missing = 6 - kol for k in range(kol): rocks = input() r.append(rocks) for key in dic: if r.count(key) == 0: g.append(dic[key]) print(missing) for stone in g: print(stone)",constant,['implementation'],318
"n = int(input()) gems = {'purple':'Power', 'green':'Time', 'blue': 'Space', 'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'} gems_in = [] for _ in range(n): gems_in.append(input()) print(6-len(gems_in)) r = list(set(gems) - set(gems_in)) for gem in r: print(gems[gem])",constant,['implementation'],273
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"", ""yellow"":""Mind""} s = set() n = int(input()) for _ in range(n): w = input() s.add(w) print(6 - n) for (key, value) in d.items(): if key not in s: print(value)",constant,['implementation'],246
"n = int(input()) d = {'red':'Reality', 'purple': 'Power', 'yellow':'Mind', 'orange':'Soul','blue':'Space','green':'Time'} stones = ['Reality', 'Power', 'Mind', 'Soul', 'Space', 'Time'] st=[] for _ in range(n): st.append(d[input()]) b=[] for a in stones: if a not in st: b.append(a) print(len(b)) for k in b: print(k)",constant,['implementation'],316
"import sys def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans mod = int(1e9) + 7 def ssinp(): return sys.stdin.readline().strip() def iinp(): return int(input()) def nninp(): return map(int, sys.stdin.readline().strip().split()) def llinp(): return list(map(int, sys.stdin.readline().strip().split())) def p(xyz): print(xyz) def p2(a, b): print(a, b) import math from collections import OrderedDict n=iinp() l=[] s={""purple"",""green"",""blue"",""orange"",""red"",""yellow""} for i in range(n): inp=ssinp() s.remove(inp) print(6-n) for i in s: if(i==""purple""): print(""Power"") elif(i==""green""): print(""Time"") elif(i==""blue""): print(""Space"") elif (i == ""orange""): print(""Soul"") elif (i == ""red""): print(""Reality"") else: print(""Mind"")",constant,['implementation'],1268
"d = { ""purple"": ""Power"", ""green"": ""Time"", ""blue"": ""Space"", ""orange"": ""Soul"", ""red"": ""Reality"", ""yellow"": ""Mind"", } all_colors = list(d.keys()) n = int(input()) colors = [input() for i in range(n)] print(len(d) - len(colors)) for color in all_colors: if color not in colors: print(d[color])",constant,['implementation'],289
"dict={""Power"":""purple"", ""Time"":""green"", ""Space"":""blue"", ""Soul"":""orange"", ""Reality"":""red"", ""Mind"":""yellow""} dict1={} n=(int(input())) while n: str=input() if str==""purple"": dict1[""Power""]=str elif str==""green"": dict1[""Time""]=str elif str==""blue"": dict1[""Space""]=str elif str==""orange"": dict1[""Soul""]=str elif str==""red"": dict1[""Reality""]=str elif str==""yellow"": dict1[""Mind""]=str n-=1 val=list(dict.keys()) val_list=list(dict1.keys()) l=[key for key in val if key not in val_list] print(len(l)) for i in range(len(l)): print(l[i])",constant,['implementation'],529
"n=int(input()) l=[] for i in range(n): s=str(input()) l.append(s) print(6-n) if ""purple"" not in l: print(""Power"") if ""green"" not in l: print(""Time"") if ""red"" not in l: print(""Reality"") if ""blue"" not in l: print(""Space"") if ""orange"" not in l: print(""Soul"") if ""yellow"" not in l: print(""Mind"")",constant,['implementation'],291
"import sys def input(): return sys.stdin.readline().strip() def iinput(): return int(input()) def minput(): return map(int, sys.stdin.readline().strip().split()) def listinput(): return list(map(int, sys.stdin.readline().strip().split())) n=iinput() color=['purple','green','blue','orange','red','yellow'] gem=['Power','Time','Space','Soul','Reality','Mind'] for _ in range(n): s=input() indexofcolor=color.index(s) color.remove(s) gem.pop(indexofcolor) print(len(gem)) for i in gem: print(i)",constant,['implementation'],492
"n = int(input()) li1 = [] s="""" li2 = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""} for i in range(n): s = input() li1.append(s) print(6-n) for key in li2: if key in li1: continue else: li1.append(key) print(li2[key])",constant,['implementation'],271
"allcolor=['purple','green','blue','orange','red','yellow'] op=['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind'] n=int(input()) ipcolor=[] for i in range(0,n): color=input() ipcolor.append(color) diff=list(set(allcolor) - set(ipcolor)) print(len(diff)) for i in range(0,len(diff)): print(op[allcolor.index(diff[i])])",constant,['implementation'],319
"d={'purple':'Power','green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'} for _ in[0]*int(input()):d.pop(input()) print(len(d),*d.values(),sep='\n')",constant,['implementation'],173
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"", ""yellow"":""Mind""} s = set() n = int(input()) for _ in range(n): w = input() s.add(w) print(6 - n) for (key, value) in d.items(): if key not in s: print(value)",constant,['implementation'],246
"a, b, c, n = [int(j) for j in input().split()] a -= c b -= c if n - a - b - c >= 1 and a >= 0 and b >= 0: print(n - a - b - c) else: print(-1)",constant,['implementation'],142
"a,b,c,n=map(int,input().split()) if(c>b or c>a or c>n): print(-1) else: k=c+(a-c)+(b-c) k=n-k if(k>0): print(k) else: print(-1)",constant,['implementation'],127
"import math import os import random import re import sys import functools from operator import itemgetter, attrgetter from collections import Counter if __name__ == '__main__': Y = lambda: list(map(int, input().split())) P = lambda: map(int, input().split()) N = lambda: int(input()) a, b, c, n = P() if a < c or b < c: r = -1 else: r = n - (a + b - c) print(-1 if r <= 0 else r)",constant,['implementation'],379
"import os,sys from io import BytesIO, IOBase def main(): a,b,c,n = map(int,input().split()) if a+b-c > n-1 or min(a,b) < c: print(-1) else: print(n-(a+b-c)) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == '__main__': main()",constant,['implementation'],1535
"lis = list(map(int,input().split())) if lis[2] <= lis[0] and lis[2] <= lis[1]: if ((lis[0]+lis[1]) - lis[2]) < lis[3]: print(lis[3] - ((lis[0]+lis[1]) - lis[2])) elif sum(lis) == 0: print(-1) elif lis[0] == 0 and lis[1] == 0 and lis[2] == 0 : print(lis[3]) else: print(-1) else: print(-1)",constant,['implementation'],288
"A, B, C, N = map(int, input().strip().split()) D = N - (A + B - C) if D <= 0 or C > A or C > B: print('-1') exit(0) print(D)",constant,['implementation'],124
"a,b,c,n=map(int, input().split()) p=n-(a+b-c) if c>a or c>b or p<=0: print(-1) exit() if p<1: print(-1) else: print(p)",constant,['implementation'],118
"a,b,c,n= [int(c) for c in input().split()] u=a+b-c if a<c or b<c: print(-1) else: if n-u>=1: print(n-u) else: print(-1)",constant,['implementation'],119
"a,b,c,n=map(int,input().split()) if n-a-b+c>=1: if a<c or b<c: print(-1) else: print(n-a-b+c) else: print(-1)",constant,['implementation'],109
"mecces, burgerKing, both, groupSize = map(int,input().strip().split(' ')) mecces -= both burgerKing -= both notPassed = groupSize - sum((mecces,burgerKing,both)) if notPassed > 0 and burgerKing >= 0 and mecces >= 0: print(notPassed) else: print(-1)",constant,['implementation'],248
"a, b, c, n = map(int, input().split()) t = a + b - c if a >= n or b >= n or c > a or c > b or t >= n: print(-1) else: print(n - t)",constant,['implementation'],130
"a,b,c,n=list(map(int,input().split())) p=(a+b-c) f=n-p if p>=n or c>a or c>b: print(""-1"") else: print(f)",constant,['implementation'],104
"a, b, c, n = map(int, input().split()) result = n - a - b + c print(result if result > 0 and c <= a and c <= b else -1)",constant,['implementation'],119
"a, b, c, n = map(int, input().split()) t = a+b-c if c > a or c > b: print(-1) exit() if n-t >= 1: print(n-t) else: print(-1)",constant,['implementation'],124
"a,b,c,n = map(int,input().split()) a-=c b-=c if a>=0 and b>=0: if (a+b+c)<n: n-=(a+b+c) print(n) else: print(-1) else: print(-1)",constant,['implementation'],128
"from collections import defaultdict, deque, Counter from sys import stdin, stdout from heapq import heappush, heappop import math import io import os import math import bisect def isPrime(x): for i in range(2, x): if i*i > x: break if (x % i == 0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3, int(math.sqrt(n))+1, 2): while n % i == 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p): res = 1 x = x % p if (x == 0): return 0 while (y > 0): if ((y & 1) == 1): res = (res * x) % p y = y >> 1 x = (x * x) % p return res def sieve(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def digits(n): c = 0 while (n > 0): n //= 10 c += 1 return c def ceil(n, x): if (n % x == 0): return n//x return n//x+1 def mapin(): return map(int, input().split()) a, b, c, n = mapin() d = a+b-c if(d > n-1 or c > a or c > b): print(-1) else: print(n-d)",constant,['implementation'],1185
"a,b,c,n = map(int,input().split()) if c > a or c > b or (a+b) - c >=n: print(-1) else: print(n -((a+b)-c))",constant,['implementation'],106
"a, b, c, n= map(int, input().split()) p = a + b - c if p <= n-1 and a - c >= 0 and b - c >= 0: print(n - p) else : print(-1)",constant,['implementation'],124
"from sys import stdin a, b, c, n = map(int, stdin.readline().split()) if c > a or c > b: print(-1) else: val = n - ((a - c) + (b - c)) - c print(val if val <= n and val > 0 else -1)",constant,['implementation'],181
"def f(ch): if ch=='0': return 0 else: return 1 U=[ [f(i) for i in list(input())], [f(i) for i in list(input())]] i=0 size=len(U[0]) ans=0 while i+1<size: if U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]>1: i+=1 continue elif U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]==1: U[0][i]=1 U[0][i+1]=1 U[1][i]=1 U[1][i+1]=1 ans+=1 else: U[0][i]=1 U[0][i+1]=1 U[1][i]=1 ans+=1 i+=1 print(ans)",constant,"['dp', 'greedy']",366
"from math import inf a=[0,0] a[0]=[str(c)for c in list(input().strip()) ] a[1]=[str(X) for X in list(input().strip())] an = [-inf,-inf,-inf] if a[0][0]==a[1][0]=='0': an[0]=0 elif a[0][0]!=a[1][0]: an[1]=0 x=0 for i in range(1,len(a[0])) : if an[0]==0: if a[0][i]==a[1][i]=='0': x+=1 an=[-inf,0 ,-inf] elif a[0][i]!=a[1][i]: x+=1 an=[-inf]*3 else: an = [-inf, -inf, -inf] elif an[1]==0: if a[0][i]==a[1][i]=='0': x+=1 an=[-inf,-inf ,-inf] elif a[0][i]!=a[1][i]: pass else: an=[-inf,-inf ,-inf] else: if a[0][i]==a[1][i]=='0': an=[0,-inf ,-inf] elif a[0][i]!=a[1][i]: an=[-inf,0,-inf] else: an=[-inf,-inf ,-inf] print(x)",constant,"['dp', 'greedy']",619
"from math import inf a=[0,0] a[0]=[str(c)for c in list(input().strip()) ] a[1]=[str(X) for X in list(input().strip())] an = [-inf,-inf,-inf] if a[0][0]==a[1][0]=='0': an[0]=0 elif a[0][0]!=a[1][0]: an[1]=0 x=0 for i in range(1,len(a[0])) : if an[0]==0: if a[0][i]==a[1][i]=='0': x+=1 an=[-inf,0 ,-inf] elif a[0][i]!=a[1][i]: x+=1 an=[-inf]*3 else: an = [-inf, -inf, -inf] elif an[1]==0: if a[0][i]==a[1][i]=='0': x+=1 an=[-inf,-inf ,-inf] elif a[0][i]!=a[1][i]: pass else: an=[-inf,-inf ,-inf] else: if a[0][i]==a[1][i]=='0': an=[0,-inf ,-inf] elif a[0][i]!=a[1][i]: an=[-inf,0,-inf] else: an=[-inf,-inf ,-inf] print(x)",constant,"['dp', 'greedy']",619
input_1 = input() input_2 = input() line_1 = [i for i in str(input_1)] line_2 = [i for i in str(input_2)] no = 0 for i in range(len(line_1) - 1): if line_1[i] != 'X' and line_2[i] != 'X': if line_1[i + 1] != 'X': no += 1 line_1[i] = 'X' line_2[i] = 'X' line_1[i + 1] = 'X' elif line_2[i + 1] != 'X': no += 1 line_1[i] = 'X' line_2[i] = 'X' line_2[i + 1] = 'X' elif line_1[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X': no += 1 line_1[i] = 'X' line_1[i + 1] = 'X' line_2[i + 1] = 'X' elif line_2[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X': no += 1 line_2[i] = 'X' line_1[i + 1] = 'X' line_2[i + 1] = 'X' print(no),constant,"['dp', 'greedy']",643
"S = [str(input()) for i in range(2)] S[0] = S[0].replace('X','1') S[1] = S[1].replace('X','1') n = len(S[0]) if n == 1: print(0) exit() INF = 10**18 from collections import defaultdict dp = defaultdict(lambda: -INF) for i in range(0, 2): for j in range(0, 2): dp[(i, j)] = -INF dp[(int(S[0][0]), int(S[1][0]))] = 0 for i in range(1, n): nx = defaultdict(lambda: -INF) for j in range(0, 2): for k in range(0, 2): nx[(int(S[0][i]), int(S[1][i]))] = max(nx[(int(S[0][i]), int(S[1][i]))], dp[(j, k)]) for j in range(0, 2): for k in range(0, 2): if dp[(j, k)] == -INF: continue if j == 0 and k == 0: if S[0][i] == '1' and S[1][i] != '1': nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1) if S[0][i] != '1' and S[1][i] == '1': nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1) if S[0][i] != '1' and S[1][i] != '1': nx[(1, 0)] = max(nx[(1, 0)], dp[(j, k)]+1) nx[(0, 1)] = max(nx[(0, 1)], dp[(j, k)]+1) nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1) if j == 0 and k == 1: if S[0][i] != '1' and S[1][i] != '1': nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1) if j == 1 and k == 0: if S[0][i] != '1' and S[1][i] != '1': nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1) dp = nx ans = -INF for k, v in dp.items(): ans = max(ans, v) print(ans)",constant,"['dp', 'greedy']",1201
"s = [list(input()), list(input())] ans = 0 l = len(s[0]) i = 0 while i < l - 1: a = (s[0][i], s[0][i + 1], s[1][i], s[1][i + 1]) if a.count(""0"") == 4: ans += 1 s[0][i + 1] = ""X"" i+=1 elif a.count(""0"") == 3: ans += 1 i += 2 else: i += 1 print(ans)",constant,"['dp', 'greedy']",246
"import itertools import bisect import math from collections import * import os import sys from io import BytesIO, IOBase ii = lambda: int(input()) lmii = lambda: list(map(int, input().split())) li = lambda: list(input()) mii = lambda: map(int, input().split()) msi = lambda: map(str, input().split()) def main(): a = li() b = li() n = len(a) ans = 0 for i in range(n): if a[i] == ""0"": ans += 1 if i - 1 >= 0 and a[i] == b[i] == b[i - 1]: a[i] = b[i] = b[i - 1] = ""X"" elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]: a[i] = b[i] = a[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i] == b[i + 1]: a[i] = b[i] = b[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]: a[i] = b[i + 1] = a[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i] == a[i + 1]: a[i] = b[i] = a[i + 1] = ""X"" else: ans -= 1 print(ans) pass BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda:",constant,"['dp', 'greedy']",1999
"import itertools import bisect import math from collections import * import os import sys from io import BytesIO, IOBase ii = lambda: int(input()) lmii = lambda: list(map(int, input().split())) li = lambda: list(input()) mii = lambda: map(int, input().split()) msi = lambda: map(str, input().split()) def main(): a = li() b = li() n = len(a) ans = 0 for i in range(n): if a[i] == ""0"": ans += 1 if i - 1 >= 0 and a[i] == b[i] == b[i - 1]: a[i] = b[i] = b[i - 1] = ""X"" elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]: a[i] = b[i] = a[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i] == b[i + 1]: a[i] = b[i] = b[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]: a[i] = b[i + 1] = a[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i] == a[i + 1]: a[i] = b[i] = a[i + 1] = ""X"" else: ans -= 1 print(ans) pass BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda:",constant,"['dp', 'greedy']",1999
"import itertools import bisect import math from collections import * import os import sys from io import BytesIO, IOBase ii = lambda: int(input()) lmii = lambda: list(map(int, input().split())) li = lambda: list(input()) mii = lambda: map(int, input().split()) msi = lambda: map(str, input().split()) def main(): a = li() b = li() n = len(a) ans = 0 for i in range(n): if a[i] == ""0"": ans += 1 if i - 1 >= 0 and a[i] == b[i] == b[i - 1]: a[i] = b[i] = b[i - 1] = ""X"" elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]: a[i] = b[i] = a[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i] == b[i + 1]: a[i] = b[i] = b[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]: a[i] = b[i + 1] = a[i + 1] = ""X"" elif i + 1 < n and a[i] == b[i] == a[i + 1]: a[i] = b[i] = a[i + 1] = ""X"" else: ans -= 1 print(ans) pass BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda:",constant,"['dp', 'greedy']",1999
b = [list(input()) for _ in range(2)] n = len(b[0]) ans = 0 a = [] for i in range(n): ai = 0 if b[0][i] == '0': ai += 1 if b[1][i] == '0': ai += 1 a.append(ai) prv = 0 for i in range(n): if a[i] == 0: prv = 0 elif a[i] == 1: if prv == 2: ans += 1 prv = 0 else: prv = 1 elif a[i] == 2: if prv == 2: ans += 1 prv = 1 elif prv == 1: ans += 1 prv = 0 else: prv = 2 print(ans),constant,"['dp', 'greedy']",371
"s=[list(input()) for i in range(2)] n=len(s[0]) cnt=0 for i in range(n-1): if s[0][i]==s[1][i]==s[0][i+1]==""0"": cnt+=1 s[0][i]=s[1][i]=s[0][i+1]=""X"" elif s[0][i]==s[1][i]==s[1][i+1]==""0"": cnt+=1 s[0][i]=s[1][i]=s[1][i+1]=""X"" elif s[0][i]==s[1][i+1]==s[0][i+1]==""0"": cnt+=1 s[0][i]=s[1][i+1]=s[0][i+1]=""X"" elif s[0][i+1]==s[1][i]==s[1][i+1]==""0"": cnt+=1 s[0][i+1]=s[1][i]=s[1][i+1]=""X"" print(cnt)",constant,"['dp', 'greedy']",395
"import re import sys exit=sys.exit from bisect import bisect_left as bsl,bisect_right as bsr from collections import Counter,defaultdict as ddict,deque from functools import lru_cache cache=lru_cache(None) from heapq import * from itertools import * from math import inf from pprint import pprint as pp enum=enumerate ri=lambda:int(rln()) ris=lambda:list(map(int,rfs())) rln=sys.stdin.readline rl=lambda:rln().rstrip('\n') rfs=lambda:rln().split() cat=''.join catn='\n'.join mod=1000000007 d4=[(0,-1),(1,0),(0,1),(-1,0)] d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)] figures=[ ((0,0),(0,1),(1,0)), ((0,0),(0,1),(1,1)), ((0,1),(1,0),(1,1)), ((0,0),(1,0),(1,1)), ] board=[] for _ in range(2): s=rl() board.append(list(s)) n=len(board[0]) ans=0 for j in range(n-1): for fig in figures: ok=1 for fi,fj in fig: if board[fi][j+fj]=='X': ok=0 break if not ok: continue ans+=1 for fi,fj in fig: board[fi][j+fj]='X' print(ans)",constant,"['dp', 'greedy']",930
"import re import sys exit=sys.exit from bisect import bisect_left as bsl,bisect_right as bsr from collections import Counter,defaultdict as ddict,deque from functools import lru_cache cache=lru_cache(None) from heapq import * from itertools import * from math import inf from pprint import pprint as pp enum=enumerate ri=lambda:int(rln()) ris=lambda:list(map(int,rfs())) rln=sys.stdin.readline rl=lambda:rln().rstrip('\n') rfs=lambda:rln().split() cat=''.join catn='\n'.join mod=1000000007 d4=[(0,-1),(1,0),(0,1),(-1,0)] d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)] figures=[ [(0,0),(0,1),(1,0)], [(0,0),(0,1),(1,1)], [(0,1),(1,0),(1,1)], [(0,0),(1,0),(1,1)], ] board=[] for _ in range(2): s=rl() board.append(list(s)) n=len(board[0]) ans=0 for j in range(n-1): for fig in figures: ok=1 for fi,fj in fig: if board[fi][j+fj]=='X': ok=0 break if not ok: continue ans+=1 for fi,fj in fig: board[fi][j+fj]='X' break print(ans)",constant,"['dp', 'greedy']",936
"import os import sys from io import BytesIO, IOBase def get(a,x): return (a[0][x] == ""0"") + (a[1][x] == ""0"") def main(): a=[input().rstrip() for _ in range(2)] n=len(a[0]) if n==1: print(0) else: dp=[[-1,-1,-1] for _ in range(n)] z=get(a,0) dp[0][z]=0 for i in range(1,n): z=get(a,i) if z==0: dp[i][0]=max(dp[i-1]) elif z==1: dp[i][0]=dp[i-1][2]+1 dp[i][1]=max(dp[i-1]) elif z==2: dp[i][0]=max(dp[i-1][1]+1,dp[i-1][2]+(i!=1)) dp[i][1]=dp[i-1][2]+1 dp[i][2]=max(dp[i-1]) print(max(dp[-1])) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",constant,"['dp', 'greedy']",1867
"arr1=str(input()) arr2=str(input()) arr1=arr1.encode() arr2=arr2.encode() arr1=bytearray(arr1) arr2=bytearray(arr2) n, tot=len(arr1), 0 for i in range(n-1): if arr1[i]==48 and arr1[i+1]==48 and arr2[i]==48: tot+=1 arr1[i]=49 arr1[i+1]=49 arr2[i]=49 elif arr1[i]==48 and arr2[i]==48 and arr2[i+1]==48: tot+=1 arr1[i]=49 arr2[i]=49 arr2[i+1]=49 elif arr2[i]==48 and arr2[i+1]==48 and arr1[i+1]==48: tot+=1 arr2[i]=49 arr2[i+1]=49 arr1[i+1]=49 elif arr1[i]==48 and arr1[i+1]==48 and arr2[i+1]==48: tot+=1 arr1[i]=49 arr1[i+1]=49 arr2[i+1]=49 print(tot)",constant,"['dp', 'greedy']",549
"import os import sys from io import BytesIO, IOBase import math from queue import Queue import collections import itertools import bisect import heapq import random def main(): pass BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while (n > 1): n //= 2 p += 1 return (p) def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: l.append(i) n = n / i if n > 2: l.append(int(n)) return (l) def primeFactorsCount(n): cnt=0 while n % 2 == 0: cnt+=1 n = n // 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: cnt+=1",constant,"['dp', 'greedy']",1999
"def ch_x(stri, n): res = '' for i in range(len(stri)): if i != n: res += stri[i] else: res += 'x' return res a = input() b = input() n = 0 for i in range(0, len(a)): if a[i] == '0' and b[i] == '0': c = [i-1, i+1] for e in c: if 0 <= e < len(a): if a[e] == '0': n += 1 a = ch_x(a, e) break if b[e] == '0': n += 1 b = ch_x(b, e) break a = ch_x(a, i) b = ch_x(b, i) print(n)",constant,"['dp', 'greedy']",371
"s = [input(), input()] n = len(s[0]) dp = [[0,0,0] for _ in range(n+1)] for i in range(n-2,-1,-1): dp[i] = [dp[i+1][0]]*3 vals = [0,0,0,0] if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i] == '0': vals[0] = dp[i+1][2] + 1 if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0': vals[1] = dp[i+2][0] + 1 if s[1][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0': vals[2] = dp[i+2][0] + 1 if s[0][i] == '0' and s[1][i] == '0' and s[1][i+1] == '0': vals[3] = dp[i+1][1] + 1 dp[i][1] = max(dp[i+1][0], vals[1]) dp[i][2] = max(dp[i+1][0], vals[2]) dp[i][0] = max(dp[i][1], dp[i][2], *vals) result = max(dp[0]) print(result)",constant,"['dp', 'greedy']",626
"l, r = [{'0': 1, 'X': 0}[c] for cc in zip(input(), input()) for c in cc], 0 for i in range(0, len(l) - 3, 2): s = 7 - sum(l[i:i + 4]) if s < 5: r += 1 l[i:i + s] = [0] * s print(r)",constant,"['dp', 'greedy']",180
"a = list(map(int, input().split())) b = list(map(int, input().split())) a1 = min(a[::2]) b1 = max(a[::2]) c1 = min(a[1::2]) d1 = max(a[1::2]) g = sum(b[::2]) / 4 h = sum(b[1::2]) / 4 r = abs(b[0] - g) + abs(b[1] - h) for i in range(a1, b1+1) : for j in range(c1, d1+1) : if abs(i-g) + abs(j-h) <= r: print(""YES"") exit() print(""NO"")",constant,['brute force'],331
"x1, y1, x2, y2, x3, y3, x4, y4 = map(int, input().split()) X1, Y1, X2, Y2, X3, Y3, X4, Y4 = map(int, input().split()) x = [x1, x2, x3, x4] y = [y1, y2, y3, y4] x = list(set(x)) y = list(set(y)) x.sort() y.sort() xl, xr = x yl, yr = y if xl <= X1 <= xr and yl <= Y1 <= yr: print('YES') exit() if xl <= X2 <= xr and yl <= Y2 <= yr: print('YES') exit() if xl <= X3 <= xr and yl <= Y3 <= yr: print('YES') exit() if xl <= X4 <= xr and yl <= Y4 <= yr: print('YES') exit() CX, CY = (X1+X2+X3+X4)//4, (Y1+Y2+Y3+Y4)//4 X1, X2, X3, X4 = X1-CX, X2-CX, X3-CX, X4-CX Y1, Y2, Y3, Y4 = Y1-CY, Y2-CY, Y3-CY, Y4-CY if xl <= CX <= xr and yl <= CY <= yr: print('YES') exit() A = 0 for X in (X1, X2, X3, X4): A = max(A, abs(X)) if abs(x1-CX)+abs(y1-CY) <= A: print('YES') exit() if abs(x2-CX)+abs(y2-CY) <= A: print('YES') exit() if abs(x3-CX)+abs(y3-CY) <= A: print('YES') exit() if abs(x4-CX)+abs(y4-CY) <= A: print('YES') exit() print('NO')",constant,['brute force'],923
"def inn1(s1): t=False for i in s1: if i[0]>=xmi1 and i[0]<=xma1 and i[1]>=ymi1 and i[1]<=yma1: t=True break if c2[0]>=xmi1 and c2[0]<=xma1 and c2[1]>=ymi1 and c2[1]<=yma1: t=True return t def inn2(s): t=False for i in s: if i[0]>=xmi2 and i[0]<=xma2 and i[1]>=ymi2 and i[1]<=yma2: t=True break if c1[0]>=xmi2 and c1[0]<=xma2 and c1[1]>=ymi2 and c1[1]<=yma2: t=True return t def conv(s): for i in range(4): x=s[i][0] y=s[i][1] s[i][0]=x+y s[i][1]=x-y return s aux=list(map(int,input().split())) s=[] for i in range(0,8,2): s.append([aux[i],aux[i+1]]) aux=list(map(int,input().split())) s1=[] for i in range(0,8,2): s1.append([aux[i],aux[i+1]]) st=set() for i in s: st.add(i[1]) xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1] for i in range(4): xma1=max(xma1,s[i][0]) xma2=max(xma2,s1[i][0]) xmi1=min(xmi1,s[i][0]) xmi2=min(xmi2,s1[i][0]) yma1=max(yma1,s[i][1]) yma2=max(yma2,s1[i][1]) ymi1=min(ymi1,s[i][1]) ymi2=min(ymi2,s1[i][1]) c1=[(xma1+xmi1)/2,(yma1+ymi1)/2] c2=[(xma2+xmi2)/2,(yma2+ymi2)/2] t=False if len(st)==2: t=True if t: t1=inn1(s1) s=conv(s) s1=conv(s1) xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1] for i in range(4): xma1=max(xma1,s[i][0]) xma2=max(xma2,s1[i][0]) xmi1=min(xmi1,s[i][0]) xmi2=min(xmi2,s1[i][0]) yma1=max(yma1,s[i][1]) yma2=max(yma2,s1[i][1]) ymi1=min(ymi1,s[i][1]) ymi2=min(ymi2,s1[i][1]) c1=[(xma1+xmi1)/2,(yma1+ymi1)/2] c2=[(xma2+xmi2)/2,(yma2+ymi2)/2] t2=inn2(s) else: t1=inn2(s) s=conv(s) s1=conv(s1) xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1] for i in range(4): xma1=max(xma1,s[i][0]) xma2=max(xma2,s1[i][0]) xmi1=min(xmi1,s[i][0]) xmi2=min(xmi2,s1[i][0]) yma1=max(yma1,s[i][1]) yma2=max(yma2,s1[i][1]) ymi1=min(ymi1,s[i][1]) ymi2=min(ymi2,s1[i][1]) c1=[(xma1+xmi1)/2,(yma1+ymi1)/2] c2=[(xma2+xmi2)/2,(yma2+ymi2)/2] t2=inn1(s1) if t1 or t2: print(""YES"") else: print(""NO"")",constant,['brute force'],1995
"def onseg(p,q,r): return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \ min(p[1], r[1]) <= q[1] <= max(p[1], r[1]) def orientation(p,q,r): val = (q[1] - p[1]) * (r[0] - q[0]) - \ (q[0] - p[0]) * (r[1] - q[1]) if (val == 0): return 0 return 1 if val > 0 else 2 def doint(p1, q1, p2, q2): o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) if o1 != o2 and o3 != o4: return True if o1 == 0 and onseg(p1, p2, q1): return True if o2 == 0 and onseg(p1, q2, q1): return True if o3 == 0 and onseg(p2, p1, q2): return True if o4 == 0 and onseg(p2, q1, q2): return True return False x0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split()) x4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split()) A = x0,y0 B = x1,y1 C = x2,y2 D = x3,y3 a = x4,y4 b = x5,y5 c = x6,y6 d = x7,y7 if doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \ doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \ doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \ doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \ doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \ doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d): print('YES') else: print('NO')",constant,['brute force'],1511
"a, b, c, d, e, f, g, h = map(int, input().split(' ')) i, j, k, l, m, n, o, p = map(int, input().split(' ')) s1 = [[a, b], [c, d], [e, f], [g, h]] s1.sort() bleft = s1[0] tr = s1[3] u, v, w, x = bleft[0], bleft[1], tr[0], tr[1] def check(xd, dx, u, v, w, x): return (u <= xd and xd <= w and v <= dx and dx <= x) god = [(i+k+m+o)/4, (j+l+n+p)/4] nani = 0 for moo in [[i, j], [k, l], [m, n], [o, p]]: if check(moo[0], moo[1], u, v, w, x): print(""Yes"") quit() if check(god[0], god[1], u, v, w, x): nani += 1 i, j = i+j, i-j k, l = k+l, k-l m, n = m+n, m-n o, p = o+p, o-p a, b = a+b, a-b c, d = c+d, c-d e, f = e+f, e-f g, h = g+h, g-h a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p = i, j, k, l, m, n, o, p, a, b, c, d, e, f, g, h s1 = [[a, b], [c, d], [e, f], [g, h]] s1.sort() bleft = s1[0] tr = s1[3] u, v, w, x = bleft[0], bleft[1], tr[0], tr[1] def check(xd, dx, u, v, w, x): return (u <= xd and xd <= w and v <= dx and dx <= x) god = [(i+k+m+o)/4, (j+l+n+p)/4] for moo in [[i, j], [k, l], [m, n], [o, p]]: if check(moo[0], moo[1], u, v, w, x): print(""Yes"") quit() if check(god[0], god[1], u, v, w, x): nani += 1 if nani == 2: print(""Yes"") quit() print(""No"")",constant,['brute force'],1160
"import sys def sol(a,b): for square in [a,b]: for i1 in range(4): i2 = (i1 + 1)%4 p1,p2 = square[i1],square[i2] norm = (p2[1]-p1[1],p1[0]-p2[0]) minA = maxA = minB = maxB = None for p in a: proj = norm[0] * p[0] + norm[1] * p[1] if minA == None or proj < minA: minA = proj if maxA == None or proj > maxA: maxA = proj for p in b: proj = norm[0] * p[0] + norm[1] * p[1] if minB == None or proj < minB: minB = proj if maxB == None or proj > maxB: maxB = proj if maxA < minB or maxB < minA: return False return True x11,y11,x12,y12,x13,y13,x14,y14 = list(map(int,sys.stdin.readline().strip().split(' '))) x21,y21,x22,y22,x23,y23,x24,y24 = list(map(int,sys.stdin.readline().strip().split(' '))) a = [(x11,y11), (x12,y12), (x13,y13), (x14,y14)] b = [(x21,y21), (x22,y22), (x23,y23), (x24,y24)] print([""NO"",""YES""][sol(a,b)])",constant,['brute force'],817
"p = [int(x) + 100 for x in input().strip().split()] d = [int(x) + 100 for x in input().strip().split()] minx = min(p[::2]) maxx = max(p[::2]) miny = min(p[1::2]) maxy = max(p[1::2]) grid = [[False] * 201 for _ in range(201)] for x in range(minx, maxx+1): for y in range(miny, maxy+1): grid[x][y] = True minx = min(d[::2]) maxx = max(d[::2]) avgx = sum(d[::2]) // 4 avgy = sum(d[1::2]) // 4 span = (maxx - minx) // 2 for x in range(minx, maxx+1): height = span - abs(x - avgx) for y in range(avgy - height, avgy + height + 1): if grid[x][y]: print('YES') exit() print('NO')",constant,['brute force'],572
"from collections import namedtuple Point = namedtuple(""Point"", ""x y"") Square = namedtuple(""Square"", ""left right top bottom"") Triangle = namedtuple(""Triangle"", ""left top"") a = [int(v) for v in input().split()] b = [int(v) for v in input().split()] a = [Point(a[i], a[i + 1]) for i in range(0, 8, 2)] b = [Point(b[i], b[i + 1]) for i in range(0, 8, 2)] bc = Point(sum(p.x for p in b) // 4, sum(p.y for p in b) // 4) bb = [None] * 4 for p in b: if p.x < bc.x: bb[0] = p elif p.y > bc.y: bb[1] = p elif p.x > bc.x: bb[2] = p elif p.y < bc.y: bb[3] = p else: assert False def in_sqr(sqr, pt): return sqr.left <= pt.x <= sqr.right and sqr.bottom <= pt.y <= sqr.top def in_tri(tri, pt): return ( tri.left.x <= pt.x <= tri.top.x and tri.left.y <= pt.y <= tri.top.y and pt.y - tri.left.y <= pt.x - tri.left.x ) def solve_sqr_tri(sqr, tri): return ( in_sqr(sqr, tri.left) or in_sqr(sqr, tri.top) or in_sqr(sqr, Point(tri.top.x, tri.left.y)) or in_tri(tri, Point(sqr.left, sqr.top)) or in_tri(tri, Point(sqr.right, sqr.top)) or in_tri(tri, Point(sqr.right, sqr.bottom)) or in_tri(tri, Point(sqr.left, sqr.bottom)) ) def rotate90(pt): return Point(-pt.y, pt.x) def iterate_rot(pt, times): for _ in range(times): pt = rotate90(pt) return pt def solve_sqr_sqr45(sqr_pts, sqr45): for i in range(4): tri_pts = sqr45[i], sqr45[(i + 1) % 4] left, top = [iterate_rot(pt, i) for pt in tri_pts] assert left.x < top.x assert left.y < top.y tri = Triangle(left=left, top=top) sqr = Square( left=min(p.x for p in sqr_pts), right=max(p.x for p in sqr_pts), top=max(p.y for p in sqr_pts), bottom=min(p.y for p in sqr_pts), ) if solve_sqr_tri(sqr, tri): return True sqr_pts = [rotate90(pt) for pt in sqr_pts] return False print([""NO"", ""YES""][solve_sqr_sqr45(a, bb)])",constant,['brute force'],1739
"one = list(map(int, input().split())) two = list(map(int, input().split())) one_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0])) two_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0])) ones = [one_[0], one_[2], one_[3], one_[1]] twos = [two_[1], two_[3], two_[2], two_[0]] L, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0] def in_one(point): x, y = point return L <= x <= R and D <= y <= U def in_two(point): x_0, y_0 = twos[0] def U_p(x_): return x_ + y_0 - x_0 def D_m(x_): return -x_ + y_0 + x_0 x_1, y_1 = twos[2] def U_m(x_): return -x_ + y_1 + x_1 def D_p(x_): return x_ + y_1 - x_1 x, y = point return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x) c_one = ((L + R) / 2, (U + D) / 2) c_two = ((twos[0][0] + twos[2][0]) / 2, (twos[1][1] + twos[3][1]) / 2) ones.append(c_one) twos.append(c_two) for p in ones: if in_two(p): print('YES') exit() for p in twos: if in_one(p): print('YES') exit() print('NO')",constant,['brute force'],991
"import math class Point: def __init__(self, x, y): self.x = x self.y = y def print(self): print(self.x, self.y) class Line: def __init__(self, p1, p2): self.p1 = p1 self.p2 = p2 def on(self, p): return distance(self.p1, p) + distance(self.p2, p) == distance(self.p1, self.p2) def print(self): self.p1.print() self.p2.print() class Square: def __init__(self, points): self.points = points def area(self): return distance(self.points[0], self.points[1]) ** 2 def lines(self): l = [] for i in range(3): l.append(Line(self.points[i], self.points[i + 1])) l.append(Line(self.points[3], self.points[0])) return l def midpoint(self): return Point(self.points[0].x / 2 + self.points[2].x / 2, self.points[0].y / 2 + self.points[2].y / 2) def print(self): for point in self.points: point.print() def distance(p1, p2): return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** .5 def tri_area(p1, p2, p3): a = distance(p1, p2) b = distance(p2, p3) c = distance(p3, p1) s = a + b + c s /= 2 return (s * (s - a) * (s - b) * (s - c)) ** .5 def inter(p, s): a = s.area() area_sum = tri_area(s.points[0], s.points[1], p) + tri_area(s.points[1], s.points[2], p) area_sum += tri_area(s.points[2], s.points[3], p) + tri_area(s.points[3], s.points[0], p) if abs(a - area_sum) < 0.000001: return True return False c1 = input().split("" "") c2 = input().split("" "") for i in range(8): c1[i] = int(c1[i]) c2[i] = int(c2[i]) c1p = [] c2p = [] for i in range(0, 8, 2): c1p.append(Point(c1[i], c1[i + 1])) c2p.append(Point(c2[i], c2[i + 1])) s1 = Square(c1p) s2 = Square(c2p) yes = False for point in s1.points: if inter(point, s2): if not yes: print(""YES"") yes = True for point in s2.points: if inter(point, s1): if not yes: print(""YES"") yes = True if inter(s1.midpoint(), s2): if not yes: print(""YES"") yes = True if inter(s2.midpoint(), s1): if not yes: print(""YES"") if not yes: print(""NO"")",constant,['brute force'],1858
"from collections import deque from sys import stdin, stderr lines = deque(line.strip() for line in stdin.readlines()) def nextline(): return lines.popleft() def types(cast, sep=None): return tuple(cast(x) for x in strs(sep=sep)) def ints(sep=None): return types(int, sep=sep) def strs(sep=None): return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep)) def signum(n): return 1 if n > 0 else 0 if n == 0 else -1 def range_includes(i, j): s = signum(j - i) return range(i, j + s, s) def main(): first = ints() aCoords = tuple(first[i:i+2] for i in range(0, 8, 2)) minX = min(aCoord[0] for aCoord in aCoords) minY = min(aCoord[1] for aCoord in aCoords) maxX = max(aCoord[0] for aCoord in aCoords) maxY = max(aCoord[1] for aCoord in aCoords) def inFirst(x, y): return x >= minX and x <= maxX and y >= minY and y <= maxY second = ints() bCoords = tuple(second[i:i+2] for i in range(0, 8, 2)) minSum = min(sum(bCoord) for bCoord in bCoords) maxSum = max(sum(bCoord) for bCoord in bCoords) minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords) maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords) def inSecond(x, y): return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff for aCoord in aCoords: if inSecond(*aCoord): return True for i in range(-1, 3): c1 = bCoords[i] c2 = bCoords[i + 1] for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])): if inFirst(x, y): return True return False if __name__ == '__main__': print(""YES"" if main() else ""NO"")",constant,['brute force'],1520
"class vec(): def __init__(self, x, y=None): if y is None: x, y = x self.x = x self.y = y def __mod__(self, other): return self.x*other.y - self.y*other.x def __sub__(self, other): return vec(self.x - other.x, self.y - other.y) def __repr__(self): return 'vec({}, {})'.format(self.x, self.y) def lines_cross(a, b, c, d): ab, ac, ad = b - a, c - a, d - a cd, ca, cb = d - c, a - c, b - c return (ab % ac) * (ab % ad) <= 0 and (cd % ca) * (cd % cb) <= 0 def rot(a): return vec(a.x-a.y, a.x+a.y) ax, ay, bx, by, cx, cy, dx, dy = map(int, input().split()) kx, ky, lx, ly, mx, my, nx, ny = map(int, input().split()) c, b, d, a = map(vec, sorted([(ax, ay), (bx, by), (cx, cy), (dx, dy)])) m, n, l, k = map(vec, sorted([(kx, ky), (lx, ly), (mx, my), (nx, ny)])) res = False s1 = [a, b, c, d] s2 = [k, l, m, n] for i in range(4): for j in range(4): if lines_cross(s1[i], s1[(i+1)%4], s2[j], s2[(j+1)%4]): res = True break if res: break if all([b.x <= p.x <= a.x and c.y <= p.y <= b.y for p in [k, l, m ,n]]): res = True if all([rot(l).x <= rot(p).x <= rot(k).x and rot(m).y <= rot(p).y <= rot(l).y for p in [a, b, c ,d]]): res = True print('YES' if res else 'NO')",constant,['brute force'],1154
"x1, y1, x2, y2, x3, y3, x4, y4 = [int(s) for s in input().split()] x11, y11, x22, y22, x33, y33, x44, y44 = [int(s) for s in input().split()] min_x1 = min(x1, x2, x3, x4) min_y1 = min(y1, y2, y3, y4) max_x1 = max(x1, x2, x3, x4) max_y1 = max(y1, y2, y3, y4) min_x11 = min(x11, x22, x33, x44) min_y11 = min(y11, y22, y33, y44) max_x11 = max(x11, x22, x33, x44) max_y11 = max(y11, y22, y33, y44) a = (max_x11 + min_x11) / 2 b = (max_y11 + min_y11) / 2 d2 = (max_x11 - min_x11) / 2 for x in range(min_x1, max_x1 + 1): for y in range(min_y1, max_y1 + 1): if abs(x - a) + abs(y - b) <= d2: print(""yes"") exit(0) print(""no"")",constant,['brute force'],617
"a,b=list(map(int,input().split())) c,d=(((b+1)//2)-1,(b-a-1)) print(c if d<0 else c-d if c>d else 0)",constant,['math'],100
"a = input() lst = [] a_1 = """" for i in range(len(a)): if a[i] != "" "": a_1 = a_1 + a[i] else: lst.append(int(a_1)) a_1 = """" lst.append(int(a_1)) if lst[1] > 2 * lst[0] - 1: print(0) else: countr = 0 if lst[1] % 2 == 1: countr = (lst[1] - 1) // 2 else: countr = (lst[1] - 2) // 2 if lst[1] > lst[0] + 1: countr = countr - lst[1] + lst[0] + 1 print(countr)",constant,['math'],353
"n,k=map(int,input().split()) if 2*n-1<k : print(0) elif k<=n+1 : if k%2: print(k//2) else: print(k//2-1) else: t1=k-n if k%2==0: print(k//2-t1) else: print(k//2-t1+1)",constant,['math'],166
"n,k=map(int,input().split()) if k>n+(n-1): print(0) else: if k<=n: print((k-1)//2) else: x=n-(k-n) print((x+1)//2)",constant,['math'],114
"import sys,os,io from sys import stdin from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop from bisect import bisect_left , bisect_right import math alphabets = list('abcdefghijklmnopqrstuvwxyz') def isPrime(x): for i in range(2,x): if i*i>x: break if (x%i==0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def SieveOfEratosthenes(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def countdig(n): c = 0 while (n > 0): n //= 10 c += 1 return c def si(): return input() def prefix_sum(arr): r = [0] * (len(arr)+1) for i, el in enumerate(arr): r[i+1] = r[i] + el return r def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') def power_set(L): cardinality=len(L) n=2 ** cardinality powerset = [] for i in range(n): a=bin(i)[2:] subset=[] for j in range(len(a)): if a[-j-1]=='1': subset.append(L[j]) powerset.append(subset) powerset_orderred=[] for k in range(cardinality+1): for w in powerset: if len(w)==k: powerset_orderred.append(w) return powerset_orderred def fastPlrintNextLines(a): print('\n'.join(map(str,a))) def sortByFirstAndSecond(A): A = sorted(A,key = lambda x:x[0]) A = sorted(A,key = lambda x:x[1]) return l",constant,['math'],1999
"import sys def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans def SieveOfEratosthenes(n): cnt = 0 prime = [True for i in range(n + 1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n + 1, p): prime[i] = False p += 1 for p in range(2, n + 1): if prime[p]: cnt += 1 return (cnt) def nCr(n, r): f = math.factorial return f(n) // f(r) // f(n - r) mod = int(1e9) + 7 def ssinp(): return sys.stdin.readline().strip() def iinp(): return int(input()) def nninp(): return map(int, sys.stdin.readline().strip().split()) def llinp(): return list(map(int, sys.stdin.readline().strip().split())) def p(xyz): print(xyz) def p2(a, b): print(a, b) import math n,k=nninp() if(k>=2*n): p(0) elif(k<=n): if(k%2==1): p(k//2) else: p(k//2-1) else: if(k%2==1): print(k//2-(k-n)+1) else: print(k//2 - (k - n))",constant,['math'],1359
"n,m = map(int,input().split()) if m<=n: print((m-1)//2) elif m>n: if (m-n) in range(1,n+1): if(n-(m-n))%2==0: print((n-(m-n))//2) else: print((n-(m-n))//2+1) else: print(0)",constant,['math'],172
"n,k = map(int,input().split()) if k>n+n-1: print(0) exit(0) if k-1<=n: ml = 1 mr = k-1 print((mr-ml+1)//2) else: mr = n ml = k-n print((mr-ml+1)//2)",constant,['math'],148
"n,k=map(int,input().split()) if n>=k: print((k-1)//2) elif n*2>k: print(n-k//2) else: print(0)",constant,['math'],94
"n,k=map(int,input().split()) if n>=k: print((k-1)//2) elif n*2>k: print(n-k//2) else: print(0)",constant,['math'],94
"n,k = map(int,input().split()) if(k - n >= n) : print(0) exit() if(k <= n): if(k%2): print(k//2) else : print(k//2-1) else: print(n-k//2)",constant,['math'],137
"n, k = (int(x) for x in input().split()) if k > n * 2 or k < 3: print(0) elif n >= k-1: print(k - k//2 - 1) else: print(n - k//2)",constant,['math'],129
"import sys import math from collections import OrderedDict def input(): return sys.stdin.readline().strip() def iinput(): return int(input()) def minput(): return map(int, input().split()) def listinput(): return list(map(int, input().split())) n,k=minput() if n==k:print(math.ceil(n/2)-1) elif k>2*n:print(0) else:print(min(n,k-1)-k//2)",constant,['math'],337
"n,k=map(int,input().split()) print(max(min(n,k-1)-k//2,0))",constant,['math'],58
"n,k=map(int,input().split()) if n>=k: print((k-1)//2) elif n*2>k: print(n-k//2) else: print(0)",constant,['math'],94
"import math n, k = map(int, input().split()) if k % 2 == 1: mink = (k + 1) // 2 else: mink = k // 2 + 1 print(max(0, min(k - 1, n) - mink + 1))",constant,['math'],143
"import math types_of_toy , toy_pair = map(int,input().split()) if(toy_pair <= types_of_toy ): print(math.floor( ( toy_pair - 1 ) /2)) elif( toy_pair <= 2*types_of_toy - 1): print(math.floor( ( types_of_toy +1 -(toy_pair - types_of_toy) )/ 2)) else: print(0)",constant,['math'],257
"import sys, string n, m = map(int, sys.stdin.readline().split()) print('4' * 2229) print('5' * 2228 + '6')",constant,"['constructive algorithms', 'math']",106
"import os,sys from io import BytesIO, IOBase def main(): n,m = map(int,input().split()) x = ((n-5)//4+((n-5)%4!=0)) if n <= 5: a,b = '5','5' else: a = '5'*(x+1) b = '4'*x+'5' print(a,b) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == '__main__': main()",constant,"['constructive algorithms', 'math']",1564
"n, m = map(int, input().split()) a = [] b = [] check = True while n >= 0: if check == True: a.append(5) n -= 5 b.append(4) check = False else: check = True a.append(4) n -= 4 b.append(5) if m != 1: a.append(5) b.append(6) else: a.append(5) b.append(5) print(*a, sep = """") print(*b, sep = """")",constant,"['constructive algorithms', 'math']",291
"n, m = map(int, input().split()) a = [] b = [] check = True while n >= 0: if check == True: a.append(5) n -= 5 b.append(4) check = False else: check = True a.append(4) n -= 4 b.append(5) a.append(5) b.append(5) print(*a, sep = """") print(*b, sep = """")",constant,"['constructive algorithms', 'math']",250
"n, m = map(int, input().split()) a = [] b = [] while n >= 0: a.append(4) n -= 4 b.append(5) a.append(5) b.append(5) print(*a, sep = """") print(*b, sep = """")",constant,"['constructive algorithms', 'math']",155
"n, m = map(int, input().split()) a = [] b = [] if n <= 8: a = [4] b = [5] while n > 8: a += [4,5] b += [5,4] n -= 8 print(*a + [5], sep="""") print(*b + [5], sep="""")",constant,"['constructive algorithms', 'math']",163
"n,m = map(int,input().split()) print(n*""8"") print((n-1)*""1""+""2"")",constant,"['constructive algorithms', 'math']",64
"n,m = map(int,input().split()) print(n*""8"") print((n-1)*""1""+""2"")",constant,"['constructive algorithms', 'math']",64
"def f(l): n,m = l return ['5'*282,'4'*281+'5'] l = list(map(int,input().split())) [print(r) for r in f(l)]",constant,"['constructive algorithms', 'math']",106
"a, b = map(int, input().split()) print(""1""*a) print(int(""1"" + (""0"" * a)) - int(""1"" * a))",constant,"['constructive algorithms', 'math']",88
a='4'*(300)+'5' b='5'*(301) print(a);print(b),constant,"['constructive algorithms', 'math']",45
"n,m=[int(x) for x in input().split()] ans1=""1""*1500 ans2=""8""*1499+""9"" print(ans1) print(ans2)",constant,"['constructive algorithms', 'math']",93
"n,m=[int(x) for x in input().split(' ')] print((n-1)*'4'+'5') print(n*'5')",constant,"['constructive algorithms', 'math']",74
"n, m = map(int, input().split()) a = 1 for i in range(n - 1): a *= 10 a += 1 b = 10 ** n - a print(a) print(b)",constant,"['constructive algorithms', 'math']",110
"for i in range (1000) : print(5,end="""") print() for i in range (999) : print(4,end="""") print(5)",constant,"['constructive algorithms', 'math']",95
print('4'*1131+'\n'+'5'*1130+'6'),constant,"['constructive algorithms', 'math']",33
a=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 b=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 print(a) print(b),constant,"['constructive algorithms', 'math']",403
"n,m = map(int, input().strip().split(' ')) a='8'*1129 + '9' b='1'*1130 print(a) print(b)",constant,"['constructive algorithms', 'math']",88
"n = int(input()) ax, ay = list(map(int, input().split(' '))) bx, by = list(map(int, input().split(' '))) cx, cy = list(map(int, input().split(' '))) if ((cx < ax) == (bx < ax)) and ((cy < ay) == (by < ay)): print('YES') else: print('NO')",constant,"['dfs and similar', 'graphs', 'implementation']",237
"n = int(input()) ax, ay = list(map(int, input().split())) bx, by = list(map(int, input().split())) cx, cy = list(map(int, input().split())) x = [ax, bx, cx] y = [ay, by, cy] x.sort() y.sort() if (x[1] != ax) and (y[1] != ay): print('YES') else: print('NO')",constant,"['dfs and similar', 'graphs', 'implementation']",256
"n = int(input()) x1, y1 = map(int, input().split()) x2, y2 = map(int, input().split()) x3, y3 = map(int, input().split()) if (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1): print(""YES"") else: print(""NO"")",constant,"['dfs and similar', 'graphs', 'implementation']",250
"n=int(input()) a,b=map(int,input().split()) b1,b2=map(int,input().split()) c1,c2=map(int,input().split()) b1-=a b2-=b c1-=a c2-=b if b1==0 or b2==0 or c1==0 or c2==0:print('NO') else: if b1*c1<0 or b2*c2<=0:print('NO') else:print('YES')",constant,"['dfs and similar', 'graphs', 'implementation']",236
"import sys import string from math import gcd import getpass import math from decimal import Decimal def ria(): return [int(i) for i in input().split()] if getpass.getuser() != 'frohenk': filename = 'half' else: sys.stdin = open('input.txt') n = ria()[0] x, y = ria() bx, by = ria() cx, cy = ria() x1, y1 = x - bx, y - by x2, y2 = x - cx, y - cy if abs(x2) == abs(y2): print('NO') exit(0) if math.copysign(x2, x1) != x2: print('NO') exit(0) if math.copysign(y2, y1) != y2: print('NO') exit(0) print('YES')",constant,"['dfs and similar', 'graphs', 'implementation']",505
"import sys if __name__ == '__main__': cin = sys.stdin n = int(next(cin)) ax, ay = map(int, next(cin).split()) bx, by = map(int, next(cin).split()) cx, cy = map(int, next(cin).split()) if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0: print('YES') else: print('NO')",constant,"['dfs and similar', 'graphs', 'implementation']",262
"n = int(input()) ax, ay = map(int, input().split()) bx, by = map(int, input().split()) cx, cy = map(int, input().split()) if bx < ax < cx or bx > ax > cx or by < ay < cy or cy < ay < by: print('NO') else: print('YES')",constant,"['dfs and similar', 'graphs', 'implementation']",217
"size = int(input()) x1, y1 = map(int, input().split()) x2, y2 = map(int, input().split()) x3, y3 = map(int, input().split()) if (y2 - y1) * (y3 - y1) > 0 and (x2 - x1) * (x3 - x1) > 0 and x1 + y1 != x3 + y3: print('YES') else: print('NO')",constant,"['dfs and similar', 'graphs', 'implementation']",238
"n = int(input()) ax, ay = map(int, input().split()) bx, by = map(int, input().split()) cx, cy = map(int, input().split()) if bx < ax < cx: print(""NO"") elif cx < ax < bx: print(""NO"") elif by < ay < cy: print(""NO"") elif cy < ay < by: print(""NO"") else: print(""YES"")",constant,"['dfs and similar', 'graphs', 'implementation']",262
"n = int(input()) ax, ay = map(int, input().split()) bx, by = map(int, input().split()) cx, cy = map(int, input().split()) if (bx > ax, by > ay) != (cx > ax, cy > ay): print(""NO"") exit(0) print(""YES"")",constant,"['dfs and similar', 'graphs', 'implementation']",199
"n = int(input()) (ax, ay) = [int(x) for x in input().split()] (bx, by) = [int(x) for x in input().split()] (cx, cy) = [int(x) for x in input().split()] if (bx < ax < cx) or (bx > ax > cx) or (by < ay < cy) or (by > ay > cy): print(""NO"") else: print(""YES"")",constant,"['dfs and similar', 'graphs', 'implementation']",255
"n=int(input()) ax, ay = map(int,input().split()) bx, by = map(int,input().split()) cx, cy = map(int,input().split()) if ((bx<ax and cx<ax) or (bx>ax and cx>ax)) and ((by<ay and cy<ay) or (by>ay and cy>ay)): print('YES') else: print('NO')",constant,"['dfs and similar', 'graphs', 'implementation']",237
"n = int(input()) bx, by = map(int, input().split()) ax, ay = map(int, input().split()) cx, cy = map(int, input().split()) num1 = ax > bx num3 = cx > bx num2 = ay > by num4 = cy > by if num1 == num3 and num2 == num4: print(""YES"") else: print(""NO"")",constant,"['dfs and similar', 'graphs', 'implementation']",246
"def x(a,b): if(a>b): return(1) else: return(0) n=int(input()) a1,a2=map(int,input().split()) b1,b2=map(int,input().split()) c1,c2=map(int,input().split()) if((a1-a2)==(b1-b2)): print(""NO"") elif((a1+a2)==(b1+b2)): print(""NO"") elif(a1==b1): print(""NO"") elif(a2==b2): print(""NO"") elif((a1-a2)==(c1-c2)): print(""NO"") elif((a1+a2)==(c1+c2)): print(""NO"") elif(a1==c1): print(""NO"") elif(a2==c2): print(""NO"") else: if((x(a1,b1)==x(a1,c1)) and (x(a2,b2)==x(a2,c2))): print(""YES"") else: print(""NO"")",constant,"['dfs and similar', 'graphs', 'implementation']",488
"n = int(input()) queen = list(map(int,input().split("" ""))) king = list(map(int,input().split("" ""))) target = list(map(int,input().split("" ""))) def done(): print(""NO"") exit() def complete(): print(""YES"") exit() if king[0] < queen[0]: if target[0] > queen[0]: done() if king[1] > queen[1]: if target[1] < queen[1]: done() complete() else: if target[1] > queen[1]: done() complete() else: if target[0] < queen[0]: done() if king[1] > queen[1]: if target[1] < queen[1]: done() complete() else: if target[1] > queen[1]: done() complete()",constant,"['dfs and similar', 'graphs', 'implementation']",532
"n = int(input()) ax,ay = list(map(int,input().split())) bx,by = list(map(int,input().split())) cx,cy = list(map(int,input().split())) if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0: print(""YES"") else: print(""NO"")",constant,"['dfs and similar', 'graphs', 'implementation']",212
"import sys next(sys.stdin) q_x, q_y = map(int, next(sys.stdin).rstrip().split()) k_x, k_y = map(int, next(sys.stdin).rstrip().split()) dest_x, dest_y = map(int, next(sys.stdin).rstrip().split()) def sign(x): return 1 if x >= 0 else -1 def which_square(x, y): return sign(x - q_x), sign(y - q_y) if which_square(k_x, k_y) == which_square(dest_x, dest_y): print(""YES"") else: print(""NO"")",constant,"['dfs and similar', 'graphs', 'implementation']",384
"def quadrant(x, y, rx, ry): if x>rx and y>ry: return 1 elif x<rx and y>ry: return 2 elif x<rx and y<ry: return 3 else: return 4 n = int(input()) qx, qy = map(int, input().split()) kx, ky = map(int, input().split()) cx, cy = map(int, input().split()) if quadrant(kx, ky, qx, qy) == quadrant(cx, cy, qx, qy): print(""YES"") else: print(""NO"")",constant,"['dfs and similar', 'graphs', 'implementation']",337
"n = int(input()) ax,ay = [int(s) for s in input().split()] bx,by = [int(s) for s in input().split()] cx,cy = [int(s) for s in input().split()] if ((bx-ax < 0 and cx-ax < 0 or bx-ax > 0 and cx-ax > 0) and (by-ay < 0 and cy-ay < 0 or by-ay > 0 and cy-ay > 0)): print(""YES"") else: print(""NO"")",constant,"['dfs and similar', 'graphs', 'implementation']",289
"N, K = map(int, input().split()) print((K+N-1)//N)",constant,['math'],50
"n, k = map(int, input().split()) print((k + n - 1) // n)",constant,['math'],56
"n, k = map(int, input().split()) h = k // n if h * n < k: h += 1 print(h)",constant,['math'],73
"a,b=map(int,input().split(' ')) print((b+a-1)//a)",constant,['math'],49
"n, k = map(int, input().split()) print((k + n - 1) // n)",constant,['math'],56
"n,k=map(int,input().split()) print(-(-k//n))",constant,['math'],44
"USE_STDIO = False if not USE_STDIO: try: import mypc except: pass def main(): n, k = map(int, input().split(' ')) ans = (k + n - 1) // n print(ans) if __name__ == '__main__': main()",constant,['math'],181
"n, k = map(int, input().split()) p = (k - 1) // n + 1 print(p)",constant,['math'],62
"n,k=map(int,input().split()) ans=k//n if(k%n): ans+=1 print(ans)",constant,['math'],64
"n, k = map(int , input().split()) s = k // n if k % n != 0: s += 1 print(s)",constant,['math'],75
"n, m = map(int, input().split()) print(m // n + (1 if m % n else 0))",constant,['math'],68
"n,k = map(int,input().split()) print(-(-k//n))",constant,['math'],46
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, **kwargs, file=sys.stderr) dprint('debug mode') except ModuleNotFoundError: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) N, K = getIntList() r= K//N if K%N!=0: r+=1 print(r)",constant,['math'],602
"a, b = map(int, input().split()) print((b+a-1)//a)",constant,['math'],50
"n, k = map(int, input().split()) print(k // n + (k % n != 0))",constant,['math'],61
"[n, k]=[int(i) for i in input().split()] print((k+n-1)//n)",constant,['math'],58
"a,b = (map(int,input().split())) print((b+a-1)//a)",constant,['math'],50
"n, k = map(int, input().split()) q = 2 * n + 1 p = k // n if k % n: print(p + 1) else: print(p)",constant,['math'],95
"q=int(input()) for e in range(q): x,y,k=map(int,input().split()) x,y=abs(x),abs(y) x,y=max(x,y),min(x,y) if(x%2!=k%2): k-=1 y-=1 if(x>k): print(-1) continue if((x-y)%2): k-=1 x-=1 print(k)",constant,['math'],188
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, **kwargs, file=sys.stderr) dprint('debug mode') except ModuleNotFoundError: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) Q, = getIntList() for _ in range(Q): N, M, K = getIntList() if max(N,M) >K: print(-1) continue r = K if N%2!= K%2: r-=1 if M%2!= K%2: r-=1 print(r)",constant,['math'],697
"q = int(input()) for i in range(q): x, y, k = map(int, input().split()) if x > y: x, y = y, x m = y d = y if (y - x) % 2 == 1: d -= 1 if k < m: print(-1) continue r = k - m if r % 2 != 0: r -= 1 if d != m: d += 1 else: d -= 1 d += r print(d)",constant,['math'],241
q = int(input()) otvet = [] for i in range(q): g = input().split() n = int(g[0]) m = int(g[1]) k = int(g[2]) if n < 0: n = -n if m < 0: m = -m if m > k or n > k: otvet.append(-1) elif m % 2 == k % 2 and n % 2 == k % 2: otvet.append(k) elif m % 2 == k % 2 or n % 2 == k % 2: otvet.append(k - 1) else: otvet.append(k - 2) for i in otvet: print(i),constant,['math'],344
"q = int(input()) for i in range(q): a, b, k = map(int, input().split()) if a < b: a, b, = b, a if a > k: print(-1) elif a % 2 == b % 2 != k % 2: print(k - 2) elif (a + b) % 2 != 0: print(k - 1) else: print(k)",constant,['math'],208
"q = int(input()) for i in range(q): n, m, k = map(int, input().split()) m, n = abs(m), abs(n) mx = max(m, n) remaining = k - mx if remaining < 0: print(-1) elif m == n == 0: if k == 1: print(-1) elif k % 2: print(k - 1) else: print(k) elif abs(m - n) % 2 == 0: if remaining % 2 == 0: print(k) else: print(k - 2) else: if not remaining: print(k - 1) elif remaining % 2 == 0: print(k - 1) else: print(k - 1)",constant,['math'],405
"from collections import deque from sys import stdin lines = deque(line.strip() for line in stdin.readlines()) def nextline(): return lines.popleft() def types(cast, sep=None): return tuple(cast(x) for x in strs(sep=sep)) def ints(sep=None): return types(int, sep=sep) def strs(sep=None): return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep)) def main(): T = int(nextline()) for testCase in range(1, T + 1): n, m, k = ints() min_k = max(n, m) if min_k > k: print(-1) continue if (n - m) % 2 == 0: if k % 2 == n % 2: print(k) continue print(k - 2) continue print(k - 1) if __name__ == '__main__': main()",constant,['math'],623
"q = int(input()) for _ in range(q): n, m, k = map(int, input().split()) if max([n, m]) > k: print(-1) else: if (n + m) % 2 == 0: if max([n, m]) % 2 != k % 2: print(k - 2) else: print(k) else: print(k - 1);",constant,['math'],205
"import math q = int(input()) for i in range(q): x, y, k = map(int, input().split()) if x > k or y > k: print(-1) else: if (x+y)%2 == 0: if (k-max(x,y)) % 2 == 0: print(k) else: print(k - 2) else: if (k-max(x,y)) % 2 == 0: print(k-1) else: print(k-1)",constant,['math'],249
"q = int(input()) for _ in range(q): n, m, k = map(int, input().split()) if k == 0: if n == 0 and m == 0: print(0) else: print(-1) elif k == 1: if max(abs(n), abs(m)) != 1: print(-1) elif abs(n) == abs(m) == 1: print(1) else: print(0) else: if max(abs(n), abs(m)) > k: print(-1) elif abs(n) == abs(m): if (k - abs(n)) % 2 == 0: print(k) else: print(k - 2) elif (max(abs(n), abs(m)) - min(abs(n), abs(m))) % 2 == 0: if (k - max(abs(n), abs(m))) % 2 == 0: print(k) else: print(k - 2) else: print(k - 1)",constant,['math'],499
"import sys input=sys.stdin.readline for _ in range(int(input())): n,m,k=map(int,input().split()) n=abs(n) m=abs(m) if max(n,m)>k: print(""-1"") else: bad1=((n+k)%2==1) bad2=((m+k)%2==1) print(k-bad1-bad2)",constant,['math'],202
"USE_STDIO = False if not USE_STDIO: try: import mypc except: pass def main(): q, = map(int, input().split(' ')) for _ in range(q): n, m, k = map(int, input().split(' ')) if n > k or m > k: print(-1) elif (n - m) % 2: print(k - 1) elif (n - k) % 2: print(k - 2) else: print(k) if __name__ == '__main__': main()",constant,['math'],309
"q=int(input()) Q=[list(map(int,input().split())) for i in range(q)] for n,m,k in Q: if n>k or m>k: print(-1) continue x=max(n,m)-min(n,m) y=k-max(n,m) if x%2==0 and y%2==0: print(k) elif x%2==0 and y%2==1: print(k-2) elif x%2==1 and y%2==0: print(k-1) elif x%2==1 and y%2==1: print(k-1)",constant,['math'],286
"n = int(input()) for i in range(n): a, b, c = [int(el) for el in input().split()] if ( a > c or b > c): print(-1) else: if (a% 2 + b % 2 == 1): print(c - 1) elif (a%2 == b%2 == c%2): print(c) else: print(c - 2)",constant,['math'],210
"Q = int(input()) src = [tuple(map(int,input().split())) for i in range(Q)] ans = [] for x,y,k in src: d = max(x,y) if (x+y)%2: ans.append(-1 if d > k else k-1) else: if d > k: ans.append(-1) else: ans.append(k-2 if (d+k)%2 else k) print(*ans,sep='\n')",constant,['math'],251
"def m(): [x, y, k] = [int(i) for i in input().split()] d=min(x, y) x-=d y-=d k-=d if k-x-y<0: print(-1) else: x+=y if x%2 > 0 and k%2>0: print(d+k-1) elif x%2 >0: print(d+k-1) elif k%2>0: print(d+k-2) else: print(d+k) n=int(input()) for i in range(n): m()",constant,['math'],255
"q = int(input()) for i in range(q): (x, y, k) = map(int, input().split()) if max(x, y) > k: print(-1) elif x == y and k == x + 1: print(k - 2) continue elif x % 2 == 1 and y % 2 == 1 and k % 2 == 0: print(k - 2) continue elif x % 2 == 0 and y % 2 == 0 and k % 2 == 1: print(k - 2) continue elif (x + y) % 2 == 0: print(k) else: print(k - 1)",constant,['math'],340
"n = int(input()) for q in range(n): x, y, k = map(int, input().split()) if max(x, y) > k: print(-1) else: if 0 == (x + y) % 2: if k % 2 == max(x, y) % 2: print(k) else: print(k - 2) else: print(k - 1)",constant,['math'],200
"def go(): n = int(input()) for i in range(n): a, b, d = [int(i) for i in input().split(' ')] if a > d or b > d: print(-1) elif a % 2 == b % 2: if a % 2 == d % 2: print(d) else: print(d - 2) else: if a % 2 == b % 2: if d % 2 == a % 2: print(d) else: print(d - 2) else: print(d - 1) go()",constant,['math'],285
"x, y, z, t1, t2, t3 = map(int, input().split()) ladder = abs(x - y) * t1 elevator = abs(x - z) * t2 + 3 * t3 + abs(x - y) * t2 if elevator > ladder: print(""NO"") else: print(""YES"")",constant,['implementation'],179
"x, y, z, t1, t2, t3 = list(map(int, input().split())) print(""YES"" if 3 * t3 + abs(x - z) * t2 + abs(x - y) * t2 <= abs(x - y) * t1 else ""NO"")",constant,['implementation'],141
"from sys import stdin, stdout from math import sin, tan, cos x, y, z, t1, t2, t3 = map(int, stdin.readline().split()) if abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3 <= abs(x - y) * t1: stdout.write('YES') else: stdout.write('NO')",constant,['implementation'],228
"x, y, z, t1, t2, t3 = map(int, input().split()) a = abs(x - y) * t1 b = abs(x - z) * t2 + abs(x - y) * t2 + t3 * 3 if a < b: print('NO') else: print('YES')",constant,['implementation'],155
"x, y, z, t1, t2, t3 = map(int, input().split()) stair = t1 * abs(x - y) lift = t2 * (abs(z - x) + abs(x - y)) + t3 * 3 print(""YES"" if lift <= stair else ""NO"")",constant,['implementation'],158
"x, y, z, t1, t2, t3 = [int(i) for i in input().split()] if abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1: print(""YES"") else: print(""NO"")",constant,['implementation'],140
"x, y, z, t1, t2, t3 = map(int, input().split()) lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3 stairs = t1 * abs(x - y) if lift <= stairs: print(""YES"") else: print(""NO"")",constant,['implementation'],178
"x, y, z, t1, t2, t3 = map(int, input().split()) d1 = abs(x - y) * t1 d2 = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3 if d2 <= d1: print('YES') else: print('NO')",constant,['implementation'],160
"x, y, z, t1, t2, t3 = map(int, input().split()) a=abs(x-y)*t1 b=abs(x-z)*t2+abs(x-y)*t2+3*t3 if b<=a:print(""YES"") else:print(""NO"")",constant,['implementation'],130
"x, y, z, t1, t2, t3 = map(int, input().split()) dp = abs(x - y) * t1; dl = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3; if dp < dl: print(""NO"") else: print(""YES"")",constant,['implementation'],161
"x, y, z, t1, t2, t3 = map(int, input().split()) tp = abs(x - y) * t1 pt = (abs(x - y) + abs(x - z)) * t2 + t3 + t3 + t3 if tp >= pt: print(""YES"") else: print(""NO"")",constant,['implementation'],163
"x,y,z,t1,t2,t3 = map(int, input().split()) stairs = abs(x - y) * t1 lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3 print('YES' if lift <= stairs else 'NO')",constant,['implementation'],164
"if __name__ == '__main__': x, y, z, t1, t2, t3 = [int(i) for i in input().split(' ')] lift_time = (abs(z-x) + abs(y-x))*t2 + 3*t3 stairs_time = abs(y-x)*t1 if lift_time <= stairs_time: print('YES') else: print('NO')",constant,['implementation'],215
"x, y, z, t1, t2, t3 = map(int, raw_input().split()) elev = t3*3 + t2*(abs(z-x) + abs(x-y)) stairs = t1*abs(x - y) if elev <= stairs: print('YES') else: print('NO')",constant,['implementation'],163
"x,y,z,t1,t2,t3=map(int,input().split()) if abs(x-y)*t1>=abs(x-z)*t2+t3*3+abs(x-y)*t2: print('YES') else: print('NO')",constant,['implementation'],116
"x, y, z, t1, t2, t3 = map( int, input().split() ) elevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3 stairs = t1 * abs( x - y ) if elevator > stairs: print( 'NO' ) else: print( 'YES' )",constant,['implementation'],190
"x,y,z,t1,t2,t3 = map(int, input().split()) time1 = abs(x-y)*t1 time2 = (abs(x-y)+abs(z-x))*t2+3*t3 if time2 <= time1: print(""YES"") else: print(""NO"")",constant,['implementation'],148
"x, y, z, t1, t2, t3, = map(int, input().split()) if abs(x-z)*t2 + abs((x-y))*t2 + t3*3 <= t1*abs((x-y)): print(""YES"") else: print(""NO"")",constant,['implementation'],135
"(x, y, z, t1, t2, t3) = map(int, input().split()) if 3 * t3 + t2 * (abs(z - x) + abs(x - y)) <= t1 * abs(x - y): print(""YES"") else: print(""NO"")",constant,['implementation'],143
"n,t=int(input()),1 while n>0: if n!=3: k=n//2+n%2 print((str(t)+' ')*k,end= '') n-=k t*=2 else: print(t,t,t*3) n=0",constant,"['constructive algorithms', 'math']",114
"n, m =map(int, input().split()) if m % n != 0: print( m // n + 1) else: print(m // n)",constant,"['greedy', 'implementation', 'math']",85
"n, m = map(int, input().split()) ans = m // n + min(1, m % n) print(ans)",constant,"['greedy', 'implementation', 'math']",72
"n, s = map(int, input().split()) print((s + n - 1) // n)",constant,"['greedy', 'implementation', 'math']",56
"m, a = map(int, input().split()) if (a % m == 0): print(a // m) else: print(a//m + 1)",constant,"['greedy', 'implementation', 'math']",85
"n, s = map(int, input().split()) if s % n == 0: print(s // n) else: print(s // n + 1)",constant,"['greedy', 'implementation', 'math']",85
"from sys import stdin, stdout from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial n, s = map(int, stdin.readline().split()) stdout.write(str((s + n - 1) // n))",constant,"['greedy', 'implementation', 'math']",178
"n, S = map(int, input().split()) print((S + n - 1) // n);",constant,"['greedy', 'implementation', 'math']",57
"n, s = map(int, input().split()) ans = s // n s %= n if s != 0: ans += 1 print(ans)",constant,"['greedy', 'implementation', 'math']",83
"n,s=map(int,input().split()) x=s//n if x*n<s: x+=1 print(x)",constant,"['greedy', 'implementation', 'math']",59
"from __future__ import division from sys import stdin, stdout def write(x): stdout.write(str(x) + ""\n"") n, s = map(int, stdin.readline().split()) if s % n == 0: write(s // n) else: write(s // n + 1)",constant,"['greedy', 'implementation', 'math']",198
"n, s = list(map(int, input().split())) num_1 = s // n if s % n == 0: print(num_1) else: print(num_1 + 1)",constant,"['greedy', 'implementation', 'math']",104
"n,s=map(int,input().split()) count=0 for i in range(n): count+=(s//(n-i)) s-=(s//(n-i))*(n-i) print(count)",constant,"['greedy', 'implementation', 'math']",106
"import math as ma import sys from sys import exit from decimal import Decimal as dec from itertools import permutations def li(): return list(map(int , input().split())) def num(): return map(int , input().split()) def nu(): return int(input()) n,s=num() cc=0 for i in range(n,0,-1): cc+=s//i s=s%i print(cc)",constant,"['greedy', 'implementation', 'math']",308
"n, s = map(int, input().split()) print((s + n - 1) // n)",constant,"['greedy', 'implementation', 'math']",56
"n, s = map(int, input().split()) big = s // n r = s - big * n if r > 0: print(big + 1) else: print(big)",constant,"['greedy', 'implementation', 'math']",103
"n,s = map(int,input().split()) if s%n==0: print(s//n) else: print(s//n+1)",constant,"['greedy', 'implementation', 'math']",73
"n, s = map(int, input().split(' ')) if(s <= n): sol = 1 else: sol = s // n if(s % n): sol += 1 print(sol)",constant,"['greedy', 'implementation', 'math']",105
"from math import * k,n=map(int,input().split()) print(ceil(n/k))",constant,"['greedy', 'implementation', 'math']",64
"n, s = map(int, input().split()) print((s + n - 1) // n)",constant,"['greedy', 'implementation', 'math']",56
"from itertools import* moves =[(x*mx,y*my) for mx,my,(x,y) in product( (-1,1),(-1,1), ( (1,2),(2,1) ) )] def ac(l,x): if l==0: return 0 return l[x] if 0<=x<len(l) else 0 def work(): x=1 while x: x=0 for r in range(len(a)): for c in range(len(a[0])): if not a[r][c] and sum(ac(ac(a,r+dr),c+dc) for dr,dc in moves)>=4: a[r][c]=1 x=1 for n in [int(input())]: cand=set() for i in range(1000): for x,y in ( (0,i),(i,0),(i,1),(-i,0),(-i,1),(0,-i) ): if x==0 or x%3!=1: if n==len(cand): break cand.add((x,y)) assert len(cand)==n for x,y in cand: print(x,y)",constant,['constructive algorithms'],549
"n, m, k, l = map(int, input().split()) cnt = (k + l + m - 1) // m if cnt * m > n: print(-1) else: print(cnt)",constant,['math'],108
"n, m, k, l = map(int, input().split()) need = k + l if need % m == 0 and need <= n: print(need // m) else: x = need // m + 1 if x * m > n: print(-1) else: print(x)",constant,['math'],163
"n, m, k, l = map(int, input().split()) if (k+l+m-1)//m*m > n: print(-1) else: print((k+l+m-1)//m)",constant,['math'],97
"n, m, k, l = map(int, input().split()) if k + l > n: print(-1) else: x = (k + l) // m + (1 if (k + l) % m != 0 else 0) if x * m > n: print(-1) else: print(x)",constant,['math'],157
"n,m,k,l=map(int,input().split()) c=(k+l)//m if (k+l)%m!=0: c+=1 if n>=m*c: print(c) else : print(-1)",constant,['math'],100
"n, m, k, l = map(int, input().split()) k += l x = (k + m - 1) // (m); if m * x > n: print(-1) else: print(x)",constant,['math'],108
"n, m, k, l = list(map(int, input().split())) if (l > n - k): print(-1) else: am = ((l + k) // m + bool((l + k) % m)) if am * m > n: print(-1) else: print(am)",constant,['math'],157
"N, M, K, L = map(int, input().split()) if N < M or K + L > N: print(-1) else: print((L + K - 1) // M + 1 if ((L + K - 1) // M + 1) * M <= N else -1)",constant,['math'],148
"n, m, k, l = map(int, input().split()) required = k + l per_friend = (required + m - 1) // m if (m * per_friend > n): print(-1) else: print(per_friend)",constant,['math'],151
"import math if __name__ == '__main__': n, m, k, l = map(int, input().split()) one_friend = (k + l) // m + int((k + l) % m != 0) if one_friend * m > n: print(-1) else: print(one_friend)",constant,['math'],184
"import math def main(): n,m,k,l = map(int, input().strip().split()) t = int(k + l + m - 1) // m if k + l > n: print(-1) return if m * t > n: print(-1) return print(t) if __name__ == '__main__': main()",constant,['math'],200
"n, m, k, l = [int(x) for x in input().split()] if (l + k) % m == 0: c = (l + k)//m else: c = (l + k)//m + 1 if m * c > n: print(-1) else: print(c)",constant,['math'],146
"n, m, k, l = map(int, input().split()) if m > n: print(-1) elif l + k > n: print(-1) else: s = (l + k) // m + bool((l + k) % m) if s * m > n: print(-1) else: print(s)",constant,['math'],166
"n, m, k, l = map(int, input().split()) if m > n or (l + k + m - 1) // m * m > n: print(-1) else: x = (l + k + m - 1) // m print(x)",constant,['math'],130
"import math, sys def mp(): return list(map(int, input().split())) def main(): n, m, k, l = mp() ost = n - k need = (l + k) if ost < l or need > n: print(-1) return ans = (l + k - 1) // m + 1 if ans * m - k >= l and ans * m <= n: print(ans) else: print(-1) deb = 0 if deb: file = open(""input.txt"", ""r"") input = file.readline else: input = sys.stdin.readline main() if deb: file.close()",constant,['math'],384
"import math n, m, k, l = map(int, input().split()) x = (l + k) // m if x * m < l + k: x += 1 assert x * m >= l + k if m * x > n: print(-1) else: print(x)",constant,['math'],153
"n,m,k,l=map(int,input().split()) q=(l+k-1)//m+1 if q*m>n:print(-1) else:print(q)",constant,['math'],80
"def main(): n, m, k, l = map(int, input().split()) d = (l + k) // m if (l + k) % m: d += 1 if m * d > n or n - k < l: print(-1) else: print(d) main()",constant,['math'],149
"N, M, K, L = list(map(int, input().split())) each = (K + L) // M if (K + L) % M != 0: each += 1 if each * M > N: print(-1) else: print(each)",constant,['math'],140
"n = int(input()) x, y = map(int, input().split()) white = max(x - 1, y - 1) black = max(n - x, n - y) print(""White"" if white <= black else ""Black"")",constant,"['implementation', 'math']",147
"n=int(input()) a,b=map(int,input().split()) white=abs(a-1)+abs(b-1) black=abs(n-a)+abs(n-b) if white<=black: print(""White"") else: print(""Black"")",constant,"['implementation', 'math']",144
"n = int(input()) x, y = list(map(int,input().split())) if x-1+y-1 <= n-x+n-y: print('White') else: print('Black')",constant,"['implementation', 'math']",113
"n = int(input()) x,y = map(int,input().split()) if max(x-1,y-1) > max(n-x,n-y): print(""Black"") else: print(""White"")",constant,"['implementation', 'math']",115
"n = int(input()) x, y = map(int, input().split()) na = abs(x - 1) + abs(y - 1) nb = abs(n - x) + abs(n - y) if na <= nb: print(""white"") else: print(""black"")",constant,"['implementation', 'math']",156
"def solve(x, y, n): return ""White"" if (x-1 + y-1) <= (n-x + n-y) else ""Black"" def main(): n = int(input()) x, y = [int(i) for i in input().split()] print(solve(x, y, n)) main()",constant,"['implementation', 'math']",176
"n = int(input()) x,y = map(int,input().split()) num = x - 1 + y - 1 num2 = n - x + n - y ans = num <= num2 if ans: print(""White"") else: print(""Black"")",constant,"['implementation', 'math']",150
"n = int(input()) x, y = list(map(int, input().split())) d0 = max(x - 1, y - 1) d1 = max(n - x, n - y) print('White' if d0 <= d1 else 'Black')",constant,"['implementation', 'math']",141
"n = int(input()) x, y = [int(i) for i in input().split()] d1 = abs(x - 1) + abs(y - 1) d2 = abs(n - x) + abs(n - y) print(""White"" if d1 <= d2 else ""Black"")",constant,"['implementation', 'math']",155
"n = int(input()) x, y = map(int, input().split()) ans = (x - 1) + (y - 1) <= (n - x) + (n - y) print('White' if ans else 'Black')",constant,"['implementation', 'math']",129
"n = int(input()) x, y = map(int, input().split()) if abs(x - 1) + abs(y - 1) <= abs(x - n) + abs(y - n): print('White') else: print('Black')",constant,"['implementation', 'math']",140
"import sys import string from math import gcd import getpass import math from decimal import Decimal import pprint def ria(): return [int(i) for i in input().split()] if getpass.getuser() != 'frohenk': filename = 'half' else: sys.stdin = open('input.txt') n = ria()[0] x, y = ria() d1 = abs(1 - x) + abs(1 - y) d2 = abs(n - x) + abs(n - y) if d1<=d2: print('White') else: print('Black')",constant,"['implementation', 'math']",386
"from bisect import bisect_right as br from bisect import bisect_left as bl from math import * def isprime(n): n = abs(int(n)) if n < 2: return False if n == 2: return True if not n & 1: return False for x in range(3, int(n**0.5) + 1, 2): if n % x == 0: return False return True def mhd(a,b,x,y): return abs(a-x)+abs(b-y) n = int(input()) a,b = map(int,input().split()) if(mhd(a,b,1,1)<=mhd(a,b,n,n)): print('White') else: print('Black')",constant,"['implementation', 'math']",436
"n = int(input()) x, y = map(int, input().split()) def d(a, b): return a + b if d(x-1, y-1) <= d(n-x, n-y): print(""White"") else: print(""Black"")",constant,"['implementation', 'math']",142
"n=int(input()) x,y=map(int,input().split()) val1=max(x,y)-1 val2=n-min(x,y) if(val1<=val2): print('White') else: print('Black')",constant,"['implementation', 'math']",127
"def go(): n = int(input()) x, y = [int(i) for i in input().split(' ')] a = 1 + 1 b = n + n c = x + y distance_w = c - a distance_b = b - c if distance_w == distance_b: return 'White' if distance_w < distance_b: return 'White' return 'Black' print(go())",constant,"['implementation', 'math']",252
"n = int(input()) x, y = list(map(int, input().strip().split())) if n-x + n-y >= x-1 + y-1: print(""White"") else: print(""Black"")",constant,"['implementation', 'math']",126
"q = int(input()) a,s = map(int,input().split()) if ((a+s-2)<=(q+q-a-s)): print(""White"") else: print('Black')",constant,"['implementation', 'math']",108
"n=int(input()) x,y=map(int,input().split()) d1=max(x-1,y-1) d2=max(n-x,n-y) if d1<=d2: print(""White"") else: print(""Black"")",constant,"['implementation', 'math']",122
"from math import ceil n, k = map(int, input().split()) print(ceil((8 * n) / k) + ceil((5 * n) / k) + ceil((2 * n) / k))",constant,['math'],119
"n,k=map(int,input().split()) ans=0 ans+=(2*n)//k + bool((2*n)%k!=0) ans+=(5*n)//k + bool((5*n)%k!=0) ans+=(8*n)//k + bool((8*n)%k!=0) print(ans)",constant,['math'],144
"from sys import stdin, stdout from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial n, k = map(int, stdin.readline().split()) stdout.write(str((n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k))",constant,['math'],228
"n, k = map(int, input().split()) a, b, c = 2 * n, 5 * n, 8 * n ceil = lambda x, y: (x + y - 1) // y print(ceil(a, k) + ceil(b, k) + ceil(c, k))",constant,['math'],143
"n, k = map(int, input().split()) r_n = n * 2 g_n = n * 5 b_n = n * 8 t = 0 t += r_n // k if r_n % k != 0: t += 1 t += g_n // k if g_n % k != 0: t += 1 t += b_n // k if b_n % k != 0: t += 1 print(t)",constant,['math'],197
"N, K= map(int, input().split()) Rcnt = N * 2 Gcnt = N * 5 Bcnt = N * 8 res = (Rcnt + K - 1) // K + (Gcnt + K - 1) //K + (Bcnt + K -1 ) // K print(res)",constant,['math'],150
"import sys from math import floor, ceil input = sys.stdin.readline n, k = map(int, input().split()) print(ceil((n*2)/k) + ceil((n*5)/k) + ceil((n*8)/k))",constant,['math'],152
"from math import ceil n, k = map(int, input().split()) print(ceil(n*2/k) + ceil(n*5/k) + ceil(n*8/k))",constant,['math'],101
"from __future__ import division from sys import stdin, stdout from math import ceil def write(x): stdout.write(str(x) + ""\n"") n, k = map(int, stdin.readline().split()) red = 2 * n green = 5 * n blue = 8 * n need = int(ceil(red / k)) + int(ceil(green / k)) + int(ceil(blue / k)) write(need)",constant,['math'],289
"import sys, math def mp(): return list(map(int, input().split())) def main(): n, k = mp() a = [2, 5, 8] s = 0 for i in a: s += (n * i - 1) // k + 1 print(s) debug = 0 if debug: file = open(""input.txt"", ""r"") input = file.readline main() if debug: file.close()",constant,['math'],258
"n,k = map(int, input().split()) a = 2*n b = 5*n c = 8*n print((a+k-1)//k + (b+k-1)//k + (c + k -1) // k)",constant,['math'],104
"n,k = map(int,input().split()) print((2*n + k - 1) // k + (5*n+k-1) // k + (8*n+k-1)//k)",constant,['math'],88
"from math import ceil n, k = map(int, input().split()) cou = 0 cou += ceil(n*2/k) cou += ceil(n*5/k) cou += ceil(n*8/k) print(cou)",constant,['math'],130
"from math import ceil n,k = map(int,input().split()) print(ceil(n*2/k)+ceil(n*5/k)+ceil(n*8/k))",constant,['math'],95
"from math import ceil n, k = list(map(int, input().strip().split())) r = 2*n g = 5*n b = 8*n print(ceil(r/k)+ceil(g/k)+ceil(b/k))",constant,['math'],129
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) n, k = mi() ans = (n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k print(ans)",constant,['math'],196
"n, k = map(int, input().split()) print((n*2)//k + bool((n*2)%k) + (n*5)//k + bool((n*5)%k) + (n*8)//k + bool((n*8)%k))",constant,['math'],118
"n, k = map(int, input().split()) print((8 * n + k - 1) // k + (5 * n + k - 1) // k + (2 * n + k - 1) // k)",constant,['math'],106
"n,k=map(int,input().split()) print((-(-n*2//k))+(-(-n*5//k))+(-(-n*8//k)))",constant,['math'],74
"def s(k): if k % 2 == 0: return k // 2 else: return - (k + 1) // 2 for i in range(int(input())): l, r = map(int, input().split()) print(s(r) - s(l - 1))",constant,['math'],152
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) for _ in range(ii()): l, r = mi() l -= 1 sr = r // 2 + (r % 2) * -r sl = l // 2 + (l % 2) * -l print(sr - sl)",constant,['math'],210
"def main(): def calc(x): if x & 1: return -x + calc(x - 1) return x // 2 n = int(input()) for i in range(n): a, b = map(int, input().split()) print(calc(b) - calc(a - 1)) main()",constant,['math'],177
"input = raw_input def f(n): t = (n + 1) // 2 return t if n % 2 == 0 else -t for i in range(int(input())): le, rg = map(int, input().split()) print(f(rg) - f(le - 1))",constant,['math'],165
"from sys import stdin, stdout from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial def get(l, r): if l > r: return 0 if l & 1: return (-l - r) * (r - l + 2) // 4 else: return (l + r) * (r - l + 2) // 4 def solution(l, r): l1, l2, r1, r2 = l, l, r, r if l & 1: l2 += 1 else: l1 += 1 if r & 1: r2 -= 1 else: r1 -= 1 return get(l1, r1) + get(l2, r2) q = int(stdin.readline()) for i in range(q): l, r = map(int, stdin.readline().split()) stdout.write(str(solution(l, r)) + '\n')",constant,['math'],492
"n = int(input()) for i in range(n): a,b = map(int, input().split()) a1 = a if a % 2 == 0: a1 += 1 b1 = b if b % 2 == 0: b1 -= 1 n = 0 if a1 <= b1: num = (b1 - a1) // 2 + 1 n = num * (b1 + a1) // 2 n *= -1 b2 = b a2 = a if a % 2 == 1: a2 += 1 if b % 2 == 1: b2 -= 1 n2 = 0 if a2 <= b2: num = (b2 - a2) // 2 + 1 n2 = num * (b2 + a2) // 2 print(n + n2)",constant,['math'],349
"import math n = int(input()) for i in range(n): l,r = [*map(int, input().split())] l-=1 war1 = math.ceil(l/2) if(l%2 == 1): war1 = -1*war1 war2 = math.ceil(r/2) if(r%2 == 1): war2 = -1*war2 print(war2-war1)",constant,['math'],206
"import sys, math def mp(): return list(map(int, input().split())) def ss(x): return x * (x + 1) // 2 def sol(x): if x == 0: return 0 res = ss(x // 2) * 2 res1 = ss(x) - res return res - res1 def main(): q = int(input()) for i in range(q): l, r = mp() print(sol(r) - sol(l - 1)) debug = 0 if debug: file = open(""input.txt"", ""r"") input = file.readline main() if debug: file.close()",constant,['math'],379
"q = int(input()) for i in range(q): l, r = map(int, input().split()) if l % 2 == 0: count = -((r - l + 1) // 2) else: count = ((r - l + 1) // 2) if (r - l + 1) % 2 == 0: print(count) else: if r % 2 == 0: print(count + r) else: print(count - r)",constant,['math'],243
"n = int(input()) for _ in range(n): l, r = map(int, input().split()) if (l - r) % 2 == 1: if l % 2: print((r-l+1)//2) else: print(-((r-l+1)//2)) else: ans = 0 if l % 2: ans = ans + (r-l)//2 else: ans = ans + -(r-l)//2 if r % 2: ans = ans - r else: ans = ans + r print(ans)",constant,['math'],272
"import sys input = sys.stdin.readline Q=int(input()) LR=[list(map(int,input().split())) for i in range(Q)] def SUM(i): plus=i//2 minus=(i+1)//2 P=(2+2*plus)*plus//2 M=(1+2*minus-1)*minus//2 return P-M for l,r in LR: print(SUM(r)-SUM(l-1))",constant,['math'],238
"import math import collections import bisect import heapq import time import itertools import sys Q = int(input()) ans = [] for i in range(Q): l, r = map(int, input().split()) if l % 2 == 0 and r % 2 == 0: ans.append((r-l)//2 + l) elif l % 2 == 1 and r % 2 == 0: ans.append((r-l+1)//2) elif l % 2 == 1 and r % 2 == 1: ans.append(0-(r-l)//2-l) else: ans.append(0-(r-l+1)//2) print('\n'.join(map(str, ans)))",constant,['math'],405
"cs = int(input()) for c in range(cs): l, r = map(int, input().split()) if l%2 == 0 and r%2 == 0: print((r - l) // 2 + l) if l%2 == 1 and r%2 == 0: print((r - l + 1) // 2) if l%2 == 0 and r%2 == 1: print(-(r - l + 1) // 2) if l%2 == 1 and r%2 == 1: print(-(r - l) // 2 - l)",constant,['math'],272
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, file=sys.stderr) dprint('debug mode') except Exception: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) N, = getIntList() for _ in range(N): l,r = getIntList() n = (r-l+1) z = n//2 if l%2==0: z*=-1 if n%2==1: if r%2==0: z += r else: z-=r print(z)",constant,['math'],672
"Q = int(input()) def getsum(N): A = (N+1)//2 r1 = -A + A*(A+1) B = N // 2 r2 = B*(B+1) return -r1 + r2 while Q != 0: L, R = map(int, input().split()) print(getsum(R) - getsum(L-1)) Q -= 1",constant,['math'],187
"def getsum(a, b): if a % 2 == 0: return (a + b) * ((b - a) // 2 + 1) // 2 else: return -(a + b) * ((b - a) // 2 + 1) // 2 q = int(input()) for i in range(q): l, r = map(int, input().split()) if l == r: print(l if l % 2 == 0 else -l) else: print( getsum(l if l % 2 == 1 else l + 1, r if r % 2 == 1 else r - 1) + getsum(l if l % 2 == 0 else l + 1, r if r % 2 == 0 else r - 1) )",constant,['math'],375
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools sys.setrecursionlimit(10**7) inf = 10**20 eps = 1.0 / 10**13 mod = 10**9+7 dd = [(-1,0),(0,1),(1,0),(0,-1)] ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)] def LI(): return [int(x) for x in sys.stdin.readline().split()] def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()] def LF(): return [float(x) for x in sys.stdin.readline().split()] def LS(): return sys.stdin.readline().split() def I(): return int(sys.stdin.readline()) def F(): return float(sys.stdin.readline()) def S(): return input() def pf(s): return print(s, flush=True) def main(): n = I() aa = [LI() for _ in range(n)] r = [] for a,b in aa: al = a + (1-a%2) ar = b - (1-b%2) sa = (ar-al) // 2 + 1 tr = -(al+ar) * sa // 2 bl = a + (a%2) br = b - (b%2) sb = (br-bl) // 2 + 1 tr += (bl+br) * sb // 2 r.append(tr) return ""\n"".join(map(str,r)) print(main())",constant,['math'],949
"for _ in range(int(input())): i, j = map(int, input().split()) i -= 1 print((j//2 * (j//2 + 1) - i//2 * (i//2 + 1)) - (((j - j//2) * (j - j//2)) - ((i - i//2) * (i - i//2))))",constant,['math'],174
"q = int(input()) for _ in range(q): l, r = map(int, input().split()) sign = -1 if l % 2 else 1 if (r-l) % 2: print(-sign*(r-l+1)//2) else: print(sign*(l+(r-l)//2))",constant,['math'],163
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) def pre(x, y): w = x * (y // 2) + (y % 2) * (x + 1) // 2 b = x * (y // 2) + (y % 2) * x // 2 assert w + b == x * y return w def count(x1, y1, x2, y2): w = pre(x2, y2) + pre(x1 - 1, y1 - 1) - pre(x2, y1 - 1) - pre(x1 - 1, y2) b = (x2 - x1 + 1) * (y2 - y1 + 1) - w return w, b for t in range(ii()): n, m = mi() x1, y1, x2, y2 = mi() x3, y3, x4, y4 = mi() w = pre(m, n) b = m * n - w wc, bc = count(x1, y1, x2, y2) w -= wc b -= bc w += (x2 - x1 + 1) * (y2 - y1 + 1) if max(x1, x3) <= min(x2, x4) and max(y1, y3) <= min(y2, y4): x5 = max(x1, x3) y5 = max(y1, y3) x6 = min(x2, x4) y6 = min(y2, y4) w -= (x6 - x5 + 1) * (y6 - y5 + 1) wc, bc = count(x5, y5, x6, y6) w += wc b += bc wc, bc = count(x3, y3, x4, y4) w -= wc b -= bc b += (x4 - x3 + 1) * (y4 - y3 + 1) print(w, b)",constant,['implementation'],869
"def main(): def calc(x1, y1, x2, y2): if x1 > x2 or y1 > y2: return 0 if (x2 - x1 + 1) * (y2 - y1 + 1) % 2 == 0: return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 if (x1 + y1) % 2 == 1: return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + 1 return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 T = int(input()) for t in range(T): n, m = map(int, input().split()) a, b, c, d = map(int, input().split()) e, f, g, h = map(int, input().split()) j, k, l, q = max(a, e), max(b, f), min(c, g), min(d, h) black = calc(1, 1, n, m) - calc(a, b, c, d) - calc(e, f, g, h) + (h - f + 1) * (g - e + 1) + calc(j,k,l,q) print(n * m - black, black) main()",constant,['implementation'],610
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools sys.setrecursionlimit(10**7) inf = 10**20 eps = 1.0 / 10**13 mod = 10**9+7 dd = [(-1,0),(0,1),(1,0),(0,-1)] ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)] def LI(): return [int(x) for x in sys.stdin.readline().split()] def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()] def LF(): return [float(x) for x in sys.stdin.readline().split()] def LS(): return sys.stdin.readline().split() def I(): return int(sys.stdin.readline()) def F(): return float(sys.stdin.readline()) def S(): return input() def pf(s): return print(s, flush=True) def main(): q = I() rr = [] def f(a,b,c,d): if a > c or b > d: return (0,0) sa = c-a + 1 sb = d-b + 1 g = h = (sa * sb) // 2 if (sa*sb) % 2 == 1: g += 1 if (a+b) % 2 == 0: return (g,h) return (h,g) def fa(a): return f(a[0],a[1],a[2],a[3]) for _ in range(q): n,m = LI() wa = LI() ba = LI() wc,bc = f(1,1,n,m) w1,b1 = fa(wa) w2,b2 = fa(ba) w3,b3 = f(max(wa[0],ba[0]),max(wa[1],ba[1]),min(wa[2],ba[2]),min(wa[3],ba[3])) wc += b1 bc -= b1 wc -= w2 bc += w2 wc -= b3 bc += b3 rr.append('{} {}'.format(wc,bc)) return ""\n"".join(map(str,rr)) print(main())",constant,['implementation'],1213
"def color(x, y): return 'white' if (x + y) % 2 == 0 else 'black' def white(x1, y1, x2, y2): if x1 > x2 or y1 > y2: return 0 if color(x1, y1) != color(x2, y2): return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 else: if color(x1, y1) == color(x1, y2) == color(x2, y1) == 'white': return ((x2 - x1 + 1) * (y2 - y1 + 1) + 1) // 2 elif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'black': return ((x2 - x1 + 1) * (y2 - y1 + 1) - 1) // 2 else: return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 def black(x1, y1, x2, y2): if x1 > x2 or y1 > y2: return 0 return (x2 - x1 + 1) * (y2 - y1 + 1) - white(x1, y1, x2, y2) def intersect_1D(x1, x2, x3, x4): return max(x1, x3), min(x2, x4) def intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4): xl, xr = intersect_1D(x1, x2, x3, x4) yl, yr = intersect_1D(y1, y2, y3, y4) return xl, yl, xr, yr for i in range(int(input())): n, m = map(int, input().split()) x1, y1, x2, y2 = map(int, input().split()) x3, y3, x4, y4 = map(int, input().split()) w0, b0 = white(1, 1, m, n), black(1, 1, m, n) _b0 = black(x1, y1, x2, y2) w1, b1 = w0 + _b0, b0 - _b0 _w1 = white(x3, y3, x4, y4) w2, b2 = w1 - _w1, b1 + _w1 xl, yl, xr, yr = intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4) _b2 = black(xl, yl, xr, yr) w3, b3 = w2 - _b2, b2 + _b2 print(w3, b3)",constant,['implementation'],1251
"t = int(input()) def getcol(x1, y1, x2, y2): dx = max((x2-x1+1), 0) dy = max((y2-y1+1), 0) b = w = dx*dy//2 if dx % 2 and dy % 2: if (x1+y1) % 2: b = b + 1 else: w = w + 1 return w, b for _ in range(t): n, m = map(int, input().split()) x1, y1, x2, y2 = map(int, input().split()) x3, y3, x4, y4 = map(int, input().split()) w, b = getcol(1,1,n,m) w1, b1 = getcol(x1,y1,x2,y2) w2, b2 = getcol(x3,y3,x4,y4) w3, b3 = getcol(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4)) woff = w-w1-w2+w3 boff = b-b1-b2+b3 print(woff+w1-w3+b1-b3, boff+w3+b3+b2-b3+w2-w3)",constant,['implementation'],547
"import sys, math def mp(): return list(map(int, input().split())) def quer(x1, y1, x2, y2): if x1 > x2 or y1 > y2: return [0, 0] s = (x2 - (x1 - 1)) * (y2 - (y1 - 1)) if s % 2 == 0: return [s // 2, s // 2] if (x1 + y1) & 1: return [s // 2 + 1, s // 2] return [s // 2, s // 2 + 1] def main(): q = int(input()) for i in range(q): n, m = mp() x1, y1, x2, y2 = mp() s = quer(1, 1, n, m) s1 = quer(x1, y1, x2, y2) s[0] -= s1[0] s[1] += s1[0] x3, y3, x4, y4 = mp() xmn = max(x1, x3) xmx = min(x2, x4) ymn = max(y1, y3) ymx = min(y2, y4) s1 = quer(x3, y3, x4, y4) s[0] += s1[1] s[1] -= s1[1] s1 = quer(xmn, ymn, xmx, ymx) s[0] += s1[0] s[1] -= s1[0] print(*s[::-1]) debug = 0 if debug: file = open(""input.txt"", ""r"") input = file.readline main() if debug: file.close()",constant,['implementation'],760
"def area(rect): if rect is None: return 0 x1, y1, x2, y2 = rect return (x2-x1+1) * (y2-y1+1) def get_w(rect): if rect is None: return 0 x1, y1, x2, y2 = rect ra = area(rect) more, less = (ra + 1) // 2, ra // 2 if (x1 + y1) % 2 == 0: return more else: return less def intersect_rects(r1, r2): out = [] for i, a, b in zip(range(4), r1, r2): out.append(max(a,b) if i < 2 else min(a,b)) if out[0] > out[2] or out[1] > out[3]: return None return out def main(): n, m = list(map(int, input().split())) rect1 = list(map(int, input().split())) rect2 = list(map(int, input().split())) rect12 = intersect_rects(rect1, rect2) w_start = get_w([1,1,n,m]) w1 = get_w(rect1) w2 = get_w(rect2) w12 = get_w(rect12) w = w_start - w1 - w2 + w12 + area(rect1) - area(rect12) print(w, n*m-w) q = int(input()) for i in range(q): main()",constant,['implementation'],813
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, file=sys.stderr) dprint('debug mode') except Exception: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) T, = getIntList() def isin( x,y, M): if M[0] <= x <= M[2] and M[1] <= y <= M[3]: return True return False for _ in range(T): N, M = getIntList() m1 = getIntList() m2 = getIntList() zx = [0, M] zx += [m1[0]-1, m1[2]] zx += [m2[0]-1, m2[2]] zx.sort() zy = [0, N] zy += [m1[1]-1, m1[3]] zy += [m2[1]-1, m2[3]] zy.sort() totB = 0 for i0 in range(5): if zx[i0] == zx[i0+1]: continue for i1 in range(5): if zy[i1] == zy[i1+1]: continue x0 = zx[i0]+1 y0 = zy[i1]+1 dprint('x0,y0', x0,y0) size = (zx[i0+1] - zx[i0] ) *( zy[i1+1] - zy[i1]) if isin(x0,y0, m2): dprint('black') totB += size elif isin(x0,y0, m1): dprint('white') pass else: totB+= size//2 if size%2==1: if (x0+y0)%2==1: dprint('extra black') totB+=1 print(N*M - totB, totB)",constant,['implementation'],1258
"def num_sq(x,y,x2,y2): a = (abs(x2-x)+1) b = (abs(y2-y)+1) if a % 2 == 0 or b % 2 == 0: return (a*b // 2, a*b // 2) if (x+y) % 2 == 0: num_b = a * b // 2 return (num_b, a * b - num_b) num_w = a * b // 2 return (a * b - num_w, num_w) def pt_in(p1, r1, r2): return r1[0] <= p1[0] <= r2[0] and r1[1] <= p1[1] <= r2[1] def intc(p1, p2, p3, p4): x1 = max(p1[0], p3[0]) x2 = min(p2[0], p4[0]) y1 = max(p1[1], p3[1]) y2 = min(p2[1], p4[1]) if x1 <= x2 and y1 <= y2: return ((x1, y1), (x2, y2)) return None num_ = int(input()) for _ in range(num_): n, m = map(int, input().split()) x1,y1,x2,y2 = map(int,input().split()) x3,y3,x4,y4 = map(int,input().split()) p1 = (x1,y1) p2 = (x2,y2) p3 = (x3,y3) p4 = (x4,y4) all_b, all_w = num_sq(1, 1, n, m) tmp = intc(p1, p2, p3, p4) if tmp: intc_1, intc_2 = tmp t_b, t_w = num_sq(intc_1[0], intc_1[1], intc_2[0], intc_2[1]) b,w = num_sq(x1,y1,x2,y2) if tmp: b -= t_b w -= t_w b2,w2 = num_sq(x3,y3,x4,y4) if tmp: b2 -= t_b w2 -= t_w w_tot, b_tot = (all_w + b - w2, all_b - b + w2) if tmp: w_tot -= t_w b_tot += t_w print(w_tot, b_tot)",constant,['implementation'],1065
"def get_colors(x1, y1, x2, y2): w = x2 - x1 + 1 h = y2 - y1 + 1 if w % 2 == 0 or h % 2 == 0: black = w * h // 2 white = w * h // 2 else: oddx = w // 2 if x1 % 2 == 1 and x2 % 2 == 1: oddx += 1 oddy = h // 2 if y1 % 2 == 1 and y2 % 2 == 1: oddy += 1 evenx = w // 2 if x1 % 2 == 0 and x2 % 2 == 0: evenx += 1 eveny = h // 2 if y1 % 2 == 0 and y2 % 2 == 0: eveny += 1 white = oddx * oddy + evenx * eveny black = w * h - white return white, black def get_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2): if ax1 > bx2: return None, None, None, None if bx1 > ax2: return None, None, None, None if ay1 > by2: return None, None, None, None if by1 > ay2: return None, None, None, None return max(ax1, bx1), max(ay1, by1), min(ax2, bx2), min(ay2, by2) t = int(input()) for i in range(t): n, m = map(int, input().split()) white, black = get_colors(1, 1, m, n) wx1, wy1, wx2, wy2 = map(int, input().split()) w, b = get_colors(wx1, wy1, wx2, wy2) white += b black -= b bx1, by1, bx2, by2 = map(int, input().split()) ix1, iy1, ix2, iy2 = get_intersection(wx1, wy1, wx2, wy2, bx1, by1, bx2, by2) if ix1 is not None: w, b = get_colors(ix1, iy1, ix2, iy2) white -= b black += b w, b = get_colors(bx1, by1, bx2, by2) white -= w black += w print(white, black)",constant,['implementation'],1245
"t = int(input()) for i in range(t): n, m = map(int, input().split()) x1, y1, x2, y2 = map(int, input().split()) x3, y3, x4, y4 = map(int, input().split()) count_w = n * m // 2 + n * m % 2 count_g = n * m // 2 if (x1 + y1) % 2 == 0: count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2 count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2 else: count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2 count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2 x5 = max(x1, x3) x6 = min(x4, x2) y5 = max(y1, y3) y6 = min(y4, y2) if (x3 + y3) % 2 == 1: count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2 count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2 else: count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2 count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2 if (x5 + y5) % 2 == 0 and x5 <= x6 and y5 <= y6: count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2 count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2 elif x5 <= x6 and y5 <= y6: count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2 count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2 print(count_w, count_g)",constant,['implementation'],1203
"def getBW(x1, y1, x2, y2): if (x2 - x1) % 2 == 1 or (y2 - y1) % 2 == 1: return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2] else: if (x1 % 2 == 0 and y1 % 2 == 0) or (x1 % 2 == 1 and y1 % 2 == 1): return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, 1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2] else: return [1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2] cs = int(input()) for c in range(cs): m, n = map(int, input().split()) BW = getBW(1, 1, n, m) x1, y1, x2, y2 = map(int, input().split()) x3, y3, x4, y4 = map(int, input().split()) BW1 = getBW(x1, y1, x2, y2) BW2 = getBW(x3, y3, x4, y4) BWO =[0, 0] xo1 = max(x1, x3) xo2 = min(x2, x4) yo1 = max(y1, y3) yo2 = min(y2, y4) if (xo2 >= xo1 and yo2 >= yo1): BWO = getBW(xo1, yo1, xo2, yo2) B = BW[0] - BW1[0] + BW2[1] + BWO[0] W = BW[1] + BW1[0] - BW2[1] - BWO[0] print(W, end = "" "") print(B)",constant,['implementation'],885
"from collections import defaultdict def read_line(): return [int(x) for x in input().split()] def solve2(n, m, x1, y1, x2, y2, x3, y3, x4, y4): def inside(x, y): return 1 <= x <= m and 1 <= y <= n def col(a, b): assert inside(a, b) return 'WB'[(a+b)%2] d = {} for i in range(1, m+1): for j in range(1, n+1): d[(i, j)] = col(i, j) for i in range(x1, x2+1): for j in range(y1, y2+1): d[(i, j)] = 'W' for i in range(x3, x4+1): for j in range(y3, y4+1): d[(i, j)] = 'B' return len([P for P in d if d[P] == 'W']), len([P for P in d if d[P] == 'B']) def rnd_test(): from random import randint n = randint(1, 50) m = randint(1, 50) x1, x2, x3, x4 = [randint(1, m) for _ in range(4)] y1, y2, y3, y4 = [randint(1, n) for _ in range(4)] x1, x2 = min(x1, x2), max(x1, x2) y1, y2 = min(y1, y2), max(y1, y2) x3, x4 = min(x3, x4), max(x3, x4) y3, y4 = min(y3, y4), max(y3, y4) assert solve(n, m, x1, y1, x2, y2, x3, y3, x4, y4) == solve2(n, m, x1, y1, x2, y2, x3, y3, x4, y4) def solve(n, m, x1, y1, x2, y2, x3, y3, x4, y4): def inside(x, y): return 1 <= x <= m and 1 <= y <= n def col(a, b): assert inside(a, b) return 'WB'[(a+b)%2] def cols(x1, y1, x2, y2): assert inside(x1, y1) and inside(x2, y2) assert x1 <= x2 and y1 <= y2 w, h = x2+1-x1, y2+1-y1 if w % 2 == 0 or h % 2 == 0: return w*h // 2, w*h // 2 else: WH, BL = w*h // 2, w*h // 2 if col(x1, y1) == 'W': WH += 1 else: BL += 1 return WH, BL def overlap(): X1 = max(x1, x3) X2 = min(x2, x4) Y1 = max(y1, y3) Y2 = min(y2, y4) if X1 > X2 or Y1 > Y2: return None return X1, Y1, X2, Y2 tot_wh, tot_bl = cols(1, 1, m, n) A_wh, A_bl = cols(x1, y1, x2, y2) ovrlp = overlap() if ovrlp is not None: O_wh, O_bl = cols(*ovrlp) assert A_wh >= O_wh and A_bl >= O_bl A_wh -= O_wh A_bl -= O_bl B_wh, B_bl = cols(x3, y3, x4, y4) tot_wh += A_bl tot_bl -= A_bl tot_wh -= B_wh tot_bl += B_wh return(tot_wh, tot_bl) t = int(input()) for _ in range(t): n, m = read_line() x1, y1, x2, y2 = read_line() x3, y3, x4, y4 = read_line() print(*solve(n, m, x1, y1, x2, y2, x3, y3, x4",constant,['implementation'],2000
"def wb(n,m,flip=False): w = b = n*m // 2 if n%2 == 1 and m %2 == 1: w += 1 if flip: return b,w else: return w,b t = int(input()) for tt in range(t): n,m = map(int, input().split()) x1,y1,x2,y2 = map(int, input().split()) x3,y3,x4,y4 = map(int, input().split()) x5 = max(x1,x3) x6 = min(x2,x4) y5 = max(y1,y3) y6 = min(y2,y4) ov = False if x6-x5 >= 0 and y6-y5 >= 0: ov = True w,b = wb(n,m) wm,bm = wb(x2-x1+1, y2-y1+1, (x1+y1)%2==1) wd,bd = wb(x4-x3+1, y4-y3+1, (x3+y3)%2==1) if ov: wo,bo = wb(x6-x5+1, y6-y5+1, (x5+y5)%2==1) else: wo,bo = 0,0 w = w+bm-wd-bo b = b-bm+wd+bo print(w,b)",constant,['implementation'],584
"import math import collections import bisect import heapq import time import itertools import sys T = int(input()) def interact(rect1, rect2): x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 ans = (-1, -1, -1, -1) if x2 < x3 or x4 < x1: return 0, ans if y2 < y3 or y4 < y1: return 0, ans ans = (max(x1, x3), max(y1, y3), min(x2, x4), min(y2, y4)) return area(ans), ans def area(rect): return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1) def winrect(rect): a = area(rect) if a % 2 == 0: return a // 2 x1, y1, x2, y2 = rect e1, e2 = x1 % 2 == 0, y1 % 2 == 0 ow = (e1 and e2) or (not e1 and not e2) return a // 2 + 1 if ow else a // 2 ans = [] for ti in range(T): N, M = map(int, input().split()) x1, y1, x2, y2 = map(int, input().split()) x3, y3, x4, y4 = map(int, input().split()) w = winrect((1, 1, N, M)) a, b = (x1, y1, x2, y2), (x3, y3, x4, y4) s, c = interact(a, b) if s == 0: w -= winrect(a) + winrect(b) w += area(a) elif s == area(a): w -= winrect(b) elif s == area(b): w -= winrect(b) w += area(a) - area(b) - (winrect(a) - winrect(b)) else: w += area(a) - winrect(a) w -= winrect(b) w -= area(c) - winrect(c) ans.append((w, N*M-w)) print('\n'.join(['{} {}'.format(a, b) for a, b in ans]))",constant,['implementation'],1200
"def black_count(x, y): total = x * y return total // 2 def black_count2(a, b, c, d): return black_count(c, d) - black_count(a-1, d) - black_count(c, b-1) + black_count(a-1, b-1) def white_count2(a, b, c, d): total = (c - a + 1) * (d - b + 1) return total - black_count2(a, b, c, d) def intersection(a, b, c, d, x, y): if x < a or y < b: return None x = min(x, c) y = min(y, d) return (a, b, x, y) def intersection2(a1, b1, c1, d1, a2, b2, c2, d2): if b1 > d2 or a1 > c2: return None if b2 > d1 or a2 > c1: return None a = max(a1, a2) b = max(b1, b2) c = min(c1, c2) d = min(d1, d2) return (a, b, c, d) def solve(n, m, W, B): total = n * m whites = total - black_count(n, m) whites += black_count2(*W) whites -= white_count2(*B) I = intersection2(*W, *B) if I: whites -= black_count2(*I) blacks = n * m - whites return whites, blacks def main(): t = int(input()) for _ in range(t): n, m = map(int, input().split()) W = list(int(i) for i in input().split()) B = list(int(i) for i in input().split()) w, b = solve(n, m, W, B) print(w, b) if __name__ == '__main__': main()",constant,['implementation'],1068
"import sys input = sys.stdin.readline testcase=int(input()) T=[list(map(int,input().split())) for i in range(testcase*3)] def COMMON(WHITE,BLACK): x1,y1,x2,y2=WHITE x3,y3,x4,y4=BLACK return (max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4)) def BtoW(WHITE): x1,y1,x2,y2=WHITE if (x1+y1)%2==0: return (x2-x1+1)*(y2-y1+1)//2 else: return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2 def WtoB(BLACK): x1,y1,x2,y2=BLACK if (x1+y1)%2==1: return (x2-x1+1)*(y2-y1+1)//2 else: return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2 for test in range(testcase): n,m=T[test*3] WHITE=T[test*3+1] BLACK=T[test*3+2] ANSB=n*m//2 ANSW=n*m-ANSB WHITE2=COMMON(WHITE,BLACK) k=BtoW(WHITE) ANSB-=k ANSW+=k if WHITE2[0]>WHITE2[2] or WHITE2[1]>WHITE2[3]: True else: l=BtoW(WHITE2) ANSB+=l ANSW-=l m=WtoB(BLACK) ANSB+=m ANSW-=m print(ANSW,ANSB)",constant,['implementation'],809
"def whb(a,b,c,d): dim = (c-a+1)*(d-b+1) col1 = dim//2 col2 = dim-col1 if (a+b)%2==0: return [col2, col1] else: return [col1, col2] def insegment(a, b, a1, b1): li = [[a,1], [b,1], [a1,2], [b1,2]] li.sort() if li[0][1] == li[1][1]: if li[1][0] == li[2][0]: return [li[1][0], li[2][0]] else: return -1 else: return [li[1][0], li[2][0]] def inrect(a,b,c,d,a1,b1,c1,d1): xra = insegment(a,c,a1,c1) yra = insegment(b,d,b1,d1) if xra==-1 or yra==-1: return -1 else: return [xra[0], yra[0], xra[1], yra[1]] q = int(input()) for quer in range(q): [n, m] = [int(i) for i in input().split()] [x1, y1, x2, y2] = [int(i) for i in input().split()] [x3, y3, x4, y4] = [int(i) for i in input().split()] [white, black] = whb(1,1,n,m) [w1, b1] = whb(x1, y1, x2, y2) [w2, b2] = whb(x3, y3, x4, y4) black+= w2-b1 white+= b1-w2 inter = inrect(x1, y1, x2, y2, x3, y3, x4, y4) if type(inter)==list: [w3, b3] = whb(inter[0], inter[1],inter[2], inter[3]) black += b3 white -= b3 print(white, black)",constant,['implementation'],974
"def fis(sq): if sq[2] < sq[0] or sq[3] < sq[1]: return [0, 0] sc = (sq[0] + sq[1]) % 2 fc = (sq[2] + sq[3]) % 2 sxl = sq[2] - sq[0] + 1 syl = sq[3] - sq[1] + 1 hf = (sxl * syl) // 2 cp = -1 if sc == fc and (sxl+syl) % 2 == 0 and sxl % 2 == 1: cp = sc return([hf + (1 if cp == 0 else 0), hf + (1 if cp == 1 else 0)]) t = int(input()) for i in range(t): n, m = [int(x) for x in input().split()] wco = [int(x) for x in input().split()] bco = [int(x) for x in input().split()] wf, bf = fis([1, 1, m, n]) btw = fis(wco)[1] wtb = fis(bco)[0] bnac = [max(wco[0], bco[0]), max(wco[1], bco[1]), min(wco[2], bco[2]), min(wco[3], bco[3])] bna = fis(bnac)[1] print(wf+btw-wtb-bna, bf+wtb-btw+bna)",constant,['implementation'],684
"pw = [1, 4] for i in range(2, 32): pw.append(pw[i - 1] * 4) t = int(input()) for cas in range(t): n, k = map(int, input().split()) last = 1 path = 1 ans = n i = 0 while True: if((pw[i + 1] - 1) // 3 > k): ans -= i last = k - (pw[i] - 1) // 3 break i = i + 1 path *= 2 sp = path * 2 - 1 if((ans < 0) or ((ans == 0) and (last > 0))): print(""No"") continue sq = path * path - sp if (ans == 1) and (last > sq) and (last < sp): print(""No"") continue elif (ans == 1) and (last >= sp): ans = ans - 1 print(""Yes"", ans)",constant,"['constructive algorithms', 'implementation', 'math']",508
"import math t = int(input()) def eval_(n, k): level = 0.5*math.log2(3*k+1) if n > 30: cond = (level - n) > 0 else: cond = (3*k+1) > 4**n if cond: return ""NO"" elif n == 2 and k == 3: return ""NO"" else: level = math.floor(level) if n > 5: temp = 1 + 0.5*math.log2(3*(k-1) + 1) if n > temp: return ""YES "" + str(n - 1) else: return ""YES 0"" else: delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3 start = (4**(level)-1)//3 if k <=(start+delta): return ""YES "" + str(n - level) else: return ""YES "" + str(n - level-1) for i in range(t): (n, k) = [int(i) for i in input().split()] print(eval_(n, k))",constant,"['constructive algorithms', 'implementation', 'math']",593
"f = [0 for _ in range(40)] for i in range(1, 32): f[i] = 1 + 4 * f[i - 1] t = int(input()) for _ in range(t): n, k = map(int, input().split()) if n >= 32: print(""YES %d"" % (n - 1)) continue if f[n] < k: print(""NO"") continue k -= 1 extra = 1 way = 3 size = n - 1 done = False total = f[size] ans = True while k > total and size > 0: if k < way: ans = False break k -= way size -= 1 extra = way * 2 - 1 way = way * 2 + 1 total += extra * f[size] if ans: print(""YES %d"" % size) else: print(""NO"")",constant,"['constructive algorithms', 'implementation', 'math']",492
"import os,sys from io import BytesIO,IOBase from collections import defaultdict,Counter from copy import deepcopy def main(): n,c = map(int,input().split()) a = list(map(int,input().split())) nums = defaultdict(lambda :[0]) freq,minus = Counter(),0 for i in a: if i == c: minus += 1 else: freq[i] += 1 nums[i].append(freq[i]-minus) tot = minus suff = deepcopy(nums) for i in nums: for j in range(len(nums[i])-2,0,-1): suff[i][j] = max(suff[i][j],suff[i][j+1]) freq,ans = Counter(),tot for i in a: if i == c: continue freq[i] += 1 ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot) print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self,file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) self.newlines = b.count(b""\n"")+(not b) ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd,self.buffer.getvalue()) self.buffer.truncate(0),self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self,file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s:self.buffer.write(s.encode(""ascii"")) self.read = lambda:self.buffer.read().decode(""ascii"") self.readline = lambda:self.buffer.readline().decode(""ascii"") sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout) input = lambda:sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",constant,"['binary search', 'dp', 'greedy']",1952
"a = list(map(int,input().split())) b = list(map(int,input().split())) c = list(map(int,input().split())) a,b,c= sorted([a,b,c]) path = [] for i in range(min(a[1],b[1],c[1]) , max(a[1],b[1],c[1]) + 1): path.append((b[0],i)) for i in range(a[0],b[0]+1): path.append((i,a[1])) for i in range(b[0],c[0]+1): path.append((i,c[1])) print(len(set(path))) for i in set(path): print(*i)",constant,"['greedy', 'implementation']",376
"def get_path_hv(A, B): x, y = A path = [(x, y)] while x < B[0]: x += 1 path.append((x, y)) while x > B[0]: x -= 1 path.append((x, y)) while y < B[1]: y += 1 path.append((x, y)) while y > B[1]: y -= 1 path.append((x, y)) return path def get_path_vh(A, B): x, y = A path = [(x, y)] while y < B[1]: y += 1 path.append((x, y)) while y > B[1]: y -= 1 path.append((x, y)) while x < B[0]: x += 1 path.append((x, y)) while x > B[0]: x -= 1 path.append((x, y)) return path A = tuple(map(int, input().split())) B = tuple(map(int, input().split())) C = tuple(map(int, input().split())) paths = [] paths.append([get_path_vh(A, B), get_path_hv(A, B)]) paths.append([get_path_vh(C, B), get_path_hv(C, B)]) paths.append([get_path_vh(A, C), get_path_hv(A, C)]) ans = 10 ** 8 ans_path = [] for i in range(3): for j in range(3): if i != j: for a in paths[i]: for b in paths[j]: X = list(set([*a, *b])) if len(X) < ans: ans = len(X) ans_path = X print(ans) for p in ans_path: print(*p)",constant,"['greedy', 'implementation']",966
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, file=sys.stderr) dprint('debug mode') except Exception: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) p0 = getIntList() p1 = getIntList() p2 = getIntList() zp = [p0, p1, p2] def getpath( p0, p1): if p0[0] < p1[0]: sp = 1 elif p0[0] > p1[0]: sp = -1 else: sp =0 zz = [tuple(p0), tuple(p1)] if sp!=0: for x in range(p0[0], p1[0]+ sp, sp): tp = (x, p0[1]) zz.append(tp) if p0[1] < p1[1]: sp = 1 elif p0[1] > p1[1]: sp = -1 else: sp = 0 if sp!=0: for y in range(p0[1], p1[1] + sp, sp): tp = (p1[0], y) zz.append(tp) return zz nr = 1000000; zr = set() for i in range(3): for j in range(3): cx = zp[i][0] cy = zp[j][1] cp = (cx, cy) z1 = getpath(cp, zp[0]) z2 =getpath(cp, zp[1]) z3 =getpath(cp, zp[2]) z0 = z1+z2+z3 s1 = set(z0) dprint(cp,s1) if len(s1) < nr: nr = len(s1) zr = s1 print(len(zr)) for x in zr: print(x[0], x[1])",constant,"['greedy', 'implementation']",1249
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) a = [tuple(mi()) for i in range(3)] a.sort() up1 = a[1][1] >= a[0][1] up2 = a[2][1] >= a[0][1] ans = {a[0]} x, y = a[0] if up1 and up2: while y < min(a[1][1], a[2][1]): y += 1 ans.add((x, y)) while x < a[2][0]: x += 1 ans.add((x, y)) hx, hy = a[2] if a[2][1] > a[1][1] else a[1] while hy > y: ans.add((hx, hy)) hy -= 1 else: dn1 = a[1][1] <= a[0][1] dn2 = a[2][1] <= a[0][1] ans = {a[0]} x, y = a[0] if dn1 and dn2: while y > max(a[1][1], a[2][1]): y -= 1 ans.add((x, y)) while x < a[2][0]: x += 1 ans.add((x, y)) lx, ly = a[2] if a[2][1] < a[1][1] else a[1] while ly < y: ans.add((lx, ly)) ly += 1 else: x, y = a[0] ans = {a[0]} while x < a[2][0]: x += 1 ans.add((x, y)) dy = 1 if a[1][1] <= a[0][1] else -1 xx, yy = a[1] while yy != a[0][1]: ans.add((xx, yy)) yy += dy dy = 1 if a[2][1] <= a[0][1] else -1 xx, yy = a[2] while yy != a[0][1]: ans.add((xx, yy)) yy += dy ans = sorted(ans) print(len(ans)) print('\n'.join('%d %d' % (x, y) for x, y in ans))",constant,"['greedy', 'implementation']",1055
"xa, ya = map(int, input().split()) xb, yb = map(int, input().split()) xc, yc = map(int, input().split()) if (xb, yb) < (xa, ya): xa, ya, xb, yb = xb, yb, xa, ya if (xc, yc) < (xa, ya): xa, ya, xc, yc = xc, yc, xa, ya if xb > xc: xb, yb, xc, yc = xc, yc, xb, yb d = 1 if ya <= yc else -1 if ya <= yb <= yc or ya >= yb >= yc: print(xc - xa + abs(yc - ya) + 1) for x in range(xa, xb): print(x, ya) for y in range(ya, yc, d): print(xb, y) for x in range(xb, xc + 1): print(x, yc) elif yb < min(ya, yc): print(xc - xa + max(ya, yc) - yb + 1) for x in range(xa, xc + 1): print(x, min(ya, yc)) for y in range(yb, min(ya, yc)): print(xb, y) if ya < yc: for y in range(ya + 1, yc + 1): print(xc, y) else: for y in range(yc + 1, ya + 1): print(xa, y) else: print(xc - xa + yb - min(ya, yc) + 1) for x in range(xa, xc + 1): print(x, max(ya, yc)) for y in range(max(ya, yc) + 1, yb + 1): print(xb, y) if ya < yc: for y in range(ya, yc): print(xa, y) else: for y in range(yc, ya): print(xc, y)",constant,"['greedy', 'implementation']",980
"def path(x1,y1,x2,y2,hor): out=[] if hor: for i in range(x2-x1): out.append((x1+i,y1)) if y2>y1: for i in range(y2-y1): out.append((x2,y1+i)) else: for i in range(y1-y2): out.append((x2,y1-i)) else: for i in range(x2-x1): out.append((x2-i,y2)) if y2>y1: for i in range(y2-y1): out.append((x1,y2-i)) else: for i in range(y1-y2): out.append((x1,y2+i)) return out[1:] a,b=map(int,input().split()) c,d=map(int,input().split()) e,f=map(int,input().split()) if a>c: a,b,c,d=c,d,a,b if c>e: c,d,e,f=e,f,c,d if a>c: a,b,c,d=c,d,a,b if c==e and abs(f-b)<abs(d-b): c,d,e,f=e,f,c,d g1=path(a,b,c,d,True) if d>b: if f<b: g2=path(c,b,e,f,True) elif f<d: g2=path(c,f,e,f,True) else: g2=path(c,d,e,f,True) else: if f<d: g2=path(c,d,e,f,True) elif f<b: g2=path(c,f,e,f,True) else: g2=path(c,b,e,f,True) print(len(g1)+len(g2)+3) print(a,b) print(c,d) print(e,f) for x,y in g1: print(x,y) for x,y in g2: print(x,y)",constant,"['greedy', 'implementation']",896
"import sys from math import floor, ceil r = lambda: sys.stdin.readline().strip() a = [[0] * 2 for i in range(3)] def abs(x): if x < 0: x = -x return x def calcLen(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) + 1 def main(): a[0][0], a[0][1] = map(int, r().split()) a[1][0], a[1][1] = map(int, r().split()) a[2][0], a[2][1] = map(int, r().split()) xMax = max(a[0][0], a[1][0], a[2][0]) xMin = min(a[0][0], a[1][0], a[2][0]) yMax = max(a[0][1], a[1][1], a[2][1]) yMin = min(a[0][1], a[1][1], a[2][1]) pathLen = xMax - xMin + yMax - yMin + 1 for i in range(3): for j in range(3): px = a[i][0] py = a[j][1] sum = 0 for k in range(3): sum += (calcLen(a[k][0], a[k][1], px, py)) sum -= 2 if sum == pathLen: break if sum == pathLen: break sq = [[0]*(yMax+1) for i in range(xMax+1)] for i in range(3): if px == a[i][0]: c = -1 if py > a[i][1]: c = 1 for j in range(a[i][1], py, c): sq[px][j]=1 elif py== a[i][1]: c = -1 if px > a[i][0]: c= 1 for j in range(a[i][0], px, c): sq[j][py] = 1 else: c = -1 if py > a[i][1]: c = 1 for j in range(a[i][1], py + c, c): sq[a[i][0]][j] = 1 c = -1 if px > a[i][0]: c= 1 for j in range(a[i][0], px, c): sq[j][py] = 1 sq[px][py] = 1 ans = [] for i in range(xMax + 1): for j in range(yMax + 1): if sq[i][j] == 1: ans.append((i, j)) print(len(ans)) for i in ans: print(i[0], i[1]) main()",constant,"['greedy', 'implementation']",1320
"l = [] a, b = map(int, input().split()) l.append((a,b)) a, b = map(int, input().split()) l.append((a,b)) a, b = map(int, input().split()) l.append((a,b)) l.sort() path = [] path.append(l[0]) x = l[0][0] while(x<l[1][0]): path.append((x, l[0][1])) x = x + 1 up = False if(l[0][1]<l[1][1]): up = True if(up): y = l[0][1] while(y<=l[1][1]): path.append((l[1][0], y)) y = y+1 else: y = l[0][1] while(y>=l[1][1]): path.append((l[1][0], y)) y = y-1 up = False if(l[1][1]<l[2][1]): up = True if(up): y = l[1][1] while(y<=l[2][1]): path.append((l[1][0], y)) y = y+1 else: y = l[1][1] while(y>=l[2][1]): path.append((l[1][0], y)) y = y-1 x = l[1][0] while(x<l[2][0]): path.append((x, l[2][1])) x = x + 1 path.append(l[2]) path = list(set(path)) print(len(path)) for i in range(len(path)): print(str(path[i][0])+"" ""+str(path[i][1]))",constant,"['greedy', 'implementation']",822
"ax, ay = map(int, input().split()) bx, by = map(int, input().split()) cx, cy = map(int, input().split()) if ax > bx: ax, bx = bx, ax ay, by = by, ay if ax > cx: ax, cx = cx, ax ay, cy = cy, ay if bx > cx: bx, cx = cx, bx by, cy = cy, by ans = [] for i in range(min(ay, by, cy), max(ay, by, cy) + 1): ans.append([bx, i]) for i in range(ax, bx): ans.append([i, ay]) for i in range(bx + 1, cx + 1): ans.append([i, cy]) print(len(ans)) for x in ans: print(x[0], x[1])",constant,"['greedy', 'implementation']",463
"import sys import math import bisect from sys import stdin, stdout from math import gcd, floor, sqrt, log2, ceil from collections import defaultdict as dd from bisect import bisect_left as bl, bisect_right as br from bisect import insort from collections import Counter from collections import deque from heapq import heappush,heappop,heapify from itertools import permutations,combinations from itertools import accumulate as ac mod = int(1e9)+7 ip = lambda : int(stdin.readline()) inp = lambda: map(int,stdin.readline().split()) ips = lambda: stdin.readline().rstrip() out = lambda x : stdout.write(str(x)+""\n"") t = 1 for _ in range(t): q = ""? {} {}"".format(0,0) print(q,flush = True) cond = ip() cur_a = 0 cur_b = 0 for i in range(29,-1,-1): xor = (1<<i) query_a = cur_a^xor query_b = cur_b^xor q = ""? {} {}"".format(query_a,query_b) print(q,flush = True) val = ip() if val != cond: if cond == -1 and val == 1: cur_b ^= xor query_a = cur_a query_b = cur_b q = ""? {} {}"".format(query_a,query_b) print(q,flush = True) val = ip() cond = val else: cur_a ^= xor query_a = cur_a query_b = cur_b q = ""? {} {}"".format(query_a,query_b) print(q,flush = True) val = ip() cond = val else: cond = val query_a = cur_a^xor query_b = cur_b q = ""? {} {}"".format(query_a,query_b) print(q,flush = True) val = ip() if val == -1: cur_a ^= xor cur_b ^= xor else: pass ans = ""! {} {}"".format(cur_a,cur_b) print(ans,flush = True)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",1407
"import sys def ask(c, d): print(""? {} {}"".format(c, d)) return int(input()) c = d = 0 def solve(mi, base): def solve_same(): global c, d print("" for i in range(mi, -1, -1): print(f"">> {i=} {c=} {d=}"", file=sys.stderr) bit = 1 << i res1 = ask(c ^ bit, d) res2 = ask(c, d ^ bit) if res1 == -1 and res2 == 1: c |= bit d |= bit def solve1(): global c, d print("" for i in range(mi, -1, -1): print(f"">> {i=} {c=} {d=}"", file=sys.stderr) bit = 1 << i res1 = ask(c ^ bit, d ^ bit) if res1 == -1: c |= bit return solve(i - 1, ask(c, d)) else: res2 = ask(c ^ bit, d) if res2 == -1: c |= bit d |= bit def solve2(): global c, d print("" for i in range(mi, -1, -1): print(f"">> {i=} {c=} {d=}"", file=sys.stderr) bit = 1 << i res1 = ask(c ^ bit, d ^ bit) if res1 == 1: d |= bit return solve(i - 1, ask(c, d)) else: res2 = ask(c, d ^ bit) if res2 == 1: c |= bit d |= bit if base == 0: solve_same() elif base == 1: solve1() else: solve2() solve(29, ask(0, 0)) print(""! {} {}"".format(c, d))",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",971
"import os, sys from io import BytesIO, IOBase from math import log2, ceil, sqrt, gcd from _collections import deque import heapq as hp from bisect import bisect_left, bisect_right from math import cos, sin BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") mod = 10 ** 9 + 7 def ask(x, y): print('?', x, y, flush=True) return int(input()) a = b = 0 cond = ask(a, b) for i in range(29, -1, -1): if cond: x = a + (1 << i) y = b + (1 << i) n_cond = ask(x, y) if cond == n_cond: if cond == 1: n_cond1 = ask(x, b) else: n_cond1 = ask(a, y) if cond != n_cond1: a = x b = y else: if cond == 1: a = x else: b = y cond = ask(a, b) else: x = a + (1 << i) y = b + (1 << i) n_cond = ask(x, b) if n_cond == -1: a = x b",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",1999
"print(""?"",0,0) e=int(input()) astr=""000000000000000000000000000000"" bstr=""000000000000000000000000000000"" abig=e for i in range(30): if abig==0: print(""?"",int(astr,2)+2**(29-i),int(bstr,2)) e=int(input()) if e==1: continue else: if i<29: astr=astr[:i]+""1""+astr[i+1:] bstr=bstr[:i]+""1""+bstr[i+1:] else: astr=astr[:i]+""1"" bstr=bstr[:i]+""1"" else: print(""?"",int(astr,2)+2**(29-i),int(bstr,2)+2**(29-i)) e=int(input()) if e==-abig: if abig==1: if i<29: astr=astr[:i]+""1""+astr[i+1:] else: astr=astr[:i]+""1"" else: if i<29: bstr=bstr[:i]+""1""+bstr[i+1:] else: bstr=bstr[:i]+""1"" print(""?"",int(astr,2),int(bstr,2)) abig=int(input()) else: print(""?"",int(astr,2)+2**(29-i),int(bstr,2)) e=int(input()) if e==-1: if i<29: astr=astr[:i]+""1""+astr[i+1:] bstr=bstr[:i]+""1""+bstr[i+1:] else: astr=astr[:i]+""1"" bstr=bstr[:i]+""1"" print(""!"",int(astr,2),int(bstr,2))",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",841
"a0 = (1 << 30) - 1 a0 = 3 b0 = 1 def mock_query(c, d): res = (a0 ^ c) - (b0 ^ d) if res > 0: return 1 elif res < 0: return -1 else: return 0 def query2(c, d): ans = mock_query(c, d) print('? {:08b} {:08b} --> {}'.format(c, d, ans)) return ans def query(c, d): print('?', c, d) return int(input()) def solve(): a = 0 b = 0 last_ans = query(0, 0) pos = 29 while pos >= 0: bit = 1 << pos ans = query(a + bit, b + bit) if (last_ans, ans) == (1, -1): a += bit last_ans = query(a, b) elif (last_ans, ans) == (-1, 1): b += bit last_ans = query(a, b) else: last_ans = ans ans = query(a + bit, b) if ans == -1: a += bit b += bit pos -= 1 print('!', a, b) solve()",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",653
"print(""? 0 0"") ans00 = input() xr = 0 a = 0 b = 0 cb = 2 ** 29 while cb: print(""?"", xr + cb, cb) ans11 = input() print(""?"", xr, cb) if ans11 == ans00: ans01 = input() if ans01 == '1': a += cb b += cb else: ans00 = input() if ans11 == '1': b += cb else: a += cb xr += cb cb //= 2 print(""!"", a, b)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",295
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, file=sys.stderr) dprint('debug mode') except Exception: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) import random import time random.seed( int(time.time()) ) bb = random.randint(0, 2**30-1) hat1 = 0 hat2 = 0 lastresult = None for i in range(29, -1, -1): g1 = hat1 + (1<<i) g2 = hat2 + (1<<i) if lastresult is None: print('?',hat1^ bb,hat2) t1 = int(input()) else: t1 = lastresult if t1!=0: print('?',g1^ bb,g2) t2 = int(input()) if t1!=t2: if t1==1: hat1+= (1<<i) else: hat2+= (1<<i) lastresult = None continue lastresult = t1 print('?',g1^ bb,hat2) t3 = int(input()) if t3==1: pass else: hat1+= (1<<i) hat2+= (1<<i) print('!', hat1^bb% (2**30), hat2)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",1081
"print(""? 0 0"") t = int(input()) A=[] B=[] a=0 b=0 for i in range(30): A.append(-1) B.append(-1) i = 29 d = 2**i while i>=0: a+=d b+=d print(""?"", end=' ') print(a, end=' ') print(b) s=int(input()) if s == -t: if s==1: A[i]=0 B[i]=1 b-=d print(""?"", end=' ') print(a, end=' ') print(b) t=int(input()) elif s==-1: A[i]=1 a-=d B[i]=0 print(""?"", end=' ') print(a, end=' ') print(b) t=int(input()) i-=1 d//=2 d=1 for j in range(30): if A[j]==-1: a = a^d print(""?"", end=' ') print(a, end=' ') print(b) s = int(input()) if s==1: A[j]=1 B[j]=1 else: A[j]=0 B[j]=0 a = a^d d*=2 d=1 a=0 b=0 for i in range(30): a+=d*A[i] b+=d*B[i] d*=2 print(""!"", end=' ') print(a, end=' ') print(b)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",670
"import sys keta=29 print(""?"",0,0,flush=True) A00=int(input()) if A00==0: ANS=0 for k in range(keta,-1,-1): print(""?"",2**k,0,flush=True) if int(input())==-1: ANS+=2**k print(""!"",ANS,ANS,flush=True) sys.exit() A=0 B=0 for k in range(keta,-1,-1): LIST=[] print(""?"",2**k+A,B,flush=True) LIST.append(int(input())) print(""?"",A,2**k+B,flush=True) LIST.append(int(input())) if LIST[0]!=LIST[1]: if LIST[0]==-1: A+=2**k B+=2**k else: if A00==1: A+=2**k else: B+=2**k A00=LIST[0] print(""!"",A,B,flush=True)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",495
"from sys import stdout a, b = 0, 0 mp = 29 c, d = 0,0 powers = [1] for i in range(32): powers.append(powers[-1]*2) qqq = 0 def get_ans(c, d): global qqq qqq += 1 a, b = 1073741823, 1073741821 a, b = 3, 1 print(c, d) if (a^c) > (b^d): print(1) return -1 elif (a^c) < (b^d): print(-1) return 1 print(0) return 0 def get_ans(c, d): print('? {} {}'.format(c, d)) stdout.flush() return -int(input()) q = get_ans(0, 0) for i in range(mp+1): cp = mp - i c += powers[cp] d += powers[cp] if q == 0: continue t = get_ans(c, d) if t != q: if t == 1: a += powers[cp] c -= powers[cp] elif t == -1: b += powers[cp] d -= powers[cp] q = get_ans(c, d) for i in range(mp+1): cp = mp - i if c & powers[cp] > 0 and d & powers[cp] > 0: c -= powers[cp] t = get_ans(c, d) if t < 0: a += powers[cp] b += powers[cp] c += powers[cp] print('!', a, b)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",823
"def ask(a, b): print(""?"", a, b, flush=True) return int(input()) <= 0 def solve(M): a, b = 0, 0 less = ask(0, 0) for i in range(M - 1, -1, -1): bit = 1 << i if less: if not ask(a | bit, b | bit): b |= bit less = ask(a, b) elif ask(a | bit, b): a |= bit b |= bit else: if ask(a | bit, b | bit): a |= bit less = ask(a, b) elif ask(a | bit, b): a |= bit b |= bit print(""!"", a, b, flush=True) if __name__ == '__main__': solve(30)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",424
"from sys import stdin,stdout stdout.flush() def qu(a,b): print(""?"",a,b) return int(input()) a=0 b=0 big=qu(a,b) for i in range(29,-1,-1): x=2**i f=qu(a+x,b) l=qu(a,b+x) if l==f: if big==1: a+=x else: b+=x big=f elif f==-1: a+=x b+=x print(""!"",a,b)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",247
"import sys def ask(x,y,rev): if (rev==0): print(""? %d %d""%(x,y)) else: print(""? %d %d""%(y,x)) sys.stdout.flush() if (rev==1): return -int(input()) else: return int(input()) comp=ask(0,0,0) nowa=0 nowb=0 rev=0 for i in range(29,-1,-1): if (comp<0): rev^=1 nowa,nowb=nowb,nowa comp=-comp if comp>=0: comp=ask(nowa|(1<<i),nowb|(1<<i),rev) if (comp<0): nowa|=1<<i comp=ask(nowa,nowb,rev) else: tmp=ask(nowa|(1<<i),nowb,rev) if (tmp<0): nowa|=1<<i nowb|=1<<i if (rev==1): nowa,nowb=nowb,nowa print(""! %d %d""%(nowa,nowb))",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",515
"def interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1) def main(): def ask(c, d): print(""?"", c, d, flush = True) return int(input()) relative = ask(0, 0) curA = 0 curB = 0 for i in range(29, -1, -1): q1 = ask(curA ^ 2 ** i, curB) q2 = ask(curA, curB ^ 2 ** i) if q1 == q2: if relative == 1: curA ^= 2 ** i else: curB ^= 2 ** i relative = q1 elif q2 == 1: curA ^= 2 ** i curB ^= 2 ** i return curA, curB print(""!"", *main())",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",429
"print(""? 0 0"") ans00 = input() xr = 0 a = 0 b = 0 cb = 2 ** 29 while cb: print(""?"", xr + cb, cb) ans11 = input() print(""?"", xr, cb) if ans11 == ans00: ans01 = input() if ans01 == '1': a += cb b += cb else: ans00 = input() if ans11 == '1': b += cb else: a += cb xr += cb cb //= 2 print(""!"", a, b)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",295
"from sys import stdout m = 30 a, b = 0, 0 fle = 1 for i in range(m): if fle: print('? {} {}'.format(a, b)) stdout.flush() resp1 = int(raw_input()) fle = 0 print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i))) stdout.flush() resp2 = int(raw_input()) if resp1 == -1 and resp2 == 1: b += 2**(m-1-i) fle = 1 elif resp1 == 1 and resp2 == -1: a += 2**(m-1-i) fle = 1 else: fle = 0 print('? {} {}'.format(a + 2**(m-1-i), b)) stdout.flush() resp3 = int(raw_input()) if resp3 == -1: b += 2**(m-1-i) a += 2**(m-1-i) print('! {} {}'.format(a,b)) stdout.flush()",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",550
"print('?', 0, 0, flush=True) t = int(input()) s = [0]*31 if t == 1: s[30] = 1 else: s[30] = -1 a = 0 b = 0 for i in range(30, 0, -1): c = (1 << (i-1)) + a d = b print('?', c, d, flush=True) ans1 = int(input()) c = a d = (1 << (i-1)) + b print('?', c, d, flush=True) ans2 = int(input()) if ans1 == -1 and ans2 == 1: a += 1 << (i-1) b += 1 << (i-1) s[i-1] = s[i] elif ans1 == 1 and ans2 == -1: a += 0 << (i-1) b += 0 << (i-1) s[i-1] = s[i] else: s[i-1] = ans1 if s[i] == 1: a += 1 << (i-1) b += 0 << (i-1) else: a += 0 << (i-1) b += 1 << (i-1) print('!', a, b)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",558
"print(""? 0 0"", flush=True) res = input() i = 1 a = 0 b = 0 for i in range(29,-1,-1): print(""?"",(a^(1<<i)), b, flush=True) res1 = input() print(""?"",a, (b^(1<<i)), flush=True) res2 = input() if res1 == res2: if res == '1': a ^= (1<<i) else: b ^= (1<<i) res = res1 elif res1 == '-1': a ^= (1<<i) b ^= (1<<i) print(""!"", a, b, flush=True)",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",333
"import sys def query(c, d): print('? %d %d' % (c, d)) sys.stdout.flush() res = int(input()) return res a = 0 b = 0 big = query(0, 0) for i in range(29, -1, -1): p = query(a ^ (1 << i), b) q = query(a, b ^ (1 << i)) if p == q: if big == 1: a ^= 1 << i else: b ^= 1 << i big = p elif p == -1: a ^= 1 << i b ^= 1 << i print('! %d %d' % (a, b)) sys.stdout.flush()",constant,"['bitmasks', 'constructive algorithms', 'implementation', 'interactive']",359
"from math import sin pi = 3.141592653589793238462643383279502884197 n, r = map(int,input().split()) theta = 2*pi / n R = r / (1-sin(theta/2)) print(R-r)",constant,"['binary search', 'geometry', 'math']",152
"import math n, r = list(map(int, input().split(' '))) l = 2 * r * math.sin(math.pi/n) R = l * r / (-l + 2*r) print(R)",constant,"['binary search', 'geometry', 'math']",117
"import math n, r = map(float, input().split()) a = math.pi / n s = math.sin(a) R = (r * s) / (1 - s) print(R)",constant,"['binary search', 'geometry', 'math']",109
"import math n, r = map(int, input().split()) angle = math.pi / n s = math.sin(angle) print('%.8f' % (r * s / (1 - s)))",constant,"['binary search', 'geometry', 'math']",118
"import math n,r = [int(x) for x in input().split()] x = math.sin(math.pi/n) y = (x*r)/(1-x) print(y)",constant,"['binary search', 'geometry', 'math']",100
"import math n,r = list(map(int,input().split())) angle = math.pi/(n) c = math.sin(angle) k = c/(1-c) R = k*r R = float(format(R,'.7f')) print(R)",constant,"['binary search', 'geometry', 'math']",144
"def solve(a, b, c): D = b * b - 4 * a * c k = D**0.5 x1 = (-b+k)/(2*a) x2 = (-b-k)/(2*a) return max(x1,x2) from math import * n, r = map(int, input().split()) a = (1/tan(pi/n))**2 b = -2 * r c = -(r*r) ans = solve(a,b,c) print(""%.10f"" % ans)",constant,"['binary search', 'geometry', 'math']",241
"from math import sin, pi n, r = map(int, input().split()) print(r * sin(pi / n) / (1 - sin(pi / n)))",constant,"['binary search', 'geometry', 'math']",100
"from math import sin, pi n, r = map(int, input().split()) def p(n, r): return 2 * n * r * sin(pi / n) le = 0; ri = r * 1000 while ri - le > 1e-9: m = (ri + le) / 2 if p(n, r + m) < n * m * 2: ri = m else: le = m print(m)",constant,"['binary search', 'geometry', 'math']",220
"import math n, r = (int(x) for x in input().split()) s = math.sin(math.pi/n) ans = (r*s)/(1-s) print(""%.7f"" % ans)",constant,"['binary search', 'geometry', 'math']",114
"import math n, r = map(int, input().split()) a = math.pi/n sin = math.sin(a) R = r*sin/(1-sin) print(R)",constant,"['binary search', 'geometry', 'math']",103
"import math n, r = map(int, input().split()) s = math.sin(math.pi / n) print('%.7lf' % (r * s / (1 - s)))",constant,"['binary search', 'geometry', 'math']",105
"from math import pi, sin from decimal import Decimal n, r = map(int, input().split()) alpha = Decimal(pi)/Decimal(n) a = Decimal(sin(alpha)) R = Decimal((r * a) / (1 - a)) print(R)",constant,"['binary search', 'geometry', 'math']",180
"from math import sin n,r=[int(i) for i in input().split()] pi=3.14159265359 print(r/((2*sin(pi*(1/2-1/n)))/(sin(2*pi/n))-1))",constant,"['binary search', 'geometry', 'math']",124
"from math import sin, pi n, r = map(int, input().split()) R = r*sin(pi/n)/(1-sin(pi/n)) print(R)",constant,"['binary search', 'geometry', 'math']",96
"import math n,r=map(int,input().split()) print(r/( 1/math.cos(math.pi*(n-2)/2/n)-1))",constant,"['binary search', 'geometry', 'math']",84
"import math n, r = [int(i) for i in input().split()] t = math.sin(math.pi/n) res = r*t/(1-t) print(res)",constant,"['binary search', 'geometry', 'math']",103
"from math import pi, sin n, r = map(float, input().split()) ang = pi / n k = sin(ang) print(k * r / (1 - k))",constant,"['binary search', 'geometry', 'math']",108
"import math N,r=map(int,input().split()) print(r*math.sin(math.pi/N)/(1-math.sin(math.pi/N)))",constant,"['binary search', 'geometry', 'math']",93
"n,k=map(int,input().split()) if k>=n-1: print(n-1) else: print(k+ ((n-k)*(n-k+1))//2 - 1)",constant,"['dp', 'greedy', 'math']",89
"n, v = map(int, input().split()) result = v-1 + (n-v)*(n-v+1)//2 if n-1 > v else n-1 print(result)",constant,"['dp', 'greedy', 'math']",98
if __name__ == '__main__': nums = input().split() n = int(nums[0]) v = int(nums[1]) if n < v+2: print(n - 1) else: print(int(v-1 + (n-v)*(n-v+1)/2)),constant,"['dp', 'greedy', 'math']",148
"citys,cap=map(int,input().split()) if citys-1<=cap: print(citys-1) else: n=citys-cap print(n*(n+1)//2+cap-1)",constant,"['dp', 'greedy', 'math']",108
"s = map(int, raw_input().rstrip().split()) n = s[0] v = s[1] primo = min(n -1, v) if primo == n-1: print(primo) else: rimane = n - primo print(primo - 1 + (rimane)*(rimane + 1) / 2)",constant,"['dp', 'greedy', 'math']",181
"from operator import itemgetter n, v = map(int, input().split()) if v >= n-1: ans = n-1 else: ans = v + ((2+(2+n-v-2))*(n-v-1))//2 print(ans)",constant,"['dp', 'greedy', 'math']",141
"n,v = [int(x) for x in input().strip().split("" "")] if v>=(n-1): print(n-1) else: print(n-1+((n-1-v)*(n-v)//2))",constant,"['dp', 'greedy', 'math']",110
"list_int_input = lambda inp: list(map(int, inp.split())) int_input = lambda inp: int(inp) string_to_list_input = lambda inp: list(inp) n,v=map(int,input().split()) val=v-1+int(((n-v)*(n-v+1))/2) if n>v: print(val) else: print(n-1)",constant,"['dp', 'greedy', 'math']",230
"n, v = map(int, input().split()) if n - 1 > v: print(v + (n - v + 2) * (n - v - 1) // 2) else: print(n - 1)",constant,"['dp', 'greedy', 'math']",107
"n,v=[int(x) for x in input().split()] if v>=(n-1): print(n-1) else: print(int((((n-v)*(n-v+1))/2)-1+v))",constant,"['dp', 'greedy', 'math']",103
"n,v = map(int,input().split()) if n <= v + 1: print( n - 1 ) else: b = n - v print( v - 1 + ((b*(b+1))//2))",constant,"['dp', 'greedy', 'math']",107
"n, v = list(map(int, input().split())) f = lambda x: x*(x+1)//2 print(min(n-1, v)+f(n-min(n-1, v))-1)",constant,"['dp', 'greedy', 'math']",101
"n, k = [int(x) for x in input().split()] if k == 1: print(""1"" + ""0""*(n-1)) elif 3*k <= n: print((""0"" * ((n-k)//2)) + ""1"" + (""0""*(k-2)) + ""1"" + ""0"" * ((n-k)//2)) else: tmp = ""0"" * ((n-k)//2) + ""1"" s = tmp s = tmp * (n // len(tmp) + 1) s = s[:n] print(s)",constant,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",252
"n, k = [int(x) for x in input().split()] if k == 1: print(""1"" + ""0""*(n-1)) else: tmp = ""0"" * ((n-k)//2) + ""1"" s = tmp s = tmp * (n // len(tmp) + 1) s = s[:n] print(s)",constant,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",166
"n, k = map(int, input().split()) if n == k: print('1' * n) elif k == 1: print('0' + '1' * (n - 1)) else: x = (n - k) // 2 a = '0' * x + '1' print(a * (n // (x + 1)) + '0' * (n % (x + 1)))",constant,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",187
"from math import * from fractions import * def li(): return list(map(int, input().split("" ""))) n,k = li() if k == 1: print(""1"" + ""0""*(n-1)) else: a = (n-k)//2 p = ""1"" + ""0""*a ans = p * (n//(a+1)) + p[:(n%(a+1))] print(ans)",constant,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",222
k = int(input()) if k<=9: print(k) else: num_arr = [9*(i+1)* 10**i for i in range(11)] index = 0 while True: if k<=num_arr[index]: break else: k -= num_arr[index] index += 1 digit = index+1 k += digit-1 num = k//digit offset = k%digit string_num = str(10**(digit-1)+ num-1) print(string_num[offset]),constant,"['binary search', 'divide and conquer', 'implementation']",299
"import math n=int(input()) a=[9] for i in range(2,20): a.append(10**i - 10**(i-1) ) b=[0] for i in range(1,20): b.append(b[-1]+ i*a[i-1]) for i in range(20): if n<=b[i]: break p=b[i-1] k=n-p ans=10**(i-1) - 1 + math.ceil(k/(i)) if k%i==0: print(('0'+str(ans))[i]) else: print(('0'+str(ans))[k%i])",constant,"['binary search', 'divide and conquer', 'implementation']",296
k = int(input()) ch = 0 i = 0 r = 1 while k > r - 1: r += 9 * (i + 1) * 10 ** i i += 1 r -= 9 * i * 10 ** (i - 1) print(str((k - r) // i + 10 ** (i - 1))[(k - r) % i] ),constant,"['binary search', 'divide and conquer', 'implementation']",168
k=int(input()) i=0 r=1 while(k>=r): r+=9*(i+1)*10**i i+=1 r=r-(9*i*10**(i-1)) ans=str(((k-r)//i)+10**(i-1))[(k-r)%i] print(ans),constant,"['binary search', 'divide and conquer', 'implementation']",127
k = int(input()) prev=0 nextt=0 NumofDigits=0 while(True): prev = nextt nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits) if(k>= prev and k<=nextt): break NumofDigits=NumofDigits+1 if(NumofDigits==1): print(k) else: result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits) i=0 while(True): if (k-int(prev+1))%NumofDigits == i: break i=i+1 result = str(result) print(result[i]),constant,"['binary search', 'divide and conquer', 'implementation']",382
"a = int(input()) c = [1] * 30 for i in range (1,20): c[i] = 9 * i * pow(10,i-1) for i in range (1,15): if (a > c[i]): a -= c[i] else: d = int((a-1) / i + pow(10,i-1) - 1) e = (a-1) % i + 1 f = str(d+1) print(f[e-1]) exit()",constant,"['binary search', 'divide and conquer', 'implementation']",222
n=input() i=0 while(True): if (n-9*10**i*(i+1))<=0: break n-=9*10**i*(i+1) i+=1 a=n/(i+1) b=n%(i+1) if(b!=0): print(str(10**i+a)[b-1]) else: print(str(10**i+a-1)[-1]),constant,"['binary search', 'divide and conquer', 'implementation']",166
k = int(input()) - 1 l = 1 c = 9 while k >= c*l: k -= c * l l += 1 c *= 10 c = 10**(l-1) + k // l print(str(c)[k % l]),constant,"['binary search', 'divide and conquer', 'implementation']",118
"def mp(): return map(int, input().split()) def f(i): return (10 ** i - 10 ** (i - 1)) * i n = int(input()) i = 1 sum = 0 while n - f(i) >= 0: n -= f(i) sum += f(i) // i i += 1 print(str(sum + (n + i - 1) // i)[n % i - 1])",constant,"['binary search', 'divide and conquer', 'implementation']",221
"from sys import stdin def solve(tc): k = int(stdin.readline().strip()) cmp = 9 ndigit = 1 while k>(cmp*ndigit): k -= cmp*ndigit cmp *= 10 ndigit += 1 num = (10**(ndigit-1)) + ((k-1) // ndigit) pos = (k-1) % ndigit print(str(num)[pos]) pass LOCAL_TEST = not __debug__ if LOCAL_TEST: infile = __file__.split('.')[0] + ""-test.in"" stdin = open(infile, 'r') tcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1) tc = 1 while tc <= tcs: solve(tc) tc += 1",constant,"['binary search', 'divide and conquer', 'implementation']",453
"import sys k=int(input()) if type(k)!=int or k<=0 or k>pow(10,12) : print(""wrong input. try again"") sys.exit() lim_init=lim=decimal=9 c=0 while True: c+=1 if k<=lim: diff=lim-k pos=diff%c diff=int(diff/c) diff=decimal-diff print(''.join(list(reversed(str(diff))))[pos]) break else: decimal = int(str(lim_init)*(c+1)) lim+=int(str(lim_init)+'0'*c)*(c+1)",constant,"['binary search', 'divide and conquer', 'implementation']",352
n=int(input()) x=1 while n>(10**(len(str(x))-1)*9*len(str(x))): n-=10**(len(str(x))-1)*9*len(str(x)) x*=10 t=len(str(x)) nadighe=False while nadighe==False: qw=1 nadighe=True while n>(10**(len(str(qw))-1)*9*t): n-=10**(len(str(qw))-1)*9*t nadighe=False qw*=10 x+=qw-1 while n>len(str(x)): n-=len(str(x)) x+=1 for i in range(len(str(x))): if n!=0: s=str(x)[i] n-=1 print(s),constant,"['binary search', 'divide and conquer', 'implementation']",372
n = int(input()) limit_int = limit = decimal = 9 count = 0 while True: count += 1 if n <= limit: difference = limit - n position = difference % count difference = difference // count difference = decimal - difference print(''.join(list(reversed(str(difference))))[position]) break else: decimal = int(str(limit_int) * (count + 1)) limit += int(str(limit_int) + '0' * count) * (count + 1),constant,"['binary search', 'divide and conquer', 'implementation']",387
k=int(input()) num_digits=1 num_numbers=9 k-=1 while k>num_digits*num_numbers: k -= num_numbers*num_digits num_digits += 1 num_numbers *= 10 number = 10**(num_digits - 1) + k // num_digits index = k % num_digits answer = str(number)[index] print(answer),constant,"['binary search', 'divide and conquer', 'implementation']",253
L = [(i+1)*9*10**i for i in range(12)] number = int(input()) exponent=0 while number >= 0: number-=L[exponent] exponent+=1 exponent-=1 number%=L[exponent] start = 10**exponent numDigits = exponent+1 final = start+(number//numDigits-1) remainder = number%numDigits if remainder == 0: final = str(final) print(final[-1]) else: final = str(final+1) print(final[remainder-1]),constant,"['binary search', 'divide and conquer', 'implementation']",371
"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889) k = int(input()) a = 0 for i in T: if i - k > 0: a = T.index(i) break temp = T[a] - k x = temp % a res = (10 ** a) - 1 - int(temp / a) ans = int((res % (10 ** (x+1))) / (10 ** x)) print(ans)",constant,"['binary search', 'divide and conquer', 'implementation']",297
k=int(input()) x=0 c=0 while(x<k): x+=9*(10**c)*(c+1) c+=1 p=(x-k)%c k=((10**c)-int(((x-k)/c))-1) k=str(k) print(k[len(k)-(p)-1]),constant,"['binary search', 'divide and conquer', 'implementation']",129
"k=int(input()) a=[] for i in range(0,12): s=9*pow(10,i)*(i+1) if k<=s: break else: k-=s pos=i+1 num=(pow(10,pos-1)+(k//pos)-1) if k%pos==0: print(str(num)[-1]) else: print(str(num+(0 if pos==1 else 1))[(k%pos)-1])",constant,"['binary search', 'divide and conquer', 'implementation']",213
index = int(input()) total = 9 n = 1 while index > total: total += (n + 1) * (10**n) * 9 n += 1 last = 10**(n - 1) total -= n * 9 * last index = index - total r = index % (n) k = index // n number = last + k if r == 0: print(str(number - 1)[n-1]) else: print(str(number)[r - 1]),constant,"['binary search', 'divide and conquer', 'implementation']",278
n = int(input()) a = n * (n + 1) // 2 print(4 * a - 4 * n + 1),constant,"['dp', 'implementation', 'math']",62
n=int(input()) print(int(n**2+(n-1)**2)),constant,"['dp', 'implementation', 'math']",40
n=int(input()) print(2*(n*(n-1))+1),constant,"['dp', 'implementation', 'math']",35
a = int(input()) print(a * (a - 1) * 2 + 1),constant,"['dp', 'implementation', 'math']",43
a = int(input()) print(a**2+(a-1)**2),constant,"['dp', 'implementation', 'math']",37
n=int(input())-1 print(2*n*(n+1)+1),constant,"['dp', 'implementation', 'math']",35
n = int(input()) print(n**2 + (n-1)**2),constant,"['dp', 'implementation', 'math']",39
n = int(input()) print(n**2+((n-1)**2)),constant,"['dp', 'implementation', 'math']",39
n=int(input()) print(n**2+(n-1)**2),constant,"['dp', 'implementation', 'math']",35
import sys sys.setrecursionlimit(int(1e7)) def main(): n = int(input().strip()) print(2*(n*(n-1))+1) return while 1: try: main() except EOFError: break,constant,"['dp', 'implementation', 'math']",151
n=int(input()) print(2*n*n-2*n+1),constant,"['dp', 'implementation', 'math']",33
"def main(): n = int(input()) ans = n * n + (n - 1) * (n - 1) print(ans) if __name__ == ""__main__"": main()",constant,"['dp', 'implementation', 'math']",105
n = int(input()) ans = (2 * (n - 1) ** 2) + 2 * n - 1 print(ans),constant,"['dp', 'implementation', 'math']",64
n = int(input()) print(1+2*((n-1)*n)),constant,"['dp', 'implementation', 'math']",37
n = int(input().strip()) print(n**2+(n-1)**2),constant,"['dp', 'implementation', 'math']",45
n = int(input()) print(n * n + (n - 1) **2),constant,"['dp', 'implementation', 'math']",43
n = int(input()) print(2*(n**2)-2*n+1),constant,"['dp', 'implementation', 'math']",38
n=int(input()) print(2*n**2-2*n+1),constant,"['dp', 'implementation', 'math']",34
"t1, t2, t3 = input().split() ans = 2 if t1 == t2 or t2 == t3 or t3 == t1: if t1 == t2 == t3: ans = 0 else: ans = 1 aaa = [] for i in range(10): for j in range(10): for k in range(10): if k - j == j - i == 1: aaa.append({i, j, k}) if t1[1] == t2[1] == t3[1] and {int(t1[0]), int(t2[0]), int(t3[0])} in aaa: ans = 0 elif (t1[1] == t2[1] and (abs(int(t1[0]) - int(t2[0])) == 1 or abs(int(t1[0]) - int(t2[0])) == 2)) or (t1[1] == t3[1] and (abs(int(t1[0]) - int(t3[0])) == 1 or abs(int(t1[0]) - int(t3[0])) == 2)) or (t3[1] == t2[1] and (abs(int(t3[0]) - int(t2[0])) == 1 or abs(int(t3[0]) - int(t2[0])) == 2)): ans = min(1, ans) print(ans)",constant,"['brute force', 'implementation']",636
"from math import sqrt as sqrt n, k = map(int, input().split()) t = int(sqrt(8 * n + 8 * k + 9) + 0.0001) m = (t - 3) // 2 print(n - m)",constant,"['binary search', 'brute force', 'math']",134
"n, k = map(int, input().split()) c = n + k p = int(0.5 * ((8 * c + 9) ** 0.5 - 3)) print(n - p)",constant,"['binary search', 'brute force', 'math']",95
"from math import * n,k=map(int,input().split()) val=int(sqrt(9+(8*(n+k)))) ans=(-3+val)//2 print(n-ans)",constant,"['binary search', 'brute force', 'math']",103
"import time (n, k) = (int(i) for i in input().split()) start = time.time() print((2*n+3-int((9+8*(n+k))**0.5))//2) finish = time.time()",constant,"['binary search', 'brute force', 'math']",135
"import sys import math n, k = list(map(int, sys.stdin.readline().strip().split())) a = (2 * n + 3 - math.sqrt((2*n+3)**2 - 4 * (n**2 + n - 2 * k))) // 2 print(int(a))",constant,"['binary search', 'brute force', 'math']",166
"n,k=map(int,input().split()) for i in range(10**5): if (i*(i+1))//2-(n-i)==k: print(n-i)",constant,"['binary search', 'brute force', 'math']",88
"import math n,k = [int(x) for x in input().split(' ')] ans = ((2*n + 3) - int(math.sqrt(8*n + 8*k + 9)))//2 print(ans);",constant,"['binary search', 'brute force', 'math']",119
"n, k = map(int, input().split()) d = int((9 + 8 * (n + k)) ** 0.5) x = (d - 3) // 2 print(n - x)",constant,"['binary search', 'brute force', 'math']",96
"from math import sqrt n, k = map(int, input().split()) print(int(n - 0.5 * (sqrt(8 * (k + n) + 9) - 3)))",constant,"['binary search', 'brute force', 'math']",104
"import math n, k = map(int, input().split()) q = int(-3 + math.sqrt(9 + 8*(n+k)))//2 r = n-q print(r)",constant,"['binary search', 'brute force', 'math']",101
"n,k=[int(i) for i in input().split()] a = pow(1+2*k+2*n,0.5) - 1 print(n-int(a))",constant,"['binary search', 'brute force', 'math']",80
"from sys import stdin, stdout, exit import math n, k = map(int, stdin.readline().split()) ans = round((-3 + math.sqrt(9 + 8*(k+n))) / 2) stdout.write(str(n-ans) + ""\n"")",constant,"['binary search', 'brute force', 'math']",168
"n,k=map(int,input().split()) b=(9+8*(n+k))**0.5 a=int(b) print(n-(a-3)//2)",constant,"['binary search', 'brute force', 'math']",74
"def find(n,k): x=9+8*(n+k) a=(-3+int(x**0.5))//2 b=n-a return b n,k=list(map(int,input().strip().split(' '))) print(find(n,k))",constant,"['binary search', 'brute force', 'math']",126
"n, k = map(int, input().split()) a = 1 b = -(2*n+3) c = (n*n+n-2*k) d = int((b*b - 4*a*c) ** 0.5) s1 = (-b + d) // (2 * a) s2 = (-b - d) // (2 * a) if s1 >= 0 and s1 <= n: print(s1) else: print(s2)",constant,"['binary search', 'brute force', 'math']",197
"def MI(): return map(int,input().split()) def I(): return int(input()) def LI(): return [int(i) for i in input().split()] n,k=MI() b=-(2*n+3) c=n*n+n-2*k x=(-b-((b*b-4*c)**0.5))//2 y=(-b+((b*b-4*c)**0.5))//2 x,y=int(x),int(y) for i in [x-1,x,x+1,y-1,y,y+1]: if i**2+b*i+c==0 and 0<=i<=n-1: print(i) break",constant,"['binary search', 'brute force', 'math']",304
"from math import sqrt n, k = map(int, input().split()) answer = int(-1.5 + sqrt(9/4 + 2*(n+k))) print(n - answer)",constant,"['binary search', 'brute force', 'math']",113
"t=int(input()) for i in range(t): n=int(input()) g=list(map(int,input().split())) m1=max(g) g.remove(m1) m2=max(g) dl=len(g)-1 print(min(dl,m2-1))",constant,"['greedy', 'math', 'sortings']",146
"read = lambda: map(int, input().split()) def sq(x): return int(x ** 0.5) ** 2 == x t = int(input()) for _ in range(t): n = int(input()) if (n % 2 == 0 and sq(n // 2)) or (n % 4 == 0 and sq(n // 4)): print('YES') else: print('NO')",constant,"['brute force', 'geometry', 'math', 'number theory']",229
"def solve(): n = int(input()) for d in [2,4]: if n % d != 0: continue temp = int((n//d) ** (0.5)) temp -= 1 while temp*temp < n//d: temp += 1 if temp*temp == n//d: print(""YES"") return print(""NO"") for _ in range(int(input())): solve()",constant,"['brute force', 'geometry', 'math', 'number theory']",233
"from math import sqrt for _ in ' '*int(input()): n = int(input()) if int(sqrt(n/2)) == sqrt(n/2) or int(sqrt(n/4)) == sqrt(n/4): print(""YES"") else: print(""NO"")",constant,"['brute force', 'geometry', 'math', 'number theory']",159
"def divisors(M): d=[] i=1 while M>=i**2: if M%i==0: d.append(i) if i**2!=M: d.append(M//i) i=i+1 return d def popcount(x): x = x - ((x >> 1) & 0x55555555) x = (x & 0x33333333) + ((x >> 2) & 0x33333333) x = (x + (x >> 4)) & 0x0f0f0f0f x = x + (x >> 8) x = x + (x >> 16) return x & 0x0000007f def eratosthenes(n): res=[0 for i in range(n+1)] prime=set([]) for i in range(2,n+1): if not res[i]: prime.add(i) for j in range(1,n//i+1): res[i*j]=1 return prime def factorization(n): res=[] for p in prime: if n%p==0: while n%p==0: n//=p res.append(p) if n!=1: res.append(n) return res def euler_phi(n): res = n for x in range(2,n+1): if x ** 2 > n: break if n%x==0: res = res//x * (x-1) while n%x==0: n //= x if n!=1: res = res//n * (n-1) return res def ind(b,n): res=0 while n%b==0: res+=1 n//=b return res def isPrimeMR(n): if n==1: return 0 d = n - 1 d = d // (d & -d) L = [2, 3, 5, 7, 11, 13, 17] for a in L: t = d y = pow(a, t, n) if y == 1: continue while y != n - 1: y = (y * y) % n if y == 1 or t == n - 1: return 0 t <<= 1 return 1 def findFactorRho(n): from math import gcd m = 1 << n.bit_length() // 8 for c in range(1, 99): f = lambda x: (x * x + c) % n y, r, q, g = 2, 1, 1, 1 while g == 1: x = y for i in range(r): y = f(y) k = 0 while k < r and g == 1: ys = y for i in range(min(m, r - k)): y = f(y) q = q * abs(x - y) % n g = gcd(q, n) k += m r <<= 1 if g == n: g = 1 while g == 1: ys = f(ys) g = gcd(abs(x - ys), n) if g < n: if isPrimeMR(g): return g elif isPrimeMR(n // g): return n // g return findFactorRho(g) def primeFactor(n): i = 2 ret = {} rhoFlg = 0 while i*i <= n: k = 0 while n % i == 0: n //= i k += 1 if k: ret[i] = k i += 1 + i % 2 if i == 101 and n >= 2 ** 20: while n > 1: if isPrimeMR(n): ret[n], n = 1, 1 else: rhoFlg = 1 j = findFactorRho(n) k = 0 while n % j == 0: n //= j k += 1 ret[j] = k if n > 1: ret[n] = 1 if rhoFlg: ret = {x: ret[x] for x in sorted(ret)} return ret def divisors(n): res = [1] prime = primeFactor(n) for p in prime: newres = [] for d in res: for",constant,"['brute force', 'geometry', 'math', 'number theory']",2000
"def chk(n): return int(n**0.5+0.1)**2 == n for _ in range(int(input())): n = int(input()) if n % 2 == 0 and chk(n//2) or n % 4 == 0 and chk(n//4): print(""YES"") else: print(""NO"")",constant,"['brute force', 'geometry', 'math', 'number theory']",177
"import sys input = sys.stdin.readline ok = set() for i in range(114514): x = i * i ok.add(2 * x) ok.add(4 * x) t = int(input()) for _ in range(t): n = int(input()) ans = ""YES"" if n in ok else ""NO"" print(ans)",constant,"['brute force', 'geometry', 'math', 'number theory']",207
"import io import os def solve(N,): if N % 2 != 0: return ""NO"" N //= 2 if int(N ** 0.5) ** 2 == N: return ""YES"" if N % 2 != 0: return ""NO"" N //= 2 if int(N ** 0.5) ** 2 == N: return ""YES"" return ""NO"" if __name__ == ""__main__"": input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline TC = int(input()) for tc in range(1, TC + 1): (N,) = [int(x) for x in input().split()] ans = solve(N,) print(ans)",constant,"['brute force', 'geometry', 'math', 'number theory']",400
"import os import sys from io import BytesIO, IOBase def main(): from math import sqrt for _ in range(int(input())): n = int(input()) if (round(sqrt(n)) ** 2 == n and n % 2 == 0) or round(sqrt(n * 2)) ** 2 == 2 * n: print(""YES"") else: print(""NO"") BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",constant,"['brute force', 'geometry', 'math', 'number theory']",1624
"t=int(input()) k=set() for i in range(1,10**5): k.add(4*i*i) k.add(2*i*i) for _ in range(t): n=int(input()) if n in k: print('YES') else: print('NO')",constant,"['brute force', 'geometry', 'math', 'number theory']",149
"import sys input=sys.stdin.readline hashi=dict() for i in range(1,10**5): hashi[i*i]=1 hashi[(2*i*i)]=1 t=int(input()) for you in range(t): n=int(input()) if(n%2): print(""NO"") continue z=n//2 if(z in hashi): print(""YES"") else: print(""NO"")",constant,"['brute force', 'geometry', 'math', 'number theory']",238
"import sys,math input = sys.stdin.readline out = [] t = int(input()) for _ in range(t): n = int(input()) o1 = math.isqrt(n//2) o2 = math.isqrt(n//4) if 2 * o1 * o1 == n or 4 * o2 * o2 == n: out.append('YES') else: out.append('NO') print('\n'.join(out))",constant,"['brute force', 'geometry', 'math', 'number theory']",252
"def checksq(n): m = int(n**0.5) if m * m == n: return m m += 1 if m * m == n: return m return -1 def main(): n = int(input()) if n % 2 == 1: print(""NO"") return if checksq(n // 2) != -1: print('YES') return n //= 2 if n % 2 == 1: print('NO') return if checksq(n // 2) != -1: print('YES') else: print('NO') for i in range(int(input())): main()",constant,"['brute force', 'geometry', 'math', 'number theory']",341
"import sys input = sys.stdin.readline def main(): n = int(input()) if n % 2 == 1: print(""NO"") return n //= 2 if n == int(n ** 0.5) ** 2: print(""YES"") return if n % 2 == 1: print(""NO"") return n //= 2 if n == int(n ** 0.5) ** 2: print(""YES"") return print(""NO"") for _ in range(int(input())): main()",constant,"['brute force', 'geometry', 'math', 'number theory']",295
"from sys import stdin t = int(stdin.readline()) for _ in range(t): n = int(stdin.readline()) a = round((n / 2) ** 0.5) b = round((n / 4) ** 0.5) if 2*a**2 == n or 4*b**2 == n: print(""YES"") else: print(""NO"")",constant,"['brute force', 'geometry', 'math', 'number theory']",206
"from math import sqrt def inpl(): return list(map(int, input().split())) def inpi(): return int(input()) def issq(p): x = int(sqrt(p)) return x*x == p def g(n): return (issq(n//2) and n%2==0) or (issq(n//4) and n%4==0) def f(): n = inpi() print(""YES"" if g(n) else ""NO"") t = int(input()) for _ in range(t): f()",constant,"['brute force', 'geometry', 'math', 'number theory']",309
import math def solve(n) : if not n%2 and math.sqrt(n//2) == int(math.sqrt(n//2)) : print('YES') return if not n%4 and math.sqrt(n//4) == int(math.sqrt(n//4)) : print('YES') return print('NO') t = int(input()) for i in range(t) : n = int(input()) solve(n),constant,"['brute force', 'geometry', 'math', 'number theory']",255
"import math for _ in range (int(input())): n=int(input()) s=1 ch=0 for i in range (1,31): s*=2 d=math.sqrt(n//s) if n%s==0 and d==int(d): ch=1 break if ch: print(""YES"") else: print(""NO"")",constant,"['brute force', 'geometry', 'math', 'number theory']",186
"def is_square(x): sq = int(x**0.5) return sq * sq == x for _ in range(int(input())): n = int(input()) if ((n % 2 == 0 and is_square(n//2)) or (n % 4 == 0 and is_square(n//4))): print(""YES"") else: print(""NO"")",constant,"['brute force', 'geometry', 'math', 'number theory']",207
"T = int(input()) for _ in range(T): N = int(input()) if N%2 == 1: print(""NO"") else: N //= 2 if N**(1/2) == int(N**(1/2)): print(""YES"") else: if N%2 == 1: print(""NO"") else: N //= 2 if N**(1/2) == int(N**(1/2)): print(""YES"") else: print(""NO"")",constant,"['brute force', 'geometry', 'math', 'number theory']",240
"import re inputs = int(input()) for x in range(inputs): coordinates = input() match = re.match(""R(\d+)C(\d+)"", coordinates) if match: rows = int(match.group(1)) columns = int(match.group(2)) output = """" i = 0 while columns > 0: alpha_index = (columns // (26 ** i) - 1) % 26 output = chr(65 + alpha_index) + output columns -= (alpha_index + 1) * (26 ** i) i += 1 output += str(rows) print(output) else: match = re.match(""(\D+)(\d+)"", coordinates) letters = match.group(1) rows = match.group(2) columns = 0 for i in range(len(letters), 0, -1): columns += (ord(letters[i - 1]) - 64) * (26 ** (len(letters) - i)) output = f""R{rows}C{columns}"" print(output)",linear,"['implementation', 'math']",652
"from math import floor import re z = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"" def convert_num(x): output = """" row, col = [int(x) for x in re.split(""(\d+)"", x) if x.isnumeric()] while col > 0: y = (col - 1) % 26 output += z[y] col = floor((col - 1) / 26) return f""{output[::-1]}{row}"" def convert_alpha(x): output = 0 word = ("""".join([i for i in x if i.isalpha()]))[::-1] for i in range(0, len(word)): output += (z.index(word[i]) + 1) * 26 ** i ending = x[len(word) :] return f""R{ending}C{output}"" i = int(input()) output = """" for x in range(i): hehexd = input() if hehexd.startswith(""R"") and hehexd[1].isnumeric() and ""C"" in hehexd: output += f""{convert_num(hehexd)}\n"" else: output += f""{convert_alpha(hehexd)}\n"" print(output)",linear,"['implementation', 'math']",716
"def decimal_to_26(num): num = int(num) res = '' while num: mod = num % 26 if mod == 0: res = 'Z' + res num = num // 26 - 1 else: num //= 26 res = chr(mod+64) + res return res def RXCY_to_Excel(c,r): new_row = decimal_to_26(r) return new_row + str(c) n = int(input()) li = [] for i in range(n): li.append(input()) for i in li: di_index = [] al_index = [] temp = i for j in range(len(i)): if i[j].isalpha(): al_index.append(j) i = i.replace(i[j],' ') elif i[j].isdigit(): di_index.append(j) i = i.replace(i[j],' ') i = temp if min(di_index) < max(al_index): row = int(i[1:i.index('C')]) col = int(i[i.index('C')+1:]) print(RXCY_to_Excel(row,col)) else: row_num = 0 for k in range(len(i)): if i[k].isdigit(): num_start = k break length = len(i[0:k]) for m in range(num_start): row_num += 26 ** (length-1) * (ord(i[m])-64) or (ord(i[m])-64) length -= 1 print('R'+i[num_start:]+'C'+str(row_num))",linear,"['implementation', 'math']",890
"def numtostr(a): var=[] while a>0: if a%26==0: var.append(""Z"") a=a//26-1 else: var.append(chr(a%26-1+ord(""A""))) a=a//26 var.reverse() return """".join(var) def strtonum(b): par=len(b) result=0 for i in range(1,par): result+=(26**i) par=len(b)-1 for elem in b: if par!=0: result+=((ord(elem)-ord(""A""))*((26)**par)) else: result += ((ord(elem) - ord(""A""))+1) if par==0: break par -= 1 return result def method1(par1): C=par1.index(""C"") result=numtostr(int(par1[C+1:]))+str(par1[1:C]) return result def method2(par2): c=0 for elem in par2: try: if int(elem): break except: c+=1 return ""R""+par2[c:]+""C""+str(strtonum(par2[:c])) i=input() inp=[] for j in range(int(i)): x=input() inp.append(x) for key in range(len(inp)): if ""R"" in inp[key] and ""C"" in inp[key]: try: if int(inp[key][1:inp[key].index(""C"")]) and int(inp[key][inp[key].index(""C"")+1:]): print(method1(inp[key])) except: print(method2(inp[key])) else: print(method2(inp[key]))",linear,"['implementation', 'math']",930
"for _ in range(int(input())): s = input() ro=co=0 for c in s: if '0'<= c <= '9': ro = 10*ro+int(c) elif ro: ro, co = s[1:].split('C'); co=int(co) v = '' while co: co-=1 r = co%26 co = co//26 v += chr(65+r) print(v[::-1]+ro) break else: co = co*26 + ord(c) - 64 else: print(""R{}C{}"".format(ro, co))",linear,"['implementation', 'math']",297
"import re import string import math letter_number_pattern = ""[a-zA-Z]*[0-9]*"" alpha = dict(zip(range(1,28), string.ascii_uppercase)) decimals = dict(zip(string.ascii_uppercase, range(1,27))) alpha_len = len(alpha) def letter_to_decimal(n): exponents = [] pow_i = 0 while True: if n // (26**pow_i) > 26: exponents.append(1) n = n - (26**pow_i) pow_i += 1 else: exponents.append(n // (26**pow_i)) n = n - ((n // (26**pow_i)) * (26**pow_i)) break pow_i = pow_i - 1 while n != 0: t = n // (26**pow_i) n = n - (t * (26 ** pow_i)) exponents[pow_i] = exponents[pow_i] + t pow_i = pow_i - 1 result = ''.join(list(map(lambda x: alpha[x], reversed(exponents)))) return result def letters_to_deci(letters): total_sum = 0 pows = list(reversed(range(len(letters)))) for i in range(len(letters)): total_sum += decimals[letters[i]] * (26**pows[i]) return total_sum input_cells = [] n_lines = input() for i in range(int(n_lines)): input_cells.append(input()) for cell in input_cells: all_matches = re.findall(letter_number_pattern, cell)[:-1] if len(all_matches) == 2: rows = int(re.search(""[0-9]*$"", all_matches[0]).group()) cols = int(re.search(""[0-9]*$"", all_matches[1]).group()) converted_cols = letter_to_decimal(cols) print(""%s%s"" % (converted_cols, rows)) elif len(all_matches) == 1: rows = re.match(""[A-Z]*"", all_matches[0]).group() cols = re.search(""[0-9]*$"", all_matches[0]).group() converted_rows = letters_to_deci(rows) print(""R%sC%s"" % (cols, converted_rows)) else: pass",linear,"['implementation', 'math']",1467
"def parse(line): i = 0 while line[i].isalpha(): i += 1 i1 = i while i < len(line) and line[i].isdigit(): i += 1 return line[:i1], int(line[i1:i]), line[i:] for _ in range(int(input())): a1, n1, rest = parse(input()) if rest: _, n2, _ = parse(rest) a2 = '' while n2: r = (n2 - 1) % 26 a2 = chr(r + ord('A')) + a2 n2 = (n2 - r - 1) // 26 print(a2 + str(n1)) else: n2 = 0 for c in a1: n2 = 26 * n2 + (ord(c) - ord('A') + 1) print(f'R{n1}C{n2}')",linear,"['implementation', 'math']",441
"def solution(): n = int(input()) for _ in range(n): s = input() p = s.find('C') if s[0] == 'R' and s[1].isdigit() and p > 1: r = int(s[1:p]) c = int(s[(p + 1):]) v = list() while c > 0: if c % 26 == 0: v.append('Z') c = (c - 1) // 26 else: v.append(chr(ord('A') + (c % 26 - 1))) c //= 26 v.reverse() print(""%s%d"" % ("""".join(v), r)) else: p = 0 while p < len(s): if s[p].isdigit(): break p += 1 sr = s[:p] sc = s[p:] c = 0 for x in sr: c = c * 26 + (ord(x) - ord('A') + 1) print(""R%sC%d"" % (sc, c)) if __name__ == ""__main__"": solution()",linear,"['implementation', 'math']",535
"def solution(): v = list() n = int(input()) for _ in range(n): s = input() p = s.find('C') if s[0] == 'R' and s[1].isdigit() and p > 1: r = int(s[1:p]) c = int(s[(p + 1):]) v.clear() while c > 0: if c % 26 == 0: v.append('Z') c = (c - 1) // 26 else: v.append(chr(ord('A') + (c % 26 - 1))) c //= 26 v.reverse() print(""%s%d"" % ("""".join(v), r)) else: c = 0 p = 0 while p < len(s): if s[p].isdigit(): break c = c * 26 + (ord(s[p]) - ord('A') + 1) p += 1 print(""R%sC%d"" % (s[p:], c)) if __name__ == ""__main__"": solution()",linear,"['implementation', 'math']",516
"a,k=map(int,input().split()) p=[] for n in range(2,a+1): for i in range(2,int(n**0.5)+1): if n%i==0: break else: p.append(n) c=0 for i in range(0,len(p)-1): n=p[i]+p[i+1]+1 for i in range(2,int(n**0.5)+1): if n%i==0: break else: if n<=a: c+=1 if c>=k: print(""YES"") else: print(""NO"")",linear,"['brute force', 'math', 'number theory']",282
"n,k = map(int,input().split()) B = [1]*(n+1) B[0] = B[1] = 0 for i in range(2,n+1): if B[i] == 1: m = 2 while m*i <= n: B[m*i] = 0 m += 1 C = [] D = [] for i in range(len(B)): if B[i] != 0: D.append(i) for i in range(1,len(D)): c = D[i] + D[i-1] + 1 if c <= n: C.append(c) x = 0 for i in range(len(C)): if B[C[i]] == 1: x += 1 if x >= k: print('YES') else: print('NO')",linear,"['brute force', 'math', 'number theory']",368
"def prime(n): j = 3 while j * j <= n: if n % j == 0: return False j += 2 return True ref = [2] for j in range(3, 1000, 2): if prime(j) == True: ref.append(j) def check(n): for j in range(1, len(ref) - 1): v = n - ref[j] - 1 if ref[j - 1] == v or ref[j + 1] == v: return True if j > n: break return False arr = [] for j in range(3, 1001, 2): if prime(j) == True and check(j) == True: arr.append(j) n, k = [int(j) for j in input().split()] count = 0 for j in range(2, n + 1): if j in arr: count += 1 if count >= k: print(""YES"") else: print(""NO"")",linear,"['brute force', 'math', 'number theory']",543
"n,k=map(int,input().strip().split()) v = [] for i in range(2,n+1): if all(i%j!=0 for j in v): v.append(i) c = 0 for i in range(len(v)-1): if 1+v[i]+v[i+1] in v: c += 1 if c >= k: print(""YES"") else: print(""NO"")",linear,"['brute force', 'math', 'number theory']",209
"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997] n,k=map(int,input().split()) c=0 for i in range(len(l)-1): if(l[i]+l[i+1]+1 in l and l[i]+l[i+1]+1<=n): c+=1 if(c>=k): print('YES') else: print('NO')",linear,"['brute force', 'math', 'number theory']",954
"import math n,k = map(int,input().split()) l=[] c=0 for j in range(2,n): p=0 for i in range(2,int(math.sqrt(j))+1): if j%i==0: p=1 break else: pass if p==0: l.append(j) l+=[n] for i in range(len(l)-1): if (l[i]+l[i+1]+1) in l: c+=1 if c>=k: print(""YES"") else: print(""NO"")",linear,"['brute force', 'math', 'number theory']",271
"def f(n): k=2 while k*k<=n: if n%k==0: return False k+=1 return True n,k=map(int,input().split()) a=[] x=0 for i in range(2,n+1): if f(i): a.append(i) for i in range(len(a)-2): if a[i]+a[i+1]+1 in a: x+=1 if x>=k: print('YES') else: print('NO')",linear,"['brute force', 'math', 'number theory']",244
"import sys import math import bisect from sys import stdin, stdout from math import gcd, floor, sqrt, log from collections import defaultdict as dd from bisect import bisect_left as bl, bisect_right as br from collections import Counter from collections import defaultdict as dd flush = lambda: stdout.flush() stdstr = lambda: stdin.readline() stdint = lambda: int(stdin.readline()) stdpr = lambda x: stdout.write(str(x)) stdmap = lambda: map(int, stdstr().split()) stdarr = lambda: list(map(int, stdstr().split())) mod = 1000000007 def sieve(n): prime = [True for _ in range(n+1)] p = 2 while(p*p <= n): if(prime[p] == True): for i in range(p*p, n+1, p): prime[i] = False p += 1 return prime n,k = stdmap() all = sieve(n) primes = [] for i in range(1, len(all)): if(all[i] == True): primes.append(i) s = Counter(primes) res = 0 for i in range(len(primes)-1): toCheck = primes[i]+primes[i+1]+1 if(toCheck in s): res += 1 if(res >= k): print(""YES"") else: print(""NO"")",linear,"['brute force', 'math', 'number theory']",965
"y = [2] h = [] j = 0 for i in range(3,1000): z = 0 for x in range(2, int(i**0.5)+1): if i%x == 0: z+=1 if z == 0: y.append(i) for i in range(0,len(y)-1): x = y[i]+y[i+1] h.append(x) k = list(input().split()) a = int(k[0]) b = int(k[1]) for i in range(0,len(h)): h[i] = h[i] + 1 g = [] for i in h: z = 0 for x in range(2, int(i**0.5)+1): if i%x == 0: z+=1 if z == 0: g.append(i) for i in g: if i>=2 and i<=a: j+=1 if j >= b: print(""YES"") else: print(""NO"")",linear,"['brute force', 'math', 'number theory']",454
"try: odd, even, oddIndex, evenIndex = 0, 0, 0, 0 n = int(input()) s = list(map(int, input().split())) counter = 0 for i in s: if i % 2 == 0: even += 1 evenIndex = counter else: odd += 1 oddIndex = counter counter += 1 ans = evenIndex + 1 if even == 1 else oddIndex + 1 print(ans) except EOFError as e: pass",linear,['brute force'],306
"n = int(input()) arr = list(map(int, input().split())) codd = 0 ceven = 0 ptodd = -1 pteven = -1 for i in range(n): if arr[i]%2 == 0: ceven += 1 pteven = i else: codd += 1 ptodd = i if ceven == 1: print(pteven+1) else: print(ptodd+1)",linear,['brute force'],233
n=int(input()) def judge(x): if x%2==0: return 0 else: return 1 ls=[int(x) for x in input().split()] if judge(ls[0])==judge(ls[1]): for x in ls[2:]: if judge(x)!=judge(ls[0]): print(ls.index(x)+1) break else: if judge(ls[2])==judge(ls[0]): print(2) elif judge(ls[2])==judge(ls[1]): print(1),linear,['brute force'],290
"a = int(input()) b = list(map(int, input().split())) c = [int(i % 2 == 0) for i in b] if(c.count(1) == 1): print(c.index(1) + 1) else: print(c.index(0) + 1)",linear,['brute force'],156
input() l=[int(x)%2 for x in input().split()] print(l.index(sum(l)==1)+1),linear,['brute force'],73
"n = int(input()) lst = list(map(int, input().split())) evens = [] odds = [] for e, x in enumerate(lst): if x % 2 == 0: evens.append(e + 1) else: odds.append(e + 1) if len(evens) < len(odds): print(evens[0]) else: print(odds[0])",linear,['brute force'],227
"n=int(input()) li=list(map(int,input().split())) lis=[x%2 for x in li] if lis.count(0)>lis.count(1): print(lis.index(1)+1) else: print(lis.index(0)+1)",linear,['brute force'],150
"n = int(input()) a = list(map(int, input().split())) chet = 0 ne_chet = 0 chet1 = [] ne_chet1 = [] for i in range(len(a)): if a[i] % 2 == 0: chet += 1 chet1.append(a[i]) else: ne_chet += 1 ne_chet1.append(a[i]) if chet >= 1 and ne_chet >= 1 and (chet > 1 or ne_chet > 1): break if chet == 1: print(a.index(chet1[0]) + 1) elif ne_chet == 1: print(a.index(ne_chet1[0]) + 1)",linear,['brute force'],371
"n = int(input()) l = list(map(int,input().split())) c1 = 0 c2 = 0 for i in l: if i % 2 == 0: c1+=1 else: c2+=1 for i in range(len(l)-1,-1,-1): if l[i] % 2 == 0: lasteven = i break for i in range(len(l)-1,-1,-1): if l[i] % 2 != 0: lastodd = i break if c1 == 1: print(lasteven + 1) else: print(lastodd + 1)",linear,['brute force'],304
"n, s = int(input()), input() * 2 h = s.count('H') // 2 print(h - max(s[i:i + h].count('H') for i in range(n)))",linear,['two pointers'],110
n=int(input()) a=input() b=a.count('T') c=-1 for i in range(n): d=0 for j in range(b): d+=int(a[(i+j)%n]=='H') if c==-1 or d<c: c=d print(c),linear,['two pointers'],140
"a = int(input()) s = input() d = s.count('H') p = [] for i in range(len(s)): if i+d > len(s): n = d+i - len(s) m = d - n h = s[:m] + s[-n:] k = h.count(""T"") p.append(k) else: h = s[i:d+i] k = h.count(""T"") p.append(k) mi = a for i in range(len(p)): if p[i] < mi: mi = p[i] if s.count(""H"") == 1 or s.count(""T"") == 0: print(0) else: print(mi)",linear,['two pointers'],339
"import sys n=int(input()) s=input() s+=s h=0 for i in range(n): if s[i]=='H': h+=1 ans=h for i in range(n): c=0 for j in range(i,i+h): if s[j]=='T': c+=1 ans=min(ans,c) print(ans)",linear,['two pointers'],179
"def process(S): n = len(S) h_count = 0 answer = float('inf') for c in S: if c=='H': h_count+=1 current = 0 for i in range(h_count): if S[i]=='H': current+=1 answer = min(answer, h_count-current) for i in range(h_count, n+h_count): if i > n-1: i1 = i-n else: i1 = i i2 = i-h_count if S[i1]=='H': current+=1 if S[i2]=='H': current-=1 answer = min(answer, h_count-current) return answer n = int(input()) S = input() print(process(S))",linear,['two pointers'],430
"R = lambda : map(int, input().split()) n = int(input()) s = input() hc, tc = s.count('H'), s.count('T') hr = min([s[i:i + hc].count('T') for i in range(n - hc)]) tr = min([s[i:i + tc].count('H') for i in range(n - tc)]) print(min(hr, tr))",linear,['two pointers'],238
n=int(input()) s=input() h=s.count('H') s=s+s print(min(s[i:i+h].count('T') for i in range(n))),linear,['two pointers'],95
"n, s = int(input()), input() * 2 h = s.count('H') // 2 print(h - max(s[i:i + h].count('H') for i in range(n)))",linear,['two pointers'],110
"def steps(start, target): ans = 0 for i, v in enumerate(start): u = target[i] if v != u: for j in range(i+1, len(start)): a, b = start[j], target[j] if a != b and a == u: start[i], start[j] = start[j], start[i] break ans += 1 return ans def solve(seq): hc = seq.count('H') tc = len(seq) - hc ans = float('inf') for i in range(tc+1): s = ['T'] * i + ['H'] * hc + ['T'] * (tc-i) ans = min(steps(seq.copy(), s), ans) for i in range(hc+1): s = ['H'] * i + ['T'] * tc + ['H'] * (hc-i) ans = min(steps(seq.copy(), s), ans) return ans N = int(input()) line = list(input()) print(solve(line))",linear,['two pointers'],584
"n, k = map(int,input().split()) arr = list(map(int, input().split())) def find_segment(arr, n, k): f = [0]*100001 L = count = 0 R = -1 while R < n-1: R += 1 if f[arr[R]] == 0: count += 1 f[arr[R]] += 1 while count == k: f[arr[L]] -= 1 if f[arr[L]] == 0: print(L+1, R+1) return L += 1 print(-1,-1) find_segment(arr, n, k)",linear,"['bitmasks', 'implementation', 'two pointers']",320
"n,k = map(int,input().split()) a = list(map(int,input().split())) count = 0 b = {} for i in range(n): if a[i] in b: b[a[i]] += 1 else: b[a[i]] =1 if b[a[i]] == 1: count += 1 if count == k: break for j in range(n): if a[j] in b: b[a[j]] -= 1 if b[a[j]] == 0: break if count != k: print(""-1 -1"") else: if n == 1: print(1,1) elif n == 2 and count == 2: print(1,2) else: print(j+1,i+1)",linear,"['bitmasks', 'implementation', 'two pointers']",381
"n,k=map(int, input().split()) a=list(map(int, input().split())) i=0 d=0 x=-1 y=-1 s=[0]*(10**5+1) for j in range (len(a)): s[a[j]]+=1 i+=1 if s[a[j]]==1: d+=1 if i==1: x=j+1 if d==k: y=j+1 break while k!=1 and s[a[x-1]]-1!=0: s[a[x-1]]-=1 x+=1 if x==-1 or y==-1: x=-1 y=-1 print(x,y)",linear,"['bitmasks', 'implementation', 'two pointers']",283
"n, k = map(int, input().split()) values, single, l, r = [int(i) for i in input().split()], set(), -1, -1 for i in range(n): single.add(values[i]) if len(single) == k: l, r = 1, i + 1 break single = set() for i in range(r - 1, max(-1, l - 2), -1): single.add(values[i]) if len(single) == k: l = i + 1 break if len(single) < k: print(-1, -1) else: print(l, r)",linear,"['bitmasks', 'implementation', 'two pointers']",357
"from sys import stdin,stdout from collections import Counter nmbr=lambda:int(stdin.readline()) lst = lambda: list(map(int,stdin.readline().split())) for _ in range(1): n,k=lst() a=lst() d={};r=l=-2 for i in range(n): d[a[i]]=d.get(a[i],0)+1 if len(d)==k: r=i break for i in range(r+1): if d[a[i]]==1: l=i break d[a[i]]-=1 print(l+1,r+1)",linear,"['bitmasks', 'implementation', 'two pointers']",336
"n, k= map(int, input().split()) A = list(map(int, input().split())) C = [0] * 100001 l = 0 r = 0 p = 0 while r<n and p < k: C[A[r]] += 1 if C[A[r]] == 1: p += 1 r += 1 if p != k: print('-1', '-1') else: while p == k: C[A[l]] -= 1 if C[A[l]] == 0: p -= 1 l +=1 l -= 1 print(l+1,r)",linear,"['bitmasks', 'implementation', 'two pointers']",279
"n, k = list(map(int, input().split())) arr = list(map(int, input().split())) count = [0]*(int(1e5+1)) for i in arr: count[i] += 1 s = sum([1 if i>0 else 0 for i in count]) if s < k: print('-1 -1') exit() r = n-1 while True: if count[arr[r]] == 1: s -= 1 if s < k: s += 1 break count[arr[r]] -= 1 r -= 1 l=0 while True: if count[arr[l]] == 1: s -= 1 if s < k: s += 1 break count[arr[l]] -= 1 l += 1 print(l+1, r+1)",linear,"['bitmasks', 'implementation', 'two pointers']",413
"n,k=map(int,input().split()) a=list(map(int,input().split())) q={0} e=0 l=[] for i in range(n): if a[i] not in q: e+=1 q.add(a[i]) if e==k: e=0 q={0} l+=[i] w=10**5 t=0 for i in l: e=0 q={0} for j in range(i,-1,-1): if a[j] not in q: e+=1 q.add(a[j]) if e==k: if w>len(q): w=j+1 t=i+1 break if len(set(a))>=k:print(w,t) else:print(-1,-1)",linear,"['bitmasks', 'implementation', 'two pointers']",337
"n, m = map(int, input().split()) arr = list(map(int, input().split())) d = {} i = 1 for x in arr: if len(d) == m: break d[x] = i i += 1 if len(d) == m: print(min(d.values()), max(d.values())) else: print(-1,-1)",linear,"['bitmasks', 'implementation', 'two pointers']",210
"def process(X, a, b): X1 = set(X) Other = set([]) A = set([]) B = set([]) Both = set([]) for x in X: if a-x in X1 and b-x not in X1: A.add(x) A.add(a-x) elif a-x not in X1 and b-x in X1: B.add(x) B.add(b-x) elif a-x not in X1 and b-x not in X1: return 'NO' else: Both.add(x) start = A.copy() while len(start) > 0: next_s = set([]) for x in start: if b-x in Both: Both.remove(b-x) next_s.add(b-x) if a-b+x in Both: Both.remove(a-b+x) A.add(a-b+x) next_s.add(a-b+x) A.add(b-x) if a-x in Both: Both.remove(a-x) next_s.add(a-x) A.add(a-x) elif a-x in B or a-x not in A: return 'NO' start = next_s start = B.copy() while len(start) > 0: next_s = set([]) for x in start: if a-x in Both: Both.remove(a-x) next_s.add(a-x) if b-a+x in Both: Both.remove(b-a+x) B.add(b-a+x) next_s.add(b-a+x) B.add(a-x) if b-x in Both: Both.remove(b-x) next_s.add(b-x) B.add(b-x) elif b-x in A or b-x not in B: return 'NO' start = next_s answer = [] for x in X: if x in A: answer.append(0) else: answer.append(1) return answer n, a, b = [int(x) for x in input().split()] X = [int(x) for x in input().split()] answer = process(X, a, b) if answer=='NO': print('NO') else: print('YES') print(' '.join(map(str, answer)))",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",1189
"parent = [i for i in range(int(1e5 + 10))] def findSet(u): if parent[u] != u: parent[u] = findSet(parent[u]) return parent[u] def unionSet(u, v): up = findSet(u) vp = findSet(v) parent[up] = vp if __name__ == '__main__': n, a, b = map(int, input().split()) lst = list(map(int, input().split())) temp = {lst[i]: i for i in range(n)} for i in range(n): if a - lst[i] in temp: unionSet(i, temp[a - lst[i]]) else: unionSet(i, n) if b - lst[i] in temp: unionSet(i, temp[b - lst[i]]) else: unionSet(i, n + 1) if findSet(n) == findSet(n + 1): print('NO') else: print('YES') tmp = findSet(n + 1) lst = [0 if findSet(i) == tmp else 1 for i in range(n)] print(*lst)",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",655
"class DisjointSet: def __init__(self, n): self._fa = list(range(n)) def union(self, x, y): x = self.get_father(x) y = self.get_father(y) self._fa[x] = y return y def get_father(self, x): y = self._fa[x] if self._fa[y] == y: return y else: z = self._fa[y] = self.get_father(y) return z def __repr__(self): return repr([self.get_father(i) for i in range(len(self._fa))]) def solve(n, a, b, xs): h = {x: i for i, x in enumerate(xs)} if a == b: if all(a - x in h for x in xs): return [0] * n return False g1 = n g2 = n + 1 ds = DisjointSet(n + 2) for i, x in enumerate(xs): for t in (a, b): if t - x in h: ds.union(i, h[t - x]) for i, x in enumerate(xs): b1 = (a - x) in h b2 = (b - x) in h if b1 + b2 == 0: return False if b1 + b2 == 1: if b1: ds.union(i, g1) else: ds.union(i, g2) if ds.get_father(g1) == ds.get_father(g2): return False group = [None] * n for i, x in enumerate(xs): f = ds.get_father(i) if f < n: return False group[i] = f - n return group n, a, b = map(int, input().split()) xs = list(map(int, input().split())) group = solve(n, a, b, xs) if isinstance(group, list): print('YES') print(' '.join(map(str, group))) else: print('NO')",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",1146
"parent = [i for i in range(int(1e5 + 2))] def findSet(u): if parent[u] != u: parent[u] = findSet(parent[u]) return parent[u] def unionSet(u, v): up = findSet(u) vp = findSet(v) parent[up] = vp if __name__ == '__main__': n, a, b = map(int, input().split()) lst = list(map(int, input().split())) temp = {lst[i]: i for i in range(n)} for i in range(n): if a - lst[i] in temp: unionSet(i, temp[a - lst[i]]) else: unionSet(i, n) if b - lst[i] in temp: unionSet(i, temp[b - lst[i]]) else: unionSet(i, n + 1) pa = findSet(n) pb = findSet(n + 1) if pa == pb: print('NO') else: print('YES') lst = [0 if findSet(i) == pb else 1 for i in range(n)] print(*lst)",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",648
"def findSet(u, parent): if parent[u] != u: parent[u] = findSet(parent[u], parent) return parent[u] def unionSet(u, v, parent): up = findSet(u, parent) vp = findSet(v, parent) parent[up] = vp if __name__ == '__main__': n, a, b = map(int, input().split()) lst = list(map(int, input().split())) parent = [i for i in range(n + 2)] temp = {lst[i]: i for i in range(n)} for i in range(n): if a - lst[i] in temp: unionSet(i, temp[a - lst[i]], parent) else: unionSet(i, n, parent) if b - lst[i] in temp: unionSet(i, temp[b - lst[i]], parent) else: unionSet(i, n + 1, parent) pa = findSet(n, parent) pb = findSet(n + 1, parent) if pa == pb: print('NO') else: print('YES') lst = [0 if findSet(i, parent) == pb else 1 for i in range(n)] print(*lst)",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",737
"parent = [i for i in range(100002)] def findSet(u): if parent[u] != u: parent[u] = findSet(parent[u]) return parent[u] def unionSet(u, v): up = findSet(u) vp = findSet(v) parent[up] = vp if __name__ == '__main__': n, a, b = map(int, input().split()) lst = list(map(int, input().split())) temp = {lst[i]: i for i in range(n)} for i in range(n): if a - lst[i] in temp: unionSet(i, temp[a - lst[i]]) else: unionSet(i, n) if b - lst[i] in temp: unionSet(i, temp[b - lst[i]]) else: unionSet(i, n + 1) pa = findSet(n) pb = findSet(n + 1) if pa == pb: print('NO') else: print('YES') lst = [0 if findSet(i) == pb else 1 for i in range(n)] print(*lst)",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",642
"def find(u): global par if u != par[u]: par[u] = find(par[u]) return par[u] def union(u, v): u = find(u) v = find(v) par[u] = v n, a, b = map(int, input().split()) p = list(map(int, input().split())) mp = dict() for i in range(n): mp[p[i]] = i + 1 par = [i for i in range(n + 2)] for i in range(n): union(i + 1, mp.get(a - p[i], n + 1)) union(i + 1, mp.get(b - p[i], 0)) A = find(0) B = find(n + 1) if A != B: print('YES') print(' '.join(['1' if find(i) == B else '0' for i in range(1, n + 1)])) else: print('NO')",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",513
"def findSet(u): if parents[u] != u: parents[u] = findSet(parents[u]) return parents[u] def unionSet(u, v): up = findSet(u) vp = findSet(v) if up == vp: return if ranks[up] > ranks[vp]: parents[vp] = up elif ranks[up] < ranks[vp]: parents[up] = vp else: parents[up] = vp ranks[vp] += 1 n, a, b = map(int, input().split()) ps = list(map(int, input().split())) mapping = set(ps) parents = {x: x for x in ps} parents['A'] = 'A' parents['B'] = 'B' ranks = {x: 0 for x in ps} ranks['A'] = 0 ranks['B'] = 0 result = True for x in ps: if a - x in mapping: unionSet(x, a - x) else: unionSet(x, 'B') if b - x in mapping: unionSet(x, b - x) else: unionSet(x, 'A') if findSet('A') == findSet('B'): print(""NO"") else: print(""YES"") for i in ps: if findSet(i) == findSet('A'): print(""0"", end = ' ') else: print(""1"", end = ' ')",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",810
"MAX = 100001 parent = [] def makeSet(): global parent parent = [i for i in range(MAX + 1)] def findSet(u): global parent if u != parent[u]: parent[u] = findSet(parent[u]) return parent[u] def unionSet(u, v): up = findSet(u) vp = findSet(v) parent[up] = vp makeSet() n, a, b = map(int, input().split()) p = list(map(int, input().split())) pos = dict() for i in range(n): pos[p[i]] = i + 1 for i in range(n): unionSet(i + 1, pos.get(a - p[i], n + 1)) unionSet(i + 1, pos.get(b - p[i], 0)) A = findSet(0) B = findSet(n + 1) if A != B: print('YES') for i in range(1, n + 1): if findSet(i) == B: print('1', end = "" "") else: print('0', end = "" "") else: print('NO')",linear,"['2-sat', 'dfs and similar', 'dsu', 'graph matchings', 'greedy']",658
"import string n, s, t = int(input()), input(), input() x, i, j = 0, -1, -1 sc_dict = {c: set() for c in string.ascii_lowercase} tc_dict = {c: set() for c in string.ascii_lowercase} sti_dict, tsi_dict = dict(), dict() for ci, sc, tc in zip(range(n), s, t): if sc == tc: continue sc_dict[sc].add(tc) tc_dict[tc].add(sc) sti_dict[sc + tc] = ci tsi_dict[tc + sc] = ci x += 1 for c in string.ascii_lowercase: cs = sc_dict[c] & tc_dict[c] if not cs: continue c2 = cs.pop() x -= 2 i = sti_dict[c + c2] + 1 j = tsi_dict[c + c2] + 1 break else: for c in string.ascii_lowercase: if not sc_dict[c] or not tc_dict[c]: continue x -= 1 i = sti_dict[c + sc_dict[c].pop()] + 1 j = tsi_dict[c + tc_dict[c].pop()] + 1 break print(x) print(i, j)",linear,['greedy'],726
"num=int(input()) a=input() b=input() dic={} lis=[] ham=0 swap1=-1 swap2=-1 p=False q=False for i in range(num): if a[i]!=b[i]: ham+=1 lis.append(i) dic[b[i]]=i for i in lis: if a[i] in dic: p=True swap1=i+1 f=dic[a[i]] swap2=f+1 if a[f]==b[i]: q=True break print(ham-(2 if q else 1 if p else 0)) print(swap1,swap2)",linear,['greedy'],314
"n = int(input()) s = input() t = input() dic, diff = {}, [] res, res1, res2 = 0, -1, -1 for i in range(n) : if s[i] != t[i] : res += 1 diff.append(i) dic[t[i]] = i swap1, swap2 = False, False for i in diff : if s[i] in dic: swap1 = True res1 = i+1 j = dic[s[i]] res2 = j+1 if s[j] == t[i] : swap2 = True break print(res - (2 if swap2 else 1 if swap1 else 0)) print(res1, res2)",linear,['greedy'],376
"__author__ = 'ruckus' n = int(input()) s = input() t = input() dif = {} hem = 0 for i in range(n): if s[i] != t[i]: dif[i] = [s[i], t[i]] hem += 1 change = [] probed = [] k = 0 for i in dif.keys(): if dif[i] in probed: continue probed.append(dif[i]) k += 1 for j in list(dif.keys())[k:]: if dif[i] == dif[j][::-1]: print(hem - 2) print(i + 1, j + 1) quit() if not change and (dif[i][0] == dif[j][1] or dif[j][0] == dif[i][1]): change = [i, j] if change: print(hem - 1) print(change[0] + 1, change[1] + 1) else: print(hem) print('-1 -1')",linear,['greedy'],536
"n = int(input()) s = input() t = input() p = [-1, -1] a = [[-1] * 26 for i in range(26)] k = 0 for i in range(n): if t[i] != s[i]: k += 1 for i in range(n): if t[i] != s[i]: if a[ord(t[i]) - 97][ord(s[i]) - 97] != -1: print(k - 2) print(a[ord(t[i]) - 97][ord(s[i]) - 97] + 1, i + 1) exit() a[ord(s[i]) - 97][ord(t[i]) - 97] = i for i in range(n): if t[i] != s[i]: for j in range(26): if a[j][ord(s[i]) - 97] != -1: print(k - 1) print(a[j][ord(s[i]) - 97] + 1, i + 1) exit() a[ord(s[i]) - 97][ord(t[i]) - 97] = i print(k) print(-1, -1)",linear,['greedy'],534
"n=int(input()) s=list(input()) t=list(input()) d={} ans=0 x,y=-1,-1 for i in range(n): if s[i]!=t[i]: d[(s[i],t[i])]=i ans+=1 l=[chr(i+97) for i in range(26)] for i in l: for j in l: if (i,j) in d and (j,i) in d: ans-=2 x=d[(i,j)]+1 y=d[(j,i)]+1 break if x!=-1: break if x==y==-1: for i in l: for j in l: for k in l: if (i,j) in d and (j,k) in d: ans-=1 x=d[(i,j)]+1 y=d[(j,k)]+1 break if x!=-1: break print(ans) print(x,y)",linear,['greedy'],423
"from sys import stdin,stdout from collections import Counter def ai(): return list(map(int, stdin.readline().split())) def ei(): return map(int, stdin.readline().split()) def ip(): return int(stdin.readline().strip()) def op(ans): return stdout.write(str(ans) + '\n') n = ip() s = input() t = input() value = {} li = [] res1 = 0 res2 =res3 = -1 for i in range(n): if s[i] != t[i]: value[t[i]] = i res1 += 1 li.append(i) p = sq = False for i in li: if s[i] in value: p = True res2 = i+1 f = value[s[i]] res3 = f+1 if s[f] == t[i]: sq = True break print(res1-(2 if sq else 1 if p else 0)) print(res2,res3)",linear,['greedy'],603
"n = int(input()) s = input() t = input() pair2ind = {} letters_s = [0] * 26 letters_t = [0] * 26 non_common = set() cnt = 0 for i in range(n): if s[i] != t[i]: pair2ind[(s[i], t[i])] = i + 1 letters_s[ord(s[i]) - ord('a')] = i + 1 letters_t[ord(t[i]) - ord('a')] = i + 1 non_common.add(i + 1) cnt += 1 sim = -1 for i in range(26): if letters_s[i] != 0 and letters_t[i] != 0: sim = letters_s[i] break else: print(cnt) print(-1, -1) exit() for i in range(n): if s[i] != t[i]: if (t[i], s[i]) in pair2ind: print(cnt - 2) print(pair2ind[(s[i], t[i])], pair2ind[(t[i], s[i])]) exit() non_common.remove(sim) print(cnt - 1) print(sim, letters_t[ord(s[sim-1]) - ord('a')]) exit()",linear,['greedy'],671
"import sys def input(): return sys.stdin.readline().strip() def iinput(): return int(input()) def rinput(): return map(int, sys.stdin.readline().strip().split()) def get_list(): return list(map(int, sys.stdin.readline().strip().split())) n,s=rinput() maxi=s for i in range(n): f,t=rinput() maxi=max(maxi,f+t) print(maxi)",linear,"['implementation', 'math']",320
"def solve(n, p, s): p.append((0, 0)) p.sort() t = 0 while p: x = p.pop() s, t = x[0], max(x[1], t + abs(s - x[0])) return t n, s = [int(x) for x in input().split(' ')] p = [tuple([int(x) for x in input().split(' ')]) for r in range(n)] print(solve(n, p, s))",linear,"['implementation', 'math']",257
"n, s = map(int, input().split()) ans = s f = [] t = [] for i in range(n): f, t = map(int, input().split()) if(t>(s-f)): ans += t - (s-f) s += t - (s-f) print(ans)",linear,"['implementation', 'math']",162
"n, s = map(int, input().split()) ans = s for i in range(n): f, t = map(int, input().split()) ans = max(ans, t+f) print(ans)",linear,"['implementation', 'math']",123
"n, s = map(int, input().split()) ans = s for i in range(n): f, t = map(int, input().split()) if(t>(s-f)): ans += t - (s-f) s += t - (s-f) print(ans)",linear,"['implementation', 'math']",148
"n , s = map(int , input().split()) lst = [] for i in range(n): lst.append(list(map(int , input().split()))) lst = sorted(lst , key =lambda x : x[0] , reverse = True) prev , ans = s , 0 for i in range(n): ans += prev -lst[i][0] if ans < lst[i][1]: ans += (lst[i][1]- ans) prev = lst[i][0] print(ans+prev)",linear,"['implementation', 'math']",303
"import sys from math import sqrt, log, log2, ceil, log10, gcd, floor, pow, sin, cos, tan, pi, inf, factorial from copy import copy, deepcopy from sys import exit, stdin, stdout from collections import Counter, defaultdict, deque from itertools import permutations import heapq from bisect import bisect_left from bisect import bisect_right mod = 1000000007 iinp = lambda: int(sys.stdin.readline()) inp = lambda: sys.stdin.readline().strip() strl = lambda: list(inp().strip().split("" "")) intl = lambda: list(map(int, inp().split("" ""))) mint = lambda: map(int, inp().split()) flol = lambda: list(map(float, inp().split("" ""))) flush = lambda: stdout.flush() def solve(): n,s=mint() cm=0 for i in range(n): fi,ti=mint() if i==0: cm=fi+ti if i!=0: if fi+ti>cm: cm=fi+ti if cm>s: print(cm) else: print(s) t=1 for _ in range(t): solve()",linear,"['implementation', 'math']",829
"n,s=map(int,input().split()) arr=[] for i in range(n): arr.append([]) arr[i]=[int(i) for i in input().split()] arr=sorted(arr,reverse=True,key=lambda x:x[0]) ans,c=0,0 for i in range(n): if i!=0: c=arr[i-1][0] if i==0: ans=ans+s-arr[i][0] else: ans=ans+c-arr[i][0] if arr[i][1]>=ans: ans=ans+(arr[i][1]-ans) ans=ans+arr[n-1][0] print(ans)",linear,"['implementation', 'math']",338
"n,s=map(int,input().split()) mins=s my_dict={} mylist=[] while(n): person,floor=map(int,input().split()) mylist.append(person+floor) n-=1 val=max(mylist) if(val<mins): print(mins) else: print(val)",linear,"['implementation', 'math']",196
"a , b = input(), input() ans = 0 ones = [0 for i in range(len(b)+1)] zeros = [0 for i in range(len(b)+1)] for i in range(len(b)): ones[i] = ones[i-1] + int(b[i]) zeros[i] = i + 1 - ones[i] for i in range(len(a)): if a[i] == '1': ans += zeros[len(b)-len(a)+i] - zeros[i-1] else: ans += ones[len(b)-len(a)+i] - ones[i-1] print(ans)",linear,"['combinatorics', 'strings']",329
"if __name__ == '__main__': a = [int(c) for c in str(input())] b = [int(c) for c in str(input())] b_len = len(b) a_len = len(a) carCountPrefix = [[ 0 for c in range(2)] for _ in range(b_len+1)] b_zero_count = 0 b_one_count = 0 for b_i in range(b_len): if b[b_i] == 0: b_zero_count += 1 elif b[b_i] == 1: b_one_count += 1 carCountPrefix[b_i+1][1] = b_one_count carCountPrefix[b_i+1][0] = b_zero_count res = 0 for cur in range(0, a_len): for dig in range(2): res += (carCountPrefix[b_len - a_len + cur + 1][dig] - carCountPrefix[cur][dig]) * abs(a[cur] -dig) print(res)",linear,"['combinatorics', 'strings']",566
"def solve(a, b): m = len(a) n = len(b) p_b = [0] for x in b[:]: p_b.append(p_b[-1] + int(x)) s = 0 for i in range(m): if a[i] == '0': s += p_b[n - m + 1 + i] - p_b[i] else: s += (n - m + 1) - (p_b[n - m + 1 + i] - p_b[i]) return s a = input() b = input() print(solve(a, b))",linear,"['combinatorics', 'strings']",273
"a = input() b = input() o = [] z = [] c0 = 0 c1 = 0 for i in b: if i == ""0"": c0 += 1 else: c1 += 1 o.append(c1) z.append(c0) n = len(b)-1 m = len(a)-1 ans = 0 for i in range(len(a)): x = a[i] if x == ""1"": ans += z[(n-(m-i))]-z[i] if b[i] == ""0"": ans += 1 else: ans += o[(n - (m - i))] - o[i] if b[i] == ""1"": ans += 1 print(ans)",linear,"['combinatorics', 'strings']",327
"from sys import stdin,stdout mod=10**9+7 t=1 for _ in range(t): a=input() b=input() n=len(a) m=len(b) dp=[[0 for i in range(2)] for j in range(m+1)] dp[1][0]=int(b[0])^1 dp[1][1]=int(b[0]) for i in range(2,m+1): dp[i][0]=dp[i-1][0]+(int(b[i-1])^1) dp[i][1]=dp[i-1][1]+int(b[i-1]) ans=0 for i in range(n): count0=dp[m-n+i+1][0]-dp[i][0] count1=dp[m-n+i+1][1]-dp[i][1] ans+=count0*int(a[i])+count1*(int(a[i])^1) print(ans)",linear,"['combinatorics', 'strings']",420
"first = [int(i) for i in input()] second = [int(i) for i in input()] pref_dists = [ [0] + [int(0 != c) for c in second], [0] + [int(1 != c) for c in second] ] for i in range(1, len(second) + 1): pref_dists[0][i] += pref_dists[0][i - 1] pref_dists[1][i] += pref_dists[1][i - 1] total = 0 for i, c in enumerate(first): end = len(second) - (len(first) - i) total += pref_dists[c][end + 1] - pref_dists[c][i] print(total)",linear,"['combinatorics', 'strings']",417
a=str(input()) b=str(input()) count=0 al=len(a) bl=len(b) s=b[:bl-al+1].count('1') for i in range(al-1): if a[i]=='0': count+=s else: count+=bl-al+1-s s+=int(b[bl-al+i+1])-int(b[i]) if a[-1]=='0': count+=s else: count+=bl-al+1-s print(count),linear,"['combinatorics', 'strings']",241
"import os import sys from io import BytesIO, IOBase def main(): a=list(map(int,input())) b=list(map(int,input())) dff=len(b)-len(a) if dff<0: print(0) exit() lb=len(b) c=[0]*(lb+1) for i in range(lb): c[i+1]=c[i]+b[i] ans=0 for i in range(len(a)): item=a[i] if item: ans+=(dff+1-(c[dff+i+1]-c[i])) else: ans+=(c[dff+i+1]-c[i]) print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = 'x' in file.mode or 'r' not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b'\n') + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode('ascii')) self.read = lambda: self.buffer.read().decode('ascii') self.readline = lambda: self.buffer.readline().decode('ascii') sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip('\r\n') if __name__ == '__main__': main()",linear,"['combinatorics', 'strings']",1716
"a = list(input()) a = [int(x) for x in a] b = list(input()) b = [int(x) for x in b] n = len(a) m = len(b) ans = 0 for i in range(n): ans+=a[i]^b[i] ones = [0 for i in range(m)] zeros = [0 for i in range(m)] for i in range(m): if b[i]: ones[i]=1 else: zeros[i]=1 for i in range(1,m): ones[i]+=ones[i-1] zeros[i]+=zeros[i-1] for i in range(n): if a[i]==1: ans+=zeros[m-n+i]-zeros[i] else: ans+=ones[m-n+i]-ones[i] print(ans)",linear,"['combinatorics', 'strings']",422
"from sys import stdin from bisect import * rints = lambda: [int(x) for x in stdin.readline().split()] rints_2d = lambda n: [rints() for _ in range(n)] n, mem, pos, power = int(input()), [1], [], [] a = sorted(rints_2d(n)) for x, y in a: pos.append(x) power.append(y) for i in range(1, n): ix = bisect_left(pos, pos[i] - power[i]) - 1 if ix == -1: mem.append(1) else: mem.append(mem[ix] + 1) print(n - max(mem))",linear,['dp'],410
"import sys def chain_reaction(n, beacons): table = [0] * n for i in range(n): position = beacons[i][0] power = beacons[i][1] destroyed = 0 r = position - power b = 0 lo = 0 hi = len(beacons) - 1 while lo <= hi: mid = int(lo + (hi - lo) / 2) pos = beacons[mid][0] if beacons[mid][0] < r: lo = mid + 1 else: hi = mid - 1 destroyed += table[hi] destroyed += (i - (hi + 1)) table[i] = destroyed cost = n ind = 0 while ind < len(table): cost = min(cost, n - ind - 1 + table[ind]) ind += 1 return cost n = int(sys.stdin.readline().strip()) beacons = [] for i in range(n): a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")] beacons.append((a, b)) beacons.sort() print(chain_reaction(n, beacons))",linear,['dp'],702
"import sys def chain_reaction(n, beacons): table = [0] * n for i in range(n): position = beacons[i][0] power = beacons[i][1] destroyed = 0 r = position - power b = 0 lo = 0 hi = len(beacons) - 1 while lo <= hi: mid = int(lo + (hi - lo) / 2) pos = beacons[mid][0] if beacons[mid][0] < r: lo = mid + 1 else: hi = mid - 1 destroyed += table[hi] destroyed += (i - (hi + 1)) table[i] = destroyed max_val = max(table) ind = 0 while ind < len(table): if table[ind] == max_val: break ind += 1 cost = (len(table) - ind) + table[ind - 1] options = [] for i in range(n): cost = (n - i) + table[i - 1] options.append(cost) min_cost = min(options) return min(table[n - 1], min_cost) n = int(sys.stdin.readline().strip()) beacons = [] for i in range(n): a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")] beacons.append((a, b)) beacons.sort() print(chain_reaction(n, beacons))",linear,['dp'],876
"import sys def chain_reaction(n, beacons): table = [0] * n for i in range(n): position = beacons[i][0] power = beacons[i][1] destroyed = 0 r = position - power b = 0 lo = 0 hi = len(beacons) - 1 while lo <= hi: mid = int(lo + (hi - lo) / 2) pos = beacons[mid][0] if beacons[mid][0] < r: lo = mid + 1 else: hi = mid - 1 destroyed += table[hi] destroyed += (i - (hi + 1)) table[i] = destroyed options = [] for i in range(n): cost = (n - i) + table[i - 1] options.append(cost) min_cost = min(options) return min(table[n - 1], min_cost) n = int(sys.stdin.readline().strip()) beacons = [] for i in range(n): a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")] beacons.append((a, b)) beacons.sort() print(chain_reaction(n, beacons))",linear,['dp'],739
"import math n = int(input()) beacons = {} sortedKeys = [0]*n for i in range(n): a, b = map(int, input().split(' ')) sortedKeys[i] = a beacons[a] = b sortedKeys.sort() maxA = sortedKeys[-1] sumBeacons = [0]*(maxA+1) count = 0 for a in range(maxA+1): sumBeacons[a] = count if a in beacons: count += 1 f = [0]*(n+1) minF = math.inf for i in range(1, n+1): a = sortedKeys[i-1] b = beacons[a] end = max(0, a-b) numDestroyed = sumBeacons[a] - sumBeacons[end] f[i] = numDestroyed if i-numDestroyed > 0: f[i] += f[(i-1)-numDestroyed] minF = min(minF, f[i]+n-i) print(minF)",linear,['dp'],564
"n = int(input()) dp = [0] * 1000007 majak = [0] * 1000007 q = 1000007 p = 0 for i in range(n): a, b = map(int, input().split()) q = min(q, a) majak[a] = b dp[q] = 1 ma = 1 for i in range(q + 1, 1000003, 1): if(majak[i] == 0): dp[i] = dp[i - 1] else: dp[i] = dp[i - majak[i] - 1] + 1 ma = max(ma, dp[i]) print(n - ma)",linear,['dp'],316
"import sys maxN = 10**6 + 5 dp = [0] * maxN b = [0] * maxN N = int(sys.stdin.readline()) for _ in range(N): beacon = [int(x) for x in sys.stdin.readline().split()] b[beacon[0]] = beacon[1] if b[0] > 0: dp[0] = 1 for i in range(1, maxN): if b[i] == 0: dp[i] = dp[i-1] else: if b[i] >= i: dp[i] = 1 else: dp[i] = dp[i-b[i]-1]+1 print(N-max(dp))",linear,['dp'],342
"n = int(input()) p = [(-(10**6), 0)] + sorted([tuple(map(int, input().split())) for i in range(n)]) dp = [0] * (n + 1) for i in range(1, n + 1): l, r = 0, i while r - l > 1: mid = (l + r) >> 1 if p[i][0] - p[i][1] <= p[mid][0]: r = mid else: l = mid dp[i] = i - r + dp[r - 1] ans = min(dp[i] + (n - i) for i in range(1, n + 1)) print(ans)",linear,['dp'],338
"import sys from math import * def minp(): return sys.stdin.readline().strip() def mint(): return int(minp()) def mints(): return map(int, minp().split()) n = mint() a = [0]*n dp = [0]*n for i in range(n): a[i] = tuple(mints()) a.sort() for i in range(n): x, p = a[i] l = -1 r = n v = x-p while r-l > 1: c = (l + r)//2 if a[c][0] >= v: r = c else: l = c if l == -1: dp[i] = i-l-1 else: dp[i] = i-l-1+dp[l] z = 1e9 for i in range(n): z = min(z,dp[i]+n-i-1) print(z)",linear,['dp'],463
"import sys LI=lambda:list(map(int, sys.stdin.readline().split())) MI=lambda:map(int, sys.stdin.readline().split()) SI=lambda:sys.stdin.readline().strip('\n') II=lambda:int(sys.stdin.readline()) n=II() s=SI() c=set(s) ln=[0]*n for d in c: last=-1 for i, v in enumerate(s): if v==d: last=i if last==-1: ln[i]=int(1e9) else: ln[i]=max(ln[i], i-last+1) print(min(ln))",linear,"['binary search', 'strings', 'two pointers']",363
"def main(): n = int(input()) s = input() u_set = set() for i in s: u_set.add(i) u_cnt = len(u_set) d = {} j = 0 ans = 10**9 for i in range(n): while len(d.keys()) < u_cnt and j < n: d[s[j]] = d.get(s[j], 0) + 1 j += 1 if len(d.keys()) == u_cnt: if j - i < ans: ans = j - i elif j == n: break d[s[i]] -= 1 if d[s[i]] == 0: del d[s[i]] print(ans) if __name__ == '__main__': main()",linear,"['binary search', 'strings', 'two pointers']",378
n = int(input()) pokemons = input() last = {} start_of_all = 0 for i in range(n): ty = pokemons[i] if ty not in last: start_of_all = i last[ty] = 0 minlen = 100001 for i in range(n): ty = pokemons[i] last[ty] = i length = i + 1 - min(last.values()) if i >= start_of_all and length < minlen: minlen = length print(minlen),linear,"['binary search', 'strings', 'two pointers']",320
"import sys import math prime=[True for _ in range(1000001)] def solve(): n,e,h,a,b,c=map(int,input().split()) ans=1e9 for i in range(1,1000001): su=0 ntmp=n tmp1=e tmp2=h tmp1-=i tmp2-=i if (tmp1<0 or tmp2<0 or i>ntmp): break ntmp-=i su+=(c*i) if (ntmp==0): ans=min(ans,su) continue if (a<=b): if ((tmp1//2)>=ntmp): su+=int(a*ntmp) ntmp-=ntmp else: su+=int(a*(tmp1//2)) ntmp-=(tmp1//2) if (ntmp<=(tmp2//3)): su+=int(b*ntmp) ntmp-=ntmp else: su+=int(b*(tmp2//3)) ntmp-=(tmp2//3) else: if ((tmp2//3)>=ntmp): su+=int(b*ntmp) ntmp-=ntmp else: su+=int(b*(tmp2//3)) ntmp-=(tmp2//3) if (ntmp<=(tmp1//2)): su+=int(a*ntmp) ntmp-=ntmp else: su+=int(a*(tmp1//2)) ntmp-=(tmp1//2) if (ntmp==0): ans=min(ans,su) if (ans==1e9): print(""-1"") else: print(ans) def main(): n=int(input()) s=input() m={} have={} cc=0 for c in s: if (c not in m): m[c]=1 else: m[c]+=1 ct=len(m) l=0 ans=1e9 for i in range(0,n): if (s[i] not in have): have[s[i]]=0 cc+=1 have[s[i]]+=1 while(l<=i and have[s[l]]>1): have[s[l]]-=1 l+=1 if (cc==ct): ans=min(ans,i-l+1) print(ans) if __name__ == ""__main__"": main()",linear,"['binary search', 'strings', 'two pointers']",1071
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest sys.setrecursionlimit(111111) INF=99999999999999999999999999999999 class SortedList: def __init__(self, iterable=[], _load=200): values = sorted(iterable) self._len = _len = len(values) self._load = _load self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)] self._list_lens = [len(_list) for _list in _lists] self._mins = [_list[0] for _list in _lists] self._fen_tree = [] self._rebuild = True def _fen_build(self): self._fen_tree[:] = self._list_lens _fen_tree = self._fen_tree for i in range(len(_fen_tree)): if i | i + 1 < len(_fen_tree): _fen_tree[i | i + 1] += _fen_tree[i] self._rebuild = False def _fen_update(self, index, value): if not self._rebuild: _fen_tree = self._fen_tree while index < len(_fen_tree): _fen_tree[index] += value index |= index + 1 def _fen_query(self, end): if self._rebuild: self._fen_build() _fen_tree = self._fen_tree x = 0 while end: x += _fen_tree[end - 1] end &= end - 1 return x def _fen_findkth(self, k): _list_lens = self._list_lens if k < _list_lens[0]: return 0, k if k >= self._len - _list_lens[-1]: return len(_list_lens) - 1, k + _list_lens[-1] - self._len if self._rebuild: self._fen_build() _fen_tree = self._fen_tree idx = -1 for d in reversed(range(len(_fen_tree).bit_length())): right_idx = idx + (1 << d) if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]: idx = right_idx k -= _fen_t",linear,"['binary search', 'strings', 'two pointers']",2000
"M = {} N = int(input()) S = input().strip() s = set() for c in S: s.add(c) M[c] = 0 i = 0; j = -1; aux = 0; ans = 1e10 while j < N - 1: j += 1 M[S[j]] += 1 if M[S[j]] == 1: aux += 1 while M[S[i]] > 1: M[S[i]] -= 1 i += 1 if aux == len(s): ans = min(ans, j - i + 1) print(ans)",linear,"['binary search', 'strings', 'two pointers']",275
"n,s=int(input()),input() p,q,r=len(set(s)),{},10**6 for i in range(n): q[s[i]]=i if len(q)==p:r=min(r,max(q.values())-min(q.values())) print(r+1)",linear,"['binary search', 'strings', 'two pointers']",145
"def bs(l, h): while l < h: m = (l + h) // 2 if gf(m): h = m else: l = m + 1 return l def gf(x): d = {} for i in range(x): if s[i] in d: d[s[i]] += 1 else: d[s[i]] = 1 if len(d) == len(u): return 1 for i in range(x, n): if s[i] in d: d[s[i]] += 1 else: d[s[i]] = 1 d[s[i - x]] -= 1 if not d[s[i - x]]: del d[s[i - x]] if len(d) == len(u): return 1 return 0 n = int(input()) s = input() u = set([*s]) print(bs(1, n))",linear,"['binary search', 'strings', 'two pointers']",414
"n = int(input()) s = input() want = len(set(s)) d = {} j = 0 count = 0 ans = float(""inf"") for i in range(n): if s[i] not in d: d[s[i]] = 0 count+=1 d[s[i]]+=1 if count==want: while d[s[j]]>1: d[s[j]]-=1 j+=1 ans = min(ans,i-j+1) print(ans)",linear,"['binary search', 'strings', 'two pointers']",239
"import sys n = int(sys.stdin.buffer.readline().decode('utf-8')) cost = [0] + \ list(map(int, sys.stdin.buffer.readline().decode('utf-8').split())) a = [line.decode('utf-8').rstrip() for line in sys.stdin.buffer] mask = [0, 1, 51, 1911] inf, bs_size, full_bit = 10**9, 1 << 12, (1 << 12) - 1 dp = [[inf]*bs_size for _ in range(4*n+1)] dp[0][0] = 0 for i in range(4*n): y, x = i & 3, i >> 2 is_dot = 1 if a[y][x] == '.' else 0 for bitset in range(bs_size): if y == 0: if dp[i+4][full_bit] > dp[i][bitset] + cost[4]: dp[i+4][full_bit] = dp[i][bitset] + cost[4] if (is_dot | bitset & 1) and\ dp[i+1][bitset >> 1] > dp[i][bitset]: dp[i+1][bitset >> 1] = dp[i][bitset] for k in range(1, min(4-y, 3)+1): if dp[i][bitset | mask[k]] > dp[i][bitset] + cost[k]: dp[i][bitset | mask[k]] = dp[i][bitset] + cost[k] print(min(dp[4*n]))",linear,"['bitmasks', 'dp']",820
"s1, s2 = [str(j) for j in input().split()] output = s1 + s2 for j in range(len(s1)): s = s1[:j + 1] for k in range(len(s2)): s += s2[k] if sorted([s, output])[0] == s: output = s print(output)",linear,"['brute force', 'greedy', 'sortings']",192
"a, b = input().split() li = [] for i in range(len(a)): li.append(a[:i + 1] + b[0]) li.sort() print(li[0])",linear,"['brute force', 'greedy', 'sortings']",105
import sys import bisect l=input().split() a=l[0] b=l[1] p=[] for i in range(len(a)): for j in range(len(b)): ok=a[:i+1]+b[:j+1] p.append(ok) print(min(p)),linear,"['brute force', 'greedy', 'sortings']",155
"s1, s2 = input().split() ans = 'z' * 21 for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): ans = min(ans, s1[:i] + s2[:j]) print(ans)",linear,"['brute force', 'greedy', 'sortings']",146
"s1, s2 = input().split() ans = s1[0] for i in range(1, len(s1)): if s1[i] < s2[0]: ans += s1[i] if i == len(s1) - 1:ans += s2[0] else: ans += s2[0] break if len(s1) == 1:print(s1[0] + s2[0]) else:print(ans)",linear,"['brute force', 'greedy', 'sortings']",206
"s1, s2 = input().split() ans = s1[0] for i in range(1, len(s1)): if s1[i] < s2[0]:ans += s1[i] else:break print(ans + s2[0])",linear,"['brute force', 'greedy', 'sortings']",124
"str1,str2=map(str,input("""").split()) lst=[] lst_ans=[] l_count=0 count=0 for i in str2: if(count<1): lst.append(i) else: break for i in str1: if(count==0): lst_ans.append(i) count+=1 elif(ord(i)<ord(lst[0])): lst_ans.append(i) else: lst_ans.append(lst[0]) break else: lst_ans.append(lst[0]) print(''.join(lst_ans))",linear,"['brute force', 'greedy', 'sortings']",314
"s = input().split(' ') s1 = s[0] s2 = s[1] res = s1[0] flag = 0 for i in range(1, len(s1)): if(s1[i]>=s2[0]): res+=s2[0] flag = 1 break else: res+=s1[i] if(flag == 0): res+=s2[0] print(res)",linear,"['brute force', 'greedy', 'sortings']",189
"first,last=input().split() username=first[0] first=first[1:] while first!="""" and first[0]<last[0]: username=username+first[0] first=first[1:] print(username+last[0])",linear,"['brute force', 'greedy', 'sortings']",165
"n=int(input());print(sum(i for i in range(1+n%2!=1,n+1,2)))",linear,"['constructive algorithms', 'math']",59
"print(sum(i for i in range(int(input()),-1,-2)))",linear,"['constructive algorithms', 'math']",48
n = int(input()) import math print(math.ceil(n/2) * (math.floor(n/2)+1)),linear,"['constructive algorithms', 'math']",72
"n = int(input()) dp = [0]*101 dp[1] = 1 dp[2] = 2 for i in range(3, 101): dp[i] = dp[i-2]+i print(dp[n])",linear,"['constructive algorithms', 'math']",104
from math import ceil N = int(input()) S = (N * (N + 1)) / 2 F = int(ceil(N /2.0)) ans = int((S + F) / 2) print(ans),linear,"['constructive algorithms', 'math']",116
import math n=int(input()) if(n%2==0): x=math.floor(n/2+1)*(math.floor(n/2)) if(n%2!=0): x=(math.ceil(n/2)*(math.ceil(n/2))) print(x),linear,"['constructive algorithms', 'math']",133
import math n=int(input()) print((math.floor(n/2)+1)*math.ceil(n/2)),linear,"['constructive algorithms', 'math']",68
n=int(input()) a=[] for i in range(n+1): a.append(((n+1)-i)*i) print(max(a)),linear,"['constructive algorithms', 'math']",76
n=int(input()) print((n+n%2)*((n+2)//2)//2),linear,"['constructive algorithms', 'math']",43
"def process(a): assert len(a) >= 2 n = len(a) min_ = float('inf') for i, [cnt, c] in enumerate(a): if i == 0 or i == n-1: min_ = min(min_, cnt) else: min_ = min(min_, (cnt+1) //2) b = [] for i, [cnt, c] in enumerate(a): if i == 0 or i == n-1: remain = cnt - min_ else: remain = cnt - min_ * 2 if remain <= 0: continue if len(b) == 0 or c != b[-1][1]: b.append([remain, c]) else: pre_cnt, pre_c = b.pop() b.append([pre_cnt+remain, c]) return b, min_ S = input() + ' ' cur = [] cnt = 0 pre = '' for x in S: if cnt == 0: cnt+= 1 pre = x elif x!=pre: cur.append([cnt, pre]) cnt = 1 pre = x else: cnt+=1 cnt = 0 while len(cur) not in [0, 1]: cur, min_ = process(cur) cnt+=min_ print(cnt)",linear,"['data structures', 'greedy', 'implementation']",682
"n=int(input()) g={} for i in range(1,n): p=int(input()) if g.get(p):g[p].append(i+1) else:g[p]=[i+1] ams='YES' for i in g: c=0 for j in g[i]: if j not in g:c+=1 if c<3:ams='NO' print(ams)",linear,"['implementation', 'trees']",187
"n= int(input()) t=[[] for _ in range(n+1)] for i in range(n-1): v = int(input()) t[v].append(i+2) flag=True for l in t: if l!=[]: cnt=0 for ele in l: if t[ele]==[]: cnt+=1 if cnt<3: flag=False break if flag: print(""YES"") else: print(""NO"")",linear,"['implementation', 'trees']",238
"n = int(input()) a = [0] * (n+1) ; b = [0] * (n+1) ; c = [0] * (n+1) for i in range(2, n+1): a[i] = int(input()) b[a[i]] += 1 for i in range(1, n+1): if b[i] == 0: c[a[i]] += 1 for i in range(1, n+1): if b[i] != 0 and c[i] < 3: print(""NO"") exit() print(""YES"")",linear,"['implementation', 'trees']",259
"from collections import defaultdict from collections import deque class graph: def __init__(self): self.g=defaultdict(list) def addedge(self,u,v): self.g[u].append(v) def router(values): gr=graph() for i in range(len(values)): gr.addedge(values[i], i+2) return gr.g def isleaf(node,gr): if len(gr[node])==0: return True return False def christmas(gr,start,visited): q=deque() q.append(start) visited[start]=True count=0 while q: count=0 value=q.popleft() for val in gr[value]: if not isleaf(val,gr): q.append(val) visited[val]=True else: visited[val]=True count=count+1 if count<3: return 'No' if count<3: return 'No' return 'Yes' n=int(input()) values=[] for i in range(n-1): value=int(input()) values.append(value) gr=router(values) visited=[False]*(n+1) print(christmas(gr, 1, visited))",linear,"['implementation', 'trees']",789
"n=int(input()) d,l,m,a=[0]*(n+1),[0]*2,[0]*(n+1),0 for _ in range(n-1): a=int(input()) l.append(a) m[a]+=1 for i in range(1,n+1): if m[i]==0: d[l[i]]+=1 for i in range(1,n+1): if m[i]>0 and d[i]<3: print(""No"") break else: print(""Yes"")",linear,"['implementation', 'trees']",234
"def if_Spruce(n,l,m): d=[0]*(n+1) for i in range(1, n + 1): if m[i] == 0: d[l[i]] += 1 for i in range(1, n + 1): if m[i] > 0 and d[i] < 3: return ""No"" return ""Yes"" n=int(input()) l,m,a=[0]*2,[0]*(n+1),0 for _ in range(n-1): a=int(input()) l.append(a) m[a]+=1 print(if_Spruce(n,l,m))",linear,"['implementation', 'trees']",282
"def if_spruce(n,l,m): d=[0]*(n+1) for i in range(1,n+1): if m[i]==0: d[l[i]]+=1 for i in range(1,n+1): if m[i]>0 and d[i]<3: return ""No"" return ""Yes"" n=int(input()) l,m,a=[0]*2,[0]*(n+1),0 for _ in range(n-1): a=int(input()) l.append(a) m[a]+=1 print(if_spruce(n,l,m))",linear,"['implementation', 'trees']",268
"def if_spruce(n,l,s): d=[0]*(n+1) for i in range(1,n+1): if i not in s: d[l[i]]+=1 for i in range(1,n+1): if i in s and d[i]<3: return ""No"" return ""Yes"" n=int(input()) l,a=[0]*2,0 for _ in range(n-1): a=int(input()) l.append(a) s=set(l) print(if_spruce(n,l,s))",linear,"['implementation', 'trees']",260
"def if_spruce(n,l,s): d=[0]*(n+1) for i in range(1,n+1): if i not in s: d[l[i]]+=1 for i in range(1,n+1): if i in s and d[i]<3: return ""No"" return ""Yes"" n=int(input()) l,a=[0]*2,0 for _ in range(n-1): a=int(input()) l.append(a) s=set(l) print(if_spruce(n,l,s))",linear,"['implementation', 'trees']",260
"class Combi(): def __init__(self, N, mod=10**9 + 7): self.power = [1 for _ in range(N+1)] self.rev = [1 for _ in range(N+1)] self.mod = mod for i in range(2, N+1): self.power[i] = (self.power[i-1]*i) % self.mod self.rev[N] = pow(self.power[N], self.mod-2, self.mod) for j in range(N, 0, -1): self.rev[j-1] = (self.rev[j]*j) % self.mod def com(self, K, R): if not (0 <= R <= K): return 0 else: return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod def perm(self, K, R): if not (0 <= R <= K): return 0 else: return (self.power[K])*(self.rev[K-R]) % self.mod def bitcnt(X): res = 0 v = X while v: res += v & 1 v >>= 1 return res c = Combi(10000) NL = list(map(int, list(input())))[::-1] N = len(NL) K = int(input()) MOD = 10**9 + 7 dp = [[0]*(1020) for i in range(1020)] dp[0][0] = 1 for pos, bit in enumerate(NL): if bit == 1: for bit in range(1010): dp[pos + 1][bit] = (dp[pos][bit - 1] + c.com(pos, bit)) % MOD continue else: for bit in range(1010): dp[pos + 1][bit] = dp[pos][bit] continue INF = 1 << 60 cnt = [INF]*(1010) cnt[1] = 0 MOD = 10**9 + 7 for i in range(2, 1010): cnt[i] = 1 + cnt[bitcnt(i)] if K == 0: print(dp[N][0]) exit() else: ans = 0 for bitcnt in range(1010): if cnt[bitcnt] == K - 1: ans += dp[N][bitcnt] if K == 1: ans -= 1 print(ans % MOD) exit()",linear,"['brute force', 'combinatorics', 'dp']",1280
"N = 1030 MOD = int(1e9+7) c = [[0] * N for i in range(N)] for i in range(N): c[i][0] = 1 for i in range(1, N): for j in range(1, N): c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD arr = list(map(int, list(input()))) cnt = int(input()) if cnt == 0: print(1) exit() dp = [0] * N for i in range(2, N): dp[i] = dp[bin(i).count('1')] + 1 res = 0 for i in range(1, N): if dp[i] != cnt - 1: continue n, k = len(arr)-1, i for pos in range(len(arr)): if arr[pos] == 1: res = (res + c[n][k]) % MOD k -= 1 n -= 1 if n == -1 and k == 0: res += 1 if cnt == 1: res -= 1 print(res)",linear,"['brute force', 'combinatorics', 'dp']",561
"import sys import math input = sys.stdin.readline from functools import cmp_to_key; def pi(): return(int(input())) def pl(): return(int(input(), 16)) def ti(): return(list(map(int,input().split()))) def ts(): s = input() return(list(s[:len(s) - 1])) def invr(): return(map(int,input().split())) mod = 1000000007; f = []; def fact(n,m): global f; f = [1 for i in range(n+1)]; f[0] = 1; for i in range(1,n+1): f[i] = (f[i-1]*i)%m; def fast_mod_exp(a,b,m): res = 1; while b > 0: if b & 1: res = (res*a)%m; a = (a*a)%m; b = b >> 1; return res; def inverseMod(n,m): return fast_mod_exp(n,m-2,m); def ncr(n,r,m): if n < 0 or r < 0 or r > n: return 0; if r == 0: return 1; return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m; def main(): C(); def D(): [n,m,k] = ti(); w = [[] for i in range(n)]; for i in range(n): w[i] = ts(); mn = [[0 for j in range(k+1)] for i in range(n+1)]; for i in range(1,n+1): for j in range(k+1): c = 0; st,en = -1,-1; for x in range(m): if w[i-1][x] == '1': if c == j and st == -1: st = x; if c < j: c += 1; if c == j: en = x; mn[i][j] = en-st+1 if st != -1 and en != -1 else 0; st,en = -1,-1; c = 0; for x in range(m-1,-1,-1): if w[i-1][x] == '1': if c == j and st == -1: st = x; if c < j: c += 1; if c == j: en = x; if st != -1 and en != -1 >= 0: mn[i][j] = min(mn[i][j], st-en+1); dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)]; for i in range(k+1): dp[0][i] = 0; for i in range(1,n+1): for j in range(k+1): for x in range(k+1): if j-x >= 0: dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]); print(dp[n][k]); def getCount(n): x = 1; count = 0; while n > 0: if n & 1 == 1: count += 1; n = n >> 1; return count; def C(): try: n = ts(); k = pi(); if k == 0: print(1); return; dp = [0 for i in range(1010)]; for i in range(1010): if i == 0 or i == 1: continue; dp[i] = dp[getCount(i)]+1; fact(1010,mod); ans = 0; s = n; count = 0; for i in range(len(s)): if s[i] == '0': continue; for j in range(max(count,1),1010): if dp[j] == k-1: ans = (ans+ncr(len(s)",linear,"['brute force', 'combinatorics', 'dp']",2000
"s0=input() k=int(input()) s1=s0[::-1] lens1=len(s1) maxnum=1005 mod=1000000007 dp=[[0]*maxnum for tmpi in range(maxnum)] f=[0]*maxnum c=[[0]*maxnum for tmpi in range(maxnum)] def cntone(num): tmps=bin(num)[2:] cnt=0 for i in range(len(tmps)): if(tmps[i]=='1'): cnt+=1 return cnt for i in range(1,maxnum): if(i==1): f[i]=0 else: f[i]=f[cntone(i)]+1 for i in range(maxnum): if(i==0): c[i][0]=1 continue for j in range(i+1): if(j==0): c[i][j]=1 else: c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod for i in range(lens1): if(i==0): dp[i][0] = 1 if(s1[i]=='1'): dp[i][1]=1 else: dp[i][1]=0 continue else: for j in range(0,i+2): if(j==0): dp[i][j]=1 continue if(s1[i]=='1'): dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod else: dp[i][j]=dp[i-1][j]%mod ans=0 for i in range(1,lens1+1): if(f[i]==k-1): ans=(ans+dp[lens1-1][i])%mod if(k==0): ans=1 elif(k==1): ans-=1 else: ans=ans print(ans)",linear,"['brute force', 'combinatorics', 'dp']",860
"s0=input() k=int(input()) s1=s0[::-1] lens1=len(s1) maxnum=1005 mod=1000000007 dp=[[0]*maxnum for tmpi in range(maxnum)] f=[0]*maxnum c=[[0]*maxnum for tmpi in range(maxnum)] def cntone(num): tmps=bin(num)[2:] cnt=0 for i in range(len(tmps)): if(tmps[i]=='1'): cnt+=1 return cnt for i in range(1,maxnum): if(i==1): f[i]=0 else: f[i]=f[cntone(i)]+1 for i in range(maxnum): if(i==0): c[i][0]=1 continue for j in range(i+1): if(j==0): c[i][j]=1 else: c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod for i in range(lens1): if(i==0): dp[i][0] = 1 if(s1[i]=='1'): dp[i][1]=1 else: dp[i][1]=0 continue else: for j in range(0,i+2): if(j==0): dp[i][j]=1 continue if(s1[i]=='1'): dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod else: dp[i][j]=dp[i-1][j]%mod ans=0 for i in range(1,lens1+1): if(f[i]==k-1): ans=(ans+dp[lens1-1][i])%mod if(k==0): ans=1 elif(k==1): ans-=1 else: ans=ans print(ans)",linear,"['brute force', 'combinatorics', 'dp']",860
"import os,sys from io import BytesIO, IOBase def bit_count(x): ans = 0 while x: x &= x-1 ans += 1 return ans def main(): n = input().strip() x = len(n) k = int(input()) if n == '1': print(int(k==0)) exit() if not k: print(1) exit() mod = 10**9+7 dp = [0]*(x+1) dp[1] = 1 for i in range(2,x+1): dp[i] = dp[bit_count(i)]+1 dp1 = [[0]*(x+1) for _ in range(x+1)] for i in range(x+1): dp1[i][0] = 1 for i in range(1,x+1): for j in range(1,i+1): dp1[i][j] = (dp1[i-1][j-1]+dp1[i-1][j])%mod ans = 0 cou = n.count('1') for i in range(1,x+1): if dp[i] != k: continue se = i for j in range(x): if n[j] == '0': continue ans = (ans+dp1[x-1-j][se]-(se==1 and k==1))%mod se -= 1 if se < 0: break if cou == i: ans = (ans+1)%mod print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWr",linear,"['brute force', 'combinatorics', 'dp']",1999
"import os, sys from io import BytesIO, IOBase def bit_count(x): ans = 0 while x: x &= x - 1 ans += 1 return ans def main(): n = input().strip() x = len(n) k = int(input()) if n == '1': print(int(k == 0)) exit() if not k: print(1) exit() mod = 10 ** 9 + 7 dp = [0] * (x + 1) dp[1] = 1 for i in range(2, x + 1): dp[i] = dp[bit_count(i)] + 1 dp1 = [[0] * (x + 1) for _ in range(x + 1)] for i in range(x + 1): dp1[i][0] = 1 for i in range(1, x + 1): for j in range(1, i + 1): dp1[i][j] = (dp1[i - 1][j - 1] + dp1[i - 1][j]) % mod ans = 0 cou = n.count('1') for i in range(1, x + 1): if dp[i] != k: continue se = i for j in range(x): if n[j] == '0': continue ans = (ans + dp1[x - 1 - j][se] - (se == 1 and k == 1)) % mod se -= 1 if se < 0: break if cou == i: ans = (ans + 1) % mod print(ans) main()",linear,"['brute force', 'combinatorics', 'dp']",793
"global fact,inv_fact def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7): global fact, inv_fact max_n = min(max_n, mod - 1) fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1) fact[0] = 1 for i in range(max_n): fact[i + 1] = fact[i] * (i + 1) % mod inv_fact[-1] = pow(fact[-1], mod - 2, mod) for i in reversed(range(max_n)): inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod make_nCr_mod() def comb(n, r): mod=10**9+7 global fact,inv_fact res = 1 while n or r: a, b = n % mod, r % mod if a < b: return 0 res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod n //= mod r //= mod return res def f(): dp=[0]*(1000+100) dp[1]=1 for i in range(2,len(dp)): o=bin(i).count(""1"") if o==1: dp[i]=2 else: dp[i]+=dp[o]+1 return dp def bit(s,k): dp=f() l=[] ans=0 ll=len(s) ans=0 ones=0 if k==0: return 1 for i in range(ll): if s[i]==""0"": continue else: for j in range(max(ones,1),1000): if dp[j]==k: ans=(ans+comb(ll-i-1,j-ones))%(10**9+7) if i==0 and k==1: ans-=1 ones+=1 if dp[ones]==k: ans+=1 return (ans)%(10**9+7) s=input().strip() k=int(input()) print(bit(s,k))",linear,"['brute force', 'combinatorics', 'dp']",1066
"def make_nCr_mod(max_n=2 * 10 ** 5, mod=10 ** 9 + 7): max_n = min(max_n, mod - 1) fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1) fact[0] = 1 for i in range(max_n): fact[i + 1] = fact[i] * (i + 1) % mod inv_fact[-1] = pow(fact[-1], mod - 2, mod) for i in reversed(range(max_n)): inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod def nCr_mod(n, r): res = 1 while n or r: a, b = n % mod, r % mod if a < b: return 0 res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod n //= mod r //= mod return res return nCr_mod def f(): dp = [0] * (1000 + 100) dp[1] = 1 for i in range(2, len(dp)): o = bin(i).count(""1"") if o == 1: dp[i] = 2 else: dp[i] += dp[o] + 1 return dp def bit(s, k): dp = f() l = [] comb=make_nCr_mod() ans = 0 ll = len(s) ans = 0 ones = 0 if k == 0: return 1 for i in range(ll): if s[i] == ""0"": continue else: for j in range(max(ones, 1), 1000): if dp[j] == k: ans = (ans + comb(ll - i - 1, j - ones)) % (10 ** 9 + 7) if i == 0 and k == 1: ans -= 1 ones += 1 if dp[ones] == k: ans += 1 return (ans) % (10 ** 9 + 7) s = input().strip() k = int(input()) print(bit(s, k))",linear,"['brute force', 'combinatorics', 'dp']",1097
"n=int(input()) a=list(map(int,input().split())) b=[] maxi=0 for i in range(n): maxi=max(maxi,a[i]+1) b.append(maxi) c=[] count=b[-1] for i in range(n-1,-1,-1): if count-1>=b[i]: count-=1 c.append(count) else: c.append(count) c=c[::-1] ans=0 for i in range(n): ans+=(c[i]-a[i]-1) print(ans)",linear,"['data structures', 'dp', 'greedy']",289
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from collections import Counter, defaultdict import bisect import math for _ in range(1): n = int(input()) arr = list(map(int, input().split())) t=[0]*n cur=0 for i in range(n-1,-1,-1): cur=max(cur-1,0,arr[i]+1) t[i]=cur ans=0 for i in range(n): cur=max(cur,t[i]) ans+=cur for i in range(n): ans-=(arr[i]+1) print(ans)",linear,"['data structures', 'dp', 'greedy']",1715
"def f(ar): mx = ar.index(max(ar)) cmark = 0 ans = 0 big = [0] * (len(ar)) for i in range(len(ar) - 1, -1, -1): cmark = max(cmark - 1, ar[i] + 1, 0) big[i] = cmark cmark = 0 t=[0]*(len(ar)) for i in range(len(ar)): cmark = max(cmark, big[i]) t[i]=cmark ans=0 for i in range(len(ar)): t[i]=t[i]-ar[i]-1 return (sum(t)) a = input() print(f([*map(int, input().strip().split())]))",linear,"['data structures', 'dp', 'greedy']",375
"n = int(input()) m = input().split() t = [] for i in range(n): m[i] = int(m[i]) if i == 0: t.append(m[i]+1) else: t.append(max(t[i-1], m[i]+1)) s = t[n-1] - m[n-1] - 1 for i in range(n-2, -1, -1): if t[i] < t[i+1]-1: t[i] = t[i+1]-1 s += t[i] - m[i] - 1 print(s)",linear,"['data structures', 'dp', 'greedy']",262
"n = int(input()) m = input().split(' ') j = 0 mark = [1] for i in range(1,len(m)) : tmp = max(mark[i-1],int(m[i])+1) mark.append(tmp) j+=mark[len(m)-1]-int(m[len(m)-1])-1 for i in range(len(m)-2,-1,-1): if mark[i]<mark[i+1]-1: mark[i] = mark[i+1]-1 j+=mark[i]-int(m[i])-1 print(j)",linear,"['data structures', 'dp', 'greedy']",280
"n=int(input()) a=input().split(' ') for i in range(len(a)): a[i]=int(a[i]) khat=n*[0] ted=0 assl=0 khat[0]=1 lol=[0,0] for i in range(1,len(khat)): khat[i]=max([khat[i-1],a[i]+1]) for i in range(len(khat)-2,-1,-1): if khat[i]<khat[i+1]-1: khat[i]=khat[i+1]-1 ted=ted+(khat[i]-(a[i]+1)) ted=ted+(khat[n-1]-(a[n-1]+1)) print(ted)",linear,"['data structures', 'dp', 'greedy']",327
"n = int(input()) Ab = input().split() Un = [] Al = [0] r = 0 for i in range(n): Ab[i] = int(Ab[i]) Al.append(max(Ab[i]+1,Al[i])) for i in range(n,-1,-1): if Al[i-1] < Al[i] - 1: Al[i-1] = Al[i] - 1 for i in range(n): Un.append(Al[i+1]-Ab[i]-1) r += Un[-1] print(r)",linear,"['data structures', 'dp', 'greedy']",264
"n,p = map(int,input().split()) a = list(map(int,input().split())) forward = [a[0]] for i in range(1,n): forward.append(forward[-1] + a[i]) sm = sum(a) mx = -float('inf') for i in range(n-1): mx = max(mx,(forward[i]%p) + ((sm -forward[i] )%p)) print(mx)",linear,['brute force'],252
"n,k = map(int, input().strip().split(' ')) lst = list(map(int, input().strip().split(' '))) s=sum(lst) s2=0 m=0 for i in range(n-1): s2+=lst[i] s-=lst[i] if (s2%k)+(s%k)>m: m=(s2%k)+(s%k) print(m)",linear,['brute force'],196
"n, p = map(int, input().split()) a = list(map(int, input().split())) t = 0 k = 0 for i in range(n): k += a[i] s = 0 for i in range(0, n-1): s += a[i] t = max(t, s%p + (k - s)%p) print(t)",linear,['brute force'],186
"n, p = map(int, input().split()) arr = [int(b) for b in input().split()] res = [] prefsums = [arr[0]] for i in range(1, n): prefsums.append(prefsums[i - 1] + arr[i]) allsum = sum(arr) if len(arr) == 2: print(arr[0] % p + arr[1] % p) exit() for i in range(1, n - 1): res.append((prefsums[i] % p) + ((allsum - prefsums[i]) % p)) print(max(res))",linear,['brute force'],342
"n, p = map(int, input().split()) a = list(map(int, input().split())) a = [c % p for c in a] s = sum(a) sp = s % p if sp == s or sp + 1 == p: print(sp) else: print(sp + p)",linear,['brute force'],170
"from collections import deque as de import math import re from collections import Counter as cnt from functools import reduce from typing import MutableMapping from itertools import groupby as gb from fractions import Fraction as fr from bisect import bisect_left as bl, bisect_right as br def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def decimalToBinary(n): return bin(n).replace(""0b"", """") def binarytodecimal(n): return int(n,2) def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def getProduct(n): product = 1 while (n != 0): product = product * (n % 10) n = n // 10 return product def dupconscount(nums): element = [] freque = [] if not nums: return element running_count = 1 for i in range(len(nums)-1): if nums[i] == nums[i+1]: running_count += 1 else: freque.append(running_count) element.append(nums[i]) running_count = 1 freque.append(running_count) element.append(nums[i+1]) return element,freque def isPowerOfTwo(n): return (math.ceil(Log",linear,['brute force'],1999
"n, p=map(int, input().split()) arr=list(map(int, input().split())) su=0 for i in range(n): su+=arr[i] maxi, f=0, 0 for i in range(n-1): f+=arr[i] maxi=max(maxi, f%p+(su-f)%p) print(maxi)",linear,['brute force'],186
"n, p = map(int, input().split()) list1 = list(map(int, input().split())) mx = 0 curr = 0 nxt = sum(list1) for i in range(n - 1): curr += list1[i] nxt -= list1[i] mx = max(mx, curr % p + nxt % p) print(mx)",linear,['brute force'],204
"arr = [] d = {} for _ in range(int(input())): s = input() a,b,c = tuple(map(int, s.replace(""("","""").replace("")"","""").replace(""/"",""."").replace(""+"",""."").split("".""))) x = (a+b)/c arr.append(x) if x not in d: d[x] = 0 d[x] += 1 for i in arr: print(d[i], end = "" "")",linear,"['expression parsing', 'math']",258
"from math import gcd import sys input=sys.stdin.readline from collections import defaultdict as dd m=int(input()) d=dd(int) l=[] for i in range(m): s=input().split()[0] a=0 b=0 c=0 n=len(s) ind=0 for i in range(1,n): if(s[i]=='+'): ind=i+1 break a=a*10+int(s[i]) for i in range(ind,n): if(s[i]==')'): ind1=i+2 break b=b*10+int(s[i]) for i in range(ind1,n): c=c*10+int(s[i]) a=a+b g=gcd(a,c) a=a//g c=c//g d[(a,c)]+=1 l.append((a,c)) for i in l: print(d[i],end="" "")",linear,"['expression parsing', 'math']",464
"from collections import defaultdict from sys import stdin input = stdin.readline dct = defaultdict(int) n = int(input()) lst = [0] * n for i in range(n): t = input().strip() a, b, c = map(int, (t[1:t.index('+')], t[t.index('+') + 1:t.index(')')], t[t.index('/') + 1:])) x = (a + b) / c lst[i] = x dct[x] += 1 for i in lst: print(dct[i], end=' ')",linear,"['expression parsing', 'math']",345
"def val(s): ans = ((int(s.split('+')[0][1:]) + int(s.split('+')[1].split(')')[0])) / int(s.split('/')[1])) return ans n = int(input()) s = [] f = {} for i in range(n): ss = input() s.append(val(ss)) if(s[i] not in f): f[s[i]] = 1 else: f[s[i]] += 1 for i in range(len(s)): print(f[s[i]], end= "" "") print()",linear,"['expression parsing', 'math']",305
"f=input D,E=dict(),[eval(f())for i in range(int(f()))] for e in E:D[e]=D.get(e,0)+1 for e in E:print(D[e])",linear,"['expression parsing', 'math']",106
"f=input D,E={},[eval(f())for _ in range(int(f()))] for e in E:D[e]=D.get(e,0)+1 for e in E:print(D[e])",linear,"['expression parsing', 'math']",102
"from math import gcd n = int(input()) d = dict() qs = [] for i in range(n): s = input() a = int(s[1:s.index('+')]) b = int(s[s.index('+') + 1: s.index(')')]) c = int(s[s.index(')') + 2:]) a = a + b gc = gcd(a, c) res = (a // gc, c // gc) qs.append(res) if res in d: d[res] += 1 else: d[res] = 1 for q in qs: print(d[q], end=' ')",linear,"['expression parsing', 'math']",328
"from math import gcd from collections import defaultdict as dd m=int(input()) d=dd(int) l=[] ans=[] for i in range(m): s=input().split()[0] a=0 b=0 c=0 n=len(s) ind=0 for i in range(1,n): if(s[i]=='+'): ind=i+1 break a=a*10+int(s[i]) for i in range(ind,n): if(s[i]==')'): ind1=i+2 break b=b*10+int(s[i]) for i in range(ind1,n): c=c*10+int(s[i]) a=a+b g=gcd(a,c) a=a//g c=c//g d[(a,c)]+=1 l.append((a,c)) for i in l: ans.append(d[i]) print(*ans)",linear,"['expression parsing', 'math']",444
"n=int(input()) dict1={} dict2={} for i in range(n): s=input() s=s.split('/') c=int(s[1]) s=s[0].strip('(').strip(')').split('+') a=int(s[0]) b=int(s[1]) ans=(a+b)/c try: dict2[ans] += 1 except: dict2[ans] = 1 dict1[i] = ans for i in range(n): print(dict2[dict1[i]],end=' ')",linear,"['expression parsing', 'math']",273
"import sys from functools import lru_cache, cmp_to_key from heapq import merge, heapify, heappop, heappush from math import * from collections import defaultdict as dd, deque, Counter as C from itertools import combinations as comb, permutations as perm from bisect import bisect_left as bl, bisect_right as br, bisect from time import perf_counter from fractions import Fraction import copy import time starttime = time.time() mod = int(pow(10, 9) + 7) mod2 = 998244353 def data(): return sys.stdin.readline().strip() def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end) def L(): return list(sp()) def sl(): return list(ssp()) def sp(): return map(int, data().split()) def ssp(): return map(str, data().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)] try: sys.stdin = open(""input.txt"", ""r"") except: pass n=L()[0] if n<6: print(-1) else: print(1,2) print(1,3) print(1,4) for i in range(5,n+1): print(2,i) for i in range(1,n): print(i,i+1) endtime = time.time()",linear,"['constructive algorithms', 'trees']",1050
"import os import sys from io import BytesIO, IOBase from collections import Counter BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def gcd(a, b): if a == 0: return b return gcd(b % a, a) def lcm(a, b): return (a * b) / gcd(a, b) def main(): n=int(input()) if n<6: print(-1) else: for i in range(2, n-2+1): print(1, i) print(2, n-1) print(2, n) for i in range(1,n): print(i, i+1) return if __name__ == ""__main__"": main()",linear,"['constructive algorithms', 'trees']",1665
"import sys input = sys.stdin.readline n = int(input()) if n < 6: print(-1) else: l = [] o = [] x = (3+n)//2 for i in range(3,x+1): l.append((1,i)) for i in range(x+1,n+1): o.append((2,i)) sys.stdout.write(""1""+"" ""+""2""+""\n"") for x in l: sys.stdout.write(str(x[0]) + "" "" + str(x[1]) + ""\n"") for x in o: sys.stdout.write(str(x[0]) + "" "" + str(x[1]) + ""\n"") sys.stdout.write(""1""+"" ""+""2""+""\n"") p = 2 for i in range(3,n+1): sys.stdout.write(str(p) + "" "" + str(i) + ""\n"") p = i",linear,"['constructive algorithms', 'trees']",469
"n = int(input()) if n<6: print(-1) else: print(""1 2\n1 3\n1 4"") for i in range(5,n+1): print('2 '+str(i)) for i in range(2, n+1): print('1 '+str(i))",linear,"['constructive algorithms', 'trees']",148
"n=int(input()) if(n<6): print(-1) else: print(1,2) print(1,3) print(1,4) for i in range(4,n): print(2,i+1) for i in range(n-1): print(1,i+1+1)",linear,"['constructive algorithms', 'trees']",142
"n = int(input()) if n <= 5: print(-1) for i in range(2, n+1): print(1, i) exit() print(1, 2) print(2, 3) print(2, 4) for i in range(5, n+1): print(3, i) for i in range(2, n+1): print(1, i)",linear,"['constructive algorithms', 'trees']",188
"import sys import os.path from collections import * import math import bisect if (os.path.exists('input.txt')): sys.stdin = open(""input.txt"", ""r"") sys.stdout = open(""output.txt"", ""w"") else: input = sys.stdin.readline n = int(input()) if(n == 2 or n == 3 or n == 4 or n == 5): print(-1) else: print(1,2) print(2,3) print(2,4) for i in range(5,n + 1): print(4,i) for i in range(2,n + 1): print(1,i)",linear,"['constructive algorithms', 'trees']",396
"import sys input=sys.stdin.readline from collections import defaultdict as dc from collections import Counter from bisect import bisect_right, bisect_left import math from operator import itemgetter from heapq import heapify, heappop, heappush from queue import PriorityQueue as pq n=int(input()) if n<=5: print(-1) else: for i in range(2,5): print(1,i) for i in range(5,n+1): print(2,i) for i in range(2,n+1): print(1,i)",linear,"['constructive algorithms', 'trees']",421
"n=int(input()) if n>=6: for i in range(2, n-1): print(1, i) for i in range(n-1, n+1): print(2, i) else: print(-1) for i in range(2, n+1): print(1, i)",linear,"['constructive algorithms', 'trees']",149
"n, k = map(int, input().split()) a = list(map(int, input().split())) t = list(map(int, input().split())) p = [0] * (n + 1) now = 0 for i in range(0, n): if (t[i] == 1): now += a[i] p[i + 1] = p[i] if (t[i] == 0): p[i + 1] += a[i] s = 0 for i in range(n - k + 1): s = max(s, p[i + k] - p[i]) print(now + s)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",305
"n,k = list(map(int, input().split())) a = list(map(int, input().split())) t = list(map(int, input().split())) x = 0 summ = 0 maxx = 0 for i in range(n): summ += a[i]*t[i] for i in range(k): if not t[i]: x+=a[i] maxx = max(maxx,x) for i in range(n-k): x+=a[i+k]*(1-t[i+k]) x-=a[i]*(1-t[i]) if x>maxx: maxx=x print(summ+maxx)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",323
"import sys input=sys.stdin.readline n,k=map(int,input().split()) theorems=list(map(int,input().split())) sleep=list(map(int,input().split())) tsum=[] ts=0 sleepsum=[] slsum=0 for i in range(n): ts+=theorems[i] tsum.append(ts) if(sleep[i]==1): slsum+=theorems[i] sleepsum.append(slsum) maxdiff=0 maxdiff=tsum[k-1]-sleepsum[k-1] for i in range(1,n-k+1): diff=(tsum[i+k-1]-tsum[i-1])-(sleepsum[i+k-1]-sleepsum[i-1]) maxdiff=max(maxdiff,diff) print(slsum+maxdiff)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",459
"n,k=map(int,input().split()) a=list(map(int,input().split())) t=list(map(int,input().split())) ans=0 m=0 for i in range(n): if t[i]: ans+=a[i] a[i]=0 cf=[0]*(n+1) for i in range(1,n+1): cf[i]=cf[i-1]+a[i-1] for i in range(n-k+1): m=max(m,cf[i+k]-cf[i]) print(ans+m)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",265
"def ints(): return list(map(int,input().split())) n,k=ints() a,t=ints(),ints() ans=sum(a[ii] for ii in range(n) if t[ii]) bb=[a[ii] if t[ii]==0 else 0 for ii in range(n)] ll=0 rr=k tmp=sws=sum(bb[:k]) while rr<n: sws-=bb[ll] sws+=bb[rr] ll+=1 rr+=1 tmp=max(tmp,sws) ans+=tmp print(ans)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",285
"fast=lambda:stdin.readline().strip() zzz=lambda:[int(i) for i in fast().split()] z,zz=input,lambda:list(map(int,z().split())) szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz()) from re import * from sys import * from math import * from heapq import * from queue import * from bisect import * from string import * from itertools import * from collections import * from math import factorial as f from bisect import bisect as bs from bisect import bisect_left as bsl from collections import Counter as cc from itertools import accumulate as ac def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2)) def prime(x): p=ceil(x**.5)+1 for i in range(2,p): if (x%i==0 and x!=2) or x==0:return 0 return 1 def dfs(u,visit,graph): visit[u]=1 for i in graph[u]: if not visit[i]: dfs(i,visit,graph) def output(answer): stdout.write(str(answer)) n,k=zzz() arr1=zzz() arr2=zzz() ans=0 new_arr=[0]*n for i in range(n): if arr2[i]==0: new_arr[i]=arr1[i] else: ans+=arr1[i] total=sum(new_arr[:k]) mx=total j=0 for i in range(k,n): total-=new_arr[j] total+=new_arr[i] mx=max(mx,total) j+=1 print(mx+ans)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",1108
"n,k=list(map(int,input().split())) arr1=list(map(int,input().split())) arr2=list(map(int,input().split())) ans=0 new_arr=[0]*n for i in range(n): if arr2[i]==0: new_arr[i]=arr1[i] else: ans+=arr1[i] total=sum(new_arr[:k]) mx=total j=0 for i in range(k,n): total-=new_arr[j] total+=new_arr[i] mx=max(mx,total) j+=1 print(mx+ans)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",327
"from sys import stdin, stdout from itertools import accumulate nmbr = lambda: int(stdin.readline()) lst = lambda: list(map(int, stdin.readline().split())) for _ in range(1): n,k=lst() a=lst() b=lst() ps=list(accumulate(a)) dp=[[0 for _ in range(2)] for _ in range(1+n)] for i in range(1,n+1): dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1] dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0]) print(max(max(v) for v in dp))",linear,"['data structures', 'dp', 'implementation', 'two pointers']",453
"from sys import stdin, stdout from itertools import accumulate nmbr = lambda: int(stdin.readline()) lst = lambda: list(map(int, stdin.readline().split())) for _ in range(1): n,k=lst() a=lst() b=lst() ps=list(accumulate(a)) dp=[[0 for _ in range(2)] for _ in range(1+n)] for i in range(1,n+1): dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1] dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0]) print(max(dp[n]))",linear,"['data structures', 'dp', 'implementation', 'two pointers']",440
"n = int(input()) t = list(map(int,input().split())) p = sum(t) import math a = math.ceil(p/2) u=0 for j in range(n): u+=t[j] if u>=a: print(j+1) break",linear,['implementation'],150
"def get_answer(arr): current_sum = 0 total = sum(arr) for index, val in enumerate(arr): current_sum += val if current_sum >= total / 2: return index + 1 nonsense = input() input_values = input() values = [int(v) for v in input_values.split()] print(get_answer(values))",linear,['implementation'],268
"n=int(input()) a=list(map(int,input().split())) s=sum(a) new=0 i=0 while 2*(new+a[i])<s: new+=a[i] i+=1 print(i+1)",linear,['implementation'],114
"n = int(input()) number_sequence = [int(x) for x in input().split("" "")] number_total = sum(number_sequence) current_total = 0 current_position = 0 for number in number_sequence: current_total = current_total + number current_position = current_position + 1 if(current_total >= number_total/2): print(current_position) break",linear,['implementation'],323
"import math input() all_days_problems = list(map(int, input().split())) sum_count = sum(all_days_problems) half_problems = math.ceil(sum_count/2) current_sum = 0 answer = 0 for num in all_days_problems: answer += 1 current_sum +=num if current_sum >=half_problems: break print(answer)",linear,['implementation'],284
"import bisect def solve(): n = int(input()) a = [int(x) for x in input().split(' ')] p = [0] for x in a: p.append(p[-1] + x) return bisect.bisect_left(p, p[-1] / 2) print(solve())",linear,['implementation'],179
"n = int(input()) A = [int(a) for a in input().split()] prefix = [0] * n prefix[0] = A[0] for i in range(1, n): prefix[i] = prefix[i - 1] + A[i] target = (sum(A) + 1) // 2 for i in range(n): if prefix[i] < target: continue else: print(i + 1) break",linear,['implementation'],246
"import sys,os,io from sys import stdin from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop from bisect import bisect_left , bisect_right import math alphabets = list('abcdefghijklmnopqrstuvwxyz') def isPrime(x): for i in range(2,x): if i*i>x: break if (x%i==0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def SieveOfEratosthenes(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def countdig(n): c = 0 while (n > 0): n //= 10 c += 1 return c def si(): return input() def prefix_sum(arr): r = [0] * (len(arr)+1) for i, el in enumerate(arr): r[i+1] = r[i] + el return r def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') def fastPrintNextLines(a): print('\n'.join(map(str,a))) if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") else: input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline t = 1 for _ in range(t): n = ii() a = li() s = sum(a) cur = 0 for i in range(n): cur+=a[i] if cur>=s/2: print(i+1) break",linear,['implementation'],1850
"from sys import stdin rints = lambda: [int(x) for x in stdin.readline().split()] n, A, B, C, T = rints() a, ans = rints(), 0 for i in range(n): su, cur = A, A for j in range(a[i], T): cur -= B su = max(su, (j - a[i] + 1) * C + cur) ans += su print(ans)",linear,['math'],252
"n, a, b, c, t = map(int, input().split()) l = list(map(int, input().split())) f = [0] * 1001 for i in l: f[i] -= -1 tmp = 0 tmp2 = 0 for i in range(1, t): tmp += (t - i) * f[i] tmp = n * a + tmp * c - tmp * b print(max(n * a, tmp))",linear,['math'],231
"n, a, b, c, T = map(int, input().split()) ts = list(map(int, input().split())) ts.sort() ans = 0 for t in ts: temp = -10**18 for u in range(t, T+1): temp = max(temp, c*(u-t)+a-b*(u-t)) ans += temp print(ans)",linear,['math'],207
"n,a,b,c,t=map(int,input().split()) l=list(map(int,input().split())) if c>b: r=0 for i in l: k=t-i k*=(c-b) r+=k print(a*n+r) else: print(a*n)",linear,['math'],141
"n,a,b,c,T=map(int,input().split()) arr=list(map(int,input().split())) Tcnt=arr.count(T);l=n-Tcnt;ans=0;a1=0 for i in range(1,T): for j in range(n): if arr[j]<=i:a1+=1 ans+=a1*c;a1=0 b1=0 for i in range(n): b1=a-((T-arr[i])*b) if b1<=0:ans+=b1; else:ans+=b1 ans1=n*a print(max(ans,ans1))",linear,['math'],286
"import sys,os,io from sys import stdin from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop, heapify from bisect import bisect_left , bisect_right import math alphabets = list('abcdefghijklmnopqrstuvwxyz') from types import GeneratorType def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den,p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) c = dict(Counter(l)) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def sieveForSmallestPrimeFactor(): MAXN = 100001 spf = [0 for i in range(MAXN)] spf[1] = 1 for i in range(2, MAXN): spf[i] = i for i in range(4, MAXN, 2): spf[i] = 2 for i in range(3, math.ceil(math.sqrt(MAXN))): if (spf[i] == i): for j in range(i * i, MAXN, i): if (spf[j] == j): spf[j] = i return spf def getPrimeFactorizationLOGN(x): spf = sieveForSmallestPrimeFactor() ret = list() while (x != 1): ret.append(spf[x]) x = x // spf[x] return ret def SieveOfEratosthenes(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def si(): return input() def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt""",linear,['math'],1999
"n,A,B,C,T=map(int,input().split()) t=list(map(int,input().split())) if(B>C): print(n*A) else: c=0 t.sort() for i in t: c+=(T-i)*(C-B)+A print(c)",linear,['math'],144
"n, s = map(int, input().split()) times = [] result = 0 need = True for i in range (n): h, m = map(int, input().split()) times.append(60*h + m) if n == 1: if 0 + s + 1 <= times[0]: need = False for i in range(n-1): if 0 + s + 1 <= times[0]: need = False break if times[i+1] - times[i] >= 2 + 2*s: result = times[i] + 1 + s break if result == 0 and need: result = times[n-1] + 1 + s hour = result // 60 minute = result % 60 print(hour, minute)",linear,['implementation'],441
"if __name__ == '__main__': n, s = map(int, input().split()) a = [] for _ in range(n): h, m = map(int, input().split()) a.append(h * 60 + m) if a[0] != 0 and a[0] > s: print(0, 0) else: a.append(a[n - 1] + 2 * s + 3) for i in range(1, n + 1): if a[i] - (a[i - 1] + 2 + s) >= s: print((a[i - 1] + s + 1)//60, (a[i - 1] + s + 1)%60) break",linear,['implementation'],335
"n, m = map(int,input().split()) b = [] d = [] for x in range(n): if x == 0: a,c = map(int,input().split()) if (a * 60) + c > m:b.append(""0 0"") d.append((a * 60) + c) else: a ,c = map(int,input().split()) if ((a * 60) + c) - d[-1] > (m * 2) + 1: f = d[-1] + m + 1 b.append(str(f // 60) + "" "" + str((f % 60))) d.append((a * 60) + c) if len(b) == 0: f = d[-1] + m + 1 b.append(str(f // 60) + "" "" + str((f % 60))) print(b[0])",linear,['implementation'],421
"n,k = map(int,input().split()) r = 0 for _ in range(n): h,m = map(int,input().split()) t = 60*h+m if(t>r+k): break r = t+k+1 print(r//60,r%60)",linear,['implementation'],142
"n,s=map(int,input().split()) h=list() m=list() l=list() l.append(0) for _ in range(n): x,y=map(int,input().split()) h.append(x) m.append(y) l.append((x*60)+y) if(l[1]!=0 and (l[1]-l[0])>=s+1): print(0,0) else: k=2*s+2 r=0 for i in range(n): if(l[i+1]-l[i]>=k): r=l[i]+s+1 break else: continue if(r==0): r=l[n]+s+1 print(r//60,r%60)",linear,['implementation'],331
"n,s = map(int,input().split()) t=[[0,0]] for j in range(n): a,b = map(int,input().split()) total = a*60+b last = t[-1][0]*60+t[-1][1]+1 t.append([a,b]) if j==0: if total>= s+1: print(0,0) break if total-last > 2*s: u = last+s print(u//60, u%60) break if j==n-1: x = t[-1][0]*60+t[-1][1] print((x+s+1)//60 ,(x+s+1)%60 ) break",linear,['implementation'],324
"from __future__ import division from sys import stdin, stdout from collections import * rstr = lambda: stdin.readline().strip() rstrs = lambda: [str(x) for x in stdin.readline().split()] rstr_2d = lambda n: [rstr() for _ in range(n)] rint = lambda: int(stdin.readline()) rints = lambda: [int(x) for x in stdin.readline().split()] rint_2d = lambda n: [rint() for _ in range(n)] rints_2d = lambda n: [rints() for _ in range(n)] pr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\n') ceil1, out = lambda a, b: (a + b - 1) // b, [] n, s = rints() a, ans = rints_2d(n), -1 for i in range(26): for j in range(60): tem = i * 60 + j ans = (i, j) for h, m in a: tem2 = h * 60 + m if tem <= tem2: if tem2 - (tem + 1) < s: ans = -1 break else: if tem - (tem2 + 1) < s: ans = -1 break if ans != -1: print('%d %d' % (ans[0], ans[1])) exit()",linear,['implementation'],841
"from itertools import * n, s = map(int, input().split()) times = [] for i in range(n): h, m = map(int, input().split()) times.append((h * 60 + m)) times.sort() for t in count(): if all(abs(u - t) > s for u in times): print(*divmod(t, 60)) break",linear,['implementation'],244
"I=lambda:map(int,input().split()) n,s=I() l=[0] for i in range(n): q,w=I() q=q*60+w l+=[q] if l[1]-l[0]>s:exit(print(0, 0)) for i in range(n): if l[i+1]-l[i]>2*s+1: l[i]+=s+1 exit(print(l[i]//60,l[i]%60)) l[-1]+=s+1 print(l[-1]//60,l[-1]%60)",linear,['implementation'],241
"import math import random import heapq, bisect import sys from collections import deque, defaultdict from fractions import Fraction import sys from collections import defaultdict mod = 10 ** 9 + 7 mod1 = 998244353 import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class TreeNode: def __init__(self, k, v): self.key = k self.value = v self.left = None self.right = None self.parent = None self.height = 1 self.num_left = 1 self.num_total = 1 class AvlTree: def __init__(self): self._tree = None def add(self, k, v): if not self._tree: self._tree = TreeNode(k, v) return node = self._add(k, v) if node: self._rebalance(node) def _add(self, k, v): node =",linear,"['geometry', 'math']",1998
"import sys import io, os input = sys.stdin.buffer.readline from collections import defaultdict n, a, b = map(int, input().split()) XV = [] for i in range(n): x, vx, vy = map(int, input().split()) XV.append((x, vx, vy)) if a != 0: ans = 0 d = defaultdict(lambda:0) dvx = defaultdict(lambda:0) for x, vx, vy in XV: k = -a*vx+vy ans += max(0, d[k]-dvx[(k, vx)]) d[k] += 1 dvx[(k, vx)] += 1 print(ans*2) else: ans = 0 d = defaultdict(lambda:defaultdict(lambda:0)) ds = defaultdict(lambda:0) for x, vx, vy in XV: ans += max(0, ds[vy]-d[vy][vx]) d[vy][vx] += 1 ds[vy] += 1 print(ans*2)",linear,"['geometry', 'math']",579
"import sys import io, os input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline from collections import defaultdict n, a, b = map(int, input().split()) XV = [] for i in range(n): x, vx, vy = map(int, input().split()) XV.append((x, vx, vy)) if a != 0: ans = 0 d = defaultdict(lambda:0) dvx = defaultdict(lambda:0) dvy = defaultdict(lambda:0) dvxy = defaultdict(lambda:0) for x, vx, vy in XV: k = -a*vx+vy ans += max(0, d[k]-(dvx[(k, vx)]+dvy[(k, vy)]-dvxy[(k, vx, vy)])) d[k] += 1 dvx[(k, vx)] += 1 dvy[(k, vy)] += 1 dvxy[(k, vx, vy)] += 1 print(ans*2) else: ans = 0 d = defaultdict(lambda:defaultdict(lambda:0)) ds = defaultdict(lambda:0) for x, vx, vy in XV: ans += max(0, ds[vy]-d[vy][vx]) d[vy][vx] += 1 ds[vy] += 1 print(ans*2)",linear,"['geometry', 'math']",736
"n, A, C = list(map(int, input().split())) def Ro(x, y): return A * x - y + C huh = [] for i in range(n): z, x, y = list(map(int, input().split())) huh.append((Ro(x + z, z * A + y), x)) huh = sorted(huh) anss = 0 c1 = 0 c2 = 0 prev = (-9999999999999, -999999999999999) g = [] huh.append((-9999999999999, -999999999999999)) for huhh in huh: if huhh[0] != prev[0]: g.append(c1) for j in g: anss += (c2 - j) * j g = [] c1 = 1 c2 = 1 prev = (huhh[0], huhh[1]) continue c2 += 1 if huhh[1] != prev[1]: g.append(c1) c1 = 0 prev = (huhh[0], huhh[1]) c1 += 1 print(anss)",linear,"['geometry', 'math']",560
"import atexit import io import sys _INPUT_LINES = sys.stdin.read().splitlines() input = iter(_INPUT_LINES).__next__ _OUTPUT_BUFFER = io.StringIO() sys.stdout = _OUTPUT_BUFFER @atexit.register def write(): sys.__stdout__.write(_OUTPUT_BUFFER.getvalue()) def main(): n, a, b = [int(x) for x in input().split()] dc = {} for i in range(n): x, vx, vy = [int(x) for x in input().split()] nx = x + vx ny = a*x+b + vy dd = a*nx - ny + b if dd not in dc: dc[dd] = {} if (vx,vy) not in dc[dd]: dc[dd][(vx,vy)] = 0 dc[dd][(vx,vy)] += 1 tot = 0 for v,k in dc.items(): tt = 0 pp =0 for _,cc in k.items(): tt -= cc * (cc+1) // 2 pp += cc tt += pp * (pp+1) // 2 tot += tt*2 print(tot) if __name__ == '__main__': main()",linear,"['geometry', 'math']",703
"n, a, b = map(int, input().split()) ghosts = [(vx, vy) for x, vx, vy in (map(int, input().split()) for i in range(n))] speeds = {} for vx, vy in ghosts: vl = a * vx - vy k = vx + a * vy ss = speeds.setdefault(vl, {}) ss[k] = ss.get(k, 0) + 1 result = 0 for vl, ss in speeds.items(): group_size = sum(ss.values()) for sss in ss.values(): result += sss * (group_size - sss) print(result)",linear,"['geometry', 'math']",385
"import atexit import io import sys _INPUT_LINES = sys.stdin.read().splitlines() input = iter(_INPUT_LINES).__next__ _OUTPUT_BUFFER = io.StringIO() sys.stdout = _OUTPUT_BUFFER @atexit.register def write(): sys.__stdout__.write(_OUTPUT_BUFFER.getvalue()) def main(): n, a, b = [int(x) for x in input().split()] dc = {} for i in range(n): x, vx, vy = [int(x) for x in input().split()] nx = x + vx ny = a * x + b + vy dd = a * nx - ny + b if dd not in dc: dc[dd] = {} if (vx, vy) not in dc[dd]: dc[dd][(vx, vy)] = 0 dc[dd][(vx, vy)] += 1 tot = 0 for v, k in dc.items(): tt = 0 pp = 0 for _, cc in k.items(): tt -= cc * (cc + 1) // 2 pp += cc tt += pp * (pp + 1) // 2 tot += tt * 2 print(tot) if __name__ == '__main__': main()",linear,"['geometry', 'math']",721
"import atexit import io import sys _INPUT_LINES = sys.stdin.read().splitlines() input = iter(_INPUT_LINES).__next__ def main(): n, a, b = [int(x) for x in input().split()] dc = {} for i in range(n): x, vx, vy = [int(x) for x in input().split()] nx = x + vx ny = a * x + b + vy dd = a * nx - ny + b if dd not in dc: dc[dd] = {} if (vx, vy) not in dc[dd]: dc[dd][(vx, vy)] = 0 dc[dd][(vx, vy)] += 1 tot = 0 for v, k in dc.items(): tt = 0 pp = 0 for _, cc in k.items(): tt -= cc * (cc + 1) // 2 pp += cc tt += pp * (pp + 1) // 2 tot += tt * 2 print(tot) if __name__ == '__main__': main()",linear,"['geometry', 'math']",584
"import sys if locals()['__file__'][-2:] == 'py': sys.stdin = open('in.txt', 'r') from sys import stdin rl = lambda l: tuple(map(int, l.split())) n, a, b = rl(input()) l = list(map(rl, stdin.readlines())) c, d = {}, {} r = 0 for _, x, y in l: i, j = a * x - y, (x, y) r += c.get(i, 0) - d.get(j, 0) c[i] = c.get(i, 0) + 1 d[j] = d.get(j, 0) + 1 print(2 * r)",linear,"['geometry', 'math']",356
"num=int(input()) b=input() if b=='0' or b=='1': print(b) else: s=len(list(filter(lambda x:x=='0',b))) print('1'+'0'*s)",linear,['implementation'],118
"n = int(input()) a = input() zero = 0 for i in range(len(a)): if (a[i] == ""0""): zero += 1 if (""1"" in a): print(""1"", end="""") print(""0""*zero) else: print(""0""*zero)",linear,['implementation'],161
n = int(input()) s = input() x = s.count('0') if s == '0': print('0') else: print('1' + '0'*x),linear,['implementation'],94
n = int(input()) s = input() if n == 1: print(s) else: zeros = s.count('0') print('1' + zeros * '0'),linear,['implementation'],100
"n = int(input()) m = input() s = list(m) if n==1: ans = s[0] else: count = 0 for i in range(0,n): if s[i]=='0': count = count + 1 ans = '1' for i in range(0,count): ans = ans + '0' print(ans)",linear,['implementation'],191
"n=int(input()) s=input() if ""0"" in s: if ""1"" in s: print(""1""+""0""*s.count(""0"")) else: print(""0"") else: print(""1"")",linear,['implementation'],112
"n, = map(int,input().split()) s = input() if s=='0': print(0) else: print(""1""+""0""*s.count('0'))",linear,['implementation'],95
_ = int(input()) binary_number = input() if binary_number == '0': print('0') else: count_0 = sum(1 for b in binary_number if b == '0') count_1 = sum(1 for b in binary_number if b == '1') print('1' + '0' * count_0),linear,['implementation'],213
"n = input() s = input() n = int(n) print('1'*min(s.count('1'), 1)+'0'*s.count('0'))",linear,['implementation'],83
"x=int(input()) s=input() def substring(x,s): count=0 ans=0 for i in range(x): if s[i]==""x"": count+=1 else: if count>=3: ans+=count-2 count=0 if count>=3: ans+=count-2 return ans print(substring(x,s))",linear,"['greedy', 'strings']",199
n = int(input()) s = input() count = 0 temp_count = 0 for c in s: if c == 'x': temp_count += 1 else: temp_count = 0 if temp_count == 3: count += 1 temp_count -= 1 print(count),linear,"['greedy', 'strings']",175
size = int(input()) s = input() ct = 0 F = 0 for i in range(size-2): if s[i]==s[i+1] and s[i+1]==s[i+2] and s[i] == 'x': ct += 1 F = 1 if F == 0: print(0) else: print(ct),linear,"['greedy', 'strings']",170
a = int(input()) b = input() s = 0 for i in range(a-2): if b[i:i+3] == 'xxx': s = s + 1 print(s),linear,"['greedy', 'strings']",96
"import os import sys from math import * from collections import * from bisect import * from io import BytesIO, IOBase def vsInput(): sys.stdin = open(""input.txt"", ""r"") sys.stdout = open(""output.txt"", ""w"") BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") ALPHA = ""abcdefghijklmnopqrstuvwxyz/"" M = 1000000007 EPS = 1e-6 def Ceil(a, b): return a // b + int(a % b > 0) def value(): return tuple(map(int, input().split())) def array(): return [int(i) for i in input().split()] def Int(): return int(input()) def Str(): return input() def arrayS(): return [i for i in input().split()] n = int(input()) s = input() ans = 0 cnt = 0 for x in s: if x == ""x"": cnt += 1 if cnt >= 3: ans += 1 else: cnt = 0 print(ans)",linear,"['greedy', 'strings']",2000
"from itertools import groupby n=int(input()) s=input() x=[len(list(group)) for key,group in groupby(s) if key==""x""] ans=sum(max(0,l-3+1) for l in x) print(ans)",linear,"['greedy', 'strings']",159
"from sys import stdin,stdout input=stdin.readline t=1 for _ in range(t): n=int(input()) x=input() c=0 ans=0 for i in x: if i=='x': c+=1 else: ans+=max(0,c-2) c = 0 ans+=max(0,c-2) print(ans)",linear,"['greedy', 'strings']",190
n = int(input()) string = input() i = 0 j = 0 total = 0 while j < len(string): bool = False count = 0 while j < len(string) and string[i] == 'x' and string[j] == 'x': count += 1 bool = True j += 1 if count >= 3: total += (count-3)+1 if bool: i = j else: i += 1 j += 1 print(total),linear,"['greedy', 'strings']",280
"import re input() print(sum(len(f)-2 for f in re.findall('x{3,}',input())))",linear,"['greedy', 'strings']",75
"n = int(input()) black = list(input()) white = list(input()) katie = list(input()) ALPHABET = [chr(i) for i in range(65, 65+26)] + [chr(i) for i in range(97, 97+26)] def optimal_score(LIST): d = {char: 0 for char in ALPHABET} for v in LIST: d[v] += 1 max_freq = max(d.values()) L = len(LIST) res = 0 for freq in d.values(): if L - freq >= n: res = max(res, freq + n) else: if not (L -freq < n and n == 1): res = L else: res = max(res, L - 1) return res score_black = optimal_score(black) score_white = optimal_score(white) score_katie = optimal_score(katie) M = max(score_black, score_katie, score_white) MAXCNT = 0 winner = ""NOBODY"" if M == score_black: winner = ""Kuro"" MAXCNT += 1 if M == score_white: winner = ""Shiro"" MAXCNT += 1 if M == score_katie: winner = ""Katie"" MAXCNT += 1 if MAXCNT == 1: print(winner) else: print(""Draw"")",linear,['greedy'],832
"import sys input=sys.stdin.readline al=list(""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"") n=int(input()) s=[input().rstrip() for i in range(3)] l=len(s[0]) ans=[0]*3 for c in al: for i in range(3): cnt_c=s[i].count(c) if cnt_c+n<=l: ans[i]=max(ans[i],cnt_c+n) else: if n==1 and l==cnt_c: ans[i]=max(ans[i],l-1) else: ans[i]=l if (ans[0]==ans[1] and max(ans)==ans[0]) or (ans[1]==ans[2] and max(ans)==ans[1]) or (ans[0]==ans[2] and max(ans)==ans[2]): print(""Draw"") elif max(ans)==ans[0]: print(""Kuro"") elif max(ans)==ans[1]: print(""Shiro"") else: print(""Katie"")",linear,['greedy'],569
"n=int(input()) st_a=input() st_b=input() st_c=input() a=[0 for i in range(125)] b=[0 for i in range(125)] c=[0 for i in range(125)] l=len(st_c) for i in range(l): a[ord(st_a[i])] +=1 b[ord(st_b[i])] +=1 c[ord(st_c[i])] +=1 maxi_a=0 maxi_b=0 maxi_c=0 if n==1: maxi_a =max(a) +1 maxi_b=max(b) +1 maxi_c=max(c) +1 if maxi_a >l: maxi_a-=2 if maxi_b >l: maxi_b -=2 if maxi_c >l: maxi_c-=2 else: for i in range(123): if (i>=65 and i <=90) or (i>=97 and i<=122): if a[i] +n >=l: maxi_a=max(maxi_a,l) else: maxi_a =max(maxi_a ,a[i] +n) if b[i] +n >=l: maxi_b=max(maxi_b,l) else: maxi_b =max(maxi_b ,b[i] +n) if c[i] +n >=l: maxi_c=max(maxi_c,l) else: maxi_c =max(maxi_c ,c[i] +n) s=[maxi_a,maxi_b,maxi_c] s.sort() if s[1] ==s[2]: print(""Draw"") if maxi_a >max(maxi_b,maxi_c): print(""Kuro"") if maxi_b >max(maxi_c,maxi_a): print(""Shiro"") if maxi_c >max(maxi_b,maxi_a): print(""Katie"")",linear,['greedy'],872
"from collections import Counter def f(x): return max(list(Counter(x).values())) n=int(input()) z=input() l=len(z) a=f(z) b=f(input()) c=f(input()) def v(x): if x==l: return x-1 else: return x+1 if n==1: a, b, c=v(a), v(b), v(c) if a>b and a>c: print(""Kuro"") elif b>a and b>c: print(""Shiro"") elif c>a and c>b: print(""Katie"") else: print(""Draw"") elif (l-a<=n)+(l-b<=n)+(l-c<=n)>=2: print(""Draw"") elif a>b and a>c: print(""Kuro"") elif b>a and b>c: print(""Shiro"") elif c>a and c>b: print(""Katie"") else: print(""Draw"")",linear,['greedy'],511
"turns = int(input()) s0 = input() s1 = input() s2 = input() d0 = dict() d1 = dict() d2 = dict() alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' for char in alphabet: d0[char] = 0 d1[char] = 0 d2[char] = 0 for char in s0: d0[char] += 1 for char in s1: d1[char] += 1 for char in s2: d2[char] += 1 m0 = max([d0[char] for char in alphabet]) m1 = max([d1[char] for char in alphabet]) m2 = max([d2[char] for char in alphabet]) l0 = len(s0) l1 = len(s1) l2 = len(s2) if turns == 1 and m0 == l0: score0 = m0 - 1 else: score0 = min(l0,m0+turns) if turns == 1 and m1 == l1: score1 = m1 - 1 else: score1 = min(l1,m1+turns) if turns == 1 and m2 == l2: score2 = m2 - 1 else: score2 = min(l2,m2+turns) scores = [score0,score1,score2] bestscore = max(scores) winnerlist = [i for i in range(3) if scores[i] == bestscore] if len(winnerlist) > 1: print('Draw') else: print(['Kuro','Shiro','Katie'][winnerlist[0]])",linear,['greedy'],913
"from collections import Counter; n = int(input()) a = input() b = input() c = input() fa = Counter(a); fb = Counter(b); fc = Counter(c); la = min(fa.most_common(1)[0][1] + n, len(a)) lb = min(fb.most_common(1)[0][1] + n, len(a)) lc = min(fc.most_common(1)[0][1] + n, len(a)) if fa.most_common(1)[0][1] == len(a) and n == 1: la = len(a)-1 if fb.most_common(1)[0][1] == len(b) and n == 1: lb = len(b)-1 if fc.most_common(1)[0][1] == len(c) and n == 1: lc = len(c)-1 if la > max(lb, lc): print(""Kuro"") elif lb > max(la, lc): print(""Shiro"") elif lc > max(la, lb): print(""Katie"") else: print(""Draw"")",linear,['greedy'],594
"N = int(input()) S = [input() for i in range(3)] bu = [] for s in S: cnt = {} mx = 0 for c in s: if c not in cnt: cnt[c] = 0 cnt[c] += 1 mx = max(mx, cnt[c]) if mx == len(s) and N == 1: bu.append(mx - 1) else: bu.append(min(len(s), mx + N)) ans = -1 ansmx = -1 for i in range(3): if bu[i] > ansmx: ans = i ansmx = bu[i] elif bu[i] == ansmx: ans = -1 if ans == -1: print('Draw') elif ans == 0: print('Kuro') elif ans == 1: print('Shiro') else: print('Katie')",linear,['greedy'],457
"def ct(s): a=[0]*26*2 for i in s: if ord(i)<97: a[ord(i)-65]+=1 else: a[ord(i)-97+26]+=1 return max(a) n=int(input()) s1=input() ln=len(s1) s1=ct(s1) s2=ct(input()) s3=ct(input()) s=[s1,s2,s3] for i in range(len(s)): if s[i]==ln and n==1: s[i]=ln-1 else:s[i]=s[i]+n if s[i]>ln: s[i]=ln s1=s[0] s2=s[1] s3=s[2] s.sort() if s[2]==s[1]: print('Draw') elif s[-1]==s1: print('Kuro') elif s[-1]==s2: print('Shiro') elif s[-1]==s3: print('Katie')",linear,['greedy'],439
"from collections import Counter def solve(n, ribbons): L = len(ribbons[0]) a = [Counter(r).most_common(1)[0][1] for r in ribbons] r = sorted([(x, i) for i, x in enumerate(a)], reverse=True) if n == 1: c = Counter(a) if c[L - 1] == 1: for i in range(3): if a[i] == L - 1: return i if c[L - 1] > 1: return 3 if c[L] + c[L - 2] == 1: for i in range(3): if a[i] == L or a[i] == L-2: return i if c[L] + c[L - 2] > 1: return 3 if r[1][0] == r[0][0]: return 3 if r[1][0] + n >= L: return 3 return r[0][1] print(a) def main(): n = int(input()) cats = ('Kuro', 'Shiro', 'Katie', 'Draw') ribbons = [input().strip() for _ in range(3)] k = solve(n, ribbons) print(cats[k]) if __name__ == '__main__': main()",linear,['greedy'],694
"n,k=list(map(int,input().split())) if k%2==0: s=""."" s=s+"" s=s+"".""*(n-len(s)) print(""YES"") print("".""*n) print(s) print(s) print("".""*n) else: if k<=n-2: a="" s="".""*((n-k)//2)+a+"".""*((n-k)//2) print(""YES"") print("".""*n) print(s) print("".""*n) print("".""*n) else: k=k-n+3 a="" s="".""*((n-k)//2)+a+"".""*((n-k)//2) print(""YES"") print("".""*n) print("".""+"" s=list(s) s[n//2]=""."" s="""".join(s) print(s) print("".""*n)",linear,['constructive algorithms'],396
"import sys,os,io from sys import stdin from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop from bisect import bisect_left , bisect_right import math alphabets = list('abcdefghijklmnopqrstuvwxyz') def isPrime(x): for i in range(2,x): if i*i>x: break if (x%i==0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def SieveOfEratosthenes(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def countdig(n): c = 0 while (n > 0): n //= 10 c += 1 return c def si(): return input() def prefix_sum(arr): r = [0] * (len(arr)+1) for i, el in enumerate(arr): r[i+1] = r[i] + el return r def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') def power_set(L): cardinality=len(L) n=2 ** cardinality powerset = [] for i in range(n): a=bin(i)[2:] subset=[] for j in range(len(a)): if a[-j-1]=='1': subset.append(L[j]) powerset.append(subset) powerset_orderred=[] for k in range(cardinality+1): for w in powerset: if len(w)==k: powerset_orderred.append(w) return powerset_orderred def fastPlrintNextLines(a): print('\n'.join(map(str,a))) def sortByFirstAndSecond(A): A = sorted(A,key = lambda x:x[0]) A = sorted(A,key = lambda x:x[1]) return li",linear,['constructive algorithms'],2000
"n,k=map(int,input().split()) if(k%2==0): print(""YES"") print('.'*n) print('.'+' print('.'+' print('.'*n) else: print(""YES"") print('.'*n) if(k<=n-2): print('.'*((n-k)//2)+' print('.'*n) else: print('.'+' print('.'+' print('.'*n)",linear,['constructive algorithms'],226
"from sys import stdin n, k = map(int, stdin.readline().split()) out = [['.'] * n for _ in range(4)] if k & 1: out[1][n >> 1] = ' k -= 1 for i in range(1, 3): l, r = 1, n - 2 for j in range(1, n - 2): if k: k -= 1 if j & 1: out[i][l] = ' l += 1 else: out[i][r] = ' r -= 1 for i in range(1, 3): if k: k -= 1 out[i][n >> 1] = ' print('YES\n%s' % ('\n'.join([''.join(x) for x in out])))",linear,['constructive algorithms'],382
"n,k=map(int,input().split()) s=[["".""]*n for i in range(4)] if k%2==0: for j in range(1,n-1): if k==0: break s[1][j]="" s[2][j]="" k-=2 else: cen=n//2 s[1][cen]="" k-=1 for i in range(1,3): for j in range(1,cen): if k>0: k-=2 s[i][j]=s[i][-j-1]="" if k==0: print(""YES"") for i in range(4): print("""".join(s[i])) else: print(""NO"")",linear,['constructive algorithms'],322
"def solution(n, k): ret = [['.' for _ in range(n)] for _ in range(4)] if 1 == k & 1: ret[1][n >> 1] = ' for i in range(1, n >> 1): if k < 2: break k -= 2 ret[1][i] = ' ret[1][n - 1 - i] = ' for i in range(1, n >> 1): if k < 2: break k -= 2 ret[2][i] = ' ret[2][n - 1 - i] = ' else: for i in range(1, n - 1): if k < 2: break k -= 2 ret[1][i] = ' ret[2][i] = ' print('YES') for i in range(4): print(''.join(ret[i])) solution(*map(int, input().split()))",linear,['constructive algorithms'],450
"n, k = map(int, input().split()) grid = [['.']*n for i in range(4)] if k % 2 == 0: for i in range(k//2): grid[1][1+i], grid[2][1+i] = ' else: m = n//2 if k > n - 2: for i in range(1, n-1): grid[1][i] = ' for i in range(1, (k-n+2)//2 + 1): grid[2][m+i], grid[2][m-i] = ' else: grid[1][m] = ' if k > 1: for i in range(1, k//2 + 1): grid[1][m-i], grid[1][m+i] = ' print('YES') for i in grid: print(''.join(i))",linear,['constructive algorithms'],406
"def getIntList(): return list(map(int, input().split())); nbColumn, h=getIntList(); if (nbColumn-2)*2<h: print('NO') else: print('YES') if h%2==0: print('.'*nbColumn); print('.'+' print('.'+' print('.'*nbColumn); else: print('.'*nbColumn); hFirst=min(h, nbColumn-2); countPoint=(nbColumn-hFirst)//2; print('.'*countPoint+' hSecond=(h-hFirst)//2; countPoint=nbColumn-2*hSecond-2; print('.'+' print('.'*nbColumn);",linear,['constructive algorithms'],411
"n, k = map(int, input().split()) print(""YES"") for i in range(n): print(""."", end = '') print() if k&1: if k <= n-2: tmp = (n-k)>>1 for i in range(tmp): print(""."", end = '') for i in range(k): print("" for i in range(tmp): print(""."", end = '') print() for i in range(n): print(""."", end = '') print() else: print(""."", end = '') for i in range(n-2): print("" print(""."") k -= n-2 print(""."", end = '') for i in range(k>>1): print("" for i in range(n-k-2): print(""."", end = '') for i in range(k>>1): print("" print(""."") else: k = k>>1 for j in range(2): print(""."", end = '') for i in range(k): print("" for i in range(n-k-1): print(""."", end = '') print() for i in range(n): print(""."", end = '') print()",linear,['constructive algorithms'],690
"s = input() while s!="""": if s==s[::-1]: s=s[:(len(s)-1)] else: break print(len(s))",linear,"['brute force', 'implementation', 'strings']",82
"s=input() for i in range(len(s),0,-1): if s[:i]!=s[i-1::-1]: print(i) break else: print(0)",linear,"['brute force', 'implementation', 'strings']",90
def palin(s): global ans if (s[::-1] != s or len(s) == 0): return len(s) else: return palin(s[1:]) s = input() print(palin(s)),linear,"['brute force', 'implementation', 'strings']",126
"s = input() def palindrome(s): i=0 j=len(s)-1 p=True while i<=j: if s[i]!=s[j]: p=False break i+=1 j-=1 return p ans=0 for i in range(len(s)): for j in range(len(s)-1, i,-1): if not palindrome(s[i:j+1]): ans=max(ans, len(s[i:j+1])) break print(ans)",linear,"['brute force', 'implementation', 'strings']",248
"s = input() n = len(s) Ans = 0 for i in range(n): for j in range(i + 1, n): L = i R = j while L < R and s[L] == s[R]: L += 1 R -= 1 if L < R and Ans < j - i + 1: Ans = j - i + 1 print(Ans)",linear,"['brute force', 'implementation', 'strings']",188
s = input() def is_pal(s): if s == s[::-1]: return True else: return False if not is_pal(s): print(len(s)) else: not_eq = False for i in range(len(s)-1): if s[i] != s[i+1]: print(len(s)-1) not_eq = True break if not not_eq: print(0),linear,"['brute force', 'implementation', 'strings']",232
s=input() c=c1=0 for i in range(len(s)//2): if s[i]==s[len(s)-i-1]: c+=1 for i in range(len(s)): if s[i]==s[0]: c1+=1 if c1==len(s): print(0) elif c==len(s)//2: print(len(s)-1) else: print(len(s)),linear,"['brute force', 'implementation', 'strings']",196
s=input() while(len(s)>0): if s!=s[::-1]: break else: s=s[1:] print(len(s)),linear,"['brute force', 'implementation', 'strings']",75
s=input() while(1): if(len(s)==1): print(0) break elif(s==s[::-1]): s=s[1:] else: print(len(s)) break,linear,"['brute force', 'implementation', 'strings']",101
"from collections import deque import sys input = sys.stdin.readline def bfs(start,graph,explored): queue = deque([start]) visited = {start} ele = 0 while queue: node = queue.popleft() explored.add(node) neighbours = graph[node] cnt = 0 for neighbour in neighbours: if neighbour not in visited and neighbour not in explored: cnt += 1 if e[0] == 0 and cnt != 1: ele = node break else: for neighbour in neighbours: if neighbour not in visited: queue.append(neighbour) visited.add(neighbour) return ele from types import GeneratorType def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc @bootstrap def solve(i): cnt = 0 visited.add(i) for k in graph[i]: if k not in visited: cnt += 1 if cnt >= 1: for k in graph[i]: if k not in visited: yield solve(k) break else: r[0] = i yield n = int(input()) graph = {} for _ in range(n-1): a,b = map(int,input().split()) if a in graph: graph[a].append(b) else: graph[a] = [b] if b in graph: graph[b].append(a) else: graph[b] = [a] roots = [] visited = set() ele = 0 e = [ele] for i in graph: if len(graph[i]) == 1: roots.append(i) x = roots[0] ans = [] ele = bfs(x,graph,visited) ans.append((str(x),str(ele))) for i in graph[ele]: r = [0] if i not in visited: y = solve(i) ans.append([str(r[0]),str(ele)]) if len(visited) == n: sys.stdout.write(""Yes\n"") q = str(len(ans)) sys.stdout.write(q+""\n"") for i in ans: e = "" "".join(i) sys.stdout.write(e + ""\n"") else: sys.stdout.write(""No\n"")",linear,"['implementation', 'trees']",1658
"a = int(input()) s = {} ans = 0 for i in range(a - 1): v, c = map(int, input().split()) if v in s: s[v].append(c) else: s[v] = [c] if c in s: s[c].append(v) else: s[c] = [v] c = 0 for i in range(1, a + 1): if len(s[i]) > 2: c += 1 ans = i if c > 1: print(""No"") elif c == 0: print(""Yes"") print(1) for i in s: if len(s[i]) == 1: print(i, end="" "") else: print(""Yes"") print(len(s[ans])) k = [] for i in s: if len(s[i]) == 1: k.append(i) for i in k: print(min(ans, i), max(ans, i))",linear,"['implementation', 'trees']",476
"import os, sys from io import BytesIO, IOBase def main(): n = rint() deg, edges = [0] * n, rints_2d(n - 1) for u, v in edges: deg[u - 1] += 1 deg[v - 1] += 1 coun = [0, deg.count(1), deg.count(2)] if n - coun[1] == 1: print(f'Yes\n{n - 1}') [print(*x) for x in edges] elif coun[1] + coun[2] == n: print(f'Yes\n1\n{deg.index(1) + 1} {n - deg[::-1].index(1)}') elif n - sum(coun) == 1: for i in range(n): if deg[i] > 2: print(f'Yes\n{deg[i]}') for j in range(n): if deg[j] == 1: print(i + 1, j + 1) exit() else: print('No') class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") BUFSIZE = 8192 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") rstr = lambda: input().strip() rstrs = lambda: [str(x) for x in input().split()] rstr_2d = lambda n: [rstr() for _ in range(n)] rint",linear,"['implementation', 'trees']",1999
"import os, sys from io import BytesIO, IOBase def main(): n = rint() deg, edges = [0] * n, rints_2d(n - 1) if n == 2: exit(print(f'Yes\n1\n1 2')) for u, v in edges: deg[u - 1] += 1 deg[v - 1] += 1 ix = deg.index(max(deg)) if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1: print(f'Yes\n{deg.count(1)}') for i in range(n): if deg[i] == 1: print(i + 1, ix + 1) else: print('No') class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") BUFSIZE = 8192 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") rstr = lambda: input().strip() rstrs = lambda: [str(x) for x in input().split()] rstr_2d = lambda n: [rstr() for _ in range(n)] rint = lambda: int(input()) rints = lambda: [int(x) for x in input().split()] rint_2d = lambda n: [rint() for _ in range(n)] rints_2d = lambda n:",linear,"['implementation', 'trees']",2000
"import os, sys from io import BytesIO, IOBase def main(): n = rint() deg = [0] * n if n == 2: exit(print(f'Yes\n1\n1 2')) for i in range(n - 1): u, v = rints() deg[u - 1] += 1 deg[v - 1] += 1 ix = deg.index(max(deg)) if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1: print(f'Yes\n{deg.count(1)}') for i in range(n): if deg[i] == 1: print(i + 1, ix + 1) else: print('No') class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") BUFSIZE = 8192 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") rstr = lambda: input().strip() rstrs = lambda: [str(x) for x in input().split()] rstr_2d = lambda n: [rstr() for _ in range(n)] rint = lambda: int(input()) rints = lambda: [int(x) for x in input().split()] rint_2d = lambda n: [rint() for _ in range(n)] rints_2d = lambda n: [rin",linear,"['implementation', 'trees']",2000
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans def",linear,"['implementation', 'trees']",1999
"import sys def input(): return sys.stdin.readline().strip() def iinput(): return int(input()) def rinput(): return map(int, sys.stdin.readline().strip().split()) def get_list(): return list(map(int, sys.stdin.readline().strip().split())) n=iinput() d={} for i in range(n - 1): u,v=rinput() d.setdefault(u,[]).append(v) d.setdefault(v,[]).append(u) node=1 for key in d: if(len(d[key])>len(d[node])): node=key ans=[] visited=[0]*n visited[node-1]=1 for c in d[node]: while(True): visited[c-1]=1 if(len(d[c])==1): ans.append([node,c]) break for child in d[c]: if(visited[child-1]!=1): c=child break if(sum(visited)==n): print(""Yes"") print(len(ans)) for c in ans: print(*c) else: print(""No"")",linear,"['implementation', 'trees']",687
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans def",linear,"['implementation', 'trees']",1999
"def main(): nNodes = int(input()) neighborsOf = {node: [] for node in map(str, range(1, nNodes+1))} threeNeighborNodeExists, threeNeighborNode = False, None for i in range(1, nNodes): node1, node2 = input().split() neighborsOf[node1].append(node2), neighborsOf[node2].append(node1) if len(neighborsOf[node1]) == 3: if threeNeighborNodeExists: return 'No' threeNeighborNodeExists, threeNeighborNode = True, node1 elif len(neighborsOf[node2]) == 3: if threeNeighborNodeExists: return 'No' threeNeighborNodeExists, threeNeighborNode = True, node2 if threeNeighborNodeExists: return tnnDecompositionFrom(neighborsOf, threeNeighborNode+' ') return decompositionFrom(neighborsOf) def tnnDecompositionFrom(tree, threeNeighborNode): paths = tuple(threeNeighborNode + node for node in tree if len(tree[node]) == 1) return f'Yes\n{len(paths)}\n' + '\n'.join(paths) def decompositionFrom(tree): return 'Yes\n1\n' + ' '.join(node for node in tree if len(tree[node]) == 1) if __name__ == '__main__': print(main())",linear,"['implementation', 'trees']",1000
"n,m,a,b=[int(x) for x in input().split()] if n>m: if n%m==0: print(0) else: t1=n%m print(min(t1*b,(m-t1)*a)) elif n==m: print(0) else: print(min(n*b,(m-n)*a))",linear,"['implementation', 'math']",158
"n,m,a,b=map(int, input().split()) print(min(n%m*b, (m-n%m)*a))",linear,"['implementation', 'math']",62
"n,m,a,b=map(int,input().split()) z=(n%m)*b x=((n//m+1)*m-n)*a y=min(z,x) print(y if y>0 else 0)",linear,"['implementation', 'math']",95
"n,m,a,b=[int(x)for x in input().split()] if n<m:print(min(a*(m-n),b*n)) else:print(min(b*(n%m),a*(m-(n%m)) ))",linear,"['implementation', 'math']",109
"from collections import deque as de import math from collections import Counter as cnt from functools import reduce from typing import MutableMapping from itertools import groupby as gb from fractions import Fraction as fr def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def decimalToBinary(n): return bin(n).replace(""0b"", """") def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def isPowerOfTwo(n): return (math.ceil(Log2(n)) == math.floor(Log2(n))); n,m,a,b=map(int,input().split()) if n%m: ul=(n//m)+1 ll=n//m print(min(((ul*m)-n)*a, (n-(ll*m))*b)) else: print(0)",linear,"['implementation', 'math']",1612
"n,m,a,b = map(int,input().split()) if n%m==0: print(0) else: k = n%m print(min(k*b,(m-k)*a))",linear,"['implementation', 'math']",92
"n,m,a,b = map(int,input().split()) if n%m!=0: mn = n//m * m mx = n//m * m + m print(min(((n - mn) * b),((mx - n) * a))) else:print(0)",linear,"['implementation', 'math']",133
"n, m, a, b = map(int, input().split()) print(min(n%m*b, (m-n%m)*a))",linear,"['implementation', 'math']",67
"from sys import stdin n, m, a, b = map(int, stdin.readline().split()) x = n%m print(min(a *(m-x), b*x))",linear,"['implementation', 'math']",103
"inf=10**9 n=int(input()) t=[0]*n m={} for j in range(n): s=input() bal=0 req=0 for i in s: if i=="")"": bal-=1 else: if bal<0: req+=bal bal=1 else: bal+=1 if req<0: if bal>0: req=inf else: req+=bal else: req=bal t[j]=req if req not in m: m[req]=1 else: m[req]+=1 res=0 for i in t: if i>=0: if -i in m: res+=m[-i] print(res)",linear,['implementation'],321
"import sys import io, os input = sys.stdin.readline n = int(input()) S = [str(input().rstrip()) for i in range(n)] from collections import defaultdict d1 = defaultdict(lambda: 0) d2 = defaultdict(lambda: 0) ans = 0 for i, s in enumerate(S): cum1 = 0 flag1 = True for c in s: if c == '(': cum1 += 1 else: cum1 -= 1 if cum1 < 0: flag1 = False if flag1: ans += d2[cum1] cum2 = 0 flag2 = True for i in reversed(range(len(s))): c = s[i] if c == ')': cum2 += 1 else: cum2 -= 1 if cum2 < 0: flag2 = False if flag2: ans += d1[cum2] if cum1 == 0 and cum2 == 0 and flag1 and flag2: ans += 1 if flag1: d1[cum1] += 1 if flag2: d2[cum2] += 1 print(ans)",linear,['implementation'],639
op=[0]*1000000 cl=[0]*1000000 def fun(s): v = [] for i in range(len(s)): l = len(v) if s[i]=='(': v.append(s[i]) elif l>0 and v[l-1]=='(': v.pop() else : v.append(')') l = len(v) if l==0: op[0]+=1 cl[0]+=1 elif v[0]==v[l-1]: if v[0]=='(': op[l]+=1 else : cl[l]+=1 t = int ( input() ) while t>0: t-=1 s = str ( input() ) fun(s) ans = 0 for i in range(1000000): ans+=(op[i] * cl[i]) print(ans),linear,['implementation'],391
"def main(): c,r,o,e=0,0,[0]*300000,[0]*300000 for _ in range(int(input())): s=input() l,n=0,0 for i in s: if i=='(': l+=1 else: if l!=0: l-=1 else: n+=1 if l==0 and n==0: c+=1 elif l!=0 and n!=0: pass elif l!=0: o[l]+=1 else: e[n]+=1 for i in range(300000): if e[i] and o[i]: r+=e[i]*o[i] print(pow(c,2)+r) if __name__=='__main__': main()",linear,['implementation'],338
"from sys import stdin input=stdin.readline from collections import defaultdict def num(s): l,r=0,0 for i in s: if l==0 and i=="")"": r+=1 elif i==""("": l+=1 elif l and i=="")"": l-=1 return (l,r) def f(mp,cnt): ans=0 for l in cnt: if l.count(0)<1: continue if l!=(0,0) and l==l[::-1]: continue t=mp[l[::-1]] t2=mp[l[::-1]] ans+=t if t and l!=l[::-1]: mp[l]-=1 return ans cnt=[] mp=defaultdict(int) for i in range(int(input())): s=input() l=num(s) cnt.append(l) mp[l]+=1 print(f(mp,cnt))",linear,['implementation'],481
"from sys import stdin input=stdin.readline from collections import defaultdict def num(s): l,r=0,0 for i in s: if l==0 and i=="")"": r+=1 elif i==""("": l+=1 elif l and i=="")"": l-=1 return (l,r) def f(mp,cnt): ans=0 for l in cnt: if l.count(0)<1: continue t=mp[l[::-1]] ans+=t if t and l!=l[::-1]: mp[l]-=1 return ans cnt=[] mp=defaultdict(int) for i in range(int(input())): s=input() l=num(s) cnt.append(l) mp[l]+=1 print(f(mp,cnt))",linear,['implementation'],429
"from collections import defaultdict from sys import stdin all_in = stdin.read().splitlines() n = int(all_in[0]) s = all_in[1:] one = defaultdict(lambda: 0) two = defaultdict(lambda: 0) for el in s: I = 0 min_ = 0 for char in el: I += {'(': 1, ')': -1}[char] min_ = min(min_, I) if I >= 0 and min_ == 0: one[I] += 1 if I <= 0 and min_ == I: two[I] += 1 ans = 0 for el in one.keys(): ans += one[el] * two[-el] print(ans)",linear,['implementation'],418
"n = int(input()) from collections import defaultdict first = defaultdict(int) second = defaultdict(int) for _ in range(n): s = input().strip() count = 0 min_count = 0 for c in s: if c == '(': count += 1 else: count -= 1 min_count = min(count, min_count) if min_count >= 0: first[count] += 1 if count == min_count: second[count] += 1 res = 0 for k, v in first.items(): res += v * second[-k] print(res)",linear,['implementation'],400
"n = int(input()) a = list(map(int, input().strip().split())) b = set(a) res = len(b) if 0 in b: res -= 1 print(res)",linear,"['implementation', 'sortings']",115
"n = int(input()) a = set(map(int, input().split())) ans = len(a) - 1 if 0 in a else len(a) print(ans)",linear,"['implementation', 'sortings']",101
"n = int(input()) a = list(map(int, input().split())) d = set(a) if (0 in a): print(len(d)-1) else: print(len(d))",linear,"['implementation', 'sortings']",112
"n=int(input()) a=list(map(int,input().split())) c=0 po=[0]*1000000 ne=[0]*1000000 for i in range(n): if(a[i]<0 and ne[a[i]]!=1): c+=1 ne[a[i]]=1 elif(a[i]>0 and po[a[i]]!=1): c+=1 po[a[i]]=1 print(c)",linear,"['implementation', 'sortings']",199
n=int(input()) l=[int(i) for i in input().split()] s=set(l) if 0 in s: print(len(s)-1) else: print(len(s)),linear,"['implementation', 'sortings']",106
"n=int(input()) l=list(map(int,input().split())) s=set(l) x=0 if x in s: print(len(s)-1) else: print(len(s))",linear,"['implementation', 'sortings']",107
"n = int(input()) a = list(map(int, input().split())) s = set(a) s.discard(0) print(len(s))",linear,"['implementation', 'sortings']",90
"n=int(input()) l1=list(map(int,input().split())) if len(list(set(l1)))==1 and l1[0]>0: print(1) else: l2=list(set(l1)) x=l1.count(0) if x==0: print(len(l2)) else: print(len(l2)-1)",linear,"['implementation', 'sortings']",179
"n, = map(int,input().split()) arr = set(map(int,input().split())) print(len(arr)-(0 in arr))",linear,"['implementation', 'sortings']",92
"n=int(input()) a=list(map(int,input().split())) b=[0]*n for i in range(n): if(i+1>a[i]): b[i]=i+1 else: q=(a[i]-(i+1)+n)//n b[i]=i+1 + q*n print(b.index(min(b))+1)",linear,"['binary search', 'math']",163
"from math import ceil def main(): n=int(input()) a=list(map(int,input().split( ))) ans=10**6 value=10**9+7 for i in range(n): t=ceil((a[i]-i)/n) tmp=i+n*t if tmp<value: value=tmp ans=i+1 print(ans) main()",linear,"['binary search', 'math']",204
"a=int(input()) z=list(map(int,input().split())) ans=[] k=len(z) for i in range(len(z)): if((z[i]-i)%len(z)==0): ans.append((z[i]-i)//k) else: ans.append((z[i]-i)//k) ans[-1]+=1 t=min(ans) print(ans.index(t)+1)",linear,"['binary search', 'math']",209
"from sys import stdin,stdout from math import ceil nmbr = lambda: int(stdin.readline()) lst = lambda: list(map(int, stdin.readline().split())) for _ in range(1): n=nmbr() a=lst() p=0 ans=float('inf') for i in range(n): turns=ceil((a[i]-i)/n) if turns<ans: ans=turns p=i print(p+1)",linear,"['binary search', 'math']",280
num = int(input()) layne = input() layne = layne.split() layne = [int(i) for i in layne] mx = max(layne) dorf = mx * 2 * num indx = 1 for i in range(num): dor = (layne[i] // num) * num if (layne[i] % num) - i > 0: dor = dor + num + i + 1 else: dor = dor + i + 1 if dor < dorf: dorf = dor indx = i + 1 print(indx),linear,"['binary search', 'math']",312
"import math n = int(input()) a = list(map(lambda x : int(x), input().split())) q = len(a) earliest_time = pow(10, 9) + 1000 earliest_queue = 1 for i in range(q): n = int(max(0, math.ceil((a[i] + 1 - (i + 1)) / q))) t = (i + 1) + n * q if t < earliest_time: earliest_time = t earliest_queue = i + 1 print(earliest_queue)",linear,"['binary search', 'math']",319
"n = int(input()) arr = list(map(int, input().split())) for i in range(n): arr[i] = (arr[i]-i)//n + (1 if (arr[i]-i)%n>0 else 0) print(arr.index(min(arr))+1)",linear,"['binary search', 'math']",156
"import math n=int(input()) a=list(map(int ,input().split())) x=10**9+2 y=0 for i in range(n): if(x>math.ceil((a[i]-i)/n)*n+i+1): x=math.ceil((a[i]-i)/n)*n+i+1 y=i+1 print(y)",linear,"['binary search', 'math']",173
"n = int(input()) a = list(map(int, input().strip().split())) amin = min(a) for i in range(n): a[i] -= amin ans = amin % n cnt = 0 while True: if a[ans] <= cnt: break ans = (ans + 1) % n cnt += 1 print(ans + 1)",linear,"['binary search', 'math']",209
"from collections import defaultdict import sys import bisect input=sys.stdin.readline n,m=map(int,input().split()) a=[int(i) for i in input().split()if i!='\n'] rem=[[] for i in range(m)] req=n//m ans=0 for i in range(n): rem[a[i]%m].append([a[i],i]) ind=m-1 for i in range(m): size=len(rem[i]) if size>req: ind=i if size<req: ok=False for j in range(ind,-1,-1): while len(rem[j])>req: pop,_=rem[j].pop() rem[i].append([pop+(i-j)%m,_]) if len(rem[i])==req: ok=True break if ok: break ind-=1 else: ind=m-1 for j in range(ind,-1,-1): while len(rem[j])>req: pop,_=rem[j].pop() rem[i].append([pop+(i-j)%m,_]) if len(rem[i])==req: ok=True break if ok: break ind-=1 out=[0]*(n) for i in rem: for j in i: out[j[1]]=j[0] print(sum(out)-sum(a)) out=' '.join(map(str,out)) print(out)",linear,"['data structures', 'greedy', 'implementation']",773
"from collections import defaultdict import sys import bisect input=sys.stdin.readline n,m=map(int,input().split()) a=[int(i) for i in input().split()if i!='\n'] rem=[[] for i in range(m)] req=n//m ans=0 for i in range(n): rem[a[i]%m].append([a[i],i]) ind=m-1 for i in range(m): size=len(rem[i]) if size>req: ind=i if size<req: ok=False for j in range(ind,ind-m,-1): while len(rem[j])>req: pop,_=rem[j].pop() rem[i].append([pop+(i-j)%m,_]) if len(rem[i])==req: ok=True break if ok: break ind-=1 out=[0]*(n) for i in rem: for j in i: out[j[1]]=j[0] print(sum(out)-sum(a)) out=' '.join(map(str,out)) print(out)",linear,"['data structures', 'greedy', 'implementation']",607
"from sys import stdin input = stdin.buffer.readline n,m=map(int,input().split()) arr=[int(x) for x in input().split()] dp=[[] for i in range(m)] for i in range(n): dp[arr[i]%m].append(i) res=0 k=n//m ans=arr.copy() s=[] for t in range(2): for i in range(m): if len(dp[i])<k: while len(s)!=0 and len(dp[i])<k: x=s.pop() y=arr[x]%m if i>y: ans[x]=ans[x]+(i-y) res=res+(i-y) else: ans[x]=ans[x]+(m-1-y)+(i+1) res=res+(m-1-y)+(i+1) dp[i].append(""xxx"") if len(dp[i])>k: while len(dp[i])>k: s.append(dp[i].pop()) print(res) print(*ans)",linear,"['data structures', 'greedy', 'implementation']",529
"n,m=map(int, input().split()) a=list(map(int, input().split())) t=n//m remain=[[] for i in range(m)] for i in range(n): x=a[i]%m remain[x].append(i) ans=0 f=[] for i in range(2*m): cur=i%m while len(remain[cur])>t: elm=remain[cur].pop() f.append([elm,i]) while len(remain[cur])<t and len(f)!=0: elm,j=f.pop() remain[cur].append(elm) a[elm]+=abs(i-j) ans+=abs(i-j) print(ans) print(*a)",linear,"['data structures', 'greedy', 'implementation']",384
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = sel",linear,"['data structures', 'greedy', 'implementation']",1999
"from collections import deque n, m = map(int, input().split()) arr = [int(z) for z in input().split()] mods = [0 for i in range(m)] placement = [[] for i in range(m)] for i in range(n): mods[arr[i] % m] += 1 placement[arr[i] % m].append(i) cnt = 0 queue = deque() target = n//m for i in range(2*m): mod = i % m if mods[mod] > n//m: for c in range(mods[mod] - target): queue.append([i, placement[mod][c]]) mods[mod] = target elif mods[mod] < target: while len(queue) > 0 and mods[mod] < target: elem, indice = queue.popleft() mods[mod] += 1 cnt += (mod - elem) % m arr[indice] += (mod - elem) % m print(cnt) print(' '.join([str(i) for i in arr]))",linear,"['data structures', 'greedy', 'implementation']",645
"from sys import stdout, stdin, setrecursionlimit from io import BytesIO, IOBase from collections import * from itertools import * from random import * from bisect import * from string import * from queue import * from heapq import * from math import * from re import * from os import * class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") stdin, stdout = IOWrapper(stdin), IOWrapper(stdout) def fast(): return stdin.readline().strip() def zzz(): return [int(i) for i in fast().split()] z, zz = fast, lambda: (map(int, z().split())) szz, graph, mod, szzz = lambda: sorted( zz()), {}, 10**9 + 7, lambda: sorted(zzz()) def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2)) def output(answer, end='\n'): stdout.write(str(answer) + end) dx = [-1, 1, 0, 0, 1, -1, 1, -1] dy = [0, 0, 1, -1, 1, -1, -1, 1] n, m = zz() arr = zzz() s = sum(arr) x = [[] for i in",linear,"['data structures', 'greedy', 'implementation']",2000
"from sys import stdout, stdin, setrecursionlimit from io import BytesIO, IOBase from collections import * from itertools import * from random import * from bisect import * from string import * from queue import * from heapq import * from math import * from re import * from os import * class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") stdin, stdout = IOWrapper(stdin), IOWrapper(stdout) def fast(): return stdin.readline().strip() def zzz(): return [int(i) for i in fast().split()] z, zz = fast, lambda: (map(int, z().split())) szz, graph, mod, szzz = lambda: sorted( zz()), {}, 10**9 + 7, lambda: sorted(zzz()) def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2)) def output(answer, end='\n'): stdout.write(str(answer) + end) dx = [-1, 1, 0, 0, 1, -1, 1, -1] dy = [0, 0, 1, -1, 1, -1, -1, 1] n,m=zzz() arr = zzz() s = sum(arr) idx = [[] for i in",linear,"['data structures', 'greedy', 'implementation']",2000
"from sys import stdout, stdin, setrecursionlimit from io import BytesIO, IOBase from collections import * from itertools import * from random import * from bisect import * from string import * from queue import * from heapq import * from math import * from re import * from os import * class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") stdin, stdout = IOWrapper(stdin), IOWrapper(stdout) def fast(): return stdin.readline().strip() def zzz(): return [int(i) for i in fast().split()] z, zz = fast, lambda: (map(int, z().split())) szz, graph, mod, szzz = lambda: sorted( zz()), {}, 10**9 + 7, lambda: sorted(zzz()) def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2)) def output(answer, end='\n'): stdout.write(str(answer) + end) dx = [-1, 1, 0, 0, 1, -1, 1, -1] dy = [0, 0, 1, -1, 1, -1, -1, 1] n,m=zzz() arr = zzz() s = sum(arr) idx = [[] for i in",linear,"['data structures', 'greedy', 'implementation']",2000
"import sys, heapq n = int(sys.stdin.readline()) key = [] for i in ['S', 'M', 'L']: for j in range(4): key.append(j * 'X' + i) prev = dict().fromkeys(key, 0) now = dict().fromkeys(key, 0) for _ in range(n): prev[sys.stdin.readline().rstrip()] += 1 for _ in range(n): now[sys.stdin.readline().rstrip()] += 1 for i in key: temp = min(prev[i], now[i]) prev[i] -= temp now[i] -= temp ans = 0 for i in key: ans += now[i] print(ans)",linear,"['greedy', 'implementation']",425
n=int(input()) a=b=[] k=0 for _ in range(n): a.append(input()) for i in range(n): t=input() if t in a: a.remove(t) print(len(a)),linear,"['greedy', 'implementation']",128
n=int(input()) l1=[] l2=[] for _ in range(n): l1.append(input()) for _ in range(n): l2.append(input()) c=0 for i in range(n): if(l1[i] in l2): l2.remove(l1[i]) else: c+=1 print(c),linear,"['greedy', 'implementation']",179
"n = int(input()) a = [input() for _ in range(n)] b = [input() for _ in range(n)] cost = 0 for s in [""M"", ""S"", ""XS"", ""XXS"", ""XXXS"", ""L"", ""XL"", ""XXL"", ""XXXL""]: ca = a.count(s) cb = b.count(s) cost += ca - min(ca, cb) print(cost)",linear,"['greedy', 'implementation']",226
"def solve(): n = int(input()) a_dicts = [{}, {}] for j in range(2): for i in range(n): x = input() if x in a_dicts[j]: a_dicts[j][x] += 1 else: a_dicts[j][x] = 1 if x not in a_dicts[1 - j]: a_dicts[1 - j][x] = 0 c = 0 for k in a_dicts[0]: c += abs(a_dicts[0][k] - a_dicts[1][k]) return c // 2 print(solve())",linear,"['greedy', 'implementation']",307
x = int(input()) list1 = [] for i in range(x): value = input() list1.append(value) for i in range(x): value = input() if value in list1: list1.remove(value) print(len(list1)),linear,"['greedy', 'implementation']",174
"from collections import Counter n = int(input()) a = Counter() b = Counter() for _ in range(n): a[input().strip()] += 1 for _ in range(n): b[input().strip()] += 1 ans = 0 for key in b: ans += max(b[key] - a[key], 0) print(ans)",linear,"['greedy', 'implementation']",226
"import sys, os.path if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") t = int(input()) last = [] current = [] for i in range(t): last.append(str(input())) for i in range(t): current.append(str(input())) for i in range(len(last)): if last[i] in current: current[current.index(last[i])] = ""*"" last[i] = ""*"" last.sort() current.sort() total = 0 for i in range(len(last)): if last[i] == current[i]: continue else: total+=1 print(total)",linear,"['greedy', 'implementation']",448
"from collections import deque as de import math from collections import Counter as cnt class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic n=int(input()) pp=n nn=n pl=[] nl=[] while pp: pp-=1 pl.append(input()) while nn: nn-=1 nl.append(input()) ans=0 pmc=pl.count(""M"") mc=nl.count(""M"") if pmc < mc: ans+=mc -pmc psc=pl.count(""S"") sc=nl.count(""S"") if psc < sc: ans+=sc -psc plc=pl.count(""L"") lc=nl.count(""L"") if plc < lc: ans+=lc -plc pxlc=pl.count(""XL"") xlc=nl.count(""XL"") if pxlc < xlc: ans+=xlc -pxlc pxxlc=pl.count(""XXL"") xxlc=nl.count(""XXL"") if pxxlc < xxlc: ans+=xxlc -pxxlc pxxxlc=pl.count(""XXXL"") xxxlc=nl.count(""XXXL"") if pxxxlc < xxxlc: ans+=xxxlc -pxxxlc pxsc=pl.count(""XS"") xsc=nl.count(""XS"") if pxsc < xsc: ans+=xsc -pxsc pxxsc=pl.count(""XXS"") xxsc=nl.count(""XXS"") if pxxsc < xxsc: ans+=xxsc -pxxsc pxxxsc=pl.count(""XXXS"") xxxsc=nl.count(""XXXS"") if pxxxsc < xxxsc: ans+=xxxsc -pxxxsc print(ans)",linear,"['greedy', 'implementation']",1837
"n,M=map(int,input().split()) a=[0]+[int(x) for x in input().split()]+[M] t1=[] t2=[] for i in range(n+1): if i%2==0: t1.append(a[i+1]-a[i]) else: t2.append(a[i+1]-a[i]) t2.append(0) import math ans=sum(t1) p=0 q=sum(t2) for i in range(math.ceil(n/2)): p=p+t1[i] q=q-t2[i-1] ans=max(ans,p+q-1) print(ans)",linear,['greedy'],303
"N,M=map(int,input().split()) light=[0]+[int(_) for _ in input().split()]+[M] sumlist=[] sumlight,ans=0,-10**30 for i in range(N+1): sumlight+=(-1)**(i+1)*light[i] sumlist.append(sumlight) for i in range(1,N+1): if light[i]>light[i-1]+1: ans=max(ans,2*sumlist[i-1]-sumlight+(-1)**(i+1)*(light[i]-1)) if light[i]<light[i+1]-1: ans=max(ans,2*sumlist[i]-sumlight+(-1)**i*(light[i]+1)) if N%2==0: print(max(ans,sumlight+M)) else: print(max(ans+M,sumlight))",linear,['greedy'],451
"N,M=map(int,input().split()) L=[0]+[int(_) for _ in input().split()]+[M] sumL=[0] ans=-10**30 for i in range(1,N+1): sumL.append(sumL[-1]-(-1)**i*L[i]) for i in range(1,N+1): if L[i]>L[i-1]+1: ans=max(ans,2*sumL[i-1]-sumL[-1]-(-1)**(i)*(L[i]-1)) if L[i]<L[i+1]-1: ans=max(ans,2*sumL[i]-sumL[-1]+(-1)**i*(L[i]+1)) if N%2==0: print(max(ans,sumL[-1]+M)) else: print(max(ans+M,sumL[-1]))",linear,['greedy'],383
"n, M = map(int, input().strip().split()) a = list(map(int, input().strip().split())) a.insert(0, 0) n += 1 lit = [0] * (n + 1) for i in range(1, n): if i % 2 == 0: lit[i] = lit[i - 1] else: lit[i] = lit[i - 1] + a[i] - a[i - 1] if n % 2 == 0: lit[n] = lit[n - 1] else: lit[n] = lit[n - 1] + M - a[n - 1] ans = lit[n] for i in range(n): pre_lit = lit[i] post_lit = M - a[i] - (lit[n] - lit[i]) if i > 0 and a[i - 1] + 1 < a[i]: if i % 2 == 0: ans = max(ans, pre_lit + 1 + post_lit) else: ans = max(ans, pre_lit - 1 + post_lit) if (i + 1 < n and a[i] + 1 < a[i + 1]) or (i + 1 == n and a[n - 1] + 1 < M): if i % 2 == 0: ans = max(ans, pre_lit + post_lit + 1) else: ans = max(ans, pre_lit + post_lit - 1) print(ans)",linear,['greedy'],712
"n, M = map(int, input().split()) A = list(map(int, input().split())) A = [0]+A+[M] D = [] for i in range(n+1): D.append(A[i+1]-A[i]) E = [] O = [] for i, d in enumerate(D): if i%2 == 0: E.append(d) O.append(0) else: O.append(d) E.append(0) from itertools import accumulate CE = [0]+E CE = list(accumulate(CE)) CO = [0]+O CO = list(accumulate(CO)) ans = CE[-1] for i in range(n+1): if D[i] == 1: continue temp = CE[i]+(D[i]-1)+CO[-1]-CO[i+1] ans = max(ans, temp) print(ans)",linear,['greedy'],472
"from sys import stdin, stdout get_string = lambda: stdin.readline().strip('\n') get_intmap = lambda: map( int, get_string().split(' ') ) def testcase(): n, M = get_intmap() a = [0] + list(get_intmap()) + [M] ontime = [0] * (n + 1) tmp = 0 for ind in range(n, -1, -1): if ind %2 == 0: tmp += a[ind + 1] - a[ind] ontime[ind] = tmp mx = ontime[0] for ind in range(n + 1): l,r = a[ind], a[ind+1] if r - l <= 1: continue for x in (l+1, r-1): newtime = ontime[0] - ontime[ind] if ind % 2 == 0: newtime += x - l else: newtime += r - x newtime += (M - r) - ontime[ind] mx = max(mx, newtime) print(mx) testcase();quit() for t in range(int(input())): testcase()",linear,['greedy'],651
"from sys import stdin, stdout nmbr = lambda: int(input()) lst = lambda: list(map(int, input().split())) for _ in range(1): n,m=lst() a=lst() a=[0]+a+[m] n=len(a) suf=[0]*n suf[n-2]=abs(a[-2]-a[-1]) for i in range(n-3, -1, -1): suf[i]=a[i+1]-a[i]+suf[i+2] ans=suf[0] cost=0 for i in range(1, n): if i&1: v=a[i]-1-a[i-1] if v!=0:ans=max(ans, cost+v+suf[i]) cost+=a[i]-a[i-1] else: v=a[i-1]+1 if v!=a[i]:ans=max(ans, cost+a[i]-v+(suf[i+1] if i+1<n else 0)) print(ans)",linear,['greedy'],464
"n, m=[int(k) for k in input().split()] w=[int(k) for k in input().split()] w=[0]+w+[m] c, d=[], [] res=0 for j in range(n+1): c.append(res) if j%2==0: res+=w[j+1]-w[j] res=0 for j in range(n+1, -1, -1): if j%2==0 and j!=n+1: res+=w[j+1]-w[j] d.append(res) d=d[::-1] mx=d[0] for j in range(n+1): mx=max(c[j]+(w[j+1]-w[j]-1)+(m-w[j+1]-d[j+1]), mx) print(mx)",linear,['greedy'],355
"a,b = map(int,input().split()) d = list(map(int,input().split())) e = [] e1= [] mx = 0 current = 0 for i in range(len(d)): if i%2 == 0: e.append(d[i]-current) else: e1.append(d[i]-current) current=d[i] if i%2 == 0: e1.append(b-current) else: e.append(b-current) mx = sum(e) su = 0 su2 = sum(e1) for i in range(len(e)): su+=e[i] mx = max(mx,su+su2-1) try: su2-=e1[i] except: break print(mx)",linear,['greedy'],389
"n, k = map(int, input().split()) l = list(map(int, input().split())) o = 2 for i in range(n): if i+1 == n: break d = abs(l[i] - l[i+1]) / k if d == 2: o += 1 elif d > 2: o += 2 print(o)",linear,['implementation'],185
"a=list(map(int,input().split())) t=a[0] d=a[1] arr=list(map(int,input().split())) count=0 for i in range(t-1): if(arr[i+1]-arr[i]==2*d): count+=1 elif(arr[i+1]-arr[i]>2*d): count+=2 print(count+2)",linear,['implementation'],196
"from sys import stdin,stdout nmbr=lambda:int(stdin.readline()) lst=lambda:list(map(int,stdin.readline().split())) for _ in range(1): n,d=lst() a=sorted(lst()) s=set() for i in range(n): x=a[i]-d left=a[i-1] if i>=1 else float('inf') if abs(x-left)>=d:s.add(x) x=a[i]+d right=a[i+1] if i+1<n else float('inf') if abs(x-right)>=d:s.add(x) print(len(s))",linear,['implementation'],350
"import math n, d = [int(x) for x in input().split(' ')] pos = [int(x) for x in input().split(' ')] count = 2 for i in range(1,n): if math.fabs(pos[i] - pos[i-1]) > 2*d: count += 2 elif math.fabs(pos[i] - pos[i-1]) == 2*d: count += 1 else: continue; print(count)",linear,['implementation'],261
"n, d = map(int, input().split()) lst = list(map(int, input().split())) lst.sort() Ans = 2 for i in range(1, n): if lst[i] - lst[i - 1] > 2 * d: Ans += 2 elif lst[i] - lst[i - 1] == 2 * d: Ans += 1 print(Ans)",linear,['implementation'],207
"import functools import time def timer(func): @functools.wraps(func) def wrapper(*args, **kwargs): stime = time.perf_counter() res = func(*args, **kwargs) elapsed = time.perf_counter() - stime print(f""{func.__name__} in {elapsed:.4f} secs"") return res return wrapper class solver: def __init__(self): n, d = map(int, input().strip().split()) x = list(map(int, input().strip().split())) ans = set() for i in range(n): for z in [-d, d]: y = x[i] + z dmin = min(abs(y - xi) for xi in x) if dmin == d: ans.add(y) print(len(ans)) solver()",linear,['implementation'],533
"import math n,d=map(int,input().split()) p=list(map(int,input().split())) q=[] for i in range(len(p)-1): q.append(abs(p[i+1]-p[i])) count=0 for k in q: if k==2*d: count+=1 elif k>=2*d: count+=2 print(count+2)",linear,['implementation'],208
"from collections import deque as de import math from collections import Counter as cnt from functools import reduce from typing import MutableMapping def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def isPowerOfTwo(n): return (math.ceil(Log2(n)) == math.floor(Log2(n))); n,d=map(int,input().split()) x=list(map(int,input().split())) ans=0 for i in range(1,n): diff=x[i]-x[i-1] if diff >= 2*d: ans+=min(2,(x[i]-d)-(x[i-1]+d)+1) ans+=2 print(ans)",linear,['implementation'],1542
"n,d=[int(x) for x in input().split("" "")] a=[int(x) for x in input().split("" "")] pos=2 for i in range(n-1): l=a[i]+d r=a[i+1]-d if l==r: pos+=1 elif l<r: pos+=2 print(pos)",linear,['implementation'],170
"from operator import itemgetter def main(): n,m=map(int,input().split( )) a=[] for _ in range(m): x,y=map(int,input().split( )) x-=1;y-=1 a.append((x,y)) a=sorted(a,key=itemgetter(0,1)) ans=[-1]*n for l,r in a: if ans[l]==-1: flag=1 for i in range(l,r+1): if flag: ans[i]=1 else: ans[i]=0 flag^=1 else: flag=1 x=ans[l] for i in range(l,r+1): if flag: ans[i]=x else: ans[i]=x^1 flag^=1 for i in range(n): if ans[i]==-1: ans[i]=0 ans=map(str,ans) print(''.join(ans)) main()",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",471
"a, b = map(int, input().split()) q, r = divmod(a, 2) print('01'*q + '0'*r)",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",74
"import sys, heapq n, m = map(int, sys.stdin.readline().split()) for _ in range(m): a, b = map(int, sys.stdin.readline().split()) ans = [0] * n for i in range(1, n, 2): ans[i] = 1 print(''.join(map(str, ans)))",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",208
"import math n,k=map(int,input().split()) for _ in range(k): l,r=map(int,input().split()) for i in range(1,n+1): if i%2==0: print('0',end='') else: print('1',end='') print()",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",172
"n,m=map(int,input().split()) l=list() r=list() for _ in range(m): a,b=map(int,input().split()) l.append(a) r.append(b) for i in range(n): if(i%2==0): print(0,end='') else: print(1,end='')",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",187
"import functools import time def timer(func): @functools.wraps(func) def wrapper(*args, **kwargs): stime = time.perf_counter() res = func(*args, **kwargs) elapsed = time.perf_counter() - stime print(f""{func.__name__} in {elapsed:.4f} secs"") return res return wrapper class solver: def __init__(self): n, m = map(int, input().strip().split()) segs = list() for i in range(m): segs.append(list(map(int, input().strip().split()))) def calc(s, segs): res = 0 for x in segs: ones = sum(s[x[0]:x[1] + 1]) res += ones * (x[1] - x[0] + 1 - ones) return res s1 = [0 for i in range(n)] s2 = [1 for i in range(n)] for i in range(n): if i % 2 == 0: s1[i] = 1 s2[i] = 0 ans = s1 if calc(s1, segs) > calc(s2, segs) else s2 print(''.join(map(str, ans))) solver()",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",747
"n,m=map(int,input().split()) arr=[] for i in range(m): arr.append(list(map(int,input().split()))) k=0;ans=str() for i in range(n): ans+=str(k^1) k=k^1 print(ans)",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",161
"n,m = map(int,input().split()) for _ in range(m): x,y = map(int,input().split()) cnt = 0 ans = [] for i in range(n): if cnt%2 == 0: ans.append(""0"") else: ans.append(""1"") cnt += 1 print("""".join(ans))",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",198
"n,m=map(int,input().split()) c=0;ans=str() for i in range(n): ans+=str(c^1) c=c^1 print(ans)",linear,"['constructive algorithms', 'greedy', 'implementation', 'math']",92
"s=input() n=len(s) l=[[0,0,0] for i in range(n)] ans=0 x=int(s[0])%3 if(x==0): ans+=1 else: l[0][x]=1 for i in range(1,n): x=int(s[i])%3 if(x==0): ans+=1 continue if(l[i-1][3-x]>0): ans+=1 l[i][3-x]=0 l[i][x]=0 else: if(l[i-1][x]!=0): l[i][1]=1 l[i][2]=1 else: l[i][x]=1 print(ans)",linear,"['dp', 'greedy', 'number theory']",281
s = input() count = 0 i = 0 while i < len(s): if int(s[i]) % 3 == 0: count += 1 i += 1 elif i < len(s)-1 and (int(s[i:i+2]) % 3 == 0 or int(s[i+1]) % 3 == 0 ): count += 1 i +=2 elif i < len(s)-2 and ( int(s[i+1:i+3]) % 3 == 0 or int(s[i:i+3]) % 3 == 0 or s[i+2] == '0') : count += 1 i += 3 else: i +=1 print(count),linear,"['dp', 'greedy', 'number theory']",314
"n=input() ans=0 r,c=0,0 for i in range(len(n)): r+=int(n[i]) c+=1 if int(n[i])%3==0 or r%3==0 or c==3: ans+=1 r,c=0,0 print(ans)",linear,"['dp', 'greedy', 'number theory']",128
"n=input() ans=0 r,c=0,0 for i in n: r+=int(i) c+=1 if int(i)%3==0 or r%3==0 or c==3: ans+=1 r,c=0,0 print(ans)",linear,"['dp', 'greedy', 'number theory']",110
s = input() n = len(s) ans = 0 c = 0 l = [] for i in range(n): a = int(s[i])%3 if a==0: ans+=1 c = 0 l = [] else: if c==0: l.append(int(s[i])) c+=1 elif c==1: if (a+l[0])%3==0: ans+=1 c = 0 l = [] else: c+=1 else: ans+=1 c=0 l = [] print(ans),linear,"['dp', 'greedy', 'number theory']",242
"import sys from math import sqrt,log2 from collections import Counter input = lambda: sys.stdin.readline().rstrip(""\r\n"") n=input() ct=0 i=0 s=[] while i <len(n): if not int(n[i])%3: ct+=1 s.clear() else: t=int(n[i])%3 if 3-t in s: ct+=1 s.clear() else: s.append(t) if len(s)==3: ct+=1 s.clear() i+=1 print(ct)",linear,"['dp', 'greedy', 'number theory']",310
"from os import path;import sys,time mod = int(1e9 + 7) from math import ceil, floor,gcd,log,log2 ,factorial,sqrt from collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations from string import ascii_lowercase ,ascii_uppercase from bisect import *;from functools import reduce;from operator import mul;maxx = float('inf') I = lambda :int(sys.stdin.buffer.readline()) lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()] S = lambda: sys.stdin.readline().strip('\n') grid = lambda r :[lint() for i in range(r)] localsys = 0 start_time = time.time() nCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r) def ceill(n,x): return (n+x -1 )//x T =0 def solve(): arr = list(map(int , S())) s , cnt , ans = 0 , 0 ,0 for i in arr: s , cnt = s + i , cnt + 1 if i % 3 ==0 or cnt % 3 ==0 or s % 3 ==0: s , cnt,ans =0 , 0 , ans + 1 print(ans) def run(): if (path.exists('input.txt')): sys.stdin=open('input.txt','r') sys.stdout=open('output.txt','w') run() T = I() if T else 1 for _ in range(T): solve() if localsys: print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")",linear,"['dp', 'greedy', 'number theory']",1154
"from os import path;import sys,time mod = int(1e9 + 7) from math import ceil, floor,gcd,log,log2 ,factorial,sqrt from collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations from string import ascii_lowercase ,ascii_uppercase from bisect import *;from functools import reduce;from operator import mul;maxx = float('inf') I = lambda :int(sys.stdin.buffer.readline()) lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()] S = lambda: sys.stdin.readline().strip('\n') grid = lambda r :[lint() for i in range(r)] localsys = 0 start_time = time.time() nCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r) def ceill(n,x): return (n+x -1 )//x T =0 def solve(): arr = list(map(int , S())) d ,s, ans = {0} , 0 , 0 for i in arr: s+=i s%=3 if s in d : ans+=1 s =0 d = {0} d.add(s) print(ans) def run(): if (path.exists('input.txt')): sys.stdin=open('input.txt','r') sys.stdout=open('output.txt','w') run() T = I() if T else 1 for _ in range(T): solve() if localsys: print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")",linear,"['dp', 'greedy', 'number theory']",1107
"from collections import defaultdict, Counter import os import sys from io import BytesIO, IOBase ii = lambda: int(input()) lmii = lambda: list(map(int, input().split())) slmii = lambda: sorted(map(int, input().split())) li = lambda: list(input()) mii = lambda: map(int, input().split()) msi = lambda: map(str, input().split()) def gcd(a, b): if b == 0: return a return gcd(b, a % b) def lcm(a, b): return (a * b) // gcd(a, b) def main(): s = li() n = len(s) cnt = 0 sm = 0 for i in range(n): s[i] = int(s[i]) % 3 i = 0 while i < n: if s[i] == 0: cnt += 1 sm = 0 i += 1 else: sm += s[i] if sm % 3 == 0: sm = 0 cnt += 1 i += 1 else: if i + 1 < n and s[i] + s[i + 1] == 3: i += 2 cnt += 1 sm = 0 else: i += 1 print(cnt) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(s",linear,"['dp', 'greedy', 'number theory']",1999
"n, m = map(int, input().split()) c = list(map(int, input().split())) a = list(map(int, input().split())) ans = 0 i = 0 for bill in a: try: i += next(ind for ind, el in enumerate(c[i:]) if el <= bill) + 1 ans += 1 except StopIteration: break print(ans)",linear,['implementation'],251
"n ,m = list(map(int, input().split())) a = list(map(int, input().split())) b = list(map(int, input().split())) ans = 0 for i in range(len(a)): if (len(b) == 0): break if (b[0] >= a[i]): ans += 1 del b[0] print(ans)",linear,['implementation'],214
"n,m=map(int,input().split()) c=list(map(int,input().split())) a=list(map(int,input().split())) j,res=0,0 for i in range(n): if j < m: if c[i] <= a[j]: j+=1 res+=1 print(res)",linear,['implementation'],173
"n,m = map(int,input().split()) arr1 = list(map(int,input().split())) arr2 = list(map(int,input().split())) j = 0 for i in range(n): if j<m and arr2[j]>=arr1[i]: j+=1 print(j)",linear,['implementation'],174
"games,bills = map(int,input().split()) g = list(map(int,input().split())) b=list(map(int,input().split())) total = 0 i=0 j=0 while(i < games and j < bills): if g[i] <= b[j]: total+=1 i+=1 j+=1 elif g[i] > b[j]: i+=1 print(total)",linear,['implementation'],228
"n, m = map(int, input().split()) k = list(map(int, input().split())) p = list(map(int, input().split())) a = 0 b = 0 ans = 0 while a != n and b != m: if p[b] >= k[a]: ans += 1 a += 1 b += 1 else: a += 1 print(ans)",linear,['implementation'],213
"import re def main(): total_games, total_notes = map(int, input().split()) games = [int(i) for i in input().split()] notes = [int(i) for i in input().split()] note = 0 for game in games: if notes[note] >= game: note += 1 if note == total_notes: break print(note) main()",linear,['implementation'],269
"n, m = map(int, input().split()) c = list(map(int, input().split())) a = list(map(int, input().split())) x = 0 for i in range(n): try: if a[0] >= c[i]: x += 1 a.pop(0) except IndexError: pass print(x)",linear,['implementation'],200
"def main(): n, m = list(map(int, input().split())) c = list(map(int, input().split())) a = list(map(int, input().split())) c_i= 0 a_i= 0 bought = 0 while c_i!= n and a_i!= m: if(a[a_i]>=c[c_i]): a_i+=1 c_i+=1 bought+=1 else: c_i+=1 print(bought) if __name__ == ""__main__"": main()",linear,['implementation'],279
"from os import path import sys,time from math import ceil, floor,gcd,log,log2 ,factorial from collections import * maxx = float('inf') I = lambda :int(sys.stdin.buffer.readline()) tup= lambda : map(int , sys.stdin.buffer.readline().split()) lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()] S = lambda: sys.stdin.readline().strip('\n') def grid(r, c): return [lint() for i in range(r)] stpr = lambda x : sys.stdout.write(f'{x}' + '\n') star = lambda x: print(' '.join(map(str, x))) localsys = 0 start_time = time.time() if (path.exists('input.txt')): sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w'); s=S() ans = s.replace('1','')+'2' t = ans.find('2') print(ans[:t]+'1'*s.count('1')+ans[t:len(ans)-1]) if localsys: print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")",linear,"['greedy', 'implementation']",813
"s = input() t = s.count('1') s = s.replace('1', '') i = s.find('2') if i == -1: print(s + '1'*t) else: print(s[:i] + '1'*t + s[i:])",linear,"['greedy', 'implementation']",131
"s = input() one = s.count('1') zero = 0 ind = -1 for i in range(len(s)): if s[i]=='2': ind=i break if s[i]=='0': zero+=1 d = """" if ind==-1: print(""0""*zero+""1""*one) exit() d = d + ""0""*zero+""1""*one for i in s[ind:]: if i!='1': d+=i print(d)",linear,"['greedy', 'implementation']",238
"fast=lambda:stdin.readline().strip() zzz=lambda:[int(i) for i in fast().split()] z,zz=input,lambda:list(map(int,z().split())) szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz()) from re import * from sys import * from math import * from heapq import * from queue import * from bisect import * from string import * from itertools import * from collections import * from math import factorial as f from bisect import bisect as bs from bisect import bisect_left as bsl from collections import Counter as cc from itertools import accumulate as ac def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2)) def output(answer):stdout.write(str(answer)) s=fast() ans=s.replace('1','')+'2' t=ans.find('2') print(ans[:t]+'1'*s.count('1')+ans[t:-1])",linear,"['greedy', 'implementation']",759
"import bisect from itertools import accumulate import os import sys import math from decimal import * from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def input(): return sys.stdin.readline().rstrip(""\r\n"") def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def SieveOfEratosthenes(n): prime=[] primes = [True for i in range(n+1)] p = 2 while (p * p <= n): if (primes[p] == True): prime.append(p) for i in range(p * p, n+1, p): primes[i] = False p += 1 return prime def factors(n): fac=[] while(n%2==0): fac.append(2) n=n//2 for i in range(3,int(math.sqrt(n))+2)",linear,"['greedy', 'implementation']",2000
"a=input() c1=a.count('1') a=a.split('2') lex='0'*a[0].count('0')+'1'*c1 n=len(a) for i in range(1,n): lex=lex+'2'+'0'*a[i].count('0') print(lex)",linear,"['greedy', 'implementation']",144
"import sys input=sys.stdin.readline inf = 1e10 mod = int(1e9 + 7) t=1; for _ in range(t): s=input() c=s.count('1') c1, i=0, 0 while(i<len(s) and s[i]!='2'): if(s[i]=='0'):c1+=1 i+=1 print('0'*c1, end="""") print('1'*c, end="""") while(i<len(s)): if(s[i]!='1'): print(s[i], end="""") i+=1",linear,"['greedy', 'implementation']",281
"import functools import time def timer(func): @functools.wraps(func) def wrapper(*args, **kwargs): stime = time.perf_counter() res = func(*args, **kwargs) elapsed = time.perf_counter() - stime print(f""{func.__name__} in {elapsed:.4f} secs"") return res return wrapper class solver: def __init__(self): pass def __call__(self): s = list(input().strip()) n = len(s) res = list() p = n - 1 ones = 0 zeros = 0 while p >= 0: if s[p] == '0': zeros += 1 elif s[p] == '1': ones += 1 elif s[p] == '2': res.extend(['0'] * zeros) res.append('2') zeros = 0 p -= 1 res.extend(['1'] * ones) res.extend(['0'] * zeros) res.reverse() print(''.join(map(str, res))) solver()()",linear,"['greedy', 'implementation']",656
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest INF=99999999999999999999999999999999 def outIn(x): print(x, flush=True) return input() def main(): mod=1000000007 starttime=datetime.datetime.now() if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") sys.stdout = open(""output.txt"",""w"") tc = 1 for _ in range(tc): s=rs() d=Counter(s) if '1' in d: news="""" for i in s: if i!='1': news+=i ans="""" ind=len(news) for i in range(len(news)): if news[i]=='2': ind=i break ans=news[0:ind]+'1'*d['1']+news[ind:] ws(ans) else: ws(s) endtime=datetime.datetime.now() time=(endtime-starttime).total_seconds()*1000 if(os.path.exists('input.txt')): print(""Time:"",time,""ms"") class FastReader(io.IOBase): newlines = 0 def __init__(self, fd, chunk_size=1024 * 8): self._fd = fd self._chunk_size = chunk_size self.buffer = io.BytesIO() def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self, size=-1): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline()",linear,"['greedy', 'implementation']",2000
"import functools import time def timer(func): @functools.wraps(func) def wrapper(*args, **kwargs): stime = time.perf_counter() res = func(*args, **kwargs) elapsed = time.perf_counter() - stime print(f""{func.__name__} in {elapsed:.4f} secs"") return res return wrapper class solver: def __init__(self): pass def __call__(self): n, m = map(int, input().strip().split()) y = 0 for _ in range(m): x, d = map(int, input().strip().split()) if d >= 0: y += d * (n - 1) * n // 2 else: if n % 2 != 0: l = (n - 1) // 2 y += d * l * (l + 1) else: l = n // 2 y += d * (l * (l + 1) - l) y += x * n y /= n print(f'{y:.9f}') solver()()",linear,"['greedy', 'math']",619
"import sys import io, os input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline n, m = map(int, input().split()) MAX = 0 MIN = 10**18 for i in range(n): l = i*(i+1)//2 r = (n-1-i)*(n-1-i+1)//2 MAX= max(MAX, l+r) MIN = min(MIN, l+r) ans = 0 for i in range(m): x, d = map(int, input().split()) ans += n*x if d >= 0: ans += d*MAX else: ans += d*MIN print(ans/n)",linear,"['greedy', 'math']",363
"from sys import stdin,stdout from math import gcd,sqrt,factorial,pi,inf from collections import deque,defaultdict from bisect import bisect,bisect_left from time import time from itertools import permutations as per from heapq import heapify,heappush,heappop,heappushpop input=stdin.readline R=lambda:map(int,input().split()) I=lambda:int(input()) S=lambda:input().rstrip('\r\n') L=lambda:list(R()) P=lambda x:stdout.write(str(x)+'\n') lcm=lambda x,y:(x*y)//gcd(x,y) nCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N inv=lambda x:pow(x,N-2,N) sm=lambda x:(x**2+x)//2 N=10**9+7 n,k=R() s=0 for i in range(k): x,d=R() s+=n*x if d<0: s+=sm(n//2)*d+sm(n//2-(n+1)%2)*d else: s+=sm(n-1)*d print(s/n)",linear,"['greedy', 'math']",688
"n,m=map(int,input().split()) arr=[] for i in range(m): arr.append(list(map(int,input().split()))) count=0 for i in range(m): count +=arr[i][0] *(n) if n %2==1 and arr[i][1] <0: count +=(n//2)*(n//2 +1)*arr[i][1] if n %2==1 and arr[i][1] >0: count +=(n) *(n-1) *arr[i][1]//2 if n %2==0 and arr[i][1] <0: count +=(n//2)*(n//2 -1)*arr[i][1] count +=(n//2) *arr[i][1] if n %2==0 and arr[i][1] >0: count +=(n) *(n-1) *arr[i][1] //2 print(count /n)",linear,"['greedy', 'math']",442
"import sys p2D = lambda x: print(*x, sep=""\n"") def II(): return int(sys.stdin.buffer.readline()) def MI(): return map(int, sys.stdin.buffer.readline().split()) def LI(): return list(map(int, sys.stdin.buffer.readline().split())) def LLI(rows_number): return [LI() for _ in range(rows_number)] def BI(): return sys.stdin.buffer.readline().rstrip() def SI(): return sys.stdin.buffer.readline().rstrip().decode() def li(): return [int(i) for i in input().split()] def lli(rows): return [li() for _ in range(rows)] def si(): return input() def ii(): return int(input()) def ins(): return input().split() n,m=MI() posf=(n*(n-1))//2 if(n%2!=0): negf=(n//2)*(n//2+1) else: negf=(n//2)*(n//2-1)+n//2 ans=0 for i in range(m): x,d=MI() ans+=n*x if(d>=0): ans+=posf*d else: ans+=negf*d print(ans/n)",linear,"['greedy', 'math']",787
"n, m = map(int, input().split()) res = 0 mx = (n-1)*n//2 mn = 0 if n&1: mn = (n//2)*(n//2+1) else: mn = n*n//4 for i in range(m): x, d = map(int, input().split()) res += x*n if d > 0: res += mx*d else: res += mn*d print('%.10f'%(res/n))",linear,"['greedy', 'math']",236
"n, m = map(int, input().split()) a = (n * (n - 1)) // 2 n2 = n // 2 b = n2 * (n2 + 1) if n % 2 == 0: b -= n2 s = 0 for i in range(m): x, d = map(int, input().split()) s += x * n s += d * (a if d > 0 else b) print(s / n)",linear,"['greedy', 'math']",219
"import time from copy import deepcopy import itertools from bisect import bisect_left from bisect import bisect_right import math from collections import deque from collections import Counter def read(): return int(input()) def readmap(): return map(int, input().split()) def readlist(): return list(map(int, input().split())) n, m = readmap() X = [] D = [] for _ in range(m): x, d = readmap() X.append(x) D.append(d) summ = n * sum(X) for i in range(m): d = D[i] if d < 0: if n % 2 == 1: summ += d * (n // 2) * (n // 2 + 1) else: summ += d * (n // 2) * (n // 2) else: summ += d * (n - 1) * n // 2 print(summ / n)",linear,"['greedy', 'math']",613
"n, m = map(int,input().split()) max_dist = (n - 1)* n//2 min_dist = max_dist curr_value = max_dist for i in range(n): curr_value = i * (i + 1) // 2 + (n - 1 - i)*(n - i)//2 min_dist = min(min_dist, curr_value) answer = 0 add_value = 0 for i in range(m): x, d = map(int, input().split()) answer+=x if d >= 0: add_value += d*max_dist else: add_value += d * min_dist print(answer + (add_value / n))",linear,"['greedy', 'math']",395
"import os import sys from collections import * from bisect import * from io import BytesIO, IOBase def vsInput(): sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") ALPHA='abcdefghijklmnopqrstuvwxyz' M=998244353 EPS=1e-6 def Ceil(a,b): return a//b+int(a%b>0) def value():return tuple(map(int,input().split())) def array():return [int(i) for i in input().split()] def Int():return int(input()) def Str():return input() def arrayS():return [i for i in input().split()] n=Int() a=array() series = [1] fact = 1 for i in range(n+1): series.append(((series[-1]*2)%M + fact)%M) fact = (fact*2)%M ind = n-1 ans=0 for i in range(n): ans = (an",linear,"['combinatorics', 'math', 'probabilities']",1999
"from sys import stdin, stdout def main(): p = 998244353 n = int(stdin.readline()) a = list(readline()) answer = a[-1] pow_ = 1 for i in range(n - 1, 0, -1): answer = (answer + a[i - 1] * (2 + n - i) * pow_ % p) % p pow_ = pow_ * 2 % p return answer def readline(): return map(int, stdin.readline().strip().split()) if __name__ == '__main__': stdout.write(str(main()) + '\n')",linear,"['combinatorics', 'math', 'probabilities']",374
"def some_random_function(): x = 10 x *= 100 i_dont_know = x why_am_i_writing_this = x*x print(i_dont_know) print(why_am_i_writing_this) def some_random_function5(): x = 10 x *= 100 i_dont_know = x why_am_i_writing_this = x*x print(i_dont_know) print(why_am_i_writing_this) import os,sys from io import BytesIO,IOBase def main(): mod = 998244353 powe = [1] for _ in range(10**6): powe.append((powe[-1]*2)%mod) n = int(input()) a = list(map(int,input().split())) ans,dp,dp1 = (a[0]*powe[n-1])%mod,a[0],0 for i in range(1,n): if i == 1: dp = (dp+a[i])%mod else: dp = (dp*2+a[i]-dp1)%mod ans = (ans+powe[n-i-1]*dp)%mod dp1 = a[i] print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def some_random_f",linear,"['combinatorics', 'math', 'probabilities']",1999
"import functools import time def timer(func): @functools.wraps(func) def wrapper(*args, **kwargs): stime = time.perf_counter() res = func(*args, **kwargs) elapsed = time.perf_counter() - stime print(f""{func.__name__} in {elapsed:.4f} secs"") return res return wrapper class solver: def __init__(self): pass def __call__(self): MOD = 998244353 N = 1000007 pow2 = [0] * N n = int(input()) a = list(map(int, input().strip().split())) pow2[0] = 1 for i in range(n): pow2[i + 1] = (2 * pow2[i]) % MOD res = 0 for i in range(1, n): tmp = (a[i - 1] * (n + 2 - i)) % MOD res += (pow2[n - 1 - i] * tmp) % MOD res %= MOD res += a[n - 1] res %= MOD print(res) solver()()",linear,"['combinatorics', 'math', 'probabilities']",658
"import os import sys import math from io import BytesIO, IOBase import io from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=0, func=lambda a, b: a+b): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = sel",linear,"['combinatorics', 'math', 'probabilities']",1999
"M = 0x3b800001 wa = 0; n = int(input()) a = list(map(int, input().split())) now = 1 wa += a[-1] for i in range(n - 1)[::-1]: wa += (now * (n - i - 1) + now * 2) * a[i] wa %= M now *= 2 now %= M print(wa % M)",linear,"['combinatorics', 'math', 'probabilities']",207
"MOD = 998244353 def main(): n = int(input()) a = [int(x) for x in input().split(' ')] p, sp, s, ss = 0, 0, 0, 0 for x in a: ss = (2 * ss + s) % MOD s = (s + x) % MOD p = (ss + sp + s) % MOD sp = (sp + p) % MOD print(p) if __name__ == '__main__': main()",linear,"['combinatorics', 'math', 'probabilities']",252
"n = int(input()) ans = 0 mod = 998244353 a = list(map(int, input().split())) p = 1 / 2 for i in range(n): ans = (ans + (i + 2) * (p * a[n - i - 1] % mod) % mod) % mod p = (2 * p) % mod print(int(ans) % mod)",linear,"['combinatorics', 'math', 'probabilities']",206
"n = int(input()) a = list(map(int, input().split())) s = a[0] % 998244353 y = a[0] for x in a[1:]: s = s * 2 + y + x y = y * 2 + x s %= 998244353 y %= 998244353 print(s)",linear,"['combinatorics', 'math', 'probabilities']",169
"n=int(input()) m=int(input()) a=list(map(int, input().split())) b=list(map(int, input().split())) curr=m f=0 if b[0]!=1: curr+=(curr)/(b[0]-1) else: f=1 for i in range(n-1,-1,-1): if a[i]!=1: curr+=(curr)/(a[i]-1) else: f=1 if i>0: if b[i]!=1: curr+=(curr)/(b[i]-1) else: f=1 if f: print(-1) else: print(curr-m)",linear,"['binary search', 'math']",311
"from sys import stdin import collections import copy import math n = int(stdin.readline()) m = int(stdin.readline()) up = list(map(int, stdin.readline().split())) down = list(map(int, stdin.readline().split())) def check(x): weight = m + x fuel = x for i in range(n): f = weight/up[i] if fuel<f: return False else: weight -= f fuel -= f f = weight/down[i] if fuel<f: return False else: weight -= f fuel -= f return True l = 0 r = 1e9 + 1e-6 for ii in range(100): mid = (r + l)/2 if(check(mid)): r = mid else: l = mid if r-l <= 1e-10: break if l >= 1e9+ 1e-6: print(-1) else: print(""%.10f"" %l)",linear,"['binary search', 'math']",592
"from sys import stdin EPS = 1e-6 n = int(stdin.readline()) m = int(stdin.readline()) a = list(map(int, stdin.readline().split())) b = list(map(int, stdin.readline().split())) b.append(b[0]) def check(f): fuel_left = f total_weight = float(m + fuel_left) for i in range(n): cost = total_weight / a[i] fuel_left = fuel_left - cost total_weight = total_weight - cost cost = total_weight / b[i + 1] fuel_left = fuel_left - cost total_weight = total_weight - cost if fuel_left < 0: return False return True def binary_search(left, right): mid = (left + right) / 2 if abs(left - right) < EPS: return mid if check(mid): return binary_search(left, mid) else: return binary_search(mid, right) res = binary_search(0, 1e9 + 1) if res - 1e9 > EPS: print(-1) else: print(""%.10f"" % res)",linear,"['binary search', 'math']",772
"from sys import stdin EPS = 1e-6 n = int(stdin.readline()) m = int(stdin.readline()) a = list(map(int, stdin.readline().split())) b = list(map(int, stdin.readline().split())) b.append(b[0]) def check(f): fuel_left = f total_weight = float(m + fuel_left) for i in range(n): cost = total_weight / a[i] fuel_left = fuel_left - cost total_weight = total_weight - cost cost = total_weight / b[i + 1] fuel_left = fuel_left - cost total_weight = total_weight - cost if fuel_left < 0: return False return True def binary_search(left, right): mid = (left + right) / 2 if abs(left - right) < EPS: return mid if check(mid): return binary_search(left, mid) else: return binary_search(mid, right) res = binary_search(0, 1e9 + 1) if res - 1e9 > EPS: print(-1) else: print(""%.10f"" % res)",linear,"['binary search', 'math']",772
"import sys import math import heapq import bisect from collections import Counter from collections import defaultdict from io import BytesIO, IOBase import string class FastIO(IOBase): newlines = 0 def __init__(self, file): import os self.os = os self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None self.BUFSIZE = 8192 def read(self): while True: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: self.os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def get_int(): return int(input()) def get_ints(): return list(map(int, input().split(' '))) def get_int_grid(n): return [get_ints() for _ in range(n)] def get_str(): return input().split(' ') def yes_no(b): if b: return ""YES"" else: return ""NO"" def prefix_sums(a): p = [0] for x in a: p.append(p[-1] + x) return p def binary_search(good, left, right, delta=1, right_true=False): limits = [left, right] while limits[1] - limits[0]",linear,"['binary search', 'math']",2000
"i=input i() m=int(i()) v=m try: for a in map(int, (i()+' '+i()).split()):v*=a/(a-1) except:v=m-1 print(v-m)",linear,"['binary search', 'math']",107
"from math import ceil def test(f): for i in range(n): if (r1+ f) > f * lift[i]: return 0 f -= (r1 + f) / lift[i] if (r1+ f) > f * land[i + 1]: return 0 f -= (r1 + f) / land[i + 1] return 1 p=int(input()) total_wgt=int(input());r1=total_wgt lift=list(map(int,input().split())) land=list(map(int,input().split()));n=len(land);ans=1e20 lift+=[lift[0]];land+=[land[0]] l=0.0;r=1e20 for i in range(1000): mid=(l+r)/2.0 if test(mid):r=mid else:l=mid if r<1e19: print('%.17f' %r) else: print(-1)",linear,"['binary search', 'math']",488
n = int(input()) m = int(input()) a = [int(i) for i in input().split()] b = [int(i) for i in input().split()] low = 1 high = 1000000000 ans = -1 while low<=high: if high-low < 0.000001: low = high mid = low+(high-low)/2 try_val = mid init_wt = m+try_val isPossible = True for i in range(n): req1 = init_wt/a[i] try_val -= req1 if try_val<=0: isPossible = False break j=(i+1)%n init_wt -= req1 req2 = init_wt/b[j] try_val -= req2 if try_val<0 or (i<n-1 and try_val==0): isPossible = False break init_wt -= req2 if isPossible: ans = mid high = mid-0.000001 else: low = mid+0.000001 if (ans==-1): isPossible = True try_val = 1000000000.000001 init_wt = m+try_val for i in range(n): req1 = init_wt/(a[i]) try_val -= req1 if try_val<=0: isPossible = False break j=(i+1)%n init_wt -= req1 req2 = init_wt/(b[j]) try_val -= req2 if try_val<0 or (i<n-1 and try_val==0): isPossible = False break init_wt -= req2 if isPossible: ans = 1000000000 print(ans),linear,"['binary search', 'math']",944
"import sys readline = sys.stdin.readline N = int(readline()) M = float(readline()) A = list(map(int, readline().split())) B = list(map(int, readline().split())) B = B[1:] + [B[0]] C = [] for a, b in zip(A[::-1], B[::-1]): C.append(b) C.append(a) if 1 in C: print(-1) else: M0 = M for c in C: M += M/(c-1) print(M-M0)",linear,"['binary search', 'math']",316
"n,k = map(int,input().split()) def tonny(i) : return (ord(i)-96) a= sorted(input()) a=list(map(tonny,a)) a=sorted(list(set(a))) ans=[a.pop(0)] k-=1 for j in a : if j-ans[-1] >1 and k>0 : k-=1 ans.append(j) if k==0 : break if k!=0 : print(-1) else: print(sum(ans))",linear,"['greedy', 'implementation', 'sortings']",263
"import sys input = sys.stdin.readline def inlt(): return(list(map(int,input().split()))) def insr(): s = input() return(list(s[:len(s) - 1])) def cint(c): return ord(c) - 96 def find_min_weight(n, k, stages): n = len(stages) min_weight = float('inf') def backtrack(s, w, t): nonlocal min_weight if t >= k: min_weight = min(min_weight, w) return if s >= n - 1: return for i in range(s+1, n, 1): if stages[i] - stages[s] > 1: backtrack(i, w+stages[i], t+1) backtrack(0, stages[0], 1) if min_weight == float('inf'): return -1 return min_weight n, k = inlt() stages = list(set(map(cint, insr()))) stages.sort() print(find_min_weight(n, k, stages))",linear,"['greedy', 'implementation', 'sortings']",643
"a, b = map(int, input().split()) c = input() sorted(c) summa = 0 count = 0 j = -2 i = 0 abc = ""abcdefghijklmnopqrstuvwxyz"" while i < 26 and count < b: if abc[i] in c and i-2 >= j: summa += i+1 count += 1 j = i i += 1 if count < b: print(-1) else: print(summa)",linear,"['greedy', 'implementation', 'sortings']",259
"a, b = map(int, input().split()) c = input() su = 0 cnt = 0 j = -2 i = 0 lis = ""abcdefghijklmnopqrstuvwxyz"" while i < 26 and cnt < b: if lis[i] in c and i-2 >= j: su += i+1 cnt += 1 j = i i += 1 if cnt < b: print(-1) else: print(su)",linear,"['greedy', 'implementation', 'sortings']",232
"a, b = map(int, input().split()) c = input() su = 0 cnt = 0 j = -2 i = 0 lis = ""abcdefghijklmnopqrstuvwxyz"" while i < 26 and cnt < b: if lis[i] in c and i-2 >= j: su += i+1 cnt += 1 j = i i += 1 if cnt < b: print(-1) else: print(su)",linear,"['greedy', 'implementation', 'sortings']",232
"from collections import deque as de import math from collections import Counter as cnt from functools import reduce from typing import MutableMapping def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def isPowerOfTwo(n): return (math.ceil(Log2(n)) == math.floor(Log2(n))); n,k=map(int, input().split()) kk=list(map(str, input())) s=sorted(list(set(kk))) if k > 13: print(-1) else: dic={} for index, value in enumerate(""abcdefghijklmnopqrstuvwxyz""): dic[value]= index+1 ans=0 ans+=dic[s[0]] k-=1 curr=s[0] for i in range(1,len(s)): if k: if dic[s[i]]>dic[curr]+1: ans+=dic[s[i]] curr=s[i] k-=1 if k==0: break if k==0: print(ans) else: print(-1)",linear,"['greedy', 'implementation', 'sortings']",1739
"n,k = map(int, input().split()) s = input() l = [] for i in s: a = ord(i)-96 if a not in l: l.append(a) l.sort() c = l[0] a = 1 b = l[0] for i in range(1,len(l)): if a==k: break if (l[i]-b)>1: a += 1 c += l[i] b = l[i] if a<k: print(-1) else: print(c)",linear,"['greedy', 'implementation', 'sortings']",251
"n, k = map(int, input().split()) s = input() a = [0] * 26 for i in s: a[ord(i) - ord('a')] = 1 ans = 0 i = 0 while i < 26: if a[i] > 0: ans += i + 1 k -= 1 i += 1 if k == 0: print(ans) break i += 1 else: print(-1)",linear,"['greedy', 'implementation', 'sortings']",213
"n,k=map(int,input().split()) l=input() l=sorted(l) ans=l[0] sum=ord(l[0]) index=0 for j in range(1,n): if len(ans)<k: if ord(l[j])-ord(l[index])>1: ans=ans+l[j] sum=sum+ord(l[j]) index=j else: break if len(ans)==k: sum=sum-96*k print(sum) else: print(-1)",linear,"['greedy', 'implementation', 'sortings']",254
"n,x = list(map(int, input().split())) a = set(map(int, input().split())) if len(a) < n : print(0) else : d = set() p = 0 for i in a : d.add(i&x) if i&x != i and i&x in a : print(1) p = 1 break if len(d) < n and p == 0 : print(2) elif p != 1 : print(-1)",linear,['greedy'],252
"n,x=list(map(int,input().split())) b=list(map(int,input().split())) d={} flag=0 for i in b: if d.get(i): flag=1 break else: d[i]=1 if flag: print(0) else: flag=0 c=set() for i in b: a=i&x c.add(a) if d.get(a) and a!=i: flag=1 break if flag: print(1) elif len(c)<n and flag==0: print(2) else: print(-1)",linear,['greedy'],301
"import sys, heapq n, x = map(int, sys.stdin.readline().split()) arr = list(map(int, sys.stdin.readline().split())) res = dict().fromkeys(set(arr), 0) for i in arr: res[i] += 1 can = False for i in res: if res[i] >= 2: can = True break if can: print(0) else: res = dict().fromkeys([i for i in range(max(arr) + 1)]) for i in res: res[i] = [] for i in range(n): temp = set() now = arr[i] cnt = 0 while True: added = False before = len(temp) temp.add(now) after = len(temp) if before == after: break heapq.heappush(res[now], cnt) now = now & x cnt += 1 ans = 9876543210 for i in res: if len(res[i]) >= 2: ans = min(ans, heapq.heappop(res[i]) + heapq.heappop(res[i])) print(ans if ans != 9876543210 else -1)",linear,['greedy'],702
"from sys import stdin,stdout from itertools import accumulate nmbr=lambda:int(stdin.readline()) lst=lambda:list(map(int,stdin.readline().split())) for _ in range(1): n,x=lst() a=lst() ans=0 s=set(a) if len(s) != n: print(0) continue for i in range(n): v=a[i] a[i]&=x if a[i] in s and v!=a[i]: ans=1 break if ans==1:print(1) elif len(set(a))==n:print(-1) else:print(2)",linear,['greedy'],367
"n,x = list(map(int, input().split())) arr = list(map(int, input().split())) f = [0]*100100 s = [0]*100100 can = [False]*100100 for i in range(n): f[arr[i]]+=1 s[arr[i]&x]+=1 if (arr[i]&x != arr[i]): can[arr[i]&x] = True ans = 3 for i in range(len(f)): if f[i] >= 2: ans = 0 break if f[i] == 1 and s[i] >= 1: if can[i]: ans = min(ans,1) if s[i] >= 2: ans = min(ans,2) if ans == 3: print(-1) else: print(ans)",linear,['greedy'],406
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest def main(): starttime=datetime.datetime.now() if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") sys.stdout = open(""output.txt"",""w"") tc = 1 for _ in range(tc): n,x=ria() a=ria() d=Counter(a) sa=set(a) if len(sa)<n: print(0) else: c=0 for i in a: k=i&x if k!=i and k in d: c=1 print(1) break if c==0: z=[] for i in a: z.append(i&x) if len(set(z))<n: print(2) else: print(""-1"") endtime=datetime.datetime.now() time=(endtime-starttime).total_seconds()*1000 if(os.path.exists('input.txt')): print(""Time:"",time,""ms"") class FastReader(io.IOBase): newlines = 0 def __init__(self, fd, chunk_size=1024 * 8): self._fd = fd self._chunk_size = chunk_size self.buffer = io.BytesIO() def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self, size=-1): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() class FastWriter(io.IOBase): def __init__(self, fd): self._fd = fd self.buffer = io.BytesIO(",linear,['greedy'],2000
"n, x = [int(i) for i in input().split()] a = [int(i) for i in input().split()] s = set(a) mv = 999 if len(s) < n: print(0) else: for i in a: if i & x != i and i & x in s: print(1) break else: k = [i & x for i in a] if len(set(k)) < n: print(2) else: print(-1)",linear,['greedy'],259
"import sys,math a,b=map(int,input().split()) l=list(map(int,input().split())) t=[[-1,0] for i in range(100001)] for i in range(a): if t[l[i]][0]!=-1:print(0);sys.exit() t[l[i]][0]=3 s=math.inf for i in range(a): if t[l[i]&b][0]!=-1: if l[i]&b!=l[i] and t[l[i]&b][0]!=1: t[l[i]&b]=[1,min(2,t[l[i]&b][1]+1)] else:t[l[i]&b]=[2,1] for i in range(a): if t[l[i]&b][1]!=0 and t[l[i]&b][0]==1:s=min(s,t[l[i]&b][1]) if s==math.inf: print(-1) else: print(s)",linear,['greedy'],447
"n,x = list(map(int, input().split())) a = set(map(int, input().split())) if len(a) < n : print(0) else : d = set() p = 0 for i in a : d.add(i&x) if i&x != i and i&x in a : print(1) p = 1 break if len(d) < n and p == 0 : print(2) elif p != 1 : print(-1)",linear,['greedy'],252
n=int(input()) a=[] for i in range(n): l=[int(i) for i in input().split()] if i==0: t=sum(l) a.append(sum(l)) a.sort(reverse=True) print(a.index(t)+1),linear,['implementation'],150
"test=int(input()) first=[] for i in range(test): list_=list(map(int,input().split())) sum_=sum(list_) first.append(sum_) first_sum=first[0] count=0 for i in first: if first_sum<i: count=count+1 else: continue print(count+1)",linear,['implementation'],223
"n=int(input()) S=[] for i in range(n): A=[int(i) for i in input().split()] S.append(sum(A)) if S[0]==max(S): print(""1"") exit() thomas=S[0] rank=1 S.sort(reverse=True) for i in S: if i == thomas: print(rank) exit() else: rank+=1",linear,['implementation'],227
"n = int(input()) r = 1 t = sum(map(int, input().split())) for i in range(n - 1): if sum(map(int, input().split())) > t: r += 1 print(r)",linear,['implementation'],135
"rank = 1 n = int(input()) score = sum(map(int,input().split())) for i in range(n-1): student = sum(map(int,input().split())) if(student > score): rank += 1 print(rank)",linear,['implementation'],167
"n = int(input()) r = [] for _ in range(n): a,b,c,d = map(int,input().split()) r.append(sum([a,b,c,d])) thomas = r[0] print(sorted(r, reverse=True).index(thomas)+1)",linear,['implementation'],163
"n = int(input()) l = [] for i in range(n): c = list(map(int, input().split())) l.append(sum(c)) m = l[0] l.sort(reverse=True) for i in range(len(l)): if m == l[i]: print(i+1) break",linear,['implementation'],180
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest def main(): starttime=datetime.datetime.now() if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") sys.stdout = open(""output.txt"",""w"") tc=1 for _ in range(tc): n=ri() ans=[] i=1 k=1 t=0 while True: k=i*i if k<=n: t=i else: break i+=1 a=[] z=[] for i in range(n): z+=[i+1] if len(z)==t: a=z+a z=[] a=z+a wia(a) endtime=datetime.datetime.now() time=(endtime-starttime).total_seconds()*1000 if(os.path.exists('input.txt')): print(""Time:"",time,""ms"") class FastReader(io.IOBase): newlines = 0 def __init__(self, fd, chunk_size=1024 * 8): self._fd = fd self._chunk_size = chunk_size self.buffer = io.BytesIO() def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self, size=-1): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() class FastWriter(io.IOBase): def __init__(self, fd): self._fd = fd self.buffer = io.BytesIO() self.write = self.buffer.write def flush(self): os.write(self._fd,",linear,"['constructive algorithms', 'greedy']",2000
"n = int(input()) m = int(n**.5) a = [] for i in range(0, n, m): for j in range(i, min(i+m, n)): a.append(min(i+m, n)-j + i) print(' '.join(str(_) for _ in a))",linear,"['constructive algorithms', 'greedy']",158
"n = int(input()) m = int(n**.5) a = [] for i in range(0, n, m): for j in range(i, min(i+m, n)): a.append(min(i+m, n)-j + i) print(' '.join(str(_) for _ in a))",linear,"['constructive algorithms', 'greedy']",158
"import math n = int(input()) A = [i + 1 for i in range(n)] x = int(math.sqrt(n)) X = [A[i:i + x] for i in range(0, len(A), x)] X = X[::-1] f = [item for sublist in X for item in sublist] print(*f)",linear,"['constructive algorithms', 'greedy']",196
"import math def getx(n): return math.floor(math.sqrt(n)) def getans(n,x): l1=[i for i in range(n,0,-1)] l2=[] i=0 while(i<n): l2=l2+sorted(l1[i:i+x]) i+=x return l2 n=int(input()) a=getx(n) ans=getans(n,a) ans1=[str(i) for i in ans] print(' '.join(ans1))",linear,"['constructive algorithms', 'greedy']",254
"import functools import time from collections import Counter def timer(func): @functools.wraps(func) def wrapper(*args, **kwargs): stime = time.perf_counter() res = func(*args, **kwargs) elapsed = time.perf_counter() - stime print(f""{func.__name__} in {elapsed:.4f} secs"") return res return wrapper class solver: def __init__(self): pass def __call__(self): n = int(input()) minv = n + 1 mini = n for l in range(1, n + 1): v = l + (n + l - 1) // l if v < minv: minv = v mini = l ref = [i + 1 for i in range(n)] l = mini res = list() p = n - 1 while p >= 0: pp = max(0, p - l + 1) res.extend(ref[pp:p + 1]) p = pp - 1 print(' '.join(map(str, res))) solver()()",linear,"['constructive algorithms', 'greedy']",658
"ceil1 = lambda a, b: (a + b - 1) // b n = int(input()) sq = int(n ** .5) sq2, ans, cur = ceil1(n, sq), [], 0 for i in range(sq2 - 1): cur += sq ans.extend([x for x in range(cur, cur - sq, -1)]) ans.extend([x for x in range(n, cur, -1)]) print(' '.join(map(str, ans)))",linear,"['constructive algorithms', 'greedy']",267
"def inp1(): return int(input()) def inp2(): return list(map(int,input().split())) def inp3(): return map(int,input().split()) if 1: n=inp1() x=int(n**0.5) i=0 y=n ans=[] while(i<n): arr=[] for j in range(x): if y==0: break arr.append(y) y-=1 i+=1 if y==0: break arr=arr[::-1] for j in arr: ans.append(j) print(*ans)",linear,"['constructive algorithms', 'greedy']",315
"n=int(input()) ans=[] m=int(n**0.5) x=n while x-m>0: for i in range(1,m+1): ans.append(x-m+i) x-=m for i in range(1,x+1): ans.append(i) print(*ans)",linear,"['constructive algorithms', 'greedy']",147
"import sys, string n, m = map(int, sys.stdin.readline().split()) s = list(sys.stdin.readline().rstrip()) t = list(sys.stdin.readline().rstrip()) idx = -1 for i in range(n): if s[i] == '*': idx = i if idx == -1: if s == t: print('YES') else: print('NO') else: if m < n - 1: print('NO') else: s_left = s[0 : idx] s_right = s[idx + 1 : n] a = len(s_left) b = len(s_right) t_left = [] t_right = [] for i in range(a): t_left.append(t[i]) t[i] = '' for i in range(b): t_right.append(t[m - i - 1]) if s_left == t_left and s_right == t_right[::-1]: print('YES') else: print('NO')",linear,"['brute force', 'implementation', 'strings']",571
"n, m = map(int, input().split()) a = input() b = input() flag = 0 for c in a: if(c == '*'): flag = 1 if(flag == 1): a1, a2 = a.split('*') Len1 = len(a1) Len2 = len(a2) b1 = b[:Len1] b2 = '' if(Len2): b2 = b[-Len2:] if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)): print('YES') else: print('NO') else: if(a == b): print('YES') else: print('NO')",linear,"['brute force', 'implementation', 'strings']",347
"import math n,m = map(int, input().strip().split(' ')) s=input() t=input() if '*' not in s: if s==t: print('YES') else: print('NO') elif n>m+1: print('NO') elif n==1 and s=='*': print('YES') else: s=list(s) t=list(t) if s[0]=='*': if s[1:]==t[-(len(s[1:])):]: print('YES') else: print('NO') elif s[-1]=='*': if s[:n-1]==t[:n-1]: print('YES') else: print('NO') else: ind=s.index('*') if s[:ind]==t[:ind] and s[ind+1:]==t[-len(s[ind+1:]):]: print('YES') else: print('NO')",linear,"['brute force', 'implementation', 'strings']",469
"n, m = map(int, input().split()) a = input() b = input() flag = 0 for c in a: if(c == '*'): flag = 1 if(flag == 1): a1, a2 = a.split('*') Len1 = len(a1) Len2 = len(a2) b1 = b[:Len1] b2 = '' if(Len2): b2 = b[-Len2:] if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)): print('YES') else: print('NO') else: if(a == b): print('YES') else: print('NO')",linear,"['brute force', 'implementation', 'strings']",347
"n,m = map(int, input().split()) a= input() b = input() if '*' in a: c = a.replace('*','') i = a.index('*') if c==b: print(""YES"") elif a[:i]==b[:i]: t = a[i+1:] tt = b[m - n+1+i:] if t ==tt and n-1<=m: print(""YES"") else: print(""NO"") else: print(""NO"") elif n>m: print(""NO"") else: if a==b: print(""YES"") else: print(""NO"")",linear,"['brute force', 'implementation', 'strings']",317
"n, m = map(int, input().split()) s = input() t = input() if ""*"" in s: front, back = s.split(""*"") if len(t) >= len(s) - 1 and t.startswith(front) and t.endswith(back): print(""YES"") else: print(""NO"") else: print(""YES"" if s == t else ""NO"")",linear,"['brute force', 'implementation', 'strings']",236
"import sys,os,io from sys import stdin from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop from bisect import bisect_left , bisect_right import math alphabets = list('abcdefghijklmnopqrstuvwxyz') def isPrime(x): for i in range(2,x): if i*i>x: break if (x%i==0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def SieveOfEratosthenes(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def countdig(n): c = 0 while (n > 0): n //= 10 c += 1 return c def si(): return input() def prefix_sum(arr): r = [0] * (len(arr)+1) for i, el in enumerate(arr): r[i+1] = r[i] + el return r def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') def power_set(L): cardinality=len(L) n=2 ** cardinality powerset = [] for i in range(n): a=bin(i)[2:] subset=[] for j in range(len(a)): if a[-j-1]=='1': subset.append(L[j]) powerset.append(subset) powerset_orderred=[] for k in range(cardinality+1): for w in powerset: if len(w)==k: powerset_orderred.append(w) return powerset_orderred def fastPlrintNextLines(a): print('\n'.join(map(str,a))) def sortByFirstAndSecond(A): A = sorted(A,key = lambda x:x[0]) A = sorted(A,key = lambda x:x[1]) return l",linear,"['brute force', 'implementation', 'strings']",1999
"n,m=map(int,input().split()) s=input() t=input() if n-1>m: print('NO') else: try: a=s.index('*') except: a=-1 if a==-1: if s==t: print('YES') else: print('NO') else: f=True for i in range(a): if s[i]!=t[i]: print('NO') exit() i=1 while m-i>=a and n-i>a: if s[n-i]!=t[m-i]: print('NO') exit() i+=1 print('YES')",linear,"['brute force', 'implementation', 'strings']",309
"n,m=map(int,input().split()) s=input() t=input() if n==1: if s==t or s=='*': print('YES') else: print('NO') elif s.count('*')==0: if s==t: print('YES') else: print('NO') elif n>m+1: print('NO') else: l=s.split('*') x=t[:len(l[0])] y=t[-len(l[1]):] if (l[0]==x and l[1]==y) or (s[:1]=='*' and l[1]==y) or (l[0]==x and s[-1:]=='*'): print('YES') else: print('NO')",linear,"['brute force', 'implementation', 'strings']",361
"import sys, string n, k = map(int, sys.stdin.readline().split()) arr = list(sys.stdin.readline().rstrip()) st = [] ans = [] for i in range(n): if k <= 0: break else: if arr[i] == '(': st.append((arr[i], i)) else: if st and st[-1][0] == '(': k -= 2 ans.append(st.pop()) ans.append((arr[i], i)) else: st.append((arr[i], i)) ans.sort(key=lambda x: x[1]) res = [] for i in ans: res.append(i[0]) print(''.join(res))",linear,['greedy'],410
"line = input().split() n, k = int(line[0]), int(line[1]) line = input() if n == k: print(line) else: ans = [] arr = [] for i in line: arr.append(i) for i in range(n): if len(ans) == k//2: break if arr[i] == '(': ans.append(i) for i in range(n-1, -1, -1): if len(ans) == k: break if arr[i] == ')': ans.append(i) ans.sort() for i in ans: print(arr[i], end="""")",linear,['greedy'],357
"n,k = map(int,input().split()) s = input() a = (n-k)//2 s1 = s.replace('(','',a) s2 = s1.replace(')','',a) print(s2)",linear,['greedy'],116
"from collections import deque as de import math from collections import Counter as cnt from functools import reduce from typing import MutableMapping def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def isPowerOfTwo(n): return (math.ceil(Log2(n)) == math.floor(Log2(n))); n,k=map(int,input().split()) s=list(map(str, input())) dic={} for i in range(n): if s[i]==""("": arrStack.my_push([i,""(""]) else: if arrStack.my_peak()[1]==""("": index=arrStack.my_peak()[0] dic[index]=1 dic[i]=1 k-=2 arrStack.my_pop() if k==0: break ans ="""" for i in range(n): if i in dic: ans+=s[i] print(ans)",linear,['greedy'],1675
"import sys def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans def SieveOfEratosthenes(n): cnt = 0 prime = [True for i in range(n + 1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n + 1, p): prime[i] = False p += 1 for p in range(2, n + 1): if prime[p]: cnt += 1 return (cnt) def nCr(n, r): f = math.factorial return f(n) // f(r) // f(n - r) mod = int(1e9) + 7 def ssinp(): return sys.stdin.readline().strip() def iinp(): return int(input()) def nninp(): return map(int, sys.stdin.readline().strip().split()) def llinp(): return list(map(int, sys.stdin.readline().strip().split())) def p(xyz): print(xyz) def p2(a, b): print(a, b) import math import random from collections import OrderedDict from fractions import Fraction n,k=nninp() s=ssinp() ans=[] lb=k//2 rb=k//2 for c in s: if(lb>0): if(c==""(""): lb-=1 else: rb-=1 ans.append(c) elif(rb>0): if(c=="")""): ans.append(c) rb-=1 elif(lb==0 and rb==0): break p(lts(ans))",linear,['greedy'],1493
"import sys def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans def SieveOfEratosthenes(n): cnt = 0 prime = [True for i in range(n + 1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n + 1, p): prime[i] = False p += 1 for p in range(2, n + 1): if prime[p]: cnt += 1 return (cnt) def nCr(n, r): f = math.factorial return f(n) // f(r) // f(n - r) mod = int(1e9) + 7 def ssinp(): return sys.stdin.readline().strip() def iinp(): return int(input()) def nninp(): return map(int, sys.stdin.readline().strip().split()) def llinp(): return list(map(int, sys.stdin.readline().strip().split())) def p(xyz): print(xyz) def p2(a, b): print(a, b) import math n,k=nninp() s=ssinp() ans=[] lb=k//2 rb=k//2 for c in s: if(lb>0): if(c==""(""): lb-=1 else: rb-=1 ans.append(c) elif(rb>0): if(c=="")""): ans.append(c) rb-=1 elif(lb==0 and rb==0): break p(lts(ans))",linear,['greedy'],1412
"import sys,os,io from sys import stdin from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop from bisect import bisect_left , bisect_right import math alphabets = list('abcdefghijklmnopqrstuvwxyz') def isPrime(x): for i in range(2,x): if i*i>x: break if (x%i==0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def SieveOfEratosthenes(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def countdig(n): c = 0 while (n > 0): n //= 10 c += 1 return c def si(): return input() def prefix_sum(arr): r = [0] * (len(arr)+1) for i, el in enumerate(arr): r[i+1] = r[i] + el return r def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') def power_set(L): cardinality=len(L) n=2 ** cardinality powerset = [] for i in range(n): a=bin(i)[2:] subset=[] for j in range(len(a)): if a[-j-1]=='1': subset.append(L[j]) powerset.append(subset) powerset_orderred=[] for k in range(cardinality+1): for w in powerset: if len(w)==k: powerset_orderred.append(w) return powerset_orderred def fastPlrintNextLines(a): print('\n'.join(map(str,a))) def sortByFirstAndSecond(A): A = sorted(A,key = lambda x:x[0]) A = sorted(A,key = lambda x:x[1]) return l",linear,['greedy'],1999
"try: n,k=list(map(int,input().split("" ""))) s=input() s=list(s) if len(s)>k: p='('*(k//2) p=list(p) c=0 for i in range(0,len(s)): if s[i]==')': p.insert(i,')') c+=1 if c==k//2: break print("""".join(p)) else: print("""".join(s)) except: pass",linear,['greedy'],236
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest def main(): starttime=datetime.datetime.now() if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") sys.stdout = open(""output.txt"",""w"") tc=1 for _ in range(tc): s=2*rs()+""333"" le=(len(s)-3)//2 a=[] for i in s: if i=='b': a.append(0) if i=='w': a.append(1) if i=='3': a.append(3) pehla=[0,1]*len(s) doosra=[1,0]*len(s) k=[0]*len(s) for i in range(len(s)): if a[i]==pehla[i]: k[i]=1 ans=0 t=0 for i in k: if i==1: t+=1 else: ans=max(t,ans) t=0 k=[0]*len(s) for i in range(len(s)): if a[i]==doosra[i]: k[i]=1 t=0 for i in k: if i==1: t+=1 else: ans=max(t,ans) t=0 print(min(le,ans)) endtime=datetime.datetime.now() time=(endtime-starttime).total_seconds()*1000 if(os.path.exists('input.txt')): print(""Time:"",time,""ms"") class FastReader(io.IOBase): newlines = 0 def __init__(self, fd, chunk_size=1024 * 8): self._fd = fd self._chunk_size = chunk_size self.buffer = io.BytesIO() def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self, size=-1): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buf",linear,"['constructive algorithms', 'implementation']",2000
"s = input() s = s*3 n = len(s) m,curr=1,1 for i in range(n-1): if s[i]!=s[i+1]: curr+=1 m=max(curr,m) else: curr=1 print(min(m,n//3))",linear,"['constructive algorithms', 'implementation']",133
"import sys,os,io from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop from sys import stdin import math def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def si(): return input() def prefix_sum(arr): r = [0] * (len(arr)+1) for i, el in enumerate(arr): r[i+1] = r[i] + el return r def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") sys.stdout = open(""output.txt"",""w"") t = 1 for _ in range(t): s = si() s = s*3 m = 0 c = 1 for i in range(1,len(s)): if (s[i]!=s[i-1]): c+=1 else: m = max(m,c) c = 1 m = max(m,c) m = min(m,len(s)//3) print(m)",linear,"['constructive algorithms', 'implementation']",1349
"s=input().strip() s=s+s n=len(s) an=1 m=1 for i in range(1,n): if s[i]!=s[i-1]: m+=1 an = max(an, m) else: an = max(an, m) m=1 print(min(an,n//2))",linear,"['constructive algorithms', 'implementation']",146
"s=list(input()) ans=0 far=0 for i in range(len(s)-1): if(s[i]!=s[i+1]): far+=1 continue if(s[0]!=s[-1]): s[:i+1]=s[:i+1][::-1] s[i+1:]=s[i+1:][::-1] far+=1 else: ans=max(ans,far+1) far=0 print(max(far+1,ans))",linear,"['constructive algorithms', 'implementation']",208
"import sys input=sys.stdin.readline s=list(input().rstrip()) n=len(s) s.extend(s) cnt=0 c=1 for i in range(len(s)-1): if s[i]!=s[i+1]: c+=1 else: cnt=max(c,cnt) c=1 cnt=max(cnt,c) print(min(cnt,n))",linear,"['constructive algorithms', 'implementation']",197
"a=input() n=len(a) b=[] c=0 d=0 for i in range(1,n): if a[i]==a[i-1]: b.append(['bw'.find(a[c]),i-c]) d=max(d,i-c) c=i b.append(['bw'.find(a[c]),n-c]) d=max(d,n-c) if d<n and b[0][0]==(b[-1][0]+b[-1][1])%2: d=max(d,b[-1][1]+b[0][1]) print(d)",linear,"['constructive algorithms', 'implementation']",241
"from collections import defaultdict, deque, Counter from sys import stdin, stdout from heapq import heappush, heappop import math import io import os import math import bisect def isPrime(x): for i in range(2, x): if i*i > x: break if (x % i == 0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3, int(math.sqrt(n))+1, 2): while n % i == 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p): res = 1 x = x % p if (x == 0): return 0 while (y > 0): if ((y & 1) == 1): res = (res * x) % p y = y >> 1 x = (x * x) % p return res def sieve(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def digits(n): c = 0 while (n > 0): n //= 10 c += 1 return c def ceil(n, x): if (n % x == 0): return n//x return n//x+1 def mapin(): return map(int, input().split()) s = list(input()) n = len(s) l = [1] for i in range(n-1): if(s[i]!= s[i+1]): l[-1]+=1 else: l.append(1) ans = max(l) if(len(l)>1): if(s[0]!= s[-1]): ans = max(ans, l[0]+l[-1]) print(ans)",linear,"['constructive algorithms', 'implementation']",1283
"def check(st): count = 1 i = 1 pre = st[0] maxi = 0 pre_indx = 0 indx = [0 for i in range(n)] while i<n: if pre != st[i]: count+=1 else: indx[pre_indx] =count count=1 pre_indx=i pre =st[i] i+=1 indx[pre_indx] =count return indx st=input() n=len(st) actual_indx=check(st) reverse_indx=check(st[::-1]) if st[0] ==st[-1]: print(max(actual_indx)) else: print(min(n,max(max(actual_indx[1:]),actual_indx[0] +reverse_indx[0])))",linear,"['constructive algorithms', 'implementation']",420
"import sys,os,io input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline n = int(input()) c = [int(i) for i in input().split()] a = [int(i)-1 for i in input().split()] vis = [-1]*n ans = 0 for i in range (n): ind = i while(vis[ind]==-1): vis[ind]=i ind = a[ind] if vis[ind]==i: start = ind ind = a[ind] cost = c[start] while(ind!=start): cost = min(cost, c[ind]) ind = a[ind] ans+=cost print(ans)",linear,"['dfs and similar', 'graphs']",401
"import sys import io, os input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline n = int(input()) C = list(map(int, input().split())) A = list(map(int, input().split())) A = [a-1 for a in A] visit = [False]*n loops = [] for i in range(n): if not visit[i]: s = [i] temp = set() temp.add(i) flag = False while s: v = s.pop() if visit[A[v]]: break if A[v] in temp: flag = True p = A[v] break else: s.append(A[v]) temp.add(A[v]) if flag: loop = [p] nv = A[p] cnt = 0 while nv != p: loop.append(nv) nv = A[nv] loops.append(loop) for v in temp: visit[v] = True ans = 0 for l in loops: m = 10**18 for i in l: m = min(m, C[i]) ans += m print(ans)",linear,"['dfs and similar', 'graphs']",642
"import sys import io, os import math from heapq import * gcd = math.gcd sqrt = math.sqrt ceil = math.ceil input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline def strinp(testcases): k = 5 if (testcases == -1 or testcases == 1): k = 1 f = str(input()) f = f[2:len(f) - k] return f def ind(ch): return ord(ch)-ord(""a"") def main(): n=int(input()) b=[0] cost=b+list(map(int, input().split())) arr=b+list(map(int, input().split())) nv=[-1]*(n+1) colors=[] c=0 for i in range(1,n+1): if(nv[i]!=-1): continue nv[i]=c dest=arr[i] while(nv[dest]==-1): nv[dest]=c dest=arr[dest] if(nv[dest]==c): colors.append(dest) c+=1 s=0 for i in colors: mi=cost[i] nxt=arr[i] while(nxt!=i): mi=min(mi,cost[nxt]) nxt=arr[nxt] s+=mi print(s) main()",linear,"['dfs and similar', 'graphs']",732
"import sys,os,io from sys import stdin import math from collections import defaultdict from heapq import heappush, heappop, heapify from bisect import bisect_left , bisect_right from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") alphabets = list('abcdefghijklmnopqrstuvwxyz') from types import GeneratorType def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den,p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append",linear,"['dfs and similar', 'graphs']",1999
"import sys rd = lambda : sys.stdin.readline().rstrip() n = int(rd()) c = list(map(int, rd().split())) a = list(map(lambda x: int(x)-1, rd().split())) visited = [-1] * (n) res = 0 for i in range(n): trace = [] t = i mn = 1e9 while visited[t] == -1: visited[t] = i trace.append(t) t = a[t] if visited[t] != i: continue while len(trace) > 0: v = trace.pop() mn = min(mn, c[v]) if t == v: break res += mn print(res)",linear,"['dfs and similar', 'graphs']",411
"input() c = list(map(int, input().split())) a = list(map(int, input().split())) u = [0] * len(a) ans = 0 for i in range(len(a)): if u[i] != 0: continue idx = i while u[idx] == 0: u[idx] = 1 idx = a[idx] - 1 if (u[idx] == 2): idx = i while u[idx] == 1: u[idx] = 2 idx = a[idx] - 1 continue start = idx mn = c[idx] u[idx] = 2 while a[idx] - 1 != start: idx = a[idx] - 1 mn = min(mn, c[idx]) u[idx] = 2 idx = i while u[idx] == 1: u[idx] = 2 idx = a[idx] - 1 ans += mn print(ans)",linear,"['dfs and similar', 'graphs']",475
"input() c = list(map(int, input().split())) a = list(map(int, input().split())) u = [0] * len(a) ans = 0 for i in range(len(a)): if u[i] != 0: continue idx = i while u[idx] == 0: u[idx] = 1 idx = a[idx] - 1 if (u[idx] == 2): idx = i while u[idx] == 1: u[idx] = 2 idx = a[idx] - 1 continue start = idx mn = c[idx] u[idx] = 2 while a[idx] - 1 != start: idx = a[idx] - 1 mn = min(mn, c[idx]) u[idx] = 2 idx = i while u[idx] == 1: u[idx] = 2 idx = a[idx] - 1 ans += mn print(ans)",linear,"['dfs and similar', 'graphs']",475
"n = int(input()) c = [0] + [int(j) for j in input().split()] a = [0] + [int(j) for j in input().split()] vis = [0] * (n + 1) ans = 0 for i in range(1, n + 1): x = i while vis[x] == 0: vis[x] = i x = a[x] if vis[x] != i: continue v = x mn = c[x] while a[x] != v: x = a[x] mn = min(mn, c[x]) ans += mn print(ans)",linear,"['dfs and similar', 'graphs']",310
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest def main(): starttime=datetime.datetime.now() if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") sys.stdout = open(""output.txt"",""w"") def intersection(l1,r1,l2,r2): if l1>r2 or r1<l2: return [0,0] else: return [max(l1,l2),min(r1,r2)] tc=1 for _ in range(tc): n=ri() pref=[] suff=[] z=[] for i in range(n): z.append(ria()) pix,piy=intersection(z[0][0],z[0][1],z[0][0],z[0][1]) six,siy=intersection(z[-1][0],z[-1][1],z[-1][0],z[-1][1]) for i in range(n): pix,piy=intersection(pix,piy,z[i][0],z[i][1]) pref.append([pix,piy]) for i in range(n-1,-1,-1): six,siy=intersection(six,siy,z[i][0],z[i][1]) suff.append([six,siy]) suff=suff[::-1] ans=max(suff[1][1]-suff[1][0],pref[n-2][1]-pref[n-2][0]) for i in range(1,n-1): intersect=intersection(pref[i-1][0],pref[i-1][1],suff[i+1][0],suff[i+1][1]) ans=max(ans,intersect[1]-intersect[0]) wi(ans) endtime=datetime.datetime.now() time=(endtime-starttime).total_seconds()*1000 if(os.path.exists('input.txt')): print(""Time:"",time,""ms"") class FastReader(io.IOBase): newlines = 0 def __init__(self, fd, chunk_size=1024 * 8): self._fd = fd self._chunk_size = chunk_size self.buffer = io.BytesIO() def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlin",linear,"['greedy', 'math', 'sortings']",2000
"import sys import math from collections import defaultdict,deque input = sys.stdin.readline def inar(): return [int(el) for el in input().split()] def main(): t=int(input()) tup=[] for _ in range(t): l,r=inar() tup.append([l,r]) tup.sort() l=tup[0][0] r=tup[0][1] prefix=[[l,r]] for i in range(1,t): if l>tup[i][1] or r<tup[i][0]: prefix.append([-1,-1]) for j in range(i+1,t): prefix.append([-1, -1]) break l=max(l,tup[i][0]) r=min(r,tup[i][1]) prefix.append([l,r]) l = tup[-1][0] r = tup[-1][1] suffix = [] for i in range(t): suffix.append([-1,-1]) suffix[-1][0]=l suffix[-1][1]=r for i in range(t-2,-1,-1): if l > tup[i][1] or r < tup[i][0]: break l = max(l, tup[i][0]) r = min(r, tup[i][1]) suffix[i][0]=l suffix[i][1]=r ans=0 for i in range(t): if i==0: ans=max(ans,abs(suffix[i+1][0]-suffix[i+1][1])) continue if i==t-1: ans=max(ans,abs(prefix[i-1][0]-prefix[i-1][1])) continue prefix_l=prefix[i-1][0] prefix_r=prefix[i-1][1] suffix_l=suffix[i+1][0] suffix_r=suffix[i+1][1] l=max(prefix_l,suffix_l) r=min(prefix_r,suffix_r) ans=max(ans,max(0,r-l)) print(ans) if __name__ == '__main__': main()",linear,"['greedy', 'math', 'sortings']",1097
"import sys import math import collections import bisect def get_ints(): return map(int, sys.stdin.readline().strip().split()) def get_list(): return list(map(int, sys.stdin.readline().strip().split())) def get_string(): return sys.stdin.readline().strip() for t in range(1): n=int(input()) starting=[] ending=[] points=[] for i in range(n): x,y=get_ints() starting.append(x) ending.append(y) ans=0 start_count=collections.Counter(starting) end_count=collections.Counter(ending) s=starting.copy() s.sort() e=ending.copy() e.sort() maxim=max(starting) minim=min(ending) for i in range(n): if starting[i]==maxim: if start_count[maxim]>1: loc_max=maxim else: pos=bisect.bisect_left(s,maxim) loc_max=s[pos-1] else: loc_max=maxim if ending[i]==minim: if end_count[minim]>1: loc_min=minim else: pos=bisect.bisect_right(e,minim) loc_min=e[pos] else: loc_min=minim ans=max(ans,loc_min-loc_max) print(ans)",linear,"['greedy', 'math', 'sortings']",895
"import sys input = sys.stdin.readline def intersection(segs): end = float('inf') start = - float('inf') for l, r in segs: end = min(end, r) start = max(start, l) return start, end def solve(): n = int(input()) segs = [tuple([int(x) for x in input().split(' ')]) for s in range(n)] starts = {} ends = {} x = intersection(segs) for l, r in segs: if r in starts: starts[r] = max(starts[r], l) else: starts[r] = l if l in ends: ends[l] = min(ends[l], r) else: ends[l] = r b = segs.copy() b.remove((x[0], ends[x[0]])) y = intersection(b) c = segs.copy() c.remove((starts[x[1]], x[1])) z = intersection(c) return max(x[1] - x[0], y[1] - y[0], z[1] - z[0], 0) print(solve())",linear,"['greedy', 'math', 'sortings']",667
"l1=l2=-1 r1=r2=1<<30 for i in range(int(input())): l,r=map(int,input().split()) if l>l1:il,l1,l2=i,l,l1 elif l>l2:l2=l if r<r1:ir,r1,r2=i,r,r1 elif r<r2:r2=r print(max(0,(r2-l2,max(r1-l2,r2-l1))[il!=ir]))",linear,"['greedy', 'math', 'sortings']",204
"from sys import stdin input=stdin.readline def intersec(arr): a=sorted(arr,key=lambda s:s[0],reverse=True) b=sorted(arr,key=lambda s:s[1]) x, y = 0, 0 if a[0]==b[0]: return max(b[1][1]-a[1][0],0) else: x=b[0][1]-a[1][0] y=b[1][1]-a[0][0] return max(x,y,0) blanck=[] for i in range(int(input())): a,b=map(int,input().strip().split()) blanck.append([a,b]) print(intersec(blanck))",linear,"['greedy', 'math', 'sortings']",377
"from collections import defaultdict, deque, Counter from sys import stdin, stdout from heapq import heappush, heappop import math import io import os import math import bisect def isPrime(x): for i in range(2, x): if i*i > x: break if (x % i == 0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3, int(math.sqrt(n))+1, 2): while n % i == 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p): res = 1 x = x % p if (x == 0): return 0 while (y > 0): if ((y & 1) == 1): res = (res * x) % p y = y >> 1 x = (x * x) % p return res def sieve(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def digits(n): c = 0 while (n > 0): n //= 10 c += 1 return c def ceil(n, x): if (n % x == 0): return n//x return n//x+1 def mapin(): return map(int, input().split()) def solve(final, n): fifi = [[final[j][i] for j in range(n)] for i in range(n)] k = [] for i in range(n): k.append(sum(final[i])) a = max(k)-min(k) a = a*a k = [] for i in range(n): k.append(sum(fifi[i])) b = max(k)-min(k) b = b*b return a+b def inte(a, b, c, d): a = max(a, c) b = min(b, d) return [a, b] input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline n = int(input()) l = [] for i in range(n): a, b = mapin() l.append([a, b]) f= [] ff = [] a = 0 b = 10000000000000 f.append([a, b]) for i in range(n): x = inte(a, b, l[i][0], l[i][1]) a = x[0] b = x[1] f.append([a, b]) a = 0 b = 10000000000000 ff = [[] for i in range(n)] for i in reversed(range(n)): x = inte(a, b, l[i][0], l[i][1]) a = x[0] b = x[1] ff[i] = [a, b] ff.append([0, 100000000000000]) ans = 0 for i in range(n): a = f[i] b = ff[i+1] y = inte(a[0], a[1], b[0], b[1]) if(y[1]>= y[0]): ans = max(ans, y[1]-y[0]) print(ans)",linear,"['greedy', 'math', 'sortings']",1996
"from collections import defaultdict import os import sys from io import BytesIO, IOBase ii = lambda: int(input()) lmii = lambda: list(map(int, input().split())) slmii = lambda: sorted(map(int, input().split())) li = lambda: list(input()) mii = lambda: map(int, input().split()) msi = lambda: map(str, input().split()) def gcd(a, b): if b == 0: return a return gcd(b, a % b) def lcm(a, b): return (a * b) // gcd(a, b) def main(): n = ii() d = defaultdict(int) ll = defaultdict(list) rr = defaultdict(list) llst = [] rlst = [] lst = [] for i in range(n): l, r = mii() lst.append([l,r]) llst.append(l) rlst.append(r) ll[l].append(r) rr[r].append(l) left = max(llst) right = min(rlst) lleft = min(ll[left]) lright = max(rr[right]) lst.remove([left,lleft]) pl = max(i[0] for i in lst) pr = min(i[1] for i in lst) mx = max(0,pr-pl) lst.append([left,lleft]) lst.remove([lright,right]) pl = max(i[0] for i in lst) pr = min(i[1] for i in lst) print(max(mx, max(0,pr-pl))) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffe",linear,"['greedy', 'math', 'sortings']",1999
"from collections import defaultdict from collections import deque import sys input = sys.stdin.readline def bfs(s): q = deque() q.append(s) dist = [-1] * (n + 1) dist[s] = 0 p = [] parent = [1] * (n + 1) ok = [0] * (n + 1) while q: i = q.popleft() d = dist[i] if d < 3: ok[i] = 1 p.append(i) for j in G[i]: if dist[j] == -1: q.append(j) dist[j] = d + 1 parent[j] = i ans = 0 while p: i = p.pop() j = parent[i] if not ok[i]: ok[j] = 1 ans += 1 for k in G[j]: ok[k] = 1 return ans n = int(input()) G = [[] for _ in range(n + 1)] for _ in range(n - 1): u, v = map(int, input().split()) G[u].append(v) G[v].append(u) ans = bfs(1) print(ans)",linear,"['dp', 'graphs', 'greedy']",636
"from sys import stdin n = int(stdin.readline()) g = dict() for i in range(n-1): u,v = map(int,stdin.readline().split()) g.setdefault(u-1,[]).append(v-1) g.setdefault(v-1, []).append(u-1) st = [0] rank = [0]*n tree = [0]*n msk = [0]*n rd = dict() while len(st)>0: top = st.pop() msk[top] = 1 for c in g[top]: if msk[c] == 0: st.append(c) tree[c] = top rank[c] = rank[top]+1 rd.setdefault(rank[c], []).append(c) max_rank = max(rank) reach = [0]*n build = [0]*n ans = 0 for r in range(max_rank, 2, -1): for node in rd[r]: if reach[node] == 0: reach[node] = 1 reach[tree[node]] = 1 reach[tree[tree[node]]] = 1 build[tree[node]] = 1 print(sum(build))",linear,"['dp', 'graphs', 'greedy']",645
"import sys from collections import deque import heapq input = sys.stdin.readline N=int(input()) EDGE=[list(map(int,input().split())) for i in range(N-1)] EDGELIST=[[] for i in range(N+1)] for i,j in EDGE: EDGELIST[i].append(j) EDGELIST[j].append(i) REDG=[None for i in range(N+1)] QUE=deque([1]) check=[0]*(N+1) DEPTH=[None]*(N+1) i=0 while QUE: NQUE=deque() i+=1 while QUE: x=QUE.pop() DEPTH[x]=i check[x]=1 for to in EDGELIST[x]: if check[to]==1: continue else: REDG[to]=x NQUE.append(to) QUE=NQUE check=[0]*(N+1) check[1]=1 LEAF=[] for i in range(2,N+1): if len(EDGELIST[i])==1: LEAF.append((-DEPTH[i],i)) QUE=LEAF heapq.heapify(QUE) ANS=0 while QUE: dep,x=heapq.heappop(QUE) if check[x]!=0 or dep>=-3: continue if check[REDG[x]]==2: continue if check[x]==0: check[x]=1 if check[REDG[REDG[x]]]==0: check[REDG[REDG[x]]]=1 check[REDG[x]]=2 heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]])) ANS+=1 print(ANS)",linear,"['dp', 'graphs', 'greedy']",928
"import sys from collections import deque mod = 10**9+7 INF = float('inf') def inp(): return int(sys.stdin.readline()) def inpl(): return list(map(int, sys.stdin.readline().split())) n = inp() edges = [[] for _ in range(n)] for _ in range(n-1): a,b = inpl() a,b = a-1,b-1 edges[a].append(b) edges[b].append(a) dist = [-1] * n dist[0] = 0 pa = [-1] * n se = set() pq = [] q = deque() q.append(0) while q: now = q.popleft() for nx in edges[now]: if dist[nx] != -1: continue pa[nx] = now dist[nx] = dist[now] + 1 if dist[nx] > 2: se.add(nx) pq.append((dist[nx], nx)) q.append(nx) pq = pq[::-1] res = 0 ind = 0 while se: d,v = pq[ind] ind += 1 if not v in se: continue res += 1 pv = pa[v] se.discard(pv) for nv in edges[pv]: se.discard(nv) print(res)",linear,"['dp', 'graphs', 'greedy']",745
"import sys def get_new_edges(graph): n = len(graph) far_vertex = [] pi = [None]*n visit = [False]*n visit[0] queue = [[0,0]] i = 0 while True: if i >= len(queue): break current, d = queue[i] i += 1 visit[current] = True for v in graph[current]: if not visit[v]: u = [v, d+1] pi[v] = current queue.append(u) if d+1 > 2: far_vertex.append(u) far_vertex.sort(key=lambda x: -x[1]) pos = [None]*n for i, e in enumerate(far_vertex): pos[e[0]] = i count = 0 for i in range(len(far_vertex)): if not far_vertex[i]: continue vertex, depth = far_vertex[i] father = pi[vertex] count += 1 if pos[father]: far_vertex[pos[father]] = None for u in graph[father]: if pos[u]: far_vertex[pos[u]] = None return count def read_int_line(): return map(int, sys.stdin.readline().split()) vertex_count = int(input()) graph = [[] for _ in range(vertex_count)] for i in range(vertex_count - 1): v1, v2 = read_int_line() v1 -= 1 v2 -= 1 graph[v1].append(v2) graph[v2].append(v1) print(get_new_edges(graph))",linear,"['dp', 'graphs', 'greedy']",978
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = sel",linear,"['constructive algorithms', 'dp']",1999
"n=int(input()) arr=list(map(int,input().split())) dp=[[-1 for i in range(5+1)] for j in range(n)] for i in range(1,6): dp[0][i] =1 for i in range(1,n): if arr[i] > arr[i - 1]: for j in range(1,6): for k in range(1,j): if dp[i-1][k]==1: dp[i][j] =1 break elif arr[i] <arr[i-1]: for j in range(1,6): for k in range(j+1,6): if dp[i-1][k] ==1: dp[i][j]=1 break else: for j in range(1,6): for k in range(1,6): if j ==k: continue if dp[i-1][k] ==1: dp[i][j] =1 break ans=[] for i in range(1,6): if dp[n-1][i]==1: ans.append(i) break if len(ans) ==0: print(-1) exit() for i in range(n-2,-1,-1): curr=ans[-1] if arr[i] >arr[i+1]: for j in range(curr+1,6): if dp[i][j] ==1: ans.append(j) break elif arr[i] <arr[i+1]: for j in range(1,curr): if dp[i][j] ==1: ans.append(j) break else: for j in range(1,6): if j ==curr: continue if dp[i][j] ==1: ans.append(j) break ans=ans[::-1] print(*ans)",linear,"['constructive algorithms', 'dp']",880
"n = int(input()) arr = list(map(int, input().split())) pal = 1 if arr[1] > arr[0] else 3 if arr[0] == arr[1] else 5 b = True arr_pal = [pal] for i in range(n - 2): if arr[i + 1] > arr[i]: if pal == 5: b = False break if arr[i + 2] < arr[i + 1]: pal = 5 arr_pal.append(pal) else: pal += 1 arr_pal.append(pal) elif arr[i + 1] < arr[i]: if pal == 1: b = False break if arr[i + 2] > arr[i + 1]: pal = 1 arr_pal.append(pal) else: pal -= 1 arr_pal.append(pal) else: if arr[i + 2] > arr[i + 1]: pal = 2 if pal == 1 else 1 arr_pal.append(pal) elif arr[i + 2] < arr[i + 1]: pal = 4 if pal == 5 else 5 arr_pal.append(pal) else: pal = 4 if pal < 4 else 3 arr_pal.append(pal) if arr[-2] < arr[-1]: if pal == 5: b = False else: pal += 1 arr_pal.append(pal) elif arr[-2] > arr[-1]: if pal == 1: b = False else: pal -= 1 arr_pal.append(pal) else: pal = 3 if pal == 5 else 5 arr_pal.append(pal) if b: print(*arr_pal) else: print(-1)",linear,"['constructive algorithms', 'dp']",916
"n = int(input()) a = list(map(int, input().split())) res = [] if n == 1: print(1) exit(0) i = 0 if a[0] < a[1]: if i >= n - 2: res = [1] cur = 2 else: if a[i + 1] < a[i + 2]: res = [1] cur = 2 elif a[i + 1] > a[i + 2]: res = [1] cur = 5 else: res = [1] cur = 2 elif a[0] > a[1]: if i >= n - 2: res = [5] cur = 4 else: if a[i + 1] < a[i + 2]: res = [5] cur = 1 elif a[i + 1] > a[i + 2]: res = [5] cur = 4 else: res = [5] cur = 4 else: if i >= n - 2: res.append(1) cur = 2 else: if a[i + 1] < a[i + 2]: res.append(2) cur = 1 elif a[i + 1] > a[i + 2]: res.append(4) cur = 5 else: res.append(2) cur = 3 for i in range(1, n - 1): if not (1 <= cur <= 5): print(-1) exit(0) res.append(cur) if a[i] > a[i + 1]: if i >= n - 2: cur -= 1 else: if a[i + 1] < a[i + 2]: cur = min(cur - 1, 1) elif a[i + 1] > a[i + 2]: cur -= 1 else: cur -= 1 elif a[i] < a[i + 1]: if i >= n - 2: cur += 1 else: if a[i + 1] < a[i + 2]: cur += 1 elif a[i + 1] > a[i + 2]: cur = max(cur + 1, 5) else: cur += 1 else: if i >= n - 2: if cur != 3: cur = 3 else: cur = 2 else: if a[i + 1] < a[i + 2]: if cur == 1: cur = 2 else: cur = 1 elif a[i + 1] > a[i + 2]: if cur == 5: cur = 4 else: cur = 5 else: if cur != 3: cur = 3 else: cur = 2 if not (1 <= cur <= 5): print(-1) exit(0) res.append(cur) print(*res)",linear,"['constructive algorithms', 'dp']",1269
"n = int(input()) a = iter(map(int, input().split())) prev_type = 3 prev_res = 2 curr_a = next(a) res = [] for _ in range(1): for next_a in a: if next_a > curr_a: if prev_type == 1 or prev_res == 1: prev_res += 1 if prev_res == 5: break else: prev_res = 1 prev_type = 1 elif next_a < curr_a: if prev_type == 2 or prev_res == 5: prev_res -= 1 if prev_res == 1: break else: prev_res = 5 prev_type = 2 else: if prev_type == 1: prev_res += 1 elif prev_type == 2: prev_res -= 1 elif prev_res != 2: prev_res = 2 else: prev_res = 3 prev_type = 3 res.append(prev_res) curr_a = next_a else: if prev_type == 1: res.append(prev_res + 1) elif prev_type == 2: res.append(prev_res - 1) elif prev_res != 1: res.append(1) else: res.append(2) print(*res) break else: print('-1')",linear,"['constructive algorithms', 'dp']",760
n = int(input()) ar = [int(i) for i in input().split()] if n == 1: print(1) exit() if ar[1] > ar[0]: li = [1] elif ar[1] < ar[0]: li = [5] else: li = [3] c = 1 while c != n: j = 0 if ar[c] > ar[c - 1]: while c != n and ar[c] > ar[c - 1]: c += 1 j += 1 for i in range(j-1): li.append(li[-1] + 1) if li[-1] == 6: print(-1) exit() if c != n and ar[c] == ar[c - 1]: li.append(li[-1] + 1) else: li.append(5) elif ar[c] < ar[c - 1]: while c != n and ar[c] < ar[c - 1]: c += 1 j += 1 for i in range(j-1): li.append(li[-1] - 1) if li[-1] == 0: print(-1) exit() if c != n and ar[c] == ar[c - 1]: li.append(li[-1] - 1) else: li.append(1) else: while c != n and ar[c] == ar[c - 1]: c += 1 j += 1 for i in range(j): if li[-1] > 3: li.append(li[-1] - 1) else: li.append(li[-1] + 1) if c != n and ar[c] > ar[c - 1]: if li[-2] == 1: li[-1] = 2 else: li[-1] = 1 elif c != n and ar[c] < ar[c - 1]: if li[-2] == 5: li[-1] = 4 else: li[-1] = 5 if max(li) > 5 or min(li) < 1: print(-1) else: print(*li),linear,"['constructive algorithms', 'dp']",982
"n = int(input()) a = list(map(int, input().split())) res = [] if n == 1: print(1) exit(0) i = 0 if a[0] < a[1]: if i >= n - 2: res = [1] cur = 2 else: if a[i + 1] < a[i + 2]: res = [1] cur = 2 elif a[i + 1] > a[i + 2]: res = [1] cur = 5 else: res = [1] cur = 2 elif a[0] > a[1]: if i >= n - 2: res = [5] cur = 4 else: if a[i + 1] < a[i + 2]: res = [5] cur = 1 elif a[i + 1] > a[i + 2]: res = [5] cur = 4 else: res = [5] cur = 4 else: if i >= n - 2: res.append(1) cur = 2 else: if a[i + 1] < a[i + 2]: res.append(2) cur = 1 elif a[i + 1] > a[i + 2]: res.append(4) cur = 5 else: res.append(2) cur = 3 for i in range(1, n - 1): if not (1 <= cur <= 5): print(-1) exit(0) res.append(cur) if a[i] > a[i + 1]: if i >= n - 2: cur -= 1 else: if a[i + 1] < a[i + 2]: cur = min(cur - 1, 1) elif a[i + 1] > a[i + 2]: cur -= 1 else: cur -= 1 elif a[i] < a[i + 1]: if i >= n - 2: cur += 1 else: if a[i + 1] < a[i + 2]: cur += 1 elif a[i + 1] > a[i + 2]: cur = max(cur + 1, 5) else: cur += 1 else: if i >= n - 2: if cur != 3: cur = 3 else: cur = 2 else: if a[i + 1] < a[i + 2]: if cur == 1: cur = 2 else: cur = 1 elif a[i + 1] > a[i + 2]: if cur == 5: cur = 4 else: cur = 5 else: if cur != 3: cur = 3 else: cur = 2 if not (1 <= cur <= 5): print(-1) exit(0) res.append(cur) print(*res)",linear,"['constructive algorithms', 'dp']",1269
def get_fingering(notes): fingering = [] diff = 0 next_diff = None finger = 0 for i in range(len(notes) - 1): next_diff = notes[i+1] - notes[i] if diff == 0: if next_diff > 0: finger = 1 + (finger == 1) elif next_diff < 0: finger = 5 - (finger == 5) else: finger = 3 + (finger == 3) elif diff > 0: if finger == 5: return None if next_diff < 0: finger = 5 else: finger += 1 else: if finger == 1: return None if next_diff > 0: finger = 1 else: finger -= 1 fingering.append(finger) diff = next_diff return fingering _ = input() notes = [int(x) for x in input().split()] notes.append(notes[-1]) fingering = get_fingering(notes) if fingering: print(*fingering) else: print(-1),linear,"['constructive algorithms', 'dp']",671
"import sys input = sys.stdin.readline n=int(input()) A=list(map(int,input().split())) PLACE=[None]*(n+1) for i in range(n): PLACE[A[i]]=i al=n WINLIST=[None]*(n+1) def move(n,al): place=PLACE[n] for i in range(place,-1,-n): if A[i]>n and WINLIST[A[i]]==""B"": WINLIST[n]=""A"" return for i in range(place,al,n): if A[i]>n and WINLIST[A[i]]==""B"": WINLIST[n]=""A"" return else: WINLIST[n]=""B"" return for j in range(n,0,-1): move(j,al) ANS="""" for i in A: ANS+=WINLIST[i] print(ANS)",linear,"['brute force', 'dp', 'games']",472
"n = int(input()) a = [int(s) for s in input().split()] ans = [None]*n def get(p): if ans[p] is not None: return ans[p] elif a[p] == 1: ans[p] = ""A"" elif a[p] == n: ans[p] = ""B"" else: for i in range(p+a[p], n, a[p]): if a[i] > a[p]: if get(i) == ""B"": ans[p] = ""A"" return ans[p] for i in range(p-a[p], -1, -a[p]): if a[i] > a[p]: if get(i) == ""B"": ans[p] = ""A"" return ans[p] ans[p] = ""B"" return ans[p] if n == 1: print(""B"") else: for i in range(n-1, -1, -1): get(i) print(''.join(ans))",linear,"['brute force', 'dp', 'games']",483
"n = int(input()) l = [0]+list(map(int,input().split())) from collections import defaultdict ans = ['A','B'] x = defaultdict(int) table = [-1]*(n+1) for i in range(1,n+1): x[l[i]] = i table[x[n]] = 1 for i in range(n-1,0,-1): if(x[i]-i>0): for j in range(x[i],0,-i): if(l[j]>i): if(table[j]==1): table[x[i]] = 0 break if(n-i>0 and table[x[i]]==-1): for j in range(x[i],n+1,i): if(l[j]>i): if(table[j]==1): table[x[i]] = 0 break if(table[x[i]]==-1): table[x[i]] = 1 for i in table[1:]: print(ans[i],end='')",linear,"['brute force', 'dp', 'games']",504
"def wins(mem, l, pos): if mem[pos] != 0: return mem[pos] == 1 val = l[pos] lo = pos - val while lo >= 0: if l[lo] > val and not wins(mem, l, lo): mem[pos] = 1 return True lo -= val hi = pos + val while hi < len(l): if l[hi] > val and not wins(mem, l, hi): mem[pos] = 1 return True hi += val mem[pos] = 2 return False n = int(input()) l = list(map(int, raw_input().split())) mem = [0 for i in range(n)] ans = """" for i in range(n): ans += ""A"" if wins(mem, l, i) else ""B"" print(ans)",linear,"['brute force', 'dp', 'games']",479
"from collections import deque from sys import stdin lines = deque(line.strip() for line in stdin.readlines()) def nextline(): return lines.popleft() def types(cast, sep=None): return tuple(cast(x) for x in strs(sep=sep)) def ints(sep=None): return types(int, sep=sep) def strs(sep=None): return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep)) def main(): n = int(nextline()) a = ints() bs = set() moves = {} for i in range(n): moves[a[i]] = list(a[j] for j in range(i % a[i], n, a[i]) if a[j] > a[i]) winners = {} for i in range(n, 0, -1): winner = 'A' if any(winners[j] == 'B' for j in moves[i]) else 'B' if winner == 'B': bs.add(i) winners[i] = winner print(''.join(winners[ai] for ai in a)) if __name__ == '__main__': main()",linear,"['brute force', 'dp', 'games']",748
"n=int(input()) a=[*map(int,input().split())] b=[0]*n s=[0]*n m=n while m: for i,x in enumerate(a): if s[i]==0: r=range(i%x,n,x) if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1 if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1 print(''.join(s))",linear,"['brute force', 'dp', 'games']",251
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, **kwargs, file=sys.stderr) dprint('debug mode') except ModuleNotFoundError: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) N, = getIntList() s1 = input() +'0' s2 = input() +'0' res = 0 i = 0 while i<N: if s1[i] != s2[i]: if s1[i+1] == s2[i] and s2[i+1] == s1[i]: res+=1 i+=2 continue res+=1 i+=1 print(res)",linear,"['dp', 'greedy', 'strings']",733
"n = int(input()) a = input() b = input() c = [10**10 for i in range(n + 10)] c[0] = 0 if a[0] == b[0] else 1 for i in range(1, n): if a[i] == b[i]: c[i] = c[i - 1] elif a[i] == b[i - 1] and a[i - 1] == b[i]: c[i] = (1 + c[i - 2] if i > 1 else 1) c[i] = min(c[i], c[i - 1] + 1) print(c[n - 1])",linear,"['dp', 'greedy', 'strings']",292
"def read(): return [c == '1' for c in input()] n = int(input()) a, b = read(), read() res = 0 i = 0 while i + 1 < n: if a[i] != b[i] and a[i] != a[i+1] and b[i] != b[i+1]: a[i] = b[i] a[i+1] = b[i+1] res += 1 i += 2 else: i += 1 for i in range(n): if a[i] != b[i]: res += 1 print(res)",linear,"['dp', 'greedy', 'strings']",284
"n = int(raw_input()) a = list(raw_input()) b = list(raw_input()) ans = 0 for i in range(n - 1): if a[i] == b[i]: continue if a[i + 1] == b[i + 1]: continue if a[i] == b[i + 1] and a[i + 1] == b[i]: a[i], a[i + 1] = a[i + 1], a[i] ans += 1 for i in range(n): ans += a[i] != b[i] print(ans)",linear,"['dp', 'greedy', 'strings']",288
"n = int(input()) a = list(map(int, input())) b = list(map(int, input())) ans = sum(q != w for q, w in zip(a, b)) i = 1 while i < n: aii = a[i - 1] ai = a[i] bii = b[i - 1] bi = b[i] if aii + ai == 1 and bii + bi == 1 and aii != bii and ai != bi: ans -= 1 i += 1 i += 1 print(ans)",linear,"['dp', 'greedy', 'strings']",279
n = int(input()) a = list(input()) b = list(input()) count = 0 skip_next = False for idx in range(n - 1): if skip_next: skip_next = False continue if a[idx] != b[idx] and a[idx] == b[idx + 1] and a[idx + 1] == b[idx]: count += 1 a[idx] = b[idx] a[idx + 1] = b[idx + 1] skip_next = True for idx in range(n): if a[idx] != b[idx]: count += 1 print(count),linear,"['dp', 'greedy', 'strings']",351
n = int(input()) a = list(input()) b = list(input()) ans = 0 i = 0 while i < n: if a[i] != b[i]: ans += 1 if i < n - 1 and a[i] == b[i + 1] and b[i] == a[i + 1]: i += 1 i += 1 print(ans),linear,"['dp', 'greedy', 'strings']",186
"n = int(input()) a = list(map(int, input().strip())) b = list(map(int, input().strip())) res = 0 for j in range(n-1): if (a[j]== 0) and (a[j+1 ] == 1 ) and (b[j] == 1) and (b[j+1 ] == 0): res +=1 a[j ] = 1 a[j+1] = 0 elif (a[j]== 1) and (a[j+1] ==0 ) and (b[j] == 0) and (b[j+1 ] == 1): res +=1 a[j ] = 0 a[j+ 1] = 1 for j in range(n): if a[j] != b[j]: res += 1 print(res)",linear,"['dp', 'greedy', 'strings']",372
n = int(input()) a = str(input()) b = str(input()) k = True result = 0 for i in range(n): if a[i] == b[i]: if k == False: result += 1 k = True else: if k == False and z != a[i]: result += 1 k = True elif k == False and z == a[i]: result += 1 else: k = False z = a[i] if k == False: result += 1 print(result),linear,"['dp', 'greedy', 'strings']",307
"n = int(input()) graph = [set() for tr in range(n+2)] i = 1 while i < n: x, y = map(int, input().split()) graph[x].add(y) graph[y].add(x) i += 1 a = iter(map(int, input().split())) try: assert next(a) == 1 q = [1] for v in q: gv = graph[v] gv1 = tuple(gv) for tr2 in gv1: u = next(a) assert u in gv gv.remove(u) graph[u].remove(v) q.append(u) print(""Yes"") except AssertionError: print(""No"")",linear,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",390
"from collections import deque n = int(input()) graph = [set() for i in range(n + 1)] graph[0].add(1) graph[1].add(0) for i in range(n - 1): x, y = map(int, input().split()) graph[x].add(y) graph[y].add(x) a = list(map(int, input().split())) q = deque() q.append(0) i = 0 par = [0] * (n + 1) while len(q): v = q.popleft() graph[v].discard(par[v]) l = len(graph[v]) if graph[v] != set(a[i:i + l]): print(""No"") break for j in range(i, i + l): q.append(a[j]) par[a[j]] = v i += l else: print(""Yes"")",linear,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",494
"from collections import deque def removeUsed(adj, used): to_remove = [] for s in adj: if used[s]: to_remove.append(s) for s in to_remove: adj.remove(s) def solve(a, s): if s[0] != 0: return False q = deque() q.append(0) i, n, cur = 1, len(a), -1 used = [False]*n used[0] = True while i < n: if cur == -1: cur = q.popleft() removeUsed(a[cur], used) if not a[cur]: cur = -1 continue cur_s = s[i] i += 1 if cur_s not in a[cur]: return False a[cur].remove(cur_s) q.append(cur_s) used[cur_s] = True return True n = int(input()) a = [set() for i in range(n)] for i in range(n-1): u, v = map(int, input().split()) a[u-1].add(v-1) a[v-1].add(u-1) s = [(x-1) for x in map(int, input().split())] print(""Yes"" if solve(a, s) else ""No"")",linear,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",723
"from collections import defaultdict n = int(raw_input()) t = defaultdict(list) for _ in range(n - 1): u, v = map(int, raw_input().split()) t[u].append(v) t[v].append(u) a = list(map(int, raw_input().split())) o = {a_: i for i, a_ in enumerate(a)} i = 0 q = [1] lv = {1: 0} par = {1: 1} while i < len(q): u = q[i] i += 1 for v in t[u]: if v not in lv: lv[v] = lv[u] + 1 q.append(v) par[v] = u depths = defaultdict(list) for x in a: depths[lv[x]].append(o[par[x]]) ans = a[0] == 1 if ans: for d in depths.values(): if not all(d[i] <= d[i + 1] for i in range(len(d) - 1)): ans = False break if ans: l = [lv[x] for x in a] ans = all(l[i] <= l[i + 1] for i in range(len(l) - 1)) print(('No', 'Yes')[ans])",linear,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",699
"n=int(input()) dict1={} for i in range(n-1): x,y=map(int,input().split()) try: dict1[y].append(x) except: KeyError dict1[y]=[x] try: dict1[x].append(y) except: KeyError dict1[x]=[y] arr=list(map(int,input().split())) if(arr[0]!=1): print(""No"") else: j=0 i=1 flag=0 while(i<n and j<n): if(arr[j] in dict1[arr[i]]): i+=1 else: j+=1 if(i!=n and j==n): print('No') else: print('Yes')",linear,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",379
"n = int(input()) d = {} for i in range(n-1): a,b = map(int,input().split()) try: d[a].append(b); except: d[a] = [b] try: d[b].append(a); except: d[b] = [a] array = list(map(int,input().split())) flag=0; if array[0]==1: i = 1; j = 0; while ( j < n and i < n ): if ( array[j] in d[array[i]] ): i+=1; else: j+=1; if j==n and i!=n: flag=1; else: flag=1; if flag==1: print(""No"") else: print(""Yes"")",linear,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",392
"from sys import stdin from collections import deque n=int(stdin.readline()) g=dict() for i in range(n-1): a,b=map(int,stdin.readline().strip().split()) g.setdefault(a, set()).add(b) g.setdefault(b, set()).add(a) a=[int(x) for x in stdin.readline().strip().split()] ans = True if n > 1 and a[0] == 1: q=deque() m=[0]*(n+1) q.append(1) m[1]=1 right=1 while len(q) > 0 and ans: first = q.popleft() cnt = 0 for v in g[first]: if m[v] == 0: cnt += 1 for i in range(right, right+cnt): if m[a[i]] == 0 and a[i] in g[first]: m[a[i]] = 1 q.append(a[i]) else: ans = False break right += cnt else: ans = a[0] == 1 if ans: print(""Yes"") else: print(""No"")",linear,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",641
"from sys import stdin from collections import deque n=int(stdin.readline()) g=dict() for i in range(n-1): a,b=map(int,stdin.readline().split()) g.setdefault(a, set()).add(b) g.setdefault(b, set()).add(a) a=[int(x) for x in stdin.readline().split()] ans = True if n > 1 and a[0] == 1: q=deque() m=[0]*(n+1) q.append(1) m[1]=1 right=1 while len(q) > 0 and ans: first = q.popleft() cnt = 0 for v in g[first]: if m[v] == 0: cnt += 1 for i in range(right, right+cnt): if m[a[i]] == 0 and a[i] in g[first]: m[a[i]] = 1 q.append(a[i]) else: ans = False break right += cnt else: ans = a[0] == 1 if ans: print(""Yes"") else: print(""No"")",linear,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",625
"from collections import Counter n, k = map(int, input().split()) c = Counter(input()) ans = min(c[chr(ord('A') + i)] for i in range(k)) print(k * ans)",linear,"['implementation', 'strings']",150
"read = lambda: map(int, input().split()) n, k = read() s = input() c = [0] * 26 for i in range(n): if s[i] <= chr(ord('A') + k - 1): c[ord(s[i]) - ord('A')] += 1 print(min(c[:k]) * k)",linear,"['implementation', 'strings']",183
"n, k = map(int, input().split(' ')) s = input() m = 10 ** 10 for i in range(k): c = chr(ord('A') + i) m = min(m, s.count(c)) print(m * k)",linear,"['implementation', 'strings']",137
"ct = [0]*26 n, k =[int(i) for i in input().split()] s = input() for i in s: ct[ord(i)-ord('A')]+=1 print(min(ct[:k])*k)",linear,"['implementation', 'strings']",119
"import sys import string def ria(): return [int(i) for i in input().split()] n, k = ria() mp = {} for i in string.ascii_uppercase[:k]: mp[i] = 0 for i in input(): if i in mp: mp[i] += 1 print(min(mp.values())*k)",linear,"['implementation', 'strings']",211
"n, k = map(int, input().split()) count = [0] * k for c in input(): count[ord(c) - ord(""A"")] += 1 print(k * min(count))",linear,"['implementation', 'strings']",118
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) from collections import Counter alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' n, k = mi() s = input().strip() c = Counter(s) mn = 10 ** 9 for ch in alpha[:k]: mn = min(mn, c[ch]) print(mn * k)",linear,"['implementation', 'strings']",284
"from collections import Counter if __name__ == ""__main__"": n, k = map(int, input().split()) s = input() c = Counter(s) min_symbols = min(c[chr(ord(""A"") + i)] for i in range(k)) print(min_symbols * k)",linear,"['implementation', 'strings']",199
"n, k = map(int, input().split()) s = list(input()) a = ord('A') cnt = [0] * k for ch in s: cnt[ord(ch) - a] += 1 print(k * min(cnt))",linear,"['implementation', 'strings']",132
import sys import string def ria(): return [int(i) for i in input().split()] n = ria()[0] ar = ria() if n == 1: print(ar[0]) exit(0) onlyNegs = True onlyPos = True if max(ar) >= 0: onlyNegs = False if min(ar) <= 0: onlyPos = False if onlyNegs: print(abs(sum(ar)) + max(ar) * 2) exit(0) if onlyPos: print(abs(sum(ar)) - min(ar) * 2) exit(0) print(sum([abs(i) for i in ar])),linear,"['dp', 'greedy', 'implementation']",372
"n = int(input()) a = list(map(int, input().split())) if n == 1: print(a[0]) else: prod_minus = False for i in range(n - 1): if a[i] * a[i + 1] <= 0: prod_minus = True break Min_abs = float(""inf"") Sum = 0 for num in a: Sum += abs(num) if abs(num) < Min_abs: Min_abs = abs(num) if prod_minus: print(Sum) else: print(Sum - 2 * Min_abs)",linear,"['dp', 'greedy', 'implementation']",332
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, **kwargs, file=sys.stderr) dprint('debug mode') except ModuleNotFoundError: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) N, = getIntList() za = getIntList() if N==1: print(za[0]) sys.exit() t1 = max(za) t2 = min(za) if t2>=0: print(sum(za) - 2*t2) sys.exit() if t1<=0: print(2*t1 - sum(za)) sys.exit() res = 0 for x in za: res+= abs(x) print(res)",linear,"['dp', 'greedy', 'implementation']",775
"import sys import os def solve(slimes): if len(slimes) == 1: return slimes[0] havePos = False haveNeg = False for s in slimes: if s > 0: havePos = True elif s < 0: haveNeg = True if havePos and haveNeg: return sum(map(abs, slimes)) elif not havePos: m = max(slimes) return sum(list(map(abs, slimes))) + 2 * m elif not haveNeg: m = min(slimes) return sum(list(map(abs, slimes))) - 2 * m else: return 0 def main(): n = int(input()) slimes = list(map(int, input().split())) print(solve(slimes)) if __name__ == '__main__': main()",linear,"['dp', 'greedy', 'implementation']",525
"n = int(input()) a = input().split() for i in range(n): a[i] = int(a[i]) if(n==1): print(a[0]) else: sm = 0 havePositive = False haveNegative = False for c in a: if(c==0): haveNegative = True havePositive = True elif(c>0): havePositive = True sm += c else: haveNegative = True sm -= c if(haveNegative and havePositive): print(sm) else: for i in range(n): a[i] = abs(a[i]) ans = sum(a) low = a[0] for c in a: low = min(low,c) print(ans-2*low)",linear,"['dp', 'greedy', 'implementation']",441
"n=int(input()) A=list(map(int,input().split())) if n==1: print(A[0]) elif n==2: print(abs(A[0]-A[1])) else: SUM=0 for i in range(n): SUM+=abs(A[i]) ANS=0 for i in range(n-1): if ANS<SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]): ANS=SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]) print(ANS)",linear,"['dp', 'greedy', 'implementation']",283
"n = int(input()) arr = list(map(int, input().strip().split())) k = min(arr) h = max(arr) s = 0 for i in arr: if i >= 0: s += i else: s -= i if n == 1: print(arr[0]) elif ((k < 0 and h >= 0)): print(s) else: if (k >= 0): print(s - 2 * k) else: print(s + 2 * h)",linear,"['dp', 'greedy', 'implementation']",259
"n = int(input()) xs = [int(x) for x in input().split()] prefix = [-1 for i in range(n)] suffix = [-1 for i in range(n)] prefix[0] = 0 pre_has_neg = [False for i in range(n)] suffix[-1] = 0 suf_has_neg = [False for i in range(n)] for i in range(n): if i == 0: prefix[i] = xs[i] else: prefix[i] = prefix[i-1] + xs[i] for i in reversed(range(n)): if i == n-1: suffix[i] = xs[i] else: suffix[i] = suffix[i+1] + xs[i] for i in range(n): if i == 0: pre_has_neg[i] = xs[i] <= 0 else: pre_has_neg[i] = pre_has_neg[i-1] or xs[i] <= 0 for i in reversed(range(n)): if i == n-1: suf_has_neg[i] = xs[i] <= 0 else: suf_has_neg[i] = suf_has_neg[i+1] or xs[i] <= 0 prebignum = [None for i in range(n)] sufbignum = [None for i in range(n)] for i in range(n): if i == 0: prebignum[i] = xs[i] else: prebignum[i] = min(prebignum[i-1], xs[i]) for i in reversed(range(n)): if i == n-1: sufbignum[i] = xs[i] else: sufbignum[i] = min(sufbignum[i+1], xs[i]) neg_pre = [100000 for i in range(n)] neg_suf = [100000 for i in range(n)] for i in range(n): if i == 0: neg_pre[i] = min(xs[i], -xs[i]) else: neg_pre[i] = neg_pre[i-1] + min(xs[i], -xs[i]) for i in reversed(range(n)): if i == n-1: neg_suf[i] = min(xs[i], -xs[i]) else: neg_suf[i] = neg_suf[i+1] + min(xs[i], -xs[i]) ans = -100000000000000000 for i in range(n): tans = xs[i] if i == 0: pass elif pre_has_neg[i-1]: tans -= neg_pre[i-1] else: tans += prefix[i-1] tans -= prebignum[i-1]*2 if i == n-1: pass elif suf_has_neg[i+1]: tans -= neg_suf[i+1] else: tans += suffix[i+1] tans -= sufbignum[i+1]*2 ans = max(ans, tans) print(ans)",linear,"['dp', 'greedy', 'implementation']",1562
"n = int(input()) if n==1: a = input() print(a) else: a = list(map(int, input().split())) b = [abs(i) for i in a] if min(a)*max(a) > 0: print(sum(b)-2*min(b)) else: print(sum(b))",linear,"['dp', 'greedy', 'implementation']",177
"n = int(input()) a = list(map(int, input().split())) mx = -1 for step, elem in enumerate(a): if elem > mx + 1: print(step + 1) exit(0) else: mx = max(mx, elem) print(-1)",linear,['implementation'],169
"n = int(input()) a = [int(i) for i in input().split()] c = 0 for i in range(n): if a[i] > c: print(i+1) break else: c = max(a[i]+1, c) else: print(-1)",linear,['implementation'],150
"n = int(input()) a = list(map(int, input().split())) mex = -1 for i in range(n): if a[i] <= mex: continue elif a[i] == mex + 1: mex += 1 else: print(i+1) exit() print(-1)",linear,['implementation'],170
"n = int(input()) arr = list(map(int, input().split())) arr1 = [arr[0]] m = -1 for i, v in enumerate(arr): if v > m + 1: print(i+1) break m = max(m, v) else: print(-1)",linear,['implementation'],166
"import sys a = list(map(int, sys.stdin.readlines()[1][:-1].split())) mx = 0 for i in range(len(a)): if a[i] > mx: print(i+1) sys.exit(0) mx = max(mx,a[i] + 1) print(-1)",linear,['implementation'],168
"n = int(input()) a = list(map(int, input().split())) mx = -1 ans = -1 for i in range(n): if a[i] > mx+1: ans = i+1 break else: mx = max(mx, a[i]) print(ans)",linear,['implementation'],156
"from math import * n=int(input()) A = list(map(int,input().split())) ans =-1 maxs = 0 for j in range(n): if(A[j] > maxs): ans = j+1 break else: maxs = max(maxs,A[j]+1) print(ans)",linear,['implementation'],178
"n = int(input()) a = list(map(int, input().split())) max_el = -1; er = -1; for i in range(len(a)): if a[i] - max_el > 1: er = i + 1; break if a[i] > max_el: max_el = a[i] print(er)",linear,['implementation'],180
"n = int(input()) a = list(map(int, input().split())) s = 0 for j, i in enumerate(a): if i > s: print(j + 1) exit() if i == s: s += 1 print(-1)",linear,['implementation'],142
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = sel",linear,"['greedy', 'implementation']",1999
"from collections import defaultdict n,k=map(int,input().split()) arr=list(map(int,input().split())) xors=defaultdict(int) xors[0]=1 comp=(1<<k)-1 xor=0 ans=n*(n+1)//2 for a in arr: xor^=a if(xors[xor]>xors[comp^xor]): xor^=comp ans-=xors[xor] xors[xor]+=1 print(ans)",linear,"['greedy', 'implementation']",266
"from collections import defaultdict n, k = map(int, input().split()) a = [0] + list(map(int, input().split())) h = defaultdict(int) for i in range(n): a[i + 1] ^= a[i] for i in range(n + 1): h[min(a[i] ^ ((1 << k) - 1), a[i])] += 1 ans = 0 for x, t in h.items(): a = t // 2 b = t - a ans += a * (a - 1) // 2 + b * (b - 1) // 2 ans = (n * (n + 1)) // 2 - ans print(ans)",linear,"['greedy', 'implementation']",368
"n, k = map(int, raw_input().split()) a = map(int, raw_input().split()) for i in range(n): ai = a[i] nai = ((1<<k) - 1)^ai if nai < ai: a[i] = nai from collections import Counter C = Counter() C[0] += 1 S = 0 cnt = 0 for j, ai in enumerate(a): nai = ((1<<k) - 1)^ai v1, v2 = C[S^ai], C[S^nai] if v1 <= v2: cnt += j + 1 - v1 S ^= ai C[S] += 1 else: cnt += j + 1 - v2 S ^= nai C[S] += 1 print(cnt)",linear,"['greedy', 'implementation']",394
"from math import * n,k = map(int,input().split()) ans = [0] * n lul = 2**k - 1 A = list(map(int,input().split())) ans[0] = A[0] for j in range(1, n): ans[j] = ans[j-1]^A[j] d = dict() for j in range(n): if ans[j] in d: d[ans[j]]+=1; else: d[ans[j]] = 1 ans =0 def huy(n): return n*(n-1)//2 for j in d: now = d[j] xor = lul^j cur = now if xor in d : now2 = d[xor] cur += now2 ans += huy(cur//2+cur%2) ans+=huy(cur//2) if j ==0: ans+=2*(cur//2) else: if(j==0 or xor ==0): ans+= 2*(cur//2) ans += 2*huy(cur // 2 + cur % 2) ans += 2*huy(cur // 2) print(huy(n+1) - ans//2)",linear,"['greedy', 'implementation']",567
"def add(num): if(num<=1): return 0 return (num*(num-1))//2 n,k=map(int,input().split()) a=list(map(int,input().split())) pre=[a[0]] base=(2**(k))-1 hb=2**(k-1) for i in range(1,n): pre.append(a[i]^pre[-1]) cnt=dict() cnt[0]=[0,0] for i in range(n): if(pre[i]>=hb): if(base-pre[i] not in cnt): cnt[base-pre[i]]=[0,0] cnt[base-pre[i]][1]+=1 else: if(pre[i] not in cnt): cnt[pre[i]]=[0,0] cnt[pre[i]][0]+=1 cnt1=0 for i in cnt.values(): sum1=i[0]+i[1] cnt1+=add(sum1//2) cnt1+=add((sum1+1)//2) cnt1+=sum(cnt[0])//2 print((n*(n+1))//2 - cnt1)",linear,"['greedy', 'implementation']",538
"from collections import defaultdict n,k = map(int,input().split()) arr = list(map(int,input().split())) xors = defaultdict(int) xors[0]=1 comp = (1<<k)-1 ans = n*(n+1)//2 xor = 0 for a in arr: xor^=a if xors[xor]>xors[comp^xor]: xor^=comp ans-=xors[xor] xors[xor]+=1 print(ans)",linear,"['greedy', 'implementation']",277
"n, k = [int(i) for i in input().split()] d = dict() d[0] = 1 x = 0 for i in [int(i) for i in input().split()]: x ^= i v = min(x, (1 << k) - x - 1) if v not in d.keys(): d[v] = 0 d[v] += 1 ans = 0 for k, v in d.items(): c1 = v // 2 c2 = v - c1 ans += c1 * (c1 - 1) // 2 + c2 * (c2 - 1) // 2 print(n * (n - 1) // 2 + n - ans)",linear,"['greedy', 'implementation']",323
"n,k=list(map(int,input().split())) arr=list(map(int,input().split())) newarr=[0] for num in arr: newarr+=[newarr[-1]^num] dic={} for num in newarr: x=(min(num,2**k-1-num),max(num,2**k-1-num)) if x in dic: dic[x]+=1 else: dic[x]=1 ans=0 for elem in dic: m=dic[elem] half=m//2 ans+=half*(half-1)/2 half=m-half ans+=half*(half-1)/2 ans=n*(n+1)/2-ans print(int(ans))",linear,"['greedy', 'implementation']",362
"import sys import random import copy from itertools import permutations, combinations from math import sqrt, fabs, ceil from collections import namedtuple in_file_path = ""input.txt"" output_file_path = ""output.txt"" SUBMIT = True def get_array(x, initial=None): dimension = len(x) if dimension == 1: return [copy.deepcopy(initial) for _ in range(x[0])] else: return [get_array(x[1:], initial) for _ in range(x[0])] def read_num(fin, num_type=int): tmp_list = [num_type(x) for x in fin.readline().strip().split()] if len(tmp_list) == 1: return tmp_list[0] else: return tuple(tmp_list) def read_num_list(fin, num_type=int): return [num_type(x) for x in fin.readline().strip().split()] def solve(fin): n = read_num(fin) f = read_num_list(fin) new_f = [0] + f for i in range(0, n): new_f[i] -= 1 f = new_f chs = get_array([n], []) for i, p in enumerate(f): if p >= 0: chs[p].append(i) q = [x for x in range(0, n) if not chs[x]] vis = [0] * n count = [0] * n while q: x = q.pop(0) if not chs[x]: count[x] = 1 if f[x] >= 0: vis[f[x]] += 1 if vis[f[x]] == len(chs[f[x]]): q.append(f[x]) count[f[x]] += count[x] count = sorted(count) print(' '.join([str(x) for x in count])) if __name__ == '__main__': if SUBMIT: solve(sys.stdin) else: solve(open(in_file_path, 'r'))",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",1256
"n = int(input()) if n == 1: print(1) else: adj = [[] for i in range(n+10)] s = input().split() for i in range(2,n+1): pi = int(s[i-2]) adj[i].append(pi) adj[pi].append(i) num = 1 curr = [1] nextcurr = [] disco = [1] visited = {1:True} while num < n: for v in curr: for w in adj[v]: if w not in visited: nextcurr.append(w) visited[w] = True disco.append(w) num += 1 curr = nextcurr nextcurr = [] nl = {} nlvals = {} for v in disco[::-1]: nl[v] = max(sum(nl.get(w,0) for w in adj[v]),1) nlvals[nl[v]] = nlvals.get(nl[v],0)+1 colors = {} leaves = nlvals[1] colors[1] = leaves for c in range(2, leaves+1): colors[c] = colors[c-1] + nlvals.get(c,0) ans = """" j = 1 for i in range(1, n+1): while colors[j] < i: j += 1 ans += str(j) + ' ' print(ans.strip())",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",749
"n = int(input()) p = [0,0] + [int(w) for w in input().split()] d = [0] * (n+1) for i in range(n, 1, -1): if d[i] == 0: d[i] = 1 d[p[i]] += d[i] if n == 1: d[1] = 1 d = d[1:] d.sort() print(*d)",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",192
"from operator import itemgetter n = int(input()) if n == 1: print(1) else: pi = list(map(int,input().split())) ai = [1] * (n+1) ai[0] = 10**9 for i in pi: ai[i] = 0 for i in range(n-2,-1,-1): ai[pi[i]] += ai[i+2] ai.sort() for i in range(n): print(ai[i],end="" "")",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",262
"n = int(input()) tr = {} p = [int(s) for s in input().split()] for i in range(n-1): if not tr.get(p[i]-1): tr[p[i]-1] = [] tr[p[i]-1].append(i+1) lc = [-1 for i in range(n)] def get_lc(i): if lc[i] == -1: if tr.get(i): lc[i] = 0 for j in tr[i]: lc[i] += get_lc(j) else: lc[i] = 1 return lc[i] for i in range(n-1, -1, -1): get_lc(i) print(*sorted(lc))",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",350
"n = int(input()) p = [0,0] + [int(w) for w in input().split()] d = [0] * (n+1) for i in range(n, 1, -1): if d[i] == 0: d[i] = 1 d[p[i]] += d[i] if n == 1: d[1] = 1 d = d[1:] d.sort() print(*d)",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",192
"n=int(input()) fa=[0,0]+list(map(int,input().split())) delta=[0]*(n+1) suml=[0]*(n+1) for i in range(n,0,-1): if suml[i]==0: suml[i]=1 delta[suml[i]]+=1 suml[fa[i]]+=suml[i] for i in range(1,n+1): delta[i]+=delta[i-1] ans=0 for i in range(1,n+1): while delta[ans]<i: ans+=1 print(""%d ""%ans,end="""") print(""\n"")",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",309
"n=int(input()) p=[0,0]+list(map(int,input().split())) d=[0]*(n+1) for i in range(n,1,-1): if d[i]==0: d[i]=1 d[p[i]]+=d[i] if n==1: d[1]=1 d=d[1:] d.sort() print(*d)",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",165
"from sys import stdin from collections import Counter class Node: def __init__(self,val): self.val=val self.forw=set() self.cou=0 def __str__(self): return f'{self.val} {self.forw} {self.cou}' n=int(stdin.readline()) arr=[Node(i) for i in range(1,n+1)] c=2 for x in map(int,stdin.readline().split()): arr[x-1].forw.add(c) c+=1 dct=Counter() lst = [1] while len(lst): fl = 0 for i in arr[lst[-1]-1].forw: lst.append(i) fl = 1 break if fl: arr[lst[-2]-1].forw.remove(i) if not fl: if arr[lst[-1]-1].cou ==0: arr[lst[-1]-1].cou=1 dct[arr[lst[-1]-1].cou]+=1 k=arr[lst.pop()-1].cou if len(lst):arr[lst[-1]-1].cou+=k y=1 for _ in range(n): while not dct[y]: y+=1 dct[y]-=1 print(y,end=' ')",linear,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",683
"import sys import string from math import gcd import getpass import math from decimal import Decimal def ria(): return [int(i) for i in input().split()] if getpass.getuser() != 'frohenk': filename = 'half' else: sys.stdin = open('input.txt') n = ria()[0] if n == 1: print(1) exit(0) if n == 2: print(1, 2) exit(0) if n == 3: print(1, 1, 3) exit(0) ar = [0] * 30 for i in range(30): ar[i] = n // (2 ** i) - n // (2 ** (i + 1)) sd = 0 for i in range(30): if sd == n - 1: if n==(2**i): print(2**i) else: print(n-n%(2**(i-1))) exit(0) for j in range(ar[i]): print(2 ** i, end=' ') sd += 1",linear,"['constructive algorithms', 'math']",584
"n = int(input()) if n == 1: print(""1"") elif n == 2: print(""1 2"") else: base = 1 gap = 2 cur = base next = 1 ans = '' for i in range(n - 1): ans += str(base) + ' ' next = cur cur += gap if cur > n: base *= 2 gap *= 2 cur = base next = max(next, cur) ans += str(next) print(ans)",linear,"['constructive algorithms', 'math']",276
"from sys import stdout def main(): n = int(raw_input()) k = 2 a = [] m = n while 1: t = n / k if t <= 1: k /= 2 a.extend([k] * m) a[-1] = n / k * k break a.extend([k / 2] * (m - t)) m = t k *= 2 stdout.write(' '.join(map(str, a))) main()",linear,"['constructive algorithms', 'math']",237
"def solve(n,k): print(1*k,end = ' ') if n==2: print(2*k,end = ' ') if n == 3: print(k,3*k,end = ' ') else: temp = n//2 if(n%2 == 0): temp -= 1 print((str(k)+' ')*temp,end='') if(n>3): solve(n//2,k*2) n = int(input()) solve(n,1)",linear,"['constructive algorithms', 'math']",227
"n = int(input()) a = [0]*n; def fun(n,ptr1): global a if n == 1: a[ptr1] = 1; elif n == 2: a[ptr1] = 1; ptr1+=1; a[ptr1] = 2; elif n == 3: a[ptr1] = 1; ptr1 +=1; a[ptr1] = 1; ptr1+=1; a[ptr1]=3; else: itera = n - n//2; for i in range(itera): a[ptr1] = 1; ptr1+=1; fun(n//2,ptr1); for i in range((n//2)): a[ptr1] = 2*a[ptr1]; ptr1+=1; fun(n,0); for i in a: print(i,end="" ""); print();",linear,"['constructive algorithms', 'math']",382
"from math import log2 n = int(input()) if n == 1: print(1) exit() elif n == 3: print(1, 1, 3) exit() l = [1] * (n // 2) if n % 2 == 1: l.append(1) xn = int(log2(n)) tmp = n - len(l) for i in range(2, xn+1): fn = tmp // 2 if tmp % 2 == 1: fn += 1 tmp -= fn l += ([pow(2, i-1)] * fn) l.append((n // pow(2, xn - 1)) * pow(2, xn - 1)) print(' '.join(str(i) for i in l))",linear,"['constructive algorithms', 'math']",365
"n = int(input()) res = [] multiplier = 1 while n > 1: new_n = n // 2 res.extend((multiplier,)*(n-new_n)) if n == 3: multiplier *= 3 else: multiplier *= 2 n = new_n res.extend((multiplier,)*n) print(*res)",linear,"['constructive algorithms', 'math']",203
"n, s = map(int, input().split()) res = 0 for i in range(n, 0, -1): res += s//i s = s % i print(res)",linear,"['greedy', 'implementation', 'math']",99
"n, s = map(int, input().split()) cnt = 0 for i in range(n, 0, -1): cnt += s // i s %= i print(cnt)",linear,"['greedy', 'implementation', 'math']",98
"n, s = map( int, input().split() ) ans = 0 while s > 0: a = s // n s -= n * a ans += a n -= 1 print( ans )",linear,"['greedy', 'implementation', 'math']",106
"def init_input(): import os from sys import stdin it = iter(os.read(stdin.fileno(), 10 ** 7).split()) return lambda: next(it).decode(), lambda: int(next(it)), lambda: float(next(it)) ns, ni, nf = init_input() MOD = 10 ** 9 + 7 n, q = ni(), ni() s = 'x' + ns() c = [0] * (n + 1) for i in range(1, n + 1): c[i] = c[i - 1] + (s[i] == '1') p2 = [1] * (2 * n + 1) for i in range(1, 2 * n + 1): p2[i] = p2[i - 1] * 2 % MOD out = [] for qq in range(q): l, r = ni(), ni() o = c[r] - c[l - 1] z = (r - l + 1) - o ans = (p2[o + z] - 1 - p2[z] + 1) % MOD out.append(ans) print(*out, sep='\n')",linear,"['greedy', 'implementation', 'math']",581
"import sys from math import * def minp(): return sys.stdin.readline().strip() def mint(): return int(minp()) def mints(): return map(int, minp().split()) def add(a,b): return (a+b)%1000000007 def mul(a,b): return (a*b)%1000000007 def sub(a,b): return (a-b+1000000007)%1000000007 def qpow(a, b): r = 1 k = a for i in range(17): if b & (1<<i): r = mul(r, k) k = mul(k, k) return r n, q = mints() a = list(minp()) c = [0]*(n+1) for i in range(n): c[i+1] = c[i] + int(a[i]) for i in range(q): l, r = mints() k = (r-l+1) o = c[r]-c[l-1] z = sub(qpow(2,o),1) print(mul(z,qpow(2,k-o)))",linear,"['greedy', 'implementation', 'math']",578
"import sys mod=10**9+7 n,q=map(int,sys.stdin.readline().split()) S=sys.stdin.readline().strip() LR=[list(map(int,sys.stdin.readline().split())) for i in range(q)] LIST=[0] for s in S: if s==""1"": LIST.append(LIST[-1]+1) else: LIST.append(LIST[-1]) def count(m,n,mod): return (pow(2,m,mod)-1)*pow(2,n,mod)%mod for l,r in LR: print(count(LIST[r]-LIST[l-1],r-l+1-LIST[r]+LIST[l-1],mod))",linear,"['greedy', 'implementation', 'math']",382
"import sys input_file = sys.stdin C = (10**9+7) [n, q] = list(int(i) for i in input_file.readline().split()) temp = input_file.readline() lst = [] for char in temp[:-1]: lst.append(int(char)) new_lst = [(0, 0)] for i in lst: if i == 0: new_lst.append((new_lst[-1][0]+1, new_lst[-1][1])) else: new_lst.append((new_lst[-1][0], new_lst[-1][1]+1)) ls = [1] for i in range(n): ls.append(ls[-1]*2 % C) for line in input_file: [l, r] = list(int(i) for i in line[:-1].split()) q = (new_lst[r][0] - new_lst[l-1][0], new_lst[r][1] - new_lst[l-1][1]) print((ls[sum(q)] - ls[q[0]]) % C)",linear,"['greedy', 'implementation', 'math']",574
"from sys import stdin,stdout n,q=map(int,input().split()) mod=1000000007 o=[] s=[] r=m=0 a=input() for i in a: if i=='0': r+=1 else: m+=1 o.append(r) s.append(m) z=[1] for i in range(100000): z.append((z[-1]*2)%mod) for j in range(q): l,r=(int(j) for j in stdin.readline().split()) m=r-l+1 zs=o[r-1]-o[l-1]+(a[l-1]=='0') os=m-zs if zs!=0: print((((z[os]-1)%mod)*((z[zs])%mod))%mod) else: print(((z[os]-1)%mod))",linear,"['greedy', 'implementation', 'math']",410
"n, q = map(int, raw_input().split()) l = raw_input() cnt1, cnt0 = [0]*(n+1), [0]*(n+1) mod = 10**9 + 7 for i in range(len(l)): if l[i] == '1': cnt1[i+1] = cnt1[i] + 1 cnt0[i+1] = cnt0[i] else: cnt0[i+1] = cnt0[i] + 1 cnt1[i+1] = cnt1[i] pow2 = [1] for i in range(1, 10**5 + 10): pow2.append((2*pow2[-1])%mod) for i in range(q): l, r = map(int, raw_input().split()) ones = cnt1[r] - cnt1[l-1] zeroes = cnt0[r] - cnt0[l-1] t1 = (pow2[ones] - 1)%mod t2 = (((pow2[ones] - 1)%mod)*(pow2[zeroes] - 1))%mod print((t1+t2)%mod)",linear,"['greedy', 'implementation', 'math']",518
"MOD = 1000000007 def main(): buf = input() buflist = buf.split() n = int(buflist[0]) q = int(buflist[1]) buf = input() x = buf sum_list = [0] for i, deliciousness in enumerate(x): sum_list.append(int(deliciousness) + sum_list[i]) enjoyment_list = [0] for i in range(n): enjoyment_list.append((enjoyment_list[i] * 2 + 1) % MOD) query_list = [] for i in range(q): buf = input() buflist = buf.split() l = int(buflist[0]) r = int(buflist[1]) query_list.append((l, r)) for i, query in enumerate(query_list): l = query[0] r = query[1] banhmi_count = r - l + 1 delicious_count = sum_list[r] - sum_list[l - 1] non_delicious_count = banhmi_count - delicious_count enjoyment = 0 if delicious_count == 0: enjoyment = 0 else: enjoyment += enjoyment_list[delicious_count] enjoyment += (enjoyment_list[banhmi_count] - enjoyment_list[delicious_count] - enjoyment_list[non_delicious_count]) enjoyment = enjoyment % MOD print(enjoyment) if __name__ == '__main__': main()",linear,"['greedy', 'implementation', 'math']",953
"from sys import * mod=1000000007 n,q=map(int,stdin.readline().split()) s=str(stdin.readline()) arr=[] count=0 for i in s: if(i=='1'): count+=1 arr.append(count) ansarr=[] for i in range(q): x,y=map(int,input().split()) if(x==1): total1=arr[y-1] else: total1=arr[y-1]-arr[x-2] total0=(y-x+1-total1) ans=pow(2,y-x+1,mod)%mod ans=((((ans%mod)-(pow(2,total0,mod)%mod))%mod)+mod)%mod ansarr.append(ans) stdout.write('\n'.join(map(str, ansarr)))",linear,"['greedy', 'implementation', 'math']",439
"import math if __name__ == '__main__': n,q = [int(x) for x in raw_input().split()] qq = str(raw_input()) s = [ int(x) for x in qq] prefix = [0]*n prefix[0]= s[0] temp = [0]*(n+1) temp[0]=1 mod = (pow(10,9)//1)+7 for i in range(1,n): prefix[i] += prefix[i-1] + s[i] temp[i] =( 2*(temp[i-1]%mod) )%mod temp[n] = (2*(temp[n-1]%mod))%mod ansarr=[] while q> 0: q-=1 l,r = [int(x)-1 for x in raw_input().split()] a = prefix[r]-prefix[l]+s[l] d = r-l+1 val1 = temp[d] val2 = temp[d-a] ansarr.append((val1-val2)%mod) print('\n'.join(map(str, ansarr)))",linear,"['greedy', 'implementation', 'math']",543
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, file=sys.stderr) dprint('debug mode') except Exception: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) N, = getIntList() re = 0 for i in range(2,N): t = N // i -1 re += t * i print(re *4)",linear,"['dfs and similar', 'graphs', 'implementation', 'math']",614
"import sys n=int(input()) if n<=3: print(0) sys.exit() score=0 import math def score(x): ANS=0 xr=math.ceil(math.sqrt(x)) LIST=[] for i in range(1,xr+3): if x%i==0: LIST.append(i) LIST.append(x//i) LIST=sorted(list(set(LIST))) for l in LIST[1:-1]: ANS+=x//l return ANS ANS=0 for i in range(4,n+1): ANS+=score(i) print(ANS*4)",linear,"['dfs and similar', 'graphs', 'implementation', 'math']",324
i = input() i = int(i) v = 0 g = 2 s = 4 while g <= i: while s <= i: v = v + int(s / g * 4) s = s + g g = g + 1 s = g * 2 print(str(v)),linear,"['dfs and similar', 'graphs', 'implementation', 'math']",135
n = int(input()) r = 0 i = 2 while i*2 <=n: a = int(n/i) r += (a+2)*(a-2+1)/2 i += 1 print(int(4*r)),linear,"['dfs and similar', 'graphs', 'implementation', 'math']",100
"n = int(input()) sum = 0 for i in range(2, n + 1): j = 2 while(j * i <= n): sum += i j += 1 print(4 * sum)",linear,"['dfs and similar', 'graphs', 'implementation', 'math']",106
"from math import sqrt, floor, ceil n = int(input()) ran = list(range(2, 1+n//2)) xx = [ d*(n//d-1) for d in ran] print(sum(xx)*4)",linear,"['dfs and similar', 'graphs', 'implementation', 'math']",129
"n = int(input()) rang = list(range(2,n//2+1)) a = [i*(n//i-1) for i in rang] print(sum(a)*4)",linear,"['dfs and similar', 'graphs', 'implementation', 'math']",92
"from __future__ import division from sys import stdin, stdout def write(x): stdout.write(str(x) + ""\n"") n = int(stdin.readline()) out = 0 for i in range(2, n + 1): out += 4 * (n // i - 1) * i write(out)",linear,"['dfs and similar', 'graphs', 'implementation', 'math']",202
"n=int(input()) c=0 for j in range(2,1+n//2): e=0 i=n//j e+=(i*(i+1))//2 e-=1 if e>0: c+=e print(c*4)",linear,"['dfs and similar', 'graphs', 'implementation', 'math']",100
"import math n,k=map(int,input().split()) edges=[] for i in range(n-1): edges.append(tuple(map(int,input().split()))) degreelist=[] for i in range(min(k+1,math.floor(math.log2(n))+10)): degreelist.append({}) degrees=degreelist[0] for i in range(1,n+1): degrees[i]=0 for guy in edges: degrees[guy[0]]+=1 degrees[guy[1]]+=1 small=[] center=None done=False for i in range(k): if not done: small=[] for guy in degrees: if degrees[guy]==2: print(""No"") done=True break if degrees[guy]==3: small.append(guy) if center==None: center=guy elif center!=guy: print(""No"") done=True break elif degrees[guy]>1: small.append(guy) degrees=degreelist[i+1] if center!=None and center not in small: if not done: print(""No"") done=True break elif len(small)==0: if not done: print(""No"") done=True break for guy in small: degrees[guy]=0 for guy in edges: if guy[0] in degrees and guy[1] in degrees: degrees[guy[0]]+=1 degrees[guy[1]]+=1 for guy in degrees: if degrees[guy]>1 and degreelist[i][guy]!=degrees[guy]: if not done: print(""No"") done=True break else: break if not done: if len(degreelist[-1])==1: print(""Yes"") else: print(""No"")",linear,"['dfs and similar', 'graphs', 'shortest paths']",1112
"from sys import exit n = int(input()) if n <= 10: for i in range(n): print(0, i) exit() print(0, 0) for i in range(4, n + 1, 3): k = (i // 3) * 2 print(k, 0) print(k - 1, 1) print(k - 2, 2) k = ((n + 1) // 3) * 2 if n % 3 == 0: print(k - 1, 1) print(k - 2, 2) elif n % 3 == 2: print(k - 2, 2)",linear,['constructive algorithms'],292
"n = int(input()) k = n // 3 ans = [] for i in range(k): ans += [(0, 2 * i)] ans += [(1, 2 * i + 1)] ans += [(2, 2 * i)] for i in range(n % 3): ans += [(-1000, -1000 + i)] res = """" for i in ans: res += "" "".join(map(str, i)) + ""\n"" print(res)",linear,['constructive algorithms'],240
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, **kwargs, file=sys.stderr) dprint('debug mode') except Exception: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) N, = getIntList() zz = ( (1,-1), (0,2), (1,-1) ) now = (0,0) for i in range(N): print(now[0],now[1]) now = ( now[0] + zz[i%3] [0] , now[1] + zz[i%3][1])",linear,['constructive algorithms'],692
"n = int(input()) print('0 0') n-=1 k = n // 2 p = n - k x = -k//2 while k > 0: if x != 0: print(x, 0) k -= 1 x += 1 y = -p//2 while p > 0: if y != 0: print(0, y) p -= 1 y += 1",linear,['constructive algorithms'],175
"n = int(input()) ans = [(0, 0)] for i in range(1, n): ans.append((0, i)) ans.append((i, 0)) ans.append((0, -i)) ans.append((-i, 0)) for i in range(n): print(str(ans[i][0]) + ' ' + str(ans[i][1]))",linear,['constructive algorithms'],195
"n= int(input()) for i in range(n//3): print(-2,1+i*2) for i in range(n-n//3): print(1,i)",linear,['constructive algorithms'],88
"n = int(input()) above = n // 3 below = n - above for i in range(above): print(2 * i + 1, 3) for i in range(below): print(i, 0)",linear,['constructive algorithms'],127
"n=int(input()) for i in range(n//3): print(2*i,0) print(2*i+1,0) print(2*i+1,3) for i in range(n%3): print(2*(n//3)+i,0)",linear,['constructive algorithms'],120
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) n = ii() a = li() b = li() done = set() j = 0 ans = [] for i in range(n): if b[i] in done: ans.append(0) else: c = 0 while a[j] != b[i]: done.add(a[j]) j += 1 c += 1 done.add(a[j]) j += 1 ans.append(c + 1) print(*ans)",linear,"['implementation', 'math']",318
"n = int(input()) ai = list(map(int,input().split())) bi = list(map(int,input().split())) ai2 = [0] * (n+1) n2 = 0 for i in range(n): num = 0 if ai2[bi[i]] != 1: for j in range(n2,n): ai2[ai[j]] = 1 if ai[j] == bi[i]: num = j + 1 - n2 n2 = j + 1 break print(num,end="" "")",linear,"['implementation', 'math']",269
"n=int(input()) a=list(map(int,input().split())) b=list(map(int,input().split())) ha={} for i in range(n): ha[a[i]]=i removed=0 out="""" for i in range(n): if ha[b[i]]<removed: out+=""0 "" else: out+=str(ha[b[i]]-removed+1)+"" "" removed=ha[b[i]]+1 print(out[:-1])",linear,"['implementation', 'math']",257
"n=int(input()) A=list(map(int,input().split())) B=list(map(int,input().split())) REVA=[None]*(n+1) for i in range(n): REVA[A[i]]=i+1 top=0 ANSLIST=[] for b in B: if REVA[b]>top: ANSLIST.append(REVA[b]-top) top=REVA[b] else: ANSLIST.append(0) for ans in ANSLIST: print(ans,end="" "")",linear,"['implementation', 'math']",280
"def main(): n = int(input()) arr = list(map(int, input().split())) numb = [0 for i in range(n + 1)] for i in range(len(arr)): numb[arr[i]] = i + 1 brr = list(map(int, input().split())) ind = 0 for c in brr: total = 0 num = numb[c] if num > ind: total = num - ind ind = num print(total, end=' ') main()",linear,"['implementation', 'math']",301
"def main(): n = int(input()) a = list(map(lambda x: int(x), input().split("" ""))) b = list(map(lambda x: int(x), input().split("" ""))) now = 0 ans = [] h = set() for i in range(n): count = 0 while b[i] not in h: h.add(a[now]) now += 1 count += 1 ans.append(str(count)) print("" "".join(ans)) if __name__ == '__main__': main()",linear,"['implementation', 'math']",321
"n = int(input().strip()) a = list(map(int,input().strip().split())) b = list(map(int,input().strip().split())) pos_of = [-1 for i in range(2*10**5+1)] for i,ele in enumerate(a): pos_of[ele]=i+1 current_pos = 0 ans=[] for i in b: if(pos_of[i]>current_pos): ans.append(pos_of[i]-current_pos) current_pos=pos_of[i] else: ans.append(0) print(' '.join(list(map(str,ans))))",linear,"['implementation', 'math']",367
"n = int(input()) a = input().split() d = {} k = 0 for i in range(len(a)): d[a[i]] = i for s in input().split(): if d[s] != -1: c = d[s] print(c - k + 1, end=' ') for i in range(k, c + 1): d[a[i]] = -1 k = c + 1 else: print(0, end=' ')",linear,"['implementation', 'math']",234
"n=int(input()) a=list(map(int,input().split())) b=list(map(int,input().split())) a=a[::-1] c=[0]*n bk=[] for i in range(n): co=0 if c[b[i]-1]==0: while a[-1]!=b[i]: co+=1 c[a[-1]-1]=1 a.pop() co+=1 c[a[-1]-1]=1 a.pop() bk.append(co) print(*bk)",linear,"['implementation', 'math']",243
"n, m = map(int, input().split()) xs = list(map(int, input().split())) ts = list(map(int, input().split())) ps = [x for x, t in zip(xs, ts) if t == 0] ds = [x for x, t in zip(xs, ts) if t == 1] ans = [0] * m di = 0 for pi, p in enumerate(ps): while di < m - 1 and abs(ds[di] - p) > abs(ds[di + 1] - p): di += 1 if di >= m: ans[m - 1] += n - pi break ans[di] += 1 print(' '.join(map(str, ans)))",linear,"['implementation', 'sortings']",392
"n, m = map(int, input().split()) xs = [int(k) for k in input().split()] ts = [int(k) for k in input().split()] pos = [-1 for i in range(n + m)] if ts[0]: pos[0] = 0 for i in range(1, n + m): pos[i] = pos[i - 1] if ts[i]: pos[i] += 1 result = [0 for i in range(m)] left = 0 leftC = 0 right = 0 rightC = 0 for i in range(n + m): if ts[i] == 0: right = max(i, right) while right + 1 < n + m and not ts[right]: right += 1 mP, mD = 0, 20000000 if ts[left]: mP = pos[left] mD = xs[i] - xs[left] if ts[right] and xs[right] - xs[i] < mD: mD = xs[right] - xs[i] mP = pos[right] result[mP] += 1 else: left = i print(*result)",linear,"['implementation', 'sortings']",614
"import sys, math from sys import stdin, stdout rem = 10 ** 9 + 7 inf=10**18 sys.setrecursionlimit(10 ** 6 + 7) take = lambda: map(int, stdin.readline().split()) from heapq import heappush, heappop, heapify from collections import deque from bisect import * n,m=take() arr=take() check=take() cnt=[0 for i in range(n+m)] left=[-1 for i in range(n+m)] right=[-1 for i in range(n+m)] prev=-1 for i in range(n+m): if check[i]==0: left[i]=prev else: prev=i prev=-1 for i in range(n+m-1,-1,-1): if check[i]==0: right[i]=prev else: prev=i for i in range(n+m): if check[i]==1: continue a=left[i] b=right[i] if a==-1 and b==-1: continue if a==-1 and b!=-1: cnt[b]+=1 if a!=-1 and b==-1: cnt[a]+=1 if a!=-1 and b!=-1: if abs(arr[i]-arr[a])<=abs(arr[i]-arr[b]): cnt[a]+=1 else: cnt[b]+=1 ans=[] for i in range(n+m): if check[i]==1: ans.append(str(cnt[i])) stdout.write(' '.join(ans))",linear,"['implementation', 'sortings']",872
"import sys from math import * def minp(): return sys.stdin.readline().strip() def mint(): return int(minp()) def mints(): return map(int, minp().split()) n,m = mints() a = list(mints()) b = list(mints()) l = [None]*(n+m) r = [None]*(n+m) c = [0]*(n+m) x = None for i in range(len(a)): l[i] = x if b[i] == 1: x = i x = None for i in range(len(a)-1,-1,-1): r[i] = x if b[i] == 1: x = i for i in range(len(a)): if b[i] == 0: aa = a[i] ll = l[i] rr = r[i] if ll == None: if rr != None: c[rr] += 1 elif rr == None: c[ll] += 1 else: if aa-a[ll] <= a[rr]-aa: c[ll] += 1 else: c[rr] += 1 for i in range(len(a)): if b[i] == 1: print(c[i], end=' ')",linear,"['implementation', 'sortings']",638
"def solve(n, m, x, t): r = [0] * n d = [0] * m ans = [0] * m cr = 0 cd = 0 for i in range(n+m): if t[i]: d[cd] = x[i] cd += 1 else: r[cr] = x[i] cr += 1 cn = 0 for i in range(m-1): mid = (d[i] + d[i+1]) // 2 while cn < n and r[cn] <= mid: cn += 1 ans[i] += 1 ans[-1] += n - sum(ans) return ' '.join(str(i) for i in ans) def main(): n, m = [int(i) for i in input().split()] x = [int(i) for i in input().split()] t = [int(i) for i in input().split()] print(solve(n, m, x, t)) main()",linear,"['implementation', 'sortings']",480
"n,m = map(int,input().split()) xi = list(map(int,input().split())) ti = list(map(int,input().split())) ai = [0] * (m+2) ar = [0] * (m+2) ar[-1] = 10**11 ar[0] = -100000000000 j = 1 n2 = n + m for i in range(n2): if ti[i] == 1: ar[j] = xi[i] j += 1 i1 = 0 i2 = 1 for i in range(n2): if ti[i] == 1: i2 += 1 i1 += 1 continue num = xi[i] - ar[i1] num2 = ar[i2] - xi[i] if num <= num2: ai[i1] += 1 else: ai[i2] += 1 for i in range(1,m+1): print(ai[i],end="" "")",linear,"['implementation', 'sortings']",454
"n, m = map(int, input().split()) dist = [int(x) for x in input().split()] taxi = [int(x) for x in input().split()] dists = {} d = [] for person in range(len(taxi)): if taxi[person]: dists[dist[person]] = 0 d.append(dist[person]) start = 0 d.append(10**11) for person in range(len(taxi)): if taxi[person] == 0: while dist[person] > d[start + 1]: start += 1 if abs(dist[person] - d[start]) <= abs(dist[person] - d[start + 1]): dists[d[start]] += 1 else: dists[d[start + 1]] += 1 for d in dists: print(dists[d] if d!=10**11 else '', end=' ')",linear,"['implementation', 'sortings']",538
"import sys num_riders, _ = map(int, next(sys.stdin).split()) houses = map(int, next(sys.stdin).split()) is_rider = map(int, next(sys.stdin).split()) current_left_driver = None current_citizens = [] result = [] for house, is_rider in zip(houses, is_rider): if is_rider: if current_left_driver is None: result.append(len(current_citizens)) else: result.append(0) for citizen in current_citizens: if abs(citizen - current_left_driver) <= abs(citizen - house): result[-2] += 1 else: result[-1] += 1 current_citizens = [] current_left_driver = house else: current_citizens.append(house) result[-1] += len(current_citizens) print(' '.join(map(str, result)))",linear,"['implementation', 'sortings']",651
"n, m = map(int, input().split()) arr = list(map(int, input().split())) t = list(map(int, input().split())) taxi = list() for i in range(len(arr)): if t[i] == 1: taxi.append(arr[i]) taxi2 = list() kek = 1 for i in range(len(taxi) - 1): taxi2.append([kek, taxi[i] + (taxi[i + 1] - taxi[i]) // 2]) kek = taxi[i] + (taxi[i + 1] - taxi[i]) // 2 + 1 taxi2.append([kek, arr[-1]]) taxi3 = [0] * m j = 0 for i in range(len(arr)): if arr[i] > taxi2[j][1]: j += 1 if t[i] != 1: taxi3[j] += 1 print("" "".join(map(str, taxi3)))",linear,"['implementation', 'sortings']",513
"n = int(input()) a = list(map(int, input().split())) b = [] c = [] e = [] for i in range(n): if a[i] == 1: b += [i] for i in range(n): if a[i] != 1: c += [[a[i], i]] if not c: print(""NO"") exit(0) ans = len(c) for i in range(len(c) - 1): e += [(c[i][1], c[i + 1][1])] c[i][0] -= 1 c[i + 1][0] -= 1 if b: e += [(b[-1], c[-1][1])] c[-1][0] -= 1 b.pop() ans += 1 if b: e += [(b[-1], c[0][1])] c[0][0] -= 1 b.pop() ans += 1 i = 0 while b: while i < len(c) and c[i][0] == 0: i += 1 if i == len(c): print(""NO"") exit(0) e += [(b[-1], c[i][1])] c[i][0] -= 1 b.pop() print(""YES"", ans - 1) print(len(e)) for (x, y) in e: print(x + 1, y + 1)",linear,"['constructive algorithms', 'graphs', 'implementation']",629
"from __future__ import division from sys import stdin, stdout def write(x): stdout.write(str(x) + ""\n"") n = int(stdin.readline()) a = map(int, stdin.readline().split()) assert n == len(a) cap = [0] + a[:] ones = [] others = [] for i in range(n): if a[i] == 1: ones.append(i + 1) else: others.append(i + 1) if len(others) == 0: if len(ones) == 1: write(""YES 0"") write(""0"") else: write(""NO"") exit() dia = len(others) graph = [] for j in range(len(others) - 1): graph.append((others[j], others[j + 1])) cap[others[j]] -= 1 cap[others[j + 1]] -= 1 if len(ones) > 0: this = ones.pop() graph.append((this, others[0])) cap[others[0]] -= 1 dia += 1 if len(ones) > 0: this = ones.pop() graph.append((this, others[-1])) cap[others[-1]] -= 1 dia += 1 done = False for j in range(len(others)): while cap[others[j]] > 0: if len(ones) > 0: this = ones.pop() graph.append((this, others[j])) cap[others[j]] -= 1 else: done = True break if done: break if len(ones) > 0: write(""NO"") else: write(""YES "" + str(dia - 1)) write(len(graph)) for a,b in graph: write(str(a) + "" "" + str(b))",linear,"['constructive algorithms', 'graphs', 'implementation']",1064
"def solve(): n = int(input()) max_degs = [int(x) for x in input().split()] B = [[i+1, x] for i, x in enumerate(max_degs) if x >= 2] S = [[i+1, x] for i, x in enumerate(max_degs) if x < 2] if 2 + sum(b - 2 for _, b in B) < len(S): print('NO') return print('YES', len(B) + min(len(S), 2) - 1) print(n-1) for k in range(len(B) - 1): i, x = B[k] i_n, _ = B[k+1] print(i, i_n) B[k][1] -= 1 B[k+1][1] -= 1 k = 0 for i, (s_idx, _) in enumerate(S): if i == 0: print(B[0][0], s_idx) B[0][1] -= 1 elif i == 1: print(B[-1][0], s_idx) B[-1][1] -= 1 else: while B[k][1] == 0: k += 1 print(B[k][0], s_idx) B[k][1] -= 1 solve()",linear,"['constructive algorithms', 'graphs', 'implementation']",612
"n = int(input()) T = input().split(' ') for i in range(n): T[i]=int(T[i]) L=[] M=[] t=0 ip=0 IP=[] for i in range(n): if T[i]>=2: L.append(i+1) M.append(T[i]) t+=T[i] else: ip+=1 IP.append(i+1) if t-(2*len(L)-2)<ip: print(""NO"") else: for i in range(1, len(L)-1): M[i]-=2 if len(L)>=2: M[0]-=1 M[-1]-=1 print(""YES"",end=' ') if ip==0: print(len(L)-1) elif ip==1: print(len(L)) else: print(len(L)+1) print(len(L)-1+ip) if ip>=1: print(IP[0], end=' ') print(L[0]) M[0]-=1 if ip>=2: print(IP[-1], end=' ') print(L[-1]) M[-1]-=1 k=1 ind=0 while k < ip-1: if M[ind]==0: ind+=1 else: print(IP[k], end=' ') print(L[ind]) M[ind]-=1 k+=1 for i in range(len(L)-1): print(L[i], end=' ') print(L[i+1])",linear,"['constructive algorithms', 'graphs', 'implementation']",687
"n = int(input()) a = [int(s) for s in input().split()] os = 0 oss = [] nos = 0 nos_0 = -1 nos_1 = -1 sumnos = 0 for i in range(n): if a[i] == 1: os += 1 oss.append(i+1) else: sumnos += a[i] nos += 1 if nos_0 == -1: nos_0 = i+1 nos_1 = i+1 if os <= sumnos-(2*(nos-1)): es = [] oss_i = 0 ans = nos-1 if os >= 1: ans += 1 es.append((nos_0, oss[0])) oss_i += 1 if os >= 2: ans += 1 es.append((nos_1, oss[1])) oss_i += 1 print(""YES"", ans) prev_nos = -1 for i in range(n): if a[i] > 1: if prev_nos != -1: es.append((prev_nos+1, i+1)) for j in range(a[i]-2): if oss_i >= os: break es.append((i+1, oss[oss_i])) oss_i += 1 prev_nos = i print(len(es)) for e in es: print(*e) else: print(""NO"")",linear,"['constructive algorithms', 'graphs', 'implementation']",682
"import sys n=int(input()) A=list(map(int,input().split())) if sum(A)<2*n-2: print(""NO"") sys.exit() ONES=A.count(1) print(""YES"",min(n-1,n-ONES+1)) NOONE=[] for i in range(n): if A[i]!=1: NOONE.append([A[i],i+1]) ANS=[] for i in range(1,len(NOONE)): ANS.append((NOONE[i-1][1],NOONE[i][1])) NOONE[i-1][0]-=1 NOONE[i][0]-=1 NOONE=[[1,NOONE[-1][1]]]+NOONE[0:-1]+[[NOONE[-1][0]-1,NOONE[-1][1]]] LENNO=len(NOONE) j=0 for i in range(n): while j<LENNO and NOONE[j][0]==0: j+=1 if A[i]!=1: continue ANS.append((i+1,NOONE[j][1])) NOONE[j][0]-=1 print(len(ANS)) for a,b in ANS: print(a,b)",linear,"['constructive algorithms', 'graphs', 'implementation']",576
"n=int(input()) a=list(map(int,input().split())) leaf=[i+1 for i in range(n) if a[i]==1] root_w=[i+1 for i in range(n) if a[i]!=1] root_r=[a[i-1]-2 for i in root_w] l_path=root_w if(len(leaf)!=0): l_path=[leaf[0]]+l_path leaf=leaf[1:] if(len(leaf)!=0): l_path=l_path+[leaf[0]] leaf=leaf[1:] if sum(root_r)<len(leaf): print(""NO"") else: print(""YES {}"".format(len(l_path)-1)) print(n-1) for i in range(len(l_path)-1): print(""{} {}"".format(l_path[i],l_path[i+1])) for l in leaf: while(len(root_r)>0 and root_r[0]==0): root_w = root_w[1:] root_r = root_r[1:] print(""{} {}"".format(l,root_w[0])) root_r[0] = root_r[0]-1",linear,"['constructive algorithms', 'graphs', 'implementation']",611
"n = int(input()) a = tuple(map(int, input().split())) if n * 2 > sum(a) + 2: print(""NO"") else: n1 = [] on = [] for i in range(n): if a[i] != 1: n1.append(i) else: on.append(i) print(""YES"", len(n1) + min(2, len(on)) - 1) print(n - 1) n1it = iter(n1) next(n1it) for v, u in zip(n1, n1it): print(v + 1, u + 1) if on: print(on.pop() + 1, n1[-1] + 1) if on: print(on.pop() + 1, n1[0] + 1) on = iter(on) for n11 in n1: for i in range(a[n11] - 2): try: print(n11 + 1, next(on) + 1) except StopIteration: break else: continue break",linear,"['constructive algorithms', 'graphs', 'implementation']",523
"from collections import namedtuple n = int(input()) vertex = namedtuple('vertex', ['degree', 'id']) a, b, c = [], [], 0 rr = list(map(int, input().split())) for i in range(n): tmp = rr[i] v = vertex(tmp, i + 1) if tmp > 1: a.append(v) else: b.append(v) c += tmp if c < (n - 1)*2: print('NO') else: if len(a) == 0: print('YES 1') print('1 2') else: print('YES', len(a) - 1 + min(2, len(b))) print(n - 1) for i in range(len(a)): if i == 0: continue print(a[i - 1].id, a[i].id) if len(b) > 0: print(b[0].id, a[0].id) if len(b) > 1: print(b[1].id, a[-1].id) j = 2 for i in range(len(a)): if j >= len(b): yes = 1 break k = a[i].degree - 2 yes = 0 for t in range(k): print(a[i].id, b[j].id) j += 1 if j >= len(b): yes = 1 break if yes == 1: break",linear,"['constructive algorithms', 'graphs', 'implementation']",740
"from collections import Counter n,c=map(int,input().split()) a=list(map(int,input().split())) counter=Counter() minus=0 count=a.count(c) maxi=0 for i in range(n): if a[i]!=c: if counter[a[i]]<minus: counter[a[i]]=minus counter[a[i]]+=1 maxi=max(maxi,counter[a[i]]+count-minus) else: minus+=1 print(max(maxi,minus))",linear,"['binary search', 'dp', 'greedy']",314
"import os,sys from io import BytesIO,IOBase def main(): n,c = map(int,input().split()) a = list(map(int,input().split())) nums = [[0] for _ in range(500001)] freq,minus = [0]*500001,0 for i in a: if i == c: minus += 1 else: freq[i] += 1 nums[i].append(freq[i]-minus) tot = minus suff = [i[:] for i in nums] for i in range(500001): for j in range(len(nums[i])-2,0,-1): suff[i][j] = max(suff[i][j],suff[i][j+1]) freq,ans = [0]*500001,tot for i in a: if i == c: continue freq[i] += 1 ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot) print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self,file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) self.newlines = b.count(b""\n"")+(not b) ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd,self.buffer.getvalue()) self.buffer.truncate(0),self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self,file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s:self.buffer.write(s.encode(""ascii"")) self.read = lambda:self.buffer.read().decode(""ascii"") self.readline = lambda:self.buffer.readline().decode(""ascii"") sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout) input = lambda:sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",linear,"['binary search', 'dp', 'greedy']",1903
"from __future__ import division from sys import stdin, stdout from collections import Counter def write(x): stdout.write(str(x) + ""\n"") n, c = map(int, stdin.readline().split()) a = map(int, stdin.readline().split()) assert len(a) == n tel = Counter() target_count_last = Counter() targets = 0 best = 0 for num in a: if num == c: targets += 1 else: since_last = targets - target_count_last[num] target_count_last[num] = targets tel[num] = max(0, tel[num] - since_last) tel[num] += 1 best = max(best, tel[num]) write(targets + best)",linear,"['binary search', 'dp', 'greedy']",531
"n, c = map(int, input().split()) res1 = [0] * 500001 res = 0 for ai in map(int, input().split()): res1[ai] = max(res1[ai], res1[c]) res1[ai] += 1 res = max(res, res1[ai] - res1[c]) print(res + res1[c])",linear,"['binary search', 'dp', 'greedy']",201
"n, c = map(int, input().split()) cnt = [0] * 500005 ans = 0 for v in map(int, input().split()): if v == c: cnt[c] = cnt[c] + 1 else: if cnt[v] < cnt[c]: cnt[v] = cnt[c] cnt[v] += 1 ans = max(ans, cnt[v] - cnt[c]) print(ans + cnt[c])",linear,"['binary search', 'dp', 'greedy']",232
"n,tar=[int(i) for i in input().split()] a=[int(i) for i in input().split()] from collections import defaultdict d=defaultdict(lambda:[]) count=0 for i in range(n): d[a[i]].append(i) if a[i]==tar: count+=1 presum=[1 if a[0]==tar else 0] for e in a[1:]: if e==tar: presum.append(presum[-1]+1) else: presum.append(presum[-1]) final = 0 for k,v in d.items(): if k==tar: continue t=1 tt=1 for i in range(1,len(v)): ind=v[i] preind=v[i-1] t -= presum[ind] - presum[preind] t=max(t,0) t+=1 tt=max(tt,t) final=max(final,tt) print(final + count)",linear,"['binary search', 'dp', 'greedy']",536
"t=list(map(int,input().split())) n=t[0] c=t[1] a=list(map(int,input().split())) f=[] for i in range(0,500001): f.append(0) l=[] for i in range(0,500001): l.append([0]) m=0 for i in range(n): l[a[i]].append(f[a[i]]-m) if a[i]==c: m+=1 f[a[i]]+=1 l[a[i]].append(f[a[i]]-m) ma=0 for i in l: mi=0 for j in i: if(j<mi): mi=j if(ma<j-mi): ma=j-mi print(m+ma)",linear,"['binary search', 'dp', 'greedy']",352
"n,val=map(int,input().split()); a=[0]+list(map(int,input().split())); suma=[0 for i in range(n+1)]; mx=0; target=0; for i in range(1,n+1): suma[i]=suma[i-1]; mx=max(mx,a[i]); if (a[i]==val): target+=1; suma[i]+=1; ans=0; pre=[0 for i in range(mx+1)]; dp=[0]; for i in range(1,n+1): dp.append(max(1,1+dp[pre[a[i]]]-suma[i]+suma[pre[a[i]]])); if (a[i]!=val): ans=max(ans,dp[i]); pre[a[i]]=i; print(ans+target);",linear,"['binary search', 'dp', 'greedy']",408
"n,c = map(int,input().split("" "")) nums = list(map(int,input().split("" ""))) cPast = 0 countC = 0 for value in nums: if value == c: countC += 1 def sawC(groupsList): for key,groups in groupsList.items(): if groups[-1] < 0: groups[-1] -= 1 else: groups += [-1] return groupsList solution = countC groupsList = {} for num in nums: if num == c: groupsList = sawC(groupsList) elif num in groupsList.keys(): if groupsList[num][-1] > 0: groupsList[num][-1] += 1 else: groupsList[num] += [1] else: groupsList[num] = [1] for key,groups in groupsList.items(): maxDiff = 1 currDiff = 0 newDiff = 0 for group in groups: currDiff += group if group > currDiff: currDiff = group if currDiff > maxDiff: maxDiff = currDiff if maxDiff + countC > solution: solution = countC + maxDiff print(solution)",linear,"['binary search', 'dp', 'greedy']",780
"from itertools import permutations, chain def get_plots(a,b): ax,ay = a bx,by = b for x in range(ax,bx,1 if ax < bx else -1): yield (x,ay) for y in range(ay,by,1 if ay < by else -1): yield (bx,y) def solve(points): for a,b,c in permutations(points): ax,ay = a bx,by = b cx,cy = c if min(ax,bx) <= cx <= max(ax,bx) and min(ay,by) <= cy <= max(ay,by): return list(chain(get_plots(a,c), get_plots(c,b), [b])) def it(): for a,b,c in permutations(points): ax,ay = a bx,by = b m = (ax,by) L = list(chain(get_plots(a,m),get_plots(b,m), get_plots(c,m), [m])) yield (len(L),L) return min(it())[1] points = [tuple(map(int,input().split())) for _ in range(3)] res = solve(points) print(len(res)) for x,y in res: print(x,y)",linear,"['greedy', 'implementation']",711
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) from collections import Counter n, s = mi() d = Counter() for i in range(n - 1): u, v = mi() d[u] += 1 d[v] += 1 l = sum(v == 1 for v in d.values()) ans = s / l * 2 print('%.10f' % (ans,))",linear,"['greedy', 'implementation', 'trees']",289
"n , s = map(int, input().split()) d = [0] * (n + 1) cnt = 0 for i in range(0 , n - 1): a , b = map(int, input().split()) d[a - 1] += 1 d[b - 1] += 1 for i in range(0 , n): if(d[i] == 1): cnt += 1 print(2.0 * s / cnt)",linear,"['greedy', 'implementation', 'trees']",216
"n,s=map(int,input().split()) a=[0]*(n+1) if n==2: print(s) exit(0) for _ in range(n-1): u,v=map(int,input().split()) a[u]+=1 a[v]+=1 print(2.0*s/a.count(1))",linear,"['greedy', 'implementation', 'trees']",156
"n,s=map(int,input().split()) degs=[0]*n for i in range(n-1): a,b=map(int,input().split()) degs[a-1]+=1 degs[b-1]+=1 print(2*s/degs.count(1))",linear,"['greedy', 'implementation', 'trees']",140
"n , s = map(int,input().split()) a = [0] * (n+1) for _ in range(n-1) : u , v=map(int, input().split()) a[u] += 1 a[v] += 1 print(2.0*s/a.count(1))",linear,"['greedy', 'implementation', 'trees']",146
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) from collections import Counter n, s = mi() d = Counter() for i in range(n - 1): u, v = mi() d[u] += 1 d[v] += 1 l = sum(v == 1 for v in d.values()) ans = s / l * 2 print('%.10f' % (ans,))",linear,"['greedy', 'implementation', 'trees']",289
"n,s = [int(x) for x in input().split()] v=[ [] ] for i in range(n): v.append([]) for i in range(n-1): a, b =[int(x) for x in input().split()] v[a].append(b) v[b].append(a) ans =0 for i in range(1,n+1): if len(v[i])==1: ans+=1 print(2*s/ans)",linear,"['greedy', 'implementation', 'trees']",240
"n, s = map(int, input().split()) l = [0 for i in range(n)] for i in range(n-1): a, b = map(int, input().split()) l[a-1]+=1 l[b-1]+=1 count = 0 for i in range(n): if(l[i]==1): count+=1 print((s/count)*2)",linear,"['greedy', 'implementation', 'trees']",202
"n=int(input()) l=list(map(int,input().split())) s=input() water=0 grass=0 cgrass=0 time=0 seen=False for i in range(n): if s[i]==""G"": dist=l[i] if water>=dist: water-=dist time+=2*dist cgrass+=dist else: dist-=water time+=2*water cgrass+=water water=0 time+=3*dist grass+=dist elif s[i]==""W"": water+=l[i] time+=2*l[i] seen=True else: dist=l[i] if water>=dist: water-=dist time+=2*dist else: dist-=water time+=2*water water=0 if cgrass>=dist: cgrass-=dist grass+=dist time+=3*dist else: dist-=cgrass grass+=cgrass time+=3*cgrass cgrass=0 if grass>=dist: grass-=dist time+=3*dist else: dist-=grass time+=3*grass grass=0 if seen: time+=4*dist else: time+=6*dist print(time)",linear,"['constructive algorithms', 'greedy']",670
"n=int(input()) l=list(map(lambda x:int(x)*2,input().split("" ""))) t=list(map(lambda x:""GWL"".index(x),input())) mins=[0 for i in range(0,n+1)] for i in range(n-1,-1,-1): if t[i]!=2:mins[i]=max(mins[i+1]-l[i],0) else:mins[i]=mins[i+1]+l[i] curs=ans=st=0 for i in range(0,n): if(t[i]==0): curs+=l[i];ans+=l[i]*5 if(curs>mins[i+1]): ol=(curs-mins[i+1])//2 ol=min(ol,l[i]) ans-=4*ol;curs-=2*ol if(t[i]==1): st=1;curs+=l[i];ans+=l[i]*3 if(t[i]==2): if(curs<l[i]): ol=l[i]-curs;curs=l[i] ans+=ol*(3 if st else 5) curs-=l[i];ans+=l[i] if curs>0:ans-=curs//2*2 print(ans//2)",linear,"['constructive algorithms', 'greedy']",564
"def read(type = 1): if type: file = open(""input.dat"", ""r"") n = int(file.readline()) a = list(map(int, file.readline().split())) b = file.readline() file.close() else: n = int(input().strip()) a = list(map(int, input().strip().split())) b = input().strip() return n, a, b def solve(): sol = 0 e = 0 big = 0 g = 0 for i in range(n): if b[i] == ""W"": big = 1 sol += 3 * a[i] e += a[i] if b[i] == ""G"": sol += 5 * a[i] e += a[i] g += 2*a[i] if b[i] == ""L"": sol += a[i] e -= a[i] if e < 0: if big: sol -= 3 * e else: sol -= 5 * e e = 0 g = min(e,g) if e: sol -= 2*g sol -= (e-g) return int(sol) n, a, b = read(0) sol = solve() print(sol)",linear,"['constructive algorithms', 'greedy']",630
"def read(type = 1): if type: file = open(""input.dat"", ""r"") n = int(file.readline()) a = list(map(int, file.readline().split())) b = file.readline() file.close() else: n = int(input().strip()) a = list(map(int, input().strip().split())) b = input().strip() return n, a, b def solve(): sol = 0 e = 0 big = 0 g = 0 for i in range(n): if b[i] == ""W"": big = 1 sol += 3 * a[i] e += a[i] if b[i] == ""G"": sol += 5 * a[i] e += a[i] g += 2*a[i] if b[i] == ""L"": sol += a[i] e -= a[i] if e < 0: if big: sol -= 3 * e else: sol -= 5 * e e = 0 g = min(g, e) if e: sol -= 2*g sol -= (e-g) return int(sol) n, a, b = read(0) sol = solve() print(sol)",linear,"['constructive algorithms', 'greedy']",631
"n=input() l=list(map(lambda x:int(x)*2,raw_input().split("" ""))) t=list(map(lambda x:""GWL"".index(x),raw_input())) mins=[0 for i in range(0,n+1)] for i in range(n-1,-1,-1): if t[i]!=2:mins[i]=max(mins[i+1]-l[i],0) else:mins[i]=mins[i+1]+l[i] curs=ans=st=0 for i in range(0,n): if(t[i]==0): curs+=l[i];ans+=l[i]*5 if(curs>mins[i+1]): ol=(curs-mins[i+1])//2 ol=min(ol,l[i]) ans-=4*ol;curs-=2*ol if(t[i]==1): st=1;curs+=l[i];ans+=l[i]*3 if(t[i]==2): if(curs<l[i]): ol=l[i]-curs;curs=l[i] ans+=ol*(3 if st else 5) curs-=l[i];ans+=l[i] if curs>0:ans-=curs//2*2 print(ans//2)",linear,"['constructive algorithms', 'greedy']",567
"n = int(input()) dis = list(map(lambda x: int(x) << 1, input().split())) ter = input() st, ans = 0, 0 time = {'G': 5, 'W': 3, 'L': 1} delta = {'G':1, 'W':1, 'L':-1} hasWater = False convert = 0 for i in range(n): st += dis[i] * delta[ter[i]] ans += dis[i] * time[ter[i]] if ter[i] == 'W': hasWater = True elif ter[i] == 'G': convert += dis[i] if st < 0: if hasWater: ans += (-st) * 3 else: ans += (-st) * 5 st = 0 convert = min(convert, st // 2) ans -= 4 * convert ans -= 2 * (st // 2 - convert) print(ans // 2)",linear,"['constructive algorithms', 'greedy']",511
"n = int(input()) a = list(map(int, input().split())) q = (10 ** 6) * [-1] pnt = -1 ans = ""YES"" for i in range(n): if pnt == -1: pnt += 1 q[pnt] = a[i] else : if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0: q[pnt] = -1 pnt -= 1 else: pnt += 1 q[pnt] = a[i] if pnt > 0 : ans = ""NO"" print(ans)",linear,"['greedy', 'implementation', 'math']",292
"n=int(input()) a=list(map(int,input().split())) b=0 for i in range(n): if a[i]%2==1: if i%2==0: b+=1 else: b-=1 if n%2==0: if b==0: print(""YES"") else: print(""NO"") else: if b==0 or b==1: print(""YES"") else: print(""NO"")",linear,"['greedy', 'implementation', 'math']",216
"import math n=int(input()) columns=list(map(int, input().rstrip().split())) modcolumns=[i%2 for i in columns] test=0 previouslist=[] for i in range(0,n): if len(previouslist)==0: previouslist.append(modcolumns[i]) elif modcolumns[i]==previouslist[-1]: previouslist.pop() else: previouslist.append(modcolumns[i]) if len(previouslist)<=1: print(""YES"") else: print(""NO"")",linear,"['greedy', 'implementation', 'math']",367
"n = int(input()) a = list(map(int, input().split())) b = [] for i in range(n): a[i] %= 2 if len(b) != 0: if b[-1] == a[i]: b.pop() else: b.append(a[i]) else: b.append(a[i]) if len(b) > 1: print(""NO"") else: print(""YES"")",linear,"['greedy', 'implementation', 'math']",218
"n = int(input()) a = [int(_) & 1 for _ in input().split()] v = [a[0]] for i in range(1, n): if v and v[-1] == a[i]: v.pop() else: v.append(a[i]) print(""NO"" if len(v) > 1 else ""YES"")",linear,"['greedy', 'implementation', 'math']",181
i = int(input()) s = input().split() l = [] for j in s: if not l or int(j)%2 != l[-1]: l.append(int(j)%2) else: l.pop() if len(l) < 2: print('YES') else: print('NO'),linear,"['greedy', 'implementation', 'math']",165
i = int(input()) s = input().split() l = [] for j in s: if not l or int(j)%2 != l[-1]: l.append(int(j)%2) else: l.pop() if len(l) < 2: print('YES') else: print('NO'),linear,"['greedy', 'implementation', 'math']",165
"def f(): b = [a[0]] for e in a[1:]: if b != []: if e == b[-1] or abs(e-b[-1])%2==0: b.pop() else: b.append(e) else: b.append(e) for i in range(1,len(b)): if abs(b[i]-b[i-1])%2: print('NO') return print('YES') n=int(input()) a=[int(i) for i in input().split()] f()",linear,"['greedy', 'implementation', 'math']",263
"n=int(input()) a=list(map(int,input().split())) st=[a[0]] for i in range(1,n): if len(st)>0 and st[-1]%2==a[i]%2: st.pop() else: st.append(a[i]) if len(st)<=1: print(""YES"") else: print(""NO"")",linear,"['greedy', 'implementation', 'math']",190
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, file=sys.stderr) dprint('debug mode') except Exception: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) N, = getIntList() zb = getIntList() za1 = [0] za2 = [zb[0]] for i in range(1, N//2): t1 = zb[i] - za1[-1] if t1 <= za2[-1]: za1.append(za1[-1]) za2.append(t1) continue t2 = zb[i] - za2[-1] if t2 >= za1[-1]: za1.append(t2) za2.append(za2[-1]) continue assert False zr = za1 + za2[ : :-1] zs = [] for x in zr: zs .append(str(x)) r = ' '.join(zs) print(r)",linear,['greedy'],882
"n = int(input()) b = list(map(int, input().split())) a1 = [0] a2 = [b[0]] for x in b[1:]: new_a = a1[-1] if x - new_a > a2[-1]: new_a = x - a2[-1] new_a2 = x - new_a a1.append(new_a) a2.append(new_a2) print(*(a1+a2[::-1]))",linear,['greedy'],222
"import math import collections import bisect import heapq import time import itertools import sys N = int(input()) B = [int(x) for x in input().split()] A = [0] * N i, j = N//2-1, N//2 A[i] = B[-1] // 2 A[j] = B[-1] // 2 if B[-1] % 2 == 0 else B[-1] // 2 + 1 l, r = A[i], A[j] for bi in range(len(B)-2, -1, -1): b = B[bi] i -= 1 j += 1 if b-l >= A[j-1]: A[i] = l A[j] = b-l r = b-l else: A[j] = r A[i] = b-r l = b-r print(' '.join(map(str, A)))",linear,['greedy'],444
"n=int(input())//2 a=list(map(int,input().split(' '))) b=[0]*n a.reverse() for i in a: b.append(i) mem=b[-1] c=0 for i in range(n-1): if b[-2-i]-c>mem: c=b[-2-i]-mem b[-2-i]-=c b[1+i]+=c mem=b[-2-i] for i in b: print(i,end=' ')",linear,['greedy'],226
"n = int(input()) b = list(map(int, input().split(' '))) a = [0] * n minV = 0 maxV = b[0] m = n //2 a[n - 1] = b[0] i = 1 j = n - 2 while(i < m): if(b[i] - minV > 0 and b[i] - minV <= maxV): a[i] = minV a[j] = b[i] - minV maxV = min(maxV, b[i] - minV) else: a[i] = b[i] - maxV a[j] = maxV minV = max(minV, b[i] - maxV) i += 1 j -= 1 print(' '.join(map(str, a)))",linear,['greedy'],360
"n = int(input()) b = list(map(int, input().split())) a = [0] * (2 * (len(b))) a[-1] = b[0] for i in range(1, len(b)): if b[i] - a[i - 1] <= a[-i]: a[i] = a[i - 1] a[-i - 1] = b[i] - a[i - 1] else: a[-i - 1] = a[-i] a[i] = b[i] - a[-i - 1] print(*a)",linear,['greedy'],248
"n = int(input()) b = list(map(int, input().split())) ff = [] ss = [] for i in b[::-1]: q = i f = q // 2 if q % 2: s = f + 1 else: s = f if len(ff) == 0: ff = [f] ss = [s] else: if f > ff[-1] or s < ss[-1]: d = max(f - ff[-1], ss[-1] - s) f -= d s += d ff.append(f) ss.append(s) print(*(ff[::-1] + ss))",linear,['greedy'],301
"import sys sys.setrecursionlimit(2000) from collections import Counter if __name__ == ""__main__"": n = [int(val) for val in input().split()][0] b = [int(val) for val in input().split()] l = 0 r = b[0] a = [0] * n for i in range(n//2): a[i] = l a[n-1-i] = r if(i != n//2-1): val = b[i+1] summ = l + r if(summ == val): continue elif(summ > val): diff = summ - val r -= diff elif(summ < val): diff = val - summ l += diff for i in a: print(i, end=' ') print('')",linear,['greedy'],456
n = int(input()) b = [int(w) for w in input().split()] a = [0]*n l = n//2 - 1 r = n//2 a[l] = b[l] // 2 a[r] = b[l] - a[l] while l > 0: if b[l-1] >= b[l]: a[l-1] = a[l] a[r+1] = b[l-1] - a[l] else: a[r+1] = a[r] a[l-1] = b[l-1] - a[r] l -= 1 r += 1 print(*a),linear,['greedy'],258
"def clc(mid): sm , i , cp = 0 , 1 , n cur = 1 while(cp + 1 > cur): sm = sm + i * cur i+= 1 cp -= cur cur = cur * mid return sm + i * cp n , s = map(int,input().split()) sm = n * (n + 1) // 2 dp = [0] * 100005 x = [0] * 100005 y = [0] * 100005 x[0] = 1 if s + 1 < 2 * n: print(""No"") exit() if s > sm: print(""No"") exit() else: print(""Yes"") l = 0 r = n while r - l > 1: mid = (r + l) // 2 if(clc(mid) > s): l = mid else: r = mid i = 2 while( i < n + 1): y[i] = i + r y[i] -= 2 y[i] = y[i] // r x[i] = x[y[i]] + 1 if(dp[x[i]] == 0): dp[x[i]] = i i = i + 1 mx = x[n] ip = n s = s - clc(r) while(s != 0): if(x[ip] != x[ip - 1]): ip = ip - 1; if(s > mx - x[ip]): y[ip] = dp[mx] mx = mx + 1 s -= mx - x[ip] x[ip] = mx dp[mx] = ip else: y[ip] = dp[s + x[ip] - 1] s = 0 ip = ip - 1 i = 2 while(i < n + 1): print(y[i]) i = i + 1",linear,"['binary search', 'constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']",817
"import math def f(n,k): if k==1: return (n*(n+1))//2 a=math.floor(math.log(n,k)) b=sum(k**i for i in range(a+1)) c=sum((i+1)*k**i for i in range(a+1)) if n<b: return c-(b-n)*(a+1) else: return c+(n-b)*(a+2) n,s=map(int,input().split()) if s==(n*(n+1))//2: print(""Yes"") a=[str(i+1) for i in range(n-1)] print("" "".join(a)) elif s>(n*(n+1))//2: print(""No"") elif s<2*n-1: print(""No"") else: mini=1 maxi=n-1 curr=1 while True: a,b=f(n,curr),f(n,curr+1) if b>s: mini=curr+1 curr=math.ceil((curr+maxi)/2) elif a<=s: maxi=curr-1 curr=(curr+mini)//2 else: opt=curr+1 break depths=[0,1]+[0]*(n-1) ins=1 ind=2 while True: a=min(opt**(ind-1),n-ins) depths[ind]=a ind+=1 ins+=a if ins==n: break left=s-b far=ind-1 bulk=ind-1 if depths[bulk]==1: bulk-=1 while left>0: if far+1-bulk<=left: far+=1 left-=far-bulk depths[far]+=1 depths[bulk]-=1 if depths[bulk]==1: bulk-=1 else: depths[bulk]-=1 depths[bulk+left]+=1 left=0 verts=[None]*far sumi=0 for i in range(far): verts[i]=list(range(sumi+1,sumi+1+depths[i+1])) sumi+=depths[i+1] out="""" for i in range(1,far): for j in range(len(verts[i])): out+=str(verts[i-1][j//opt])+"" "" print(""Yes"") print(out)",linear,"['binary search', 'constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']",1133
"n, s = map(int, input().split()) if not 2*n - 1 <= s <= n * (n+1) // 2: print('No') exit() print('Yes') def ok(d): dep, cur, sum, m = 2, 1, 1, 0 while cur + m < n: m += cur cur = min(n - m, cur * d) sum += cur * dep dep += 1 return sum <= s l, r = 1, n while l < r: mid = (l+r) // 2 if ok(mid): r = mid else: l = mid + 1 a, me = [l-1] * (n+1), [_ for _ in range(n+1)] sum, low = n * (n+1) // 2, 2 while n > low and sum > s: dest = min(sum-s, n-low) sum -= dest me[n] -= dest a[me[n]+1] += l a[me[n]] -= 1 if not a[low]: low += 1 n -= 1 me, l, dg = sorted(me[1:]), 0, 0 for i in me[1:]: while me[l] < i-1 or dg == r: dg = 0 l += 1 print(l+1, end=' ') dg += 1",linear,"['binary search', 'constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']",657
"import math EPS = 1e-6 hhh = None def solve(): n, M = [int(x) for x in input().split()] if out_of_solution_bounds(n, M): print('No') return b = find_optimal_b(n, M) heights = fast_find_optimal_height_distribution(n, M, b) parents = build_tree(n, b, heights) print('Yes') print(*parents[1:]) def out_of_solution_bounds(n, M): return M < 2*n - 1 or (n * (n+1)) // 2 < M def find_optimal_b(n, M): begin = 1 end = n while begin != end: mid = (begin + end) // 2 if get_min_H_given_b(n, mid) <= M: end = mid else: begin = mid + 1 b = end return b def get_min_H_given_b(n, b): if b == 1: return (n*(n+1)) // 2 m = math.floor(math.log((b-1)*n+1) / math.log(b) + EPS) nl = round((b**m - 1) / (b - 1)) return (m*b**(m+1) - (m+1)*b**m + 1) // (b - 1)**2 + (m+1) * (n - nl) def fast_find_optimal_height_distribution(n, M, b): begin = 0 end = n+1 H_fn = lambda L : (L*(L+1))//2 + get_min_H_given_b(n - L, b) + (L > 0)*(n - L) while begin != end: mid = (begin + end) // 2 if H_fn(mid) <= M: begin = mid + 1 else: end = mid L = begin - 1 if L == n: return [1 for _ in range(n)] unif_branch_h = uniform_height_distribution(n - L, b) if L == 0: h = unif_branch_h else: h = [int(i < L) for i in range(n)] for i, x in enumerate(unif_branch_h, 1): h[i] += x return locally_increase_H(h, M, b) def uniform_height_distribution(n, b): h = [0 for _ in range(n)] h[0] = 1 i = 0 to_fill = n-1 while to_fill > 0: i += 1 h[i] = min(b*h[i-1], to_fill) to_fill -= h[i] return h def locally_increase_H(h, M, b): i = 1 while not (b * (h[i-1]) >= (h[i] - 1) and b * (h[i] - 1) >= (h[i+1] + 1)): i += 1 H = sum(i*x for i, x in enumerate(h, 1)) while H < M: if b * (h[i-1] - 1) >= (h[i] + 1): i -= 1 else: while not b * (h[i] - 1) >= (h[i+1] + 1): i += 1 h[i] -= 1 h[i+1] += 1 H += 1 return h def build_tree(n, b, h): p = [None for _ in range(n)] p[0] = 1 i = 1 j = 0 for k in range(1, n): if j == h[i]: i += 1 j = 0 p[k] = k - j - h[i-1] + (j // b) + 1 j += 1 return p if __name__ == '__main__': solve()",linear,"['binary search', 'constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']",1969
"def good(max_branch, s, n): nodes = 0 can = 1 lowest_s = 0 depth = 1 while(nodes < n): added = min(n - nodes, can) lowest_s += added * depth nodes += added can *= max_branch depth += 1 return lowest_s <= s n, s = map(int, input().split()) if s < 2 * n - 1 or s * 2 > n * (n + 1): print('No') else: lo, hi = 1, n while lo < hi: mid = (lo + hi) >> 1 if good(mid, s, n) == False: lo = mid + 1 else: hi = mid max_branch = lo level_size = [1] * (n + 1) node_level = [i for i in range(n + 1)] cur_node = n cur_level = 1 cur_sum = n * (n + 1) // 2 can = 1 while cur_sum > s: if level_size[cur_level] == can: cur_level += 1 can *= max_branch if cur_sum - (cur_node - cur_level) < s: cur_level = cur_node - (cur_sum - s) node_level[cur_node] = cur_level level_size[cur_level] += 1 cur_sum -= cur_node - cur_level cur_node -= 1 node_list = [[] for _ in range(n + 1)] for i in range(1, n + 1): node_list[node_level[i]].append(i) pre = 0 children = [0] * (n + 1) parent = [-1] * (n + 1) seen_nodes = 1 for level in range(2, n + 1): idx = 0 if not node_list[level - 1]: assert seen_nodes == n break cur_father = node_list[level - 1][0] for node in node_list[level]: if children[cur_father] == max_branch: idx += 1 cur_father = node_list[level - 1][idx] children[cur_father] += 1 parent[node] = cur_father seen_nodes += 1 print('Yes') print(*parent[2:])",linear,"['binary search', 'constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']",1339
"n,v = map(int, input().split()) ans = min(v, n-1) for i in range(n - v - 1): ans += i+2 print(ans)",linear,"['dp', 'greedy', 'math']",98
"n, v = map(int, input().strip().split()) answer = 0 n -= 1 if n <= v: print(n) else: answer =v for i in range(1,n-v + 1): answer += (i + 1) print(answer)",linear,"['dp', 'greedy', 'math']",153
"from collections import defaultdict as dd import math def nn(): return int(input()) def li(): return list(input()) def mi(): return map(int, input().split()) def lm(): return list(map(int, input().split())) n,v=mi() dist=n-1 if v>=dist: print(dist) else: off=dist-v prices=[i+2 for i in range(off)] print(v+sum(prices))",linear,"['dp', 'greedy', 'math']",319
"def solve(n, v): fuel = min(n - 1, v) cost = fuel for i in range(2, n): if fuel >= n - 1: break fuel += 1 cost += i return cost n, v = map(int, input().split()) print(solve(n, v))",linear,"['dp', 'greedy', 'math']",179
"n, v = list(map(int, input().strip().split())) remaining_dist = n - 1 adding = min(remaining_dist, v) cost = adding remaining_dist -= adding i = 2 while remaining_dist > 0: cost += i i += 1 remaining_dist -= 1 print(cost)",linear,"['dp', 'greedy', 'math']",221
"n, v = map(int, raw_input().split()) res=0 fuel=0 for i in range(1,n): miss = min(v-fuel, n-i-fuel) res+=i*miss fuel+=miss-1 if v-fuel==0: print(res) exit(0) print(res)",linear,"['dp', 'greedy', 'math']",168
"def read_nums(): return [int(x) for x in input().split()] def main(): n, v = read_nums() res = 0 cur_tank = 0 for c in range(1, n+1): need_to_by = min(v - cur_tank, n - c - cur_tank) res += need_to_by * c cur_tank += need_to_by cur_tank -= 1 print(res) if __name__ == '__main__': main()",linear,"['dp', 'greedy', 'math']",286
"a,b=map(int,input().split()) if b>=a-1: print(a-1) else: summ=b k=a-b for i in range(2,k+1): summ+=i print(summ)",linear,"['dp', 'greedy', 'math']",112
"n, v = [int(item) for item in input().split()] x = 0 c = 0 for i in range(1, n): if x < n - i: c += i * min((n - i), v - x) x += min((n - i), v - x) x -= 1 print(c)",linear,"['dp', 'greedy', 'math']",164
"n = int(input()) s = input() b = 0 for i in s: if i == '+': b += 1 else: b -= 1 b = max(b, 0) print(b)",linear,"['implementation', 'math']",102
"def go(): n = int(input()) a = [i for i in input()] x = 0 for i in a: if i == '-': x = max(0, x - 1) else: x += 1 return x print(go())",linear,"['implementation', 'math']",134
"def main(): from sys import stdin, stdout def read(): return stdin.readline().rstrip('\n') def read_array(sep=None, maxsplit=-1): return read().split(sep, maxsplit) def read_int(): return int(read()) def read_int_array(sep=None, maxsplit=-1): return [int(a) for a in read_array(sep, maxsplit)] def write(*args, **kwargs): sep = kwargs.get('sep', ' ') end = kwargs.get('end', '\n') stdout.write(sep.join(str(a) for a in args) + end) def write_array(array, **kwargs): sep = kwargs.get('sep', ' ') end = kwargs.get('end', '\n') stdout.write(sep.join(str(a) for a in array) + end) n = read_int() s = read() stones = 0 for c in s: if c == '+': stones += 1 else: stones -= 1 if stones < 0: stones = 0 write(stones) main()",linear,"['implementation', 'math']",715
"n=int(input()) s=input() cur=0 for a in s: cur=max(cur,0) if(a=='-'): cur-=1 else: cur+=1 cur=max(cur,0) print(cur)",linear,"['implementation', 'math']",115
n=int(input()) s=input() ans=0 for i in s: if(i=='+'): ans+=1 else: ans-=1 if(ans<0): ans=0 print(ans),linear,"['implementation', 'math']",102
"n = int(input()) s = input() ans = 10000 for i in range(0, 105): f = True x = i for c in s: if c == '-': x -= 1 else: x += 1 if x < 0: f = False if f: ans = min(ans, x) print(ans)",linear,"['implementation', 'math']",179
"n = int(input()) s = input() maxn = 0 now = 0 for i in s: if i == '+': now += 1 else: now -= 1 maxn = max(maxn, -now) print(now + maxn)",linear,"['implementation', 'math']",135
"n = int(input()) s = input() t = 0 for i in s: if i == '+': t += 1 else: t = max(t - 1, 0) print(max(t, 0))",linear,"['implementation', 'math']",107
"n = int(input()) s = input() t = 0 mn = 0 for i in s: if i == '-': t-=1 else: t+=1 mn = min(mn, t) print(-mn+t)",linear,"['implementation', 'math']",111
"n = int(input()) nums = [int(x) for x in input().split()] ans = 10 ** 12 for idx, num in enumerate(nums): dist = max(idx, n - idx - 1) curr = num // dist ans = min(ans, curr) print(ans)",linear,"['implementation', 'math']",185
"def main(): from sys import stdin, stdout def read(): return stdin.readline().rstrip('\n') def read_array(sep=None, maxsplit=-1): return read().split(sep, maxsplit) def read_int(): return int(read()) def read_int_array(sep=None, maxsplit=-1): return [int(a) for a in read_array(sep, maxsplit)] def write(*args, **kwargs): sep = kwargs.get('sep', ' ') end = kwargs.get('end', '\n') stdout.write(sep.join(str(a) for a in args) + end) def write_array(array, **kwargs): sep = kwargs.get('sep', ' ') end = kwargs.get('end', '\n') stdout.write(sep.join(str(a) for a in array) + end) n = read_int() nums = read_int_array() out = nums[0] first = nums[0] for i in range(1, n): out = min(out, min(nums[i], first) // i) last = nums[-1] for i in range(n-2, 0, -1): out = min(out, min(nums[i], last) // (n-1 - i)) write(out) main()",linear,"['implementation', 'math']",818
"def main(): n = int(input()) arr = list(map(int, input().split())) ans = 10 ** 10 for i in range(n): x = i if i > n - i - 1 else n - i - 1 ans = min(ans, arr[i] // x) print(ans) main()",linear,"['implementation', 'math']",184
"n = int(input()) A = list(map(int, input().split())) k = 10 ** 10 for i in range(1, n - 1): k = min(k, min(A[0], A[i]) // i) k = min(k, min(A[-1], A[i]) // (n - i - 1)) k = min(k, min(A[0], A[-1]) // (n - 1)) print(k)",linear,"['implementation', 'math']",217
"n = int(input()) arr = list(map(int, input().split())) res = float('inf') for i in range(1, n): res = min(res, min(arr[i], arr[0]) // i) for i in range(n - 1): res = min(res, min(arr[i], arr[n - 1]) // (n - 1 - i)) print(res)",linear,"['implementation', 'math']",225
"n = int(input()) a = list(map(int, input().split())) ans = float('inf') for i in range(n): ans = min(ans, a[i] // max(i, n - i - 1)) print(ans)",linear,"['implementation', 'math']",143
"n = int(input()) a = list(map(int, input().split())) max1 = float('inf') for q in range(len(a)): if q >= n-q-1: max1 = min(max1, min(a[q], a[0])//q) if q <= n-q-1: max1 = min(max1, min(a[q], a[-1]) // (n-q-1)) print(max1)",linear,"['implementation', 'math']",221
"n=int(input()) a=list(map(int,input().split())) k=min(a[0],a[-1])//(n-1) for i in range(1,n-1): k=min(k,min(a[0],a[i])//i,min(a[i],a[-1])//(n-1-i)) print(k)",linear,"['implementation', 'math']",156
"n = int(input()) l = list( map( int, input().split() ) ) ans = max(l) for i in range(n): ans = min( ans, l[ i ] // max( i, n - i - 1 )) print( ans )",linear,"['implementation', 'math']",148
"import math n, m = map(int, input().split()) b = list(map(int, input().split())) g = list(map(int, input().split())) first_max = 0 second_max = 0 for i in range(n): if b[i] < first_max and b[i] > second_max: second_max = b[i] if b[i] >= first_max: second_max = first_max first_max = b[i] first_min = min(g) if first_max > first_min: print(-1) else: total = sum(b) * m + sum(g) - m * first_max + (first_max - second_max) * (first_min != first_max) print(total)",linear,"['greedy', 'implementation', 'math']",459
"n, m = map(int, input().split()) a = [] b = [] ma = 0 macount = 0 mi = 1000000000000000000000000000 su = 0 for el in map(int, input().split()): if el > ma: ma = el macount = 1 elif el == ma: macount += 1 a.append(el) for el in map(int, input().split()): mi = min(el, mi) b.append(el) su += el if ma > mi: print(-1) elif ma == mi or macount > 1: f = True for i in range(n): if a[i] == ma and f: f = False else: su += a[i] * m print(su) else: secmax = 0 for el in a: if el > secmax and el < ma: secmax = el f = True for i in range(n): if a[i] == ma and f: f = False else: su += a[i] * m print(su + ma - secmax)",linear,"['greedy', 'implementation', 'math']",608
"import sys def second_largest(numbers): count = 0 m1 = m2 = float('-inf') for x in numbers: count += 1 if x > m2: if x >= m1: m1, m2 = x, m1 else: m2 = x return m2 if count >= 2 else None n, m = map(int, input().split()) boys = list(map(int, input().split())) girls = list(map(int, input().split())) firstMax = max(boys) secondMax = second_largest(boys) minGrills = min(girls) minSum = 0 if firstMax > minGrills: print(-1) sys.exit() elif firstMax == minGrills: minSum = m * (sum(boys) - firstMax) + sum(girls) elif n == 1: print(-1) sys.exit() else: minSum = m * sum(boys) + sum(girls) - (m-1) * firstMax - secondMax print(minSum)",linear,"['greedy', 'implementation', 'math']",631
"n, m = map(int, input().split()) B = list(map(int, input().split())) G = list(map(int, input().split())) if min(G) < max(B): print(-1) exit(0) cnt = 0 z = max(B) y = 0 f = 1 f2 = 0 for i in B: if i != z or f2: y = max(y, i) else: f2 = 1 for i in G: if i == z: f = 0 cnt += i - z if f: cnt += z - y print(cnt + sum(B) * m)",linear,"['greedy', 'implementation', 'math']",321
"import sys import collections import math import heapq import bisect from operator import itemgetter def getint(): return int(input()) def getints(): return [int(x) for x in input().split(' ')] n, m = getints() b = getints() g = getints() result = 0 bMax, bMax2, bSum = -1, -1, 0 for i, bb in enumerate(b): bSum += bb if bb > bMax: bMax2, bMax = bMax, bb elif bb > bMax2: bMax2 = bb gMin, gSum = float('inf'), 0 for j, gg in enumerate(g): gSum += gg if gg < gMin: gMin = gg if bMax > gMin: result = -1 else: result = bSum * m result += gSum result -= bMax * m if gMin > bMax: result += bMax - bMax2 print(str(result))",linear,"['greedy', 'implementation', 'math']",617
"import os import sys from math import * from collections import * from heapq import * from bisect import * from io import BytesIO, IOBase def vsInput(): sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") ALPHA='abcdefghijklmnopqrstuvwxyz' M = 998244353 EPS = 1e-6 def Ceil(a,b): return a//b+int(a%b>0) def value():return tuple(map(int,input().split())) def array():return [int(i) for i in input().split()] def Int():return int(input()) def Str():return input() def arrayS():return [i for i in input().split()] for _ in range(1): n,k = value() rep = [1] + [0]*((n-k)//2) cur = 0 ans = [] j = 0 for i in range(n): ans.append(rep[j]) j",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",1998
"n,k = map(int, input().split()) d = (n-k)//2+1 ans = ['1' if (i+1)%d==0 else '0' for i in range(n)] print(''.join(ans))",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",119
"N, K = map(int, input().split()) if N == K: print(""0""*N) elif K == 1: print(""0""*(N-1) + ""1"") elif K == 3: print(""1"" + ""0""*(N-4) + ""101"") else: res = [""0""]*N for i in range(0, N, N//2-K//2+1): res[i] = ""1"" print(''.join(res))",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",224
"import os import sys def log(*args, **kwargs): if os.environ.get('CODEFR'): print(*args, **kwargs) n, k = tuple(map(int, input().split())) s = '0'*((n-k)//2) + '1' for i in range(n): print(s[i % len(s)], end='') print()",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",219
"n, k = list(map(int,input().split())) chuj_twojej_starej = (n - k) // 2 + 1 i = 1 while True: if i % chuj_twojej_starej == 0: print(0, end = """") else: print(1, end = """") if i == n: break i += 1",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",193
"n, k = map(int, input().split()) strr = """" while len(strr) < n: strr += ""0"" * ((n-k) // 2) + ""1"" strr = strr[:n] print(strr)",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",124
"n, k = [int(x) for x in input().split()] ans = """" while len(ans) < n: ans += '1' * ((n - k) // 2) + '0'; ans = ans[:n] print(ans)",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",129
"n,k=map(int,input().strip().split()) d=(n-k)//2+1 x=['1' if (i+1)%d==0 else '0' for i in range(n)] print(''.join(x))",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",116
"n,k=map(int,input().split()) d=(n-k)//2 s=0 while s!=n: if (s+1)%(d+1)==0: print(""1"",end="""") else : print(""0"",end="""") s+=1",linear,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",122
"import sys input = sys.stdin.readline from collections import deque N, Q = map(int, input().split()) que = deque([int(a) for a in input().split()]) ma = max(que) X = [] k = -1 c = 0 while c <= k+N+5: a = deque.popleft(que) b = deque.popleft(que) X.append((a, b)) c += 1 if a > b: a, b = b, a if k < 0 and b == ma: k = c deque.appendleft(que, b) deque.append(que, a) for _ in range(Q): i = int(input()) - 1 if i <= k: print(*X[i]) else: i = (i-k)%(N-1)+k print(*X[i])",linear,"['data structures', 'implementation']",466
"from collections import defaultdict as dd, deque import sys,atexit from io import BytesIO inp = BytesIO(sys.stdin.buffer.read()) input = lambda:inp.readline().decode('ascii') buf = BytesIO() sys.stdout.write = lambda s: buf.write(s.encode('ascii')) atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue())) n,q = map(int,input().split()) S = [int(x) for x in input().split()] Q = deque(S) n = len(Q) res = [] for i in range(n): a = Q.popleft() b = Q.popleft() Q.appendleft(max(a,b)) Q.append(min(a,b)) res.append((a,b)) A = list(Q) def solve(t): if t < len(res): return res[t-1] t -= len(res) + 1 t %= n-1 return A[0],A[t+1] for _ in range(q): t = int(input()) print(*solve(t))",linear,"['data structures', 'implementation']",687
"import sys input = sys.stdin.readline from collections import deque n,q=map(int,input().split()) A=deque(map(int,input().split())) Q=[int(input()) for i in range(q)] ANS=[0] for l in range(10**5+1): x=A.popleft() y=A.popleft() ANS.append((x,y)) if x>y: A.appendleft(x) A.append(y) else: A.appendleft(y) A.append(x) ANS0=A[0] B=list(A)[1:] for q in Q: if q<=10**5+1: print(*ANS[q]) else: print(ANS0,B[(q-10**5-2)%(n-1)])",linear,"['data structures', 'implementation']",419
"n, q = map(int, input().split()) nums = list(map(int, input().split())) m = max(nums) ab = [] while nums[0] < m: ab.append([nums[0], nums[1]]) nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0)) for i in range(q): mj = int(input()) a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1])) print(a + "" "" + b)",linear,"['data structures', 'implementation']",363
"n,q = map(int, raw_input().split()) nums = list(map(int, raw_input().split())) m = max(nums) ab = [] while nums[0] < m: ab.append([nums[0], nums[1]]) nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0)) for i in range(q): mj = int(input()) a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1])) print(a + "" "" + b)",linear,"['data structures', 'implementation']",370
"from collections import deque n, q = map(int, input().split()) a = deque(map(int, input().split())) b = [] m = a.index(max(a)) for i in range(m): a0, a1 = a.popleft(), a.popleft() b.append([a0, a1]) if a0 < a1: a0, a1 = a1, a0 a.appendleft(a0) a.append(a1) for i in range(q): c = int(input()) if c <= m: print('{} {}'.format(b[c-1][0], b[c-1][1])) else: c -= m+1 c %= n-1 print('{} {}'.format(a[0], a[c+1]))",linear,"['data structures', 'implementation']",407
"from sys import stdin,stdout input=stdin.readline def count(audrey,imba,banget): return((imba-audrey-1)%(banget-1)) n,q=map(int,input().split()) L=list(map(int,input().split())) maxi=max(L) indexmax=L.index(maxi) P=[] for i in range(indexmax): P.append((L[0],L[1])) if L[0]<L[1]: L.append(L.pop(0)) else: L.append(L.pop(1)) Y=tuple(L[1:]) for p in range(q): m=int(input()) if m<=indexmax: print(str(P[m-1][0])+' '+str(P[m-1][1])) else: stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",linear,"['data structures', 'implementation']",496
"from sys import stdin,stdout def count(audrey,imba,banget): return((imba-audrey-1)%(banget-1)) n,q=map(int,input().split()) L=list(map(int,input().split())) maxi=max(L) indexmax=L.index(maxi) P=[] for i in range(indexmax): P.append((L[0],L[1])) if L[0]<L[1]: L.append(L.pop(0)) else: L.append(L.pop(1)) Y=tuple(L[1:]) for p in range(q): m=int(stdin.readline()) if m<=indexmax: print(str(P[m-1][0])+' '+str(P[m-1][1])) else: stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",linear,"['data structures', 'implementation']",484
"n,queries = list(map(int,input().split())) l = list(map(int,input().split())) if(queries==0): exit() maxval = max(l) pairs = [] count = 0 f = l[0] secix = 1 while(f!=maxval): count+=1 f = l[0] s = l[secix] pairs.append([f,s]) f,s= max(f,s), min(f,s) l[0] = f l.append(s) secix+=1 l = [l[0]]+l[secix:] for i in range(n-1): pairs.append([maxval,l[1+i]]) for m in range(queries): q = int(input()) if(q<=count): print(str(pairs[q-1][0]),str(pairs[q-1][1])) else: q-=(count+1) pos = count+(q%(n-1)) print(str(pairs[pos][0]),str(pairs[pos][1]))",linear,"['data structures', 'implementation']",538
"n = int(input()) ans = 1 for i in range(1, n): ans += i * 4 print(ans)",linear,"['dp', 'implementation', 'math']",70
n = int(input()) ans = 1 for i in range(n): ans += i * 4 print(ans),linear,"['dp', 'implementation', 'math']",67
"def getN(): return int(input()) def getList(): return list(map(int, input().split())) n = getN() mid = n * 2 -1 ans = -mid while(mid > 0): ans += mid*2 mid -= 2 print(ans)",linear,"['dp', 'implementation', 'math']",171
"n = int(input()) summ = 1 for i in range(1, n): summ+=i*4 print(summ)",linear,"['dp', 'implementation', 'math']",69
n = int(input()) ans = 1 for i in range(n): ans += 4 * i print(ans),linear,"['dp', 'implementation', 'math']",67
import math import sys n = int(input()) r = 0 t = 1 for i in range(n-1): r += t*2 t += 2 print(r + t),linear,"['dp', 'implementation', 'math']",101
n = int(input()) wyn = 1 x = 4 for i in range(n - 1): wyn += x x += 4 print(wyn),linear,"['dp', 'implementation', 'math']",80
"n=int(input()) answer=0 for i in range(1,2*n-2,2): answer+=i print(answer*2+2*n-1)",linear,"['dp', 'implementation', 'math']",82
"import sys import os from io import IOBase, BytesIO def main(): n = int(input()) x = 2 * n - 1 ans = x x -= 2 curr = 0 while x > 0: curr += x x -= 2 print(ans + 2 * curr) BUFSIZE = 8192 class FastIO(BytesIO): newlines = 0 def __init__(self, file): self._file = file self._fd = file.fileno() self.writable = ""x"" in file.mode or ""w"" in file.mode self.write = super(FastIO, self).write if self.writable else None def _fill(self): s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0]) return s def read(self): while self._fill(): pass return super(FastIO, self).read() def readline(self): while self.newlines == 0: s = self._fill() self.newlines = s.count(b""\n"") + (not s) self.newlines -= 1 return super(FastIO, self).readline() def flush(self): if self.writable: os.write(self._fd, self.getvalue()) self.truncate(0), self.seek(0) class IOWrapper(IOBase): def __init__(self, file): py2 = round(0.5) self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable if py2 == 1: self.write = self.buffer.write self.read = self.buffer.read self.readline = self.buffer.readline else: self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def get_array(): return list(map(int, sys.stdin.readline().split())) def get_ints(): return map(int, sys.stdin.readline().split()) def input(): return sys.stdin.readline().strip() if __name__ == ""__main__"": main()",linear,"['dp', 'implementation', 'math']",1651
"n = int(input()) A = list(map(int, input().split())) if n == 1: if A[0] >= 0: print(A[0]) else: print(-A[0]-1) exit(0) for i in range(n): if A[i] < 0: pass else: A[i] = -A[i]-1 if n % 2 == 0: print(*A) exit(0) mim = 0 indmim = 0 for i in range(n): if A[i] < mim: mim = A[i] indmim = i A[indmim] = -A[indmim]-1 print(*A)",linear,"['greedy', 'implementation']",319
"n = int(input()) l = list(map(int,input().split())) m = 0 for i in range(n): if l[i] >= 0: l[i] = -l[i] - 1 for i in range(n): if l[i] < 0 : m += 1 if m % 2 == 0: for i in range(n): print(l[i], end = "" "") else: maksi = -1000000000000 for i in range(n): if abs(l[i]) > maksi: maksi = abs(l[i]) mk = i l[mk] = -l[mk] - 1 for i in range(n): print(l[i], end = "" "")",linear,"['greedy', 'implementation']",360
"n = int(input()) a = list(map(int, input().split())) for i in range(n): if a[i]>=0: a[i] = -a[i]-1 x = min(a) if len(a)%2==1: for i in range(n): if a[i]==x: a[i] = -a[i]-1 break print(*a)",linear,"['greedy', 'implementation']",187
"import sys from heapq import heappush, heappop, heapify sys.setrecursionlimit(int(1e7)) def main(): n = int(input().strip()) a = [int(x) for x in input().split()] a = [-x-1 if x>=0 else x for x in a] if n%2==1: _, i = min((x,i) for i,x in enumerate(a)) a[i] = -a[i]-1 print(*a) return while 1: try: main() except EOFError: break",linear,"['greedy', 'implementation']",328
"n=int(input()) l1=list(map(int,input().split())) if n%2==0: for i in range(n): if l1[i]>=0: l1[i]=-1*l1[i]-1 else : for i in range(n): if l1[i]>=0: l1[i]=-1*l1[i]-1 l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1 print(' '.join(str(x) for x in l1))",linear,"['greedy', 'implementation']",250
"n = int(input()) a = [] for i in map(int, input().split()): if abs(-i-1)>abs(i): a.append(-i-1) else: a.append(i) c = 0 for i in a: if i<0: c+=1 if c%2: me=0 for i in range(len(a)): if a[i]<a[me]: me=i a[me]=-a[me]-1 print(*a)",linear,"['greedy', 'implementation']",226
"import sys n = int(sys.stdin.readline().strip()) a = list(map(int,sys.stdin.readline().strip().split())) for i in range (0, n): if a[i] >= 0: a[i] = - a[i] - 1 if n % 2 == 1: i = a.index(min(a)) a[i] = - a[i] - 1 a = list(map(str,a)) print("" "".join(a))",linear,"['greedy', 'implementation']",252
"n = int(input()) a = list(map(int, input().split())) max_mod = 0 max_i = -1 for i in range(n): if a[i] >= 0: a[i] = -a[i] - 1 if -a[i] > max_mod: max_mod = -a[i] max_i = i if n % 2 == 1: a[max_i] = -a[max_i] - 1 print(' '.join(list(map(str, a))))",linear,"['greedy', 'implementation']",246
"n = int(input()) a = list(map(int,input().split())) for i in range(n): if a[i] >= 0: a[i] = -a[i]-1 if n%2: m = min(a) for i in range(n): if a[i] == m: a[i] = -a[i]-1 break print(*a)",linear,"['greedy', 'implementation']",182
"from sys import setcheckinterval,stdin setcheckinterval(1000) iin=lambda :int(stdin.readline()) lin=lambda :list(map(int,stdin.readline().split())) n,q=lin() a=lin() if q==0: exit() Q=[iin() for i in range(q)] sq=set(Q) mx=max(Q) d=dict() ch=1 for i in range(min(mx,n+1)): if ch==n: ch=1 if i+1 in sq:d[i+1]=[a[0],a[ch]] if a[0]<a[ch]: a[0],a[ch]=a[ch],a[0] ch+=1 for i in Q: if i>n: x=n-1 if i%(n-1)==0 else i%(n-1) print(a[0],a[x]) else: print(*d[i])",linear,"['data structures', 'implementation']",452
"import sys n, q = list(map(int,sys.stdin.readline().strip().split())) a = list(map(int,sys.stdin.readline().strip().split())) m = [0] * q M = max(a) i = 0 x = a[0] L = [] L1 = [] L2 = [] while x != M: L1.append(x) L2.append(a[i+1]) i = i + 1 if x < a[i]: L.append(x) x = a[i] else: L.append(a[i]) b = a[i+1:] + L for j in range (0, q): m = int(sys.stdin.readline().strip()) if m <= i: print(str(L1[m-1]) + "" "" + str(L2[m-1])) else: print(str(x) + "" "" + str(b[(m - i - 1) % (n-1)]))",linear,"['data structures', 'implementation']",481
"def getN(): return int(input()) def getList(): return list(map(int, input().split())) from collections import deque n, m = getList() nums = getList() mxnum = max(nums) d = deque(nums) qr = [] for i in range(m): qr.append(getN()) log = [] rot = 0 while(True): a = d.popleft() b = d.popleft() log.append((a, b)) if a > b: a, b = b, a d.append(a) d.appendleft(b) rot += 1 if b == mxnum: break for q in qr: if q <= rot: print(log[q - 1][0], log[q - 1][1]) else: res = q - rot - 1 print(b, d[res % (n-1) + 1 ])",linear,"['data structures', 'implementation']",505
"import sys input = sys.stdin.readline def ii(): return int(input()) def mi(): return map(int, input().rstrip().split()) def lmi(): return list(map(int, input().rstrip().split())) def li(): return list(input().rstrip()) if __name__ == '__main__': n,q = mi() a = lmi() i = 0 max_a = max(a) t = a.index(max_a) last = a[0] Lis = [] tmp = [] for i in range(1, t + 1): Lis.append((last,a[i])) if last < a[i]: tmp.append(last) last = a[i] else: tmp.append(a[i]) anslist = a[t+1:] + tmp for i in range(q): tm = ii() if 1 <= tm <= t: print(Lis[tm - 1][0],Lis[tm - 1][1]) else: print(max_a,anslist[(tm-t-1)%len(anslist)])",linear,"['data structures', 'implementation']",611
"import sys mod=(10**9)+7 from sys import stdin, stdout import bisect from bisect import bisect_left as bl from bisect import bisect_right as br import itertools import collections import math import heapq from random import randint as rn from Queue import Queue as Q def modinv(n,p): return pow(n,p-2,p) def ncr(n,r,p): t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p return t def ain(): return map(int,sin().split()) def sin(): return stdin.readline().strip() def GCD(x,y): while(y): x, y = y, x % y return x def isprime(x): if(x==1): return False elif(x<4): return True for i in range(2,int(math.sqrt(x))+1): if(x%i==0): return False return True n,q=ain() a=ain() g=max(a) d=collections.deque(a) f=0 an1=[] while(d[0]!=g): f+=1 x=d.popleft() y=d.popleft() an1.append(str(x)+"" ""+str(y)) if(y==g): d.appendleft(y) d.append(x) break if(x<y): d.appendleft(y) d.append(x) else: d.appendleft(x) d.append(y) r=[] ans=[] for i in range(n): r.append(str(d.popleft())) for i in range(q): b=int(sin()) if(b<=f): ans.append(an1[b-1]) else: b-=f b-=1 b%=(n-1) ans.append(r[0]+"" ""+r[b+1]) stdout.write(""\n"".join(ans))",linear,"['data structures', 'implementation']",1099
"n, q = map(int,input().split()) ai = list(map(int,input().split())) ar = [] ar3 = [] num = 1 nummm = max(ai) if ai[0] != nummm: num2 = ai[0] for i in range(1,n): ar3 += [[num2,ai[i]]] if ai[i] == nummm: ar += [num2] num = i+1 break if ai[i] > num2: ar += [num2] num2 = ai[i] else: ar += [ai[i]] ar2 = [] for i in range(num,n): ar2 += [ai[i]] for i in range(len(ar)): ar2 += [ar[i]] num = len(ar3) for i in range(q): m = int(input()) if m <= num: print(ar3[m-1][0],ar3[m-1][1]) else: m -= num m -= 1 print(nummm,ar2[m % (n-1)])",linear,"['data structures', 'implementation']",526
"INF = 1000_000_000 from collections import deque t = 1 for test in range(t): n,q = map(int, input().split()) arr = list(map(int, input().split())) maxval = max(arr) d = deque(arr) ans = {} count = 1 while d[0]!=maxval: a = d.popleft() b = d.popleft() ans[count] = (a,b) count+=1 d.append(min(a,b)) d.appendleft(max(a,b)) n = n-1 for i in range(q): m = int(input()) if m in ans: print(ans[m][0],ans[m][1]) else: m = m - count print(maxval, d[1+(m%n)])",linear,"['data structures', 'implementation']",450
"import sys import math input = sys.stdin.readline n,q=map(int,input().split()) arr=list(map(int,input().split())) for i in range(n): arr.append(0) maxx=0 ind=arr.index(max(arr)) ans=[] ptr1=0 ptr2=n for i in range(ind): ans.append([arr[ptr1],arr[ptr1+1]]) if arr[ptr1]>arr[ptr1+1]: arr[ptr2]=arr[ptr1+1] arr[ptr1+1]=arr[ptr1] else: arr[ptr2]=arr[ptr1] ptr1+=1 ptr2+=1 for i in range(q): m=int(input()) if m<=ind: print(*ans[m-1]) else: m-=ind m=m%(n-1) if m==0: m+=n-1 print(arr[ind],arr[ind+m])",linear,"['data structures', 'implementation']",495
"a, b = map(int, input().split()) A = list(map(int, input().split())) A.append(-1) B = [] Z = [] AN = [] x, y = A[0], A[1] for i in range(a - 1): Z.append((x, y)) if x > y: B.append(y) y = A[i + 2] else: B.append(x) x, y = y, A[i + 2] for i in range(b): w = int(input()) if w <= len(Z): AN.append(Z[w - 1]) else: w = w % len(B) AN.append((x, B[w - 1])) for W in AN: print(*W)",linear,"['data structures', 'implementation']",374
"n,m,k = list(map(int,input().split())) l = list(map(int,input().split())) out = 0 d = 0 while m > d: nex = l[d] page = (nex - d - 1)//k add = 1 while d + add < m and (page * k) < l[d + add] - d <= (page + 1) * k: add += 1 d += add out += 1 print(out)",linear,"['implementation', 'two pointers']",250
"import sys n, m, k = list(map(int,sys.stdin.readline().strip().split())) p = list(map(int,sys.stdin.readline().strip().split())) i = 0 c = 0 d = 0 while i < m: c = c + 1 d2 = d x = k*((p[i]-d2-1)//k) + k while p[i]-d2 <= x: i = i + 1 d = d + 1 if i == m: break print(c)",linear,"['implementation', 'two pointers']",269
"n,m,k = map(int,input().split()) P = [int(x) for x in input().split()] P.reverse() ops = 0 i = 1 while P: nxt = P[-1] togo = nxt - i skip = togo//k*k i += skip space = k while space: special = 0 while P and P[-1] < i + space: special += 1 P.pop() i += space if not special: break ops += 1 space = special print(ops)",linear,"['implementation', 'two pointers']",315
"import sys input = sys.stdin.readline n,m,k=map(int,input().split()) A=list(map(int,input().split())) A.append(n+1) COMP=[] NOW=0 for a in A: if a-NOW-1!=0: if a-NOW-1>2*k: COMP.append([(a-NOW-1)%k+k,0]) else: COMP.append([a-NOW-1,0]) COMP.append([1,1]) NOW=a COMP.pop() ANS=0 NOW_PAGE=0 NOW_SCORE=0 pa=0 LEN=len(COMP) while pa<LEN: i,j=COMP[pa] if NOW_PAGE+i<=k: NOW_PAGE += i NOW_SCORE += j pa+=1 else: if NOW_SCORE>0: COMP[pa][0]-=k-NOW_PAGE NOW_PAGE=k-NOW_SCORE ANS+=1 NOW_SCORE=0 else: if NOW_PAGE==k: NOW_PAGE=0 else: COMP[pa][0]-=k-NOW_PAGE NOW_PAGE=k-NOW_SCORE if NOW_SCORE>0: ANS+=1 print(ANS)",linear,"['implementation', 'two pointers']",602
"n,m,k=map(int,input().split()) p=list(map(int,input().split())) count=0 delete=0 now=0 while now<m: up=((p[now]-delete-1)//k+1)*k+delete while now<m and p[now]<=up: now+=1 delete+=1 count+=1 print(count)",linear,"['implementation', 'two pointers']",203
"n, m, k = map(int, input().split()) mi = list(map(int, input().split())) ans = 0 items_to_del = 0 shift = 1 c_page = None for el in mi: if c_page is None: c_page = (el - shift) // k items_to_del = 1 else: page = (el - shift) // k if page != c_page: shift += items_to_del ans += 1 c_page = (el - shift) // k items_to_del = 1 else: items_to_del += 1 if items_to_del != 0: ans += 1 print(ans)",linear,"['implementation', 'two pointers']",389
"from sys import stdin, stdout n,m,k = [int(x) for x in stdin.readline().rstrip().split()] L = [int(x) for x in stdin.readline().rstrip().split()] off=1 page=-1 c=0 ans=0 for l in L: p=(l-off)//k if p==page: c+=1 else: off+=c c=1 ans+=1 page=(l-off)//k stdout.write( str(ans) + ""\n"" )",linear,"['implementation', 'two pointers']",283
"n, m, k = map(int, input().split(' ')) p = tuple(map(int, input().split(' '))) d = 0 part = (p[0]-1) // k moves = 0 skip = 0 for pi in p: if (pi-1-d) // k == part: skip += 1 continue d += skip part = (pi-1-d) // k skip = 1 moves += 1 print(moves+1)",linear,"['implementation', 'two pointers']",248
"import math import collections def func(a, k): if a % k != 0: mod = 1 else: mod = 0 return math.floor(a / k) * k + mod * k n, m, k = input().split() list = input().split() k = int(k) temp = k size = 0 answer = 0 c = 0 c2 = 0 check = 'false' used = 0 temp = func(int(list[0]), k) for i in range(len(list)): list[i] = int(list[i]) used = 0 if list[i] <= temp: c += 1 check = 'true' used = 1 if list[i] >= temp: if check is 'true': answer += 1 check = 'false' temp += c c = 0 if list[i] - c <= temp and used == 0: c += 1 check = 'true' used = 1 else: temp = temp + func(int(list[i]) - temp, k) if list[i] - c <= temp and used == 0: c += 1 check = 'true' used = 1 elif check is 'false': temp = temp + func(int(list[i]) - temp, k) if list[i] - c <= temp and used == 0: c += 1 check = 'true' used = 1 print(answer if check is 'false' else answer + 1)",linear,"['implementation', 'two pointers']",844
"import os import sys from io import BytesIO, IOBase from collections import Counter def main(): n=int(input()) a=list(map(int,input().split())) d=dict() z=0 s=0 for item in a: if item in d: d[item]+=1 z=item else: d[item]=1 s+=item if len(a)-len(d)>=2: print(""cslnb"") exit() if len(a)==len(d): z=(n*(n-1))//2 if (s-z)%2: print(""sjfnb"") else: print(""cslnb"") else: if z-1 in d or z==0: print(""cslnb"") else: zz=(n*(n-1))//2 if (s-zz)%2: print(""sjfnb"") else: print(""cslnb"") BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = 'x' in file.mode or 'r' not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b'\n') + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode('ascii')) self.read = lambda: self.buffer.read().decode('ascii') self.readline = lambda: self.buffer.readline().decode('ascii') sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip('\r\n') if __name__ == '__main__': main()",linear,['games'],1848
"n = int(input()) a = list(map(int,input().split())) dupes = 0 dupeVal = -1 d = set() for el in a: if el in d: dupes += 1 dupeVal = el else: d.add(el) inPlay = True if dupes > 1: print('cslnb') inPlay = False elif dupes == 1: if dupeVal == 0 or (dupeVal - 1) in d: print('cslnb') inPlay = False if inPlay: finalSum = (n*(n-1))//2 Sum = sum(a) if (Sum - finalSum) % 2 == 0: print('cslnb') else: print('sjfnb')",linear,['games'],407
"from collections import defaultdict as dd, deque n = int(input()) A = [int(x) for x in input().split()] n = len(A) C = dd(int) for a in A: C[a] += 1 thedup = None ndup = 0 screwed = False for c in C: if C[c] > 2: screwed = True elif C[c] == 2: if c == 0: screwed = True thedup = c ndup += 1 import sys if screwed or ndup > 1: print('cslnb') else: if ndup == 1: if C[thedup-1] != 0: print('cslnb') sys.exit() target = sum(range(n)) cur = sum(A) togo = cur - target if togo%2 == 0: print('cslnb') else: print('sjfnb')",linear,['games'],515
"import sys def rl(proc=None): if proc is not None: return proc(sys.stdin.readline()) else: return sys.stdin.readline().rstrip() def srl(proc=None): if proc is not None: return list(map(proc, rl().split())) else: return rl().split() def main(): rl() a = srl(int) a.sort() cnt = 0 for i in range(0, len(a)-1): if a[i] == a[i+1]: a[i] -= 1 cnt += 1 break if a[0] < 0: print('cslnb') return for i in range(0, len(a)-1): if a[i] == a[i+1]: print('cslnb') return for i, x in enumerate(a): cnt += x - i print('sjfnb' if (cnt & 1) else 'cslnb') if __name__ == '__main__': main()",linear,['games'],570
"n = int(input()) a = sorted(list(map(int,input().split()))) bal = 0 if a.count(0)>1: print('cslnb') exit() if n-len(set(a))>1: print('cslnb') exit() if n-len(set(a))==1: for i in range(1,n): if a[i]==a[i-1]: if a[i]-1 in a: print('cslnb') exit() break if n==1: print('cslnb' if not a[0] % 2 else 'sjfnb') exit() for i in range(n): bal+=a[i]-i print('sjfnb'if bal%2 else 'cslnb')",linear,['games'],378
"n = int(input()) a = sorted(list(map(int, input().split()))) duplicates = {} d = None delta = 0 for i, el in enumerate(a, 1): if el not in duplicates: duplicates[el] = 0 else: d = el duplicates[el] += 1 min_value = i-1 delta += el - min_value if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates): print('cslnb') elif delta == 0: print('cslnb') elif delta % 2 == 1: print('sjfnb') else: print('cslnb')",linear,['games'],449
"n = int(raw_input()) a = sorted(list(map(int, raw_input().split()))) duplicates = {} d = None delta = 0 for i, el in enumerate(a, 1): if el not in duplicates: duplicates[el] = 0 else: d = el duplicates[el] += 1 min_value = i-1 delta += el - min_value if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates): print('cslnb') elif delta == 0: print('cslnb') elif delta % 2 == 1: print('sjfnb') else: print('cslnb')",linear,['games'],457
"import sys def is_winning_state(nims, n): keys = set(nims) counts = dict.fromkeys(keys, 0) for nim in nims: counts[nim] += 1 if 0 in keys and counts[0] > 1: return True lose_count = 0 for k in keys: if counts[k] > 2: return True if counts[k] > 1 and (k - 1) in keys and counts[k - 1] > 0: return True if counts[k] > 1: lose_count += 1 if lose_count > 1: return True return False def main(): n = int(input()) nims = list(map(int, input().split())) if is_winning_state(nims, n): print('cslnb') else: x = sum(nims) - (n * (n - 1)) // 2 if x % 2 == 0: print('cslnb') else: print('sjfnb') main()",linear,['games'],590
"from collections import Counter import sys readline = sys.stdin.readline def check(A): CA = Counter(A) if CA[0] >= 2: return False cnt = 0 for k, v in CA.items(): if v > 2: return False if v == 2 and CA[k-1] >= 1: return False if v >= 2: cnt += 1 if cnt >= 2: return False L = len(A) if (sum(A) - L*(L-1)//2) % 2 == 0: return False return True N = int(readline()) if check(list(map(int, readline().split()))): print('sjfnb') else: print('cslnb')",linear,['games'],445
"import sys import copy input = sys.stdin.readline n,k=map(int,input().split()) C=list(input().strip()) def JUDGE(C): ANS_one=0 ANS_zero=0 for c in C: if c==""0"": ANS_zero+=1 else: break for c in C[::-1]: if c==""0"": ANS_zero+=1 else: break for c in C: if c==""1"": ANS_one+=1 else: break for c in C[::-1]: if c==""1"": ANS_one+=1 else: break if ANS_zero>=n-k or ANS_one>=n-k: return 1 else: return 0 if JUDGE(C)==1: print(""tokitsukaze"") sys.exit() if k>=n-1: print(""quailty"") sys.exit() if k<n/2: print(""once again"") sys.exit() CAN1=copy.copy(C) CAN2=copy.copy(C) if C[0]==""0"": for i in range(1,k+1): CAN1[i]=""1"" else: for i in range(1,k+1): CAN1[i]=""0"" if C[-1]==""0"": for i in range(n-1,n-k-1,-1): CAN2[i]=""1"" else: for i in range(n-2,n-k-2,-1): CAN2[i]=""0"" if JUDGE(CAN1)==1 and JUDGE(CAN2)==1: print(""quailty"") sys.exit() else: print(""once again"") sys.exit()",linear,"['brute force', 'games', 'greedy']",855
"import sys import copy input = sys.stdin.readline n,k=map(int,raw_input().split()) C=list(raw_input().strip()) def JUDGE(C): ANS_one=0 ANS_zero=0 for c in C: if c==""0"": ANS_zero+=1 else: break for c in C[::-1]: if c==""0"": ANS_zero+=1 else: break for c in C: if c==""1"": ANS_one+=1 else: break for c in C[::-1]: if c==""1"": ANS_one+=1 else: break if ANS_zero>=n-k or ANS_one>=n-k: return 1 else: return 0 if JUDGE(C)==1: print(""tokitsukaze"") sys.exit() if k>=n-1: print(""quailty"") sys.exit() if k<n/2: print(""once again"") sys.exit() CAN1=copy.copy(C) CAN2=copy.copy(C) if C[0]==""0"": for i in range(1,k+1): CAN1[i]=""1"" else: for i in range(1,k+1): CAN1[i]=""0"" if C[-1]==""0"": for i in range(n-1,n-k-1,-1): CAN2[i]=""1"" else: for i in range(n-2,n-k-2,-1): CAN2[i]=""0"" if JUDGE(CAN1)==1 and JUDGE(CAN2)==1: print(""quailty"") sys.exit() else: print(""once again"") sys.exit()",linear,"['brute force', 'games', 'greedy']",863
"import sys def sum_range(l, r): if r < l: return 0 if l == 0: return sum[r] return sum[r] - sum[l - 1] n, k = map(int, input().split()) cards = input() sum = [0] * n sum[0] = 1 if cards[0] == '1' else 0 for i in range(1, n): sum[i] += sum[i - 1] if cards[i] == '1': sum[i] += 1 min0 = min1 = n max0 = max1 = -1 for i in range(0, n): if cards[i] == '1': min1 = min(min1, i) max1 = i else: min0 = min(min0, i) max0 = i toki = False qual = True for i in range(0, n - k + 1): if sum_range(0, i - 1) + sum_range(i + k, n - 1) + k == n: toki = True if sum_range(0, i - 1) + sum_range(i + k, n - 1) + 0 == 0: toki = True prefix = sum_range(0, i - 1) == 0 suffix = sum_range(i + k, n - 1) == 0 if i > 0 and i + k < n and (prefix ^ suffix) == 0: qual = False if i - min0 > k or i - min1 > k or max0 - (i + k - 1) > k or max1 - (i + k - 1) > k: qual = False if toki == True: print('tokitsukaze') elif qual == True: print('quailty') else: print('once again')",linear,"['brute force', 'games', 'greedy']",947
"def win1(): if n==k or r[k+1]==n or l[n-k]==1: return True for i in range(2,n-k+1): if l[i-1]==1 and r[i+k]==n and a[i-1]==a[i+k]: return True return False def win2(): if 2*k<n: return False for i in range(2,n-k+1): if l[i-1]!=1 or r[i+k]!=n: return False return True if __name__ == ""__main__"": s=input().split() n,k=int(s[0]),int(s[1]) s=input().split() a=[0] l=[0 for i in range(n+1)] r=[0 for i in range(n+1)] for c in s[0]: a.append(int(c)) l[1],r[n]=1,n for i in range(2,n+1): if a[i-1]==a[i]: l[i]=l[i-1] else: l[i]=i if a[n-i+1]==a[n-i+2]: r[n-i+1]=r[n-i+2] else: r[n-i+1]=n-i+1 if win1(): print(""tokitsukaze"") elif win2(): print(""quailty"") else: print(""once again"")",linear,"['brute force', 'games', 'greedy']",673
"cards=list(input().split()) lm=[0]*9 lp=[0]*9 ls=[0]*9 for item in cards: if item[1]=='m': lm[int(item[0])-1]+=1 elif item[1]=='p': lp[int(item[0])-1]+=1 else : ls[int(item[0])-1]+=1 if max(lm)==3 or max(lp)==3 or max(ls)==3: print(0) else : flag=0 def seq_checker(li): flag=0 for i in range(9): if flag==0: if lm[i]==1: flag=1 else : if lm[i]==1: flag+=1 else : break return flag if seq_checker(lm)==3 or seq_checker(lp)==3 or seq_checker(ls)==3: print(0) elif max(lm)==2 or max(lp)==2 or max(ls)==2: print(1) else : m=0 for i in range(0,7): m=max(sum(lm[i:i+3]),sum(lp[i:i+3]),sum(ls[i:i+3]),m) print(3-m)",linear,"['brute force', 'implementation']",607
"m={""s"":[0]*9, ""m"":[0]*9, ""p"":[0]*9} for e in input().split(): m[e[1]][int(e[0])-1]+=1 ret=2 for t in ""smp"": l=m[t] if max(l)>=2: ret=min(ret, 3-max(l)) else: for i in range(7): seq = sum(l[i:i+3]) ret = min(ret, 3-seq) print(ret)",linear,"['brute force', 'implementation']",229
"a = input().split() st = set([]) cnt = [[0 for i in range(9)] for i in range(3)] for e in a: cnt['mps'.index(e[1])][int(e[0]) - 1] = 1 st.add(e) answ = len(st) - 1 for i in range(3): for j in range(7): answ = min(answ, 3 - sum(cnt[i][j:j + 3])) print(answ)",linear,"['brute force', 'implementation']",256
"s = [0] * 10 m = [0] * 10 p = [0] * 10 D = list(input().split()) for i in D: if i[1] == 'p': p[int(i[0])] += 1 elif i[1] == 'm': m[int(i[0])] += 1 else: s[int(i[0])] += 1 need = 3 for i in range(1, 10): need = min(3 - p[i], need) need = min(3 - s[i], need) need = min(3 - m[i], need) if i <= 7: tmp = 0 tmp += min(1, p[i]) tmp += min(1, p[i + 1]) tmp += min(1, p[i + 2]) need = min(3 - tmp, need) tmp = 0 tmp += min(1, m[i]) tmp += min(1, m[i + 1]) tmp += min(1, m[i + 2]) need = min(3 - tmp, need) tmp = 0 tmp += min(1, s[i]) tmp += min(1, s[i + 1]) tmp += min(1, s[i + 2]) need = min(3 - tmp, need) print(need)",linear,"['brute force', 'implementation']",612
"from sys import stdin, stdout s = input() s = s.split(' ') M = [0]*9 P = [0]*9 S = [0]*9 for pile in s: pile = list(pile) num = int(pile[0]) tile = pile[1] if tile=='s': S[num-1] += 1 elif tile=='p': P[num-1] += 1 elif tile=='m': M[num-1] += 1 for i in range(9): if M[i]==3: print(0) quit() if P[i]==3: print(0) quit() if S[i]==3: print(0) quit() for i in range(7): if M[i]==1 and M[i+1]==1 and M[i+2]==1: print(0) quit() if P[i]==1 and P[i+1]==1 and P[i+2]==1: print(0) quit() if S[i]==1 and S[i+1]==1 and S[i+2]==1: print(0) quit() for i in range(9): if M[i]==2: print(1) quit() if P[i]==2: print(1) quit() if S[i]==2: print(1) quit() for i in range(8): if M[i]==1 and M[i+1]==1: print(1) quit() if P[i]==1 and P[i+1]==1: print(1) quit() if S[i]==1 and S[i+1]==1: print(1) quit() for i in range(7): if M[i]==1 and M[i+2]==1: print(1) quit() if P[i]==1 and P[i+2]==1: print(1) quit() if S[i]==1 and S[i+2]==1: print(1) quit() print(2)",linear,"['brute force', 'implementation']",935
"def main(): buf = input() buflist = buf.split() hand = buflist; t = [] for i in range(3): t.append([]) for j in range(9): t[i].append(0) for x in hand: idx = 0 if x[1] == 'm': idx = 0 elif x[1] == 'p': idx = 1 elif x[1] == 's': idx = 2 t[idx][int(x[0])-1] += 1 max_cons = 0 max_mult = 0 for i in range(3): cons = [0, 0, 0] for j in range(9): cons[0] = cons[1] cons[1] = cons[2] if t[i][j] > 0: cons[2] = 1 else: cons[2] = 0 max_cons = max(sum(cons), max_cons) max_mult = max(max_mult, t[i][j]) print(3 - max(max_cons, max_mult)) if __name__ == '__main__': main()",linear,"['brute force', 'implementation']",562
"s = input() ans = 2 s1 = s[0:2] s2 = s[3:5] s3 = s[6:8] def func(inp): ans = 2 num = int(inp[0]) c = inp[1] ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num + 2)+c) != -1)) ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num - 1)+c) != -1)) ans = min( ans, 2 - int(s.find(str(num - 1)+c) != -1) - int(s.find(str(num - 2)+c) != -1)) ans = min( ans, 3 - s.count(inp)) return ans ans = min(ans,func(s1)) ans = min(ans,func(s2)) ans = min(ans,func(s3)) print(ans)",linear,"['brute force', 'implementation']",508
"s = input().split() hand = {'m': [], 'p': [], 's':[]} for item in s: hand[item[1]].append(int(item[0])) min_steps_needed = 10 for symb in ['m', 'p', 's']: hand[symb] = sorted(hand[symb]) for start in range(1, 10): a_needed = 10 b_needed = 10 a_needed = 3 - hand[symb].count(start) b1, b2, b3 = 0, 0, 0 if hand[symb].count(start) > 0: b1 = 1 if hand[symb].count(start+1) > 0: b2 = 1 if hand[symb].count(start+2) > 0: b3 = 1 b_needed = 3 - b1 - b2 - b3 if a_needed < min_steps_needed: min_steps_needed = a_needed if b_needed < min_steps_needed: min_steps_needed = b_needed print(min_steps_needed)",linear,"['brute force', 'implementation']",594
"m=[x for x in input().split()] tiles=[[0 for i in range(9)] for j in range(3)] for i in range(len(m)): g=int(m[i][0])-1 h=(m[i][1]) if h==""m"": tiles[0][g]+=1 elif h==""p"": tiles[1][g]+=1 else: tiles[2][g]+=1 if m[0]==m[1] and m[1]==m[2]: print(0) elif m[0]==m[1]: print(1) elif m[0]==m[2]: print(1) elif m[1]==m[2]: print(1) else: n=False for i in range(3): for j in range(9): if tiles[i][j]!=0: if j!=8 and tiles[i][j+1]!=0: if j!=7 and tiles[i][j+2]!=0: print(0) n=True break else: print(1) n=True break elif j!=7 and j!=8 and tiles[i][j+2]!=0: print(1) n=True break if n==False: print(2)",linear,"['brute force', 'implementation']",589
"n, m, k = map(int, input().split()) arr = [int(x) for x in input().split()] modulo = 0 tmp = 0 op = 1 cur = (arr[0] - 1) // k for i in range(m): if (arr[i] - 1 - modulo) // k != cur: modulo += tmp cur = (arr[i] - 1 - modulo) // k tmp = 0 op += 1 tmp += 1 print(op)",linear,['implementation'],264
"n,m,k = map(int,input().split()) pi = list(map(int,input().split())) num = 1 ans = 0 i = 0 while i < m: temp = (pi[i] - num) // k temp2 = i i += 1 while i < m : if temp != (pi[i] - num) // k: break i += 1 num += (i - temp2) ans += 1 print(ans)",linear,['implementation'],243
n = [int(i) for i in input().split()] a = [int(i) for i in input().split()] k = n[2] ans = 0 dele = 1 i = 0 while(i<n[1]): count = 1 while(((i+count)<n[1]) and (a[(i+count)]-dele)//k == (a[i]-dele)//k): count += 1 ans += 1 dele += count i += count print(ans),linear,['implementation'],258
"import math ln = [int(i) for i in input().split("" "")] n = ln[0] m = ln[1] k = ln[2] p = [int(i) for i in input().split("" "")] i = 0 ct = 0 ops = 0 while i < len(p): nm = p[i] - ct if nm % k == 0: mnm = nm else: mnm = (nm // k) * k + k si = i while p[i] - ct <= mnm: i += 1 if i >= len(p): break ct += i - si ops += 1 if i >= len(p): break print(ops)",linear,['implementation'],348
"from collections import deque n, m, k = map(int, input().split()) a = deque([int(i) for i in input().split()]) oper = 0 rem = 0 while a: x = a.popleft() pg = (x - 1 - rem) // k lrem = 1 while a and (a[0] - 1 - rem) // k == pg: a.popleft() lrem += 1 rem += lrem oper += 1 print(oper)",linear,['implementation'],282
"reduced = 1 n, m ,k = map(int,input().split()) p = list(map(int, input().split())) p.reverse() cnt = 0 while(len(p)): cnt1 = 1 first = p.pop() fack = ((first - reduced)//k) * k while(len(p) and p[-1] - fack - reduced < k): cnt1 += 1 p.pop() reduced += cnt1 cnt += 1 print(cnt)",linear,['implementation'],276
"n,m,k=map(int,input().split()) arr=list(map(int,input().split())) arr+=[0]*m ans=0 pos=0 while arr[pos]!=0: page=(arr[pos]-pos-1)//k tmp=1 for i in range(1,k): if pos+i>=2*m-1: break if (arr[pos+i]-pos-1)//k==page: tmp+=1 else: break pos+=tmp ans+=1 print(ans)",linear,['implementation'],260
"from sys import stdin from bisect import bisect_right as br from collections import deque n,m,k=map(int,stdin.readline().strip().split()) s=deque(map(int,stdin.readline().strip().split())) lim=k ans=0 while len(s)!=0: x=br(s,lim) for i in range(x): s.popleft() if x!=0: ans+=1 lim+=x else: if len(s)>0: x=s[0]-lim if x%k==0: x=x//k else: x=(x//k)+1 lim+=x*k print(ans)",linear,['implementation'],368
ints=[int(x) for x in input().split()] n=ints[0] m=ints[1] k=ints[2] special=[int(x) for x in input().split()] numOn=0 numOps=0 while numOn<m: numOps+=1 op=((special[numOn]-numOn-1)//(k))*k+k+numOn+1 while numOn<m and special[numOn]<op: numOn+=1 print(numOps),linear,['implementation'],259
n=int(input()) a=[int(x) for x in input().split()] pro=n*(n-1)//2 dic={} for item in a: if item not in dic: dic[item]=1 else: dic[item]+=1 counter=0 for item in dic: if 0 in dic and dic[0]>=2: print('cslnb') break if dic[item]>2: print('cslnb') break elif dic[item]==2: if counter==1 or item-1 in dic: print('cslnb') break else: counter=1 else: if (sum(a)-pro)%2==1: print('sjfnb') else: print('cslnb'),linear,['games'],402
"n = int(input()) a = list(map(int, input().split())) d = {} for ai in a: if ai in d: d[ai] += 1 else: d[ai] = 1 if max(d.values()) >= 3 or 0 in d and d[0] >= 2 or list(d.values()).count(2) >= 2: print('cslnb') exit() for i in d: if d[i] == 2 and i - 1 in d: print('cslnb') exit() s = sum(a) if s >= n * (n - 1) // 2: if (s - n * (n - 1) // 2) % 2 == 0: print('cslnb') else: print('sjfnb') else: pass",linear,['games'],399
"n=int(input()) arr=list(map(int,input().split())) dic={} for val in arr: if val not in dic: dic[val]=1 else: dic[val]+=1 flag1=True if 0 in dic: if dic[0]>=2: flag1=False cnt=0 for val in dic.keys(): if dic[val]>=3: flag1=False break if dic[val]==2: cnt+=1 if val-1 in dic: flag1=False break if cnt>=2: flag1=False if flag1==False: print('cslnb') else: flag2=(n*(n-1)//2+sum(arr))%2 if flag2==1: print('sjfnb') else: print('cslnb')",linear,['games'],431
n = int(input()) lst = [int(i) for i in input().split()] st = set() flag = False count = 0 for i in lst: if i not in st: st.add(i) else: flag = True count+=1 lol = i sum1 = n*(n-1)//2 if count>1: print('cslnb') quit() if not flag: if (sum(lst)- sum1)% 2 == 0: print('cslnb') else: print('sjfnb') else: if (lol-1) in lst or lol == 0: print('cslnb') else: if (sum(lst)- sum1)% 2 == 0: print('cslnb') else: print('sjfnb'),linear,['games'],418
"n = int(input()) arr = list(map(int, input().split())) solved = False s = sum(arr) if s == 0: print(""cslnb"") solved = True if not solved: n_num = {} for item in arr: if item in n_num: n_num[item] += 1 else: n_num[item] = 1 if 0 in n_num and n_num[0] >= 2: print('cslnb') solved = True if not solved: for key in n_num.keys(): if n_num[key] >= 3: print(""cslnb"") solved = True ind_pairs = [] if not solved: for key in n_num.keys(): if n_num[key] == 2: ind_pairs.append(key) if len(ind_pairs) >= 2: print(""cslnb"") solved = True elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num: print(""cslnb"") solved = True else: sum_targ = n*(n-1) // 2 dif_sum = s - sum_targ if dif_sum % 2 == 0: print(""cslnb"") else: print(""sjfnb"")",linear,['games'],718
n = int(input()) a = [int(i) for i in input().split()] total = sum(a) final = n * (n-1) // 2 repeated = [] count = {} for i in a: try: count[i] += 1 repeated.append(i) except KeyError: count[i] = 1 moves = total - final if len(repeated) > 1: print('cslnb') elif 0 in repeated: print('cslnb') elif len(repeated) == 1 and repeated[0] - 1 in a: print('cslnb') else: if moves % 2 == 0 or moves <= 0: print('cslnb') else: print('sjfnb'),linear,['games'],431
"def solve(n, arr): s = sum(arr) if s == 0: return ""cslnb"" n_num = {} for item in arr: if item in n_num: n_num[item] += 1 else: n_num[item] = 1 if 0 in n_num and n_num[0] >= 2: return 'cslnb' for key in n_num.keys(): if n_num[key] >= 3: return ""cslnb"" ind_pairs = [] for key in n_num.keys(): if n_num[key] == 2: ind_pairs.append(key) if len(ind_pairs) >= 2: return ""cslnb"" elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num: return ""cslnb"" else: sum_targ = n*(n-1) // 2 dif_sum = s - sum_targ if dif_sum % 2 == 0: return ""cslnb"" else: return ""sjfnb"" n = int(input()) arr = list(map(int, input().split())) print(solve(n, arr))",linear,['games'],628
"import io, sys input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip() ii = lambda: int(input()) mi = lambda: map(int, input().split()) li = lambda: list(mi()) n, k = mi() ans = None for x in range(1, n + 1): if x * (x + 3) == 2 * (k + n): ans = n - x break print(ans)",linear,"['binary search', 'brute force', 'math']",298
"turns, candies = map(int, input().split()) summ = 0 turn = 0 while candies != summ - (turns - turn): turn += 1 summ += turn print(turns - turn)",linear,"['binary search', 'brute force', 'math']",143
"n, k = map(int, input().split()) c = 1 while c * (c + 1) // 2 < k: c += 1 while c * (c + 1) // 2 - (n - c) != k: c += 1 print(n - c)",linear,"['binary search', 'brute force', 'math']",132
"n, k = [int(i) for i in input().split()] for i in range(100*k+100*n): if i*(i+1) == (n+k-i)*2: print(n-i) break",linear,"['binary search', 'brute force', 'math']",111
"from collections import Counter n, k = map(int, input().split()) for p in range(n+1): if p*(p+1)//2 - (n-p) == k: print(n-p) break",linear,"['binary search', 'brute force', 'math']",130
"import sys def input(): return sys.stdin.readline().strip() def dinput(): return int(input()) def tinput(): return input().split() def rinput(): return map(int, tinput()) def rt(x1, x2, y3): print(0.5 * (x2 + x1) * y3) def main(): n, k = rinput() i = 0 t = 0 while k > i: t += 1 i += t c = n - t i -= c while i != k: t += 1 i += t + 1 c -= 1 print(c) main()",linear,"['binary search', 'brute force', 'math']",357
"from math import* n,k=map(int,input().split()) s=1 dob=2 for i in range(1,n): s+=dob dob+=1 if s-(n-i-1)==k: print(n-i-1) exit() print(0)",linear,"['binary search', 'brute force', 'math']",137
"n,k = map(int,input().split()) for puts in range(10**9): candy = puts*(puts+1)//2 if candy - (n-puts) == k: print(n-puts) exit(0)",linear,"['binary search', 'brute force', 'math']",129
"from sys import stdin from collections import deque c=int(stdin.readline().strip()) for cas in range(c): n,m=map(int,stdin.readline().strip().split()) s=deque(stdin.readline().strip()) arr=[""R"",""G"",""B""] ans=n+3 for k in range(1): for i in range(3): x=i dp=[0 for i in range(n+1)] for j in range(n): if s[j]!=arr[x]: dp[j+1]+=1 dp[j+1]+=dp[j] if j+1>=m: ans=min(ans,dp[j+1]-dp[j+1-m]) x+=1 x=x%3 print(ans) 1",linear,['implementation'],407
"from sys import stdin import math rgb = 'RGB' for query in range(int(stdin.readline())): n, k = map(int, stdin.readline().split()) s = stdin.readline() ans = math.inf for start in range(3): dp = [0 for i in range(n + 1)] for i in range(n): cur = rgb[(start + i) % len(rgb)] dp[i + 1] = dp[i] + int(s[i] != cur) for i in range(n - k + 1): ans = min(ans, dp[i + k] - dp[i]) print(ans)",linear,['implementation'],382
"import sys input = sys.stdin.readline q=int(input()) for testcases in range(q): n,k=map(int,input().split()) S=list(input().strip()) for i in range(n): if S[i]==""R"": S[i]=0 elif S[i]==""G"": S[i]=1 else: S[i]=2 ANS=1<<50 for mod in range(3): SUM=0 for i in range(k): if S[i]%3!=(mod+i)%3: SUM+=1 ANS=min(ANS,SUM) for i in range(k,n): if S[i-k]!=(mod+(i-k))%3: SUM-=1 if S[i]!=(mod+i)%3: SUM+=1 ANS=min(ANS,SUM) print(ANS)",linear,['implementation'],419
"Q = int(input()) for _ in range(Q): N, K = map(int, input().split()) S = input() X = [{""R"":0, ""G"":1, ""B"":2}[s] for s in S] mi = K for i in range(3): d = 0 for j in range(N): if X[j] != (i+j) % 3: d += 1 if j >= K and X[j-K] != (i+j-K) % 3: d -= 1 if j >= K-1: mi = min(mi, d) print(mi)",linear,['implementation'],285
"def matches(pos, c, case): if case==0: return pos%3==""RGB"".index(c) elif case==1: return pos%3==""GBR"".index(c) else: return pos%3==""BRG"".index(c) q = int(input()) for _ in range(q): n, k = map(int, input().split()) s = input() mglobal = k r=g=b=0 for i, c in enumerate(s[:k]): r += not matches(i, c, 0) g += not matches(i, c, 1) b += not matches(i, c, 2) mglobal = min([mglobal, r, g, b]) for i, c in enumerate(s[k:]): i+=k r += -(not matches(i-k, s[i-k], 0)) + (not matches(i, c, 0)) g += -(not matches(i-k, s[i-k], 1)) + (not matches(i, c, 1)) b += -(not matches(i-k, s[i-k], 2)) + (not matches(i, c, 2)) mglobal = min([mglobal, r, g, b]) print(mglobal)",linear,['implementation'],655
"def solve(d, n, k): mv = sum(d[0:k]) v = mv for i in range(1, n-k+1): mv = mv + d[i+k-1] - d[i-1] v = min(v, mv) return v for _ in range(int(input())): n, k = tuple(map(int, input().split())) s = input() st = 'RGB' * (n//3 + 3) diff1, diff2, diff3 = [0 for _ in range(n)], [0 for _ in range(n)], [0 for _ in range(n)] for i in range(n): if s[i] != st[i]: diff1[i] = 1 if s[i] != st[i+1]: diff2[i] = 1 if s[i] != st[i+2]: diff3[i] = 1 print(min(solve(diff1, n, k), solve(diff2, n, k), solve(diff3, n, k)))",linear,['implementation'],504
"import sys from collections import defaultdict as dd mod=10**9+7 def ri(flag=0): if flag==0: return [int(i) for i in sys.stdin.readline().split()] else: return int(sys.stdin.readline()) for _ in range(int(input())): n,k = ri() a = input() rgb= [0 for i in range(n)] gbr= [0 for i in range(n)] brg= [0 for i in range(n)] for i in range(n): if i%3==0: if a[i]!=""R"": rgb[i]+=1 if i%3==1: if a[i]!=""G"": rgb[i]+=1 if i%3==2: if a[i]!=""B"": rgb[i]+=1 for i in range(n): if i%3==0: if a[i]!=""G"": gbr[i]+=1 if i%3==1: if a[i]!=""B"": gbr[i]+=1 if i%3==2: if a[i]!=""R"": gbr[i]+=1 for i in range(n): if i%3==0: if a[i]!=""B"": brg[i]+=1 if i%3==1: if a[i]!=""R"": brg[i]+=1 if i%3==2: if a[i]!=""G"": brg[i]+=1 for i in range(1,n): rgb[i]+=rgb[i-1] brg[i]+=brg[i-1] gbr[i]+=gbr[i-1] ans = 999999999 for i in range(k-1,n): if i-k ==-1: ans = min(ans,rgb[i],gbr[i],brg[i]) else: ans = min(ans, rgb[i]- rgb[i-k] , gbr[i]- gbr[i-k], brg[i]- brg[i-k] ) print(ans)",linear,['implementation'],939
"q = int(input()) for t in range(q): n, k = map(int, input().split()) rgb = input() dp = [0] * 3 dp[0] = [0] * (n + 1) dp[1] = [0] * (n + 1) dp[2] = [0] * (n + 1) for i in range(0, n): if rgb[i] == 'R': dp[0][i + 1] = dp[2][i] dp[1][i + 1] = dp[0][i] + 1 dp[2][i + 1] = dp[1][i] + 1 if rgb[i] == 'G': dp[0][i + 1] = dp[2][i] + 1 dp[1][i + 1] = dp[0][i] dp[2][i + 1] = dp[1][i] + 1 if rgb[i] == 'B': dp[0][i + 1] = dp[2][i] + 1 dp[1][i + 1] = dp[0][i] + 1 dp[2][i + 1] = dp[1][i] repl = k dif = k % 3 for j in range(3): for i in range(1, n - k + 2): repl = min(repl, -dp[j][i - 1] + dp[(j + dif) % 3][i + k - 1]) print(repl)",linear,['implementation'],622
"import sys input = sys.stdin.readline q = int(input()) for i in range(q): n, k = map(int, input().split()) s = input() R, G, B = 0, 0, 0 ans = float('inf') for j in range(n): if j % 3 == 0: if s[j] == 'R': G += 1 B += 1 elif s[j] == 'G': R += 1 B += 1 else: R += 1 G += 1 elif j % 3 == 1: if s[j] == 'R': G += 1 R += 1 elif s[j] == 'G': G += 1 B += 1 else: R += 1 B += 1 else: if s[j] == 'R': R += 1 B += 1 elif s[j] == 'G': R += 1 G += 1 else: G += 1 B += 1 if j >= k - 1: ans = min(ans, R, G, B) if (j - k + 1) % 3 == 0: if s[j - k + 1] == 'R': G -= 1 B -= 1 elif s[j - k + 1] == 'G': R -= 1 B -= 1 else: R -= 1 G -= 1 elif (j - k + 1) % 3 == 1: if s[j - k + 1] == 'R': G -= 1 R -= 1 elif s[j - k + 1] == 'G': G -= 1 B -= 1 else: R -= 1 B -= 1 else: if s[j - k + 1] == 'R': R -= 1 B -= 1 elif s[j - k + 1] == 'G': R -= 1 G -= 1 else: G -= 1 B -= 1 print(ans)",linear,['implementation'],860
"import sys input = sys.stdin.readline Q = int(input()) D = {""R"":0, ""G"":1, ""B"":2} for _ in range(Q): N, K = map(int, input().split()) S = input() mi = K for i in range(3): d = 0 for j in range(N): if D[S[j]] != (i+j) % 3: d += 1 if j >= K and D[S[j-K]] != (i+j-K) % 3: d -= 1 if j >= K-1: mi = min(mi, d) print(mi)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",313
"from sys import stdin,stdout input=stdin.readline for _ in range(int(input())): x=10**5 n,k=map(int,input().split()) s=input() a=10**9 ans=[[0]*n for i in range(3)] curr=['R','G','B'] for l in range(3): z=l for j in range(n): if s[j]!=curr[z]: ans[l][j]=1 z+=1 z%=3 for i in range(3): ans[i]=[0]+ans[i] for l in range(3): z=l for j in range(1,n+1): ans[l][j]+=ans[l][j-1] for l in range(3): for j in range(1,n-k+2): a=min(a,ans[l][j+k-1]-ans[l][j-1]) print(a)",linear,"['data structures', 'dp', 'implementation', 'two pointers']",459
"def main(): q = int(input()) ans = [] for i in range(q): n, k = map(int, input().split()) s = input() min_ans = 10 ** 9 pr1 = [0] pr2 = [0] pr3 = [0] for i in range(n): count1 = 0 count2 = 0 count3 = 0 if i % 3 == 0: if s[i] != ""R"": count1 += 1 if s[i] != ""G"": count2 += 1 if s[i] != ""B"": count3 += 1 if i % 3 == 1: if s[i] != ""G"": count1 += 1 if s[i] != ""B"": count2 += 1 if s[i] != ""R"": count3 += 1 if i % 3 == 2: if s[i] != ""B"": count1 += 1 if s[i] != ""R"": count2 += 1 if s[i] != ""G"": count3 += 1 pr1.append(pr1[-1] + count1) pr2.append(pr2[-1] + count2) pr3.append(pr3[-1] + count3) j = i + 1 if j >= k: count1 = pr1[j] - pr1[j - k] count2 = pr2[j] - pr2[j - k] count3 = pr3[j] - pr3[j - k] min_ans = min(min_ans, count1, count2, count3) ans.append(min_ans) print(*ans, sep=""\n"") main()",linear,"['data structures', 'dp', 'implementation', 'two pointers']",789
"import sys input = lambda: sys.stdin.readline().strip() nxt = {'R':'G', 'G':'B', 'B':'R'} T = int(input()) for _ in range(T): n, k = map(int, input().split()) s = input() res = [] for start in ['R', 'G', 'B']: mis = [] cur = start for j in range(k): if s[j]!=cur: mis.append(1) else: mis.append(0) cur = nxt[cur] res.append(sum(mis)) for j in range(k, n): res.append(res[-1]+int(s[j]!=cur)-mis[j-k]) if s[j]!=cur: mis.append(1) else: mis.append(0) cur = nxt[cur] print(min(res))",linear,"['data structures', 'dp', 'implementation', 'two pointers']",478
"import sys input = sys.stdin.readline q = int( input() ) rgb = ""RGB"" for _ in range( q ): n, k = map( int, input().split() ) s = input() ans = n for i in range( 3 ): r = [ 0 ] l = i for c in s: r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) ) l = ( l + 1 ) % 3 if len( r ) > k: ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] ) print( ans )",linear,"['data structures', 'dp', 'implementation', 'two pointers']",343
"t = int(input()) for _ in range(t): n = int(input()) a = list(map(int, input().split())) if n == 1: print(0) else: max1 = max2 = -1 for q in a: if q > max1: max1, max2 = q, max1 elif q > max2: max2 = q print(max(0, min(max2-1, len(a)-2)))",linear,"['greedy', 'math', 'sortings']",238
"import sys n = int(sys.stdin.readline().strip()) a = list(map(int, sys.stdin.readline().strip().split())) i = a.index(max(a)) v = True for j in range (0, i): if a[j] > a[j+1]: v = False for j in range (i, n-1): if a[j] < a[j+1]: v = False if v == True: print(""YES"") else: print(""NO"")",linear,"['greedy', 'implementation']",283
"def main(): import sys input = sys.stdin.readline n = int(input()) arr = list(map(int, input().split())) idx = arr.index(n) ok = 1 for i in range(1, idx): if arr[i] < arr[i - 1]: ok = 0 for i in reversed(range(idx, n - 1)): if arr[i] < arr[i + 1]: ok = 0 if ok: print(""YES"") else: print(""NO"") return 0 main()",linear,"['greedy', 'implementation']",308
"n = int(input()) arr = [int(x) for x in input().split()] x = arr.index(max(arr)) cur = max(arr) l = x - 1 r = x + 1 ok = 1 for i in range(n - 1): if l < 0: ok *= (arr[r] < cur) cur = arr[r] r += 1 elif r >= n: ok *= (arr[l] < cur) cur = arr[l] l -= 1 else: if arr[l] > arr[r]: ok *= (arr[l] < cur) cur = arr[l] l -= 1 else: ok *= (arr[r] < cur) cur = arr[r] r += 1 print(""YES"" if ok else ""NO"")",linear,"['greedy', 'implementation']",393
"n=int(input()) arr=list(map(int,input().split())) maxval=max(arr) maxindex=-1 for i in range(n): if(arr[i]==maxval): maxindex=i break flag=0 temp=maxval for i in range(maxindex-1,-1,-1): if(temp<=arr[i]): flag=1 break else: temp=arr[i] temp=maxval for i in range(maxindex+1,n): if(arr[i]>=temp): flag=1 break else: temp=arr[i] if(flag==0): print(""YES"") else: print(""NO"")",linear,"['greedy', 'implementation']",370
"n = int(input()) a = list(map(int,input().split())) fl = False ans = True for i in range(n-1): if a[i+1]>a[i]: if fl: ans = False else: fl = True if ans: print('YES') else: print('NO')",linear,"['greedy', 'implementation']",184
"n = int(input()) a = list(map(int, input().split())) c = 0 for i in range(1, n-1): if a[i] > a[i-1] and a[i] > a[i+1]: c +=1 if a[i] == a[i-1] or a[i] == a[i+1]: print('NO') exit() if a[i] <= a[i-1] and a[i] <= a[i+1]: print('NO') exit() if c>1: print('NO') else: print('YES')",linear,"['greedy', 'implementation']",276
"n = int(input()) a = list(map(int,input().split())) rev = [-1] * (n + 1) for i, j in enumerate(a): rev[j] = i mx = max(a) l = a.index(mx) r = l for i in range(n - 1, 0, -1): idx = rev[i] if idx == l - 1: l -= 1 elif idx == r + 1: r += 1 else: print('NO') exit() print('YES')",linear,"['greedy', 'implementation']",274
"n = int(input()) l = list(map(int, input().split())) to = l.index(max(l)) ok = 1 for i in range(1, to): if (l[i] <= l[i - 1]): ok = 0 break for i in range(to + 1, n): if (l[i] >= l[i - 1]): ok = 0 break if ok: print('YES') else: print('NO')",linear,"['greedy', 'implementation']",240
"t=int(input()) g=list(map(int,input().split())) k=max(g) flag=True i=0 while g[i]!=k: if i!=0 and g[i]<g[i-1]: print(""NO"") exit() i+=1 i+=1 while i<t and g[i]!=k: if i!=0 and g[i]>g[i-1]: print(""NO"") exit() i+=1 print(""YES"")",linear,"['greedy', 'implementation']",224
"import io, sys input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip() ii = lambda: int(input()) mi = lambda: map(int, input().split()) li = lambda: list(mi()) n, m, k = mi() a = [None] + li() p = [0] * (n + 1) for i in range(1, n + 1): p[i] = p[i - 1] + a[i] s = [10 ** 16 for _ in range(m)] s[0] = k ans = 0 for i in range(1, n + 1): ans = max(ans, p[i] - min(s)) s[i % m] = min(s[i % m], p[i]) s[i % m] += k print(ans)",linear,"['dp', 'greedy', 'math']",451
"import sys input = sys.stdin.readline def gcd(a, b): if a == 0: return b return gcd(b % a, a) def lcm(a, b): return (a * b) / gcd(a, b) def main(): n,r=map(int, input().split()) a=list(map(int, input().split())) ans=[] ans.append(r) for i in range(1,n): ymax=r for j in range( i): if abs(a[j]-a[i])<=2*r: ymax=max(ymax, ans[j]+(4*r*r-(a[i]-a[j])**2)**0.5) ans.append(ymax) print(*ans) return if __name__==""__main__"": main()",quadratic,"['brute force', 'geometry', 'implementation', 'math']",423
"n,r=list(map(int,input().split())) x=list(map(int,input().split())) y=[r]*n for i in range(1,n): for j in range(i): d=abs(x[i]-x[j]) if d<=2*r: y[i]=max(y[i],y[j]+(4*r*r-d*d)**(0.5)) print(*y)",quadratic,"['brute force', 'geometry', 'implementation', 'math']",192
"import math as m nDiscs, r = [int(x) for x in input().split()] x = [int(x) for x in input().split()] y = [] for i in range(len(x)): tempY = [r] for j in range(i): diffX = abs(x[i] - x[j]) if diffX <= (2 * r): addY = m.sqrt((4 * r * r) - (diffX * diffX)) tempY.append(y[j] + addY) y.append(max(tempY)) for i in range(len(y)): print(y[i], end=' ') print()",quadratic,"['brute force', 'geometry', 'implementation', 'math']",353
"import math n, r = map(int, input().split()) x = list(map(int, input().split())) y = [r] for i in range(1, n): _y = r for j in range(i): if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]): _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j]))) y.append(round(_y, 6)) print(' '.join(map(str, y)))",quadratic,"['brute force', 'geometry', 'implementation', 'math']",309
"n, r = map(int, input().split()) x = list(map(int, input().split())) y = [r] * n for i in range(n): for j in range(i): if not (abs(x[i] - x[j]) > 2 * r): y[i] = max(y[i], (4 * r ** 2 - (x[i] - x[j]) ** 2) ** 0.5 + y[j]) for i in y: print(i, end=' ')",quadratic,"['brute force', 'geometry', 'implementation', 'math']",249
"import math def C1(): n, r = map(int, input().split()) x_cord = [int(x) for x in input().split()] y_cord = [] contactedDisk = 0 for i, x in enumerate(x_cord): if len(y_cord) == 0: y_cord.append(r) else: y_cord.append(r) for j in range(i): diff = abs(x_cord[i] - x_cord[j]) if diff <= 2 * r: y_cord[i] = max(y_cord[i], math.sqrt(4*r*r - diff ** 2) + y_cord[j]) for i in y_cord: print(i, end= "" "") if __name__=='__main__': C1()",quadratic,"['brute force', 'geometry', 'implementation', 'math']",425
"import bisect from itertools import accumulate, count import os import sys import math from decimal import * from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def input(): return sys.stdin.readline().rstrip(""\r\n"") def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def SieveOfEratosthenes(n): prime = [] primes = [True for i in range(n + 1)] p = 2 while p * p <= n: if primes[p] == True: prime.append(p) for i in range(p * p, n + 1, p): primes[i] = False p += 1 primes[1]=False primes[0]=False return primes def primefactors(n): fac=[] while(n%2==0): fac.append(",quadratic,"['brute force', 'geometry', 'implementation', 'math']",2000
"import math n, r = [int(x) for x in input().split()] x = [int(x) for x in input().split()] ans = [] for i in range(n): t = r for j in range(i): a = abs(x[i] - x[j]) if a <= 2 * r: t2 = (2 * r)**2 t2 -= a**2 t2 = math.sqrt(t2) + ans[j] t = max(t, t2) ans.append(t) for k in ans: print(k)",quadratic,"['brute force', 'geometry', 'implementation', 'math']",286
"import math n_r = list(map(int, input().split())) n = n_r[0] radii = n_r[1] x_list = list(map(int, input().split())) temp_arr = [] for i in range(n): temp_arr.append(max([radii] + [math.sqrt(4*radii**2 - (x_list[i]-x_list[j])**2) + temp_arr[j] for j in range(i) if abs(x_list[i]-x_list[j]) <= 2*radii]) ) for i in temp_arr: print(i, end= "" "")",quadratic,"['brute force', 'geometry', 'implementation', 'math']",342
"from math import sqrt n, r = input().split() n = int(n) r = int(r) x = [] arr = [] inpArr = input().split("" "") for i in inpArr: x.append(int(i)) for i in range(n): arr.append(r) for j in range(i): if (abs(x[j] - x[i]) <= (r * 2)): arr[i] = max(arr[i], (arr[j] + sqrt((r*r*4)-((x[j] - x[i])*(x[j] - x[i]))) )) arr1 = [] for i in arr: arr1.append(str(i)) print("" "".join(arr1))",quadratic,"['brute force', 'geometry', 'implementation', 'math']",374
"n, r = map(int, input().split()) y = [] x = list(map(int, input().split())) for xi in x: yi = r for tx, ty in zip(x, y): if xi - 2 * r <= tx <= xi + 2 * r: dy = (4.0 * r ** 2 - (tx - xi) ** 2) ** 0.5 yi = max(yi, ty + dy) y.append(yi) print(*y)",quadratic,"['brute force', 'geometry', 'implementation', 'math']",244
"ans = [] import math disks_rad = [int(x) for x in input().split("" "")] nums = [int(x) for x in input().split("" "")] r = disks_rad[1] ans.append(r) for i in range(1, disks_rad[0]): y_cord = r for j in range(i): if ((nums[i] - nums[j]) ** 2) <= ((r ** 2) * 4): y_cord = max(y_cord, ans[j] + math.sqrt(4 * (r ** 2) - (nums[j] - nums[i]) ** 2 ) ) ans.append(y_cord) print("" "".join([str(x) for x in ans]))",quadratic,"['brute force', 'geometry', 'implementation', 'math']",398
"import math n, r = map(int, input().split()) x = list(map(int, input().split())) y = [r] for i in range(1, n): _y = r for j in range(i): if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]): _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j]))) y.append(_y) print(' '.join(map(str, y)))",quadratic,"['brute force', 'geometry', 'implementation', 'math']",299
"R = lambda: map(int, input().split()) n, r = R() xs = list(R()) ys = [] for i in range(n): ys.append(max([((2 * r) ** 2 - abs(xs[i] - xs[j]) ** 2) ** 0.5 + ys[j] for j in range(i) if abs(xs[i] - xs[j]) <= 2 * r], default=r)) print(*ys)",quadratic,"['brute force', 'geometry', 'implementation', 'math']",235
"n,r = map(int,input().split()) x_coord = list(map(int,input().split())) d = {} for i in x_coord: final = r for j in range(i-r,i+r+1): check = d.get(j,[-1,-1]) if check[0] > 0: potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5 final = max(potential,final) for j in range(i-r,i+r+1): d[j] = (i,final) print(final)",quadratic,"['brute force', 'geometry', 'implementation', 'math']",316
"n,r = map(int,input().split()) x_coord = list(map(int,input().split())) d = {} for i in x_coord: final = r for j in range(i-r,i+r+1): check = d.get(j,[-1,-1]) if check[0] > 0: potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5 final = max(potential,final) for j in range(i-r,i+r+1): d[j] = (i,final) print(final,end = "" "")",quadratic,"['brute force', 'geometry', 'implementation', 'math']",326
"from math import * a,r = map(int,input().split()) x = list(map(int,input().split())) y = [0]*a for i in range(a): h = r for j in range(i): if abs(x[i]-x[j])<=2*r: h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j]) y[i] = h print(h, end = "" "")",quadratic,"['brute force', 'geometry', 'implementation', 'math']",239
"from collections import defaultdict def E1(): mod = 10 ** 9 + 7 comb = [[1]] for i in range(1, 1010): x = [1] for j in range(1, i): x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod) x.append(1) comb.append(x) dp = [1] for i in range(1, 1010): r = 0 for k in range(i): r += dp[k] * comb[i - 1][k] r %= mod dp.append(r) m, n = map(int, input().split()) ns = [0 for __ in range(m)] for j in range(n): temp = input() s = [int(i) for i in temp] for i in range(m): ns[i] |= s[i] << j dd = defaultdict(int) for e in ns: dd[e] += 1 ans = 1 for b in dd.values(): ans = ans * dp[b] % mod print(ans) if __name__=='__main__': E1()",quadratic,"['bitmasks', 'combinatorics', 'dp', 'math']",622
"from collections import defaultdict mod_v = 1000000007 temp_arr = [[1]] for i in range(1,1010): a = [1] for k in range(1,i): a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v) a.append(1) temp_arr.append(a) ans_arr = [1] for i in range(1,1010): res = 0 for j in range(i): res += ans_arr[j] * temp_arr[i-1][j] res %= mod_v ans_arr.append(res) n_list=list(map(int, input().split())) n = n_list[0] lines = n_list[1] new_list = [0 for __ in range(n)] for i in range(lines): input1 = list(map(int, input())) for k in range(n): new_list[k] |= input1[k] << i default_d = defaultdict(int) for k in new_list: default_d[k] += 1 answer = 1 for n in default_d.values(): answer = answer * ans_arr[n] % mod_v print(answer)",quadratic,"['bitmasks', 'combinatorics', 'dp', 'math']",713
"import bisect import copy import decimal import fractions import heapq import itertools import math import random import sys from collections import deque,defaultdict from functools import lru_cache,reduce from heapq import heappush,heappop,heapify,_heappop_max,_heapify_max def _heappush_max(heap,item): heap.append(item) heapq._siftdown_max(heap,0,len(heap)-1) from math import gcd as Gcd read=sys.stdin.read readline=sys.stdin.readline readlines=sys.stdin.readlines def Extended_Euclid(n,m): stack=[] while m: stack.append((n,m)) n,m=m,n%m if n>=0: x,y=1,0 else: x,y=-1,0 for i in range(len(stack)-1,-1,-1): n,m=stack[i] x,y=y,x-(n//m)*y return x,y class MOD: def __init__(self,p,e=1): self.p=p self.e=e self.mod=self.p**self.e def Pow(self,a,n): a%=self.mod if n>=0: return pow(a,n,self.mod) else: assert math.gcd(a,self.mod)==1 x=Extended_Euclid(a,self.mod)[0] return pow(x,-n,self.mod) def Build_Fact(self,N): assert N>=0 self.factorial=[1] self.cnt=[0]*(N+1) for i in range(1,N+1): ii=i self.cnt[i]=self.cnt[i-1] while ii%self.p==0: ii//=self.p self.cnt[i]+=1 self.factorial.append((self.factorial[-1]*ii)%self.mod) self.factorial_inv=[None]*(N+1) self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1) for i in range(N-1,-1,-1): ii=i+1 while ii%self.p==0: ii//=self.p self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod def Fact(self,N): return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod def Fact_Inv(self,N): if self.cnt[N]: return None return self.factorial_inv[N] def Comb(self,N,K,divisible_count=False): if K<0 or K>N: return 0 retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K] if divisible_count: return retu,cnt else: retu*=pow(self.p,cnt,self.mod) retu%=self.mod return retu def Bell_Numbers(N,mod,prime=False): bell_numbers=[0]*(N+1) bell_numbers[0]=1 MD=MOD(mod) if prime: MD.Build_Fact(min(mod-2,N-1)) for i in range(1,min(mod,N+1)): bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) f",quadratic,"['bitmasks', 'combinatorics', 'dp', 'math']",2000
"import math import sys from collections import deque,defaultdict read=sys.stdin.read readline=sys.stdin.readline readlines=sys.stdin.readlines def Extended_Euclid(n,m): stack=[] while m: stack.append((n,m)) n,m=m,n%m if n>=0: x,y=1,0 else: x,y=-1,0 for i in range(len(stack)-1,-1,-1): n,m=stack[i] x,y=y,x-(n//m)*y return x,y class MOD: def __init__(self,p,e=1): self.p=p self.e=e self.mod=self.p**self.e def Pow(self,a,n): a%=self.mod if n>=0: return pow(a,n,self.mod) else: assert math.gcd(a,self.mod)==1 x=Extended_Euclid(a,self.mod)[0] return pow(x,-n,self.mod) def Build_Fact(self,N): assert N>=0 self.factorial=[1] self.cnt=[0]*(N+1) for i in range(1,N+1): ii=i self.cnt[i]=self.cnt[i-1] while ii%self.p==0: ii//=self.p self.cnt[i]+=1 self.factorial.append((self.factorial[-1]*ii)%self.mod) self.factorial_inv=[None]*(N+1) self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1) for i in range(N-1,-1,-1): ii=i+1 while ii%self.p==0: ii//=self.p self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod def Fact(self,N): return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod def Fact_Inv(self,N): if self.cnt[N]: return None return self.factorial_inv[N] def Comb(self,N,K,divisible_count=False): if K<0 or K>N: return 0 retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K] if divisible_count: return retu,cnt else: retu*=pow(self.p,cnt,self.mod) retu%=self.mod return retu def Bell_Numbers(N,mod,prime=False): bell_numbers=[0]*(N+1) bell_numbers[0]=1 MD=MOD(mod) if prime: MD.Build_Fact(min(mod-2,N-1)) for i in range(1,min(mod,N+1)): bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod for i in range(mod,N+1): bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod else: MD.Build_Fact(N-1) for i in range(1,N+1): bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod return bell_numbers M,N=map(int,readline().split()) S=[readline().rstrip() for i in range(N)]",quadratic,"['bitmasks', 'combinatorics', 'dp', 'math']",2000
"import math from collections import defaultdict def Extended_Euclid(n,m): stack=[] while m: stack.append((n,m)) n,m=m,n%m if n>=0: x,y=1,0 else: x,y=-1,0 for i in range(len(stack)-1,-1,-1): n,m=stack[i] x,y=y,x-(n//m)*y return x,y class MOD: def __init__(self,p,e=1): self.p=p self.e=e self.mod=self.p**self.e def Pow(self,a,n): a%=self.mod if n>=0: return pow(a,n,self.mod) else: assert math.gcd(a,self.mod)==1 x=Extended_Euclid(a,self.mod)[0] return pow(x,-n,self.mod) def Build_Fact(self,N): assert N>=0 self.factorial=[1] self.cnt=[0]*(N+1) for i in range(1,N+1): ii=i self.cnt[i]=self.cnt[i-1] while ii%self.p==0: ii//=self.p self.cnt[i]+=1 self.factorial.append((self.factorial[-1]*ii)%self.mod) self.factorial_inv=[None]*(N+1) self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1) for i in range(N-1,-1,-1): ii=i+1 while ii%self.p==0: ii//=self.p self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod def Fact(self,N): return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod def Fact_Inv(self,N): if self.cnt[N]: return None return self.factorial_inv[N] def Comb(self,N,K,divisible_count=False): if K<0 or K>N: return 0 retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K] if divisible_count: return retu,cnt else: retu*=pow(self.p,cnt,self.mod) retu%=self.mod return retu def Bell_Numbers(N,mod,prime=False): bell_numbers=[0]*(N+1) bell_numbers[0]=1 MD=MOD(mod) if prime: MD.Build_Fact(min(mod-2,N-1)) for i in range(1,min(mod,N+1)): bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod for i in range(mod,N+1): bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod else: MD.Build_Fact(N-1) for i in range(1,N+1): bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod return bell_numbers M,N=map(int,input().split()) S=[input() for i in range(N)] dct=defaultdict(int) for i in range(M): tpl=() for j in range(N): tpl+=(S[j][i],) dct[tpl]+=1 ans=1 mod=10**9",quadratic,"['bitmasks', 'combinatorics', 'dp', 'math']",2000
"num = input() num_list = [] for i in range(len(num)): num_list.append(int(num[i])) myMod = (10 ** 9) + 7 length = len(num_list) f = [0] * (length + 1) t = [1] * (length + 1) for i in range(length): f[i+1] = (f[i] * 10 + 1) % myMod t[i+1] = (t[i] * 10) % myMod ans = 0 for i in range(1, 10): dp = [0] * (length + 1) for j in range(length): dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod c = 0 ctr = 0 for k in num_list: z = min(i, k) o = k - z ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod ans %= myMod c += k >= i ctr += 1 ans += f[c] if ans >= myMod: ans -= myMod print(ans)",quadratic,"['dp', 'math']",689
"import sys from random import * from bisect import * pl=1 from math import gcd,sqrt from copy import * sys.setrecursionlimit(10**5) if pl: input=sys.stdin.readline else: sys.stdin=open('input.txt', 'r') sys.stdout=open('outpt.txt','w') def li(): return [int(xxx) for xxx in input().split()] def fi(): return int(input()) def si(): return list(input().rstrip()) def mi(): return map(int,input().split()) t=1 while t>0: t-=1 n=fi() mod=10**9+7 dp=[[0 for i in range(n+5)] for j in range(n+5)] prev=""-1"" for i in range(n): p=input().rstrip() if i==0: dp[i][0]=1 else: c=0 if prev=='f': for j in range(n): dp[i][j+1]=dp[i-1][j] else: for j in range(n,-1,-1): c=(c+dp[i-1][j])%mod dp[i][j]=c prev=p print(sum(dp[n-1])%mod)",quadratic,['dp'],717
"n = int(input()) s = [input() for i in range(n)] MOD = 10**9 + 7 dps = [[0]*(n + 3) for i in range(n + 1)] dpf = [[0]*(n + 3) for i in range(n + 1)] for k in range(n + 1): dps[0][k] = 1 for pos, char in enumerate(s): if char == ""s"": for depth in range(pos + 2): dps[pos + 1][depth] = dpf[pos][depth] - \ dpf[pos][depth - 1] + dps[pos][pos] - dps[pos][depth - 1] dps[pos + 1][depth] += dps[pos + 1][depth - 1] dps[pos + 1][depth] %= MOD for p in range(pos + 2, n+1): dpf[pos + 1][p] += dpf[pos + 1][p - 1] dpf[pos + 1][p] %= MOD continue else: for depth in range(1, pos + 2): dpf[pos + 1][depth] = dpf[pos][depth - 1] - \ dpf[pos][depth - 2] + dps[pos][pos] - dps[pos][depth - 2] dpf[pos + 1][depth] += dpf[pos + 1][depth - 1] dpf[pos + 1][depth] %= MOD for p in range(pos + 2, n+1): dpf[pos + 1][p] += dpf[pos + 1][p - 1] dpf[pos + 1][p] %= MOD ans = dps[n][n] % MOD print(ans)",quadratic,['dp'],877
"n=int(input()) f=[input().strip()==""f"" for ii in range(n)] mod=10**9+7 def summ(a,b): return (a+b)%mod dp=[1] for ii in range(1,n): pf=f[ii-1] if pf: dp.insert(0,0) else: for jj in reversed(range(1,len(dp))): dp[jj-1]=summ(dp[jj-1],dp[jj]) ans=0 for vv in dp: ans=summ(ans,vv) print(ans)",quadratic,['dp'],287
"MOD = int(1e9+7) n = int(input()) a = [input() for i in range(n)] dp = [1] for i in range(n): if a[i] == 'f': dp.append(0) continue for j in range(1, len(dp)): dp[j] = (dp[j] + dp[j-1]) % MOD print(dp[-1])",quadratic,['dp'],205
"import sys import math input = sys.stdin.readline from functools import cmp_to_key; def pi(): return(int(input())) def pl(): return(int(input(), 16)) def ti(): return(list(map(int,input().split()))) def ts(): s = input() return(list(s[:len(s) - 1])) def invr(): return(map(int,input().split())) mod = 1000000007; f = []; def fact(n,m): global f; f = [1 for i in range(n+1)]; f[0] = 1; for i in range(1,n+1): f[i] = (f[i-1]*i)%m; def fast_mod_exp(a,b,m): res = 1; while b > 0: if b & 1: res = (res*a)%m; a = (a*a)%m; b = b >> 1; return res; def inverseMod(n,m): return fast_mod_exp(n,m-2,m); def ncr(n,r,m): if n < 0 or r < 0 or r > n: return 0; if r == 0: return 1; return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m; def main(): C(); def D(): [n,m,k] = ti(); w = [[] for i in range(n)]; for i in range(n): w[i] = ts(); mn = [[0 for j in range(k+1)] for i in range(n+1)]; for i in range(1,n+1): for j in range(k+1): c = 0; st,en = -1,-1; for x in range(m): if w[i-1][x] == '1': if c == j and st == -1: st = x; if c < j: c += 1; if c == j: en = x; mn[i][j] = en-st+1 if st != -1 and en != -1 else 0; st,en = -1,-1; c = 0; for x in range(m-1,-1,-1): if w[i-1][x] == '1': if c == j and st == -1: st = x; if c < j: c += 1; if c == j: en = x; if st != -1 and en != -1 >= 0: mn[i][j] = min(mn[i][j], st-en+1); dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)]; for i in range(k+1): dp[0][i] = 0; for i in range(1,n+1): for j in range(k+1): for x in range(k+1): if j-x >= 0: dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]); print(dp[n][k]); def C(): n = pi(); s = []; mxI = 0; for i in range(n): c = input(); s.append(c[:len(c)-1]); if s[len(s)-1] == 'f': mxI += 1; dp = [[0 for j in range(mxI+1)] for i in range(n)]; dp[0][0] = 1; preSum = [1 for i in range(mxI+1)]; pre = 1; for i in range(1,n): sm = 0; pre = 0; for j in range(mxI+1): if s[i-1] == 'f': dp[i][j] = dp[i-1][j-1]%mod; else: dp[i][j] = (preSum[mxI]%mod-(pre if j != 0 else 0)%mod)%mod; pre = preSum[j]; preSum[j] = (",quadratic,['dp'],2000
"n = int(input()) mod = 10**9+7 dp = [0]*(n+1) dp[0] = 1 for i in range(n): nx = [0]*(n+1) s = str(input()) if s == 'f': nx[0] = 0 for j in range(1, n+1): nx[j] = dp[j-1] nx[j] %= mod else: nx[n] = dp[n] for j in reversed(range(n)): nx[j] = nx[j+1] nx[j] += dp[j] nx[j] %= mod if i != n-1: dp = nx print(sum(dp)%mod)",quadratic,['dp'],315
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = sel",quadratic,['dp'],1999
"n = int(input()) def prefix_sums(A): n = len(A) P = [0] * n P[0] = A[0] for k in range(1, n): P[k] = int((P[k - 1] + A[k]) % (1e9+7)) return P arr = [[0] * n for _ in range(n)] s = '' for i in range(n): inst = input() s += inst def find_ans(): idx = 0 for i in range(len(arr)-1): arr[0][0] = 1 if s[i] == 'f': for j in range(0, len(arr)): arr[i+1][0] = 0 if j > 0: arr[i+1][j] = arr[i][j-1] idx = i+1 else: val = 0 arr[i+1] = prefix_sums(arr[i][::-1])[::-1] return arr if n == 1 or 'f' not in s: if s[0] == 's': print(1) else: print(int(sum(find_ans()[-1]) % (1e9+7))) else: print(int(sum(find_ans()[-1]) % (1e9+7)))",quadratic,['dp'],616
"modulo = int(1e9+7) n = int(input()) arr = [input() for i in range(n)] dp = [1] for i in range(n): if arr[i] == 'f': dp.append(0) continue; for j in range(1, len(dp)): dp[j] = (dp[j] + dp[j-1]) % modulo print(dp[-1])",quadratic,['dp'],216
"import sys lines = int(sys.stdin.readline()) dp = [0] * lines f = 1 dp[0] = 1 for i in range(lines): char_in = sys.stdin.readline()[0] if char_in == 'f': f += 1 else: for j in range(1, f): dp[j] = (dp[j] + dp[j- 1]) % 1000000007 print(dp[f - 1])",quadratic,['dp'],245
"n = int(input().rstrip()) arr = [] mod = pow(10,9) + 7 indent_num = 0 for i in range(n): arr.append(input().rstrip()) if arr[i] == 'f': indent_num += 1 dp = [0 for i in range(indent_num + 1)] first_block_index = 0 max_indent = 0 for i in arr: if i != 'f': break first_block_index += 1 max_indent += 1 dp[max_indent] = 1 cur_indent = 0 pref = [0 for i in range(indent_num + 1)] def cal_pref(dp, pref): pref[0] = dp[0] for i in range(1, len(dp)): pref[i] = pref[i - 1] + dp[i] for i in range(first_block_index + 1,n): if arr[i] == 'f': cur_indent += 1 max_indent += 1 continue cur = [0 for i in range(indent_num + 1)] cal_pref(dp, pref) for j in range(cur_indent,indent_num + 1): res_idx = j - cur_indent res_result = pref[res_idx - 1] if res_idx > 0 else 0 cur[j] = (pref[indent_num] - res_result) % mod cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent] dp = cur cur_indent = 0 print(sum(dp) % mod)",quadratic,['dp'],911
"n = int(input().rstrip()) arr = [] mod = pow(10,9) + 7 indent_num = 0 for i in range(n): arr.append(input().rstrip()) if arr[i] == 'f': indent_num += 1 dp = [0 for i in range(indent_num + 1)] max_indent = 0 cur_indent = 0 pref = [0 for i in range(indent_num + 1)] def cal_pref(dp, pref): pref[0] = dp[0] for i in range(1, len(dp)): pref[i] = pref[i - 1] + dp[i] for i in range(n): if arr[i] == 'f': cur_indent += 1 max_indent += 1 continue cur = [0 for i in range(indent_num + 1)] cal_pref(dp, pref) for j in range(cur_indent,indent_num + 1): res_idx = j - cur_indent res_result = pref[res_idx - 1] if res_idx > 0 else 0 cur[j] = (pref[indent_num] - res_result) % mod cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent] dp = cur cur_indent = 0 print(sum(dp) % mod)",quadratic,['dp'],776
"from sys import stdin,stdout from collections import deque nmbr = lambda: int(input()) lst = lambda: list(map(int, input().split())) PI=float('inf') M=10**9+7 for _ in range(1): n=nmbr() s=[input() for _ in range(n)] dp=[[0 for _ in range(n+1)] for _ in range(n+1)] dp[0][0]=1 for i in range(1,n): for j in range(n): if i>=1 and s[i-1]=='f': if j>=1:dp[i][j]=dp[i-1][j-1]-(dp[i-1][j]) elif i>=1: dp[i][j]=dp[i-1][j] dp[i][j]%=M for k in range(n-1,-1,-1): dp[i][k]=(dp[i][k]+dp[i][k+1])%M print(dp[n-1][0]%M)",quadratic,['dp'],507
"M=10**9+7 n=int(input()) a=[] for i in range(n): a.append(input()) dp=[[0]*(n+5) for i in range(n+2)] dp[0][0]=1 for i in range(1,n): count=0 if a[i-1]=='f': for j in range(n-2,-1,-1): if dp[i-1][j]>0: dp[i][j+1]=(dp[i][j+1]+dp[i-1][j])%M else: for j in range(n-2,-1,-1): if dp[i-1][j]>0: count=(count+dp[i-1][j])%M dp[i][j]=(dp[i][j]+count)%M print(sum(dp[n-1])%M)",quadratic,['dp'],365
"import sys input=sys.stdin.readline n=int(input()) c=["" ""]+[input().rstrip() for i in range(n)] mod=10**9+7 dp=[[0]*(n+1) for i in range(n+1)] dp[1][0]=1 sdp=[0]*(n+1) sdp[0]=1 for i in range(1,n+1): if i>=2 and c[i-1]==""f"": for j in range(1,n+1): dp[i][j]=dp[i-1][j-1] dp[i][j]%=mod dp[i][0]=0 else: for j in range(n+1): dp[i][j]=sdp[j] dp[i][j]%=mod sdp=[dp[i][j] for j in range(n+1)] for j in range(1,n+1)[::-1]: sdp[j-1]+=sdp[j] sdp[j-1]%=mod print(sdp[0]%mod)",quadratic,['dp'],464
"mod=10**9+7 n=int(input()) l=[] c=0 for i in range(n): l.append(input()) dp=[[0]*(n+2) for i in range(n+1)] for i in range(n+2): dp[n][i]=1 for i in range(n-1,0,-1): s=0 for j in range(n+1): s+=dp[i+1][j] s%=mod if l[i-1]=='f': dp[i][j]=dp[i+1][j+1] else: dp[i][j]=s print(dp[1][0])",quadratic,['dp'],282
"from sys import stdin,stdout,setrecursionlimit stdin.readline def mp(): return list(map(int, stdin.readline().strip().split())) def it():return int(stdin.readline().strip()) from collections import defaultdict as dd,Counter as C,deque from math import ceil,gcd,sqrt,factorial,log2,floor from bisect import bisect_right as br,bisect_left as bl from heapq import * mod = 10**9+7 def solve(): n = it() v=[0]*(n+1) for i in range(1,n+1): v[i] = input() dp=[[0]*(n+2) for _ in range(n+1)] for l in range(n+2): dp[n][l] = 1 for i in range(n-1,0,-1): curr_sum = 0 for l in range(n): curr_sum += dp[i+1][l] curr_sum%=mod if v[i] == 'f': dp[i][l] = dp[i+1][l+1] else: dp[i][l]= curr_sum print(dp[1][0]) solve()",quadratic,['dp'],701
"n = int(input()) dp = [1] for IND in range(n): c = input() if c == ""f"": dp.insert(0,0) else: for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007 print(dp[0])",quadratic,['dp'],179
"MOD=int(1e9+7) n=int(input()) a=[] for i in range(n): a.append(input()) a="""".join(a) dp,s=[],[] for i in range(n+1): dp.append([0]*(n+1)) s.append([0]*(n+1)) dp[0][0]=1 s[0][0]=1 for i in range(1,n): for j in range(0,n): if a[i-1]=='f': dp[i][j+1]=dp[i-1][j]%MOD elif a[i-1]=='s': dp[i][j]=s[i-1][j]%MOD for j in reversed(range(n)): s[i][j]+=(dp[i][j]+s[i][j+1])%MOD print(s[n-1][0]%MOD)",quadratic,['dp'],387
"import sys input = sys.stdin.readlines() n = int(input[0].strip()) m = 10**9 + 7 curr = [0] * (n+20) last = [0] * (n+20) curr[0] = 1 for s in range(1,n): last, curr = curr, last if input[s]=='f\n': curr[0] = 0 for i in range(len(last)-1): curr[i+1] = last[i] elif input[s]=='s\n': curr[-1] = 0 for i in range(len(last)-2, -1, -1): curr[i] = (curr[i+1] + last[i]) % m s = 0 for x in curr: s = (s + x) % m print(s)",quadratic,['dp'],412
"def add(a,b): a = a%(1000000000+7) b=b%(1000000000+7) return (a+b)%(1000000000+7) n =int(input()) i=1 statements = [] dp = [[0 for i in range(n)] for i in range(n)] prefix = [[0 for i in range(n)] for i in range(n)] while(i<=n): s = input() statements.append(s) i+=1 dp[0][0]=1 prefix[0][0]=1 j=1 while(j<n): dp[0][j]=0 prefix[0][j] = dp[0][j] + prefix[0][j-1] j+=1 i=1 while(i<n): if(statements[i-1]=='f'): j=1 while(j<n): dp[i][0]=0 prefix[i][0]=0 dp[i][j] = dp[i-1][j-1] prefix[i][j] = add(prefix[i][j-1],dp[i][j]) j+=1 else: j=0 while(j<n): if(j==0): dp[i][j] = prefix[i-1][n-1] else: dp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1] prefix[i][j] = add(prefix[i][j-1],dp[i][j]) j+=1 i+=1 ans = 0 j=0 while(j<n): ans=add(ans,dp[n-1][j]) j+=1 print(ans%(1000000000+7))",quadratic,['dp'],768
"def add(x,j): x = x % (1000000000+7) j=j % (1000000000+7) return (x+j) % (1000000000+7) statements = [] n =int(input()) i=1 j=1 temp = [[0 for i in range(n)] for i in range(n)] earlier = [[0 for i in range(n)] for i in range(n)] temp[0][0]=1 earlier[0][0]=1 while(i<=n): s = input() statements.append(s) i+=1 while(j<n): temp[0][j]=0 earlier[0][j] = temp[0][j] + earlier[0][j-1] j+=1 i=1 while(i<n): if(statements[i-1]=='f'): j=1 while(j<n): temp[i][0]=0 earlier[i][0]=0 temp[i][j] = temp[i-1][j-1] earlier[i][j] = add(earlier[i][j-1],temp[i][j]) j+=1 else: j=0 while(j<n): if(j==0): temp[i][j] = earlier[i-1][n-1] else: temp[i][j] = earlier[i-1][n-1] - earlier[i-1][j-1] earlier[i][j] = add(earlier[i][j-1],temp[i][j]) j+=1 i+=1 ans = 0 j=0 while(j<n): ans=add(ans,temp[n-1][j]) j+=1 print(ans%(1000000000+7))",quadratic,['dp'],810
"n = int(input()) dp = [1] for IND in range(n): c = input() if c == ""f"": dp.insert(0,0) else: for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007 print(dp[0])",quadratic,['dp'],179
"import sys class fenwick(): def __init__(self, n): self.n = n self.data = [0]*(n+1) def to_sum(self, i): s = 0 while i > 0: s += self.data[i] i -= (i & -i) return s def add(self, i, x): while i <= self.n: self.data[i] += x i += (i & -i) def get(self, i, j): return self.to_sum(j)-self.to_sum(i-1) def input(): return sys.stdin.buffer.readline() n = int(input()) permutation = list(map(int, input().split())) seq = [(permutation[i], i + 1) for i in range(n)] seq.sort(reverse=True) m = int(input()) query = [tuple(map(int, input().split())) for i in range(m)] WHOLE_INVERSION = 0 fenwick_1 = fenwick(n) for value, index in seq: WHOLE_INVERSION += fenwick_1.get(1, index) fenwick_1.add(index, 1) for l, r in query: d = r - l + 1 WHOLE_INVERSION += d*(d-1)//2 if WHOLE_INVERSION % 2 != 0: print(""odd"") else: print(""even"")",quadratic,"['brute force', 'math']",818
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): import os self.os = os self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: self.os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def inv_cnt(b): c = 0 visited = set() for i in range(len(b)): if i + 1 in visited: pass else: visited.add(i) path = [i + 1] while b[path[-1] - 1] != path[0]: visited.add(b[path[-1] - 1]) path.append(b[path[-1] - 1]) c += len(path) - 1 return c % 2 def solve(): n = int(input()) a = [int(x) for x in input().split(' ')] x = inv_cnt(a) m = int(input()) for query in range(m): l, r = [int(x) for x in input().split(' ')] x = (x + (r - l + 1) // 2) % 2 if x: print(""odd"") else: print(""even"") solve()",quadratic,"['brute force', 'math']",1940
"n = int(input()) a = list(map(int, input().split())) m = int(input()) parity = 0 for i in range(n): for j in range(i + 1, n): if a[i] > a[j]: parity ^= 1 res = [] for _ in range(m): l, r = map(int, input().split()) s = r - l + 1 parity ^= (s * (s - 1) // 2) % 2 res.append(""odd"" if parity else ""even"") print(""\n"".join(res))",quadratic,"['brute force', 'math']",323
"def divisors(M): d=[] i=1 while M>=i**2: if M%i==0: d.append(i) if i**2!=M: d.append(M//i) i=i+1 return d def popcount(x): x = x - ((x >> 1) & 0x55555555) x = (x & 0x33333333) + ((x >> 2) & 0x33333333) x = (x + (x >> 4)) & 0x0f0f0f0f x = x + (x >> 8) x = x + (x >> 16) return x & 0x0000007f def eratosthenes(n): res=[0 for i in range(n+1)] prime=set([]) for i in range(2,n+1): if not res[i]: prime.add(i) for j in range(1,n//i+1): res[i*j]=1 return prime def factorization(n): res=[] for p in prime: if n%p==0: while n%p==0: n//=p res.append(p) if n!=1: res.append(n) return res def euler_phi(n): res = n for x in range(2,n+1): if x ** 2 > n: break if n%x==0: res = res//x * (x-1) while n%x==0: n //= x if n!=1: res = res//n * (n-1) return res def ind(b,n): res=0 while n%b==0: res+=1 n//=b return res def isPrimeMR(n): d = n - 1 d = d // (d & -d) L = [2, 3, 5, 7, 11, 13, 17] for a in L: t = d y = pow(a, t, n) if y == 1: continue while y != n - 1: y = (y * y) % n if y == 1 or t == n - 1: return 0 t <<= 1 return 1 def findFactorRho(n): from math import gcd m = 1 << n.bit_length() // 8 for c in range(1, 99): f = lambda x: (x * x + c) % n y, r, q, g = 2, 1, 1, 1 while g == 1: x = y for i in range(r): y = f(y) k = 0 while k < r and g == 1: ys = y for i in range(min(m, r - k)): y = f(y) q = q * abs(x - y) % n g = gcd(q, n) k += m r <<= 1 if g == n: g = 1 while g == 1: ys = f(ys) g = gcd(abs(x - ys), n) if g < n: if isPrimeMR(g): return g elif isPrimeMR(n // g): return n // g return findFactorRho(g) def primeFactor(n): i = 2 ret = {} rhoFlg = 0 while i*i <= n: k = 0 while n % i == 0: n //= i k += 1 if k: ret[i] = k i += 1 + i % 2 if i == 101 and n >= 2 ** 20: while n > 1: if isPrimeMR(n): ret[n], n = 1, 1 else: rhoFlg = 1 j = findFactorRho(n) k = 0 while n % j == 0: n //= j k += 1 ret[j] = k if n > 1: ret[n] = 1 if rhoFlg: ret = {x: ret[x] for x in sorted(ret)} return ret def divisors(n): res = [1] prime = primeFactor(n) for p in prime: newres = [] for d in res: for j in range(prime[",quadratic,"['brute force', 'math']",2000
"import sys readline = sys.stdin.readline N = int(readline()) A = list(map(int, readline().split())) Q = int(readline()) cnt = 0 for i in range(N): for j in range(i+1, N): if A[i] > A[j]: cnt += 1 cnt %= 2 Ans = [None]*Q for qu in range(Q): l, r = map(int, readline().split()) if (r-l+1)*(r-l)//2 & 1: cnt ^= 1 Ans[qu] = 'odd' if cnt else 'even' print('\n'.join(Ans))",quadratic,"['brute force', 'math']",366
"import sys,math,itertools from collections import Counter,deque,defaultdict from bisect import bisect_left,bisect_right from heapq import heappop,heappush,heapify, nlargest from copy import deepcopy mod = 10**9+7 INF = float('inf') def inp(): return int(sys.stdin.readline()) def inpl(): return list(map(int, sys.stdin.readline().split())) def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split())) def inps(): return sys.stdin.readline() def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x]) def err(x): print(x); exit() n = inp() a = inpl() res = 0 for i in range(n): for j in range(i+1,n): if a[i] > a[j]: res = 1-res for _ in range(inp()): l,r = inpl(); m = r-l+1 swap = m*(m-1)//2 if swap%2: res = 1-res print('odd' if res else 'even')",quadratic,"['brute force', 'math']",770
"import math import random import heapq, bisect import sys from collections import deque, defaultdict from fractions import Fraction import sys import threading from collections import defaultdict mod = 10 ** 9 + 7 mod1 = 998244353 import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class TreeNode: def __init__(self, k, v): self.key = k self.value = v self.left = None self.right = None self.parent = None self.height = 1 self.num_left = 1 self.num_total = 1 class AvlTree: def __init__(self): self._tree = None def add(self, k, v): if not self._tree: self._tree = TreeNode(k, v) return node = self._add(k, v) if node: self._rebalance(node) def _add(sel",quadratic,"['brute force', 'math']",1999
"import sys input = sys.stdin.buffer.readline n = int(input()) a = list(map(int,input().split())) parity = 0 for i in range(n): for j in range(i+1,n): if a[j] < a[i]: parity ^= 1 m = int(input()) for i in range(m): l,r = map(int,input().split()) dist = (r-l+1) pairs = (dist-1)*(dist)//2 if pairs & 1: parity ^= 1 if parity: print(""odd"") else: print(""even"")",quadratic,"['brute force', 'math']",356
"import os import sys from io import BytesIO, IOBase import math from queue import Queue import collections import itertools import bisect import heapq import random def main(): pass BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while (n > 1): n //= 2 p += 1 return (p) def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: l.append(i) n = n / i if n > 2: l.append(int(n)) return (l) def primeFactorsCount(n): cnt=0 while n % 2 == 0: cnt+=1 n = n // 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: cnt+=1",quadratic,"['brute force', 'math']",1999
"from collections import Counter from math import * import sys mod=1000000007 def pro(arr,q): n=len(arr) ans=0 for i in range(n): for j in range(i+1,n): if(arr[i]>arr[j]): ans+=1 res=ans%2 for x,y in q: k= y-x + 1 k=k//2 k=k%2 res= k^res if(res): print('odd') else: print('even') n=int(input()) arr=list(map(int,input().split())) t=int(input()) que=[] for i in range(t): que.append(list(map(int,input().split()))) pro(arr,que)",quadratic,"['brute force', 'math']",425
"import io import os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline n = int(input()) arr = [int(z) for z in input().split()] q = int(input()) inv = 0 for i in range(n): for j in range(n): if i < j and arr[i] > arr[j]: inv += 1 inv = inv % 2 for query in range(q): l, r = map(int, input().split()) diff = r - l s = diff//2 if diff % 2: s += 1 inv = (inv + (s % 2)) % 2 if inv: print(""odd"") else: print(""even"")",quadratic,"['brute force', 'math']",421
"n=int(input()) w=[int(k) for k in input().split()] m=int(input()) c=0 for i in range(n): for j in range(i+1, n): if w[i]>w[j]: c+=1 c%=2 for j in range(m): l, r=[int(k) for k in input().split()] x=r-l+1 if x!=1 and (x*(x-1)//2)%2: c=not c if c: print(""odd"") else: print(""even"")",quadratic,"['brute force', 'math']",277
"from sys import stdin, stdout n = int(stdin.readline()) values = list(map(int, stdin.readline().split())) cnt = 0 for i in range(n): for j in range(i + 1, n): if values[i] > values[j]: cnt += 1 m = int(stdin.readline()) for i in range(m): l, r = map(int, stdin.readline().split()) n = r - l + 1 cnt += n * (n - 1) // 2 cnt &= 1 if cnt == 1: stdout.write('odd\n') else: stdout.write('even\n')",quadratic,"['brute force', 'math']",391
"import sys f=sys.stdin n=int(f.readline()) a=list(map(int,f.readline().split())) s=0 for i in range(n): for j in range(i): s^=a[j]>a[i] q=int(f.readline()) for i in range(q): l,r=map(int,f.readline().split()) s^=(r-l+1)*(r-l)//2%2 print(['even','odd'][s])",quadratic,"['brute force', 'math']",255
"if __name__ == ""__main__"": n = int(input()) nums = [int(a) for a in input().strip().split()] counts = 0 for i in range(n-1): for j in range(i + 1, n): if nums[i] > nums[j]: counts += 1 ans = counts % 2 ans_tmp = [] m = int(input()) for i in range(m): l, r = [int(a) for a in input().strip().split()] tmp = r - l + 1 tmp_count = (tmp * (tmp - 1) // 2) if tmp_count % 2 == 1: ans = (ans + 1) % 2 ans_tmp.append(ans) for i in range(m): ans = ans_tmp[i] if ans % 2 == 1: print(""odd"") else: print(""even"")",quadratic,"['brute force', 'math']",499
"n = int(input()) d = list(map(int, input().split())) odd = 0 for i in range(n): for j in range(i, n): if(d[i]>d[j]): odd ^= 1 m = int(input()) ans = [] for i in range(m): l, r = map(int, input().split()) k = r-l+1 if( (k*(k-1)/2) %2): odd ^= 1 ans.append( ""odd"" if odd else ""even"") print('\n'.join(ans))",quadratic,"['brute force', 'math']",303
"import sys input=sys.stdin.readline def getsum(BITTree,i): i=i+1 s = 0 while i > 0: s += BITTree[i] i -= i & (-i) return(s) def updatebit(BITTree , n , i ,v): i=i+1 while i <= n: BITTree[i] += v i += i & (-i) n=int(input()) lista=[int(i) for i in input().split()] invercount=0 bitTree=[0]*(n+2) for k in reversed(lista): updatebit(bitTree,n+1,k,1) counter=getsum(bitTree,k-1) invercount+=counter m=int(input()) for i in range(m): l,r=map(int,input().split()) summa=((r-l+1)*(r-l))/2 if (invercount+summa)%2: print('odd') invercount=1 else: print('even') invercount=0",quadratic,"['brute force', 'math']",566
"def main(): import sys input = sys.stdin.readline n = int(input()) a = list(map(int, input().split())) cnt = 0 for i in range(n): for j in range(i+1, n): if a[i] > a[j]: cnt += 1 even = cnt % 2 == 0 q = int(input()) for _ in range(q): l, r = map(int, input().split()) len = r - l + 1 pairs = len * (len-1) // 2 if pairs % 2 == 1: even = not even if even: print('even') else: print('odd') main()",quadratic,"['brute force', 'math']",394
"def main(): import sys input = sys.stdin.readline n = int(input()) a = list(map(int, input().split())) cnt = 0 for i in range(n): for j in range(i+1, n): if a[i] > a[j]: cnt += 1 even = cnt % 2 == 0 q = int(input()) ans = [] for _ in range(q): l, r = map(int, input().split()) len = r - l + 1 pairs = len * (len-1) // 2 if pairs % 2 == 1: even = not even if even: ans.append('even') else: ans.append('odd') print('\n'.join(ans)) main()",quadratic,"['brute force', 'math']",435
"def main(): n = int(input()) a = list(map(int, input().split())) cnt = 0 for i in range(n): for j in range(i+1, n): if a[i] > a[j]: cnt += 1 even = cnt % 2 == 0 q = int(input()) ans = [] for _ in range(q): l, r = map(int, input().split()) len = r - l + 1 pairs = len * (len-1) // 2 if pairs % 2 == 1: even = not even if even: ans.append('even') else: ans.append('odd') print('\n'.join(ans)) main()",quadratic,"['brute force', 'math']",397
"import sys input = sys.stdin.readline n = int(input()) a = list(map(int, input().split())) cnt = 0 for i in range(n): for j in range(i+1, n): if a[i] > a[j]: cnt += 1 even = cnt % 2 == 0 q = int(input()) ans = [] for _ in range(q): l, r = map(int, input().split()) len = r - l + 1 pairs = len * (len-1) // 2 if pairs % 2 == 1: even = not even if even: ans.append('even') else: ans.append('odd') print('\n'.join(ans))",quadratic,"['brute force', 'math']",416
"import sys input = sys.stdin.readline maxn = int(1510) ST = [0 for _ in range(4 * maxn)] def update(id, l, r, val): if l == r == val: ST[id] = 1 return if l > val or r < val: return mid = int((l + r) / 2) update(id * 2, l, mid, val) update(id * 2 + 1, mid + 1, r, val) ST[id] = ST[id * 2] + ST[id * 2 + 1] return def get(id, l, r, x, y): if l > y or r < x: return 0 if x <= l and r <= y: return ST[id] mid = int((l + r) / 2) return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y) n, res = int(input()), 0 for x in list(map(int, input().split())): res ^= get(1, 1, n, x + 1, n) % 2 update(1, 1, n, x) for i in range (int(input())): x, y = list(map(int, input().split())) if int((y - x) * (y - x + 1) / 2) & 1: res ^= 1 if res: print(""odd"") else: print(""even"")",quadratic,"['brute force', 'math']",772
"import sys input = sys.stdin.readline maxn = int(1e5 + 10) ST = [0] * (4 * maxn) def update(id, l, r, val): if l == r == val: ST[id] = 1 return if l > val or r < val: return mid = int((l + r) / 2) update(id * 2, l, mid, val) update(id * 2 + 1, mid + 1, r, val) ST[id] = ST[id * 2] + ST[id * 2 + 1] return def get(id, l, r, x, y): if l > y or r < x: return 0 if x <= l and r <= y: return ST[id] mid = int((l + r) / 2) return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y) n, res = int(input()), 0 for x in list(map(int, input().split())): res ^= get(1, 1, n, x + 1, n) % 2 update(1, 1, n, x) for i in range (int(input())): x, y = list(map(int, input().split())) if int((y - x) * (y - x + 1) / 2) & 1: res ^= 1 if res: print(""odd"") else: print(""even"")",quadratic,"['brute force', 'math']",764
"def arr_inp(): return [int(x) for x in stdin.readline().split()] def nCr(n, r): f, m = factorial, 1 for i in range(n, n - r, -1): m *= i return int(m // f(r)) from math import factorial from sys import stdin n, a, ans, tem = int(input()), arr_inp(), [], 0 mem = [0] * (n + 1) for i in range(n): for j in range(a[i] - 1, 0, -1): if not mem[j]: tem += 1 mem[a[i]] = 1 for i in range(int(input())): l, r = arr_inp() tem += nCr(r - l + 1, 2) ans.append('odd' if tem % 2 else 'even') print('\n'.join(ans))",quadratic,"['brute force', 'math']",500
"n = int(input()) l = list(map(int, input().split())) odd = 0 for i in range(n): for j in range(i, n): if(l[i]>l[j]): odd ^= 1 m = int(input()) ans = [] for i in range(m): ll, r = map(int, input().split()) k = r-ll+1 if( (k*(k-1)/2) %2): odd ^= 1 ans.append( ""odd"" if odd else ""even"") print('\n'.join(ans))",quadratic,"['brute force', 'math']",305
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") mod=10**9+7 n=int(input()) a=list(map(int,input().split())) c=0 for i in range (1,n): for j in range (i): if a[j]>a[i]: c+=1 c=c%2 m=int(input()) for i in range (m): l,r=map(int,input().split()) s=(r-l+1)//2 if s%2==1: c=(c+1)%2 if c==0: print(""even"") else: print(""odd"")",quadratic,"['brute force', 'math']",1800
"import zlib, base64 exec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))",quadratic,"['bitmasks', 'dp', 'shortest paths']",1140
"dat = ""硼磷碳磷溴硼氧磷氮硫氮氯氟溴硼磷碳硼硫碳氯溴硼磷碳硼硫溴硼磷碳硼氯碳硫溴硼磷碳硼氯溴硼氧硼硫碳硼氯氮磷氮硫碳氯氟溴硼氧磷氮硫碳氯氟溴硼磷碳硫碳氯溴硼氧硼硫碳氯氮硼氯碳硫氮磷氟溴硼磷碳氯溴硼氧硼氯碳硫氮磷氟溴硼磷碳硫溴硼氧硼硫碳氯氮磷氟溴硼磷碳氧硫氮氯氟溴硼磷溴硼硫碳硼氯碳磷溴硼硫碳硼氯溴硼氧硼磷碳硼氯氮磷碳氯氮硫氟溴硼氧磷碳氯氮硫氟溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟溴硼氧磷碳硫氮氯氟溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮硼磷碳硼硫碳氯溴硼氧氧磷氮硫氟碳氯氮磷碳硫氟溴硼磷碳硫碳氯氮硼硫碳硼氯碳磷溴硼磷碳硫碳氯氮硼硫碳硼氯溴硼磷碳氯氮硼硫碳硼氯碳磷溴硼磷碳氯氮硼硫碳硼氯溴硼磷碳硫氮硼硫碳硼氯碳磷溴硼磷碳硫氮硼硫碳硼氯溴硼磷碳氧硫氮氯氟氮硼硫碳硼氯碳磷溴硼磷氮硼硫碳硼氯溴硼硫碳磷碳氯溴硼氧硼磷碳氯氮硼氯碳磷氮硫氟溴硼硫碳氯溴硼氧硼氯碳磷氮硫氟溴硼磷碳硼氯碳硫氮硼硫碳磷碳氯溴硼磷碳硼氯氮硼硫碳磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氯溴硼磷碳硼氯氮硼硫碳氯溴硼磷碳硫碳氯氮硼硫碳磷碳氯溴硼氧硼磷碳氯氮硼氯碳磷氮硫氟氮硼磷碳硫碳氯溴硼氧磷碳硫氟碳氯溴硼氧硼氯碳磷氮硫氟氮硼磷碳氯溴硼磷碳硫氮硼硫碳磷碳氯溴硼氧硼硫碳氯氮磷氟氮硼硫碳磷碳氯溴硼磷碳硫氮硼硫碳氯溴硼磷氮硼硫碳氯溴硼硫碳磷溴硼氧硼磷碳氯氮硫氟溴硼硫碳氧磷氮氯氟溴硼硫溴硼磷碳硼氯碳硫氮硼硫碳磷溴硼磷碳硼氯氮硼硫碳磷溴硼磷碳硼氯碳硫氮硼硫碳氧磷氮氯氟溴硼磷碳硼氯氮硼硫溴硼磷碳硫碳氯氮硼硫碳磷溴硼氧硼磷碳氯氮硫氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼硫碳磷溴硼磷碳氯氮硼硫溴硼磷碳硫氮硼硫碳磷溴硼氧硼磷碳硼硫碳氯氮磷碳硫氟溴硼磷碳氧硫氮氯氟氮硼硫碳磷溴硼磷氮硼硫溴硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳磷碳硫溴硼磷碳硼硫氮硼氯碳磷碳硫溴硼氯碳硫溴硼氧硼硫碳磷氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳硫溴硼磷碳硼硫氮硼氯碳硫溴硼磷碳硫碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳硫氮磷氟氮硼氯碳磷碳硫溴硼氧磷碳氯氟碳硫溴硼氧硼硫碳磷氮氯氟氮硼磷碳硫溴硼磷碳氯氮硼氯碳硫溴硼磷氮硼氯碳硫溴硼氯碳磷溴硼氧硼磷碳硫氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳磷溴硼磷碳硼硫氮硼氯碳磷溴硼氯碳氧磷氮硫氟溴硼氯溴硼磷碳硼硫碳氯氮硼氯碳氧磷氮硫氟溴硼磷碳硼硫氮硼氯溴硼磷碳硫碳氯氮硼氯碳磷溴硼氧硼磷碳硫氮氯氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼氯碳磷溴硼氧硼磷碳硼氯碳硫氮磷碳氯氟溴硼磷碳硫氮硼氯碳磷溴硼磷碳硫氮硼氯溴硼磷碳氧硫氮氯氟氮硼氯碳磷溴硼磷氮硼氯溴硼硫碳磷碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼硫碳磷碳氯溴硼硫碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳磷氮硫氟氮硼氯碳磷碳硫溴硼硫碳磷碳氯氮硼氯碳硫溴硼氧硼硫碳磷氮氯氟氮硼硫碳磷碳氯溴硼硫碳氯氮硼氯碳硫溴硼氧硼硫碳硼氯碳磷氮硫碳氯氟溴硼磷碳硫碳氯氮硼硫碳磷碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼磷碳硫碳氯氮硼硫碳磷碳氯溴硼氧磷碳硫氟碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳磷氮硫氟氮硼磷碳氯氮硼氯碳磷碳硫溴硼氧磷碳氯氟碳硫氮硼硫碳磷碳氯溴硼氧硼硫碳磷氮氯氟氮硼磷碳硫氮硼硫碳磷碳氯溴硼氧磷碳硫氟碳氯氮硼氯碳硫溴硼磷氮硼硫碳氯氮硼氯碳硫溴硼氧硫碳氯氟碳磷溴硼氧硼磷碳硫氮氯氟氮硼硫碳磷溴硼硫碳氯氮硼氯碳磷溴硼硫氮硼氯碳磷溴硼硫碳磷氮硼氯碳硫溴硼硫碳磷氮硼氯溴硼硫碳氧磷氮氯氟氮硼氯碳硫溴硼硫氮硼氯溴硼氧硫碳氯氟碳磷氮硼磷碳硫碳氯溴硼氧硼磷碳硫氮氯氟氮硼磷碳硫碳氯氮硼硫碳磷溴硼氧磷碳硫氟碳氯氮硼氯碳磷溴硼磷碳氯氮硼硫氮硼氯碳磷溴硼氧磷碳氯氟碳硫氮硼硫碳磷溴硼磷碳硫氮硼硫碳磷氮硼氯溴硼磷碳硫氮硼硫碳氯氮硼氯碳磷溴硼氧磷碳硫碳氯氟溴磷碳硫碳氯溴硼氧磷氮硫氮氯氟氮磷碳硫碳氯溴硼磷碳硼硫碳氯氮磷碳硫碳氯溴硼磷碳硼硫氮磷碳硫碳氯溴硼磷碳硼氯碳硫氮磷碳硫碳氯溴硼磷碳硼氯氮磷碳硫碳氯溴硼氧硼硫碳硼氯氮磷氮硫碳氯氟氮磷碳硫碳氯溴硼氧磷氮硫碳氯氟氮磷碳硫碳氯溴硫碳氯溴硼氧磷氮硫氮氯氟氮硫碳氯溴硼磷碳氯氮硫碳氯溴硼磷碳硼硫氮硫碳氯溴硼磷碳硫氮硫碳氯溴硼磷碳硼氯氮硫碳氯溴硼磷碳氧硫氮氯氟氮硫碳氯溴硼磷氮硫碳氯溴硼硫碳硼氯碳磷氮磷碳硫碳氯溴硼硫碳硼氯氮磷碳硫碳氯溴硼氧硼磷碳硼氯氮磷碳氯氮硫氟氮磷碳硫碳氯溴硼氧磷碳氯氮硫氟氮磷碳硫碳氯溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮磷碳硫碳氯溴硼氧磷碳硫氮氯氟氮磷碳硫碳氯溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮硼磷碳硼硫碳氯氮磷碳硫碳氯溴硼氧氧磷氮硫氟碳氯氮磷碳硫氟氮磷碳硫碳氯溴硼硫碳硼氯碳磷氮硫碳氯溴硼硫碳硼氯氮硫碳氯溴硼磷碳氯氮硼硫碳硼氯碳磷氮硫碳氯溴硼氧磷碳氯氮硫氟氮硫碳氯溴硼磷碳硫氮硼硫碳硼氯碳磷氮硫碳氯溴硼氧磷碳硫氮氯氟氮硫碳氯溴硼磷碳氧硫氮氯氟氮硼硫碳硼氯碳磷氮硫碳氯溴硼磷氮硼硫碳硼氯氮硫碳氯溴磷碳氯溴硼氧磷氮硫氮氯氟氮磷",quadratic,"['bitmasks', 'dp', 'shortest paths']",1999
"x = int('00001111', 2) y = int('00110011', 2) z = int('01010101', 2) E = set() T = set() F = {('x', x), ('y', y), ('z', z)} prv = (set(), set(), set()) fam = 2 ** 8 tmpl = ' ans = [tmpl] * fam def cmpr(E): global ans ans = [tmpl] * fam for e in E: if len(ans[e[1]]) > len(e[0]) or len(ans[e[1]]) == len(e[0]) and ans[e[1]] > e[0]: ans[e[1]] = e[0] return set((j, i) for i, j in enumerate(ans) if j != tmpl) while prv != (E, T, F): prv = E.copy(), T.copy(), F.copy() for f in prv[2]: F.add(('!' + f[0], ~f[1] & (fam - 1))) T.add(f) for t in prv[1]: T.add((t[0] + '&' + f[0], t[1] & f[1])) for t in prv[1]: E.add(t) for e in prv[0]: if e not in F: F.add(('(' + e[0] + ')', e[1])) for t in prv[1]: E.add((e[0] + '|' + t[0], e[1] | t[1])) E, T, F = cmpr(E), cmpr(T), cmpr(F) cmpr(E) n = int(input()) for i in range(n): print(ans[int(input(), 2)])",quadratic,"['bitmasks', 'dp', 'shortest paths']",842
"from heapq import * MSIZE = 1 << 8 def GetVal(s): ans = 0 for i in range(8): if s[i] == '1': ans = ans + (1 << i) return ans def GetNot(s): return MSIZE - 1 - s; xVal = GetVal('00001111') yVal = GetVal('00110011') zVal = GetVal('01010101') def Dijkstra(): depth = [['Z' * 585 for i in range(4)] for i in range(MSIZE)] depth[xVal][3] = 'x' depth[yVal][3] = 'y' depth[zVal][3] = 'z' pq = [] def push(kek): heappush(pq, kek) def pop(): return heappop(pq) push([1, xVal, 3]) push([1, yVal, 3]) push([1, zVal, 3]) while len(pq) > 0: l, i, j = pop(); if len(depth[i][j]) < l: continue for x in range(MSIZE): for y in range(4): nxt1 = depth[i][j] + '|' + depth[x][y] nxt2 = depth[x][y] + '|' + depth[i][j] nxt = min(nxt1, nxt2) val = (i | x) if len(depth[val][0]) == len(nxt) and depth[val][0] > nxt: depth[val][0] = nxt push([len(nxt), val, 0]) elif len(depth[val][0]) > len(nxt): depth[val][0] = nxt push([len(nxt), val, 0]) if j > 0: for x in range(MSIZE): for y in range(1, 4): nxt1 = depth[i][j] + '&' + depth[x][y] nxt2 = depth[x][y] + '&' + depth[i][j] nxt = min(nxt1, nxt2) val = (i & x) if len(depth[val][1]) == len(nxt) and depth[val][1] > nxt: depth[val][1] = nxt push([len(nxt), val, 1]) elif len(depth[val][1]) > len(nxt): depth[val][1] = nxt push([len(nxt), val, 1]) if j > 2: val = GetNot(i) nxt = '!' + depth[i][j] if len(depth[val][2]) == len(nxt) and depth[val][2] > nxt: depth[val][2] = nxt push([len(nxt), val, 2]) elif len(depth[val][2]) > len(nxt): depth[val][2] = nxt push([len(nxt), val, 2]) nxt = '(' + depth[i][j] + ')' val = i if len(depth[val][3]) == len(nxt) and depth[val][3] > nxt: depth[val][3] = nxt push([len(nxt), val, 3]) elif len(depth[val][3]) > len(nxt): depth[val][3] = nxt push([len(nxt), val, 3]) answer = [] for i in range(MSIZE): ans = 'Z' * 585 for j in range(4): if len(ans) > len(depth[i][j]): ans = depth[i][j] elif len(ans) == len(depth[i][j]) and ans > depth[i][j]: ans = depth[i][j] answer.append(ans) return answer kek = Dijkstra() q = int(input()) for i",quadratic,"['bitmasks', 'dp', 'shortest paths']",1999
"from collections import deque from types import GeneratorType import os import sys import math import heapq import functools import random from atexit import register from io import BytesIO import __pypy__ EPS = 10**-12 class Input(object): def __init__(self): if 'CPH' not in os.environ: sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size)) sys.stdout = BytesIO() register(lambda: os.write(1, sys.stdout.getvalue())) def rawInput(self): return sys.stdin.readline().rstrip('\r\n') def readInt(self): return int(self.rawInput()) class Output(object): def __init__(self): self.out = __pypy__.builders.StringBuilder() def write(self, text): self.out.append(str(text)) def writeLine(self, text): self.write(str(text) + '\n') def finalize(self): if sys.version_info[0] < 3: os.write(1, self.out.build()) else: os.write(1, self.out.build().encode()) def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc class CycleFindDirected(object): def __init__(self, n): self.n = n self.adj = [[] for _ in range(n)] def add_edge(self, u, v): assert 0 <= u < self.n assert 0 <= v < self.n self.adj[u].append(v) @bootstrap def dfs(self, node): self.color[node] = 1 for i in self.adj[node]: if self.color[i] == 0: self.parent[i] = node if (yield self.dfs(i)): yield True elif self.color[i] == 1: self.cycle_end = node self.cycle_start = i yield True self.color[node] = 2 yield False def find(self): self.color = [0] * self.n self.parent = [-1] * self.n self.cycle_end = -1 self.cycle_start = -1 for i in range(self.n): if not self.color[i] and self.dfs(i): answer = [] node_begin = self.cycle_start node_end = self.cycle_end answer.append(node_begin) while node_end != node_begin: answer.append(node_end) node_end = self.parent[node_end] answer.reverse() if len(answer) == 1: retur",quadratic,"['dfs and similar', 'graphs']",1999
"import sys def prepare(): stack = [i for i in range(n) if deg[i] == 0] cnt = 0 while stack: v = stack.pop() cnt += 1 for dest in adj[v]: deg[dest] -= 1 if deg[dest] == 0: stack.append(dest) adj[v].clear() return cnt == n def solve(st): stack = [st] visited = [0]*n cnt = 0 while stack: v = stack.pop() cnt += 1 for dest in adj[v]: if dest == st: continue visited[dest] += 1 if deg[dest] == visited[dest]: stack.append(dest) return cnt == m n, m = map(int, sys.stdin.buffer.readline().decode('utf-8').split()) adj = [[] for _ in range(n)] rev = [[] for _ in range(n)] deg = [0]*n for u, v in (map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer): adj[u-1].append(v-1) rev[v-1].append(u-1) deg[v-1] += 1 ok = prepare() if ok: print('YES') exit() m = len([1 for i in range(n) if deg[i] > 0]) for i in range(n): if deg[i] == 1 and solve(i): print('YES') exit() print('NO')",quadratic,"['dfs and similar', 'graphs']",884
"def my_solve(n, m, graph, mask): if do_dfs_bool(n,graph,mask.copy()): c = get_cyclic(n, graph, mask) for u,v in c: graph[u].remove(v) if not do_dfs_bool(n,graph,mask.copy()): return 'YES' graph[u].append(v) return ""NO"" return ""YES"" def get_cyclic(n, graph, mask): c,v = do_dfs(n,graph,mask) path = [] i = 0 begin = False if c: for u in c.keys(): if c[u] == v: begin = True path.append((c[u],u)) elif begin: path.append((c[u],u)) tmp = list(c.keys()) if len(tmp): path.append((tmp[-1],v)) return path def do_dfs_bool(n, graph, mask): colors = [0]*(n+5) for u in graph.keys(): if not u in mask.keys(): if dfs_bool(u,graph,mask,colors): return True return False def dfs_bool(u, graph, mask,colors): colors[u] = 1 mask[u] = True for v in graph[u]: if colors[v] == 1: return True if colors[v] == 0: if dfs_bool(v,graph,mask,colors): return True colors[u] = 2 return False def do_dfs(n, graph, mask): colors = [0]*(n+5) c = {} for u in graph.keys(): if not u in mask.keys(): c = {} p, v = dfs(u,graph,mask,c,colors) if p and v: return (p,v) def dfs(u, graph, mask, c, colors): colors[u] = 1 for v in graph[u]: if colors[v] == 1: return (c, v) if colors[v] == 0: c[v] = u p,w = dfs(v,graph,mask,c,colors) if w: return (p,w) colors[u] = 2 if len(c) > 0: if u in c.keys(): del c[u] return (c, None) def test(n, m, edges): graph = {} mask = {} for u,v in edges: if u not in graph.keys(): graph[u] = [] graph[u].append(v) if v not in graph.keys(): graph[v] = [] return my_solve(n, m, graph, mask) if __name__ == '__main__': n,m = [int(x) for x in input().split()] edges = [] for i in range(0,m): u,v = [int(x) for x in input().split()] edges.append((u,v)) print(test(n, m, edges))",quadratic,"['dfs and similar', 'graphs']",1669
"import sys input = sys.stdin.readline def get_input(): n, m = [int(x) for x in input().split(' ')] digraph = [[] for _ in range(n + 1)] for _ in range(m): c1, c2 = [int(x) for x in input().split(' ')] digraph[c1].append(c2) return digraph def dfs(graph, u=-1, v=-1): n = len(graph) pi = [None] * n color = ['white'] * n for node in range(1, n): if color[node] == 'white': cicle = dfs_visit(graph, node, color, pi, u, v) if cicle is not None: return cicle return None def dfs_visit(graph, root, color, pi, u, v): stack = [root] while stack: current_node = stack[-1] if color[current_node] != 'white': stack.pop() color[current_node] = 'black' continue color[current_node] = 'grey' for adj in graph[current_node]: if (current_node, adj) == (u, v): continue if color[adj] == 'white': pi[adj] = current_node stack.append(adj) elif color[adj] == 'grey': cicle = [adj] while current_node != adj: cicle.append(current_node) current_node = pi[current_node] cicle.append(adj) return cicle return None if __name__ == ""__main__"": digraph = get_input() cicle = dfs(digraph) if cicle is None: print(""YES"") else: cicle.reverse() for i in range(len(cicle) - 1): c = dfs(digraph, cicle[i], cicle[i + 1]) if c is None: print(""YES"") break else: print(""NO"")",quadratic,"['dfs and similar', 'graphs']",1238
"def detect_cycle(n,edges): visited = [False]*n stack = [] color = [0]*n for v in range(n): if not visited[v]: if dfs_visit(v,edges,visited,stack,color): return stack return None def dfs_visit(v,edges,visited,stack,color): visited[v] = True stack.append(v) color[v] = 1 for u in edges[v]: if not visited[u]: if dfs_visit(u,edges,visited,stack,color): return True elif color[u] == 1: stack.append(u) return True color[v] = 2 stack.pop(stack.index(v)) return False if __name__ == '__main__': n,m = map(int,input().split()) edges = [[] for i in range(n)] for _ in range(m): u,v = map(int,input().split()) edges[u - 1].append(v - 1) inCycle = detect_cycle(n,edges) if inCycle: possible = False index = inCycle.index(inCycle[-1]) inCycle = inCycle[index:] for v in range(len(inCycle) - 1): edges[inCycle[v]].remove(inCycle[v + 1]) if detect_cycle(n,edges) is None: possible = True break else: edges[inCycle[v]].append(inCycle[v + 1]) else: possible = True print('YES' if possible else 'NO')",quadratic,"['dfs and similar', 'graphs']",984
"from collections import deque, defaultdict, Counter from itertools import product, groupby, permutations, combinations from math import gcd, floor, inf, log2, sqrt, log10 from bisect import bisect_right, bisect_left from statistics import mode from string import ascii_uppercase cases = int(input()) matrix1 = [] for _ in range(cases): matrix1.append(list(input())) matrix2 = [] for _ in range(cases): matrix2.append(list(input())) def transpose(matrix): return [list(x) for x in zip(*matrix)] def reverse_row(matrix): return matrix[::-1] def reverse_column(matrix): return [x[::-1] for x in matrix] def rotate_90(matrix): return reverse_row(transpose(matrix)) def rotate_180(matrix): return reverse_row(reverse_column(matrix)) def rotate_270(matrix): return reverse_column(transpose(matrix)) if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \ or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2): print(""Yes"") exit() matrix2 = reverse_row(matrix2) if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \ or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2): print(""Yes"") exit() matrix2 = reverse_column(matrix2) if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \ or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2): print(""Yes"") exit() matrix2 = transpose(matrix2) if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \ or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2): print(""Yes"") exit() else: print(""No"")",quadratic,['implementation'],1780
"import os, sys from io import BytesIO, IOBase from copy import deepcopy def main(): n = rint() a1, a2 = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)) for i in range(4): if a2.mat in [a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]: exit(print('Yes')) print('No') class Matrix: def __init__(self, r, c, mat=None, id=None): self.r, self.c = r, c if mat != None: self.mat = deepcopy(mat) else: self.mat = [[0 for i in range(c)] for j in range(r)] if id != None: for i in range(r): self.mat[i][i] = 1 def __add__(self, other): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j] return mat0 def __mul__(self, other): mat0 = Matrix(self.r, other.c) for i in range(self.r): for j in range(other.c): for k in range(self.c): mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j] return mat0 def dot_mul(self, other): res = 0 for i in range(self.r): for j in range(self.c): res += self.mat[i][j] * other.mat[j][i] return res def trace(self): res = 0 for i in range(self.r): res += self.mat[i][i] return res def rotate(self): mat0 = Matrix(self.c, self.r) for i in range(self.r): for j in range(self.c): mat0.mat[j][self.r - (i + 1)] = self.mat[i][j] self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r return self.mat def flipv(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[i][self.c - (j + 1)] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat def fliph(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[self.r - (i + 1)][j] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat def mat_pow(self, mat, p, mod=None): sq = Matrix(mat.r, mat.r, id=1) while p: if p & 1: p -= 1 sq = sq * mat p //= 2 mat = mat * mat return sq.mat class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode",quadratic,['implementation'],1999
"import os, sys from io import BytesIO, IOBase from copy import deepcopy def main(): n = rint() a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), [] for i in range(4): ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]) print(['No', 'Yes'][a2.mat in ans]) class Matrix: def __init__(self, r, c, mat=None, id=None): self.r, self.c = r, c if mat != None: self.mat = deepcopy(mat) else: self.mat = [[0 for i in range(c)] for j in range(r)] if id != None: for i in range(r): self.mat[i][i] = 1 def __add__(self, other): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j] return mat0 def __mul__(self, other): mat0 = Matrix(self.r, other.c) for i in range(self.r): for j in range(other.c): for k in range(self.c): mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j] return mat0 def dot_mul(self, other): res = 0 for i in range(self.r): for j in range(self.c): res += self.mat[i][j] * other.mat[j][i] return res def trace(self): res = 0 for i in range(self.r): res += self.mat[i][i] return res def rotate(self): mat0 = Matrix(self.c, self.r) for i in range(self.r): for j in range(self.c): mat0.mat[j][self.r - (i + 1)] = self.mat[i][j] self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r return self.mat def flipv(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[i][self.c - (j + 1)] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat def fliph(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[self.r - (i + 1)][j] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat def mat_pow(self, mat, p, mod=None): sq = Matrix(mat.r, mat.r, id=1) while p: if p & 1: p -= 1 sq = sq * mat p //= 2 mat = mat * mat return sq.mat class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not i",quadratic,['implementation'],2000
"import os, sys from io import BytesIO, IOBase from copy import deepcopy def main(): n = rint() a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), [] for i in range(4): ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]) print(['No', 'Yes'][a2.mat in ans]) class Matrix: def __init__(self, r, c, mat=None, id=None): self.r, self.c = r, c if mat != None: self.mat = deepcopy(mat) else: self.mat = [[0 for i in range(c)] for j in range(r)] def __add__(self, other): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j] return mat0 def __mul__(self, other): mat0 = Matrix(self.r, other.c) for i in range(self.r): for j in range(other.c): for k in range(self.c): mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j] return mat0 def dot_mul(self, other): res = 0 for i in range(self.r): for j in range(self.c): res += self.mat[i][j] * other.mat[j][i] return res def trace(self): res = 0 for i in range(self.r): res += self.mat[i][i] return res def rotate(self): mat0 = Matrix(self.c, self.r) for i in range(self.r): for j in range(self.c): mat0.mat[j][self.r - (i + 1)] = self.mat[i][j] self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r return self.mat def flipv(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[i][self.c - (j + 1)] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat def fliph(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[self.r - (i + 1)][j] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat def mat_pow(self, mat, p, mod=None): sq = Matrix(mat.r, mat.r, id=1) while p: if p & 1: p -= 1 sq = sq * mat p //= 2 mat = mat * mat return sq.mat class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.wr",quadratic,['implementation'],2000
"import os, sys from io import BytesIO, IOBase from copy import deepcopy def main(): n = rint() a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), [] for i in range(4): ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]) print(['No', 'Yes'][a2.mat in ans]) class Matrix: def __init__(self, r, c, mat=None, id=None): self.r, self.c = r, c if mat != None: self.mat = deepcopy(mat) else: self.mat = [[0 for i in range(c)] for j in range(r)] def rotate(self): mat0 = Matrix(self.c, self.r) for i in range(self.r): for j in range(self.c): mat0.mat[j][self.r - (i + 1)] = self.mat[i][j] self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r return self.mat def flipv(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[i][self.c - (j + 1)] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat def fliph(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[self.r - (i + 1)][j] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self,",quadratic,['implementation'],2000
"import os, sys from io import BytesIO, IOBase from copy import deepcopy def main(): n = rint() a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), [] for i in range(4): ans.extend([a1.rotate(), a1.fliph()]) a1.fliph() print(['No', 'Yes'][a2.mat in ans]) class Matrix: def __init__(self, r, c, mat=None, id=None): self.r, self.c = r, c if mat != None: self.mat = deepcopy(mat) else: self.mat = [[0 for i in range(c)] for j in range(r)] def rotate(self): mat0 = Matrix(self.c, self.r) for i in range(self.r): for j in range(self.c): mat0.mat[j][self.r - (i + 1)] = self.mat[i][j] self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r return self.mat def flipv(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[i][self.c - (j + 1)] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat def fliph(self): mat0 = Matrix(self.r, self.c) for i in range(self.r): for j in range(self.c): mat0.mat[self.r - (i + 1)][j] = self.mat[i][j] self.mat = deepcopy(mat0.mat) return self.mat class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = Fas",quadratic,['implementation'],2000
"import copy def rotate90(n, f): return [[f[n - j - 1][i] for j in range(n)] for i in range(n)] def fliphor(n, f): return [[f[i][n - j - 1] for j in range(n)] for i in range(n)] def flipver(n, f): return [[f[n - i - 1][j] for j in range(n)] for i in range(n)] def eq(n, f, g): for i in range(n): for j in range(n): if f[i][j] != g[i][j]: return False return True n = int(input()) f = [list(input()) for i in range(n)] g = [list(input()) for i in range(n)] for doflipv in range(2): for dofliph in range(2): for nrot in range(4): h = copy.deepcopy(f) if dofliph == 1: h = fliphor(n, h) if doflipv == 1: h = flipver(n, h) for i in range(nrot): h = rotate90(n, h) if eq(n, h, g): print(""Yes"") exit(0) print(""No"")",quadratic,['implementation'],707
"N = int(input()) m1 = [] m2 = [] ms = [] for n in range(N): m1.append(input()) for n in range(N): m2.append(input()) ms = [ m2, [x[::-1] for x in m2], [x for x in reversed(m2)], ] a = [] for m in ms: a.append(m) a.append([x[::-1] for x in reversed(m)]) a.append([''.join(m[j][i] for j in range(N - 1, -1, -1)) for i in range(N)]) a.append([''.join(m[j][i] for j in range(N)) for i in range(N - 1, -1, -1)]) ms = a print(['NO', 'YES'][m1 in ms])",quadratic,['implementation'],444
N = int(input()) s1 = [list(input()) for i in range(N)] s2 = [list(input()) for i in range(N)] def rotate(s): ret = [[None for i in range(N)] for j in range(N)] for i in range(N): for j in range(N): ret[i][j] = s[j][N-1-i] return ret def v_mirror(s): return list(reversed(s)) def h_mirror(s): return [list(reversed(row)) for row in s] def solve(): global s1 for i in range(4): if s1 == s2: return True if v_mirror(s1) == s2: return True if h_mirror(s1) == s2: return True if v_mirror(h_mirror(s1)) == s2: return True s1 = rotate(s1) return False print('Yes' if solve() else 'No'),quadratic,['implementation'],579
"n=int(input()) ns=[] for i in range(n): s=input() ns.append(s) ns2=[] for i in range(n): s=input() ns2.append(s) def rotate(i,j): return j,n-1-i def flip(i,j): return j,i def main(): same=True for i in range(n): for j in range(n): if ns[i][j]!=ns2[i][j]: same=False break if same==False: break if same: return True same=True for i in range(n): for j in range(n): a, b = rotate(i, j) if ns[i][j] != ns2[a][b]: same = False break if same == False: break if same: return True same=True for i in range(n): for j in range(n): a, b = rotate(i, j) a, b = rotate(a, b) if ns[i][j] != ns2[a][b]: same = False break if same == False: break if same: return True same=True for i in range(n): for j in range(n): a, b = rotate(i, j) a, b = rotate(a, b) a, b = rotate(a, b) if ns[i][j] != ns2[a][b]: same = False break if same == False: break if same: return True same=True for i in range(n): for j in range(n): a,b=flip(i,j) if ns[a][b]!=ns2[i][j]: same=False break if same==False: break if same: return True same=True for i in range(n): for j in range(n): a, b = rotate(i, j) a, b = flip(a, b) if ns[i][j] != ns2[a][b]: same = False break if same == False: break if same: return True same=True for i in range(n): for j in range(n): a, b = rotate(i, j) a, b = rotate(a, b) a, b = flip(a, b) if ns[i][j] != ns2[a][b]: same = False break if same == False: break if same: return True same=True for i in range(n): for j in range(n): a, b = rotate(i, j) a, b = rotate(a, b) a, b = rotate(a, b) a, b = flip(a, b) if ns[i][j] != ns2[a][b]: same = False break if same == False: break if same: return True else: return False if main(): print('Yes') else: print('No')",quadratic,['implementation'],1643
"def solve(board): n=len(board) ans=0 for i in range(n): for j in range(n): if board[i][j] is 'X': ans+=2**(i*n+j) return ans def reverse_array(arr): for i in range(len(arr)): arr[i].reverse() def rotate(matrix, degree): if degree == 0: return matrix elif degree > 0: return rotate(zip(*matrix[::-1]), degree-90) else: return rotate(zip(*matrix)[::-1], degree+90) def make_list(board): board=list(board) arr=[] for i in range(len(list(board))): arr.append(list(board[i])) return arr def add_rotations(board,st): for i in range(4): st.add(solve(board)) reverse_array(board) st.add(solve(board)) reverse_array(board) board=make_list(rotate(board, 90)) n=int(input()) arr1=[] arr2=[] for _ in range(n): arr1.append(list(input().strip())) for _ in range(n): arr2.append(list(input().strip())) s=set() s.add(solve(arr1)) add_rotations(arr1,s) l1=len(s) s.add(solve(arr2)) add_rotations(arr2,s) l2=len(s) if l1==l2: print(""Yes"") else: print(""No"")",quadratic,['implementation'],939
"N = int(input()) first = [] second = [] for i in range(N): first.append([s for s in input()]) for i in range(N): second.append([s for s in input()]) def rotate_90(matrix): return list(zip(*matrix[::-1])) def flip(matrix): return matrix[::-1] def compare_matrices(first, second): for i in range(N): for j in range(N): if first[i][j] != second[i][j]: return False return True def wrap(first, second): if compare_matrices(first, second) == True: return 'Yes' hold_first = first[::] for _ in range(3): first = rotate_90(first) if compare_matrices(first, second) == True: return 'Yes' first = hold_first first = flip(first) if compare_matrices(first, second) == True: return 'Yes' for _ in range(3): first = rotate_90(first) if compare_matrices(first, second) == True: return 'Yes' return 'No' print(wrap(first, second))",quadratic,['implementation'],815
"from itertools import chain, combinations, permutations def powerset(iterable): xs = list(iterable) return chain.from_iterable(combinations(xs,n) for n in range(len(xs)+1)) n = int(input()) cl1 = [] cl2 = [] for i in range(n): s = input() a = [] for j in range(n): a.append(s[j]) cl1.append(a) for i in range(n): s = input() a = [] for j in range(n): a.append(s[j]) cl2.append(a) def copy(m): res = [] for i in range(n): a = [] for j in range(n): a.append(m[i][j]) res.append(a) return res def pow(m): res = [] for i in range(n): a = [] for j in range(n): a.append(m[n-1-j][i]) res.append(a) return res def vert(m): res = [] for i in range(n): res.append(m[i][::-1]) return res def gor(m): res = [] for i in range(n): a = [] for j in range(n): a.append(m[i][n-1-j]) res.append(a) return res comblist = [[1], []] cm = [pow, pow, pow, vert, gor] cm = list(powerset(cm)) res = False if cl1 == cl2: res = True else: for x in cm: for y in permutations(x): t = copy(cl1) for z in y: t = z(t) if t==cl2: res = True if res: print('Yes') else: print('No')",quadratic,['implementation'],1046
"def flipH(A,N): B=[[0 for i in range(N)] for j in range(N)] for i in range(N): for j in range(N): B[i][j]=A[i][N-j-1] return B def flipV(A,N): B=[[0 for i in range(N)] for j in range(N)] for i in range(N): for j in range(N): B[i][j]=A[N-i-1][j] return B def rotate90(A): ans = zip(*A[::-1]) ans=list(map(list,ans)) return ans def check(A,B,N): for i in range(N): for j in range(N): if A[i][j]!=B[i][j]: return False return True N=int(input()) A=[] X=[] for i in range(N): A.append(list(input())) for i in range(N): X.append(list(input())) B=flipH(A,N) C=flipV(A,N) flag=False for i in range(4): if check(A,X,N) or check(B,X,N) or check(C,X,N): flag=True break else: A=rotate90(A) B=rotate90(B) C=rotate90(C) if flag: print(""Yes"") else: print(""No"")",quadratic,['implementation'],747
"import copy n = int(input()) flg=0 mat1 = [] mat2 = [] mats = [] for i in range(0, n): mat1.append(tuple(input().strip())) for i in range(0, n): mat2.append(tuple(input().strip())) mats.append(mat2) matu = copy.copy(mat2) matv = copy.copy(mat2) matv = list(zip(*matv)) mats.append(matv) mattem = copy.copy(matu) for i in range(0, 3): mattem = list(zip(*list(reversed(mattem)))) mats.append(mattem) mattem = copy.copy(matv) for i in range(0, 3): mattem = list(zip(*list(reversed(mattem)))) mats.append(mattem) flg = 0 for cmat in mats: flg2 = 1 for ri in range(0, n): if cmat[ri]!=mat1[ri]: flg2=0 break if flg2==1: flg=1 break if flg==1: print(""Yes"") else: print(""No"")",quadratic,['implementation'],668
def rotate(L): L1 = ['' for i in range(n)] for i in range(n): for j in range(n): L1[n - j - 1] += L[i][j] return L1 def flip_v(L): L1 = [] for i in range(n): L1.append(L[i][::-1]) return L1 def flip_h(L): L1 = [] for i in range(n): L1.append(L[n - i - 1]) return L1 n = int(input()) L = [] M = [] for i in range(n): L.append(input()) for i in range(n): M.append(input()) L1 = rotate(L) L2 = rotate(L1) L3 = rotate(L2) L4 = flip_v(L) L5 = flip_h(L) L6 = rotate(L4) L7 = rotate(L6) L8 = rotate(L7) L9 = rotate(L5) L10 = rotate(L9) L11 = rotate(L10) if L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M: print('Yes') else: print('No'),quadratic,['implementation'],711
"def check(x, y): return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y]) n = int(input()) a = [list(input()) for i in range(n)] b = [list(input()) for i in range(n)] for i in range(4): for j in range(2): if check(a, b): print('Yes') exit(0) b = b[::-1] for j in range(2): if check(a, b): print('Yes') exit(0) b = [s[::-1] for s in b] c = [['' for t in range(n)] for u in range(n)] for t in range(n): for u in range(n): c[t][u] = b[u][n - t - 1] b = c[:] if check(a, b): print('Yes') exit(0) print('No')",quadratic,['implementation'],522
"def rotate(li): newli = [] for x in range (0,n): newli.append([]) newli[x] = li[x].copy() for x in range (0,n): for y in range (0,n): newli[x][y] = li[n-1-y][x] return newli def flipV(li): newli = [] for x in range (0,n): newli.append([]) newli[x] = li[x].copy() newli.reverse() return newli def flipH(li): newli = [] for x in range (0,n): newli.append([]) newli[x] = li[x].copy() for x in range (0,n): newli[x].reverse() return newli n = int(input()) li1, li2, li3, templi = [], [], [], [] for x in range (0,n): li1.append([]) li2.append([]) li3.append([]) templi.append([]) li1[x]=list(input()) for x in range (0,n): li2[x]=list(input()) if ( li1 ==li2 ): print('Yes') exit() templi = flipH(li2) if ( li1 ==templi ): print('Yes') exit() templi = flipV(li2) if ( li1 ==templi ): print('Yes') exit() templi = rotate(li2) if ( li1 ==templi ): print('Yes') exit() templi = rotate(templi) if ( li1 ==templi ): print('Yes') exit() templi = rotate(templi) if ( li1 ==templi ): print('Yes') exit() templi = flipH(li2) templi = rotate(templi) if ( li1 ==templi ): print('Yes') exit() templi = rotate(templi) if ( li1 ==templi ): print('Yes') exit() templi = rotate(templi) if ( li1 ==templi ): print('Yes') exit() print('No')",quadratic,['implementation'],1218
"def check(x, y): return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y]) n = int(input()) a = [list(input()) for i in range(n)] b = [list(input()) for i in range(n)] for i in range(4): for j in range(2): if check(a, b): print('Yes') exit(0) b = b[::-1] for j in range(2): if check(a, b): print('Yes') exit(0) b = [s[::-1] for s in b] c = [['' for t in range(n)] for u in range(n)] for t in range(n): for u in range(n): c[t][u] = b[u][n - t - 1] b = c[:] if check(a, b): print('Yes') exit(0) print('No')",quadratic,['implementation'],522
"N = int(input()) map_1 = [list(input()) for i in range(N)] map_2 = [list(input()) for i in range(N)] maps = list() maps.append([[map_2[i][j] for j in range(N)] for i in range(N)]) maps.append([[map_2[i][N - 1 - j] for j in range(N)] for i in range(N)]) maps.append([[map_2[N - 1 - i][j] for j in range(N)] for i in range(N)]) maps.append([[map_2[N - 1 - i][N - 1 - j] for j in range(N)] for i in range(N)]) maps.append([[map_2[j][i] for j in range(N)] for i in range(N)]) maps.append([[map_2[j][N - 1 - i] for j in range(N)] for i in range(N)]) maps.append([[map_2[N - 1 - j][i] for j in range(N)] for i in range(N)]) maps.append([[map_2[N - 1 - j][N - 1 - i] for j in range(N)] for i in range(N)]) print(('No', 'Yes')[any(map_1 == el for el in maps)])",quadratic,['implementation'],752
"def rotate_90(a): b=[] for x in range(len(a)): l=[] for y in range(len(a)-1,-1,-1): l.append(a[y][x]) b.append(l) return b def flip(a): b=[] for x in range(len(a)): l=[] for y in range(len(a)-1,-1,-1): l.append(a[x][y]) b.append(l) return b n=int(input()) l=[] for i in range(n): a=input() l2=[] for i2 in a: l2.append(i2) l.append(l2) l2=[] for i in range(n): a=input() l3=[] for i2 in a: l3.append(i2) l2.append(l3) d='no' for i in range(4): l = rotate_90(l) if l==l2: d='yes' l=flip(l) for i in range(4): l = rotate_90(l) if l==l2: d='yes' print(d)",quadratic,['implementation'],551
"def check(): f = True for i in range(n): for j in range(n): if map1[i][j] != map2[i][j]: f = False break if f: return True f = True for i in range(n): for j in range(n): if map1[i][j] != map2[n - 1 - i][j]: f = False break if f: return True f = True for i in range(n): for j in range(n): if map1[i][j] != map2[i][n - 1 - j]: f = False break if f: return True def rotate(): wk1=[] for i in range(n): wk1.append([]) for j in range(n): wk1[i].append(map1[i][j]) for i in range(n): for j in range(n): map1[i][j] = wk1[j][n - 1 - i] n = int(input()) map1 = [] for i in range(n): st = input() map1.append([]) for j in st: map1[i].append(j) map2 = [] for i in range(n): st = input() map2.append([]) for j in st: map2[i].append(j) f = False for k in range(4): if check(): f = True break rotate() if f: print(""Yes"") else: print(""No"")",quadratic,['implementation'],824
n = int(input()) map1 = [list(input()) for i in range(n)] map2 = [list(input()) for i in range(n)] def vFlip (m): return([list(reversed(i)) for i in m]) def hFlip(m): return(list(reversed(m))) def rotate(m): return(list(zip(*reversed(m)))) def check(): global map1 for i in range(4): if map1 == map2: return(True) if vFlip(map1)==map2: return(True) if hFlip(map1)==map2: return(True) if vFlip(hFlip(map1))==map2: return(True) map1 = rotate(map1) return(False) print('YES' if check() else 'NO'),quadratic,['implementation'],493
"import copy lista=[] listb=[] temp=[] a=int(input()) flag=0 mark=0 for i in range(0,a): str=input() for j in range(0,a): temp.append(str[j]) lista.append(temp) temp=[] for i in range(0,a): str=input() for j in range(0,a): temp.append(str[j]) listb.append(temp) temp=[] listacpy =copy.deepcopy(lista) for i in range(0,a): for j in range(0,a): if(listacpy[i][j]!=listb[i][j]): mark=1 break if(mark==1): break if(mark==0): flag=1 mark=0 for i in range(0,a): for j in range(0,a): listacpy[a-1-j][i]=lista[i][j] for i in range(0,a): for j in range(0,a): if(listacpy[i][j]!=listb[i][j]): mark=1 break if(mark==1): break if(mark==0): flag=1 mark = 0 for i in range(0,a): for j in range(0,a): listacpy[a-1-i][a-1-j]=lista[i][j] for i in range(0,a): for j in range(0,a): if(listacpy[i][j]!=listb[i][j]): mark=1 break if(mark==1): break if(mark==0): flag=1 mark = 0 for i in range(0,a): for j in range(0,a): listacpy[j][a-1-i]=lista[i][j] for i in range(0,a): for j in range(0,a): if(listacpy[i][j]!=listb[i][j]): mark=1 break if(mark==1): break if(mark==0): flag=1 mark = 0 listtemp=copy.deepcopy(lista) for i in range(0,a): for j in range(0,a): lista[i][j]=listtemp[i][a-1-j] listacpy =copy.deepcopy(lista) for i in range(0,a): for j in range(0,a): if(listacpy[i][j]!=listb[i][j]): mark=1 break if(mark==1): break if(mark==0): flag=1 mark = 0 for i in range(0,a): for j in range(0,a): listacpy[a-1-j][i]=lista[i][j] for i in range(0,a): for j in range(0,a): if(listacpy[i][j]!=listb[i][j]): mark=1 break if(mark==1): break if(mark==0): flag=1 mark = 0 for i in range(0,a): for j in range(0,a): listacpy[a-1-i][a-1-j]=lista[i][j] for i in range(0,a): for j in range(0,a): if(listacpy[i][j]!=listb[i][j]): mark=1 break if(mark==1): break if(mark==0): flag=1 mark = 0 for i in range(0,a): for j in range(0,a): listacpy[j][a-1-i]=lista[i][j] for i in range(0,a): for j in range(0,a): if(listacpy[i][j]!=listb[i][j]): mark=1 break if(mark==1): break if(mark==0): flag=1 if(flag==1): print(""yes"") else: print(""no"")",quadratic,['implementation'],2000
"n=int(input()) a=[] b=[] for i in range(n): a.append(input()) for i in range(n): b.append(input()) def h(d): c=[] for i in range(n): c.append(d[n-i-1]) return c def r(d): c=[] for i in range(n): temp="""" for j in range(n): temp+=d[j][n-i-1] c.append(temp) return c yes=0 for i in range(4): if a==b: print('YES') yes=1 break a=r(a) if yes==0: a=h(a) for i in range(4): if a==b: print('YES') yes=1 break a=r(a) if yes==0: print('NO')",quadratic,['implementation'],430
"def check(x, y): return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y]) re = int(input()) a = [list(input()) for i in range(re)] b = [list(input()) for i in range(re)] for i in range(4): for j in range(2): if check(a, b): print('Yes') exit(0) b = b[::-1] for j in range(2): if check(a, b): print('Yes') exit(0) b = [s[::-1] for s in b] c = [['' for t in range(re)] for u in range(re)] for t in range(re): for u in range(re): c[t][u] = b[u][re - t - 1] b = c[:] if check(a, b): print('Yes') exit(0) print('No')",quadratic,['implementation'],530
"def ints(): return map(int,input().split()) n,m=ints() c=ints() aa=[0]*(n+1) for cc in c: aa[cc]+=1 print(min(aa[1:]))",quadratic,['implementation'],118
"n,m = map(int, input().split()) tL0 = list(map(int, input().split())) tL = [0] * n score = 0 for i in range(m): tL[tL0[i] - 1] += 1 if(0 not in tL): score += 1 for i in range(n): tL[i] = tL[i] - 1 print(score)",quadratic,['implementation'],209
"n,m=map(int,input().split()) c=input().split() col=[0]*n for i in range(len(c)): col[int(c[i])-1]+=1 print(min(col))",quadratic,['implementation'],116
"n, m = map(int, input().split()) a = [int(i) for i in input().split()] b = [0] * n for i in a: b[i - 1] += 1 b.sort() print(b[0])",quadratic,['implementation'],129
"from collections import deque as de import math from collections import Counter as cnt from functools import reduce from typing import MutableMapping def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def decimalToBinary(n): return bin(n).replace(""0b"", """") def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def isPowerOfTwo(n): return (math.ceil(Log2(n)) == math.floor(Log2(n))); n,m=map(int,input().split()) c=list(map(int,input().split())) kk=get_frequency(c) if len(set(c))==n: print(min(kk.values())) else: print(0)",quadratic,['implementation'],1564
"import collections, bisect n, m = map(int, input().split()) arr = list(map(int, input().split())) cs = collections.Counter(arr) print(min(cs[x] for x in range(1, n + 1)))",quadratic,['implementation'],170
"n,useless=list(map(int,input().split())) arr=list(map(int,input().split())) for x in range(1,n+1): if x not in arr: print(0) break else: print(arr.count(min(arr,key=lambda x:arr.count(x))))",quadratic,['implementation'],189
"n, m = list(map(int, input().split())) square = [0] * n l = list(map(int, input().split())) for x in l: square[x-1] += 1 print(min(square))",quadratic,['implementation'],139
"def divisors(M): d=[] i=1 while M>=i**2: if M%i==0: d.append(i) if i**2!=M: d.append(M//i) i=i+1 return d def popcount(x): x = x - ((x >> 1) & 0x55555555) x = (x & 0x33333333) + ((x >> 2) & 0x33333333) x = (x + (x >> 4)) & 0x0f0f0f0f x = x + (x >> 8) x = x + (x >> 16) return x & 0x0000007f def eratosthenes(n): res=[0 for i in range(n+1)] prime=set([]) for i in range(2,n+1): if not res[i]: prime.add(i) for j in range(1,n//i+1): res[i*j]=1 return prime def factorization(n): res=[] for p in prime: if n%p==0: while n%p==0: n//=p res.append(p) if n!=1: res.append(n) return res def euler_phi(n): res = n for x in range(2,n+1): if x ** 2 > n: break if n%x==0: res = res//x * (x-1) while n%x==0: n //= x if n!=1: res = res//n * (n-1) return res def ind(b,n): res=0 while n%b==0: res+=1 n//=b return res def isPrimeMR(n): d = n - 1 d = d // (d & -d) L = [2, 3, 5, 7, 11, 13, 17] for a in L: t = d y = pow(a, t, n) if y == 1: continue while y != n - 1: y = (y * y) % n if y == 1 or t == n - 1: return 0 t <<= 1 return 1 def findFactorRho(n): from math import gcd m = 1 << n.bit_length() // 8 for c in range(1, 99): f = lambda x: (x * x + c) % n y, r, q, g = 2, 1, 1, 1 while g == 1: x = y for i in range(r): y = f(y) k = 0 while k < r and g == 1: ys = y for i in range(min(m, r - k)): y = f(y) q = q * abs(x - y) % n g = gcd(q, n) k += m r <<= 1 if g == n: g = 1 while g == 1: ys = f(ys) g = gcd(abs(x - ys), n) if g < n: if isPrimeMR(g): return g elif isPrimeMR(n // g): return n // g return findFactorRho(g) def primeFactor(n): i = 2 ret = {} rhoFlg = 0 while i*i <= n: k = 0 while n % i == 0: n //= i k += 1 if k: ret[i] = k i += 1 + i % 2 if i == 101 and n >= 2 ** 20: while n > 1: if isPrimeMR(n): ret[n], n = 1, 1 else: rhoFlg = 1 j = findFactorRho(n) k = 0 while n % j == 0: n //= j k += 1 ret[j] = k if n > 1: ret[n] = 1 if rhoFlg: ret = {x: ret[x] for x in sorted(ret)} return ret def divisors(n): res = [1] prime = primeFactor(n) for p in prime: newres = [] for d in res: for j in range(prime[",quadratic,['implementation'],2000
"import sys,math,itertools from collections import Counter,deque,defaultdict from bisect import bisect_left,bisect_right from heapq import heappop,heappush,heapify, nlargest from copy import deepcopy mod = 10**9+7 INF = float('inf') def inp(): return int(sys.stdin.readline()) def inpl(): return list(map(int, sys.stdin.readline().split())) def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split())) def inps(): return sys.stdin.readline() def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x]) def err(x): print(x); exit() n,m = inpl() cnt = [0]*n c = inpl_1() for x in c: cnt[x] += 1 print(min(cnt))",quadratic,['implementation'],629
"n,m=map(int,input().split()) count=[0]*n a=list(map(int,input().split())) for i in range(m): count[a[i]-1]+=1 print(min(count))",quadratic,['implementation'],127
"n, m = map(int, input().split()) A = list(map(int, input().split())) L = [0]*n for i in range(m): L[A[i]-1] += 1 print(min(L))",quadratic,['implementation'],126
"if __name__==""__main__"": dic={} n,m=map(int,input().split()) li=list(map(int,input().split())) c=0 for i in range(n): dic.setdefault(i+1,0) for i in li: if 0 not in dic.values(): c=c+1 for j in range(1,n+1): dic[j]=dic[j]-1 dic[i]=dic[i]+1 if 0 not in dic.values(): c=c+1 print(c)",quadratic,['implementation'],280
"if __name__ == '__main__': n,m = map(int, input().split()) l = list(map(int, input().split())) d = dict() if len(set(l)) < n: print(0) else: for i in range (m): d.setdefault(l[i],0) d[l[i]]+=1 min1 = 999999999 for i in d.values(): if i < min1 : min1 = i print(min1)",quadratic,['implementation'],265
"import sys input=sys.stdin.readline from collections import defaultdict as dc from collections import Counter from bisect import bisect_right, bisect_left import math from operator import itemgetter from heapq import heapify, heappop, heappush from queue import PriorityQueue as pq n,m=map(int,input().split()) l=list(map(int,input().split())) x=dc(int) c=0 p=0 for i in l: x[i]+=1 f=1 for i in range(1,n+1): if x[i]==0: f=0 break if f: p+=1 for i in range(1,n+1): x[i]-=1 print(p)",quadratic,['implementation'],481
"a, b = map(int, input().split()) arr = list(map(int, input().split())) mn = float(""inf"") for i in range(1, a+1): mn = min(mn, arr.count(i)) print(mn)",quadratic,['implementation'],149
"n, m = map(int, input().split()) daf1 = list(map(int, input().split())) daf2 = dict() for i in range(n): daf2[i+1] = 0 for i in daf1: if i in daf2.keys(): daf2[i] += 1 print(min(daf2.values()))",quadratic,['implementation'],193
"I=lambda:map(int,input().split()) n,m=I() q={} for i in range(1,n+1):q[i]=0 for i in I():q[i]+=1 print(min(q.values()))",quadratic,['implementation'],119
"import itertools n = int(input()) a = [] for i in range(4): a.append([input() for _ in range(n)]) if i < 3: assert input() == '' best = 4*n*n for p in itertools.permutations(a): for s in range(2): count = 0 for i in range(4): for r in range(n): for c in range(n): if p[i][r][c] != str((s + (i//2 + r) + (i % 2 + c)) % 2): count += 1 best = min(best, count) print(best)",quadratic,"['bitmasks', 'brute force', 'implementation']",368
"a=int(input()) l=[] total=0 for i in range(4): line='' for x in [0]*a: line+=input() l.append(line) input() if i!=3 else 0 l=sorted(l,key=lambda i: i[0::2].count('1')+i[1::2].count('0'))[::-1] for z,v in enumerate(l): if z<2: for i in range(a**2): total += v[i]!='0' if i%2 else v[i]!='1' else: for i in range(a**2): total += v[i]!='1' if i%2 else v[i]!='0' print(total)",quadratic,"['bitmasks', 'brute force', 'implementation']",370
"import bisect import math import itertools import sys alpha = 'abcdefghijklmnopqrstuvwxyz' inf = 1e17 def calc1(grid): l = len(grid) cnt = 0 for i in range(l): for j in range(l): if (i+j) % 2 and grid[i][j]: cnt += 1 if (i+j) % 2 == 0 and grid[i][j] == 0: cnt += 1 return cnt def calc2(grid): l = len(grid) cnt = 0 for i in range(l): for j in range(l): if (i+j) % 2 and grid[i][j] == 0: cnt += 1 if (i+j) % 2 == 0 and grid[i][j]: cnt += 1 return cnt def solve(n,grids): one = [] zero = [] for grid in grids: one.append(calc1(grid)) zero.append(calc2(grid)) take = [3,5,6,9,10,12] answer = inf for mask in range(16): cnt = 0 if mask not in take: continue if mask in take: if mask & 1: cnt += one[3] pass else: cnt += zero[3] pass if mask & 2: cnt += one[2] pass else: cnt += zero[2] pass if mask & 4: cnt += one[1] pass else: cnt += zero[1] pass if mask & 8: cnt += one[0] pass else: cnt += zero[0] pass answer = min(answer,cnt) return answer t = 1 ans = [] for _ in range(t): n = int(input()) grids = [] for i in range(4): grid = [] for j in range(n): arr = list(map(int,list(input()))) grid.append(arr) if i != 3: s = input() grids.append(grid) ans.append(solve(n,grids)) for test in ans: print(test)",quadratic,"['bitmasks', 'brute force', 'implementation']",1201
"import sys try: def check(n): count1=0 s="""" while(n!=0): if n%2: count1+=1 s=""1""+s else: s=""0""+s n//=2 return s def solve(flag,n,l): temp_ans=0 for i in range(n): y=(z[flag]^int(l[i],2) ) b=bin(y) temp_ans+=b.count(""1"") flag=not(flag) return temp_ans n=int(input()) l1 = [input() for y in range(n)] temp=input() l2 = [input() for y in range(n)] temp=input() l3 = [input() for y in range(n)] temp=input() l4 = [input() for y in range(n)] z=[] s=0 for i in range(n): if i%2==1: s+=(2**i) z.append(s) z.append( z[0] ^ (2**n-1) ) ans=m=sys.maxsize for i in range(2,17): s=check(i) if s.count(""1"")==2: s=(4-len(s))*""0""+s res=sys.maxsize for i in range(4): if i==0: x=l1 elif i==1: x=l2 elif i==2: x=l3 else: x=l4 if s[i]==""1"": res+=min(res,solve(1,n,x)) else: res+=min(res,solve(0,n,x)) ans=min(ans,res-m) print(ans) except EOFError: pass",quadratic,"['bitmasks', 'brute force', 'implementation']",833
"def divisors(M): d=[] i=1 while M>=i**2: if M%i==0: d.append(i) if i**2!=M: d.append(M//i) i=i+1 return d def popcount(x): x = x - ((x >> 1) & 0x55555555) x = (x & 0x33333333) + ((x >> 2) & 0x33333333) x = (x + (x >> 4)) & 0x0f0f0f0f x = x + (x >> 8) x = x + (x >> 16) return x & 0x0000007f def eratosthenes(n): res=[0 for i in range(n+1)] prime=set([]) for i in range(2,n+1): if not res[i]: prime.add(i) for j in range(1,n//i+1): res[i*j]=1 return prime def factorization(n): res=[] for p in prime: if n%p==0: while n%p==0: n//=p res.append(p) if n!=1: res.append(n) return res def euler_phi(n): res = n for x in range(2,n+1): if x ** 2 > n: break if n%x==0: res = res//x * (x-1) while n%x==0: n //= x if n!=1: res = res//n * (n-1) return res def ind(b,n): res=0 while n%b==0: res+=1 n//=b return res def isPrimeMR(n): d = n - 1 d = d // (d & -d) L = [2, 3, 5, 7, 11, 13, 17] for a in L: t = d y = pow(a, t, n) if y == 1: continue while y != n - 1: y = (y * y) % n if y == 1 or t == n - 1: return 0 t <<= 1 return 1 def findFactorRho(n): from math import gcd m = 1 << n.bit_length() // 8 for c in range(1, 99): f = lambda x: (x * x + c) % n y, r, q, g = 2, 1, 1, 1 while g == 1: x = y for i in range(r): y = f(y) k = 0 while k < r and g == 1: ys = y for i in range(min(m, r - k)): y = f(y) q = q * abs(x - y) % n g = gcd(q, n) k += m r <<= 1 if g == n: g = 1 while g == 1: ys = f(ys) g = gcd(abs(x - ys), n) if g < n: if isPrimeMR(g): return g elif isPrimeMR(n // g): return n // g return findFactorRho(g) def primeFactor(n): i = 2 ret = {} rhoFlg = 0 while i*i <= n: k = 0 while n % i == 0: n //= i k += 1 if k: ret[i] = k i += 1 + i % 2 if i == 101 and n >= 2 ** 20: while n > 1: if isPrimeMR(n): ret[n], n = 1, 1 else: rhoFlg = 1 j = findFactorRho(n) k = 0 while n % j == 0: n //= j k += 1 ret[j] = k if n > 1: ret[n] = 1 if rhoFlg: ret = {x: ret[x] for x in sorted(ret)} return ret def divisors(n): res = [1] prime = primeFactor(n) for p in prime: newres = [] for d in res: for j in range(prime[",quadratic,"['bitmasks', 'brute force', 'implementation']",2000
"n=int(input()) pieces=[] blacks=[0]*4 whites=[0]*4 for i in range(4): grid=[] for j in range(n): grid.append(input()) if i<3: input() count=0 for j in range(n): for k in range(n): if (int(grid[j][k])+j+k)%2: count+=1 blacks[i]=count whites[i]=n*n-count ans=4*n*n for white1 in range(3): for white2 in range(white1+1,4): for black1 in range(4): if black1==white1 or black1==white2: continue for black2 in range(black1+1,4): if black2==white1 or black2==white2: continue ans=min(ans,whites[white1]+whites[white2]+blacks[black1]+blacks[black2]) print(ans)",quadratic,"['bitmasks', 'brute force', 'implementation']",552
"import sys,math,itertools from collections import Counter,deque,defaultdict from bisect import bisect_left,bisect_right from heapq import heappop,heappush,heapify, nlargest from copy import deepcopy mod = 10**9+7 INF = float('inf') def inp(): return int(sys.stdin.readline()) def inpl(): return list(map(int, sys.stdin.readline().split())) def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split())) def inps(): return sys.stdin.readline() def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x]) def err(x): print(x); exit() n = inp() s = [] for _ in range(4): tmp = [input() for i in range(n)] if _<3: input() s.append(tmp) res = INF for pt in itertools.combinations(range(4),2): cnt = 0 for k in range(4): f = 1 if k in pt else 0 for i in range(n): for j in range(n): if (i+j+f)%2 != int(s[k][i][j]): cnt += 1 res = min(res, cnt) print(res)",quadratic,"['bitmasks', 'brute force', 'implementation']",869
"n = int(input()) s = [["""" for _ in range(n)] for __ in range(4)] for i in range(3): for j in range(n): s[i][j] = input() input() for j in range(n): s[3][j] = input() res = int(1e13) for i in range(24): perm = [0, 1, 2, 3] L = [0]*4 tmp = i for j in range(4): L[j] = tmp % (4-j) tmp //= (4-j) LL = [0]*4 for j in range(4): LL[j] = perm[L[j]] for k in range(L[j], 3-j): perm[k] = perm[k+1] lu, ru, ld, rd = LL[0], LL[1], LL[2], LL[3] Map = [s[lu][_][:]+s[ru][_][:] for _ in range(n)] + [s[ld][_][:]+s[rd][_][:] for _ in range(n)] cnt0, cnt1 = 0, 0 for j in range(2*n): for k in range(2*n): if (j+k) % 2: if Map[j][k] == '0': cnt0 += 1 else: cnt1 += 1 else: if Map[j][k] == '1': cnt0 += 1 else: cnt1 += 1 res = min(res, cnt0, cnt1) print(res)",quadratic,"['bitmasks', 'brute force', 'implementation']",739
"from sys import stdin input = stdin.readline n = int(input()) a = [] for i in range(4): a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)]) if i < 3: input() b = [] for i in range(4): b.append([]) for j in range(2): c = 0 for y in range(n): for x in range(n): if j == 1: z = (x + y) % 2 else: z = 1 - (x + y) % 2 c += a[i][y][x] != z b[-1].append(c) ans = float(""inf"") for i in (3, 5, 6, 9, 10, 12): ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1]) print(ans)",quadratic,"['bitmasks', 'brute force', 'implementation']",514
"import os, sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import ceil mod = 10 ** 9 + 7 def get_original_pieces(x): common = (pow(x, 2) - 1) // 2 first_piece = ""10""*common + '1' second_piece = '0' + ""10""*common return [first_piece, second_piece] for _ in range(1): n = int(input()) pieces = ["""" for _ in range(4)] original_pieces = get_original_pieces(n) i = 0 for _ in range(3 + (n*4)): s = input() if s: pieces[i] += s else: i += 1 till = pow(n, 2) fp = [[0,i] for i in range(4)] sp = [[0,i] for i in range(4)] for i in range(4): fpc, spc = 0, 0 for j in range(till): if pieces[i][j] != original_pieces[0][j]: fpc += 1 if pieces[i][j] != original_pieces[",quadratic,"['bitmasks', 'brute force', 'implementation']",1999
"from itertools import permutations n = int(input()) a = [] for i in range(4): a.append([list(map(int, list(input()))) for j in range(n)]) if i < 3: input() ans = 10 ** 10 for i in permutations(a, 4): cnt = 0 total = 0 for j in i: if cnt < 2: cnt2 = 0 for p in j: for q in p: if q != cnt2 % 2: total += 1 cnt2 += 1 else: cnt2 = 1 for p in j: for q in p: if q != cnt2 % 2: total += 1 cnt2 += 1 cnt += 1 ans = min(ans, total) print(ans)",quadratic,"['bitmasks', 'brute force', 'implementation']",433
"import itertools n = int(input()) boards = [] for i in range(4): boards.append([]) for j in range(n): boards[-1].append(list(map(int, list(input())))) if i < 3: input() ans = n * n * 4 def check_board(corner, board): ans = 0 for i in range(n): for j in range(n): if board[i][j] != corner: ans += 1 corner = 1 - corner return ans def solve(corner, p): ans = check_board(corner, boards[p[0]]) ans += check_board(1- corner, boards[p[1]]) ans += check_board(1 - corner, boards[p[2]]) ans += check_board(corner, boards[p[3]]) return ans for p in itertools.permutations(range(4), 4): ans = min(ans, solve(1, p)) ans = min(ans, solve(0, p)) print(ans)",quadratic,"['bitmasks', 'brute force', 'implementation']",644
"def main(): pieces_Dimension = int(input()) piece1 = ''.join(input() for _ in range(pieces_Dimension)) input() piece2 = ''.join(input() for _ in range(pieces_Dimension)) input() piece3 = ''.join(input() for _ in range(pieces_Dimension)) input() piece4 = ''.join(input() for _ in range(pieces_Dimension)) brokenPieces = (piece1, piece2, piece3, piece4) nSquares = pieces_Dimension*pieces_Dimension squares = '01'*-(-nSquares//2) return nSquaresToRecolorIn(brokenPieces, nSquares, squares) def nSquaresToRecolorIn(brokenPieces, nSquares, squares): possible_nSquares = [(sum(1 for i in range(nSquares) if piece[i] != squares[:-1][i]), sum(1 for i in range(nSquares) if piece[i] != squares[1:][i])) for piece in brokenPieces] possible_nSquares.sort(key=lambda x: x[0]) return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1] if __name__ == '__main__': print(main())",quadratic,"['bitmasks', 'brute force', 'implementation']",914
"def main(): pieces_Dimension = int(input()) piece1 = ''.join(input() for _ in range(pieces_Dimension)) input() piece2 = ''.join(input() for _ in range(pieces_Dimension)) input() piece3 = ''.join(input() for _ in range(pieces_Dimension)) input() piece4 = ''.join(input() for _ in range(pieces_Dimension)) brokenPieces = (piece1, piece2, piece3, piece4) nSquares = pieces_Dimension*pieces_Dimension squares = '01'*-(-nSquares//2) return nSquaresToRecolorIn(brokenPieces, nSquares, squares) def nSquaresToRecolorIn(brokenPieces, nSquares, squares): possible_nSquares = [(sum(piece[i] != squares[:-1][i] for i in range(nSquares)), sum(piece[i] != squares[1:][i] for i in range(nSquares))) for piece in brokenPieces] possible_nSquares.sort(key=lambda x: x[0]) return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1] if __name__ == '__main__': print(main())",quadratic,"['bitmasks', 'brute force', 'implementation']",904
"def main(): pieces_Dimension = int(input()) piece1 = ''.join(input() for _ in range(pieces_Dimension)) input() piece2 = ''.join(input() for _ in range(pieces_Dimension)) input() piece3 = ''.join(input() for _ in range(pieces_Dimension)) input() piece4 = ''.join(input() for _ in range(pieces_Dimension)) brokenPieces = (piece1, piece2, piece3, piece4) nSquares = pieces_Dimension*pieces_Dimension squares = '01'*(nSquares//2) + '0' return nSquaresToRecolorIn(brokenPieces, nSquares, squares) def nSquaresToRecolorIn(brokenPieces, nSquares, squares): possible_nSquares = [sum(piece[i] != squares[i] for i in range(nSquares)) for piece in brokenPieces] possible_nSquares.sort() return 2*nSquares + possible_nSquares[0] + possible_nSquares[1] - possible_nSquares[2] - possible_nSquares[3] if __name__ == '__main__': print(main())",quadratic,"['bitmasks', 'brute force', 'implementation']",826
n=int(input()) c=[0]*4 for k in range(4): for i in range(n): s=input() for j in range(n): if(i+j)%2!=int(s[j]):c[k]+=1 if k<3:input() c.sort() print(c[0]+c[1]+2*n*n-c[2]-c[3]),quadratic,"['bitmasks', 'brute force', 'implementation']",175
"n = int(input()) parts = [] for i in range(4): part = [] for _i in range(n): part.append([int(x) for x in input()]) parts.append(part) if i < 3:input() processed_parts = [] for part in parts: dt1 = 0 exp = 1 for h in range(n): for w in range(n): if part[h][w] != exp: dt1 += 1 exp = (exp+1) % 2 dt2 = 0 for h in range(n): for w in range(n): if part[h][w] != exp: dt2 += 1 exp = (exp+1) % 2 processed_parts.append([dt1, dt2]) ans = n*n*4 for i in range(3): for j in range(i+1, 4): a = 0 for k, part in enumerate(processed_parts): if k == i or k == j: a += part[0] else: a += part[1] ans = min(ans, a) print(ans)",quadratic,"['bitmasks', 'brute force', 'implementation']",610
"import heapq def doxor(a, b): cnt = 0 for i in range(len(a)): for j in range(len(a[0])): cnt += a[i][j] ^ b[i][j] return cnt n = int(input()) a, b = [], [] for i in range(n): ai, bi = [], [] for j in range(n): if i % 2 == 0: ai.append(j % 2) bi.append((j % 2) ^ 1) else: ai.append((j % 2) ^ 1) bi.append(j % 2) a.append(ai) b.append(bi) board = [] board.append([list(map(int, list(input()))) for _ in range(n)]) input() board.append([list(map(int, list(input()))) for _ in range(n)]) input() board.append([list(map(int, list(input()))) for _ in range(n)]) input() board.append([list(map(int, list(input()))) for _ in range(n)]) a_cnts = [] b_cnts = [] for b0 in board: heapq.heappush(a_cnts, doxor(b0, a)) heapq.heappush(b_cnts, doxor(b0, b)) print(heapq.heappop(a_cnts) + heapq.heappop(a_cnts) + heapq.heappop(b_cnts) + heapq.heappop(b_cnts))",quadratic,"['bitmasks', 'brute force', 'implementation']",843
"n = int(input()) lst1 = [] for x in range(n): lst1.append(input().split()) s = input() lst2 = [] for x in range(n): lst2.append(input().split()) s = input() lst3 = [] for x in range(n): lst3.append(input().split()) s = input() lst4 = [] for x in range(n): lst4.append(input().split()) ans_b1 = 0 ans_w1 = 0 for x in range(n): for y in range(n): if (x + y) & 1 == 0: if lst1[x][0][y] == '0': ans_b1 += 1 else: ans_w1 += 1 else: if lst1[x][0][y] == '1': ans_b1 += 1 else: ans_w1 += 1 ans_b2 = 0 ans_w2 = 0 for x in range(n): for y in range(n): if (x + y) & 1 == 0: if lst2[x][0][y] == '0': ans_b2 += 1 else: ans_w2 += 1 else: if lst2[x][0][y] == '1': ans_b2 += 1 else: ans_w2 += 1 ans_b3 = 0 ans_w3 = 0 for x in range(n): for y in range(n): if (x + y) & 1 == 0: if lst3[x][0][y] == '0': ans_b3 += 1 else: ans_w3 += 1 else: if lst3[x][0][y] == '1': ans_b3 += 1 else: ans_w3 += 1 ans_b4 = 0 ans_w4 = 0 for x in range(n): for y in range(n): if (x + y) & 1 == 0: if lst4[x][0][y] == '0': ans_b4 += 1 else: ans_w4 += 1 else: if lst4[x][0][y] == '1': ans_b4 += 1 else: ans_w4 += 1 print((2 * n) ** 2 - max(ans_b1 + ans_b2 + ans_w3 + ans_w4, ans_b1 + ans_w2 + ans_b3 + ans_w4, ans_b1 + ans_w2 + ans_w3 + ans_b4, ans_w1 + ans_b2 + ans_b3 + ans_w4, ans_w1 + ans_b2 + ans_w3 + ans_b4, ans_w1 + ans_w2 + ans_b3 + ans_b4))",quadratic,"['bitmasks', 'brute force', 'implementation']",1308
"n = int(input()) chess = [] for w in range(3): chess.append([input() for i in range(n)]) input() chess.append([input() for i in range(n)]) issue = {0:0, 1:0, 2:0, 3:0} reversed_issue = {0:0, 1:0, 3:0} for w in range(4): chessdesk = [chess[0] + chess[3]] + [chess[1] + chess[2]] for s in range(2 * n): chessdesk[0][s] += chessdesk[1][s] chessdesk.pop(1) chessdesk = chessdesk[0] colour = chessdesk[0][0] for i in range(2 * n): for j in range(2 * n): if (i + j) % 2 == 0: if chessdesk[i][j] != colour: issue[w] += 1 else: if chessdesk[i][j] == colour: issue[w] += 1 reversed_issue[w] = 4 * n**2 - issue[w] if w == 0: chess[0], chess[3] = chess[3], chess[0] elif w == 1: chess[1], chess[3] = chess[3], chess[1] elif w == 2: chess[1], chess[2] = chess[2], chess[1] print(min(min(issue.values()), min(reversed_issue.values())))",quadratic,"['bitmasks', 'brute force', 'implementation']",822
"from itertools import permutations as p rd = lambda: map(int, input()) def f(n, t): a = 0 f = 1 for i in range(n): for x in rd(): if x != f: a += 1 f = 1 - f if t < 3: rd() return a n = int(input()) m = [] b = [-1, -1, 1, 1] for i in range(4): m.append(f(n, i)) print(2 * n ** 2 + min(sum(x * y for x, y in zip(q, m)) for q in set(p(b))))",quadratic,"['bitmasks', 'brute force', 'implementation']",338
"rd = lambda: map(int, input()) def f(n, t): a = sum(i + j & 1 == x for i in range(n) for j, x in enumerate(rd())) if t < 3: rd() return a n = int(input()) m = sorted([f(n, i) for i in range(4)]) print(2 * n * n + m[0] + m[1] - m[2] - m[3])",quadratic,"['bitmasks', 'brute force', 'implementation']",239
"import atexit import io import sys _INPUT_LINES = sys.stdin.read().splitlines() input = iter(_INPUT_LINES).__next__ _OUTPUT_BUFFER = io.StringIO() sys.stdout = _OUTPUT_BUFFER @atexit.register def write(): sys.__stdout__.write(_OUTPUT_BUFFER.getvalue()) def main(): n = int(input()) s = [] for i in range(4): df = 0 for k in range(n): l = input() for j in range(n): if int(l[j]) == (k + j) % 2: df += 1 if i <3 : input() s.append(df) print( min(s[0] + s[1] + n*n-s[2] + n*n-s[3], s[0] + s[2] + n*n-s[1] + n*n-s[3], s[0] + s[3] + n*n-s[1] + n*n-s[2], s[1] + s[2] + n*n-s[0] + n*n-s[3], s[1] + s[3] + n*n-s[0] + n*n-s[2], s[2] + s[3] + n*n-s[0] + n*n-s[1])) if __name__ == '__main__': main()",quadratic,"['bitmasks', 'brute force', 'implementation']",688
"import sys,os,io from sys import stdin from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop from bisect import bisect_left , bisect_right import math alphabets = list('abcdefghijklmnopqrstuvwxyz') def isPrime(x): for i in range(2,x): if i*i>x: break if (x%i==0): return False return True def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def SieveOfEratosthenes(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime def countdig(n): c = 0 while (n > 0): n //= 10 c += 1 return c def si(): return input() def prefix_sum(arr): r = [0] * (len(arr)+1) for i, el in enumerate(arr): r[i+1] = r[i] + el return r def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') def power_set(L): cardinality=len(L) n=2 ** cardinality powerset = [] for i in range(n): a=bin(i)[2:] subset=[] for j in range(len(a)): if a[-j-1]=='1': subset.append(L[j]) powerset.append(subset) powerset_orderred=[] for k in range(cardinality+1): for w in powerset: if len(w)==k: powerset_orderred.append(w) return powerset_orderred def fastPlrintNextLines(a): print('\n'.join(map(str,a))) def sortByFirstAndSecond(A): A = sorted(A,key = lambda x:x[0]) A = sorted(A,key = lambda x:x[1]) return li",quadratic,"['games', 'greedy']",2000
"def solution(n, k, arr): ret = [] grp = [None for _ in range(256)] for i in arr: if grp[i]: continue l = None j = 1 for j in range(1, k): if i - j < 0: break if grp[i - j] is not None: l = i - j break if l is not None and grp[l] > i - k: grp[i] = grp[l] else: ll = l + 1 if l else max(0, i - k + 1) for j in range(ll, i + 1): grp[j] = ll for i in arr: ret.append(grp[i]) return ret n, k = map(int, input().split()) arr = list(map(int, input().split())) print(' '.join(map(str, solution(n, k, arr))))",quadratic,"['games', 'greedy']",499
"n,k=map(int,input().split()) arr=list(map(int,input().split())) par=[i for i in range(260)] path=[-1 for i in range(260)] for i in range(n): j=arr[i] if path[j] >=0: par[j] =par[path[j]] continue jump=1 while j>0 and path[j] ==-1 and jump <k: path[j] =arr[i] j-=1 jump +=1 if arr[i] -par[j] +1 <=k: par[arr[i]] =par[j] path[j] =arr[i] else: par[arr[i]] =par[j+1] for i in range(n): print(par[arr[i]],end=' ') print()",quadratic,"['games', 'greedy']",416
"def getIntList(): return list(map(int, input().split())); n, k = getIntList(); p=getIntList(); choosed=[False]*256; left=[i for i in range(256)]; for i, x in enumerate(p): if not choosed[x]: best=x; for j in range(x-1, max(-1, x-k), -1): if not choosed[j]: best=j; else: if x-left[j]<k: best=left[j]; break; for j in range(best, x+1): choosed[j]=True; left[j]=best; p[i]=left[x]; print(' '.join(map(str, p)));",quadratic,"['games', 'greedy']",409
"n, k = [int(x) for x in input().split()] ps = [int(x) for x in input().split()] mapping = [-1 for _ in range(256)] res = [] for p in ps: if mapping[p] == -1: j = p - k + 1 while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p): j += 1 for i in range(j, p+1): mapping[i] = j res.append(mapping[p]) print("" "".join(map(str, res)))",quadratic,"['games', 'greedy']",330
"n, k = map(int, input().split()) P = map(int, input().split()) parent = list(range(256)) sz = [1] * 256 def rt(x): if x != parent[x]: parent[x] = rt(parent[x]) return parent[x] def u(rx, ry): parent[ry] = rx sz[rx] += sz[ry] ans = [0] * n for i, p in enumerate(P): rx = rt(p) while rx > 0 and sz[rx] + sz[rt(rx - 1)] <= k: u(rt(rx - 1), rx) rx = rt(p) ans[i] = rt(p) print(' '.join(map(str, ans)))",quadratic,"['games', 'greedy']",397
"import atexit import io import sys _INPUT_LINES = sys.stdin.read().splitlines() input = iter(_INPUT_LINES).__next__ _OUTPUT_BUFFER = io.StringIO() sys.stdout = _OUTPUT_BUFFER @atexit.register def write(): sys.__stdout__.write(_OUTPUT_BUFFER.getvalue()) def main(): n, k = [int(x) for x in input().split()] p = [int(x) for x in input().split()] t = [] g={} for x in p: if x in g: t.append(g[x]) continue kk = x - 1 while True: if kk in g: if x - g[kk] < k: ttt = g[kk] else: ttt= kk + 1 for i in range(kk +1 , x + 1): g[i] = ttt t.append(g[x]) break elif kk<0 or x - kk == k: for i in range(kk +1 , x + 1): g[i] = kk + 1 t.append(g[x]) break kk -= 1 print(' '.join((str(x) for x in t))) if __name__ == '__main__': main()",quadratic,"['games', 'greedy']",719
"def solve(): num_pixels, max_group_size = (int(x) for x in input().split()) pixels = [int(x) for x in input().split()] groups = [None for _ in range(256)] for pixel in pixels: if groups[pixel] is None: smallest_of_group = pixel while smallest_of_group >= 0 and smallest_of_group > pixel - max_group_size and groups[smallest_of_group] is None: smallest_of_group -= 1 if smallest_of_group >= 0 and groups[smallest_of_group] is not None and pixel - groups[smallest_of_group] + 1 <= max_group_size: group_color = groups[smallest_of_group] else: group_color = smallest_of_group + 1 smallest_of_group += 1 for color in range(smallest_of_group, pixel + 1): groups[color] = group_color print(*(groups[pixel] for pixel in pixels)) solve()",quadratic,"['games', 'greedy']",729
"def main(): n, k = map(int, input().split()) p = list(map(int, input().split())) solve(n, k, p) def solve(n, k, p): group = 256 * [None] r = p[:] for i, pi in enumerate(p): if group[pi] is not None: r[i] = group[pi][0] else: lo = pi while lo >= 0 and pi - lo < k and group[lo] is None: lo -= 1 if lo < 0 or pi - lo == k: lo += 1 hi = pi + 1 else: if pi - group[lo][0] < k: lo = group[lo][0] hi = pi + 1 else: lo += 1 hi = pi + 1 lohi = (lo, hi) for j in range(lo, hi): group[j] = lohi r[i] = group[pi][0] print("" "".join(map(str, r))) main()",quadratic,"['games', 'greedy']",540
"n,k=map(int,input().split()) p=list(map(int,input().split())) arr=[[] for i in range(256)] ans=[] for i in p: j=i if len(arr[i])==0: c=0 while c<k and j>=0: if len(arr[j])+c>k: break if len(arr[j])!=0: arr[i].extend(arr[j]) break arr[j]=arr[i] arr[j].append(j) j-=1 c+=1 arr[i].sort() ans.append(arr[i][0]) print(*ans)",quadratic,"['games', 'greedy']",318
"n,k = [int(s) for s in input().split()] p = [int(s) for s in input().split()] map = {} res = [] for pi in p: if map.get(pi) is None: key = pi for j in range(pi, pi-k, -1): if j < 0: break if map.get(j) is None: key = j else: if map[j] >= pi-k+1: key = map[j] break for j in range(pi, key-1, -1): if map.get(j): break map[j] = key res.append(map[pi]) print(*res, sep="" "")",quadratic,"['games', 'greedy']",370
"N, K = input().split() N, K = int(N), int(K) P = [int(x) for x in input().split()] A = [None]*256 A[0] = 0 for i in range(N): pn = P[i] if A[pn] is None: for j in range(K-1, -1, -1): if pn < j: continue if A[pn-j] is None: A[pn-j] = pn-j break else: if A[pn-j] + K - 1 >= pn: break for jj in range(j, -1, -1): A[pn-jj] = A[pn-j] print(*[A[P[i]] for i in range(N)])",quadratic,"['games', 'greedy']",364
"n, k = [int(i) for i in input().split()] p = [int(i) for i in input().split()] ans = [-1] * (max(p) + 1) ans[0] = 0 for i in range(n): if ans[p[i]] < 0: position = p[i] - k + 1 for j in range(max(0,p[i] - k + 1), p[i] + 1): if ans[j] < 0: position = j break j = max(0, position - 1) key = ans[j] count = 0 while j >= 0: if ans[j] != key: position1 = j + 1 break j -= 1 count += 1 if count + p[i] + 1 - position > k: key = position for j in range(position, p[i] + 1): ans[j] = key for i in range(n): if i != len(p) - 1: wk1 = "" "" else: wk1 = ""\n"" print(ans[p[i]], end = wk1)",quadratic,"['games', 'greedy']",573
"n,k = map(int,input().split()) l = [int(x) for x in input().split()] maps = [] for _ in range(256): maps.append(['empty',0]) output = [] for innum in l: if maps[innum][0] == 'chosen': outnum = maps[innum][1] elif maps[innum][0] == 'potential': outnum = maps[innum][1] i = innum while i >= 0 and maps[i][0] == 'potential': maps[i] = ['chosen',outnum] i -= 1 else: i = innum while i >= 0 and i >= innum - (k-1) and maps[i][0] != 'chosen': i -= 1 i += 1 outnum = i for j in range(outnum,innum+1): maps[j] = ['chosen',outnum] if innum < 255: for j in range(innum+1,min(256,outnum+k)): if maps[j][0] != 'chosen': maps[j] = ['potential',outnum] output.append(str(outnum)) print(' '.join(output))",quadratic,"['games', 'greedy']",689
"n, k = map(int, input().split()) ps = list(map(int, input().split())) if k == 1: print(' '.join([str(i) for i in ps])) exit() g = [None for i in range(256)] f = [None for i in range(256)] ans = [] for i in range(n): p = ps[i] if g[p] is not None: ans.append(g[p]) f[p] = 1 else: gb= 0 for j in range(1, k): ind = p - j if f[ind] is not None: gb = ind +1 break if ind <= 0: break if j == k-1: gb = ind ans.append(gb) for j in range(k): if gb+j >= 256: break if f[gb + j] is None: g[gb+j] = gb else: break f[gb] = 1 f[p] = 1 print(' '.join([str(i) for i in ans]))",quadratic,"['games', 'greedy']",561
"n, k = map(int, input().split()) ps = list(map(int, input().split())) g = [None for i in range(256)] f = [None for i in range(256)] ans = [] for i in range(n): p = ps[i] if g[p] is not None: ans.append(g[p]) f[p] = 1 else: gb= 0 for j in range(k): ind = p - j if f[ind] is not None: gb = ind +1 break if ind <= 0: break if j == k-1: gb = ind ans.append(gb) for j in range(k): if gb+j >= 256: break if f[gb + j] is None: g[gb+j] = gb else: break f[gb] = 1 f[p] = 1 print(' '.join([str(i) for i in ans]))",quadratic,"['games', 'greedy']",502
"n, k = map(int, input().strip().split()) data = map(int, input().strip().split()) sol = [] mapping = [(-1,1000)]*256 for x in data: if mapping[x][0] == -1: for i in range(max(x-k+1,0), x+1): if mapping[i][0] == -1: if i > 0 and mapping[i-1][1]+(x-i+1) <= k: p = mapping[i-1][1]+1 for j in range(i, x+1): mapping[j] = (mapping[i-1][0], p) p += 1 else: p = 1 for j in range(i, x+1): mapping[j] = (i, p) p += 1 break sol.append(mapping[x][0]) print(' '.join(map(str, sol)))",quadratic,"['games', 'greedy']",470
"import sys n, k = map(int, next(sys.stdin).rstrip().split()) xs = list(map(int, next(sys.stdin).rstrip().split())) mapka = {} lengths = {} result = [] for x in xs: if x in mapka: result.append(mapka[x]) else: left = max(0, x - k + 1) range_potential = x - left for i in range(range_potential, -1, -1): potential_left = x - i if potential_left not in mapka: result.append(potential_left) for y in range(potential_left, x + 1): mapka[y] = potential_left lengths[potential_left] = x - potential_left + 1 break else: if lengths[mapka[potential_left]] + (x - potential_left) <= k: result.append(mapka[potential_left]) for y in range(mapka[potential_left] + lengths[mapka[potential_left]], x + 1): mapka[y] = mapka[potential_left] lengths[mapka[potential_left]] += 1 break print(' '.join(map(str, result)))",quadratic,"['games', 'greedy']",800
"a = [0 for i in range(0, 256)] n,k = input().split(' ') k = int(k) for c in input().split(' '): c = int(c) if a[c] != 0: print(a[c]-1, end=' ') else: for x in range(c, c-k, -1): if a[x] == 0: i = x else: if c-a[x]+1<k: i = a[x]-1 break if x == 0: break for x in range(int(i), c+1): a[x] = i + 1 print(i, end=' ')",quadratic,"['games', 'greedy']",312
"n, k = [int(x) for x in input().split()] ps = [int(x) for x in input().split()] mapping = [-1 for _ in range(256)] res = [] for p in ps: if mapping[p] == -1: j = p - k + 1 while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p): j += 1 for i in range(j, p+1): mapping[i] = j res.append(mapping[p]) print("" "".join(map(str, res)))",quadratic,"['games', 'greedy']",330
"def main(): n, k = [int(_) for _ in input().split()] a = [int(_) for _ in input().split()] p = [-1] * 256 p[0] = 0 for x in a: if p[x] < 0: for y in range(x - 1, max(-1, x - k), -1): if p[y] >= 0: if p[y] + k > x: p[x] = p[y] else: p[x] = p[y + 1] = y + 1 break if p[x] < 0: p[x] = p[x - k + 1] = x - k + 1 b = [p[x] for x in a] print(' '.join(map(str, b))) if __name__ == '__main__': main()",quadratic,"['games', 'greedy']",391
"n,k=[int(x)for x in input().split()] ns=[int(x) for x in input().split()] done=[None]*256 ans=[None]*n for i in range(n): c=ns[i] if done[c]==None: j=c while True: if j<0 or c-j>=k or (done[j]!=None and done[j]!=-1): break j-=1 j+=1 for kk in range(k): if kk+j>=256 or (done[kk+j]!=None and done[kk+j]!=-1): break if kk+j<=c: done[kk+j]=j else: done[kk+j]=-1 elif done[c]==-1: j=c while True: if done[j]!=None and done[j]!=-1: break j-=1 a=done[j] for kk in range(j,c+1): done[kk]=a else: pass ans[i]=done[c] ans=[str(x)for x in ans] print(' '.join(ans))",quadratic,"['games', 'greedy']",554
"n,k=map(int,input().split()) ar=[-1 for i in range(256)] ls=list(map(int,input().split())) for e in ls: if ar[e]==-1: tmp=max(0,e-k+1) for i in range(tmp,e+1): if ar[i]!=-1 and ar[i]!=i: tmp+=1 continue else: while i<=e: ar[i]=tmp i+=1 print(ar[e],end="" "")",quadratic,"['games', 'greedy']",256
"n, k = map(int, input().split()) a = list(map(int, input().split())) c = [-1]*256 ans = [0]*n for i in range(n): if c[a[i]] == -1: for j in range(a[i], max(-1, a[i]-k), -1): if c[j] != -1: if (c[j] +k) > a[i]: c[a[i]] = c[j] else: c[a[i]] = j+1 break if c[a[i]] == -1: c[a[i]] = max(0, a[i]-k+1) for xx in range(c[a[i]], a[i]): c[xx] = c[a[i]] ans[i] = str(c[a[i]]) print(' '.join(ans))",quadratic,"['games', 'greedy']",386
"n, k = list(map(int, input().split())) p = list(map(int, input().split())) processed = set() color = {} length = {} ans = [] def exists(p, elt, d): for e in p: if e > elt: if e <= elt + d: return True elif e - d <= elt + d: return False return False def exists2(p, elt, d): for e in p: if e > elt: if e <= elt + d: return False elif e - d <= elt + d: return [True, e - d] return False for i in range(n): elt = p[i] if elt in processed: ans.append(color[elt]) else: processed.add(elt) new = 1 run = True for j in range(1, k): if elt - j < 0: break elif (elt - j) not in processed: processed.add(elt - j) new += 1 elif length[elt - j] + new <= k: for i2 in range(length[elt - j] + new): color[elt - i2] = color[elt - j] length[elt] = length[elt - j] + new run = False break else: break if run: for j in range(new): color[elt - j] = elt - new + 1 length[elt] = new s = str(color[p[0]]) for elt in p[1:]: s += ' ' + str(color[elt]) print(s)",quadratic,"['games', 'greedy']",936
"import sys import math input = sys.stdin.readline from functools import cmp_to_key; def pi(): return(int(input())) def pl(): return(int(input(), 16)) def ti(): return(list(map(int,input().split()))) def ts(): s = input() return(list(s[:len(s) - 1])) def invr(): return(map(int,input().split())) mod = 998244353; f = []; def fact(n,m): global f; f = [1 for i in range(n+1)]; f[0] = 1; for i in range(1,n+1): f[i] = (f[i-1]*i)%m; def fast_mod_exp(a,b,m): res = 1; while b > 0: if b & 1: res = (res*a)%m; a = (a*a)%m; b = b >> 1; return res; def inverseMod(n,m): return fast_mod_exp(n,m-2,m); def ncr(n,r,m): if r == 0: return 1; return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m; def main(): B(); dp = []; def D(): [n,k] = ti(); a = ti(); a = sorted(a); cnt = [0 for i in range(n)]; for i in range(n): c = 0; for j in range(i,n): if a[j]-a[i] <= 5: c+=1; else:break; cnt[i] = c; global dp; dp = [[0 for j in range(k+1)] for i in range(n+1)]; ans = 0; for i in range(n): for j in range(k+1): dp[i+1][j] = max(dp[i+1][j], dp[i][j]); if j+1 <= k: dp[i+cnt[i]][j+1] = max(dp[i+cnt[i]][j+1], dp[i][j]+cnt[i]); print(dp[n][k]); def B(): n = pi(); a = ti(); q = pi(); mat = [[0 for j in range(n)] for i in range(n)]; dp = [[0 for i in range(n)] for j in range(n)]; for i in range(n): for j in range(n): if i == j: mat[i][j] = a[i]; dp[i][j] = a[i]; i = 0; x = 1; while x < n: j = x; i = 0; while j < n: mat[i][j] = mat[i][j-1] ^ mat[i+1][j]; j += 1; i += 1; x += 1; i = 0; x = 1; while x < n: j = x; i = 0; while j < n: dp[i][j] = max(mat[i][j], dp[i][j-1], dp[i+1][j]); j += 1; i += 1; x += 1; for i in range(q): [l,r] = ti(); print(dp[l-1][r-1]); main();",quadratic,['dp'],1657
"n = int(input()) values = list(map(int, input().split())) queries = int(input()) dp = [[0] * 5009 for i in range(5009)] for i in range(n): dp[0][i] = values[i] for i in range(1, n): for j in range(n-i+1): top = dp[i-1][j] right = dp[i-1][j+1] dp[i][j] = top ^ right for i in range(1, n): for j in range(n-i+1): top = dp[i-1][j] right = dp[i-1][j+1] dp[i][j] = max(right, max(dp[i][j], top)) for i in range(queries): left, right = map(int, input().split()) last_row = (right - 1) - (left - 1) last_column = (left - 1) print(dp[last_row][last_column])",quadratic,['dp'],549
"import sys input=sys.stdin.buffer.readline n=int(input()) a=list(map(int,input().split())) dp=[[0]*(n) for i in range(n)] for i in range(n): dp[i][i]=a[i] count=1 for i in range(n-1): for j in range(n-i-1): dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count] count+=1 count=1 for i in range(n-1): for j in range(n-i-1): dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count]) count+=1 for i in range(int(input())): l,r=map(int,input().split()) l-=1 r-=1 print(dp[l][r])",quadratic,['dp'],479
"import sys n = int(sys.stdin.readline()) a = list(map(int, sys.stdin.readline().split(' '))) Array = [a] for i in range(n - 1): aux = [] for j in range(1, len(Array[-1])): aux.append(Array[-1][j-1] ^ Array[-1][j]) Array.append(aux) for j in range(1, len(Array)): for k in range(len(Array[j])): Array[j][k] = max(Array[j][k], Array[j-1][k], Array[j - 1][k + 1]) q = int(sys.stdin.readline()) for i in range(q): l, r = map(int, sys.stdin.readline().split(' ')) sys.stdout.write(str(Array[r - l][l - 1]) + '\n')",quadratic,['dp'],508
"def main(): n = int(input()) a = list(map(int, input().split(' '))) array = [] array.append(a) for i in range(n - 1): aux = [] for j in range(1, len(array[-1])): xor = array[-1][j-1] ^ array[-1][j] aux.append(xor) array.append(aux) for j in range(1, len(array)): for k in range(len(array[j])): maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1]) array[j][k] = maximo q = int(input()) for i in range(q): l, r = map(int, input().split(' ')) print(str(array[r - l][l - 1])) main()",quadratic,['dp'],487
"def main(): n = int(input()) a = list(map(int, input().split(' '))) array = [] array.append(a) for i in range(n - 1): aux = [] for j in range(1, len(array[-1])): xor = array[-1][j-1] ^ array[-1][j] aux.append(xor) array.append(aux) for j in range(1, len(array)): for k in range(len(array[j])): maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1]) array[j][k] = maximo q = int(input()) aux2 = [] for i in range(q): l, r = map(int, input().split(' ')) aux2.append((l,r)) for i in aux2: l, r = i[0], i[1] print(str(array[r - l][l - 1])) main()",quadratic,['dp'],549
"def main(): n = int(input()) a = list(map(int, input().split(' '))) array = [] array.append(a) for i in range(n - 1): aux = [] for j in range(1, len(array[-1])): xor = (array[-1][j-1] ^ array[-1][j]) aux.append(xor) array.append(aux) for j in range(1, len(array)): for k in range(len(array[j])): maximo = max(array[j][k], array[j-1][k], array[j-1][k+1]) array[j][k] = maximo q = int(input()) aux2 = [] for i in range(q): l, r = map(int, input().split(' ')) aux2.append((l, r)) for i in aux2: l, r = i[0], i[1] print(str(array[r-l][l-1])) main()",quadratic,['dp'],544
"import sys input=sys.stdin.readline n=int(input()) a=list(map(int,input().split())) f=[[0]*n for i in range(n)] for i in range(n): f[0][i]=a[i] for i in range(1,n): for j in range(n-i): f[i][j]=f[i-1][j]^f[i-1][j+1] for i in range(1,n): for j in range(n-i): f[i][j]=max(f[i][j],f[i-1][j],f[i-1][j+1]) q=int(input()) for _ in range(q): l,r=map(int,input().split()) print(f[r-l][l-1])",quadratic,['dp'],382
"import sys input = lambda : sys.stdin.readline().rstrip() sys.setrecursionlimit(2*10**5+10) write = lambda x: sys.stdout.write(x+""\n"") debug = lambda x: sys.stderr.write(x+""\n"") writef = lambda x: print(""{:.12f}"".format(x)) class SG: def __init__(self, n, v=None): self._n = n self.geta = 0 x = 0 while (1 << x) < n: x += 1 self._log = x self._size = 1 << self._log self._d = [ninf] * (2 * self._size) if v is not None: for i in range(self._n): self._d[self._size + i] = v[i] for i in range(self._size - 1, 0, -1): self._update(i) def _update(self, k): self._d[k] = op(self._d[2 * k], self._d[2 * k + 1]) def update(self, p, x): assert 0 <= p < self._n p += self._size self._d[p] = x for i in range(1, self._log + 1): k = p>>i self._d[k] = op(self._d[2 * k], self._d[2 * k + 1]) def get(self, p): assert 0 <= p < self._n return self._d[p + self._size] def check(self): return [self.get(p) for p in range(self._n)] def query(self, left, right): assert 0 <= left <= right <= self._n sml = ninf smr = ninf left += self._size right += self._size while left < right: if left & 1: sml = op(sml, self._d[left]) left += 1 if right & 1: right -= 1 smr = op(self._d[right], smr) left >>= 1 right >>= 1 return op(sml, smr) def query_all(self): return self._d[1] def max_right(self, left, f): if left == self._n: return self._n left += self._size sm = ninf first = True while first or (left & -left) != left: first = False while left % 2 == 0: left >>= 1 if not f(op(sm, self._d[left])): while left < self._size: left *= 2 if f(op(sm, self._d[left])): sm = op(sm, self._d[left]) left += 1 return left - self._size sm = op(sm, self._d[left]) left += 1 return self._n def min_left(self, right, f): if right == 0: return 0 right += self._size sm = ninf first = True while first or (right & -right) != right: first = False right -= 1 while right > 1 and right % 2: right >>= 1 if not f(op(self._d[right], sm)): while right < self._size: right = 2 * right + 1 if f(op(self._d[right], sm)): sm = op(self._d[right], sm)",quadratic,['dp'],2000
"from sys import stdin def main(): n = int(input()) aa = list(map(int, input().split())) dp = [aa] for i in range(n - 1, 0, -1): aa = aa[:] for j in range(i): aa[j] ^= aa[j + 1] del aa[-1] dp.append(aa) aa = dp[0] for i, bb in enumerate(dp[1:], 1): a = aa[0] for j, b in enumerate(bb): c = aa[j + 1] bb[j] = max(a, b, c) a = c aa = bb input() res = stdin.read().splitlines() for i, s in enumerate(res): lo, hi = map(int, s.split()) res[i] = str(dp[hi - lo][lo - 1]) print('\n'.join(res)) if __name__ == '__main__': main()",quadratic,['dp'],520
"from sys import stdin, stdout n=int(input()) s=list(map(int,stdin.readline().strip().split())) dp=[[-1 for i in range(n+1)]for j in range(n+1)] for i in range(n): dp[0][i]=s[i] for i in range(1,n): for j in range(n-i): dp[i][j]=dp[i-1][j]^dp[i-1][j+1] for i in range(1,n): for j in range(n-i): dp[i][j]=max(dp[i-1][j],dp[i-1][j+1],dp[i][j]) q=int(input()) ans="""" for i in range(q): l,r=map(int,stdin.readline().strip().split()) print(dp[r-l][l-1])",quadratic,['dp'],447
"n = int(input()) *a, = map(int, input().split()) dp = [[0 for i in range(n + 1)] for j in range(n + 1)] for i in range(n): dp[0][i] = a[i] for i in range(1, n): for j in range(n - i + 1): dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1] for i in range(1, n): for j in range(n - i): dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1]) for i in range(int(input())): l, r = map(int, input().split()) print(dp[r - l][l - 1])",quadratic,['dp'],419
"t=1 for _ in range(t): n=int(input()) l=list(map(int,input().split())) dp=[[0 for j in range(n)] for i in range(n)] for i in range(n): dp[0][i]=l[i] for i in range(1,n): for j in range(n-i): dp[i][j]=dp[i-1][j]^dp[i-1][j+1] for i in range(1,n): for j in range(n-i): dp[i][j]=max(dp[i][j],dp[i-1][j],dp[i-1][j+1]) q=int(input()) for __ in range(q): x,y=map(int,input().split()) x-=1 y-=1 print(dp[y-x][x])",quadratic,['dp'],404
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") n = int(input()) *a, = map(int, input().split()) dp = [[0 for i in range(n + 1)] for j in range(n + 1)] for i in range(n): dp[0][i] = a[i] for i in range(1, n): for j in range(n - i + 1): dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1] for i in range(1, n): for j in range(n - i): dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1]) for i in range(int(input())): l, r = map(int, input().split()) print(dp[r - l][l - 1])",quadratic,['dp'],1949
"import math import random import heapq, bisect import sys from collections import deque, defaultdict from fractions import Fraction import sys import threading from collections import defaultdict threading.stack_size(10**8) mod = 10 ** 9 + 7 mod1 = 998244353 import os import sys from io import BytesIO, IOBase sys.setrecursionlimit(300000) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class TreeNode: def __init__(self, k, v): self.key = k self.value = v self.left = None self.right = None self.parent = None self.height = 1 self.num_left = 1 self.num_total = 1 class AvlTree: def __init__(self): self._tree = None def add(self, k, v): if not self._tree: self._tree = TreeNode(k, v) return node = s",quadratic,['dp'],1999
"from sys import stdin from operator import xor rints = lambda: [int(x) for x in stdin.readline().split()] n, a, m = int(input()), [rints()], int(input()) qur, out = [rints() for _ in range(m)], [] for i in range(1, n): a.append(list(map(xor, a[-1][:-1], a[-1][1:]))) for i in range(n - 1): a[i + 1] = list(map(max, a[i][:-1], a[i][1:], a[i + 1])) for l, r in qur: out.append(a[r - l][l - 1]) print('\n'.join(map(str, out)))",quadratic,['dp'],423
"from sys import stdin from operator import xor rints = lambda: [int(x) for x in stdin.readline().split()] n, a, m = int(input()), [rints()], int(input()) qur, out = [rints() for _ in range(m)], [] for i in range(1, n): a.append(map(xor, a[-1][:-1], a[-1][1:])) for i in range(n - 1): a[i + 1] = map(max, a[i][:-1], a[i][1:], a[i + 1]) for l, r in qur: out.append(a[r - l][l - 1]) print('\n'.join(map(str, out)))",quadratic,['dp'],411
"import sys input=sys.stdin.readline n=int(input()) ar=list(map(int,input().split())) dic={} li=[] for i in range(n): xx=[] for j in range(n-i): xx.append(0) li.append(xx.copy()) for i in range(n): for j in range(n-i): if(i==0): li[i][j]=ar[j] else: li[i][j]=li[i-1][j]^li[i-1][j+1] for i in range(1,n): for j in range(n-i): li[i][j]=max(li[i][j],li[i-1][j],li[i-1][j+1]) for _ in range(int(input())): l,r=map(int,input().split()) print(li[r-l][l-1])",quadratic,['dp'],449
"import sys, os def read_int(): return int(input()) def read_ints(): return list(map(int, input().split())) n = read_int() a = read_ints() dp = [[0] * n for _ in range(n)] f = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): f[i][i] = a[i] for j in range(i + 1, n): f[i][j] = f[i][j - 1] ^ f[i + 1][j] for i in range(n - 1, -1, -1): dp[i][i] = f[i][i] for j in range(i + 1, n): dp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j]) q = read_int() for _ in range(q): l, r = read_ints() print(dp[l - 1][r - 1])",quadratic,['dp'],515
"import sys, os def read_int(): return int(input()) def read_ints(): return list(map(int, input().split())) n = read_int() a = read_ints() dp = [[0] * n for _ in range(n)] f = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): f[i][i] = dp[i][i] = a[i] for j in range(i + 1, n): f[i][j] = f[i][j - 1] ^ f[i + 1][j] dp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j]) q = read_int() for _ in range(q): l, r = read_ints() print(dp[l - 1][r - 1])",quadratic,['dp'],450
"s, l= list(map(int,input().split())) sig = [] utp = [] if s == 0 or l ==0: print('NO') quit() for i in range(s): sig.append(list(map(int,input()))) for i in range(0,l): out = 0 for x in range(0,s): out+=sig[x][i] utp.append(out) sig = sorted(sig,key = sum) for i in range(0,s): res1=0 for x in range(0,l): if utp[x]-sig[i][x] <=0: break else: res1+=1 if res1 == l: print('YES') quit() print('NO')",quadratic,['implementation'],396
"n,m=map(int,input().split()) a=[int(input(),2)for _ in range(n)] s=t=0 for x in a: t|=s&x s|=x print(('YES','NO')[all(x&s&~t for x in a)])",quadratic,['implementation'],138
"def fun(grid,counter,n,m): for i in range(n): possible=True for j in range(m): if grid[i][j]=='1' and counter[j]==1: possible=False break if possible: return True return False n,m=[int(_) for _ in input().split("" "")] grid,counter=[],[0]*m for _ in range(n): s=input() for i in range(m): if s[i]=='1': counter[i]+=1 grid.append(s) if fun(grid,counter,n,m): print(""YES"") else: print(""NO"")",quadratic,['implementation'],386
"n, m = map(int,input().split()) X = [] for i in range(n): a = input() U = [char for char in a] X.append(U) nums = [] for i in range(m): t = 0 for j in range(n): t += int(X[j][i]) nums.append(t) for i in range(n): ok = True for j in range(m): if X[i][j] == '1': if nums[j]>1: continue else: ok = False if ok == True: print(""YES"") quit() print(""NO"")",quadratic,['implementation'],347
"from collections import deque as de import math from collections import Counter as cnt from functools import reduce from typing import MutableMapping def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) class My_stack(): def __init__(self): self.data = [] def my_push(self, x): return (self.data.append(x)) def my_pop(self): return (self.data.pop()) def my_peak(self): return (self.data[-1]) def my_contains(self, x): return (self.data.count(x)) def my_show_all(self): return (self.data) def isEmpty(self): return len(self.data)==0 arrStack = My_stack() def decimalToBinary(n): return bin(n).replace(""0b"", """") def isPrime(n) : if (n <= 1) : return False if (n <= 3) : return True if (n % 2 == 0 or n % 3 == 0) : return False i = 5 while(i * i <= n) : if (n % i == 0 or n % (i + 2) == 0) : return False i = i + 6 return True def get_prime_factors(number): prime_factors = [] while number % 2 == 0: prime_factors.append(2) number = number / 2 for i in range(3, int(math.sqrt(number)) + 1, 2): while number % i == 0: prime_factors.append(int(i)) number = number / i if number > 2: prime_factors.append(int(number)) return prime_factors def get_frequency(list): dic={} for ele in list: if ele in dic: dic[ele] += 1 else: dic[ele] = 1 return dic def Log2(x): return (math.log10(x) / math.log10(2)); def isPowerOfTwo(n): return (math.ceil(Log2(n)) == math.floor(Log2(n))); n,m=map(int,input().split()) l=[list(map(int,input())) for i in range(n)] dic={} discarded={} for i in range(n): for j in range(m): if l[i][j]==1 : if j+1 not in discarded: if j+1 not in dic: dic[j+1]=i+1 else: del dic[j+1] discarded[j+1]=1 if len(dic)==0: print(""YES"") else: kk=list(dic.values()) temp=list(set(kk)) if len(temp)==n: print(""NO"") else: print(""YES"")",quadratic,['implementation'],1789
"if __name__ == '__main__': cin = input n, m = map(int, cin().split()) s, l, f = [[] for _ in range(n)], [0] * m, 0 for i in range(n): t = cin() for j in range(m): if t[j] == ""1"": l[j] += int(t[j]) s[i].append(j) for i in range(n): r = set(l[c] - 1 for c in s[i]) if not 0 in r: f = not f break print(""YNEOS""[not f::2])",quadratic,['implementation'],318
"import sys,math,itertools from collections import Counter,deque,defaultdict from bisect import bisect_left,bisect_right from heapq import heappop,heappush,heapify, nlargest from copy import deepcopy mod = 10**9+7 INF = float('inf') def inp(): return int(sys.stdin.readline()) def inpl(): return list(map(int, sys.stdin.readline().split())) def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split())) def inps(): return sys.stdin.readline() def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x]) def err(x): print(x); exit() n,m = inpl() s = [inpsl(m) for _ in range(n)] lampcnt = [0]*m for i in range(n): for j in range(m): if s[i][j] == '1': lampcnt[j] += 1 res = False for i in range(n): only = False for j in range(m): if s[i][j] == '1' and lampcnt[j] == 1: only = True if not only: res = True print('YES' if res else 'NO')",quadratic,['implementation'],854
"n, m = map(int, input().split()) x = list(list(map(int , input())) for i in range(n)) res = [0] * m for i in range(n): for j in range(m): res[j] += x[i][j] for i in range(n): ok = 1 for j in range(m): if res[j] == 1 and x[i][j] == 1: ok = 0 break if ok: print(""YES"") exit() print(""NO"")",quadratic,['implementation'],285
"n, m = map(int, input().split()) grid = [] for i in range(n): grid.append(input()) cnts = [0 for i in range(m)] for i in range(n): for j in range(m): cnts[j] += 0 if grid[i][j] == '0' else 1 for i in range(n): flag = True for j in range(m): if grid[i][j] == '1' and cnts[j] == 1: flag = False break if flag: print('YES') exit(0) print('NO')",quadratic,['implementation'],340
"import sys import io, os input = sys.stdin.readline n, m = map(int, input().split()) A = [input().rstrip() for i in range(n)] C = [0]*m for i in range(n): a = A[i] for j, c in enumerate(a): C[j] += int(c) for i in range(n): a = A[i] for j, c in enumerate(a): C[j] -= int(c) for j in range(m): if C[j] == 0: break else: print('YES') exit() continue for j, c in enumerate(a): C[j] += int(c) print('NO')",quadratic,['implementation'],400
"from collections import defaultdict, deque from heapq import heappush, heappop from math import inf def solve(): n, m = map(int, input().split()) cnt = defaultdict(int) res = [] for i in range(n): A = list(map(int, list(input()))) res.append(A) for j in range(m): if A[j]: cnt[j] += 1 valid = False for r in res: j = [i for i in range(m) if r[i]] if all(cnt[i] > 1 for i in j): valid = True break if valid: print(""YES"") else: print(""NO"") t = 1 while t: t -= 1 solve()",quadratic,['implementation'],467
"from sys import stdin from functools import reduce from operator import ior def get_ints(): return list(map(int, stdin.readline().strip().split())) nk ,m = get_ints() a = [int(input(),2) for x in range(nk)] if nk == 1: print(""NO"") exit() num = reduce(ior,a) for i in range(nk): k = a.copy() k.pop(i) n = reduce(ior,k) if n == num: print(""YES"") exit() print(""NO"")",quadratic,['implementation'],362
"n, m = map(int, input().split()) a = [int(input(), 2) for _ in range(n)] s = t = 0 for x in a: t |= s & x s |= x print((""YES"", ""NO"")[all(x & s & ~t for x in a)])",quadratic,['implementation'],161
"from operator import * n, m = map(int, input().split()) a = [int(input(), 2) for _ in range(n)] s = t = 0 for x in a: t |= s & x s |= x print((""YES"", ""NO"")[all(x & s & ~t for x in a)])",quadratic,['implementation'],184
"n, m = map(int, input().split()) tc = [0]*m ps = [] for _ in range(n): temp = input() psa = [0]*m for i in range(m): if temp[i] == '1': psa[i] += 1 tc[i] += 1 ps.append(psa) ans = 'NO' for i in ps: c = 0 for j in range(m): if tc[j]-i[j] > 0: c += 1 if c == m: ans = 'YES' break print(ans)",quadratic,['implementation'],288
"n,m = map(int,input().split()) d = {x:0 for x in range(m)} l = [] for _ in range(n): s = input() for x in range(m): if s[x]== '1': d[x]+=1 l.append(s) for x in l: t=0 for y in range(m): if x[y] =='1': if d[y] ==1:t = 1;break if t==0: print('YES');exit() print('NO')",quadratic,['implementation'],265
"from sys import stdin, stdout nmbr = lambda: int(input()) lst = lambda: list(map(int, input().split())) for _ in range(1): r, c=lst() a=[input() for i in range(r)] pre=[[0 for i in range(c)] for i in range(r)] suf=[[0 for i in range(c)] for i in range(r)] for i in range(c): pre[0][i]=int(a[0][i]) suf[r-1][i]=int(a[r-1][i]) for i in range(1, r): for j in range(c): pre[i][j]=pre[i-1][j]+int(a[i][j]) for i in range(r-2, -1 ,-1): for j in range(c): suf[i][j]=suf[i+1][j]+int(a[i][j]) ans='NO' for i in range(r): f=1 for j in range(c): up=down=0 if i-1>=0:up=pre[i-1][j] if i+1<r:down=suf[i+1][j] if up+down==0: f=0 break if f: ans=""YES"" break print(ans)",quadratic,['implementation'],653
"n, m = map(int, input().split()) a = [list(map(int, input())) for i in range(n)] ignorable = [True] * n for i in range(m): cnt = 0 for j in range(n): cnt += a[j][i] if cnt == 1: for j in range(n): if a[j][i]: ignorable[j] = False if any(ignorable): print('YES') else: print('NO')",quadratic,['implementation'],279
"def main(): n, m = map(int, input().split()) a = [] for i in range(n): a.append(input()) ans = ""NO"" count = [0] * m for i in range(n): for j in range(m): if (a[i][j] == '1'): count[j] += 1 for i in range(n): ans = ""YES"" for j in range(m): if (count[j] == 1 and a[i][j] == '1'): ans = ""NO"" break if (ans == ""YES""): break print(ans) main()",quadratic,['implementation'],337
"n, m = [int(v) for v in input().split()] a = [] for _ in range(n): a.append([int(v) for v in input()]) colsums = [sum(a[i][j] for i in range(n)) for j in range(m)] for row in a: if all(rv < sv for (rv, sv) in zip(row, colsums)): print(""YES"") exit() print(""NO"")",quadratic,['implementation'],260
"import sys n=int(input()) l=list(map(int,input().split())) c=list(map(int,input().split())) a=[] for i in range(1,n-1): lr=sys.maxsize lc=sys.maxsize for j in range(0,i): if l[i]>l[j]: lc=min(lc,c[j]) for j in range(i+1,n): if l[j]>l[i]: lr=min(lr,c[j]) if lr<sys.maxsize and lc<sys.maxsize: a.append(lr+lc+c[i]) if not a: print(-1) else: print(min(a))",quadratic,"['brute force', 'dp', 'implementation']",352
"from sys import stdin,stdout nmbr=lambda:int(stdin.readline()) lst=lambda:list(map(int,stdin.readline().split())) for _ in range(1): n=nmbr() a=lst() b=lst() dp=[0]*n for i in range(n): v=float('inf') for j in range(i+1,n): if a[j]>a[i]:v=min(v,b[i]+b[j]) dp[i]=v for i in range(n): v = float('inf') for j in range(i + 1, n): if a[j] > a[i]: v = min(v, b[i] + dp[j]) dp[i] = v ans=min(dp) print(ans if ans!=float('inf') else -1)",quadratic,"['brute force', 'dp', 'implementation']",428
"from sys import stdin,stdout nmbr = lambda: int(stdin.readline()) lst = lambda: list(map(int, stdin.readline().split())) for _ in range(1): n=nmbr() a=lst() b=lst() ans=PI=float('inf') dp=[[PI for _ in range(4)] for _ in range(n)] for i in range(n): dp[i][1]=b[i] for j in range(i): if a[j]<a[i]: dp[i][2]=min(dp[i][2],dp[j][1]+b[i]) dp[i][3]=min(dp[i][3],dp[j][2]+b[i]) ans=min(ans,dp[i][3]) print(ans if ans!=PI else -1)",quadratic,"['brute force', 'dp', 'implementation']",422
"import sys input = sys.stdin.readline n = int(input()) s = list(map(int,input().split())) c = list(map(int,input().split())) d = {} for i in range(n-1): ans = 10**12 for j in range(i+1,n): if s[i] < s[j]: ans = min(ans,c[i]+c[j]) d[i] = ans ans = 10**12 for i in range(n-2): for j in range(i+1,n-1): if s[i] < s[j]: ans = min(ans,c[i]+d[j]) if ans == 10**12: print(-1) else: print(ans)",quadratic,"['brute force', 'dp', 'implementation']",385
"import sys n = int(input().strip()) sizes = list(map(int, input().strip().split())) cost = list(map(int, input().strip().split())) tot = [] for i in range(n): tot.append([sizes[i], cost[i]]) ret = False lcomp = [] for j in range(len(tot)): if j > 0 and j < len(tot)-1: temp1 = tot[:j] temp2 = tot[j+1:] mi_1 = sys.maxsize ret1 = False for i in range(len(temp1)): if temp1[i][0] < tot[j][0]: mi_1 = min(mi_1, temp1[i][1]) ret1 = True mi_2 = sys.maxsize ret2 = False for k in range(len(temp2)): if temp2[k][0] > tot[j][0]: mi_2 = min(mi_2, temp2[k][1]) ret2 = True if ret1 and ret2: ret = True lcomp.append(mi_1+tot[j][1]+mi_2) if ret: print(min(lcomp)) else: print(-1)",quadratic,"['brute force', 'dp', 'implementation']",667
"import sys input = sys.stdin.readline n = int(input()) a = list(map(int, input().split())) b = list(map(int, input().split())) ans = float('inf') for i in range(1, n-1): bef = aft = float('inf') for j in range(i): if a[j] < a[i]: bef = min(bef, b[j]) for j in range(i, n): if a[i] < a[j]: aft = min(aft, b[j]) ans = min(ans, b[i]+bef+aft) print(-1 if ans > 10**9 else ans)",quadratic,"['brute force', 'dp', 'implementation']",372
"n = int(input()) l = list(map(int, input().split("" ""))) l2 = list(map(int, input().split("" ""))) dp_1 = l2.copy() dp_2 = [9999999999]*n dp_3 = [9999999999]*n for i in range(1, n): for j in range(i): if l[i] > l[j]: dp_2[i] = min(dp_2[i], dp_1[j]+l2[i]) for i in range(1,n): for j in range(i): if l[i] > l[j]: dp_3[i] = min(dp_3[i], dp_2[j]+l2[i]) x = min(dp_3) if x == 9999999999: print(-1) else: print(x)",quadratic,"['brute force', 'dp', 'implementation']",404
"n = int(input()) l = list(map(int, input().split("" ""))) l2 = list(map(int, input().split("" ""))) dp_1 = l2.copy() dp_2 = [9999999999]*n dp_3 = [9999999999]*n for i in range(1, n): for j in range(i): if l[i] > l[j]: dp_2[i] = min(dp_2[i], dp_1[j]+l2[i]) for j in range(i): if l[i] > l[j]: dp_3[i] = min(dp_3[i], dp_2[j]+l2[i]) x = min(dp_3) if x == 9999999999: print(-1) else: print(x)",quadratic,"['brute force', 'dp', 'implementation']",383
"n = int(input()) nums = list(map(int, input().split())) costs = list(map(int, input().split())) k = -1 for i in range(n): kc = -1 for c in range(i + 1, n): if nums[i] < nums[c] and (kc == -1 or kc > costs[c]): if kc == -1: kc = costs[c] kc = costs[c] if kc > -1: nat = kc kc = -1 for c in range(i): if nums[i] > nums[c] and (kc == -1 or kc > costs[c]): if kc == -1: kc = costs[c] kc = costs[c] if kc > -1: if k == -1: k = nat + kc + costs[i] k = min(nat + kc + costs[i], k) print(k)",quadratic,"['brute force', 'dp', 'implementation']",482
"import math import sys n=int(input()) s=list(map(int,input().split())) ce=list(map(int,input().split())) best=10**9 for j in range(1,n-1): a=ce[j];b=10**9;c=10**9 for i in range(j-1,-1,-1): if s[i]<s[j]: b=min(b,ce[i]) for k in range(j+1,n): if s[k]>s[j]: c=min(c,ce[k]) best=min(best,a+b+c) if best>=10**9: print(-1) else: print(best)",quadratic,"['brute force', 'dp', 'implementation']",335
"n = int(input()) a = list(map(int,input().split())) cost = list(map(int,input().split())) ans = float(""inf"") for i in range(n): m,r = float(""inf""),float(""inf"") for j in range(i): if a[j]<a[i]: m = min(m,cost[j]) for k in range(i+1,n): if a[k]>a[i]: r = min(r,cost[k]) ans = min(ans,cost[i]+m+r) print(ans if ans!=float(""inf"") else -1)",quadratic,"['brute force', 'dp', 'implementation']",334
"import sys, os, io def rs(): return sys.stdin.readline().rstrip() def ri(): return int(sys.stdin.readline()) def ria(): return list(map(int, sys.stdin.readline().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') import math,datetime,functools,itertools,operator,bisect,fractions,statistics from collections import deque,defaultdict,OrderedDict,Counter from fractions import Fraction from decimal import Decimal from sys import stdout from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest INF=99999999999999999999999999999999 def main(): mod=1000000007 starttime=datetime.datetime.now() if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") sys.stdout = open(""output.txt"",""w"") tc = 1 for _ in range(tc): n=ri() s=ria() c=ria() ans=INF for i in range(n): mid=s[i] mcl=INF mrl=INF for j in range(i-1,-1,-1): if s[j]<mid: mcl=min(mcl,c[j]) for j in range(i+1,n): if s[j]>mid: mrl=min(mrl,c[j]) ans=min(ans,c[i]+mcl+mrl) if ans==INF: wi(-1) else: wi(ans) endtime=datetime.datetime.now() time=(endtime-starttime).total_seconds()*1000 if(os.path.exists('input.txt')): print(""Time:"",time,""ms"") class FastReader(io.IOBase): newlines = 0 def __init__(self, fd, chunk_size=1024 * 8): self._fd = fd self._chunk_size = chunk_size self.buffer = io.BytesIO() def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self, size=-1): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() class Fas",quadratic,"['brute force', 'dp', 'implementation']",2000
"class SegTree: def __init__(self, init_val, ide_ele, segfunc): self.n = len(init_val) self.num = 2**(self.n-1).bit_length() self.ide_ele = ide_ele self.segfunc = segfunc self.seg = [ide_ele]*2*self.num for i in range(self.n): self.seg[i+self.num] = init_val[i] for i in range(self.num-1, 0, -1): self.seg[i] = self.segfunc(self.seg[2*i], self.seg[2*i+1]) def update(self, k, x): k += self.num self.seg[k] = x while k: k = k >> 1 self.seg[k] = self.segfunc(self.seg[2*k], self.seg[2*k+1]) def query(self, l, r): if r <= l: return self.ide_ele l += self.num r += self.num lres = self.ide_ele rres = self.ide_ele while l < r: if r & 1: r -= 1 rres = self.segfunc(self.seg[r], rres) if l & 1: lres = self.segfunc(lres, self.seg[l]) l += 1 l = l >> 1 r = r >> 1 res = self.segfunc(lres, rres) return res def __str__(self): arr = [self.query(i,i+1) for i in range(self.n)] return str(arr) n = int(input()) S = list(map(int, input().split())) C = list(map(int, input().split())) SA = list(set(S)) SA = sorted(SA) d = {} for i, s in enumerate(SA): d[s] = i S = [d[s] for s in S] L = [0]*n R = [0]*n INF = 10**18 N = len(d) seg = SegTree([INF]*(N+1), INF, min) seg.update(S[0], C[0]) for i in range(1, n-1): s = S[i] L[i] = seg.query(0, s) seg.update(s, C[i]) seg = SegTree([INF]*(N+1), INF, min) seg.update(S[-1], C[-1]) for i in reversed(range(1, n-1)): s = S[i] R[i] = seg.query(s+1, seg.n) seg.update(s, C[i]) ans = INF for i in range(1, n-1): ans = min(ans, L[i]+C[i]+R[i]) if ans >= INF: print(-1) else: print(ans)",quadratic,"['brute force', 'dp', 'implementation']",1511
"from collections import Counter import string import math import sys from fractions import Fraction def array_int(): return [int(i) for i in sys.stdin.readline().split()] def vary(arrber_of_variables): if arrber_of_variables==1: return int(sys.stdin.readline()) if arrber_of_variables>=2: return map(int,sys.stdin.readline().split()) def makedict(var): return dict(Counter(var)) testcases=1 for _ in range(testcases): n=vary(1) indices=array_int() cost=array_int() ans=float('inf') mint=[] for i in range(n): ans=float('inf') total=cost[i] flag=0 for j in range(i): if indices[i]>indices[j]: ans=min(ans,cost[j]) flag=1 if flag!=0: total+=ans ans=float('inf') flag=0 for k in range(i+1,n): if indices[k]>indices[i]: ans=min(ans,cost[k]) flag=1 if flag!=0: total+=ans mint.append(total) else: continue else: continue if len(mint)>0: print(min(mint)) else: print(-1)",quadratic,"['brute force', 'dp', 'implementation']",864
"import sys def get_ints(): return list(map(int, sys.stdin.readline().strip().split())) def solve(N, S, C): dp = [float('inf')] * N for i in range(1, N): for j in range(i): if S[j] < S[i]: dp[i] = min(dp[i], C[j] + C[i]) dp2 = [float('inf')] * N for i in range(N - 1, 0, -1): for j in range(i + 1, N, 1): if S[i] < S[j]: dp2[j] = min(dp2[j], dp[i] + C[j]) ans = min(dp2) if ans == float('inf'): return -1 return ans N = int(input()) S = get_ints() C = get_ints() print(solve(N, S, C))",quadratic,"['brute force', 'dp', 'implementation']",483
"I=lambda:list(map(int,input().split())) n,s,a=int(input()),I(),I() t=3*10**9 q=[0]*n for i in range(n-1,-1,-1): u=10**8 for j in range(i-1,-1,-1): if s[i]>s[j]:u=min(u,a[j]) q[i]=u for i in range(n): for j in range(i+1,n): if s[i]<s[j]:t=min(t,a[i]+a[j]+q[i]) print(t if t<=sum(a)else -1)",quadratic,"['brute force', 'dp', 'implementation']",288
"n=int(input()) s=list(map(int,input().split())) c=list(map(int,input().split())) dp=[float('inf')]*(n) for i in range(1,n): mn=float('inf') for j in range(i): if s[i]>s[j]: mn=min(mn,c[i]+c[j]) dp[i]=mn res=float('inf') for i in range(1,n): for j in range(i): if s[i]>s[j]: res=min(res,c[i]+dp[j]) if res==float('inf'): res=-1 print(res)",quadratic,"['brute force', 'dp', 'implementation']",337
"import bisect n=int(input()) s=list(map(int,input().split())) c=list(map(int,input().split())) ans=10**18 for mid in range(1,n-1): l1=[c[i] for i in range(mid) if s[i]<s[mid]]+[10**18] l2=[c[i] for i in range(mid+1,n) if s[i]>s[mid]]+[10**18] ans=min(ans,min(l1)+c[mid]+min(l2)) if ans>=10**18: print(-1) else: print(ans)",quadratic,"['brute force', 'dp', 'implementation']",321
"from math import inf n = int(input()) s_list = list(map(int, input().split())) c_list = list(map(int, input().split())) total_min = inf for j in range(n): min_i = inf for i in range(0, j): if s_list[i] < s_list[j]: min_i = min(min_i, c_list[i]) min_k = inf for k in range(j + 1, n): if s_list[k] > s_list[j]: min_k = min(min_k, c_list[k]) total_min = min(total_min, min_i + c_list[j] + min_k) if total_min != inf: print(total_min) else: print(-1)",quadratic,"['brute force', 'dp', 'implementation']",446
"from os import path import sys,time, collections as c , math , pprint as p , itertools as it , operator as op maxx , localsys , mod = float('inf'), 0 , int(1e9 + 7) if (path.exists('input.txt')): sys.stdin=open('input.txt','r') ; sys.stdout=open('output.txt','w') input = sys.stdin.readline n = int(input()) ; s = list(map(int , input().split())) ; c = list(map(int , input().split())) ans = maxx for mid in range(1 , n - 1): l = [maxx] + [c[i] for i in range(mid) if s[i] < s[mid]] r = [maxx] + [c[i] for i in range(mid+1 , n) if s[i] > s[mid]] ans = min(ans , min(l) + c[mid] + min(r)) print(ans if ans != float('inf') else -1)",quadratic,"['brute force', 'dp', 'implementation']",629
"n = int(input()) ls1 = [int(i) for i in input().split()] ls2 = [int(i) for i in input().split()] ans = float('inf') for i in range(1, n - 1): l = [ls2[j] for j in range(0, i) if ls1[j] < ls1[i]] r = [ls2[j] for j in range(i + 1, n) if ls1[j] > ls1[i]] if len(l) and len(r): ans = min(ans, min(l) + min(r) + ls2[i]) print([-1 , ans][ans != float('inf')])",quadratic,"['brute force', 'dp', 'implementation']",353
"n, a, b = map(int,input().split()) if a>1 and b>1: print(""NO""); exit() if 2<=n<=3 and a == b == 1: print(""NO""); exit() print(""YES"") if b == 1: adj = [[0]*n for i in range(n)] conn = n for i in range(n): if conn == a: break adj[i][i+1] = adj[i+1][i] = 1 conn-= 1 if conn == a: break elif a == 1: adj = [[1]*n for i in range(n)] conn = n for i in range(n): adj[i][i] = 0 for i in range(n): if conn == b: break adj[i][i+1] = adj[i+1][i] = 0 conn-= 1 if conn == b: break for row in adj: print(*row, sep='')",quadratic,"['constructive algorithms', 'graphs', 'implementation']",502
"def readline(): return map(int, input().split()) def main(): n, a, b = readline() if a > 1 and b > 1: print('NO') return if n in [2, 3] and a == 1 and b == 1: print('NO') return matrix = [[i in [j + 1, j -1] for i in range(n)] for j in range(n)] a, b = n + 1 - a, n + 1 - b if a != n: matrix = [[False for i in range(n)] for j in range(n)] for i in range(n): for j in range(n): if i < a and j < a and i != j: matrix[i][j] = True elif b != n: matrix = [[False for i in range(n)] for j in range(n)] for i in range(n): for j in range(n): if i >= b or j >= b: matrix[i][j] = True if i == j: matrix[i][j] = False print('YES') for row in matrix: print("""".join(map(lambda x: '1' if x else '0', row)), flush=False) if __name__ == '__main__': main()",quadratic,"['constructive algorithms', 'graphs', 'implementation']",740
"import collections from functools import cmp_to_key import sys def getIntList(): return list(map(int, input().split())) n,a,b = getIntList() a0 = a b0 = b if a0>b0: a0,b0 = b,a if n==2 and (a0,b0) == (1,1): print('NO') sys.exit() if n==3 and (a0,b0) == (1,1): print('NO') sys.exit() if a>1 and b>1: print('NO') sys.exit() mat = [['0' for y in range(n)]for x in range(n)] mat1 = [['1' for y in range(n)]for x in range(n)] if b==1: for x in range(n-a): mat[x][x+1] = '1' mat[x+1][x] = '1' else: mat = mat1 for x in range(n): mat[x][x] = '0' for x in range(n-b): mat[x][x+1] = '0' mat[x+1][x] = '0' print('YES') for x in range(n): print(''.join(mat[x]))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",650
"def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(mi()) n, a, b = mi() c = max(a, b) if a != 1 and b != 1: print('NO') elif n == 2 and c == 1: print('NO') elif n == 3 and c == 1: print('NO') else: if a == 1: g = [[1] * n for i in range(n)] for i in range(n): g[i][i] = 0 for i in range(c - 1, n - 1): g[i][i + 1] = g[i + 1][i] = 0 else: g = [[0] * n for i in range(n)] for i in range(c - 1, n - 1): g[i][i + 1] = g[i + 1][i] = 1 print('YES') for r in g: print(''.join(str(x) for x in r))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",532
"def get_sign_1(fo): def res(s, f=fo): if f**2+s**2 == 2*f*s+1: return '1' else: return '0' return res def get_signs_2(cf, rev): cf -= 1 if rev: def res(fo, cff=cf): if fo >= cff: def res2(s, f=fo): if s == f: return '0' elif s >= cff: return '0' else: return '1' else: def res2(s, f=fo): if s == f: return '0' else: return '1' return res2 else: def res(fo, cff=cf): if fo >= cff: def res2(s, f=fo): if s == f: return '0' elif s >= cff: return '1' else: return '0' else: def res2(s): return '0' return res2 return res n, a, b = map(int, input().split()) c = a*b if a+b == c+1 and (c > 1 or n == 1 or n > 3): print(""YES"") if c == 1: get_sign_f = get_sign_1 else: get_sign_f = get_signs_2(c, c == b) for foo in range(n): print(''.join(map(get_sign_f(foo), range(n)))) else: print(""NO"")",quadratic,"['constructive algorithms', 'graphs', 'implementation']",782
"n,a,b = list( map(int, input().split())) if min(a,b) >1: print('NO') exit() m = max(a,b) if m == 1: if n == 1: print('YES') print(0) exit() elif n < 4: print('NO') exit() else: print('YES') for row in range(n): line = ['0']*n if row >0: line[row-1] = '1' if row <n-1: line[row+1] = '1' print(''.join(line)) exit() print('YES') if a == 1: c = '1' d = '0' else: c = '0' d = '1' for row in range(n): if row < m-1: line = [c]*n else: line = [c]*(m-1)+ [d]*(n-m+1) line[row] = '0' print(''.join(line))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",496
"import sys n,a,b = map(int, sys.stdin.readline().strip().split(' ')) ans = [] g = {i:set({}) for i in range(n)} if a > 1 and b > 1: print(""NO"") elif a == 1 and b == 1: if n == 1: print(""YES"") print(""0"") elif n < 4: print(""NO"") else: for i in range(n-1): g[i].add(i+1) g[i+1].add(i) for i in range(n): tmp = [] for j in range(n): if i in g[j]: tmp.append('1') else: tmp.append('0') ans.append(''.join(tmp)) print(""YES"") print('\n'.join(ans)) else: swap = False if a == 1: a, b = b, a swap = True for i in range(a-1,n-1): g[i].add(i+1) g[i+1].add(i) if swap: for i in range(n): tmp = [] for j in range(n): if i == j: tmp.append('0') elif i not in g[j]: tmp.append('1') else: tmp.append('0') ans.append(''.join(tmp)) else: for i in range(n): tmp = [] for j in range(n): if i in g[j]: tmp.append('1') else: tmp.append('0') ans.append(''.join(tmp)) print(""YES"") print('\n'.join(ans))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",878
"def read(): return int(input()) def readlist(): return list(map(int, input().split())) def readmap(): return map(int, input().split()) N, A, B = readmap() if N == 1: print(""YES"") print(0) elif N == 2: if A == 1 and B == 2: print(""YES"") print(""01"") print(""10"") elif A == 2 and B == 1: print(""YES"") print(""00"") print(""00"") else: print(""NO"") elif N == 3: if A == 1 and B == 2: print(""YES"") print(""011"") print(""100"") print(""100"") elif A == 2 and B == 1: print(""YES"") print(""001"") print(""000"") print(""100"") elif A == 1 and B == 3: print(""YES"") print(""011"") print(""101"") print(""110"") elif A == 3 and B == 1: print(""YES"") print(""000"") print(""000"") print(""000"") else: print(""NO"") else: if A != 1 and B != 1: print(""NO"") else: print(""YES"") if B == 1 and A != 1: mat = [] for i in range(N): vec = [] if i == 0: for j in range(N): if j >= A: vec.append(1) else: vec.append(0) mat.append(vec) else: vec = [0] * N if i >= A: vec[0] = 1 mat.append(vec) for n in range(N): print("""".join(list(map(str, mat[n])))) elif A == 1 and B != 1: mat = [] for i in range(N): vec = [] if i == 0: for j in range(N): if j >= B: vec.append(0) else: vec.append(1) vec[i] = 0 mat.append(vec) else: vec = [1] * N if i >= B: vec[0] = 0 vec[i] = 0 mat.append(vec) for n in range(N): print("""".join(list(map(str, mat[n])))) else: mat = [] for i in range(N): vec = [] if i == 0: for j in range(N): if j >= 2: vec.append(1) else: vec.append(0) mat.append(vec) else: vec = [0] * N if i >= 2: vec[0] = 1 mat.append(vec) mat[1][2] = 1 mat[2][1] = 1 for n in range(N): print("""".join(list(map(str, mat[n]))))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",1564
"n, a, b = map(int, input().split()) if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1: print('NO') exit() print('YES') f = int(a == 1) g = [a, b][f] r = [[f] * n for i in range(n)] for i in range(n): r[i][i] = 0 for i in range(n - g): r[i][i + 1] ^= 1 r[i + 1][i] ^= 1 for x in r: print(*x, sep='')",quadratic,"['constructive algorithms', 'graphs', 'implementation']",297
"n, a, b = map(int, input().split()) if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1: print('NO') exit() print('YES') f = int(a == 1) g = [a, b][f] r = [[f] * n for i in range(n)] for i in range(n): r[i][i] = 0 for i in range(n - g): r[i][i + 1] ^= 1 r[i + 1][i] ^= 1 print('\n'.join(map(lambda x: ''.join(map(str, x)), r)))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",324
"import math; def getIntList(): return list(map(int, input().split())); def getTransIntList(n): first=getIntList(); m=len(first); result=[[0]*n for _ in range(m)]; for i in range(m): result[i][0]=first[i]; for j in range(1, n): curr=getIntList(); for i in range(m): result[i][j]=curr[i]; return result; n, a, b = getIntList(); if a>1 and b>1: print('NO'); elif a==b==1 and (n==2 or n==3): print('NO'); else: c=max(a, b); m=[[0]*n for _ in range(n)]; for i in range(n-c): m[i][i+1]=1; m[i+1][i]=1; if b>1: for i in range(n): for j in range(n): if i!=j: m[i][j]=1-m[i][j]; print('YES'); for i in range(n): print(''.join(map(str, m[i])));",quadratic,"['constructive algorithms', 'graphs', 'implementation']",634
"def i_ints(): return list(map(int, input().split())) n, a, b = i_ints() def calc(): if min(a, b) != 1: print(""NO"") return if a == b == 1 and n in (2, 3): print(""NO"") return print(""YES"") ONE, ZERO = ""10"" if a > 1 else ""01"" edges = n - max(a, b) line = ""0"" + (ZERO, ONE)[edges>0]*(n>1) + ZERO * (n-2) print(line) for y in range(1, n): line = ZERO * (y-1) + (ZERO, ONE)[y<=edges] + ""0"" if y < n-1: line += (ZERO, ONE)[y < edges] + ZERO * (n-y-2) print(line) calc()",quadratic,"['constructive algorithms', 'graphs', 'implementation']",461
"n, a, b = map(int, input().split()) if a > 1 < b or a * b == 1 and 1 < n < 4: print('NO') else: z, o = ('01', '10')[a < b] l = [[z] * n for _ in range(n)] for i in range(n): l[i][i] = '0' for i in range(n - a * b): l[i][i + 1] = l[i + 1][i] = o print('YES') print('\n'.join(map(''.join, l)))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",291
"n, a, b = map(int, input().split()) z, o = ('01', '10')[a < b] n *= not (a > 1 < b or 1 < n * a * b < 4) l = [[z] * n for _ in range(n)] for i in range(n): l[i][i] = '0' for i in range(n - a * b): l[i][i + 1] = l[i + 1][i] = o print(('YES', 'NO')[not n]) print('\n'.join(map(''.join, l)))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",288
"n, a, b = map(int, input().split()) if a != 1 and b != 1: print(""NO"") else: con_char = '1' discon_char = '0' if a == 1: con_char = '0' discon_char = '1' t = a a = b b = t if a > 1: print(""YES"") n_con = n - a + 1 for i in range(n): res = [] for j in range(n): if i == j: res.append('0') elif i < n_con and j < n_con: res.append(con_char) else: res.append(discon_char) print(''.join(res)) else: if n == 1 or n > 3: print(""YES"") for i in range(n): res = [] for j in range(n): if i == j: res.append('0') elif abs(i-j) == 1: res.append('1') else: res.append('0') print(''.join(res)) else: print(""NO"")",quadratic,"['constructive algorithms', 'graphs', 'implementation']",595
"import sys n,a,b = list(map(int, input().split())) if a>1 and b>1: print('NO') sys.exit(0) if n==3 and a==1 and b==1: print('NO') sys.exit(0) if n==2 and a==1 and b==1: print('NO') sys.exit(0) t = [[0 for i in range(n)] for j in range(n)] comp = max(a,b) for i in range(comp-1, n-1): t[i][i+1] = 1 t[i+1][i] = 1 if b>1: for i in range(n): for j in range(n): if i!=j: t[i][j] = 1-t[i][j] print('YES') for i in range(n): print("""".join(map(str, t[i])))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",449
"n, a, b = map(int, input().split()) if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))): print(""NO"") exit() res = [[0] * n for _ in range(n)] for i in range(0, n - max(a, b)): res[i][i + 1] = res[i + 1][i] = 1 if a == 1: res = [[e ^ 1 for e in l] for l in res] print(""YES"") for i in range(n): res[i][i] = 0 print(*res[i], sep='')",quadratic,"['constructive algorithms', 'graphs', 'implementation']",336
"n, a, b = map(int, input().split()) if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))): print(""NO"") exit() res = [[0] * n for _ in range(n)] for i in range(0, n - max(a, b)): res[i][i + 1] = res[i + 1][i] = 1 if a == 1: res = [[e ^ 1 for e in l] for l in res ] print(""YES"") for i in range(n): res[i][i] = 0 print(*res[i], sep='')",quadratic,"['constructive algorithms', 'graphs', 'implementation']",337
"from collections import defaultdict n,a,b = map(int,input().split()) hash = defaultdict(list) if a == 1 and b == 1: if n == 2 or n == 3: print('NO') exit() if a == 1 or b == 1: bool = [False]*(n+1) if a>n or b>n: print('NO') exit() print('YES') l = [] for i in range(n): z = ['0']*(n) l.append(z) ans = [] for i in range(n): z = ['0']*(n) ans.append(z) if b == 1: for i in range(a-1,n-1): l[i][i+1] = '1' l[i+1][i] = '1' for i in l: print(''.join(i)) else: ans = [] for i in range(n): z = ['0']*(n) ans.append(z) for i in range(b-1,n-1): l[i][i+1] = '1' l[i+1][i] = '1' for i in range(n): for j in range(n): if i!=j: if l[i][j] == '1': ans[i][j] = '0' if l[i][j] == '0': ans[i][j] = '1' for i in ans: print(''.join(i)) else: print('NO')",quadratic,"['constructive algorithms', 'graphs', 'implementation']",736
"n,a,b=map(int,input().split()) if a>n: print('NO') exit() if b>n: print(""NO"") exit() if a==1 and b==1: if n==2 or n==3: print('NO') exit() if n==1 and a>1 or n==1 and b>1: print('NO') exit() if min(a,b)>1: print('NO') exit() def check(mat): vis=[0]*n cnt=0 for i in range(n): if vis[i]==0: q=[i] cnt+=1 vis[i]=1 while q: t=q.pop(0) for j in range(n): if mat[t][j]==1 and vis[j]==0: vis[j]=1 q.append(j) return cnt mat=[[0 for i in range(n)] for j in range(n)] m=max(a,b) j=1 for i in range(n): if j<n: mat[i][j]=1 mat[j][i]=1 j+=1 for i in range(m-1): curr=n-i-1 for j in range(n): if mat[curr][j]==1: mat[curr][j]=0 mat[j][curr]=0 if b==1: print('YES') for i in range(n): print(*mat[i],sep='') else: print('YES') for i in range(n): for j in range(n): mat[i][j]=1-mat[i][j] for i in range(n): mat[i][i]=0 for i in range(n): print(*mat[i],sep='')",quadratic,"['constructive algorithms', 'graphs', 'implementation']",845
"n, a, b = map(int, input().split()) if (n == 3 or n == 2) and (a == 1 and b == 1): print(""NO"") exit(0) g = [[0 for i in range(n)] for j in range(n)] if a > 1 and b == 1: for i in range(n - a - 1, -1, -1): g[i][i + 1] = g[i + 1][i] = 1 elif b > 1 and a == 1: a, b = b, a for i in range(n - a - 1, -1, -1): g[i][i + 1] = g[i + 1][i] = 1 for i in range(n): for j in range(n): if g[i][j] == 0: g[i][j] = 1 elif g[i][j] == 1: g[i][j] = 0 for i in range(n): g[i][i] = 0 elif a == 1 and b == 1: for i in range(n - 1): g[i][i + 1] = g[i + 1][i] = 1 elif a > 1 and b > 1: print(""NO"") exit(0) print(""YES"") for i in range(n): for j in range(n): print(g[i][j], end='') print()",quadratic,"['constructive algorithms', 'graphs', 'implementation']",664
"n, a, b = map(int, input().split()) z, o = ('01', '10')[a < b] n *= not (a > 1 < b or 1 < n * a * b < 4) l = [[z] * n for _ in range(n)] for i in range(n): l[i][i] = '0' for i in range(n - a * b): l[i][i + 1] = l[i + 1][i] = o print(('YES', 'NO')[not n]) print('\n'.join(map(''.join, l)))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",288
"n, a, b = map(int, input().split()) if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1: print('NO') exit() print('YES') f = int(a == 1) g = [a, b][f] r = [[f] * n for i in range(n)] for i in range(n): r[i][i] = 0 for i in range(n - g): r[i][i + 1] ^= 1 r[i + 1][i] ^= 1 for x in r: print(*x, sep='')",quadratic,"['constructive algorithms', 'graphs', 'implementation']",297
"n, a, b = map(int, input().split()) if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1: print('NO') exit() print('YES') f = int(a == 1) g = [a, b][f] r = [[f] * n for i in range(n)] for i in range(n): r[i][i] = 0 for i in range(n - g): r[i][i + 1] ^= 1 r[i + 1][i] ^= 1 for x in r: print(*x, sep='') johnny=0",quadratic,"['constructive algorithms', 'graphs', 'implementation']",306
"n,a,b=list(map(int,input().split())) d=[] for i in range(n): d.append([""1""]*n) d[i][i]=""0"" if [n,a,b]==[2,1,1]: print(""NO"") elif [n,a,b]==[3,1,1]: print(""NO"") elif a==1: c=n-b for i in range(c): d[i][i+1]=""0"" d[i+1][i]=""0"" print(""YES"") for i in range(n): print("""".join(d[i])) elif a!=1 and b!=1: print(""NO"") else: print(""YES"") for i in range(a-1): for j in range(n): d[i][j]=""0"" for j in range(n): d[j][i]=""0"" for i in range(n): print("""".join(d[i]))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",449
"n, a, b = map(int, input().strip().split()) if min(a, b) > 1: print('NO') exit(0) M = [[0] * n for _ in range(n)] if a == 1 and b == 1: if n == 1: print('YES') print('0') exit(0) if n == 2 or n == 3: print('NO') exit(0) for i in range(1, n): M[i - 1][i] = 1 M[i][i - 1] = 1 else: s = n - max(a, b) + 1 for i in range(s): for j in range(s): if i != j: M[i][j] = 1 if a == 1: for i in range(n): for j in range(n): if i != j: M[i][j] = 1 - M[i][j] print('YES') for i in range(n): print(''.join(map(str, M[i])))",quadratic,"['constructive algorithms', 'graphs', 'implementation']",507
"n, m = list(map(int, input().split())) a = list(map(int, input().split())) b = list(map(int, input().split())) lst = [] for i in range(len(a)): if (a[i] in b): lst.append(a[i]) if (len(lst) == 0): pass else: print(*lst)",quadratic,['implementation'],219
"n,m=map(int,input().split()) x=list(map(int,input().split())) y=list(map(int,input().split())) l=list() for i in range(m): for j in range(n): if(y[i]==x[j]): l.append(j) print(' '.join(map(str,[x[i] for i in sorted(l)])))",quadratic,['implementation'],221
"n,m=map(int,input().split()) x=list(map(int,input().split())) y=list(map(int,input().split())) l=[] for i in range(m): if y[i] in x: l.append(x.index(y[i])) l.sort() for i in l: print(x[i],end="" "")",quadratic,['implementation'],197
"n,m=map(int,input().split()) list1=list(map(int,input().split())) list2=list(map(int,input().split())) for i in list1: if i in list2: print(i,end=' ')",quadratic,['implementation'],150
"n,m = map(int,input().split()) arr1 = list(map(int,input().split())) arr2 = list(map(int,input().split())) print(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))",quadratic,['implementation'],182
"n,m = map(int,input().split()) a = list(map(int,input().split())) b = list(map(int,input().split())) r = [] for i in a: if i in b: r.append(i) print(' '.join(map(str, r)))",quadratic,['implementation'],171
"import sys def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans mod = int(1e9) + 7 def ssinp(): return sys.stdin.readline().strip() def iinp(): return int(input()) def nninp(): return map(int, sys.stdin.readline().strip().split()) def llinp(): return list(map(int, sys.stdin.readline().strip().split())) def p(xyz): print(xyz) def p2(a, b): print(a, b) import math from collections import OrderedDict from fractions import Fraction n,m=nninp() x=llinp() y=llinp() for c in x: if(c in y): print(c,end="" "")",quadratic,['implementation'],1050
"import sys import math def input(): return sys.stdin.readline().strip() def iinput(): return int(input()) def minput(): return map(int, sys.stdin.readline().strip().split()) def listinput(): return list(map(int, sys.stdin.readline().strip().split())) n,m=minput() x=listinput() y=listinput() xx=set(x) yy=set(y) common=xx.intersection(yy) for i in x: if i in common: print(i,end=' ')",quadratic,['implementation'],383
"a,b=map(int,input().split()) c=list(map(int,input().split())) d=list(map(int,input().split())) e=[] for i in c: if i in d: e.append(i) for j in e: print(j,end="" "")",quadratic,['implementation'],163
"n , m=map(int,input().split()) l1=list(map(int,input().split())) l2=list(map(int,input().split())) l3=[] for i in range(n): for j in range(m): if l1[i]==l2[j]: if l1[i] is not l3: l3.append(l1[i]) print(*l3)",quadratic,['implementation'],207
"n,m=map(int,input().split()) seq=list(map(str,input().split())) fp=list(map(str,input().split())) checklist=[] for number in seq: if(number in fp): checklist.append(number) print("" "".join(checklist))",quadratic,['implementation'],199
"n,m = map(int,input().split()) arr1 = [int(i) for i in input().split()] arr2 = [int(i) for i in input().split()] for first in arr1: for second in arr2: if first == second: print(first,end="" "")",quadratic,['implementation'],192
"n,m=map(int,input().split()) x=list(map(int,input().split())) y=list(map(int,input().split())) out=[] first=11 for a in range(len(x)): for b in range(len(y)): if y[b]==x[a]: if first<a: first=a; out.append(y[b]) b+=1 else: out.insert(0,y[b]) b+=1 else: b+=1 out.reverse() for a in out: print(a)",quadratic,['implementation'],294
"n, m = map(int, input().split()) a = map(int, input().split()) b = list(map(int, input().split())) for x in a: if x in b: print(x, end=' ')",quadratic,['implementation'],139
"n,m=(int(x) for x in input().split()) sequence=input().split()[:n] fingerprint=input().split()[:m] print("" "".join(i for i in sequence if i in fingerprint))",quadratic,['implementation'],155
"n,m=map(int,input().split()) l1=list(map(int,input().split())) l2=list(map(int,input().split())) for i in l1: if i in l2: print(i,end="" "")",quadratic,['implementation'],138
"n,m=map(int,input().split()) seq=[int(i) for i in input().split()][:n] f=[int(i) for i in input().split()][:m] a=[] for i in range(n): for j in range(m): if(seq[i]==f[j]): a.append(seq[i]) for i in range(len(a)): print(a[i],end=' ')",quadratic,['implementation'],232
"n,k=[int(x) for x in input().split()] lst1=[int(x) for x in input().split()] lst2=[int(x) for x in input().split()] lst3={} ans=[] for i in lst2: if(i in lst1): lst3[i]=lst1.index(i) for i in sorted(lst3,key=lst3.get): ans.append(i) print(*ans,sep="" "")",quadratic,['implementation'],252
"from math import * from cmath import * from itertools import * from decimal import * from fractions import * from sys import * from types import CodeType, new_class n, m = map(int, (input().split())) a = [int(x) for x in input().split()] b = [int(x) for x in input().split()] for x in a: if x in b: print(x, end = ' ')",quadratic,['implementation'],318
"n, m = map(int, input().split()) a = [int(i) for i in input().split()] b = [int(i) for i in input().split()] for i in a: if i in b: print(i, end=' ')",quadratic,['implementation'],149
"n = int(input()) l = list(map(int,input().split())) i = 0 ans = 0 while i < len(l)-1: if l[i] == l[i+1]: i = i+1 continue j = i+1 ind = -1 while j < len(l): if l[j] == l[i]: ind = j break j = j+1 while ind > i+1: l[ind],l[ind-1] = l[ind-1],l[ind] ans += 1 ind -= 1 i += 1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",282
"n=int(input()) l=list(map(int,input().split())) ans=0 m=[] for i in range(2*n-1,-1,-1): if l[i] not in m: m.append(l[i]) for tt in range(0,n): i=m[tt] j=l.index(i) l.pop(j) k=l.index(i) l.insert(k,j) ans+=k-j print(ans)",quadratic,"['greedy', 'implementation', 'math']",219
n=int(input()) l=[int(x) for x in input().split()] ans=0; while len(l)>0: a=l[0] l=l[1:] ans+=l.index(a) l.remove(a) print(ans),quadratic,"['greedy', 'implementation', 'math']",127
"n = int(input()) a = list(map(int, input().split())) ans = 0 pos = 2*n - 2 for i in range(n): x = a[-1] a.pop(-1) y = a.index(x) ans += pos - y pos -= 2 a.pop(y) print(ans)",quadratic,"['greedy', 'implementation', 'math']",172
"n = int(input()) ar = [int(i) for i in input().split()] ans = 0 for i in range(2*n): for j in range(i+1,2*n): if ar[i]==ar[j]: while j!=i+1: ar[j],ar[j-1]=ar[j-1],ar[j] j-=1 ans+=1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",191
"n = int(input()) pairs = [int(i) for i in input().split("" "")] N=len(pairs) N//=2 visited = [False] * (N + 1) minimumSwaps = 0 for i in range(2 * N) : if (visited[pairs[i]] == False) : visited[pairs[i]] = True count = 0 for j in range( i + 1, 2 * N) : if (visited[pairs[j]] == False) : count += 1 elif (pairs[i] == pairs[j]) : minimumSwaps += count print(minimumSwaps)",quadratic,"['greedy', 'implementation', 'math']",367
"import os from io import BytesIO, IOBase import sys from collections import defaultdict, deque, Counter from math import sqrt, pi, ceil, log, inf, gcd, floor from itertools import combinations, permutations from bisect import * from fractions import Fraction from heapq import * from random import randint def main(): n=int(input()) a=list(map(int,input().split())) ans=0 for i in range(0,2*n,2): if a[i]!=a[i+1]: for j in range(i+1,2*n): if a[j]==a[i]: for k in range(j,i+1,-1): a[k],a[k-1]=a[k-1],a[k] ans+=1 break print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",quadratic,"['greedy', 'implementation', 'math']",1906
"import sys input = sys.stdin.readline n = int(input()) a = list(map(int, input().split())) swaps = 0 for i in range(0, 2*n, 2): if a[i] == a[i+1]: continue c = a[i] j = i + 2 while c != a[j]: j += 1 MIN = i+1 while j > MIN: a[j], a[j-1] = a[j-1], a[j] j -= 1 swaps += 1 print(swaps)",quadratic,"['greedy', 'implementation', 'math']",282
"n=2*int(input()) a=list(map(int,input().split())) z=0 for i in range(0,n-1,2): if a[i]!=a[i+1]: for j in range(i+1,n): if a[j]==a[i]: z+=j-i-1 a.pop(j) a.insert(i+1,a[i]) print(z)",quadratic,"['greedy', 'implementation', 'math']",179
"n=int(input()) arr=list(map(int,input().split()));ans=0 while len(arr)!=0: e=arr.pop(0) ans+=arr.index(e) arr.remove(e) print(ans)",quadratic,"['greedy', 'implementation', 'math']",130
"n=int(input()) a=list(map(int,input().split())) p=0 while p+1<len(a) and a[p]==a[p+1]: p+=2 c=0 while p<len(a): if p+1<len(a): i=a.index(a[p],p+1) c+=i-p-1 tmp=a.pop(i) a.insert(p,tmp) while p+1<len(a) and a[p]==a[p+1]: p+=2 print(c)",quadratic,"['greedy', 'implementation', 'math']",233
"n=int(input()) lst = list(map(int, input().strip().split(' '))) c=0 while(len(lst)!=0): p=lst[0] del lst[0] i=lst.index(p) c+=i del lst[i] print(c)",quadratic,"['greedy', 'implementation', 'math']",147
"n=int(input()) a=list(map(int,input().split())) ans=0 while len(a)>0: c=a.pop(0) i=a.index(c) ans+=i del a[i] print(ans)",quadratic,"['greedy', 'implementation', 'math']",120
"n = int(input()) xs = [int(x) for x in input().split()] seen = {} res = 0 while xs: j = xs.index(xs[0], 1) res += j - 1 xs = xs[1:j] + xs[j+1:] print(res)",quadratic,"['greedy', 'implementation', 'math']",154
"n = int(input()) t = list(map(int, input().split())) sw = 0 while t != []: pr = 1 + t[1:].index(t[0]) sw += pr-1 t = t[1:pr] + t[pr+1:] print(sw)",quadratic,"['greedy', 'implementation', 'math']",145
"import sys input=sys.stdin.readline n=int(input()) c=list(map(int,input().split())) ans=0 for i in range(n): f=c.pop(0) g=c.index(f) c.pop(g) ans+=g print(ans)",quadratic,"['greedy', 'implementation', 'math']",159
"n = int(input()) l = [-1] * n r = [-1] * n a = list(map(int, input().split())) for i in range(2 * n): x = a[i] - 1 if l[x] == -1: l[x] = i r[x] = i ans = 0 for i in range(n): for j in range(n): if l[i] < l[j] < r[j] < r[i]: ans += 2 for i in range(n): ans += r[i] - l[i] - 1 print(ans // 2)",quadratic,"['greedy', 'implementation', 'math']",290
"def main(): n = int(input()) a = list(map(int, input().split())) r = 0 while a: c = a[0] del a[0] for i in range(len(a)): if c == a[i]: break del a[i] r += i print(r) if __name__ == ""__main__"": main()",quadratic,"['greedy', 'implementation', 'math']",200
"def mp():return map(int,input().split()) def it():return int(input()) n,k=mp() l=list(mp()) ans=0 for i in range(n): avg,count=0,0 for j in range(i,n): count+=l[j] if j-i+1>=k: avg=count/(j-i+1) ans=max(avg,ans) print(ans)",quadratic,"['brute force', 'implementation', 'math']",222
"def helper(n,k,l): res = 0 for i in range(n-k+1): base_seg = l[i:i+k] sm_bseg = sum(base_seg) ln_bseg = len(base_seg) ans = sm_bseg/ln_bseg for j in range(i+k,n): sm_bseg+=l[j] ln_bseg+=1 ans=max(ans,sm_bseg/ln_bseg) res = max(res,ans) return res n,k = map(int,input().split()) l = list(map(int,input().split())) print(helper(n,k,l))",quadratic,"['brute force', 'implementation', 'math']",333
"import sys import math import collections def get_ints(): return map(int, sys.stdin.readline().strip().split()) def get_list(): return list(map(int, sys.stdin.readline().strip().split())) def get_string(): return sys.stdin.readline().strip() for t in range(1): n,k=get_ints() arr=get_list() ans=0 for i in range(n): val=arr[i] c=1 sol=0 if c >= k: sol = max(sol, val / c) for j in range(i+1,n): val+=arr[j] c+=1 if c>=k: sol=max(sol,val/c) ans=max(sol,ans) print(ans)",quadratic,"['brute force', 'implementation', 'math']",467
"def main(): n,k=map(int,input().split( )) a=list(map(int,input().split( ))) ans=-1*10**9+7 for i in range(n): s=0 for j in range(i,n): s+=a[j] if j-i+1>=k: ans=max(ans,s/(j-i+1)) print(ans) main()",quadratic,"['brute force', 'implementation', 'math']",196
"import math for _ in range(1): n,k=map(int,input().split()) l=list(map(int,input().split())) ans=0 for i in range(n): c=0 sum1=0 for j in range(i, n): sum1 += l[j] c+=1 if c >= k: ans=max(ans,sum1/c) print(ans)",quadratic,"['brute force', 'implementation', 'math']",210
"from collections import Counter import string import math import sys from fractions import Fraction def array_int(): return [int(i) for i in sys.stdin.readline().split()] def vary(arrber_of_variables): if arrber_of_variables==1: return int(sys.stdin.readline()) if arrber_of_variables>=2: return map(int,sys.stdin.readline().split()) def makedict(var): return dict(Counter(var)) testcases=1 for _ in range(testcases): n,k=vary(2) num=array_int() maxi=0.0 for i in range(n): count=1 sumt=num[i] for j in range(i+1,n): sumt+=num[j] count+=1 if count>=k: maxi=max(maxi,sumt/count) if k==1: print(max(maxi,max(num))) else: print(maxi)",quadratic,"['brute force', 'implementation', 'math']",630
"import sys, heapq n, k = map(int, sys.stdin.readline().split()) arr = list(map(int, sys.stdin.readline().split())) pf = [0] * (n + 1) pf[0] = arr[0] for i in range(1, n): pf[i] = pf[i - 1] + arr[i] ans = 0 for i in range(n): for j in range(n): left = i right = j if right - left + 1 >= k: temp = pf[right] - pf[left - 1] ans = max(ans, temp / (right - left + 1)) print(ans)",quadratic,"['brute force', 'implementation', 'math']",373
"import os import sys from collections import * from bisect import * from io import BytesIO, IOBase def vsInput(): sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") ALPHA='abcdefghijklmnopqrstuvwxyz' M= 998244353 EPS=1e-6 def Ceil(a,b): return a//b+int(a%b>0) def value():return tuple(map(int,input().split())) def array():return [int(i) for i in input().split()] def Int():return int(input()) def Str():return input() def arrayS():return [i for i in input().split()] n,k = value() a = array() ans = 0 for i in range(n-k+1): num = sum(a[i:i+k]) den = k ans = max(ans , num/den) for j in range(i+k,n): num += a[j] den += 1 ans = max(a",quadratic,"['brute force', 'implementation', 'math']",1999
"import sys input = sys.stdin.buffer.readline n,k=map(int,input().split()) arr=[int(x) for x in input().split()] x=0 dp=[] for i in range(n): x=x+arr[i] dp.append(x) ans=0 for i in range(n): for j in range(i+k-1,n): ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1)) print(ans)",quadratic,"['brute force', 'implementation', 'math']",269
"n, k = map(int, input().split()) li = [int(num) for num in input().split("" "", n - 1)] ans = [] for i in range(0, n): su = 0 for j in range(i, n): su += li[j] if (j - i + 1 >= k): ans.append(su / (j - i + 1)) print(max(ans))",quadratic,"['brute force', 'implementation', 'math']",223
"from sys import * n, k = map(int, stdin.readline().split()) arr = list(map(int, stdin.readline().split())) avg = 0 for i in range(n): cnt = 0 sum = 0 for j in range(i, n): sum += arr[j] cnt += 1 if cnt >= k: avg = max(avg, sum / cnt) print(avg)",quadratic,"['brute force', 'implementation', 'math']",244
"import sys input = sys.stdin.buffer.readline n,k=map(int,input().split()) arr=[int(x) for x in input().split()] x=0 dp=[] for i in range(n): x=x+arr[i] dp.append(x) ans=0 for i in range(n): for j in range(i+k-1,n): ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1)) print(ans)",quadratic,"['brute force', 'implementation', 'math']",269
"n, k = map(int, input().split()) arr = list(map(int, input().split())) rsum = [0] maxx = 0.0 for i in range(n): rsum.append(rsum[-1] + arr[i]) for ki in range(k, n+1): for i in range(n-ki+1): tot = 0 avg = (rsum[i+ki] - rsum[i])/ki maxx = max(maxx, avg) print(maxx)",quadratic,"['brute force', 'implementation', 'math']",265
"n,m=map(int,input().split()) lst=list(map(int,input().split())) maxx=0 arr=[0]*(n+1) for i in range(n): summ=0 for j in range(i,n): summ+=lst[j] arr[j-i]=max(arr[j-i], summ/(j-i+1)) print(max(arr[m-1:]))",quadratic,"['brute force', 'implementation', 'math']",203
"rd = lambda: list(map(int, input().split())) n, k = rd() a = rd() r = 0 s = [0] for x in a: s.append(s[-1] + x) for i in range(n - k + 1): for j in range(i + k, min(n + 1, i + 2 * k)): r = max(r, (s[j] - s[i]) / (j - i)) print(r)",quadratic,"['brute force', 'implementation', 'math']",229
"import sys input = sys.stdin.buffer.readline from collections import deque n,d,k=map(int,input().split()) if d>=n: print(""NO"") exit() graph=[[] for i in range(n+1)] for i in range(1,d+2): graph[i].append(min(i-1,d+1-i)) for i in range(1,d+1): graph[i].append(i+1) graph[i+1].append(i) deg=[0]*(n+1) deg[1]=1 deg[d+1]=1 for i in range(2,d+1): deg[i]=2 for i in deg: if i>k: print(""NO"") exit() p=d+2 for i in range(1,d+2): q=deque() q.append(i) while len(q)!=0: x=q.popleft() while (graph[x][0]>0 and deg[x]<k and p<=n): graph[x].append(p) deg[x]=deg[x]+1 graph[p].append(graph[x][0]-1) graph[p].append(x) deg[p]=deg[p]+1 q.append(p) p=p+1 if p<=n: print(""NO"") else: print(""YES"") vis=[-1]*(n+1) for i in range(1,d+2): if vis[i]==-1: q=deque() q.append(i) while len(q)!=0: x=q.popleft() vis[x]=1 for j in range(1,len(graph[x])): if vis[graph[x][j]]==-1: print(x,graph[x][j]) q.append(graph[x][j])",quadratic,"['constructive algorithms', 'graphs']",893
"import sys def pprint(s): sys.stdout.write(str(s) + ""\n"") def solve(n, d, k): for i in range(1, d+1): pprint(str(i) + ' ' + str(i+1)) if i + 1 == n: exit() q = d+2 for i in range(2, d+1): for j in range(k-2): pprint(str(i) + ' ' + str(q)) if q == n: exit() q += 1 def rec(depth, current, head): if depth == 0: return current for i in range(k-1): pprint(str(head) + ' ' + str(current)) if current == n: exit() current += 1 current = rec(depth-1, current, current-1) return current if i <= (d+2)/2: depth = i-2 else: depth = d-i q = rec(depth, q, q-1) n, d, k = map(int, input().split()) q = k-1 maxi = 0 if k == 2: maxi = d+1 else: if d % 2: maxi = (q * (1-q**(d//2)) // (1-q) + 1) * 2 else: maxi = (q * (1-q**(d//2-1)) // (1-q) + 1) * 3 + 1 if d == 2: maxi = k + 1 if n > maxi or n <= d: print(""NO"") else: print(""YES"") solve(n, d, k)",quadratic,"['constructive algorithms', 'graphs']",833
"import sys input = sys.stdin.readline def main(): a = input().split("" "") n = int(a[0]) d = int(a[1]) k = int(a[2]) if d > n - 1: sys.stdout.write(""NO\n"") return par = [-1 for i in range(n)] prevlevel = [0] bad = [False for i in range(n)] clevel = [] cdep = 1 callow = k cnode = 1 firstchild = 1 for i in range(1, n): if len(clevel) == callow: prevlevel = clevel clevel = [] cdep += 1 callow *= (k - 1) firstchild *= (k - 1) cdiv = k if cdep > 1: cdiv -= 1 if cdiv == 0: sys.stdout.write(""NO\n"") return par[cnode] = prevlevel[len(clevel) // cdiv] clevel.append(cnode) cnode += 1 mdep = d // 2 if cdep > mdep + 1: sys.stdout.write(""NO\n"") return if cdep == mdep + 1 and ((d % 2 == 0)): sys.stdout.write(""NO\n"") return if cdep == mdep + 1 and len(clevel) > firstchild: sys.stdout.write(""NO\n"") return attach1 = -1 attach2 = -1 d1 = cdep d2 = cdep attach1 = clevel[0] if len(clevel) > firstchild: attach2 = clevel[-1] else: attach2 = prevlevel[-1] d2 -= 1 te = attach1 while te != -1: bad[te] = True te = par[te] te = attach2 while te != -1: bad[te] = True te = par[te] cptr = n - 1 while d1 + d2 < d: if bad[cptr]: cptr -= 1 continue if d2 < d1: par[cptr] = attach2 attach2 = cptr d2 += 1 else: par[cptr] = attach1 attach1 = cptr d1 += 1 cptr -= 1 sys.stdout.write(""YES\n"") for i in range(1, n): sys.stdout.write(str(i + 1) + "" "" + str(par[i] + 1) + ""\n"") main()",quadratic,"['constructive algorithms', 'graphs']",1359
"import heapq import sys input = sys.stdin.readline n, d, k = map(int, input().split()) if n == 1 or n <= d: ans = ""NO"" elif k == 1: ans = ""YES"" if n == 2 and d == 1 else ""NO"" e = [(1, 2)] else: e = [(i + 1, i + 2) for i in range(d)] h = [] l, r = 1, d + 1 if k > 2: for i in range(2, d + 1): heapq.heappush(h, (i, 2, min(i - l, r - i))) ans = ""YES"" for i in range(d + 2, n + 1): if not h: ans = ""NO"" break j, k0, d0 = heapq.heappop(h) e.append((j, i)) if k0 + 1 < k: heapq.heappush(h, (j, k0 + 1, d0)) if d0 - 1 > 0: heapq.heappush(h, (i, 1, d0 - 1)) print(ans) if ans == ""YES"": for u, v in e: print(u, v)",quadratic,"['constructive algorithms', 'graphs']",605
"from collections import deque import sys input = sys.stdin.readline n, d, k = map(int, input().split()) if n == 1 or n <= d: ans = ""NO"" elif k == 1: ans = ""YES"" if n == 2 and d == 1 else ""NO"" e = [(1, 2)] else: e = [(i + 1, i + 2) for i in range(d)] q = deque() l, r = 1, d + 1 if k > 2: for i in range(2, d + 1): q.append((i, 2, min(i - l, r - i))) ans = ""YES"" for i in range(d + 2, n + 1): if not q: ans = ""NO"" break j, k0, d0 = q.popleft() e.append((j, i)) if k0 + 1 < k: q.append((j, k0 + 1, d0)) if d0 - 1 > 0: q.append((i, 1, d0 - 1)) print(ans) if ans == ""YES"": for u, v in e: print(u, v)",quadratic,"['constructive algorithms', 'graphs']",595
"def main(): n, d, k = list(map(int, input().split())) if n == 2 and d == 1 and k == 1: print(""YES"") print(""1 2"") return 0 if n == d + 1 and k - 1: print(""YES"") for i in range(1, d + 1): print(i, i + 1) return 0 if n < d +1 or k <= 2 or d == 1: print(""NO"") return 0 if d % 2 == 0: if n * (k - 2) > -2 + k * (k - 1) ** (d // 2): print(""NO"") return 0 print(""YES"") for i in range(1, d + 1): print(i, i + 1) nodes = d + 1 leaves = [1 + d // 2] dev = 0 while True: new_leaves = [] for i in leaves: for j in range(k - 1 - (i <= d + 1)): nodes += 1 print(i, nodes) new_leaves.append(nodes) if nodes == n: return 0 dev += 1 leaves = new_leaves + [1 - dev + d // 2, 1 + dev + d // 2] else: if n * (k - 2) > -2 + k * (k - 1) ** (d // 2) + (k - 2) * (k - 1) ** (d // 2): print(""NO"") return 0 print(""YES"") for i in range(1, d + 1): print(i, i + 1) nodes = d + 1 leaves = [1 + d // 2, 2 + d // 2] dev = 0 while True: new_leaves = [] for i in leaves: for j in range(k - 1 - (i <= d + 1)): nodes += 1 print(i, nodes) new_leaves.append(nodes) if nodes == n: return 0 dev += 1 leaves = new_leaves + [1 - dev + d // 2, 2 + dev + d // 2] main()",quadratic,"['constructive algorithms', 'graphs']",1124
"def main(): n, d, k = map(int, input().split()) if n < d+1 or d > 1 and k == 1: print('NO') return edges = [(1, 2)] stack = [] d2 = d/2 d21 = d2+1 for node in range(2, d+1): edges.append((node, node+1)) stack.append([node, d2-abs(d21 - node), k-2]) next_i = d+2 while next_i <= n: if not stack: print('NO') return node = stack[-1] i, remaining_depth, remaining_degree = node if remaining_depth == 0 or remaining_degree == 0: stack.pop() continue node[2] -= 1 edges.append((i, next_i)) stack.append([next_i, remaining_depth-1, k-1]) next_i += 1 print('YES') print('\n'.join('{} {}'.format(a, b) for a, b in edges)) main()",quadratic,"['constructive algorithms', 'graphs']",620
"import sys n,d,k=map(int,input().split()) if(n<=d): print('NO') sys.exit() if(k==1 and n>2): print('NO') sys.exit() edgestot=[] edges=[[] for i in range(n)] tovisit=[] for i in range(d): edgestot.append([i,i+1]) tovisit.append([i+1,min(i+1,d-i-1)]) edges[i].append(i+1) edges[i+1].append(i) cur=d+1 while(cur<n and len(tovisit)>0): x=tovisit.pop() if(x[1]==0): continue while(len(edges[x[0]])<k and cur<n): tovisit.append([cur,x[1]-1]) edgestot.append([cur,x[0]]) edges[x[0]].append(cur) edges[cur].append(x[0]) cur+=1 if(len(edgestot)==n-1): print('YES') for i in range(n-1): print(edgestot[i][0]+1,edgestot[i][1]+1) else: print('NO')",quadratic,"['constructive algorithms', 'graphs']",635
"n,d,k = [int(x) for x in input().strip().split(' ')] l = [] i = 1 if n<=d: print(""NO"") elif k==1: if n>2: print(""NO"") elif n==2: print(""YES"") print(1,2) else: n+=1 flag = False while i<min(d+1,n): l.append(str(i)+"" ""+str(i+1)) i+=1 i+=1 cnt1=0 cnt2=1 se=[[2,d+1,1]] while cnt1<cnt2: start = se[cnt1][0] end = se[cnt1][1] mode = se[cnt1][2] kk = 3 while (i<n) and (kk<=k): if i<n and not flag: j = start while i<n and j<end: if mode==1: c = min(j-start+1,end-j) else: c = min(end-j,d-end+j) if c>1: se.append([i,i+c-1,2]) cnt2+=1 ki=j while i<n and c>0: l.append(str(ki)+"" ""+str(i)) c-=1 ki=i i+=1 j+=1 else: flag = True break kk+=1 cnt1+=1 if i<n or flag: print(""NO"") else: print(""YES"") print('\n'.join(l))",quadratic,"['constructive algorithms', 'graphs']",706
"n, d, k = map(int, input().split()) num = d+2 def solve(): global num if n == 1: return 'NO' if n == 2: if d != 1: return 'NO' else: return ""YES\n1 2"" if k < 2: return 'NO' if d > n-1: return 'NO' depth = [min(i, d-i) for i in range(d+1)] ans = [(i+1, i+2) for i in range(d)] def dfs(v, depth): global num if depth == 0: return for i in range(k-1): if len(ans) == n-1: return v2 = num num += 1 ans.append((v, v2)) dfs(v2, depth-1) for v in range(d+1): if depth[v] == 0: continue for i in range(k-2): if len(ans) == n-1: break v2 = num num += 1 ans.append((v+1, v2)) if depth[v] > 1: dfs(v2, depth[v]-1) if len(ans) < n-1: return ""NO"" return ""YES\n%s""%""\n"".join([""%d %d""%i for i in ans]) print(solve())",quadratic,"['constructive algorithms', 'graphs']",701
"from sys import exit def bad(): print(""NO"") exit() node = 1 def make_branch(u, d, deg, g, n, k): global node while deg[u] < k and d > 0 and node < n: node += 1 deg[u] += 1 deg[node] = 1 g[u].append(node) make_branch(node, d - 1, deg, g, n, k) def main(): global node n, d, k = map(int, input().split()) if d >= n or (k == 1 and n > 2): bad() g = [[] for _ in range(n + 5)] deg = [0 for _ in range(n + 5)] for i in range(1, d + 1): g[i].append(i + 1) deg[i] += 1 deg[i + 1] += 1 node = d + 1 LD = 1 RD = d - 1 for u in range(2, d + 1): make_branch(u, min(LD, RD), deg, g, n, k) LD += 1 RD -= 1 used = [False for _ in range(n + 5)] q = [[1, 1]] used[1] = True while len(q) > 0: u, p = q.pop() for v in g[u]: if v != p: used[v] = True q.append([v, u]) for i in range(1, n + 1): if used[i] == False: bad() print(""YES"") for u in range(1, n + 1): for v in g[u]: print(u, v) main()",quadratic,"['constructive algorithms', 'graphs']",874
"def main(): n, d, k = map(int, input().split()) r, odd = divmod(d, 2) k -= 1 cap = d + 1 if k == 1 else 1 if k > 1: cap = 2 * (k ** (r + 1) - 1) // (k - 1) if odd else 1 + (k + 1) * (k ** r - 1) // (k - 1) if n == 1 or k < 1 < n - 1 or k == 1 and d != n - 1 or d >= n or k > 1 and not d < n <= cap: print('NO') return def dfs(parent, depth): stack = [] for _ in range(k - 1): child = rest.pop() res.append('%s %s' % (parent, child)) if depth: stack.append((child, depth)) while stack: parent, depth = stack.pop() depth -= 1 for _ in range(k): child = rest.pop() res.append('%s %s' % (parent, child)) if depth: stack.append((child, depth)) res = ['YES'] for pc in enumerate(range(2, d + 2), 1): res.append('%d %d' % pc) rest = list(range(n, d + 1, -1)) try: for p in range(r + 1, r + odd + 2): dfs(p, r - 1) for de, p, q in zip(range(r - 2, -1, -1), range(r, 1, -1), range(r + odd + 2, d + 1)): dfs(p, de) dfs(q, de) except IndexError: pass print('\n'.join(res)) if __name__ == '__main__': main()",quadratic,"['constructive algorithms', 'graphs']",995
"def main(): n, d, k = map(int, input().split()) _min = d+1 if n < _min: print('NO') else: res = [] deg = [0] * (n+1) dist = [0] * (n+1) stack = [] deg[1] = 1 for i in range(1, d+1): res.append((i, i+1)) if i > 1: deg[i] += 2 dist[i] = max(i-1, d+1-i) dist[d+1] = d deg[d+1] = 1 for i in range(2, d+1): stack.append(i) next = d+2 while stack: if next > n: break v = stack.pop() if dist[v] < d: while next <= n and deg[v] < k: res.append((v, next)) deg[v] += 1 deg[next] += 1 dist[next] = dist[v] + 1 if dist[next] < d: stack.append(next) next += 1 ok = next > n ok &= all(deg[i] <= k for i in range(1, n+1)) ok &= all(dist[i] <= d for i in range(1, n+1)) if not ok: print('NO') else: print('YES') for e in res: print(*e) if __name__ == '__main__': main()",quadratic,"['constructive algorithms', 'graphs']",753
"n,d,k=map(int,input().split()) if n==1: print(""NO"") exit() if k==1: if n==2 and d==1: print(""YES"") print(1,2) else: print(""NO"") exit() if n<d+1: print(""NO"") exit() co=1 ans=[] for i in range(1,d+1): ans.append((i,i+1)) co+=1 def dfs(r,dist,co): if 2<=r<=d: t=k-2 else: t=k-1 if co==n: return co for _ in range(t): if dist==d: return co if co==n: return co co+=1 ans.append((r,co)) co=dfs(co,dist+1,co) return co for i in range(2,d+1): co=dfs(i,max(i-1,d-i+1),co) if co==n: print(""YES"") for j in ans: print(*j) else: print(""NO"")",quadratic,"['constructive algorithms', 'graphs']",527
"from collections import deque n, d, k = map(int, input().split()) if n==1: print('NO') exit(0) if n==2: if d>1: print('NO') else: print('YES') print(1, 2) exit(0) if (not 2<=d<=n-1) or k==1: print('NO') exit(0) ans = [] for i in range(d): ans.append((i+1, i+2)) now = d+2 for i in range(d-1): q = deque([(i+2, min(i, d-i-2))]) first = True while q and len(ans)<n-1: node, depth = q.popleft() end = now+k-1 if first: end -= 1 for j in range(now, end): ans.append((node, j)) if len(ans)==n-1: break if depth>0: q.append((j, depth-1)) now = end first = False if len(ans)==n-1: print('YES') for i, j in ans: print(i, j) else: print('NO')",quadratic,"['constructive algorithms', 'graphs']",633
"n, d, k = map(int, input().split()) if d+1 > n: print('NO') exit() ans = [] dist = [0]*n deg = [0]*n for i in range(d+1): if i == 0 or i == d: deg[i] = 1 else: deg[i] = 2 if i != d: ans.append((i+1, i+2)) dist[i] = max(i, d-i) for i in range(n): if deg[i] > k: print('NO') exit() from collections import deque q = deque(list(range(d+1))) cur = d+1 while q and cur < n: v = q.popleft() if dist[v] < d and deg[v] < k: deg[v] += 1 dist[cur] = dist[v]+1 deg[cur] = 1 ans.append((v+1, cur+1)) q.append(v) q.append(cur) cur += 1 else: continue if cur != n: print('NO') else: print('YES') for i in range(len(ans)): print(*ans[i])",quadratic,"['constructive algorithms', 'graphs']",622
"n, d, k = map(int, input().split()) if d+1 > n: print('NO') exit() ans = [] dist = [0]*n deg = [0]*n for i in range(d+1): if i == 0 or i == d: deg[i] = 1 else: deg[i] = 2 if i != d: ans.append((i+1, i+2)) dist[i] = max(i, d-i) for i in range(n): if deg[i] > k: print('NO') exit() from collections import deque q = deque(list(range(d+1))) cur = d+1 while q and cur < n: v = q.pop() if dist[v] < d and deg[v] < k: deg[v] += 1 dist[cur] = dist[v]+1 deg[cur] = 1 ans.append((v+1, cur+1)) q.append(v) q.append(cur) cur += 1 else: continue if cur != n: print('NO') else: print('YES') for i in range(len(ans)): print(*ans[i])",quadratic,"['constructive algorithms', 'graphs']",618
"def construct_tree(n,d, k): nodes = [] edges = [] if d > n - 1: return None if k == 1 and n > 2: return None for i in range(1, d+2): current_deg = k - 1 if i == 1 or i == d + 1 else k - 2 current_depth = min(i-1, d-i+1) if current_depth and current_deg: nodes.append([i, min(i-1, d-i+1), current_deg]) if i < d + 1: edges.append([i, i+1]) current_nodes_count = d + 2 pos = 0 while current_nodes_count < n + 1: if pos >= len(nodes): return None current = nodes[pos] if not current[2]: pos += 1 if pos == len(nodes): break continue if current[1] - 1 and k - 1: nodes.append([current_nodes_count, current[1] - 1, k - 1]) edges.append([current[0], current_nodes_count]) current[2] -= 1 current_nodes_count += 1 if current_nodes_count == n + 1: return edges return None n, d, k = [int(val) for val in input().split()] edges = construct_tree(n, d, k) if edges: print('YES') print('\n'.join(['{0} {1}'.format(e[0], e[1]) for e in edges])) else: print('NO')",quadratic,"['constructive algorithms', 'graphs']",949
"import sys import math import collections import bisect import string def get_ints(): return map(int, sys.stdin.readline().strip().split()) def get_list(): return list(map(int, sys.stdin.readline().strip().split())) def get_string(): return sys.stdin.readline().strip() for t in range(1): n=int(input()) s1=list(get_string()) s2=list(get_string()) count=0 ans=[] lower=string.ascii_lowercase np=0 for i in lower: if s1.count(i)!=s2.count(i): np+=1 break if np>0: print(-1) continue pos=dict() for i in range(n): if s1[i] in pos: pos[s1[i]].append(i) else: pos[s1[i]]=[i] for i in range(n): if s1[i]==s2[i]: continue else: row=pos[s2[i]] no=0 for j in range(len(row)): if row[j]>i: no=row[j] break for j in range(no,i,-1): ans.append(j) s1.pop(no) s1.insert(i,s2[i]) pos = dict() for j in range(n): if s1[j] in pos: pos[s1[j]].append(j) else: pos[s1[j]] = [j] print(len(ans)) print(*ans)",quadratic,['implementation'],886
"import sys, string def swap(i, j): temp = a[i] a[i] = a[j] a[j] = temp n = int(sys.stdin.readline()) a = list(sys.stdin.readline().rstrip()) b = list(sys.stdin.readline().rstrip()) res_a = dict().fromkeys(list(string.ascii_lowercase), 0) res_b = dict().fromkeys(list(string.ascii_lowercase), 0) for i in a: res_a[i] += 1 for i in b: res_b[i] += 1 can = True for i in res_a: if res_a[i] != res_b[i]: can = False break if not can: print(-1) else: ans = [] for i in range(n): if a[i] == b[i]: continue else: idx = -1 for j in range(i + 1, n): if a[j] == b[i]: idx = j break for j in range(idx, i, -1): ans.append(j) swap(j, j - 1) print(len(ans)) print(' '.join(map(str, ans)))",quadratic,['implementation'],674
"import sys import math from collections import defaultdict,deque input = sys.stdin.readline def inar(): return [int(el) for el in input().split()] def main(): n=int(input()) s=list(input().strip()) t=list(input().strip()) res=True ans=[] for i in range(n): if s[i]==t[i]: continue else: ind=-1 for j in range(i+1,n): if t[i]==s[j]: ind=j break if ind==-1: res=False break for j in range(ind-1,i-1,-1): ans.append(j+1) s[j],s[j+1]=s[j+1],s[j] if res: print(len(ans)) print(*ans) else: print(-1) if __name__ == '__main__': main()",quadratic,['implementation'],527
"n = int(input()) s = list(str(input())) t = list(str(input())) from collections import Counter cs = Counter(s) ct = Counter(t) if cs != ct: print(-1) exit() xs = [[] for _ in range(26)] xt = [[] for _ in range(26)] for i in range(n): j = ord(s[i])-ord('a') xs[j].append(i) for i in range(n): j = ord(t[i])-ord('a') xt[j].append(i) x = [-1]*n for i in range(26): for j, k in zip(xs[i], xt[i]): x[j] = k ans = [] for i in range(n): for j in reversed(range(i+1, n)): if x[j-1] > x[j]: x[j-1], x[j] = x[j], x[j-1] ans.append(j) print(len(ans)) print(*ans)",quadratic,['implementation'],551
"n = int(input()) s = input() t = input() sl = [i for i in s] tl = [i for i in t] ans = [] if(''.join(sorted(s))!=''.join(sorted(t))): print(-1) else: for i in range(n): if(sl[i]!=tl[i]): for j in range(i+1,n): if(sl[j]==tl[i]): break for k in range(j-1,i-1,-1): sl[k],sl[k+1] = sl[k+1],sl[k] ans.append(k+1) print(len(ans)) for i in ans: print(i,end=' ')",quadratic,['implementation'],354
"n = int(input()) s = list(input()) t = input() if sorted(s) != sorted(t): print(-1) else: lst = [0] * n for i in range(n): for j in range(n): if s[j] == t[i]: lst[j] = i + 1 s[j] = ""."" break ans = 0 a = [] for i in range(n): for j in range(n - 1): if i != j: if lst[j] > lst[j + 1]: ans += 1 lst[j], lst[j + 1] = lst[j + 1], lst[j] a.append(j+1) print(ans) print(*a)",quadratic,['implementation'],366
"n = int(input()) s = list(input()) d = list(input()) if(sorted(s) != sorted(d)): print(-1) else: ans = [] for i in range(n): if(s[i] != d[i]): for u in range(i+1,n): if(s[u] == d[i]): ind = u break else:ind = -1 if(ind == -1):print(-1);exit() cnt = abs(ind - i) s.pop(ind) s.insert(i,d[i]) for k in range(cnt): if(ind > 0): ans.append(ind) else: ans.append(1) ind -= 1 print(len(ans)) print(*ans)",quadratic,['implementation'],396
"n = int(input()) s = list(input()) d = list(input()) if(sorted(s) != sorted(d)): print(-1) else: ans = [] for i in range(n): if(s[i] != d[i]): for u in range(i+1,n): if(s[u] == d[i]): ind = u break cnt = abs(ind - i) s.pop(ind) s.insert(i,d[i]) for k in range(cnt): if(ind > 0): ans.append(ind) else: ans.append(1) ind -= 1 print(len(ans)) print(*ans)",quadratic,['implementation'],351
"n = int(input()) first = list(input()) second = list(input()) swap = list() can = True for i in range(n): if first[i] != second[i]: cont = -1 for j in range(i,n): if first[j] == second[i]: cont = j break if cont != -1: for j in range(cont, i, -1 ): first[j], first[j-1] = first[j-1], first[j] swap.append(j) else: can = False if can: print(len(swap)) print(*swap, end=' ') else: print(-1)",quadratic,['implementation'],388
"if __name__ == '__main__': cin = input n = int(cin()) s, t = [*cin()], cin() i, r = 0, list() if sorted(s) != sorted(t): print(-1) else: while i < n: j = i while j < n and s[j] != t[i]: j += 1 s[i:j + 1] = s[j:j + 1] + s[i:j] r.extend(range(j, i, -1)) i += 1 print(len(r)) print(*r)",quadratic,['implementation'],282
"import collections n = int(input()) s = input() t = input() if collections.Counter(s) != collections.Counter(t): print(-1) exit() sl = list(s) st = list(t) ans = [] p = 0 while sl: if sl[0] != st[0]: k = sl.index(st[0]) ans.extend(list(range(k + p, p, -1))) sl.pop(k) st.pop(0) else: sl.pop(0) st.pop(0) p += 1 print(len(ans)) print(*ans)",quadratic,['implementation'],338
"import sys input=sys.stdin.readline def read():return list(map(int,input().split())) n=int(input()) s=input() t=input() if sorted(s)!=sorted(t): print(-1) quit() s=list(s) t=list(t) ans=[] for i in range(n): for j in range(i,n-1): if s[j+1] == t[i]: for k in range(j,i-1,-1): ans.append(k+1) s[k+1], s[k] = s[k], s[k+1] break print(len(ans)) print(*ans)",quadratic,['implementation'],353
"from sys import stdin,stdout,setrecursionlimit from functools import lru_cache, cmp_to_key from heapq import merge, heapify, heappop, heappush,nlargest from math import * from collections import defaultdict as dd, deque, Counter as C from itertools import combinations as comb, permutations as perm , accumulate from bisect import bisect_left as bl, bisect_right as br, bisect from time import perf_counter from fractions import Fraction import copy import time setrecursionlimit(10**9) starttime = time.time() mod = int(pow(10, 9) + 7) mod2 = 998244353 def data(): return input() def num():return int(input()) def L(): return list(sp()) def LF(): return list(spf()) def sl(): return list(ssp()) def sp(): return map(int, data().split()) def spf(): return map(int, input.readline().split()) def ssp(): return map(str, data().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)] def pmat(A): for ele in A: print(*ele,end=""\n"") def pmat2(A): for ele in A: for j in ele: print(j,end='') print() def iseven(n): return n%2==0 def seive(r): prime=[1 for i in range(r+1)] prime[0]=0 prime[1]=0 for i in range(r+1): if(prime[i]): for j in range(2*i,r+1,i): prime[j]=0 return prime n = int(input()) s = list(input()) t = list(input()) ans = [] for i in range(n): for j in range(i,n): if s[j] == t[i]: for k in range(j, i, -1): s[k], s[k-1] = s[k-1], s[k] ans.append(k) break if s==t: print(len(ans)) print(' '.join(map(str, ans))) else: print(-1) endtime = time.time()",quadratic,['implementation'],1526
"n=int(input()) s=list(input()) t=list(input()) cnt=0 ans=[] f1=0 for i in range(n): if s[i]==t[i]: continue f=0 for j in range(i+1,n): if s[j]==t[i]: f=1 for k in range(j,i,-1): s[k-1],s[k]=s[k],s[k-1] ans.append(k) break if f==0: print(-1) exit() print(len(ans)) print(*ans)",quadratic,['implementation'],275
"n = int(input()) s = list(input()) t = list(input()) if sorted(t) == sorted(s): ans = [] for i in range(n-1, -1, -1): if t[i] != s[i]: j = s.index(t[i]) for k in range(j, i): s[k], s[k+1] = s[k+1], s[k] ans.append(str(k+1)) print(len(ans)) print(' '.join(ans)) else: print(-1)",quadratic,['implementation'],276
"import re import sys exit=sys.exit from bisect import bisect_left as bsl,bisect_right as bsr from collections import Counter,defaultdict as ddict,deque from functools import lru_cache cache=lru_cache(None) from heapq import * from itertools import * from math import inf from pprint import pprint as pp enum=enumerate ri=lambda:int(rln()) ris=lambda:list(map(int,rfs())) rln=sys.stdin.readline rl=lambda:rln().rstrip('\n') rfs=lambda:rln().split() mod=1000000007 d4=[(0,-1),(1,0),(0,1),(-1,0)] d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)] m,n=ris() m,n=m+2,n+2 grid =['.'*n] grid+=['.'+rl()+'.' for _ in range(m-2)] grid+=['.'*n] up=[[0]*n for _ in range(m)] dw=[[0]*n for _ in range(m)] lf=[[0]*n for _ in range(m)] rg=[[0]*n for _ in range(m)] rs=[[0]*n for _ in range(m)] cs=[[0]*n for _ in range(m)] for i in range(1,m-1): for j in range(1,n-1): if grid[i][j]=='*': up[i][j]=1+up[i-1][j] lf[i][j]=1+lf[i][j-1] for i in range(m-1,0,-1): for j in range(n-1,0,-1): if grid[i][j]=='*': dw[i][j]=1+dw[i+1][j] rg[i][j]=1+rg[i][j+1] ans=[] for i in range(1,m-1): for j in range(1,n-1): if grid[i][j]=='.': continue s=min(up[i-1][j],dw[i+1][j],lf[i][j-1],rg[i][j+1]) if s==0: continue ans.append((i,j,s)) rs[i-s][j]+=1 rs[i+s+1][j]-=1 cs[i][j-s]+=1 cs[i][j+s+1]-=1 for i in range(1,m-1): for j in range(1,n-1): rs[i][j]+=rs[i-1][j] cs[i][j]+=cs[i][j-1] for i in range(1,m-1): for j in range(1,n-1): if grid[i][j]=='.': continue if rs[i][j]==0 and cs[i][j]==0: print(-1) exit() print(len(ans)) for i,j,s in ans: print(i,j,s)",quadratic,"['binary search', 'dp', 'greedy']",1533
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=0, func=lambda a, b: a+b): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = self._default",quadratic,"['binary search', 'dp', 'greedy']",1999
"from collections import defaultdict, deque from heapq import heappush, heappop from math import inf ri = lambda : map(int, input().split()) def solve(): n,m = ri() A = [[0 for _ in range(m)] for __ in range(n)] left = [[0 for _ in range(m)] for __ in range(n)] right = [[0 for _ in range(m)] for __ in range(n)] up = [[0 for _ in range(m)] for __ in range(n)] down = [[0 for _ in range(m)] for __ in range(n)] for r in range(n): lst = input() for c in range(m): if lst[c] == '*': A[r][c] = left[r][c] = right[r][c] = up[r][c] = down[r][c] = 1 for r in range(n): for c in range(1, m): if A[r][c]: left[r][c] += left[r][c-1] for c in range(m-2, -1, -1): if A[r][c]: right[r][c] += right[r][c+1] for c in range(m): for r in range(1, n): if A[r][c]: up[r][c] += up[r-1][c] for r in range(n-2, -1, -1): if A[r][c]: down[r][c] += down[r+1][c] res = [] stars = 0 ROWS = [[0 for _ in range(m)] for __ in range(n)] COLS = [[0 for _ in range(m)] for __ in range(n)] for r in range(n): for c in range(m): if A[r][c]: can = min(left[r][c], right[r][c], up[r][c], down[r][c]) can -= 1 if can > 0: stars += 1 res.append((r+1, c+1, can)) ROWS[r-can][c] += can if r+can+1 < n: ROWS[r+can+1][c] -= can COLS[r][c-can] += can if c+can+1 < m: COLS[r][c+can+1] -= can valid = [[False for _ in range(m)] for __ in range(n)] for r in range(n): curr = 0 for c in range(m): curr += COLS[r][c] if curr > 0: valid[r][c] = True for c in range(m): curr = 0 for r in range(n): curr += ROWS[r][c] if curr > 0: valid[r][c] = True for r in range(n): for c in range(m): if A[r][c] and not valid[r][c]: print(-1) return print(stars) for x,y,z in res: print(x,y,z) t = 1 while t: t -= 1 solve()",quadratic,"['binary search', 'dp', 'greedy']",1658
"import sys input = sys.stdin.readline n, m = map(int, input().split()) s = [list(input().rstrip()) for _ in range(n)] t = [[1000] * m for _ in range(n)] ok1 = [[0] * m for _ in range(n)] ok2 = [[0] * m for _ in range(n)] for i in range(n): si = s[i] c = 0 for j in range(m): if si[j] == ""*"": c += 1 else: c = 0 t[i][j] = min(t[i][j], c) c = 0 for j in range(m - 1, -1, -1): if si[j] == ""*"": c += 1 else: c = 0 t[i][j] = min(t[i][j], c) for j in range(m): c = 0 for i in range(n): if s[i][j] == ""*"": c += 1 else: c = 0 t[i][j] = min(t[i][j], c) c = 0 for i in range(n - 1, -1, -1): if s[i][j] == ""*"": c += 1 else: c = 0 t[i][j] = min(t[i][j], c) ans = [] for i in range(n): for j in range(m): tij = t[i][j] - 1 if tij >= 1: ans.append((i + 1, j + 1, tij)) ok1[max(0, i - tij)][j] += 1 if i + tij + 1 < n: ok1[i + tij + 1][j] -= 1 ok2[i][max(0, j - tij)] += 1 if j + tij + 1 < m: ok2[i][j + tij + 1] -= 1 for i in range(1, n): for j in range(1, m): ok1[i][j] += ok1[i - 1][j] ok2[i][j] += ok2[i][j - 1] for i in range(n): for j in range(m): if s[i][j] == ""*"": if not (ok1[i][j] or ok2[i][j]): ans = -1 print(ans) exit() k = len(ans) print(k) for ans0 in ans: print(*ans0)",quadratic,"['binary search', 'dp', 'greedy']",1169
"n,m=map(int,input().split()) g=[[*input()] for _ in range(n)] c=[[0 for _ in range(m)] for _ in range(n)] for i in range(n): v=0 for j in range(m): v=(v+1)*(g[i][j]=='*') c[i][j]=v v=0 for j in range(m-1,-1,-1): v=(v+1)*(g[i][j]=='*') c[i][j]=min(c[i][j],v) for j in range(m): v=0 for i in range(n): v=(v+1)*(g[i][j]=='*') c[i][j]=min(c[i][j],v) v=0 for i in range(n-1,-1,-1): v=(v+1)*(g[i][j]=='*') c[i][j]=min(c[i][j],v) for i in range(n): for j in range(m): if c[i][j]==1: c[i][j]=0 for i in range(n): v=0 for j in range(m): v=max(v-1,c[i][j]) if v:g[i][j]='.' v=0 for j in range(m-1,-1,-1): v=max(v-1,c[i][j]) if v:g[i][j]='.' for j in range(m): v=0 for i in range(n): v=max(v-1,c[i][j]) if v:g[i][j]='.' for i in range(n-1,-1,-1): v=max(v-1,c[i][j]) if v:g[i][j]='.' if all(g[i][j]=='.' for i in range(n) for j in range(m)): r=[(i+1,j+1,c[i][j]-1) for i in range(n) for j in range(m) if c[i][j]] print(len(r)) for t in r: print(*t) else: print(-1)",quadratic,"['binary search', 'dp', 'greedy']",952
"import sys n,m=map(int,input().split()) s=[list(input()) for i in range(n)] u=[[-1 for i in range(m)] for j in range(n)] d=[[-1 for i in range(m)] for j in range(n)] l=[[-1 for i in range(m)] for j in range(n)] r=[[-1 for i in range(m)] for j in range(n)] for i in range(m): acum=0 for j in range(n): if s[j][i]==""."": acum=0 else: acum+=1 u[j][i]=acum for i in range(m): acum=0 for j in range(n-1,-1,-1): if s[j][i]==""."": acum=0 else: acum+=1 d[j][i]=acum for i in range(n): acum=0 for j in range(m): if s[i][j]==""."": acum=0 else: acum+=1 l[i][j]=acum for i in range(n): acum=0 for j in range(m-1,-1,-1): if s[i][j]==""."": acum=0 else: acum+=1 r[i][j]=acum ans=[] t1=[[0 for i in range(m)] for j in range(n)] t2=[[0 for i in range(m)] for j in range(n)] for i in range(n): for j in range(m): d1=min(l[i][j],r[i][j],u[i][j],d[i][j])-1 if d1>0: ans.append([i+1,j+1,d1]) t1[i+d1][j]+=1 t1[i-d1][j]-=1 t2[i][j-d1]+=1 t2[i][j+d1]-=1 dp=[['.' for i in range(m)] for j in range(n)] for i in range(n): acum=0 for j in range(m): acum+=t2[i][j] if acum!=0 or t2[i][j]!=0: dp[i][j]='*' for i in range(m): acum=0 for j in range(n): acum+=t1[j][i] if acum!=0 or t1[j][i]!=0 : dp[j][i]='*' if dp!=s: print(-1) sys.exit() print(len(ans)) for i in ans: print(*i)",quadratic,"['binary search', 'dp', 'greedy']",1245
"def main(): n, m = map(int, input().split()) ll = [c == '*' for _ in range(n) for c in input()] nm = n * m RLUD = [*[range(i, i + m) for i in range(0, nm, m)], *[range(i, nm, m) for i in range(m)]] cc = [1000] * nm for f in True, False: for r in RLUD: v = 0 for i in r: if ll[i]: v += 1 if cc[i] > v: cc[i] = v else: v = cc[i] = 0 if f: ll.reverse() cc.reverse() cc = [c if c != 1 else 0 for c in cc] for f in True, False: for r in RLUD: v = 0 for i in r: if v > cc[i]: v -= 1 else: v = cc[i] if v: ll[i] = False if f: ll.reverse() cc.reverse() if any(ll): print(-1) else: res = [] for i, c in enumerate(cc): if c: res.append(f'{i//m+1} {i%m+1} {c-1}') print(len(res), '\n'.join(res), sep='\n') if __name__ == '__main__': main()",quadratic,"['binary search', 'dp', 'greedy']",728
"import sys from math import * def minp(): return sys.stdin.readline().strip() def mint(): return int(minp()) def mints(): return map(int, minp().split()) def main(): n, m = mints() res = [] a = [None]*n l = [None]*n r = [None]*n s = [0]*n for i in range(n): a[i] = list(minp()) l[i] = [i for i in range(m)] r[i] = [i for i in range(m)] s[i] = [0]*m for i in range(n): j = 0 b = a[i] ll = l[i] rr = r[i] while j < m: if b[j] == '*': jj = j+1 while jj < m and b[jj] == '*': jj += 1 jj -= 1 for k in range(j,jj+1): ll[k] = j rr[k] = jj j = jj + 1 else: j += 1 for i in range(m): j = 0 while j < n: if a[j][i] == '*': jj = j+1 while jj < n and a[jj][i] == '*': jj += 1 jj -= 1 for k in range(j,jj+1): x = min(i-l[k][i],r[k][i]-i,k-j,jj-k) s[k][i] = x if x > 0: res.append((k+1,i+1,x)) j = jj + 1 else: j += 1 for i in range(n): j = 0 ss = s[i] rr = r[i] c = -1 while j < m: if ss[j] > 0 and c < ss[j]: c = ss[j] if c >= 0: rr[j] = '*' else: rr[j] = '.' j += 1 c -= 1 j = m-1 c = -1 while j >=0: if ss[j] > 0 and c < ss[j]: c = ss[j] if c >= 0: rr[j] = '*' c -= 1 j -= 1 for i in range(m): j = 0 c = -1 while j < n: x = s[j][i] if x > 0 and c < x: c = x if c >= 0: r[j][i] = '*' j += 1 c -= 1 j = n-1 c = -1 while j >=0: x = s[j][i] if x > 0 and c < x: c = x if c >= 0: r[j][i] = '*' if r[j][i] != a[j][i]: print(-1) exit(0) c -= 1 j -= 1 print(len(res)) for i in res: print(*i) main()",quadratic,"['binary search', 'dp', 'greedy']",1380
"def main(): n, m = map(int, input().split()) w = [c == '*' for i in range(n) for c in input()] nm = n * m q = [*[range(i, i + m) for i in range(0, nm, m)], *[range(i, nm, m) for i in range(m)]] e = [1000] * nm for f in True, False: for r in q: v = 0 for i in r: if w[i]: v += 1 if e[i] > v: e[i] = v else: v = e[i] = 0 if f: w.reverse() e.reverse() e = [c if c != 1 else 0 for c in e] for f in True, False: for r in q: v = 0 for i in r: if v > e[i]: v -= 1 else: v = e[i] if v: w[i] = False if f: w.reverse() e.reverse() if any(w): print(-1) else: r = [] for i, c in enumerate(e): if c: r.append(f'{i//m+1} {i%m+1} {c-1}') print(len(r), '\n'.join(r), sep='\n') main()",quadratic,"['binary search', 'dp', 'greedy']",667
"import sys input = sys.stdin.readline n,m=map(int,input().split()) MAP=[list(input().strip()) for i in range(n)] T0=[[0]*(m+1) for i in range(n+1)] T1=[[0]*(m+1) for i in range(n+1)] Y0=[[0]*(m+1) for i in range(n+1)] Y1=[[0]*(m+1) for i in range(n+1)] for i in range(n): for j in range(m): if MAP[i][j]==""*"": T0[i][j]=T0[i-1][j]+1 Y0[i][j]=Y0[i][j-1]+1 for i in range(n-1,-1,-1): for j in range(m-1,-1,-1): if MAP[i][j]==""*"": T1[i][j]=T1[i+1][j]+1 Y1[i][j]=Y1[i][j+1]+1 ANS=[[0]*m for i in range(n)] for i in range(n): for j in range(m): score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j]) if score>=2: ANS[i][j]=score T0=[[0]*(m+1) for i in range(n+1)] T1=[[0]*(m+1) for i in range(n+1)] Y0=[[0]*(m+1) for i in range(n+1)] Y1=[[0]*(m+1) for i in range(n+1)] for i in range(n): for j in range(m): T0[i][j]=max(ANS[i][j],T0[i-1][j]-1) Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1) for i in range(n-1,-1,-1): for j in range(m-1,-1,-1): T1[i][j]=max(ANS[i][j],T1[i+1][j]-1) Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1) SUF=[["".""]*m for i in range(n)] for i in range(n): for j in range(m): if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]: SUF[i][j]=""*"" if SUF!=MAP: print(-1) else: ANSLIST=[] for i in range(n): for j in range(m): if ANS[i][j]!=0: ANSLIST.append((i+1,j+1,ANS[i][j]-1)) print(len(ANSLIST)) for ans in ANSLIST: print(*ans)",quadratic,"['binary search', 'dp', 'greedy']",1312
"import sys from itertools import accumulate def input(): return sys.stdin.readline().strip() def list2d(a, b, c): return [[c] * b for i in range(a)] def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)] def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)] def ceil(x, y=1): return int(-(-x // y)) def INT(): return int(input()) def MAP(): return map(int, input().split()) def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)] def Yes(): print('Yes') def No(): print('No') def YES(): print('YES') def NO(): print('NO') INF = 10 ** 18 MOD = 10 ** 9 + 7 def build_grid(H, W, intv, _type, space=True, padding=False): if space: _input = lambda: input().split() else: _input = lambda: input() _list = lambda: list(map(_type, _input())) if padding: offset = 1 else: offset = 0 grid = list2d(H+offset*2, W+offset*2, intv) for i in range(offset, H+offset): row = _list() for j in range(offset, W+offset): grid[i][j] = row[j-offset] return grid H, W = MAP() grid = build_grid(H, W, ' ans = [] imosw = list2d(H+2, W+2, 0) imosh = list2d(H+2, W+2, 0) def check(i, j): sz = min(L[i][j], R[i][j], U[i][j], D[i][j]) if sz > 1: imosw[i][j-sz+1] += 1 imosw[i][j+sz] -= 1 imosh[i-sz+1][j] += 1 imosh[i+sz][j] -= 1 ans.append((i, j, sz-1)) def check2(): for i in range(1, H+1): for j in range(1, W+1): if grid[i][j] == '*' and not imosw[i][j] and not imosh[i][j]: return False return True L = list2d(H+2, W+2, 0) R = list2d(H+2, W+2, 0) U = list2d(H+2, W+2, 0) D = list2d(H+2, W+2, 0) for i in range(1, H+1): for j in range(1, W+1): if grid[i][j] == '.': L[i][j] = 0 else: L[i][j] = L[i][j-1] + 1 for i in range(1, H+1): for j in range(W, 0, -1): if grid[i][j] == '.': R[i][j] = 0 else: R[i][j] = R[i][j+1] + 1 for j in range(1, W+1): for i in range(1, H+1): if grid[i][j] == '.': U[i][j] = 0 else: U[i][j] = U[i-1][j] + 1 for j in range(1, W+1): for i in range(H, 0, -1): if grid[i][j] == '.': D[i][j] = 0 else: D[i]",quadratic,"['binary search', 'dp', 'greedy']",1999
"n, m = map(int, input().split()) c = [] for j in range(n): d = [] s = input() for i in s: d.append(i) c.append(d) a = [] b = [] e=[] g=[] for j in range(n): k=[0]*(m) e.append(k) for j in range(n): k=[0]*(m) g.append(k) dpu = [] for j in range(n): k=[0]*(m) dpu.append(k) dpd = [] for j in range(n): k=[0]*(m) dpd.append(k) dpl = [] for j in range(n): k=[0]*(m) dpl.append(k) dpr = [] for j in range(n): k=[0]*(m) dpr.append(k) for i in range(n): for j in range(m): if c[i][j] == ""*"": if i>0: dpu[i][j]+=dpu[i-1][j]+1 else: dpu[i][j]=1 if j>0: dpl[i][j]=dpl[i][j-1]+1 else: dpl[i][j]=1 i=n-1 while(i>=0): j=m-1 while(j>=0): if c[i][j] == ""*"": if i<(n-1): dpd[i][j] += dpd[i + 1][j] + 1 else: dpd[i][j] = 1 if j<(m-1): dpr[i][j] = dpr[i][j + 1] + 1 else: dpr[i][j] = 1 j+=-1 i+=-1 for i in range(1,n-1): for j in range(1,m-1): if c[i][j] == ""*"": k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1) if k==0: pass elif k>0: a.append([i+1,j+1,k]) e[i-k][j]+=1 if (i+k)<(n-1): e[i+k+1][j]+=-1 g[i][j-k] += 1 if (j + k) < (m - 1): g[i][j+k+1] += -1 for i in range(m): for j in range(1,n): if c[j-1][i]==""*"": e[j][i]+=e[j-1][i] for i in range(n): for j in range(1,m): if c[i][j-1]==""*"": g[i][j]+=g[i][j-1] f=0 for i in range(n): for j in range(m): if c[i][j]==""*"" and e[i][j]<=0 and g[i][j]<=0: f=1 break if f==1: print(-1) else: print(len(a)) for j in a: print(*j)",quadratic,"['binary search', 'dp', 'greedy']",1361
"n, m = map(int, input().split()) c = [] for j in range(n): d = [] s = input() for i in s: d.append(i) c.append(d) a = [] b = [] e=[] g=[] for j in range(n): k=[0]*(m) e.append(k) for j in range(n): k=[0]*(m) g.append(k) dpu = [] for j in range(n): k=[0]*(m) dpu.append(k) dpd = [] for j in range(n): k=[0]*(m) dpd.append(k) dpl = [] for j in range(n): k=[0]*(m) dpl.append(k) dpr = [] for j in range(n): k=[0]*(m) dpr.append(k) for i in range(n): for j in range(m): if c[i][j] == ""*"": if i>0: dpu[i][j]+=dpu[i-1][j]+1 else: dpu[i][j]=1 if j>0: dpl[i][j]=dpl[i][j-1]+1 else: dpl[i][j]=1 i=n-1 while(i>=0): j=m-1 while(j>=0): if c[i][j] == ""*"": if i<(n-1): dpd[i][j] += dpd[i + 1][j] + 1 else: dpd[i][j] = 1 if j<(m-1): dpr[i][j] = dpr[i][j + 1] + 1 else: dpr[i][j] = 1 j+=-1 i+=-1 for i in range(1,n-1): for j in range(1,m-1): if c[i][j] == ""*"": k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1) if k==0: pass elif k>0: a.append([i+1,j+1,k]) e[i-k][j]+=1 if (i+k)<(n-1): e[i+k+1][j]+=-1 g[i][j-k] += 1 if (j + k) < (m - 1): g[i][j+k+1] += -1 for i in range(m): for j in range(1,n): if c[j-1][i]==""*"": e[j][i]+=e[j-1][i] for i in range(n): for j in range(1,m): if c[i][j-1]==""*"": g[i][j]+=g[i][j-1] f=0 for i in range(n): for j in range(m): if c[i][j]==""*"" and e[i][j]<=0 and g[i][j]<=0: f=1 break if f==1: print(-1) else: print(len(a)) for j in a: print(*j)",quadratic,"['binary search', 'dp', 'greedy']",1361
"n,m = map(int,input().split()) mat = [] for i in range(n): mat.append(list(map(int,input().replace(""*"",""1"").replace(""."",""0"")))) ver,hor = [[0 for i in range(m)] for j in range(n)],[[0 for i in range(m)] for j in range(n)] dp = [[[0 for i in range(4)]for j in range(m) ] for k in range(n)] for i in range(1,n): for j in range(1,m): x,y = n-i-1,m-j-1 if mat[i][j]==1: dp[i][j][0] = max(dp[i][j-1][0],mat[i][j-1]) + 1 dp[i][j][1] = max(dp[i-1][j][1],mat[i-1][j]) + 1 if mat[x][y]==1: dp[x][y][2] = max(dp[x][y+1][2],mat[x][y+1]) + 1 dp[x][y][3] = max(dp[x+1][y][3],mat[x+1][y]) + 1 stars = [] for i in range(1,n-1): for j in range(1,m-1): if mat[i][j]==1: s = min(dp[i][j])-1 if s>0: stars.append((i+1,j+1,s)) ver[i-s][j]+=1 if i+s+1<n: ver[i+s+1][j] -= 1 hor[i][j-s]+=1 if j+s+1<m: hor[i][j+s+1] -= 1 for i in range(1,n): for j in range(1,m): ver[i][j] += ver[i-1][j] hor[i][j] += hor[i][j-1] chk = True for i in range(n): for j in range(m): if mat[i][j] and max(ver[i][j],hor[i][j])<=0: chk=False break if chk: print(len(stars)) for i in stars: print(*i) else: print(-1)",quadratic,"['binary search', 'dp', 'greedy']",1069
"import math import heapq, bisect import sys from collections import deque, defaultdict from fractions import Fraction import sys mod = 10 ** 9 + 7 mod1 = 998244353 import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=0, func=lambda a, b: a + b): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = self._default def __getitem",quadratic,"['binary search', 'dp', 'greedy']",1999
"import sys input=lambda:sys.stdin.readline().rstrip() h,w=map(int,input().split()) s=[list("".""*(w+2))]+[list("".""+input()+""."") for _ in range(h)]+[list("".""*(w+2))] b=[[0]*(w+2)for _ in range(h+2)] c=[[0]*(w+2)for _ in range(h+2)] for i in range(1,h+2): for j in range(1,w+2): if s[i][j]==""*"": b[i][j]=b[i-1][j]+1 c[i][j]=c[i][j-1]+1 for i in range(h,-1,-1): for j in range(w,-1,-1): if s[i][j]==""*"": b[i][j]=min(b[i][j],b[i+1][j]+1) c[i][j]=min(c[i][j],c[i][j+1]+1) ans=[] for i in range(1,h+1): for j in range(1,w+1): t=min(b[i][j],c[i][j])-1 if t>0: ans.append((i,j,t)) b=[[0]*(w+2)for _ in range(h+2)] c=[[0]*(w+2)for _ in range(h+2)] for i,j,t in ans: b[i-t][j]+=1 b[i+t+1][j]-=1 c[i][j-t]+=1 c[i][j+t+1]-=1 for i in range(h+1): for j in range(w+1): b[i+1][j]+=b[i][j] c[i][j+1]+=c[i][j] if i!=0 and j!=0: if (b[i][j]+c[i][j]>0)!=(s[i][j]==""*""): print(-1) exit() print(len(ans)) for i in ans:print(*i)",quadratic,"['binary search', 'dp', 'greedy']",904
"def main(): n,m = map(int, input().split()) S = [list(str(input())) for _ in range(n)] L = [[0]*m for _ in range(n)] R = [[0]*m for _ in range(n)] U = [[0]*m for _ in range(n)] D = [[0]*m for _ in range(n)] for i in range(n): cnt = 0 for j in range(m): if S[i][j] == '.': cnt = 0 else: cnt += 1 L[i][j] = cnt cnt = 0 for j in reversed(range(m)): if S[i][j] == '.': cnt = 0 else: cnt += 1 R[i][j] = cnt for j in range(m): cnt = 0 for i in range(n): if S[i][j] == '.': cnt = 0 else: cnt += 1 U[i][j] = cnt cnt = 0 for i in reversed(range(n)): if S[i][j] == '.': cnt = 0 else: cnt += 1 D[i][j] = cnt imosH = [[0]*(m+1) for _ in range(n)] imosV = [[0]*m for _ in range(n+1)] ans = [] for i in range(1, n-1): for j in range(1, m-1): if S[i][j] == '.': continue l = L[i][j]-1 r = R[i][j]-1 u = U[i][j]-1 d = D[i][j]-1 s = min([l, r, u, d]) if s == 0: continue ans.append((i+1, j+1, s)) imosV[i-s][j] += 1 imosV[i+s+1][j] -= 1 imosH[i][j-s] += 1 imosH[i][j+s+1] -= 1 from itertools import accumulate for i in range(n): imosH[i] = list(accumulate(imosH[i])) for j in range(m): for i in range(1, n+1): imosV[i][j] += imosV[i-1][j] for i in range(n): for j in range(m): if S[i][j] == '*': if imosH[i][j] <= 0 and imosV[i][j] <= 0: print(-1) exit() else: print(len(ans)) for i in range(len(ans)): print(*ans[i]) if __name__ == '__main__': main()",quadratic,"['binary search', 'dp', 'greedy']",1334
"from sys import stdin rints = lambda: [int(x) for x in stdin.readline().split()] rstr = lambda: stdin.readline().strip() rstr_2d = lambda n: [rstr() for _ in range(n)] n, m = rints() grid = rstr_2d(n) row = [[[] for _ in range(m)] for _ in range(n)] col = [[[] for _ in range(m)] for _ in range(n)] visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0 visc = [[-1 for _ in range(m)] for _ in range(n)] for i in range(n): be, en = -1, -1 for j in range(m): if grid[i][j] == '*': en += 1 if be == -1: be = en = j else: if be != -1: for k in range(be, en + 1): row[i][k] = [be, en] be = -1 if be != -1: for k in range(be, en + 1): row[i][k] = [be, en] for i in range(m): be, en = -1, -1 for j in range(n): if grid[j][i] == '*': en += 1 if be == -1: be = en = j else: if be != -1: for k in range(be, en + 1): col[k][i] = [be, en] be = -1 if be != -1: for k in range(be, en + 1): col[k][i] = [be, en] for i in range(n): for j in range(m): if grid[i][j] == '*': all += 1 hor = min(row[i][j][1] - j, j - row[i][j][0]) ver = min(col[i][j][1] - i, i - col[i][j][0]) if hor <= ver: ver = hor else: hor = ver if hor > 0 and ver > 0: out.append('%d %d %d' % (i + 1, j + 1, hor)) visr[i][j - ver] = j + ver visc[i - hor][j] = i + hor dis = set() for i in range(n): j, ma = 0, -1 while j < m: ma = max(ma, visr[i][j]) if ma >= j: dis.add((i, j)) j += 1 for i in range(m): j, ma = 0, -1 while j < n: ma = max(ma, visc[j][i]) if ma >= j: dis.add((j, i)) j += 1 if len(dis) != all: print(-1) else: print('%d\n%s' % (len(out), '\n'.join(out)))",quadratic,"['binary search', 'dp', 'greedy']",1539
"import os, sys, atexit from cStringIO import StringIO as BytesIO sys.stdout = BytesIO() atexit.register(lambda: os.write(1, sys.stdout.getvalue())) input = BytesIO(os.read(0, os.fstat(0).st_size)).readline rints = lambda: [int(x) for x in input().split()] rstr = lambda: input().strip() rstr_2d = lambda n: [rstr() for _ in range(n)] n, m = rints() grid = rstr_2d(n) row = [[[] for _ in range(m)] for _ in range(n)] col = [[[] for _ in range(m)] for _ in range(n)] visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0 visc = [[-1 for _ in range(m)] for _ in range(n)] for i in range(n): be, en = -1, -1 for j in range(m): if grid[i][j] == '*': en += 1 if be == -1: be = en = j else: if be != -1: for k in range(be, en + 1): row[i][k] = [be, en] be = -1 if be != -1: for k in range(be, en + 1): row[i][k] = [be, en] for i in range(m): be, en = -1, -1 for j in range(n): if grid[j][i] == '*': en += 1 if be == -1: be = en = j else: if be != -1: for k in range(be, en + 1): col[k][i] = [be, en] be = -1 if be != -1: for k in range(be, en + 1): col[k][i] = [be, en] for i in range(n): for j in range(m): if grid[i][j] == '*': all += 1 hor = min(row[i][j][1] - j, j - row[i][j][0]) ver = min(col[i][j][1] - i, i - col[i][j][0]) if hor <= ver: ver = hor else: hor = ver if hor > 0 and ver > 0: out.append('%d %d %d' % (i + 1, j + 1, hor)) visr[i][j - ver] = j + ver visc[i - hor][j] = i + hor dis = set() for i in range(n): j, ma = 0, -1 while j < m: ma = max(ma, visr[i][j]) if ma >= j: dis.add((i, j)) j += 1 for i in range(m): j, ma = 0, -1 while j < n: ma = max(ma, visc[j][i]) if ma >= j: dis.add((j, i)) j += 1 if len(dis) != all: print(-1) else: sys.stdout.write('%d\n%s' % (len(out), '\n'.join(out)))",quadratic,"['binary search', 'dp', 'greedy']",1716
"def norm(x): return (x % 998244353 + 998244353) % 998244353 n, k = map(int, input().split()) dp1 = [0] dp2 = [0] for i in range(n): l = [1] cur = 0 for j in range(n + 1): cur += l[j] if(j > i): cur -= l[j - i - 1] cur = norm(cur) l.append(cur) dp1.append(l[n]) dp2.append(norm(dp1[i + 1] - dp1[i])) ans = 0 for i in range(n + 1): for j in range(n + 1): if(i * j < k): ans = norm(ans + dp2[i] * dp2[j]) ans = norm(ans * 2) print(ans)",quadratic,"['combinatorics', 'dp', 'math']",432
"import sys from array import array def readline(): return sys.stdin.buffer.readline().decode('utf-8') n, k = map(int, readline().split()) mod = 998244353 if k == 1: print(0) exit() dp1 = [array('i', [0])*n for _ in range(n)] dp2 = [array('i', [0])*n for _ in range(n)] dp1[0][0] = 1 for i in range(n-1): for j in range(i+1): for l in range(j+1): dp2[j][0] += dp1[j][l] if dp2[j][0] >= mod: dp2[j][0] -= mod dp2[j+1 if j == l else j][l+1] += dp1[j][l] if dp2[j+1 if j == l else j][l+1] >= mod: dp2[j+1 if j == l else j][l+1] -= mod dp1[j][l] = 0 dp1, dp2 = dp2, dp1 ans = 0 for i in range(1, n+1): t = (k-1) // i if t == 0: break dps1 = array('i', [0])*(t+1) dps2 = array('i', [0])*(t+1) dps1[0] = 1 for j in range(n-1): for l in range(min(j+1, t)): dps2[0] += dps1[l] if dps2[0] >= mod: dps2[0] -= mod dps2[l+1] += dps1[l] if dps2[l+1] >= mod: dps2[l+1] -= mod dps1[l] = 0 dps1, dps2 = dps2, dps1 x = sum(dp1[i-1]) % mod ans = (ans + x * sum(dps1[:-1])) % mod print(ans * 2 % mod)",quadratic,"['combinatorics', 'dp', 'math']",980
"n, m = list(map(int, input().split())) temp = 0 a = [list(input()) for i in range(n)] for i in range(n): ok = False for j in range(m): if (a[i][j] == ""B""): pos1 = i pos2 = j temp += 1 temp2 = j if (j != m-1): ok = True while True: ok2 = False if (temp2 == m-1): ok2 = True break if (a[i][temp2 + 1] != ""B""): ok2 = True break temp += 1 temp2 += 1 elif (j == m - 1): temp = 1 ok = True break if (ok2): break if (ok): break print(temp//2 + pos1 + 1, temp//2 + pos2 + 1)",quadratic,['implementation'],466
"n, m = map(int, input().split()) top = [-1, -1] bottom = [-1, -1] matrix = list() for i in range(n): s = input() matrix.append(s) for i in range(n): left = matrix[i].find('B') if left != -1: top[0] = i top[1] = left break for i in range(n-1, -1, -1): right = matrix[i].rfind('B') if right != -1: bottom[0] = i bottom[1] = right break print(1 + top[0] + (bottom[0] - top[0]) // 2, 1 + top[1] + (bottom[1] - top[1]) // 2)",quadratic,['implementation'],419
"n, m = map(int, input().split()) top = [-1, -1] bottom = [-1, -1] for i in range(n): s = input() left = s.find('B') if left != -1: right = s.rfind('B') c = (right - left) // 2 + 1 print(i + c, left + c) break",quadratic,['implementation'],208
"n, m = map(int, input().split()) for i in range(n): s = input() left = s.find('B') if left != -1: right = s.rfind('B') c = (right - left) // 2 + 1 print(i + c, left + c) break",quadratic,['implementation'],175
"n,m=map(int,input().split()) l=[] for i in range(n): s=input() l.append(s) minX,minY,maxX,maxY=n,m,0,0 for i in range(n): for j in range(m): if l[i][j]=='B': minX,minY,maxX,maxY=min(minX,i),min(minY,j),max(maxX,i),max(maxY,j) print((minX+maxX)//2+1,(minY+maxY)//2+1)",quadratic,['implementation'],266
"n, m = map(int, input().split()) s = [""""] * n for i in range(n): s[i] = input() for i in range(n): for j in range(m): if s[i][j] == 'B': cnt = 1 for k in range(j + 1, m): if s[i][k] == 'B': cnt += 1 else: break print(i + 1 + cnt // 2, j + 1 + cnt // 2) exit(0)",quadratic,['implementation'],260
"n, m = map(int,input().split()) r=0 c=0 f= 1 for i in range(n): s = input() if f and ""B"" in s: f = 0 ci = s.index('B') cc = s.count(""B"") r = i+1+cc//2 c = ci+cc//2+1 print(r,c)",quadratic,['implementation'],176
"n, m = map(int, input().split()) a = [] def is_center(a, y, x): count1 = count2 = count3 = count4 = 0 y1 = y x1 = x while True: y2 = y1 - 1 if y2 < 0: break c = a[y2][x] if c == ""W"": break count1 += 1 y1 = y2 y1 = y x1 = x while True: y2 = y1 + 1 if y2 == n: break c = a[y2][x] if c == ""W"": break count2 += 1 y1 = y2 y1 = y x1 = x while True: x2 = x1 - 1 if x2 < 0: break c = a[y1][x2] if c == ""W"": break count3 += 1 x1 = x2 y1 = y x1 = x while True: x2 = x1 + 1 if x2 == m: break c = a[y1][x2] if c == ""W"": break count4 += 1 x1 = x2 return count1 == count2 == count3 == count4 and a[y][x] == ""B"" for k in range(n): s = input() a.append(s) for y in range(n): c = False for x in range(m): if is_center(a, y, x): print(y+1, x+1) c = True break if c: break",quadratic,['implementation'],753
"n,m = list(map(int,input().split())) l = [] for i in range(n) : s = input() l.append(s) x1=0 x2=0 y1=0 y2=0 for i in range (n) : for j in range(m) : if l[i][j]=='B' : if x1==0 and y1==0 : x1,y1 = [i+1,j+1] else : x2,y2 = [i+1,j+1] res = [] x=0 y=0 if x2!=0 : x = (x2 - x1) // 2 y = (y2 - y1) // 2 res.append(x1+x) res.append(y1+y) print(*res)",quadratic,['implementation'],342
"n,m=map(int, input().split()) for i in range(n): mt=input() if mt.count('B')!=0: print(mt.count('B')//2+i+1,mt.count('B')//2+mt.index('B')+1) break",quadratic,['implementation'],147
"from math import * from cmath import * from itertools import * from decimal import * from fractions import * from sys import * from types import CodeType, new_class a = [] n, m = map(int, input().split()) minx, miny, maxx, maxy = n, m, 0, 0 for x in range(n): a.append(input()) for y in range(m): if a[x][y] == 'B': minx = min(minx, x + 1) miny = min(miny, y + 1) maxx = max(maxx, x + 1) maxy = max(maxy, y + 1) print((maxx + minx) // 2 , (maxy + miny) // 2)",quadratic,['implementation'],458
"n,m=map(int,input().split()) listi=[] for i in range(0,n): string=input() listi.append(string) rownum=0 flag=False for row in listi: for letter in row: if(""B"" in row): p=row.index(""B"") s=row[::-1] q=abs(m-s.index(""B"")-1) if(p==q): print(rownum+1,row.index(row[p])+1) flag=True break mr=(q+p)/2 length=abs(q-p+1) rn= rownum + length//2 print(rn+1,int(mr+1)) flag=True break if(flag==True): break rownum+=1",quadratic,['implementation'],404
"import math a,b=map(int,input().split()) c=[] e=[] f=0 for i in range(a): d=str(input()) for j in range(b): if d[j]==""B"": c=c+[i] e=e+[j] p=min(c) p1=min(e) p2=max(c) plus=(max(c)-min(c))//2 p3=p+plus+1 p4=p1+plus+1 print(p3,p4)",quadratic,['implementation'],228
"n,m = map(int,input().split()) li = [[j for j in input()] for i in range(n)] for j in range(m): flag = False for i in range(n): if li[i][j] == ""B"": flag = True position1 = i break if(flag == True): break for j in range(m-1,-1,-1): flag = False for i in range(n-1,-1,-1): if li[i][j] == ""B"": flag = True position2 = i break if(flag == True): break for i in range(n): flag = False for j in range(m): if li[i][j] == ""B"": flag = True position3 = j break if(flag == True): break for i in range(n-1,-1,-1): flag = False for j in range(m-1,-1,-1): if li[i][j] == ""B"": flag = True position4 = j break if(flag == True): break avg1 = (position1+position2)//2 + 1 avg2 = (position3 + position4)//2 + 1 print(avg1,avg2)",quadratic,['implementation'],707
"n,m = map(int,input().split()) li = [[j for j in input()] for i in range(n)] position1=0 position2=0 position3=0 position4=0 for j in range(m): flag = False for i in range(n): if li[i][j] == ""B"": flag = True position1 = i break if(flag == True): break for j in range(m-1,-1,-1): flag = False for i in range(n-1,-1,-1): if li[i][j] == ""B"": flag = True position2 = i break if(flag == True): break for i in range(n): flag = False for j in range(m): if li[i][j] == ""B"": flag = True position3 = j break if(flag == True): break for i in range(n-1,-1,-1): flag = False for j in range(m-1,-1,-1): if li[i][j] == ""B"": flag = True position4 = j break if(flag == True): break avg1 = (position1+position2)//2 + 1 avg2 = (position3 + position4)//2 + 1 print(avg1,avg2)",quadratic,['implementation'],755
"from math import * n,m = map(int,input().split()) li = [[j for j in input()] for i in range(n)] min1=inf min2=inf max1=-inf max2=-inf for i in range(n): for j in range(m): if li[i][j] == ""B"": min1 = min(min1,i) min2 = min(min2, j) max1 = max(max1, i) max2 = max(max2, j) print((min1+max1)//2+1,(min2+max2)//2+1)",quadratic,['implementation'],311
"n,m=map(int,input().split()) lock=0 for i in range(n): s=str(input()) if(('B' in s) and (lock==0)): Rstart=s.index('B') cnt=s.count('B') Rcen=Rstart+(cnt//2) Cstart=i Ccen=Cstart+(cnt//2) lock=1 print(Ccen+1,Rcen+1)",quadratic,['implementation'],215
"n,m=map(int,input().split()) listi=[] for i in range(0,n): string=input() listi.append(string) rownum=0 flag=False for row in listi: for letter in row: if(""B"" in row): p=row.index(""B"") s=row[::-1] q=abs(m-s.index(""B"")-1) if(p==q): print(rownum+1,row.index(row[p])+1) flag=True break mr=(q+p)/2 length=abs(q-p+1) rn= rownum + length//2 print(rn+1,int(mr+1)) flag=True break if(flag==True): break rownum+=1",quadratic,['implementation'],404
"n, m = map(int, input().split()) x1 = -1 x2 = -1 y1 = -1 y2 = -1 for i in range(n): s = input() for j in range(m): if s[j] == 'B': if x1 == -1: x1 = j + 1 x2 = max(x2, j + 1) if y1 == -1: y1 = i + 1 y2 = i + 1 print((y1 + y2) // 2, (x1 + x2) // 2)",quadratic,['implementation'],247
"n,m=input().split() i=j=-1 while(j<0): mat=input() j=mat.find('B') i+=1 c=mat.count('B')//2+1 print(i+c,j+c)",quadratic,['implementation'],108
"n,m=map(int,input().split()) M=[['0' for x in range(m)] for y in range(n)] for a in range(n): i=input() for b in range(len(i)): M[a][b]=i[b] start=[] end=[] for a in range(n): for b in range(m): if M[a][b]=='B': if not start: start.append(a+1) start.append(b+1) else: end.clear() end.append(a+1) end.append(b+1) if not start or not end: print(start[0],start[1]) else: mid1=int((end[0]+start[0])/2) mid2=int((end[1]+start[1])/2) print(mid1,mid2)",quadratic,['implementation'],444
"import sys def main(): pass def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while n > 1: n //= 2 p += 1 return (p) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def lts(l): s = ''.join(map(str, l)) return s def stl(s): l = list(s) return l def sq(a, target, arr=[]): s = sum(arr) if (s == target): return arr if (s >= target): return for i in range(len(a)): n = a[i] remaining = a[i + 1:] ans = sq(remaining, target, arr + [n]) if (ans): return ans def SieveOfEratosthenes(n): cnt = 0 prime = [True for i in range(n + 1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n + 1, p): prime[i] = False p += 1 for p in range(2, n + 1): if prime[p]: cnt += 1 return (cnt) def nCr(n, r): f = math.factorial return f(n) // f(r) // f(n - r) mod = int(1e9) + 7 def ssinp(): return sys.stdin.readline().strip() def iinp(): return int(input()) def nninp(): return map(int, sys.stdin.readline().strip().split()) def llinp(): return list(map(int, sys.stdin.readline().strip().split())) def p(xyz): print(xyz) def p2(a, b): print(a, b) import math n,m=nninp() ans=0 cnt=f=0 for i in range(n): s=ssinp() r=stl(s) cnt=0 for c in range(len(r)): if(r[c]==""W"" and f==0): pass elif(r[c]==""B"" and f==0): cnt+=1 f=1 elif(r[c]==""B"" and f==1): cnt+=1 elif(r[c]==""W"" and f==1): f=0 if(cnt%2==1): print(i+1+(cnt//2),c-(cnt//2)) exit() if(cnt%2==1): print(i+1+cnt//2,c+1-cnt//2) exit()",quadratic,['implementation'],1541
"import sys import math from collections import defaultdict,deque input = sys.stdin.readline def inar(): return [int(el) for el in input().split()] def main(): n,k=inar() st=input().strip() res=st pos=1 cnt=1 while cnt<k: suffix=0 counter=0 for i in range(pos,len(res)): if res[i]==st[suffix]: suffix+=1 else: counter=1 break if counter: pos+=1 continue if pos>len(res): res+=st cnt+=1 pos+=1 continue res+=st[suffix:n] cnt+=1 pos+=1 print(res) if __name__ == '__main__': main()",quadratic,"['implementation', 'strings']",477
"n,k = map(int,input().split()) s= input() s1=s c=0 for i in range(len(s)-1): if(s[:i+1]==s[n-i-1:]): c=i+1 for i in range(k-1): s1+=s[c:] print(s1)",quadratic,"['implementation', 'strings']",147
"from os import path import sys,time from math import ceil, floor,gcd,log,log2 ,factorial from collections import * maxx = float('inf') I = lambda :int(sys.stdin.buffer.readline()) tup= lambda : map(int , sys.stdin.buffer.readline().split()) lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()] S = lambda: sys.stdin.readline().replace('\n', '').strip() def grid(r, c): return [lint() for i in range(r)] stpr = lambda x : sys.stdout.write(f'{x}' + '\n') star = lambda x: print(' '.join(map(str, x))) localsys = 0 start_time = time.time() if (path.exists('input.txt')): sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w'); n , k= tup() s = S() fl =0 l = None for i in range(1, n): x =s[i:n] for j in range(n): if x == s[:j+1]: l = j+1 fl = 1 break if fl : break if fl : ans = s + s[l:n]*(k-1) print(ans) else: print(s*k) if localsys: print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")",quadratic,"['implementation', 'strings']",923
"from os import path import sys,time from math import ceil, floor,gcd,log,log2 ,factorial from collections import * maxx = float('inf') I = lambda :int(sys.stdin.buffer.readline()) tup= lambda : map(int , sys.stdin.buffer.readline().split()) lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()] S = lambda: sys.stdin.readline().replace('\n', '').strip() def grid(r, c): return [lint() for i in range(r)] stpr = lambda x : sys.stdout.write(f'{x}' + '\n') star = lambda x: print(' '.join(map(str, x))) localsys = 0 start_time = time.time() if (path.exists('input.txt')): sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w'); n , k = tup() s , i = S() , 1 while s[i:] != s[:-i] :i+=1 print(s[:i]*k + s[i:]) if localsys: print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")",quadratic,"['implementation', 'strings']",806
"n,k = map(int,input().split()) t = input() if n==1: print(t*k) else: i = len(t)-1 while i>0 and t[-i:] != t[:i]: i-=1 t2 = t[i:] print(t+t2*(k-1))",quadratic,"['implementation', 'strings']",146
"from sys import stdin,stdout def main(): n,k=map(int,stdin.readline().split( )) s=stdin.readline() start=-1 i=0;j=1;prev=1 while i<n-1: while j<n: if s[i]==s[j]: if start==-1: start=j prev=j i+=1 j+=1 else: i=0 j=prev+1 prev=j start=-1 break if start==-1: stdout.write(""%s\n""%(s[:n]*k)) else: j = n - start stdout.write(""%s\n""%(s[:n]+s[j:n]*(k-1))) main()",quadratic,"['implementation', 'strings']",355
"def solve(): n, k = [int(x) for x in input().split(' ')] t = input() j = 0 for i in range(1, n): if t[:i] == t[-i:]: j = i s = t + (k - 1) * t[-(n - j):] return s print(solve())",quadratic,"['implementation', 'strings']",177
"n,k=map(int,input().split()) s=input();flag=True;lenn=10**10;ans=0 for i in range(n): s1=s+s[n-i-1:]*(k-1);cnt=0 for i in range(len(s1)-len(s)+1): if s1[i:i+len(s)]==s:cnt+=1 if cnt==k and len(s1)<lenn:ans=s1;lenn=len(s1) print(ans)",quadratic,"['implementation', 'strings']",232
"def prefix_func(s): slen, k = len(s), 0 p = [0]*slen p[0] = 0 for i in range(1, slen): while k>0 and s[k] != s[i]: k = p[k-1] if s[k] == s[i]: k += 1 p[i] = k return p n,k=map(int,input().split()) s=input() l=prefix_func(s)[-1] print(s+s[l:]*(k-1))",quadratic,"['implementation', 'strings']",248
"n, k = [int(num) for num in input().split(' ')] string = input() def fn(string, k): maximum_match = 0 for i in range(1, len(string)): if string[:i] == string[-i:]: maximum_match = i answer = list(string) extra = list(string[maximum_match:]) for i in range(k-1): answer.extend(extra) return ''.join(answer) print(fn(string, k))",quadratic,"['implementation', 'strings']",326
"def solve(): n, k = [int(x) for x in input().split(' ')] t = input() j = 0 for i in range(1, n): if t[:i] == t[-i:]: j = i s = t + (k - 1) * t[-(n - j):] return s print(solve())",quadratic,"['implementation', 'strings']",177
"n,k = map(int,input().split()) s = input() c=0 for i in range(len(s)): if s[:i]==s[-i:]: c=i print(s+s[c:]*(k-1))",quadratic,"['implementation', 'strings']",113
"tam,q = [int(i) for i in input().split()] t = input() s = t posi = -1 for j in range(tam-1): if(t[:j+1] == t[tam - j -1:]): posi = j add = t[posi+1:] for j in range(q-1): s += add print(s)",quadratic,"['implementation', 'strings']",188
v = input().split() n = int(v[0]) k = int(v[1]) s = input() ap = 0 i = 1 while i < n: if s[:i] == s[-i:]: ap = i i += 1 print(s + s[ap:]*(k-1)),quadratic,"['implementation', 'strings']",143
"n,kk=map(int,input().split()) s=input() if(s==s[::-1] or s!=s[::-1]): k="""" l=0 for i in reversed(range(1,n)): k=s[i]+k if(s.startswith(k)): l=len(k) ss=s[l:] fs=s+(ss*(kk-1)) print(fs)",quadratic,"['implementation', 'strings']",184
"n, k = map(int, input().split()) s = input() for i in range(1, n): if s[:n - i] == s[i:]: print(s + s[n - i:] * (k - 1)) exit() print(s * k)",quadratic,"['implementation', 'strings']",140
"n, k = map(int, input().split()) s = input() fail = [-1] * (len(s) + 1) for i in range(1, len(s) + 1): j = fail[i - 1] while j != -1 and s[i - 1] != s[j]: j = fail[j] fail[i] = j + 1 f1 = fail[-1] print(s + s[f1:] * (k - 1))",quadratic,"['implementation', 'strings']",224
"import sys input=sys.stdin.readline def read():return list(map(int,input().split())) n,k=read() s=input()[:-1] ans="""" for i in range(len(s)+1, 0, -1): res=s end=s[-i:] for j in range(k-1): res += end cnt=0 for j in range(len(res)-len(s)+1): if res[j:j+len(s)] == s: cnt += 1 if cnt == k: ans = res print(ans)",quadratic,"['implementation', 'strings']",308
"tam,q = [int(i) for i in input().split()] t = input() s = t posi = -1 for j in range(tam-1): if(t[:j+1] == t[tam - j -1:]): posi = j add = t[posi+1:] for j in range(q-1): s += add print(s)",quadratic,"['implementation', 'strings']",188
"n,k=map(int,input().split()) s=input() i=-1 for j in range(n-1): if s[:j+1]==s[n-j-1:]: i=j add=s[i+1:] for j in range(k-1): s+=add print(s)",quadratic,"['implementation', 'strings']",140
"a = list(map(int, input().split())) n = a[0] k = a[1] s = input() m = int(-1) for i in range(0, n - 1): ff = int(0) for j in range(0, i + 1): if s[j] != s[n - i - 1 + j]: ff = 1 break; if ff == 0: m = i print(s, end="""") for i in range(1, k): for j in range(m + 1, n): print(s[j], end="""")",quadratic,"['implementation', 'strings']",287
"n, k = map(int, input().split()) t = input() i = 1 while t[:-i] != t[i:]: i += 1 print(t[:i] * k + t[i:])",quadratic,"['implementation', 'strings']",105
"n, k = map(int,input().split()) s = input() p = len(s)-1 while s[:p] != s[-p:]: p = p -1 print(s + s[p:]*(k-1))",quadratic,"['implementation', 'strings']",111
v = input().split() n = int(v[0]) k = int(v[1]) s = input() ap = 0 i = 1 while i < n: if s[:i] == s[-i:]: ap = i i += 1 print(s + s[ap:]*(k-1)),quadratic,"['implementation', 'strings']",143
"n,k = map(int,input().split()) s = input() f = 0 for i in range(1,n): if s[:n-i]==s[i:]: f=1 break if f==0: print(s*k) else: j = n-i final = s[j:] print(s+final*(k-1))",quadratic,"['implementation', 'strings']",167
"from os import path import sys,time from math import ceil, floor,gcd,log,log2 ,factorial from collections import * maxx = float('inf') I = lambda :int(sys.stdin.buffer.readline()) tup= lambda : map(int , sys.stdin.buffer.readline().split()) lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()] S = lambda: sys.stdin.readline().replace('\n', '').strip() def grid(r, c): return [lint() for i in range(r)] stpr = lambda x : sys.stdout.write(f'{x}' + '\n') star = lambda x: print(' '.join(map(str, x))) localsys = 0 start_time = time.time() if (path.exists('input.txt')): sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w'); n = I() ls = [int(i) for i in S()] pre , s =[] , 0 for i in ls: s+=i pre.append(s) for i in range(n-1): cnt =0 su =0 for j in range(i+1 , n): su+=ls[j] if su == pre[i]: cnt+=1 su =0 if cnt and su ==0: print('YES') exit() print('NO') if localsys: print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")",quadratic,['implementation'],958
"n=int(input()) s=input() l=[] total=0 p=0 for i in range(0,450): sum1=0 flag=1 r=0 for k in range(n): sum1=sum1+int(s[k]) if(sum1>i): flag=0 if(sum1==i): sum1=0 r=r+1 if(r>=2 and sum1==0 and flag==1): print(""YES"") p=1 break if(p==0): print(""NO"")",quadratic,['implementation'],245
"n=int(input()) a=int(input()) s=0 t=a b=[] for i in range(n): s+=t%10 b.append(t%10) t//=10 b.reverse() i=2 ans=False if(s==0): ans=True while(i<=s): if(s%i!=0): i+=1 continue l=s//i c=0 su=0 for j in range(n): if(su>l): break else: su+=b[j] if(su==l): su=0 c+=1 if(c==i): ans=True i+=1 if(ans): print(""YES"") else:print(""NO"")",quadratic,['implementation'],325
"import sys, math n = int(sys.stdin.readline()) arr = list(map(int, sys.stdin.readline().rstrip())) if len(set(arr)) == 1: print('YES') else: val = sum(arr) factor = set() for i in range(1, int(val ** 0.5) + 1): if val % i == 0: factor.add(i) factor.add(val // i) can = False for i in factor: each = val // i if 1 < i <= n: idx = 0 temp = 0 cnt = 0 while idx < n: if temp + arr[idx] < each: temp += arr[idx] elif temp + arr[idx] > each: temp = 0 else: temp = 0 cnt += 1 idx += 1 if cnt == i: can = True print('YES' if can else 'NO')",quadratic,['implementation'],531
"from sys import stdin,stdout def main(): n=int(stdin.readline()) s=stdin.readline() sum=0 a=[] for v in s: if v!='0' and v!='\n': a.append(v) if not a and n>1: return 'YES' n=len(a) s=a for i in range(n-1): sum+=int(s[i]) j=i+1 check=1 while j<n: temp=int(s[j]) j+=1 while j<n: if temp>=sum: break temp+=int(s[j]) j+=1 if sum!=temp: check=1 break if sum!=temp: check=0 if check: return 'YES' return 'NO' print(main())",quadratic,['implementation'],417
"import sys, math n = int(sys.stdin.readline()) arr = list(map(int, sys.stdin.readline().rstrip())) if len(set(arr)) == 1: print('YES') else: val = sum(arr) factor = set() for i in range(1, int(val ** 0.5) + 1): if val % i == 0: factor.add(i) factor.add(val // i) can = False for i in factor: each = val // i if 1 < i <= n: idx = 0 temp = 0 cnt = 0 while idx < n: if temp + arr[idx] < each: temp += arr[idx] elif temp + arr[idx] > each: temp = 0 else: temp = 0 cnt += 1 idx += 1 if cnt == i: can = True print('YES' if can else 'NO')",quadratic,['implementation'],531
"n = int(input()) a = list(input()) smm = 0 for i in range(n): a[i] = int(a[i]) smm += a[i] ans = ""NO"" sm = smm for div in range(2, n + 1): sm = smm if not sm % div: sm //= div f = 0 s = 0 for i in range(n): s += a[i] if s == sm: s = 0 f += 1 if f == div: ans = ""YES"" break print(ans)",quadratic,['implementation'],283
"import sys lines = sys.stdin.readlines() def read_a_num(line): n = int(line.strip()) return n def read_a_str(line): line = line.strip() return line def check_ticket(digits): for target in range(900): seg_i = 0 seg_sum = 0 next_flag = False for d in digits: int_d = int(d) if int_d > target: next_flag = True break elif seg_sum + int_d > target: if next_flag: break next_flag = True continue elif int_d == target or seg_sum + int_d == target: seg_i += 1 seg_sum = 0 else: seg_sum += int_d if next_flag: continue if seg_i >= 2 and seg_sum == 0: return True return False digits = read_a_str(lines[1]) if check_ticket(digits): print(""yes"") else: print(""no"")",quadratic,['implementation'],653
"import sys import argparse import json def main(): n = int(sys.stdin.readline()) ticket = sys.stdin.readline().rstrip() integers = [int(x) for x in ticket] zeros = 0 while zeros < len(integers) and integers[-1*(zeros+1)] == 0: zeros += 1 if zeros > 0 and zeros >= len(integers): integers = [] elif zeros > 0: integers = integers[:-1*zeros] if not integers: print(""YES"") return if len(integers) == 1: print(""NO"") return total = 0 for i, val in enumerate(integers[:-1]): total += val splice = integers[i+1:] if is_golden(total, splice): print(""YES"") return print(""NO"") def is_golden(total, integers): current_total = 0 for i, val in enumerate(integers): current_total += val if current_total < total: continue elif current_total == total: splice = integers[i+1:] return (not splice) or is_golden(total, splice) elif current_total > total: return False return False def get_tests(): tests = [(""5\n73452"", ""YES""), (""4\n1248"", ""NO""), (""4\n7435"", ""NO""), (""8\n0020200"", ""YES""), (""99\n999999999999999999999999999999999999999999999918888888888888888888888888888888888888888888888888887"", ""YES""), (""84\n123608423980567916563149282633127550576921328162851174479585123236498689270768303090"", ""YES""), (""2\n00"", ""YES""), (""8\n00020200"", ""YES""), (""5\n11980"", ""NO""), (""3\n100"", ""NO"")] for test in tests: print(json.dumps({""input"": test[0], ""output"": test[1]})) if __name__ == ""__main__"": parser = argparse.ArgumentParser() parser.add_argument(""--get-tests"", action=""store_true"") args = parser.parse_args() if args.get_tests: get_tests() else: main()",quadratic,['implementation'],1532
"def STR(): return list(input()) def INT(): return int(input()) def MAP(): return map(int, input().split()) def MAP2():return map(float,input().split()) def LIST(): return list(map(int, input().split())) def STRING(): return input() import string import sys from heapq import heappop , heappush from bisect import * from collections import deque , Counter , defaultdict from math import * from itertools import permutations , accumulate dx = [-1 , 1 , 0 , 0 ] dy = [0 , 0 , 1 , - 1] def solve(x , arr ): n = len(arr) flag = True k = [] i = 0 while flag: sm = 0 while n > 0 and sm < x : sm += int(arr[i]) i +=1 n -=1 if n <= 0 : flag = False break if sm>0: k.append(sm) return k n = INT() s = STR() if len(set(s)) == 1 : print('YES');exit(0) l = [] t = 0 for i in range(n-1): t += int(s[i]) l.append(t) v = [] for i in l : if i > 0 : r = solve(i , s) if len(r) > 1 and len(set(r)) == 1 : print('YES') break else: print('NO')",quadratic,['implementation'],922
"import sys from collections import deque import bisect def chk(l,r,total): b = len(l) prev = 0 i = 0 f = 1 cnt = 0 while i < b: prev = prev+l[i] if cnt == total and prev == r: i = i+1 continue if prev == r: cnt += 1 if cnt != total: prev = 0 i = i+1 if cnt < total or i != b: f = 0 return f for _ in range(1): n = int(input()) s = input() l = [] som = 0 for i in s: l.append(int(i)) som += int(i) flag = 0 for i in range(2,n+1): if som%i == 0: r = som//i if chk(l,r,i): flag = 1 break if flag: break if flag: print(""YES"") else: print(""NO"")",quadratic,['implementation'],539
"import math n=int(input()) s2=input() s2=list(s2) s=[] for i in range(n): if s2[i]=='0': continue else: s.append(int(s2[i])) s1=sum(s) n=len(s) l=[] for i in range(2,n+1): if s1%i==0: l.append(s1//i) f=0 if len(s)==0: f=1 for i in range(len(l)): c=0 if f==1: break for j in range(n): c+=s[j] if c==l[i]: c=0 if j==n-1: f=1 elif c<l[i]: c=c else: break if f==0: print('NO') else: print('YES')",quadratic,['implementation'],391
"def solve(): n = int(input()) l = list(map(int,list(input()))) divisors = [] total = sum(l) for j in range(2,int(sqrt(total))+1): if(total%j==0): divisors.extend([j,total//j]) if(total==0): print(""YES"") return if(total!=1): divisors.append(1) for x in divisors: search = x index = 0 summ = 0 while(index<n): summ+=l[index] if(summ>search): break elif(summ==search): summ = 0 index+=1 if(summ==0 and index==n): print(""YES"") return print(""NO"") import sys import math import bisect from sys import stdin,stdout from math import gcd,floor,sqrt,log from collections import defaultdict as dd from bisect import bisect_left as bl,bisect_right as br inp =lambda: int(input()) strng =lambda: input().strip() jn =lambda x,l: x.join(map(str,l)) strl =lambda: list(input().strip()) mul =lambda: map(int,input().strip().split()) mulf =lambda: map(float,input().strip().split()) seq =lambda: list(map(int,input().strip().split())) ceil =lambda x: int(x) if(x==int(x)) else int(x)+1 ceildiv=lambda x,d: x//d if(x%d==0) else x//d+1 flush =lambda: stdout.flush() stdstr =lambda: stdin.readline() stdint =lambda: int(stdin.readline()) stdpr =lambda x: stdout.write(str(x)) solve()",quadratic,['implementation'],1162
"_=input() n=input() num=int(n) list_n=list(n) list_n_int=list(map(int,n)) lower=max(list_n_int) total=sum(list_n_int) upper=int(total/2) flag=False if lower == 0: print(""YES"") else: for i in range(lower,upper+1): flag=True p=0 temp=0 each=i seg=total/each if seg.is_integer(): while p < len(n): temp+=list_n_int[p] if temp < each: p+=1 elif temp == each: temp=0 p+=1 else: flag=False break if flag: print(""YES"") break else: flag=False if not flag: print(""NO"")",quadratic,['implementation'],459
"n = int(input()) arr = [int(z) for z in list(input())] ans = 0 if n == 2: if arr[0] == arr[1]: print(""YES"") else: print(""NO"") exit() for l in range(1, n-1): s = sum(arr[:l]) i = l v = [s] curr = 0 while i < n: curr += arr[i] if i == n-1: if curr > s: curr -= arr[i] v.append(curr) curr = arr[i] v.append(curr) elif curr > s: curr -= arr[i] v.append(curr) curr = arr[i] i += 1 if len(set(v)) == 1: print(""YES"") ans = 1 exit() if not ans: print(""NO"")",quadratic,['implementation'],448
"import sys,math,bisect from random import randint inf = float('inf') mod = 998244353 ""========================================"" def lcm(a,b): return int((a/math.gcd(a,b))*b) def gcd(a,b): return int(math.gcd(a,b)) def tobinary(n): return bin(n)[2:] def binarySearch(a,x): i = bisect.bisect_left(a,x) if i!=len(a) and a[i]==x: return i else: return -1 def lowerBound(a, x): i = bisect.bisect_left(a, x) if i: return (i-1) else: return -1 def upperBound(a,x): i = bisect.bisect_right(a,x) if i!= len(a)+1 and a[i-1]==x: return (i-1) else: return -1 def primesInRange(n): ans = [] prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 for p in range(2, n+1): if prime[p]: ans.append(p) return ans def primeFactors(n): factors = [] while n % 2 == 0: factors.append(2) n = n // 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: factors.append(i) n = n // i if n > 2: factors.append(n) return factors def isPrime(n,k=5): if (n <2): return True for i in range(0,k): a = randint(1,n-1) if(pow(a,n-1,n)!=1): return False return True ""========================================="" from collections import deque,defaultdict,Counter import heapq,string n=int(input()) s=input() s=[int(i) for i in s] flag=False for i in range(0,(9*n)+1): count=0 sum = 0 for j in s: sum+=j if sum==i: count+=1 sum=0 if count>1 and sum==0: print('YES') exit(0) print('NO')",quadratic,['implementation'],1434
"n = int(input()) s = input() for sum in range(9 * n + 1): cnt = 0 cursum = 0 for i in s: cursum += int(i) if cursum == sum: cnt += 1 cursum = 0 if cursum == 0 and cnt > 1: print(""YES"") exit(0) print(""NO"")",quadratic,['implementation'],204
"n = int(input()) a = input() sum = 0 for x in a: sum += int(x) ans = ""NO"" if sum == 0: ans = ""YES"" s = 1 while s * s <= sum and ans == ""NO"": if sum % s == 0: t = 0 flag = 0 for x in a: t += int(x) if t == s: flag = 1 if t > s: if flag == 1: flag = 0 t = int(x) if t == s: flag = 1 if t == s and t != sum: ans = ""YES"" t = 0 flag = 0 for x in a: t += int(x) if t == sum // s: flag = 1 if t > sum // s: if flag == 1: flag = 0 t = int(x) if t == sum // s: flag = 1 if t == sum // s and t != sum: ans = ""YES"" s += 1 print(ans)",quadratic,['implementation'],521
"from sys import stdout, stdin, setrecursionlimit from io import BytesIO, IOBase from collections import * from itertools import * from random import * from bisect import * from string import * from queue import * from heapq import * from math import * from re import * from os import * class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") stdin, stdout = IOWrapper(stdin), IOWrapper(stdout) graph, mod, szzz = {}, 10**9 + 7, lambda: sorted(zzz()) def getStr(): return input() def getInt(): return int(input()) def listStr(): return list(input()) def getStrs(): return input().split() def isInt(s): return '0' <= s[0] <= '9' def input(): return stdin.readline().strip() def zzz(): return [int(i) for i in input().split()] def output(answer, end='\n'): stdout.write(str(answer) + end) def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2)) def lcm(xnum1,",quadratic,['implementation'],2000
"n = int(input()) A = list(map(int, input().split())) dp = [[1 for j in range(5)] for i in range(n)] Prev = [[-1 for i in range(5)] for i in range(n)] for i in range(1, n): for j in range(5): for finger in range(5): if dp[i - 1][finger] == 1: if (A[i - 1] < A[i] and finger < j) or (A[i - 1] > A[i] and finger > j) or (A[i - 1] == A[i] and finger != j): dp[i][j] = 1 Prev[i][j] = finger break else: dp[i][j] = 0 finger = 0 for j in range(5): if dp[-1][j] == 1: finger = j path = [finger] for i in range(n - 1, 0, -1): finger = Prev[i][finger] path.append(finger) path = path[::-1] for i in range(n): print(path[i] + 1, end=' ') break else: print(-1)",quadratic,"['constructive algorithms', 'dp']",648
"n = int(input()) lst = list(map(int, input().split())) cur = 1 if n == 1: print(1) exit() if lst[cur] > lst[cur - 1]: a = [1] elif lst[cur] < lst[cur - 1]: a = [5] else: a = [3] pr = False while cur != n: cnt = 0 if lst[cur] > lst[cur - 1]: while cur != n and lst[cur] > lst[cur - 1]: cnt += 1 cur += 1 for i in range(cnt - 1): a.append(a[-1] + 1) if a[-1] >= 5: print(-1) exit() if n != cur and lst[cur] == lst[cur - 1]: a.append(a[-1] + 1) else: a.append(5) elif lst[cur] < lst[cur - 1]: while cur != n and lst[cur] < lst[cur - 1]: cnt += 1 cur += 1 for i in range(cnt - 1): a.append(a[-1] - 1) if a[-1] <= 1: print(-1) exit() if n != cur and lst[cur] == lst[cur - 1]: a.append(a[-1] - 1) else: a.append(1) else: while cur != n and lst[cur] == lst[cur - 1]: cnt += 1 cur += 1 for i in range(cnt - 1): if a[-1] < 3: a.append(a[-1] + 1) else: a.append(a[-1] - 1) if cur != n and lst[cur] > lst[cur - 1]: if a[-1] == 1: a.append(2) else: a.append(1) else: if a[-1] == 5: a.append(4) else: a.append(5) print(*a)",quadratic,"['constructive algorithms', 'dp']",1009
"n = int(input()) a = list(map(int, input().split())) dp = [ [False,False,False,False,False] for _ in range(n) ] dp[0] = [True, True, True, True, True] for i in range(1, n): for j in range(5): if a[i] == a[i - 1]: for k in range(5): if k != j: dp[i][j] = dp[i][j] or dp[i - 1][k] elif a[i] > a[i - 1]: for k in range(j): dp[i][j] = dp[i][j] or dp[i - 1][k] else: for k in range(j + 1, 5): dp[i][j] = dp[i][j] or dp[i - 1][k] if dp[-1].count(True) == 0: print(-1) exit(0) j = 0 for k in range(5): if dp[-1][k]: j = k ans = [] for i in range(n - 1, -1, -1): ans.append(j + 1) if i == 0: break if a[i] == a[i - 1]: for k in range(5): if k != j and dp[i - 1][k]: j = k break elif a[i] > a[i - 1]: for k in range(j): if dp[i - 1][k]: j = k break else: for k in range(j + 1, 5): if dp[i - 1][k]: j = k break print(*ans[::-1])",quadratic,"['constructive algorithms', 'dp']",818
"from math import fabs n = int(input()) nots = [int(s) for s in input().split()] map = [0] ampl = 0 possible = True zer = False f_s = True for i in range(len(nots) - 1): if nots[i] == nots[i + 1]: if ampl != 0: map.append(ampl) if ampl <= -5 or ampl >= 5: possible = False map.append(0) zer = True ampl = 0 else: if nots[i] < nots[i + 1]: if ampl < 0 and f_s != True: map.append(ampl) if ampl == -5: possible = False ampl = 1 else: ampl += 1 else: if ampl > 0 and f_s != True: map.append(ampl) if ampl == 5: possible = False ampl = -1 else: ampl += -1 f_s = False if ampl != 0: map.append(ampl) if ampl == -5 or ampl == 5: possible = False if len(nots) == 1: map.append(0) map.append(0) if possible == True: if zer == True: l = len(map) for i in range(1, l - 1): if map[i] == 0: if map[i - 1] == 4: map[i] = -1 if map[i - 1] == -4: map[i] = 1 if map[i + 1] == 4: map[i] = -1 if map[i + 1] == -4: map[i] = 1 for i in range(1, l-1): if map[i] == 0: if map[i - 1] >= 0 and map[i + 1] >= 0: map[i] = -1 if map[i - 1] > 0 and map[i + 1] < 0: map[i] = 1 if map[i - 1] < 0 and map[i + 1] > 0: map[i] = -1 if map[i - 1] <= 0 and map[i + 1] <= 0: map[i] = 1 fin = [] ampl = map[1] for i in range(1, l - 1): if map[i] * map[i + 1] > 0: ampl += map[i + 1] if map[i] * map[i + 1] < 0: fin.append(ampl) if ampl >= 5 or ampl <= -5: possible = False ampl = map[i + 1] fin.append(ampl) if possible == True: fin[-1] = int(fabs( fin[-1] ) / fin[-1] * (fabs( fin[-1] ) + 1)) appl = [] for i in range( len(fin) ): if fin[i] > 0: for j in range(1, fin[i] + 1): appl.append(j) if fin[i] < 0: for j in range(5, 5 + fin[i], -1): appl.append(j) else: appl = [] try: map[-2] = int(fabs(map[-2]) / map[-2] * (fabs(map[-2]) + 1)) except ZeroDivisionError: appl = [1] for i in range(len(map)): if map[i] > 0: for j in range(1, map[i] + 1): appl.append(j) if map[i] < 0: for j in range(5, 5 + map[i], -1): appl.append(j) for finger in appl: print(finger, end = ' ') if possible == False: print(-1)",quadratic,"['constructive algorithms', 'dp']",1966
n = int(input()) ar = [int(i) for i in input().split()] if n == 1: print(1) exit() if ar[1] > ar[0]: li = [1] elif ar[1] < ar[0]: li = [5] else: li = [3] c = 1 while c != n: j = 0 if ar[c] > ar[c - 1]: while c != n and ar[c] > ar[c - 1]: c += 1 j += 1 for i in range(j-1): li.append(li[-1] + 1) if li[-1] == 6: print(-1) exit() if c != n and ar[c] == ar[c - 1]: li.append(li[-1] + 1) else: li.append(5) elif ar[c] < ar[c - 1]: while c != n and ar[c] < ar[c - 1]: c += 1 j += 1 for i in range(j-1): li.append(li[-1] - 1) if li[-1] == 0: print(-1) exit() if c != n and ar[c] == ar[c - 1]: li.append(li[-1] - 1) else: li.append(1) else: while c != n and ar[c] == ar[c - 1]: c += 1 j += 1 for i in range(j): if li[-1] > 3: li.append(li[-1] - 1) else: li.append(li[-1] + 1) if c != n and ar[c] > ar[c - 1]: if li[-2] == 1: li[-1] = 2 else: li[-1] = 1 elif c != n and ar[c] < ar[c - 1]: if li[-2] == 5: li[-1] = 4 else: li[-1] = 5 if max(li) > 5 or min(li) < 1: print(-1) else: print(*li),quadratic,"['constructive algorithms', 'dp']",982
"n = int(input()) melody = [int(x) for x in input().split()] ref = [[-1] * 5 for _ in range(n)] can_finish = [[False] * 5 for _ in range(n)] can_finish[0] = [True] * 5 for idx, key in enumerate(melody[:-1]): if not any(can_finish[idx]): break for finger in range(5): if melody[idx] < melody[idx + 1] and can_finish[idx][finger]: for i in range(finger + 1, 5): can_finish[idx + 1][i] = True ref[idx + 1][i] = finger break elif melody[idx] > melody[idx + 1] and can_finish[idx][finger] and finger > 0: for i in range(finger): can_finish[idx + 1][i] = True ref[idx + 1][i] = finger elif melody[idx] == melody[idx + 1] and can_finish[idx][finger]: tmp_val, tmp_ref = can_finish[idx + 1][finger], ref[idx + 1][finger] can_finish[idx + 1] = [True] * 5 ref[idx + 1] = [finger] * 5 can_finish[idx + 1][finger], ref[idx + 1][finger] = tmp_val, tmp_ref finger = next((i for i in range(5) if can_finish[n - 1][i]), None) if finger is None: print(-1) else: seq = [finger] for i in range(n - 1, 0, -1): finger = ref[i][finger] seq.append(finger) print(' '.join(str(x + 1) for x in seq[::-1]))",quadratic,"['constructive algorithms', 'dp']",1078
"n = int(input()) arr = list(map(int, input().split())) dp = [[0] * 5 for i in range(n)] dp[0] = [1, 1, 1, 1, 1] for i in range(1, n): if arr[i] > arr[i - 1]: for j in range(1, 5): dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1]) elif arr[i] < arr[i - 1]: for j in range(3, -1, -1): dp[i][j] = max(dp[i - 1][j + 1], dp[i][j + 1]) else: for j in range(5): dp[i][j] += (sum(dp[i - 1]) > 0) * (dp[i - 1][j] == 0 or sum(dp[i - 1]) > 1) if dp[-1] == [0, 0, 0, 0, 0]: print(-1) else: ans = [dp[-1].index(1) + 1] for i in range(n - 2, -1, -1): for j in range(5): if dp[i][j] > 0 and ((j + 1 > ans[-1] and arr[i] > arr[i + 1]) or (j + 1 < ans[-1] and arr[i] < arr[i + 1]) or (j + 1 != ans[-1] and arr[i] == arr[i + 1])): ans.append(j + 1) break print(*reversed(ans))",quadratic,"['constructive algorithms', 'dp']",755
"import sys if __name__ == '__main__': cin = sys.stdin n = int(next(cin)) a = list(map(int, next(cin).split())) n2idx = {a[i]: i for i in range(n)} f = [False] * (n+1) for i in range(n, 0, -1): idx_lg = n2idx[i] win_flag = False for j in range(idx_lg%i, n, i): if a[j] > i and not f[a[j]]: win_flag = True break f[i] = win_flag f = ''.join(['A' if f[a_i] else 'B' for a_i in a]) print(f, flush=True)",quadratic,"['brute force', 'dp', 'games']",398
"n=int(input()) L=list(map(int,input().split())) ans=['']*n revL=[0]*n ans[-1]='B' for i in range(n): revL[L[i]-1]=i+1 for i in range(n-2,-1,-1): t=revL[i]-1 counter='B' for j in range(t,-1,-i-1): if j==t:continue if ans[L[j]-1]=='B': counter='A' break if counter!='A': for k in range(t,n,i+1): if k==t:continue if ans[L[k]-1]=='B': counter='A' break ans[i]=counter for i in range(n): print(ans[L[i]-1],sep='',end='')",quadratic,"['brute force', 'dp', 'games']",416
"n=int(raw_input()) arr=list(map(int,raw_input().split())) dict1={} arr1=[0]*n for i in range(n): arr1[arr[i]-1]=i for i in range(n): dict1[i+1]=[] for i in range(n): for j in range(i-arr[i],-1,-arr[i]): if(arr[j]>arr[i]): dict1[arr[i]].append(arr[j]) for j in range(i+arr[i],n,arr[i]): if(arr[j]>arr[i]): dict1[arr[i]].append(arr[j]) strarr=['.']*n for i in range(n-1,-1,-1): if(len(dict1[arr[arr1[i]]])==0): strarr[arr1[i]]='B' else: if(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0): strarr[arr1[i]]='A' else: flag=0 for j in dict1[arr[arr1[i]]]: if(strarr[arr1[j-1]]=='B'): flag=1 break if(flag==1): strarr[arr1[i]]='A' else: strarr[arr1[i]]='B' print("""".join(x for x in strarr))",quadratic,"['brute force', 'dp', 'games']",706
"n = int(input()) a = [int(i) for i in input().split()] indx = [0] * n winners = [''] * n for i, ai in enumerate(a): indx[ai-1] = i for ai in range(n, 0, -1): i = indx[ai-1] can_win = False for j in range(i + ai, n, ai): if a[j] > ai and 'B' == winners[j]: can_win = True break if not can_win: for j in range(i - ai, -1, -ai): if a[j] > ai and 'B' == winners[j]: can_win = True break if can_win: winners[i] = 'A' else: winners[i] = 'B' print(''.join(winners))",quadratic,"['brute force', 'dp', 'games']",458
"n = int(input()) arr = list(map(int, input().split())) memo = [-1 for i in range(n+1)] def can_win(idx): if memo[idx] != -1: return memo[idx] res = False delta = arr[idx] nidx = idx + delta while nidx < n: if arr[nidx] > arr[idx] and not can_win(nidx): res = True break nidx += delta nidx = idx - delta while not res and nidx >= 0: if arr[nidx] > arr[idx] and not can_win(nidx): res = True break nidx -= delta memo[idx] = res return res ans = ['A' if can_win(i) else 'B' for i in range(n)] print(''.join(ans))",quadratic,"['brute force', 'dp', 'games']",509
"import collections import sys def can_win(i, dp): if i in dp: return dp[i] else: for next in possible[i]: if not can_win(next, dp): dp[i] = True return True dp[i] = False return False data = sys.stdin.readlines() nb = int(data[0]) nums = data[1].split(' ') nums = [int(c) for c in nums] possible = [[] for _ in range(nb)] for i in range(nb): if nums[i] == 1: possible[i] = [k for k in range(nb) if k != i] else: for j in range(i+nums[i], nb, nums[i]): if nums[j] > nums[i]: possible[i].append(j) for j in range(i-nums[i], -1, -nums[i]): if nums[j] > nums[i]: possible[i].append(j) res = """" dp = {} for i in range(nb): if can_win(i, dp): res += ""A"" else: res += ""B"" print(res)",quadratic,"['brute force', 'dp', 'games']",675
"from operator import itemgetter n = int(input()) ai = list(map(int,input().split())) ai2 = [[ai[i], i] for i in range(n)] answer = [0] * n ai2.sort(key = itemgetter(0)) answer[ai2[0][1]] = 1 answer[ai2[-1][1]] = 0 for i in range(n-2,0,-1): num = ai2[i][1] % ai2[i][0] for j in range(num,n,ai2[i][0]): if ai[j] > ai2[i][0] and answer[j] == 0: answer[ai2[i][1]] = 1 break for i in range(n): if answer[i] == 1: print(""A"",end="""") else: print(""B"",end="""")",quadratic,"['brute force', 'dp', 'games']",449
"a = int(input()) lister = input().split() lister = [int(i) for i in lister] ans = dict() def findans(n): if n in ans: return ans[n] mod = n%lister[n] ok = True if n + lister[n] >= a and n - lister[n] < 0: ok = False else: for i in range(mod, a, lister[n]): if i != n and lister[i] > lister[n]: ok = ok and findans(i) ok = not(ok) ans[n] = ok return ok for i in range(len(lister)): findans(i) level = [] for i in range(a): if ans[i] == True: level.append('A') else: level.append('B') print(''.join(level))",quadratic,"['brute force', 'dp', 'games']",504
"n = int(input()) a = [int(x) for x in input().split()] a_reverse = a.copy() status = [] for i in range(n): a_reverse[a[i]-1] = i status.append(None) pos = a_reverse[n-1] status[pos] = False fails = set() fails.add(pos) for i in range(n-1,0,-1): i_ = i-1 pos = a_reverse[i_] for k in range((pos+1)%i-1,n,i): if k == pos: continue if k in fails: status[pos] = True break if not status[pos]: status[pos] = False fails.add(pos) result = """" for i in status: if i == True: result=result+""A"" else: result=result+""B"" print(result)",quadratic,"['brute force', 'dp', 'games']",522
"n = int(input()) a = [int(x) for x in input().split()] h = [-1]*(n) b = [(a[i],i) for i in range(n)] b.sort(reverse=True) for e in b: num,idx = e flag = True allNeg = True foundLosing = False foundWin = False for i in range(idx%num,n,num): if i == idx: continue if h[i]!= -1: allNeg = False if h[i] == 0: foundLosing = True break if h[i] == 1: foundWin = False if allNeg: h[idx] = 0 elif foundLosing: h[idx] = 1 else: h[idx] = 0 for i in range(n): if h[i]==0: print('B',end='') else: print('A',end='')",quadratic,"['brute force', 'dp', 'games']",501
"n = int(input()) l = [*map(int, input().split())] p = [0] * n for i in range(n): p[l[i] - 1] = i res = ['?'] * n for e in range(n, 0, -1): i = p[e - 1] res[i] = 'B' for j in range(i % e, n, e): if i != j and l[i] <= l[j] and res[j] == 'B': res[i] = 'A' break print(''.join(res))",quadratic,"['brute force', 'dp', 'games']",278
"n=int(input()) a=[*map(int,input().split())] b=[0]*n s=[0]*n m=n while m: for i,x in enumerate(a): if s[i]==0: r=range(i%x,n,x) if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1 if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1 print(''.join(s))",quadratic,"['brute force', 'dp', 'games']",251
"n=int(input()) a=[*map(int,input().split())] s=[0]*n m=n while m: for i,x in enumerate(a): if s[i]==0: r=range(i%x,n,x) if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1 if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1 print(''.join(s))",quadratic,"['brute force', 'dp', 'games']",243
"n=int(input()) a=[*map(int,input().split())] s=[0]*n m=n while m: for i,x in enumerate(a): if s[i]==0: r=range(i%x,n,x) if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1 elif any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1 print(''.join(s))",quadratic,"['brute force', 'dp', 'games']",245
"n=int(input()) a=[*map(int,input().split())] s=[0]*n m=n while m: for i,x in enumerate(a): r=range(i%x,n,x) if s[i]==0: if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1 if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1 print(''.join(s))",quadratic,"['brute force', 'dp', 'games']",243
"from queue import Queue n = int(input()) g = [set() for i in range(n+1)] for i in range(n-1): u, v = map(int, input().split()) g[u].add(v) g[v].add(u) a = list(map(int, input().split())) if a[0] != 1: print(""No"") exit() ptr = 0 i = 1 while i < n: par = a[ptr] while len(g[par]) != 0: if a[i] not in g[par]: print(""No"") exit() else: g[par].remove(a[i]) g[a[i]].remove(par) i += 1 ptr += 1 print(""Yes"")",quadratic,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",400
"from itertools import groupby n = int(input()) l = list(map(int, input().split())) r = list(map(int, input().split())) sums = [(a + b, ind) for (ind, (a, b)) in enumerate(zip(l, r))] sums.sort() answer = [None] * n curr_candies = n for key, group in groupby(sums, key=lambda i: i[0]): for elem in group: answer[elem[1]] = curr_candies curr_candies -= 1 tl = [] for i in range(n): cnt = 0 for j in range(i): if answer[j] > answer[i]: cnt += 1 tl.append(cnt) tr = [] for i in range(n): cnt = 0 for j in range(i + 1, n): if answer[j] > answer[i]: cnt += 1 tr.append(cnt) if tl != l or tr != r: print(""NO"") else: print(""YES"") print(' '.join(map(str, answer)))",quadratic,"['constructive algorithms', 'implementation']",655
"import collections, atexit, math, sys, bisect sys.setrecursionlimit(1000000) def getIntList(): return list(map(int, input().split())) try : import numpy def dprint(*args, **kwargs): print(*args, **kwargs, file=sys.stderr) dprint('debug mode') except Exception: def dprint(*args, **kwargs): pass inId = 0 outId = 0 if inId>0: dprint('use input', inId) sys.stdin = open('input'+ str(inId) + '.txt', 'r') if outId>0: dprint('use output', outId) sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') atexit.register(lambda :sys.stdout.close()) N, = getIntList() zl = getIntList() zr = getIntList() zt = [ (zl[i] + zr[i], i) for i in range(N) ] zt.sort() za = [0 for i in range(N) ] now = N for i in range(N): if i>0 and zt[i-1][0] <zt[i][0]: now-=1 za[ zt[i][1] ] = now for i in range(N): l = 0 r = 0 for j in range(i): if za[j] > za[i]: l+=1 for j in range(i+1, N): if za[j] > za[i]: r+=1 if zl[i] != l or zr[i] != r: print('NO') sys.exit() print('YES') for i in range(N): print(za[i],end = ' ')",quadratic,"['constructive algorithms', 'implementation']",992
"n = input() l = map(int, raw_input().split()) r = map(int, raw_input().split()) mp = {i:i for i in range(n)} out = [-1]*n v = 0 a = n done = set() while v < n: ids = set() for j in range(n): if l[j] == r[j] == 0 and j not in done: ids.add(j) done.add(j) if len(ids) == 0: print('NO') exit() v += len(ids) for i in ids: out[mp[i]] = a for j in range(len(l)): if j < i: r[j] -= 1 else: l[j] -= 1 a -= 1 print('YES') print(' '.join(map(str, out)))",quadratic,"['constructive algorithms', 'implementation']",444
"n = int(input()) L = list(map(int, input().split("" ""))) R = list(map(int, input().split("" ""))) LR = list(zip(L,R)) index_to_candies = {} candy = n for nn in range(n,0,-1): if(len(index_to_candies) == n): break zero_index = [] for idx, (l,r) in enumerate(LR): if (l,r) == (0,0) and not idx in index_to_candies: index_to_candies[idx] = nn zero_index.append(idx) if len(zero_index) == 0: print(""NO"") exit() dec_left = 0 dec_right = len(zero_index) zero_index_idx = 0 for idx, (l,r) in enumerate(LR): if zero_index_idx < len(zero_index) and zero_index[zero_index_idx] == idx: zero_index_idx += 1 dec_left += 1 dec_right -= 1 if (l,r) != (0,0): LR[idx] = (l-dec_left,r-dec_right) if LR[idx][0] < 0 or LR[idx][1] < 0: print(""NO"") exit() print(""YES"") j = [] for i in range(n): j.append(str(index_to_candies[i])) print("" "".join(j))",quadratic,"['constructive algorithms', 'implementation']",823
"n=int(input()) a=list(map(int,input().split())) b=list(map(int,input().split())) s=[0]*n ans=True for i in range(n): ans=ans and a[i]<=i and b[i]<=(n-i-1) s[i]=n-a[i]-b[i] def qwe(s,j): l,r=0,0 for i in range(len(s)): if i<j and s[i]>s[j]: l+=1 elif i>j and s[i]>s[j]: r+=1 return l,r if ans: for i in range(n): l,r=qwe(s,i) ans=ans and a[i]==l and b[i]==r if ans: print('YES') for i in range(n): print(n-a[i]-b[i],end=' ') else: print('NO')",quadratic,"['constructive algorithms', 'implementation']",441
"n=int(input()) l=list(map(int,input().split())) r=list(map(int,input().split())) a=[[l[i]+r[i],i] for i in range(n)] a.sort() candies=[0 for i in range(n)] if(a[0][0] != 0): print('NO') exit() else: candies[a[0][1]] = n - a[0][0] for i in range(1,n): if(a[i][0] != a[i-1][0] and a[i][0]!=i): print('NO') exit() candies[a[i][1]] = n - a[i][0] for i in range(n): l1=0 r1=0 for j in range(i): if(candies[j]>candies[i]): l1+=1 for j in range(i+1,n): if(candies[j]>candies[i]): r1+=1 if(l1 != l[i] or r1 != r[i]): print('NO') exit() print('YES') print(*candies)",quadratic,"['constructive algorithms', 'implementation']",556
"n=int(input()) l=list(map(int,input().split())) r=list(map(int,input().split())) candies=[] for i in range(n): candies.append(n-l[i]-r[i]) left=[] for i in range(n): guys=0 for j in range(i): if candies[j]>candies[i]: guys+=1 left.append(guys) right=[] for i in range(n): guys=0 for j in range(i,n): if candies[j]>candies[i]: guys+=1 right.append(guys) if left==l and right==r: print(""YES"") candiesstr="""" for i in range(n): candiesstr+=str(candies[i])+"" "" print(candiesstr[:len(candiesstr)-1]) else: print(""NO"")",quadratic,"['constructive algorithms', 'implementation']",511
"n = int(input()) l = list(map(int, input().split())) r = list(map(int, input().split())) ans = [1 for i in range(n)] s = [l[i] + r[i] for i in range(n)] order = [i for i in range(n)] for i in range(n-1): m = i for j in range(i+1,n): if s[m] < s[j]: m = j t = s[i] s[i] = s[m] s[m] = t t = order[i] order[i] = order[m] order[m] = t cur = 1 for i in range(1,n): if s[i-1] > s[i]: cur += 1 ans[order[i]] = cur for i in range(n): k = 0 for j in range(i): if ans[j] > ans[i]: k += 1 if l[i] != k: print('NO') exit() k = 0 for j in range(i+1,n): if ans[j] > ans[i]: k += 1 if r[i] != k: print('NO') exit() print('YES') for i in ans: print(i, end=' ')",quadratic,"['constructive algorithms', 'implementation']",644
"import sys n = int(input()) l = list(map(int, input().split())) r = list(map(int, input().split())) res = [0] * n for i in range(n): res[i] = n - l[i] - r[i] for i in range(n): ok = 0 for j in range(i): if res[j] > res[i]: ok += 1 if ok != l[i]: print(""NO"") sys.exit(0) ok = 0 for j in range(i + 1, n): if res[j] > res[i]: ok += 1 if ok != r[i]: print(""NO"") sys.exit(0) print(""YES"") print(' '.join(map(str, res)))",quadratic,"['constructive algorithms', 'implementation']",413
"n = int(input()) flag = True l , r = list(map(int,input().split())) , list(map(int,input().split())) ans , check_l , check_r = [n for i in range(n)] , [0 for i in range(n)] , [0 for i in range(n)] for i in range(n): ans[i] -= l[i]+r[i] for i in range(n): cl , cr = 0 , 0 for j in range(i): if ans[j] > ans[i]: cl += 1 for j in range(i+1,n): if ans[j] > ans[i]: cr += 1 if cl != l[i] or cr!=r[i]: flag = False break mini = min(ans) - 1 for i in range(n): ans[i] -= mini if flag: print(""YES"") for i in ans: print(i,end= ' ') else: print(""NO"")",quadratic,"['constructive algorithms', 'implementation']",540
"n = int(input()) l = list(map(int, input().split())) r = list(map(int, input().split())) fl = 0 m = n s = list(range(n)) for i in range(n): s[i] = m - (l[i] + r[i]) if fl != 1 and s[i] == m: fl = 1 for i in range(n): ll = 0; for j in range(i): if s[j] > s[i]: ll += 1 rr = 0 for j in range(i + 1, n): if s[j] > s[i]: rr += 1 if l[i] != ll or rr != r[i]: fl = 0 break if fl == 1 and l[0] == 0 and r[n - 1] == 0: print('YES') print(*s) else: print('NO')",quadratic,"['constructive algorithms', 'implementation']",451
"n=int(input()) l=list(map(int,input().split())) r=list(map(int,input().split())) cost=[(l[i]+r[i],i) for i in range(n)] cost.sort() CANDIES=[None]*n CANDIES[cost[0][1]]=n candy=n for i in range(1,n): if cost[i][0]==cost[i-1][0]: CANDIES[cost[i][1]]=candy else: candy-=1 CANDIES[cost[i][1]]=candy check=1 for i in range(n): lc=0 rc=0 for j in range(i): if CANDIES[j]>CANDIES[i]: lc+=1 for j in range(i+1,n): if CANDIES[j]>CANDIES[i]: rc+=1 if lc!=l[i] or rc!=r[i]: check=0 if check==1: print(""YES"") for c in CANDIES: print(c,end="" "") else: print(""NO"")",quadratic,"['constructive algorithms', 'implementation']",550
"n=int(input()) l=list(map(int,input().split())) r=list(map(int,input().split())) c=[n]*n for i in range(n): c[i]-=(r[i]+l[i]) for i in range(n): m=0 for j in range(0,i): if c[j]>c[i]: m+=1 if m!=l[i]: exit(print('NO')) for i in range(n): m=0 for j in range(i+1,n): if c[j]>c[i]: m+=1 if m!=r[i]: exit(print('NO')) print('YES') print(*(c))",quadratic,"['constructive algorithms', 'implementation']",338
"N = int(input()) L = [int(s) for s in input().split("" "")] R = [int(s) for s in input().split("" "")] C = [N - L[i] - R[i] for i in range(0, N)] for i, x in enumerate(C): if C[i] <= 0: print(""NO"") exit() l = 0 r = 0 j = i-1 while j >= 0: if C[j] > C[i]: l = l + 1 j = j - 1 j = i+1 while j < N: if C[j] > C[i]: r = r + 1 j = j + 1 if L[i] != l or R[i] != r: print(""NO"") exit() print(""YES"") for i in range(0, N-1): print(C[i], end="" "") print(C[N-1])",quadratic,"['constructive algorithms', 'implementation']",445
"def main(): n = int(input()) left = [int(x) for x in input().strip().split()] right = [int(x) for x in input().strip().split()] rank = [x + y for (x,y) in zip(left,right)] arr = [(n - r) for r in rank] for i in range(n): more = 0 for j in range(i): if arr[j] > arr[i]: more += 1 if more != left[i]: print('NO') return for i in range(n): more = 0 for j in range(i+1,n): if arr[j] > arr[i]: more += 1 if more != right[i]: print('NO') return print('YES') for x in arr: print(x, end=' ') print() if __name__ == '__main__': main()",quadratic,"['constructive algorithms', 'implementation']",525
"n = int(input()) L = [int(i) for i in input().split()] R = [int(i) for i in input().split()] E = [] otv = [0] * n for i in range(n): sum_ = L[i] + R[i] E.append([sum_, i]) E.sort() for i in range(n): x = R[i] for j in range(n): if (x > 0): if (E[j][1] > i): otv[E[j][1]] += 1 x -= 1 else: break if (x > 0): print(""NO"") exit() x = L[i] for j in range(n): if (x > 0): if (E[j][1] < i): otv[E[j][1]] += 1 x -= 1 else: break if (x > 0): print(""NO"") exit() for i in range(n): r = 0 l = 0 for j in range(i + 1, n): if (otv[j] > otv[i]): r += 1 for z in range(i - 1, -1, -1): if (otv[z] > otv[i]): l += 1 if (r != R[i]) or (l != L[i]): print(""NO"") exit() print(""YES"") for i in range(n): print(otv[i] + 1, end = ' ')",quadratic,"['constructive algorithms', 'implementation']",708
"n=int(input()) l=list(map(int,input().split())) r=list(map(int,input().split())) if l[0]!=0 or r[n-1]!=0: print(""NO"") exit(0) s=[(l[i]+r[i]) for i in range(n)] m=max(s)+1 k=[] for i in s: k.append(m-i) l1=[] r1=[] for i in range(n): c=0 d=0 for j in range(0,i): if k[j]>k[i]: c+=1 l1.append(c) for j in range(i+1,n): if k[j]>k[i]: d+=1 r1.append(d) if l1!=l or r1!=r: print(""NO"") else: print(""YES"") print(*k)",quadratic,"['constructive algorithms', 'implementation']",408
"import collections def main(): n = int(input()) left = list(map(int, input().split())) right = list(map(int, input().split())) res = [0] * n val = n if all(not left[i] and not right[i] for i in range(n)): print(""YES"") print(' '.join(['1'] * n)) return while not all(not left[i] and not right[i] for i in range(n)): zeroSet = set() for i in range(n): if not left[i] and not right[i] and res[i] == 0: zeroSet.add(i) res[i] = val for v in zeroSet: for i in range(v + 1, n): if i not in zeroSet and res[i] == 0: left[i] -= 1 for i in range(v): if i not in zeroSet and res[i] == 0: right[i] -= 1 val -= 1 if not zeroSet: print(""NO"") return for i in range(n): if not res[i]: res[i] = str(val) else: res[i] = str(res[i]) if any(i == '0' for i in res): print(""NO"") return print(""YES"") print(' '.join(res)) main()",quadratic,"['constructive algorithms', 'implementation']",804
"n=int(input()) l=list(map(int, input().split())) r=list(map(int, input().split())) maxx=0 s=[] it=0 for i in range(n): s.append(l[i]+r[i]) if l[i]>i or r[i]>n-i-1: it=1 its=list(s) while maxx<n: summ=0 ll=0 rr=its.count(-1) for i in range(n): if its[i]==-1: ll+=1 rr-=1 if its[i]!=-1 and i<n-1 and r[i]<rr: it=1 break if its[i]!=-1 and i>0 and l[i]<ll: it=1 break if it==1: break for i in range(n): if s[i]==maxx: s[i]=-maxx its[i]=-1 summ+=1 if summ==0: it=1 break maxx+=summ if it==1: print('NO') else: print('YES') for i in s: print(i-min(s)+1, end=' ')",quadratic,"['constructive algorithms', 'implementation']",556
"def lr(a): l = [0] * len(a) r = [0] * len(a) for i in range(len(a)): for j in range(i+1, len(a)): if a[j] > a[i]: r[i] += 1 if a[i] > a[j]: l[j] += 1 return l, r n = int(input()) l = [int(i) for i in input().split()] r = [int(i) for i in input().split()] a = [0] * n for i in range(n): for j in range(n): if l[j] + r[j] == i: a[j] = n-i l1, r1 = lr(a) if l1 != l or r1 != r: print(""NO"") else: print(""YES"") print(' '.join([str(i) for i in a]))",quadratic,"['constructive algorithms', 'implementation']",442
"n = int(input()) l = list(map(int, input().split("" ""))) r = list(map(int, input().split("" ""))) slr = [l[i]+r[i] for i in range(n)] ans = [n-slr[i] for i in range(n)] flag = True if l[0]!=0 or r[n-1]!=0: flag= False for i in range(n): great = 0 for j in range(i+1, n): if ans[i]<ans[j]: great = great + 1 if r[i]!=great: flag = False break for i in range(n-1, -1, -1): great = 0 for j in range(i-1, -1, -1): if ans[i]<ans[j]: great = great + 1 if l[i]!=great: flag = False break if flag: print(""YES"") for i in range(0, n-1): print(ans[i], end="" "") print(ans[n-1]) else: print(""NO"")",quadratic,"['constructive algorithms', 'implementation']",580
"n=int(input()) le=[int(i) for i in input().split()] ri=[int(i) for i in input().split()] notp = False check=[] for i in range(n): check.append(n-le[i]-ri[i]) for i in range(n): tot=0 for j in range(i-1,-1,-1): if(check[j]>check[i]): tot+=1 if(tot!=le[i]): notp=True break if(notp==False): for i in range(n): tot=0 for j in range(i+1,n): if(check[j]>check[i]): tot+=1 if(tot!=ri[i]): notp=True break if(notp): print('NO') else: print('YES') print(*check)",quadratic,"['constructive algorithms', 'implementation']",453
"n = int(input()) l = [int(i) for i in input().split()] r = [int(i) for i in input().split()] items = [(-l[i]-r[i],i) for i in range(n)] items.sort() vals = [1] * n m = 1 for i in range(1, n): if items[i-1][0] != items[i][0]: m += 1 vals[items[i][1]] = m for i in range(n): ln = sum(map(lambda x: x-vals[i] > 0, vals[:i])) lr = sum(map(lambda x: x-vals[i] > 0, vals[i:])) if ln != l[i] or lr != r[i]: print('NO') break else: print('YES') print(' '.join(str(i) for i in vals))",quadratic,"['constructive algorithms', 'implementation']",474
"def main(): def update(l, r, i, res): j = 0 while j < i: if res[j] is None: r[j] -= 1 if r[j] < 0: return False j += 1 j += 1 while j < n: if res[j] is None: l[j] -= 1 if l[j] < 0: return False j += 1 return True ilist = {1} n = int(input()) res = [None] * n cur = n l = [int(x) for x in input().split()] r = [int(x) for x in input().split()] while ilist and (sum(l) != 0 or sum(r) != 0): ilist = set() for i in range(n): if l[i] == r[i] == 0 and res[i] is None: res[i] = cur ilist.add(i) for i in ilist: check = update(l, r, i, res) if not check: return False cur -= 1 if not ilist: return False for i in range(n): if res[i] is None: res[i] = cur return res if __name__ == '__main__': res = main() if not res: print('NO') else: print('YES') for x in res: print(x, end=' ')",quadratic,"['constructive algorithms', 'implementation']",773
"def get_input_list(): return list(map(int, input().split())) n = int(input()) l = get_input_list() r = get_input_list() a = [0 for _ in range(n)] m = [] m_ = [] for i in range(n): m.append(l[i] + r[i]) m_.append(l[i] + r[i]) m.sort() ma = m[-1] + 1 for i in range(n): a[i] = ma - m_[i] l_ = [] r_ = [] for i in range(n): c = 0 d = 0 for j in range(i+1): if a[j] > a[i]: c += 1 for j in range(i,n): if a[j] > a[i]: d += 1 l_.append(c) r_.append(d) res = True for i in range(n): if l[i] != l_[i] or r[i] != r_[i]: res = False break if res: print(""YES"") for i in range(n): a[i] = str(a[i]) print("" "".join(a)) else: print(""NO"")",quadratic,"['constructive algorithms', 'implementation']",623
"n = int(input()) a = list(map(int, input().split())) s = list(map(int, input().split())) d = [] for q in range(n): d.append(a[q]+s[q]) d = [n-q for q in d] for q in range(n): f = 0 for q1 in range(q): if d[q1] > d[q]: f += 1 g = 0 for q1 in range(q+1, n): if d[q1] > d[q]: g += 1 if f != a[q] or g != s[q]: print('NO') break else: print('YES') print(*d)",quadratic,"['constructive algorithms', 'implementation']",353
"R = lambda: map(int, input().split()) n = int(input()) arr1 = tuple(R()) arr2 = tuple(R()) d = dict() ans = [0]*n for i in range(n): d[i] = [arr1[i], arr2[i]] def run(): for nn in range(n, 0, -1): s = list() for i in d: if d[i][0] == d[i][1] == 0: s.append(i) ans[i] = nn if s: for i in s: del d[i] for i in d: l = r = 0 for j in s: if j < i: l += 1 else: r += 1 if d[i][0] >= l: d[i][0] -= l else: return if d[i][1] >= r: d[i][1] -= r else: return else: return run() if 0 in ans: print('NO') else: print('YES') print(*ans, sep=' ')",quadratic,"['constructive algorithms', 'implementation']",532
"import math as ma import sys from sys import exit from decimal import Decimal as dec from itertools import permutations def li(): return list(map(int , input().split())) def num(): return map(int , input().split()) def nu(): return int(input()) def find_gcd(x , y): while (y): x , y = y , x % y return x n=nu() a=li() b=li() z=[] for i in range(n): z.append((a[i]+b[i],i)) z.sort() fl=True x=[] cc=0 xp=0 mp={} np=[] for i in range(n): if(a[i]>i): fl=False if(b[i]>(n-i-1)): fl=False if((n-a[i]-b[i])<=0): fl=False if(fl==False): print(""NO"") else: zz=[0]*n for i in range(n): zz[i]=(n-a[i]-b[i]) for i in range(n): xl = 0 xr = 0 for j in range(i + 1 , n): if (zz[j] > zz[i]): xr += 1 for j in range(i - 1 , -1 , -1): if (zz[j] > zz[i]): xl += 1 if (xl != a[i] or xr != b[i]): fl = False break if (fl == True): print(""YES"") print(*zz) else: print(""NO"")",quadratic,"['constructive algorithms', 'implementation']",851
"import collections import sys N = int(input()) p = [int(x) for x in input().split()] G = collections.defaultdict(list) for i, v in enumerate(p): u = i + 2 G[u].append(v) G[v].append(u) root = 1 colors = [0] * (N + 1) counts = [0] * (N + 1) q = [root] parents = [0] * (N+1) vis = [0] * (N+1) while q: u = q.pop() if vis[u]: colors[parents[u]] += colors[u] continue children = [v for v in G[u] if v != parents[u]] for v in children: parents[v] = u if children: vis[u] = True q.append(u) q.extend(children) else: vis[u] = True colors[u] = 1 colors[parents[u]] += 1 colors = colors[1:] colors.sort() print(' '.join(map(str, colors)))",quadratic,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",629
"n=int(input()) if n==1: print(1) else: p=list(map(int,input().split())) children=[] for i in range(n): children.append([]) for i in range(n-1): children[p[i]-1].append(i+1) layers=[1]+[0]*(n-1) layer=[0] num=2 bylayer=[] while len(layer)>0: bylayer.append(layer) newlayer=[] for vert in layer: for child in children[vert]: layers[child]=num newlayer.append(child) layer=newlayer num+=1 bylayer=bylayer[::-1] count=[0]*n for layer in bylayer: for vert in layer: if children[vert]==[]: count[vert]=1 else: count[vert]=sum(count[v] for v in children[vert]) count.sort() out="""" for guy in count: out+=str(guy)+"" "" print(out)",quadratic,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",620
"import sys input=sys.stdin.readline from collections import defaultdict graph=defaultdict(list) n=int(input()) par=[ int(i) for i in input().split() if i!='\n'] bulb=[1]*(n+1) for i in range(n-1): bulb[par[i]]=0 graph[par[i]].append(i+2) zero=bulb.count(0) for i in range(n,0,-1): if bulb[i]==0: count=0 for j in graph[i]: count+=bulb[j] bulb[i]=count bulb=bulb[1:] bulb.sort() sys.stdout.write(' '.join(map(str,bulb)))",quadratic,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",419
"import sys input=sys.stdin.readline from collections import defaultdict graph=defaultdict(list) n=int(input()) par=[ int(i) for i in input().split() if i!='\n'] bulb=[1]*(n+1) for i in range(n-1): bulb[par[i]]=0 graph[par[i]].append(i+2) zero=bulb.count(0) for i in range(n,0,-1): if bulb[i]==0: count=0 for j in graph[i]: count+=bulb[j] bulb[i]=count bulb=bulb[1:] bulb.sort() sys.stdout.write(' '.join(map(str,bulb)))",quadratic,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",419
"import sys import threading inp = sys.stdin.buffer.readline input = lambda: sys.stdin.readline().rstrip() def I(): return list(map(int,inp().split())) def main(): n,=I() ; vis=[0]*n ; st=[0]*n if n==1: print(1) exit(0) def dfs(g,e): if vis[e]==1: return else: vis[e]=1 for i in g[e]: dfs(g,i) if len(g[e])==1 and e!=0: st[e]+=1 for i in g[e]: st[e]+=st[i] a=[int(i)-1 for i in input().split()] g=[[] for i in range(n)] for i in range(n-1): g[i+1].append(a[i]) g[a[i]].append(i+1) dfs(g,0) st.sort() print(*st) sys.setrecursionlimit(2097152) threading.stack_size(134217728) main_thread = threading.Thread(target=main) main_thread.start() main_thread.join()",quadratic,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",655
"import sys import threading def dfs(g, i, p): global ans count = 0 for j in g[i]: if j == p: continue count += dfs(g, j, i) if count == 0: count = 1 ans.append(count) return count def solve(): n = int(input()) l = list(map(int, input().split())) g = [[] for i in range(n+1)] for i in range(1, n): g[i+1].append(l[i-1]) g[l[i-1]].append(i+1) dfs(g, 1, 0) ans.sort() st = ' '.join(map(str, ans)) print(st) ans = [] max_recur_size = 10**5*2 + 1000 max_stack_size = max_recur_size*500 sys.setrecursionlimit(max_recur_size) threading.stack_size(max_stack_size) thread = threading.Thread(target=solve) thread.start()",quadratic,"['constructive algorithms', 'dfs and similar', 'dp', 'graphs', 'greedy', 'sortings', 'trees']",610
"n, m = [int(i) for i in input().split()] A = [] ct = [] for i in range(n): x = list(input()) y = [0]*m A.append(x) ct.append(y) ok = 1 for i in range(n-2): for j in range(m-2): if A[i][j]==' ct[i][j] = 1 ct[i][j+1] = 1 ct[i][j+2] = 1 ct[i+1][j] = 1 ct[i+1][j+2] = 1 ct[i+2][j] = 1 ct[i+2][j+1] = 1 ct[i+2][j+2] = 1 xct = 0 xhs = 0 for i in range(len(ct)): for j in range(len(ct[i])): if ct[i][j] == 1: xct+=1 if A[i][j] == ' xhs+=1 if xhs==xct: print('YES') else: print('NO')",quadratic,['implementation'],475
"def isValid(field, y, x): for i in range(3): for j in range(3): if i == 1 and j == 1: continue if field[y + i][x + j] == '.': return False return True def fill(field, y, x): for i in range(3): for j in range(3): if i == 1 and j == 1: continue cur[y + i][x + j] = ' n, m = list(map(int, input().split())) sig = [] cur = [] for i in range(n): sig += [list(input())] cur += [["".""] * m] for i in range(n - 2): for j in range(m - 2): if isValid(sig, i, j): fill(cur, i, j) if sig == cur: print(""YES"") else: print(""NO"")",quadratic,['implementation'],513
"def main(): n, m = map(int, input().split()) a = [] for i in range(n): s = input() b = [] for l in s: b.append(l) a.append(b) for i in range(1, n - 1): for j in range(1, m - 1): may = True if (a[i][j - 1] == '.' or a[i][j + 1] == '.' or a[i + 1][j - 1] == '.' or a[i + 1][j + 1] == '.' or a[i + 1][j] == '.' or a[i - 1][j - 1] == '.' or a[i - 1][j + 1] == '.' or a[i - 1][j] == '.'): may = False if (may): a[i][j - 1] = a[i][j + 1] = a[i + 1][j - 1] = a[i + 1][j + 1] = a[i + 1][j] = a[i - 1][j - 1] = a[i - 1][j + 1] = a[i - 1][j] = '?' for i in range(n): for j in range(m): if (a[i][j] == ' print(""NO"") return print(""YES"") main()",quadratic,['implementation'],631
"import sys def solve(n, m, grid): for i, row in enumerate(grid): for j, cell in enumerate(row): if cell == 0: continue must = cell == 1 if i >= n - 2 or j >= m - 2: if must: return 'NO' continue for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]: if grid[i + di][j + dj] == 0: if must: return 'NO' break else: for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]: grid[i + di][j + dj] = 2 grid[i][j] = 2 return 'YES' n, m = list(map(int, input().split())) grid = [['. print(solve(n, m, grid))",quadratic,['implementation'],530
"n, m = map(int, input().split()) mp = [] for i in range(n): line = input().strip() mp.append(list(map(lambda c: c == ' mp1 = [[False for _ in range(m)] for _ in range(n)] for i in range(1, n - 1): for j in range(1, m - 1): f = all(mp[i - 1][j - k] for k in range(-1, 1+1)) f = f and all(mp[i + 1][j - k] for k in range(-1, 1+1)) f = f and (mp[i][j - 1] and mp[i][j + 1]) if not f: continue for ik in range(-1, 2): for jk in range(-1, 2): if ik == 0 and jk == 0: continue mp1[i + ik][j + jk] = True if all(all(mp[i][j] == mp1[i][j] for j in range(m)) for i in range(n)): print('YES') else: print('NO')",quadratic,['implementation'],600
"n, m = map(int, input().split()) u = [] u1 = [] for i in range(n): u.append(list(input())) u1.append(['.'] * m) for i in range(n - 2): for j in range(m - 2): ok = True for k in range(3): if u[i][j + k] != ' ok = False break if ok: if u[i + 2][j + 1] != ' ok = False else: for k in range(3): u1[i][j + k] = ' u1[i + k][j] = ' u1[i + 2][j + 1] = ' u1[i + 2][j + 2] = ' u1[i + 1][j + 2] = ' ok = True for i in range(n): for j in range(m): if u[i][j] != u1[i][j]: ok = False break if not ok: break if ok: print('YES') else: print('NO')",quadratic,['implementation'],531
"n,m=map(int,input().split()) s=[] st=set() cst=set() for i in range(n): s.append(input()) for j in range(len(s[i])): if s[i][j]==' st.add((i,j)) for i in range(1,n-1): for j in range(1,m-1): if s[i-1][j-1]!=' continue if s[i - 1][j ] != ' continue if s[i-1][j+1]!=' continue if s[i][j-1]!=' continue if s[i][j+1]!=' continue if s[i+1][j-1]!=' continue if s[i+1][j]!=' continue if s[i+1][j+1]!=' continue cst.add((i-1,j)) cst.add((i - 1, j-1)) cst.add((i - 1, j+1)) cst.add((i + 1, j)) cst.add((i + 1, j-1)) cst.add((i + 1, j+1)) cst.add((i , j+1)) cst.add((i , j-1)) if len(cst)==len(st): print('YES') else: print('NO')",quadratic,['implementation'],619
"import math import sys DEBUG = False def inp(): return sys.stdin.readline().rstrip() def dprint(*value, sep=' ', end='\n'): if DEBUG: print(*value, sep=sep, end=end) def solve(H, W, A): visited = [bytearray(W) for _ in range(H)] for y in range(H): for x in range(W): if A[y][x] == '.' or visited[y][x]: continue dprint(x, y) for dx, dy in [(0, 0), (-1, 0), (-2, 0), (0, -1), (-2, -1), (0, -2), (-1, -2), (-2, -2)]: tx = x + dx ty = y + dy dprint(' ', tx, ty) if tx < 0 or ty < 0 or tx + 2 >= W or ty + 2 >= H: continue bad = False for ex, ey in [(0, 0), (1, 0), (2, 0), (0, 1), (2, 1), (0, 2), (1, 2), (2, 2)]: nx = tx + ex ny = ty + ey if A[ny][nx] == '.': bad = True break if bad: continue for ex, ey in [(0, 0), (1, 0), (2, 0), (0, 1), (2, 1), (0, 2), (1, 2), (2, 2)]: nx = tx + ex ny = ty + ey visited[ny][nx] = 1 assert visited[ny][nx] == 1 break if visited[y][x] == 0: return False return True def main(): H, W = [int(e) for e in inp().split()] A = [inp() for _ in range(H)] print('YES' if solve(H, W, A) else 'NO') if __name__ == '__main__': main()",quadratic,['implementation'],1055
"n,m=map(int,raw_input().split()) arr=[] arr1=[] for i in range(n): arr2=str(raw_input()) arr.append(arr2) x1=[0]*m arr1.append(x1) for i in range(n): for j in range(m): if(arr[i][j]==' if(arr[i][j+1]==' arr1[i][j]=1 arr1[i+1][j]=1 arr1[i+2][j]=1 arr1[i+2][j+1]=1 arr1[i+2][j+2]=1 arr1[i+1][j+2]=1 arr1[i][j+1]=1 arr1[i][j+2]=1 flag=0 for i in range(n): for j in range(m): if(arr[i][j]=="" flag=1 break if(flag==1): break if(flag==1): print(""NO"") else: print(""YES"")",quadratic,['implementation'],463
"import sys import copy lines = iter(sys.stdin) def nexts(): return next(lines) def nextint(): return int(nexts()) def snexts(): return next(lines).split(' ') def snextint(): return map(int, snexts()) def array(length, base=0): return [base] * length def matrix(length, width, base=0): return [[base] * width for _ in range(length)] n, m = snextint() grid = array(n, []) for i in range(n): grid[i] = list(nexts()) grid2 = copy.deepcopy(grid) for i in range(1, n - 1): for j in range(1, m - 1): if grid[i - 1][j] == ' grid2[i - 1][j] = '.' grid2[i - 1][j + 1] = '.' grid2[i][j + 1] = '.' grid2[i + 1][j + 1] = '.' grid2[i + 1][j] = '.' grid2[i + 1][j - 1] = '.' grid2[i][j - 1] = '.' grid2[i - 1][j - 1] = '.' match = True for i in grid2: for ch in i: if ch == ' match = False break if match: print('YES') else: print('NO')",quadratic,['implementation'],821
"n,m=map(int,input().split()) MAP=[list(input()) for i in range(n)] ANSMAP=[[""."" for i in range(m)] for j in range(n)] for i in range(1,n-1): for j in range(1,m-1): if MAP[i-1][j-1]=="" ANSMAP[i-1][j-1] ="" ANSMAP[i-1][j]="" ANSMAP[i-1][j+1]="" ANSMAP[i][j-1]="" ANSMAP[i][j+1]="" ANSMAP[i+1][j-1]="" ANSMAP[i+1][j]="" ANSMAP[i+1][j+1]="" if MAP==ANSMAP: print(""YES"") else: print(""NO"")",quadratic,['implementation'],375
"N, M = map(int, input().split()) grid = [] for _ in range(N): grid.append(list(input())) def check(grid, i, j, sx, sy): if i - sx >= 0 and j - sy >= 0 and i + 2 - sx < N and j + 2 - sy < M: i -= sx j -= sy v = grid[i][j] == ' return v return False prev = False for m in range(M): for n in range(N): if grid[n][m] == ' if not (check(grid, n, m, 0, 0) or check(grid, n, m, 1, 0) or check(grid, n, m, 2, 0) or check(grid, n, m, 0, 1) or check(grid, n, m, 2, 1) or check(grid, n, m, 0, 2) or check(grid, n, m, 1, 2) or check(grid, n, m, 2, 2)): print(""NO"") exit(0) print(""YES"")",quadratic,['implementation'],573
"from math import ceil, sqrt t = 1 for test in range(1,t+1): n,m = (map(int, input().split())) arr = [[""."" for i in range(m)] for i in range(n)] arr2 = [] for i in range(n): arr2.append(list(input())) for i in range(1,n-1): for j in range(1,m-1): if arr2[i+1][j] == arr2[i][j+1]==arr2[i+1][j+1]==arr2[i-1][j]==arr2[i][j-1]==arr2[i-1][j-1]==arr2[i+1][j-1]==arr2[i-1][j+1]=="" arr[i+1][j] = arr[i][j+1]=arr[i+1][j+1]=arr[i-1][j]=arr[i][j-1]=arr[i-1][j-1]=arr[i+1][j-1]=arr[i-1][j+1]="" if arr == arr2: print(""YES"") else: print(""NO"")",quadratic,['implementation'],527
"n,m=[int(x) for x in input().split()] s=[] for i in range(n): s.append(input()) mapp=[[False]*m for i in range(n)] rnd=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)) def gene(x,y,p): cx=x-rnd[p][0] cy=y-rnd[p][1] ans=[] for i in range(8): ans.append((cx+rnd[i][0],cy+rnd[i][1])) return ans def judge(ps): for x,y in ps: if x>=0 and x<n and y>=0 and y<m and s[x][y]==' continue else: return False return True def dye(ps): global mapp for x,y in ps: mapp[x][y]=True def check(x,y): for i in range(8): r=gene(x,y,i) if judge(r): dye(r) return True return False for i in range(n): for j in range(m): if s[i][j]==' if check(i,j): continue else: print('NO') quit() print('YES')",quadratic,['implementation'],680
"n,m=map(int,raw_input().split()) l=[] for i in range(n): s=raw_input() l.append([]) for j in range(m): l[-1].append(s[j]) ans=[] for i in range(n): ans.append([]) for j in range(m): ans[-1].append(""."") for i in range(n-2): for j in range(m-2): if l[i][j]=="" if l[i][j]==l[i][j+1] and l[i][j]==l[i][j+2] and l[i][j]==l[i+1][j] and l[i][j]==l[i+1][j+2] and l[i][j]==l[i+2][j] and l[i][j]==l[i+2][j+1] and l[i][j]==l[i+2][j+2]: ans[i][j]="" ans[i][j+1]="" ans[i][j+2]="" ans[i+1][j]="" ans[i+1][j+2]="" ans[i+2][j]="" ans[i+2][j+1]="" ans[i+2][j+2]="" flag = True for i in range(n): for j in range(m): if l[i][j]!=ans[i][j]: flag = False break if flag==False: break if flag==True: print(""YES"") else: print(""NO"")",quadratic,['implementation'],700
"n,m = map(int, input().split()) a = [] for i in range(n): s = input() a.append(s) for i in range(n): for j in range(m): if a[i][j] == '.': continue if i >= 2 and j >= 2: if a[i-2][j-2] == ' and a[i-1][j] == ' continue if i >= 1 and i <= n-2 and j >= 2 and a[i-1][j-2] == ' and a[i][j-2] == ' continue if i <= n-3 and j >= 2 and a[i][j-1] == ' and a[i+1][j-2] == ' continue if i <= n-3 and j >= 1 and j <= m-2 and a[i][j-1] == ' and a[i+1][j+1] == ' continue if i <= n-3 and j <= m-3 and a[i][j+1] == ' and a[i+1][j+2] == ' continue if i <= n-2 and i >= 1 and j <= m-3 and a[i-1][j] == ' and a[i][j+2] == ' continue if i >= 2 and j <= m-3 and a[i-2][j] == ' and a[i-1][j] == ' continue if i >= 2 and j <= m-2 and j >= 1 and a[i-2][j-1] == ' and a[i-1][j-1] == ' continue print('NO') exit() print('YES')",quadratic,['implementation'],801
"import sys def rint(): return map(int, sys.stdin.readline().split()) def writable(r, c): if r+2 >= n or c+2 >= m: return False t = set() t.add(cells[r][c]) t.add(cells[r][c+1]) t.add(cells[r][c+2]) t.add(cells[r+1][c]) t.add(cells[r+1][c+2]) t.add(cells[r+2][c]) t.add(cells[r+2][c+1]) t.add(cells[r+2][c+2]) return not '.' in t def fill_ink(r,c): paper[r][c] = "" paper[r][c+1] = "" paper[r][c+2] = "" paper[r+1][c] = "" paper[r+1][c+2] = "" paper[r+2][c] = "" paper[r+2][c+1] = "" paper[r+2][c+2] = "" n, m = rint() cells = [] for i in range(n): cells.append(input()) paper = [[""."" for j in range(m)] for i in range(n)] for r in range(n): for c in range(m): if writable(r,c) is True: fill_ink(r, c) for r in range(n): for c in range(m): if cells[r][c] != paper[r][c]: print(""NO"") exit() print(""YES"")",quadratic,['implementation'],793
"n,m=map(int,input().split()) dp=[[-1 for i in range(m)] for j in range(n)] dp2=[[-1 for i in range(m)] for j in range(n)] for i in range(0,n): s=input() for j in range(0,m): if(s[j]=='.'): dp[i][j]=-1 else: dp[i][j]=s[j] for i in range(0,n-2): for j in range(0,m-2): p=0 c=0 for k in range(i,i+3): for h in range(j,j+3): p=p+1 if(p!=5): if(dp[k][h]==' c=c+1 if(c==8): p=0 for k in range(i,i+3): for h in range(j,j+3): p=p+1 if(p!=5): dp2[k][h]=' if(dp==dp2): print('YES') else: print('NO')",quadratic,['implementation'],489
"n,m=map(int,input().split()) s=[] for i in range(n): s.append(list(map(str,input().strip()))) t=[] for i in range(n): p=['.']*m t.append(p) for i in range(1,n-1): for j in range(1,m-1): f=0 if s[i-1][j-1]==' f=1 if f==1: t[i-1][j-1]=' t[i-1][j]=' t[i-1][j+1]=' t[i][j-1]=' t[i][j+1]=' t[i+1][j-1]=' t[i+1][j]=' t[i+1][j+1]=' f=1 for i in range(n): for j in range(m): if s[i][j]==' f=0 break if f==0: break if f==1: print(""YES"") else: print(""NO"")",quadratic,['implementation'],445
"n,m = [int(i) for i in input().split()] b=[] a=[] for i in range(n): b.append([i for i in input()]) a.append([0 for i in range(m)]) def check(e,r,q): if e>=0 and r>=0 and e+2<n and r+2<m: if b[e][r]==' a[e][r]==1 a[e+1][r]==1 a[e+2][r]==1 a[e+2][r+1]==1 a[e+2][r+2]==1 a[e+1][r+2]==1 a[e][r+2]==1 a[e][r+1]==1 return True if q ==1: return False return check(e,r-1,1) or check(e,r-2,1) or check(e-1,r-2,1) or check(e-2,r-2,1) or check(e-2,r-1,1) or check(e-2,r,1) or check(e-1,r,1) for i in range(n): for j in range(m): if b[i][j]==' if (not check(i,j,0)) and a[i][j]==0: print(""NO"") exit() print(""YES"")",quadratic,['implementation'],602
"def color8(i,j,ip): if i>n-3 or j>m-3: return else: ip[i][j]=' ip[i][j+1]=' ip[i][j+2]=' ip[i+1][j]=' ip[i+1][j+2]=' ip[i+2][j]=' ip[i+2][j+1]=' ip[i+2][j+2]=' n,m=map(int,input().split()) ip=[] op=[['.' for i in range(m)] for j in range(n)] b=0 for i in range(n): ip.append(str(input())) for i in range(n): for j in range(m): if ip[i][j]==' try: if ip[i+2][j+2]==' temp=(ip[i][j]==' if temp==True: color8(i,j,op) except: pass for i in range(n): if ''.join(op[i])!=ip[i]: print('NO') b=1 break if b==0: print('YES')",quadratic,['implementation'],515
"import sys; def transform(c): if c == '.': return 0; if c == ' return 2; def take_care(board,n,m): if n + 2 >= N: return; if m + 2 >= M: return; if board[n][m+1] == 0 or board[n][m+2] == 0 or board[n+1][m] == 0 or board[n+1][m+2] == 0 or board[n+2][m] == 0 or board[n+2][m+1] == 0 or board[n+2][m+2] == 0: return; board[n][m] = 2 board[n][m+1] = 2 board[n][m+2] = 2 board[n+1][m] = 2 board[n+1][m+2] = 2 board[n+2][m] = 2 board[n+2][m+1] = 2 board[n+2][m+2] = 2 return False,board; N,M = [int(i) for i in input().strip().split()]; board = []; for n in range(N): row = input().strip(); row = [ transform(c) for c in row]; board.append(row); for n in range(N): for m in range(M): take_care(board,n,m); for row in board: if 1 in row: print('NO'); sys.exit(); print('YES');",quadratic,['implementation'],769
"n, m = [int(x) for x in input().split()] mat = [] v = [] for i in range(n): mat.append([x == ' v.append([False]*m) def check(m, v, x, y): for i in (-1,0,1): for j in (-1,0,1): if (i,j) == (0,0): continue if not m[x+i][y+j]: return for i in (-1,0,1): for j in (-1,0,1): if (i,j) != (0,0): v[x+i][y+j] = True for x in range(1, n-1): for y in range(1,m-1): check(mat, v, x, y) flag = True for i in range(0,n): for j in range(0,m): if mat[i][j] and (not v[i][j]): flag = False if flag: print(""YES"") else: print(""NO"")",quadratic,['implementation'],512
"n, m = list(map(int, input().split())) cl = [] for i in range(n): cl.append(input()) def is_squad(x, y): if cl[x][y]==' return True else: return False def cv(x, y): counter = 0 if x-2>=0 and y+2<=m-1 and is_squad(x-2, y): return True elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y): return True elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y): return True elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1): return True elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2): return True elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2): return True elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2): return True elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1): return True else: return False for i in range(n): for j in range(m): if cl[i][j]==' if not cv(i, j): print('NO') exit() print('YES')",quadratic,['implementation'],819
"n,m=map(int,input().split()) a=[list('') for x in range(n)] b=[list('.'*m) for x in range(n)] start=0 for i in range(n): a[i]=list(input()) if (start==0): if ('.' in a[i]): start=((i-3)//3) *3 for i in range(start): b[i]=list(' for i in range(start,n-2): for j in range(m-2): ok=True if a[i][j]==' for y in range(i,i+3): if ok==False: break for x in range(j,j+3): if not((y==i+1)and(x==j+1)): if a[y][x]!=' ok=False break if ok: for y in range(i,i+3): for x in range(j,j+3): if not((y==i+1)and(x==j+1)): b[y][x]=' if a==b: print('YES') else: print('NO')",quadratic,['implementation'],553
"n, m = map(int, input().split()) a = [] array = [] for i in range(n): a.append(list(map(str, input()))) listt = [] for c in range(m): if a[i][c] == ' listt.append(1) else: listt.append(0) array.append(listt) for y in range(1, n - 1): for x in range(1, m - 1): f = a[y + 1][x] == ' s = a[y][x + 1] == ' th = a[y - 1][x] == ' if f and s and th: array[y + 1][x] -= 1 array[y + 1][x + 1] -= 1 array[y + 1][x - 1] -= 1 array[y][x + 1] -= 1 array[y][x - 1] -= 1 array[y - 1][x - 1] -= 1 array[y - 1][x] -= 1 array[y - 1][x + 1] -= 1 mb = True for y in range(n): for x in range(m): if array[y][x] == 1: mb = False break if mb: print(""YES"") else: print(""NO"")",quadratic,['implementation'],650
"import sys m,n = [int(i) for i in input().split(' ')] l = [[] for _ in range(m)] for i in range(m): l[i] = input() inks = [] for i in range(1, m-1): for j in range(1, n-1): if l[i-1][j-1] == ' inks += [(i-1,j-1),(i,j-1),(i+1,j-1), (i-1,j ) ,(i+1,j ), (i-1,j+1),(i,j+1),(i+1,j+1),] for i in range(m): for j in range(n): if l[i][j] == ' print(""NO"") sys.exit() else: print(""YES"")",quadratic,['implementation'],376
"import math as ma import sys from sys import exit from decimal import Decimal as dec from itertools import permutations def li(): return list(map(int , input().split())) def modInverse(a , m): m0 = m y = 0 x = 1 if (m == 1): return 0 while (a > 1): q = a // m t = m m = a % m a = t t = y y = x - q * y x = t if (x < 0): x = x + m0 return x def num(): return map(int , input().split()) def nu(): return int(input()) def find_gcd(x , y): while (y): x , y = y , x % y return x n,m=num() a=[0]*n for i in range(n): a[i]=[0]*m for i in range(n): s=input() for j in range(m): a[i][j]=s[j] z=["".""]*n for i in range(n): z[i]=["".""]*m for i in range(n): for j in range(m): if(j-1>=0 and j+1 <m and i+1<n and i-1>=0): if(a[i-1][j]=="" z[i-1][j]="" z[i + 1][j] = "" z[i][j - 1] = "" z[i][j + 1] = "" z[i - 1][j - 1] = "" z[i - 1][j + 1] = "" z[i + 1][j - 1] = "" z[i + 1][j + 1] = "" ff=True for i in range(n): for j in range(m): if(z[i][j]!=a[i][j]): ff=False break if(ff): print(""YES"") else: print(""NO"")",quadratic,['implementation'],984
"D = False def hash(r,c): return str(r) + ""-"" + str(c) def sol(): R, C = [int(x) for x in input().split("" "")] m = [] count = 0 for _ in range(R): line = input() m.append(line) count += line.count("" if D: print(""Count:"", count) lookup = {} for r in range(1, R-1): for c in range(1, C-1): if D: print("" row,col:"", r, c) offset = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)] lst = [] fail = False for o in offset: cell = (r + o[0], c + o[1]) if D: print("" cell:"", cell, m[cell[0]][cell[1]]) h = hash(cell[0], cell[1]) if m[cell[0]][cell[1]] == "" if (not h in lookup): lst.append(h) else: fail = True break if not fail: for item in lst: lookup[item] = True count -= len(lst) return ""YES"" if count == 0 else ""NO"" ans = sol() print(ans)",quadratic,['implementation'],740
"n = int(input()) a = list(map(int, input().split()))[::-1] b = list(map(int, input().split())) ans = [0] * n marked = [True] * (n + 1) for i in range(n): if marked[b[i]]: while True: marked[a[-1]] = False ans[i] += 1 if a[-1] == b[i]: a.pop() break a.pop() else: continue print(*ans)",quadratic,"['implementation', 'math']",283
"n, m = map(int, input().split()) a = list(map(int, input().split())) t = list(map(int, input().split())) ans = [0] * m p = [] for i in range(n + m): if t[i] == 1: p.append(i) ans[0] = p[0] for i in range(m): if i == m - 1: ans[i] += n + m - p[i] - 1 else: for j in range(p[i] + 1, p[i + 1]): if a[j] - a[p[i]] <= a[p[i + 1]] - a[j]: ans[i] += 1 else: ans[i + 1] += 1 print(' '.join(map(str, ans)))",quadratic,"['implementation', 'sortings']",397
"n, m = [int(x) for x in input().split()] xs = [int(x) for x in input().split()] ts = [int(x) for x in input().split()] taxi_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 1]) passenger_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 0]) a_is = [0] * len(taxi_idx) t_idx = 0 p_idx = 0 while True: if p_idx >= len(passenger_idx): break if t_idx == len(taxi_idx) - 1: a_is[t_idx] += 1 else: while t_idx < len(taxi_idx) - 1: d1 = abs(passenger_idx[p_idx] - taxi_idx[t_idx]) d2 = abs(passenger_idx[p_idx] - taxi_idx[t_idx + 1]) if d1 > d2: t_idx += 1 else: break a_is[t_idx] += 1 p_idx += 1 print(' '.join([str(x) for x in a_is]))",quadratic,"['implementation', 'sortings']",650
"n,m=map(int,input().split()) a=list(map(int,input().split())) b=list(map(int,input().split())) def next(k,a): i=k+1 while a[i]!=1: i+=1 return i ans=[0]*(m+1) k=-1 k=next(k,b) ans[1]=k for i in range(2,m+1): kk=next(k,b) for j in range(k+1,kk): if a[j]-a[k]<=a[kk]-a[j]: ans[i-1]+=1 else: ans[i]+=1 k=kk ans[m]+=(n+m-1-k) for i in range(1,m+1): print(ans[i],end=' ')",quadratic,"['implementation', 'sortings']",366
"n, m = list(map(int,input().split())) x = list(map(int,input().split())) t = list(map(int,input().split())) arr = [] pep = {} for i in range(n+m): if t[i] == 0: arr.append(i) pep[x[i]] = 0 else: for j in arr: pep[x[j]] = i arr = [] for i in range(n+m-1, -1, -1): if t[i] == 0: arr.append(i) else: for j in arr: if abs(x[j] - x[i]) <= abs(x[pep[x[j]]] - x[j]): pep[x[j]] = i arr = [] ans = [] for i in range(n+m): if t[i]: ans.append(1) else: ans.append(0) for i in pep: ans[pep[i]] += 1 for i in ans: if i: print(i-1, end = ' ')",quadratic,"['implementation', 'sortings']",528
"n=int(input()) l=[int(c) for c in input().split()] ll=[] res=[] head=0 dia=0 for i in range(1,n): if l[i]==1: l[i]=0 ll.append(i) else: res.append((head+1,i+1)) l[head]-=1 dia+=1 head=i l[head]-=1 if l[head]>0 and len(ll)>0: res.append((ll[0]+1,head+1)) l[head]-=1 del(ll[0]) dia+=1 if l[0]>0 and len(ll)>0: res.append((ll[0]+1,1)) l[0]-=1 del(ll[0]) dia+=1 for i in ll: for j in range(n): if l[j]>0: res.append((j+1,i+1)) l[j]-=1 break if len(res)<n-1: print(""NO"") else: print(""YES ""+str(dia)) print(n-1) for p in res: print(p[0],end ="" "") print(p[1])",quadratic,"['constructive algorithms', 'graphs', 'implementation']",552
"from collections import namedtuple vertex = namedtuple('vertex', ['degree', 'id']) a, b, c = [], [], 0 n = int(input()) rr = list(map(int, input().split())) for i in range(n): if rr[i] > 1: a.append(vertex(rr[i], i + 1)) else: b.append(vertex(rr[i], i + 1)) c += rr[i] if c < (n - 1)*2: print('NO') else: print('YES', len(a) - 1 + min(2, len(b))) print(n - 1) for i in range(1,len(a)): print(a[i - 1].id, a[i].id) if len(b) > 0: print(b[0].id, a[0].id) if len(b) > 1: print(b[1].id, a[-1].id) j, yes = 2, 0 for i in range(len(a)): k = a[i].degree - 2 for t in range(k): if j >= len(b): yes = 1 break print(a[i].id, b[j].id) j += 1 if yes == 1: break",quadratic,"['constructive algorithms', 'graphs', 'implementation']",649
"n = int(input()) a, edge = [0], [] last, sum, ans = 0, 0, 0 for i in map(int, input().split()) : a.append(i) sum += i for i in range(1, n + 1) : if(a[i] == 1) : last = i a[last] = 0 for i in range(1, n + 1) : if(a[i] > 1) : if(last) : edge.append([last, i]) ans += 1 last = i for i in range(1, n + 1) : if(a[i] == 1 and last) : edge.append([last, i]) last = 0 a[i] = 0 ans += 1 for i in range(1, n + 1) : for j in range(1, n + 1) : if(a[j] == 1 and a[i] > 2) : edge.append([i, j]) a[i] -= 1 a[j] -= 1 if(len(edge) != n - 1) : print(""NO"") else : print(""YES"", ans) print(len(edge)) for i in edge : print(i[0], i[1])",quadratic,"['constructive algorithms', 'graphs', 'implementation']",613
"n = int(input()) a = list(map(int, input().split())) if sum(a) < (2 * n) - 2: print(""NO"") else: one = [] rst = [] for i in range(0, n): if a[i] > 1: rst.append(i) else: one.append(i) ans = [] for i in range(1, len(rst)): ans.append((rst[i], rst[i - 1])) a[rst[i]] -= 1 a[rst[i - 1]] -= 1 for i in range(1, len(one)): for j in range(0, len(rst)): if a[rst[j]] > 0: a[rst[j]] -= 1 ans.append((rst[j], one[i])) break if len(one): for i in range(len(rst) - 1, -1, -1): if a[rst[i]] > 0: ans.append((rst[i], one[0])) break siz = min(len(one) + len(rst), 2 + len(rst)) - 1 print(""YES "", siz) print(len(ans)) for u,v in ans: print(u + 1,v + 1)",quadratic,"['constructive algorithms', 'graphs', 'implementation']",636
"x1, y1 = map(int, input().split()) x2, y2 = map(int, input().split()) x3, y3 = map(int, input().split()) points = [(x1, y1), (x2, y2), (y3, x3)] def gen_points(A, B): return [(A[0], B[1]), (B[0], A[1])] points += gen_points([x1, y1], [x2, y2]) points += gen_points([x2, y2], [x3, y3]) points += gen_points([x1, y1], [x3, y3]) points = list(set(points)) ans = 1e9 ans_l = [] def mark_points(A, B): A = list(A) B = list(B) d = set() x_s = 1 if A[0] < B[0] else -1 y_s = 1 if A[1] < B[1] else -1 d.add((A[0], A[1])) while A[0] != B[0]: A[0] += x_s d.add((A[0], A[1])) while A[1] != B[1]: A[1] += y_s d.add((A[0], A[1])) return d for el in points: d = mark_points([x1, y1], el).union(mark_points([x2, y2], el)) d = d.union(mark_points([x3, y3], el)) if len(d) < ans: ans = len(d) ans_l = d print(ans) for el in ans_l: print(*el)",quadratic,"['greedy', 'implementation']",824
"n, v = map(int, input().split()) cur = 0 total = 0 for i in range(n): while cur < n - i - 1: cur += 1 total += (i + 1) if cur == v: break cur -= 1 print(total)",quadratic,"['dp', 'greedy', 'math']",159
"n, v = map(int, input().split()) b = 0 ans = 0 sss = 0 for i in range(1, n + 1): while b < v: if sss == n - 1: break sss += 1 ans += i b += 1 b -= 1 print(ans)",quadratic,"['dp', 'greedy', 'math']",159
"def stones_after(n, s): for i in s: if i == '-': n -= 1 else: n += 1 if n < 0: return -1 return n n = int(input().strip()) s = input().strip() ans = 99999999 for i in range(n+1): stones = stones_after(i, s) if stones != -1: ans = min(ans, stones) print(ans)",quadratic,"['implementation', 'math']",257
def main(): n = int(input()) s = input() for i in range(n+1): flag = True stones = i for j in s: if j == '-': if stones > 0: stones -= 1 else: flag = False break else: stones += 1 if flag: n = i break stones = n for i in s: if i == '-': stones -= 1 else: stones += 1 print(stones) main(),quadratic,"['implementation', 'math']",287
"n, k = map( int, input().split() ) d = n - k d = d // 2 l = [] while n > 0: i = min(n,d) while i>0: l.append('1') i -= 1 n -= 1 if n > 0: l.append('0') n -= 1 print( """".join( l ) )",quadratic,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",180
"n, e = map( int, input().split() ) d = (n - e) // 2 q = [] while n > 0: i = min(n, d) while i > 0: q.append('1') i -= 1 n -= 1 if n > 0: q.append('0') n -= 1 print( """".join(q) )",quadratic,"['brute force', 'greedy', 'constructive algorithms', 'math', 'strings']",177
"import os import sys from io import BytesIO, IOBase import math from collections import defaultdict, deque import random BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") n, k = map(int, input().split("" "")) ans = [] for i in range(1, n*k + 1): if i%2: x,y = divmod(i//2, k) ans.append([x+1, y+1]) else: x,y = divmod(n*k-i//2, k) ans.append([x + 1, y + 1]) for i in ans: sys.stdout.write('{} {}\n'.format(*i))",quadratic,['constructive algorithms'],1703
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def main(): n,m=map(int,input().split()) ans=[];moves=n*m; c1=[1,1];c2=[n,m];p=0 while moves>0: if p%2==0: ans.append(tuple(c1)) c1[1]+=1 if c1[1]>m: c1[0]+=1;c1[1]=1 else: ans.append(tuple(c2)) c2[1]-=1 if c2[1]<1: c2[0]-=1;c2[1]=m moves-=1;p+=1 for i in ans: print(*i) main()",quadratic,['constructive algorithms'],1674
"import sys n,m=map(int,input().split()) for i in range(n//2): for j in range(m): sys.stdout.write('{} {}\n'.format(*[i+1,j+1])) sys.stdout.write('{} {}\n'.format(*[n-i,m-j])) if n%2: for j in range(m//2): sys.stdout.write('{} {}\n'.format(*[n//2+1,j+1])) sys.stdout.write('{} {}\n'.format(*[n//2+1,m-j])) if m%2: sys.stdout.write('{} {}\n'.format(*[n//2+1,m//2+1]))",quadratic,['constructive algorithms'],365
"(x, y) = list(map(int, input().split(' '))) a = 0 b = x * y pos = True for t in reversed(range(b)): b -= 1 print(str(int(a / y + 1)) + ' '+ str(int(a % y + 1))) a += b * (1 if pos else -1) pos = not pos",quadratic,['constructive algorithms'],202
"import os import sys from io import BytesIO, IOBase def main(): n,m=map(int,input().split()) s,e,ans=[1,1],[n,m],[] for i in range(n*m//2): ans.append(s[:]) ans.append(e[:]) s[1],e[1]=s[1]+1,e[1]-1 if s[1]==m+1: s=[s[0]+1,1] if not e[1]: e=[e[0]-1,m] if (n*m)&1: ans.append([s[0],s[1]]) for i in ans: print(*i) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",quadratic,['constructive algorithms'],1689
"n, m=[int(k) for k in input().split()] res=[] for j in range(n//2): for k in range(m): res.append(str(j+1)+"" ""+str(k+1)) res.append(str(n-j)+"" ""+str(m-k)) if n%2: for j in range(m//2): res.append(f""{n//2+1} {j+1}"") res.append(f""{n//2+1} {m-j}"") if m%2: res.append(f""{n//2+1} {m//2+1}"") print(""\n"".join(res))",quadratic,['constructive algorithms'],307
"import sys,atexit from io import BytesIO inp = BytesIO(sys.stdin.buffer.read()) input = lambda:inp.readline().decode('ascii') buf = BytesIO() sys.stdout.write = lambda s: buf.write(s.encode('ascii')) atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue())) n,m = map(int,input().split()) if m%2 == 0: steps = [] for j in range(m//2): for i in range(n): steps.append((j,i)) steps.append((m-j-1,n-i-1)) else: steps = [] for j in range(m//2): for i in range(n): steps.append((j,i)) steps.append((m-j-1,n-i-1)) l = 0 r = n-1 mid = m//2 while l<=r: steps.append((mid,l)) if l != r: steps.append((mid,r)) l += 1 r -= 1 for x,y in steps: print(y+1,x+1)",quadratic,['constructive algorithms'],656
"import sys input = sys.stdin.readline n,m=map(int,input().split()) ANS=[] for i in range(1,n//2+1): for j in range(1,m+1): sys.stdout.write("""".join((str(i),"" "",str(j),""\n""))) sys.stdout.write("""".join((str(n-i+1),"" "",str(m-j+1),""\n""))) if n%2==1: for j in range(1,m//2+1): sys.stdout.write("""".join((str(n//2+1),"" "",str(j),""\n""))) sys.stdout.write("""".join((str(n//2+1),"" "",str(m-j+1),""\n""))) if m%2==1: sys.stdout.write("""".join((str(n//2+1),"" "",str(m//2+1),""\n"")))",quadratic,['constructive algorithms'],462
"import sys input = sys.stdin.readline n,m=map(int,input().split()) ANS=[] for i in range(1,n//2+1): for j in range(1,m+1): sys.stdout.write((str(i)+"" ""+str(j)+""\n"")) sys.stdout.write((str(n-i+1)+"" ""+str(m-j+1)+""\n"")) if n%2==1: for j in range(1,m//2+1): sys.stdout.write((str(n//2+1)+"" ""+str(j)+""\n"")) sys.stdout.write((str(n//2+1)+"" ""+str(m-j+1)+""\n"")) if m%2==1: sys.stdout.write((str(n//2+1)+"" ""+str(m//2+1)+""\n""))",quadratic,['constructive algorithms'],417
"def main(): n, m = map(int, input().split()) r = [] rappend = r.append for i in range(1, (n >> 1) + 1): for j in range(1, m + 1): rappend(str(i) + ' ' + str(j)) rappend(str(n + 1 - i) + ' ' + str(m + 1 - j)) if n & 1: for i in range(1, (m >> 1) + 1): rappend(str((n + 1) >> 1) + ' ' + str(i)) rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i)) if m & 1: rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1)) print('\n'.join(r)) main()",quadratic,['constructive algorithms'],432
"import sys N, M = map(int, input().split()) Ans = [(0, 0) for _ in range(N*M)] for i in range(1, N*M+1): if i % 2: a, b = divmod(i//2, M) else: a, b = divmod(N*M - i//2, M) Ans[i-1] = ' '.join((str(a+1), str(b+1))) for a in Ans: sys.stdout.write(f'{a}\n')",quadratic,['constructive algorithms'],255
"import sys N, M = map(int, input().split()) Ans = [(0, 0) for _ in range(N*M)] for i in range(1, N*M+1): if i % 2: a, b = divmod(i//2, M) else: a, b = divmod(N*M - i//2, M) Ans[i-1] = (a+1, b+1) for a in Ans: sys.stdout.write('{} {}\n'.format(*a))",quadratic,['constructive algorithms'],247
"import sys N, M = map(int, input().split()) Ans = [None]*(N*M) for i in range(1, N*M+1): if i % 2: a, b = divmod(i//2, M) else: a, b = divmod(N*M - i//2, M) Ans[i-1] = (a+1, b+1) for a in Ans: sys.stdout.write('{} {}\n'.format(*a))",quadratic,['constructive algorithms'],231
"from sys import stdout N,M=map(int,input().split()) if M%2==0 and N%2==0: for m in range (1,M//2+1): for n in range (1,N+1): stdout.write(str(n)+' '+str(m)+'\n') stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n') elif M%2==0 and N%2==1: for m in range (1,M//2+1): for i in range (1,N+1): stdout.write(str(i)+' '+str(m)+'\n') stdout.write(str(N+1-i)+' '+str(M+1-m)+'\n') else: for m in range (1,(M+1)//2): for n in range (1,N+1): stdout.write(str(n)+' '+str(m)+'\n') stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n') if N%2==0: for i in range (1,N//2+1): stdout.write(str(i)+' '+str((M+1)//2)+'\n') stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n') else: for i in range (1,(N+1)//2): stdout.write(str(i)+' '+str((M+1)//2)+'\n') stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n') stdout.write(str((N+1)//2)+' '+str((M+1)//2)+'\n')",quadratic,['constructive algorithms'],812
"import math inp = input().split(' ') m = int(inp[0]) n = int(inp[1]) result = [] for column in range(1, math.ceil(m/2) + 1): rowRange = range(1, n + 1) if column == math.ceil(m / 2) and m % 2 == 1: rowRange = range(1, math.ceil(n/2) + 1) for row in rowRange: result.append(str(column) + ' ' + str(row)) if row == math.ceil(n/2) and n % 2 == 1 and column == math.ceil(m / 2) and m % 2 == 1: continue result.append(str(m + 1 - column) + ' ' + str(n + 1 - row)) print('\n'.join(result))",quadratic,['constructive algorithms'],483
"n, m = map(int, input().split()) buf = [] for i in range(n//2): for j in range(m): buf.append(f'{i + 1} {j + 1}\n') buf.append(f'{n - i} {m - j}\n') if n % 2 == 1: for j in range(m // 2): buf.append(f'{n // 2 + 1} {j + 1}\n') buf.append(f'{n // 2 + 1} {m - j}\n') if m % 2 == 1: buf.append(f'{n//2 + 1} {m//2 + 1}\n') print(*buf, sep='')",quadratic,['constructive algorithms'],337
"def main(): n, m = map(int,raw_input().split()) r = [] rappend = r.append for i in range(1, (n >> 1) + 1): for j in range(1, m + 1): rappend(str(i) + ' ' + str(j)) rappend(str(n + 1 - i) + ' ' + str(m + 1 - j)) if n & 1: for i in range(1, (m >> 1) + 1): rappend(str((n + 1) >> 1) + ' ' + str(i)) rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i)) if m & 1: rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1)) print('\n'.join(r)) main()",quadratic,['constructive algorithms'],435
"n, m = map(int, input().split()) np1 = n + 1 mp1 = m + 1 for i in range(1, 1 + n // 2): for j in range(1, mp1): print('%d %d\n%d %d' % (i,j,np1-i,mp1-j)) if n & 1: i = 1 + n // 2 for j in range(1, 1 + m // 2): print('%d %d\n%d %d' % (i,j,i,mp1-j)) if m & 1: print(i, 1 + m // 2)",quadratic,['constructive algorithms'],278
"import sys import math from collections import defaultdict n,m=map(int,sys.stdin.readline().split()) up,down=1,n count=0 while up<=down: left,right=1,m while left<=m and count<n*m: if count<n*m: sys.stdout.write((str(up)+"" ""+str(left)+""\n"")) count+=1 left+=1 if count<n*m: sys.stdout.write((str(down)+"" ""+str(right)+""\n"")) count+=1 right-=1 up+=1 down-=1 '''if n==1: a=len(ans) for i in range(a//2): print(ans[i][0],ans[i][1]) else: a=len(ans) for i in range(a//2): print(ans[i][0],ans[i][1])",quadratic,['constructive algorithms'],492
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") n,m=map(int,input().split()) s=0 e=n-1 for i in range(n//2): for j in range(m): print(s+1,j+1) print(e+1,m-j) s+=1 e-=1 if n%2==1: s=n//2 for j in range(m//2): print(s+1,j+1) print(s+1,m-j) if m%2==1: print(s+1,m//2+1)",quadratic,['constructive algorithms'],1615
"from sys import stdin, stdout n,m = [int(x) for x in stdin.readline().split()] if n == 2: c = 1 way = [] mult = 1 for x in range(m-1,-1,-1): way.append(c) c += x*mult mult *= -1 for x in way: print(1, x) for x in way[::-1]: print(2,x) elif n == 1: c = 1 way = [] mult = 1 for x in range(m-1,-1,-1): way.append(c) c += x*mult mult *= -1 for x in way: print(1, x) elif m == 2: c = 1 way = [] mult = 1 for x in range(n-1,-1,-1): way.append(c) c += x*mult mult *= -1 for x in way: print(x,1) for x in way[:-1:-1]: print(x,2) elif m == 1: c = 1 way = [] mult = 1 for x in range(n-1,-1,-1): way.append(c) c += x*mult mult *= -1 for x in way: print(x,1) else: outStr = '' for x in range(n//2): for y in range(1,m+1): stdout.write(str(x+1) + ' ' + str(y)+'\n') stdout.write(str(n-x) + ' ' + str(m+1-y)+'\n') if n%2 == 1: c = 1 way = [] mult = 1 for x in range(m-1,-1,-1): way.append(c) c += x*mult mult *= -1 for x in way: stdout.write(str(n//2+1)+' ' + str(x)+'\n')",quadratic,['constructive algorithms'],958
"import sys input=sys.stdin.readline n,m=map(int,input().split()) for i in range(n//2+n%2): x1=i+1 x2=n-i if(x1==x2): for j in range(m//2+m%2): if(j+1==m-j): sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n"")) else: sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n"")) sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n"")) else: if(i%2==0): for j in range(m): sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n"")) sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n"")) else: for j in range(m): sys.stdout.write((str(x1)+"" ""+str(m-j)+""\n"")) sys.stdout.write((str(x2)+"" ""+str(j+1)+""\n""))",quadratic,['constructive algorithms'],546
"import sys input=sys.stdin.buffer.readline n,m=map(int,input().split()) for i in range(n//2+n%2): x1=i+1 x2=n-i if(x1==x2): for j in range(m//2+m%2): if(j+1==m-j): sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n"")) else: sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n"")) sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n"")) else: if(i%2==0): for j in range(m): sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n"")) sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n"")) else: for j in range(m): sys.stdout.write((str(x1)+"" ""+str(m-j)+""\n"")) sys.stdout.write((str(x2)+"" ""+str(j+1)+""\n""))",quadratic,['constructive algorithms'],553
"import sys def countR(ip): c=0 for i in ip: if(i=='R'): c+=1 return c def countB(ip): c=0 for i in ip: if(i=='B'): c+=1 return c def countG(ip): c=0 for i in ip: if(i=='G'): c+=1 return c t=int(sys.stdin.readline()) x='RGB'*680 y='GBR'*680 z='BRG'*680 for i in range(t): n,k=list(map(int,sys.stdin.readline().strip().split())) a=sys.stdin.readline().strip() xk=x[:k] yk=y[:k] zk=z[:k] op=2001 for j in range(n-k+1): b=a[j:j+k] xd=0 yd=0 zd=0 for jj in range(len(b)): if(b[jj]!=xk[jj]): xd+=1 if(b[jj]!=yk[jj]): yd+=1 if(b[jj]!=zk[jj]): zd+=1 op=min(op,xd,yd,zd) print(op)",quadratic,['implementation'],571
"def givestringsk(k): t=[""R"",""G"",""B""] ans=[] for i in range(3): temp="""" for j in range(i,i+k): temp+=t[j%3] ans.append(temp) return ans def countdifferences(a,b): cnt=0 for i in range(len(a)): if a[i]!=b[i]:cnt+=1 return cnt for _ in range(int(input())): n,k=list(map(int,input().split())) s=input() temp=givestringsk(k) ans=10000000000000 for i in range(k,n+1): for j in range(3): ans=min(ans,countdifferences(s[i-k:i],temp[j])) print(ans)",quadratic,['implementation'],439
"q = int(input()) for _ in range(q): n, k = map(int, input().split()) s = input() ans = k sample = ""RGB"" for i in range(n - k + 1): cnt = 0 x = 0 for j in range(i, i + k): if s[j] != sample[x]: cnt += 1 x = (x + 1) % 3 ans = min(ans, cnt) cnt = 0 x = 1 for j in range(i, i + k): if s[j] != sample[x]: cnt += 1 x = (x + 1) % 3 ans = min(ans, cnt) cnt = 0 x = 2 for j in range(i, i + k): if s[j] != sample[x]: cnt += 1 x = (x + 1) % 3 ans = min(ans, cnt) print(ans)",quadratic,['implementation'],462
"def main(): q = int(input()) for i in range(q): n, k = map(int, input().split()) s = input() min_ans = 10 ** 9 for i in range(n - k + 1): count1 = 0 count2 = 0 count3 = 0 for j in range(k): if (i + j) % 3 == 0: if s[i + j] != ""R"": count1 += 1 if s[i + j] != ""G"": count2 += 1 if s[i + j] != ""B"": count3 += 1 if (i + j) % 3 == 1: if s[i + j] != ""G"": count1 += 1 if s[i + j] != ""B"": count2 += 1 if s[i + j] != ""R"": count3 += 1 if (i + j) % 3 == 2: if s[i + j] != ""B"": count1 += 1 if s[i + j] != ""R"": count2 += 1 if s[i + j] != ""G"": count3 += 1 min_ans = min(min_ans, count1, count2, count3) print(min_ans) main()",quadratic,['implementation'],609
"q = int(input()) b = [] for m in range(q): n, k = map(int, input().split()) l = input() k1 = 'R' k2 = 'G' k3 = 'B' for i in range(1, k): if k1[i - 1] == 'R': k1 = k1 + 'G' if k1[i - 1] == 'G': k1 = k1 + 'B' if k1[i - 1] == 'B': k1 = k1 + 'R' if k2[i - 1] == 'R': k2 = k2 + 'G' if k2[i - 1] == 'G': k2 = k2 + 'B' if k2[i - 1] == 'B': k2 = k2 + 'R' if k3[i - 1] == 'R': k3 = k3 + 'G' if k3[i - 1] == 'G': k3 = k3 + 'B' if k3[i - 1] == 'B': k3 = k3 + 'R' minn = n for i in range(n - k + 1): tec = 0 for j in range(k): if l[i + j] != k1[j]: tec += 1 if tec < minn: minn = tec for i in range(n - k + 1): tec = 0 for j in range(k): if l[i + j] != k2[j]: tec += 1 if tec < minn: minn = tec for i in range(n - k + 1): tec = 0 for j in range(k): if l[i + j] != k3[j]: tec += 1 if tec < minn: minn = tec b.append(minn) for i in range(q): print(b[i])",quadratic,['implementation'],839
"def user99(): text = 'RGB' * 2222 for _ in range(int(input())): n, k = map(int, input().split()) s = input() ans = 2222 for i in range(3): p = text[i: k + i] for j in range(n - k + 1): diff = 0 for l in range(j, j + k): if s[l] != p[l - j]: diff += 1 ans = min(ans, diff) print(ans) user99()",quadratic,['implementation'],291
"R = lambda: map(int, input().split()) for _ in range(int(input())): n,k = R() s = input() p = (k+2)//2 l = ""RGB""*p res = n for i in range(n-k+1): c = 0 for j in range(0,k): c += (s[i+j] != l[j]) res = min(res,c) c = 0 for j in range(1,k+1): c += (s[i+j-1] != l[j]) res = min(res,c) c = 0 for j in range(2,k+2): c += (s[i+j-2] != l[j]) res = min(res,c) print(res)",quadratic,['implementation'],362
"import math class Read: @staticmethod def int(): return int(input()) @staticmethod def list(sep=' '): return input().split(sep) @staticmethod def list_int(sep=' '): return list(map(int, input().split(sep))) def solve(): n, k = Read.list_int() s = input() sf = 'RGB' * (k + 2) max_s = 0 for i in range(n - k + 1): for j in range(3): count = 0 for b in range(k): if sf[j + b] == s[i + b]: count += 1 if count > max_s: max_s = count print(k - max_s) query_count = Read.int() for j in range(query_count): solve()",quadratic,['implementation'],508
"import sys input = sys.stdin.readline RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()] rw = lambda : input().strip().split() from collections import defaultdict as df import random infinite = float('inf') t=int(input()) for _ in range(t): n,k=RI() s=input() mini=n test=""RGB""*(k//3 + 5) for i in range(n-k+1): count=0 for j in range(k): if(s[i+j]!=test[j]): count+=1 mini=min(count,mini) test=""GBR""*(k//3 + 5) for i in range(n-k+1): count=0 for j in range(k): if(s[i+j]!=test[j]): count+=1 mini=min(count,mini) test=""BRG""*(k//3 + 5) for i in range(n-k+1): count=0 for j in range(k): if(s[i+j]!=test[j]): count+=1 mini=min(count,mini) print(mini)",quadratic,['implementation'],665
"from sys import stdin,stdout input=stdin.readline for _ in range(int(input())): x=10**5 n,k=map(int,input().split()) s=input() ans=10**9 for i in range(n-k+1): x=s[i:i+k] m=0 curr=['R','G','B'] for l in range(3): m=0 z=l for j in x: if j!=curr[z]: m+=1 z+=1 z%=3 ans=min(ans,m) print(ans)",quadratic,['implementation'],288
"import sys input = sys.stdin.readline RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()] rw = lambda : input().strip().split() infinite = float('inf') t=int(input()) for _ in range(t): n,k=RI() s=input() mini=n test=""RGB""*(k//3 + 5) for i in range(n-k+1): count=0 for j in range(k): if(s[i+j]!=test[j]): count+=1 mini=min(count,mini) test=""GBR""*(k//3 + 5) for i in range(n-k+1): count=0 for j in range(k): if(s[i+j]!=test[j]): count+=1 mini=min(count,mini) test=""BRG""*(k//3 + 5) for i in range(n-k+1): count=0 for j in range(k): if(s[i+j]!=test[j]): count+=1 mini=min(count,mini) print(mini)",quadratic,['implementation'],609
"import sys input = lambda: sys.stdin.readline().strip() from math import ceil def mismatch(s1, s2): cnt = 0 for i in range(len(s1)): if s1[i]!=s2[i]: cnt+=1 return cnt T = int(input()) for _ in range(T): n, k = map(int, input().split()) check = '' for i in range(ceil((k+2)/3)): check+='RGB' ls = [] for i in range(3): ls.append(check[i:i+k]) s = input() m = n for i in range(n-k+1): for j in ls: m = min(m, mismatch(s[i:i+k], j)) print(m)",quadratic,['implementation'],439
"T=int(input()) for _ in range(T): n,k=map(int,input().split()) s=input() rq1='' rq2='' rq3='' for i in range(k): if(i%3==0): rq1=rq1+'R' rq2=rq2+'G' rq3=rq3+'B' elif(i%3==1): rq1=rq1+'G' rq2=rq2+'B' rq3=rq3+'R' elif(i%3==2): rq1=rq1+'B' rq2=rq2+'R' rq3=rq3+'G' ans=1000000000000000000 for i in range(0,len(s)-k+1): a1=0 a2=0 a3=0 for j in range(i,i+k): if(s[j]!=rq1[j-i]): a1+=1 if(s[j]!=rq2[j-i]): a2+=1 if(s[j]!=rq3[j-i]): a3+=1 ans=min(ans,min(a1,a2,a3)) print(ans)",quadratic,['implementation'],468
"q=int(input()) for i in range(q): n,k=map(int,input().split()) s=input() m=10**4 for j in range(n): if j+k<=n: l1=[""R"",""G"",""B""] m1,m2,m3=0,0,0 for i in range(j,j+k): if l1[(i-j)%3]!=s[i]: m1+=1 for i in range(j,j+k): if l1[(i+1-j)%3]!=s[i]: m2+=1 for i in range(j,j+k): if l1[(i+2-j)%3]!=s[i]: m3+=1 m=min(m,m1,m2,m3) else: break print(m)",quadratic,['implementation'],338
"def gen(n, b): a = [(x + b) % 3 for x in range(n)] s = """" for i in range(n): if a[i] == 0: s += ""R"" if a[i] == 1: s += ""G"" if a[i] == 2: s += ""B"" return s q = int(input()) for _ in range(q): n, k = map(int, input().split()) s = input() ans = n for xi in range(3): t = gen(n, xi) diff = 0 for i in range(k): if s[i] != t[i]: diff += 1 ans = min(ans, diff) for j in range(k, n): if s[j - k] != t[j - k]: diff -= 1 if s[j] != t[j]: diff += 1 ans = min(ans, diff) print(ans)",quadratic,['implementation'],470
"import sys sss='RGB'*700 def check(ss,p): i=0 m=10**5 ans=0 while i<len(p): if p[i]!=sss[i]: ans+=1 i+=1 m=min(m,ans) ans=0 i=1 while i<len(p)+1: if p[i-1]!=sss[i]: ans+=1 i+=1 m=min(m,ans) ans=0 i=2 while i<len(p)+2: if p[i-2]!=sss[i]: ans+=1 i+=1 m=min(m,ans) return m for _ in range(int(input())): n,k=(list(map(int,sys.stdin.readline().split()))) s=input() m=10**5 for i in range(n-k+1): m=min(m,(check(sss,s[i:i+k]))) print(m)",quadratic,['implementation'],431
"import sys input = sys.stdin.readline q=int(input()) for i in range(q): n,k=map(int,input().split()) s=input() a=k for j in range(n-k+1): a1,a2,a3=0,0,0 for jj in range(k): if jj%3==0: if s[j+jj]==""R"": a2+=1 a3+=1 elif s[j+jj]==""G"": a1+=1 a3+=1 else: a1+=1 a2+=1 elif jj%3==1: if s[j+jj]==""R"": a1+=1 a2+=1 elif s[j+jj]==""G"": a2+=1 a3+=1 else: a3+=1 a1+=1 else: if s[j+jj]==""R"": a1+=1 a3+=1 elif s[j+jj]==""G"": a1+=1 a2+=1 else: a3+=1 a2+=1 a=min(a,a1,a2,a3) print(a)",quadratic,['implementation'],465
"rgb = 'RGB' * 1000 for q in range(int(input())): n, k = [int(s) for s in input().split()] s = input() ans = 3000 for w in range(3): for e in range(n - k + 1): temp = 0 for i in range(k): if s[e + i] != rgb[w + i]: temp += 1 ans = min(ans, temp) print(ans)",quadratic,['implementation'],255
"N, M, K = map(int, input().split()) A = [int(a) for a in input().split()] S = [0] for a in A: S.append(S[-1]+M*a-K) MI = [(10**50)] * M ans = 0 for i in range(N+1): MI[i%M] = min(MI[i%M], S[i]) for j in range(M): ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M) print(ans)",quadratic,"['dp', 'greedy', 'math']",274
"n,m,k=map(int,raw_input().split()) l=list(map(int,raw_input().split())) ma=0 for deb in range(n-1,n-m-1,-1): cumi=0 scu=0 for i in range(deb,-1,-1): scu+=l[i] ma=max(ma,scu-cumi-k) if (deb-i+1)%m==0: scu-=k if scu<cumi: cumi=scu print(ma)",quadratic,"['dp', 'greedy', 'math']",238
"n, m, k = map(int, input().split()) A = list(map(int, input().split())) glans = 0 for s in range(m): B = [] f = s su = 0 sus = 0 for i in range(s, n): su += A[i] sus = max(sus, su) if (i + 1) % m == s: B.append(sus - k) B.append(su - sus) su = 0 sus = 0 f = i + 1 dob = 0 klol = 0 for j in range(f, n): dob += A[j] klol = max(klol, dob - k) B = [0] + B + [klol] for i in range(1, len(B)): B[i] += B[i - 1] cnt = -10 ** 10 ans = [0, 0] minsum = 10 ** 10 candidat = 0 for i in range(len(B)): if B[i] - minsum > cnt: cnt = B[i] - minsum ans[1] = i ans[0] = candidat if B[i] <= minsum: minsum = B[i] candidat = i glans = max(glans, B[ans[1]] - B[ans[0]]) print(glans)",quadratic,"['dp', 'greedy', 'math']",663
"n,m,k = [int(w) for w in input().split()] a = [int(w) for w in input().split()] def f(o): r = e = 0 for i, x in enumerate(a): if i < o: continue if i % m == o: e -= k if e < -k: e = -k e += x if e > r: r = e return r print(max(f(o) for o in range(m)))",quadratic,"['dp', 'greedy', 'math']",251
"import math n, m, k = list(map(int, input().split())) arr = list(map(int, input().split())) part_sum = [0] for i in range(n): part_sum.append(part_sum[-1] + arr[i]) part_sum_add = [[] for _ in range(m)] min_in_part_sum_add = [[] for _ in range(m)] for shift in range(m): count_blocks = math.ceil((n - shift) / m + 1) for i in range(n + 1): cur_part_sum = part_sum[i] + k * (count_blocks - ((i - shift) // m)) if i == 0 or cur_part_sum < prev_min_in_part_sum_add: cur_min_in_part_sum_add = cur_part_sum else: cur_min_in_part_sum_add = prev_min_in_part_sum_add part_sum_add[shift].append(cur_part_sum) min_in_part_sum_add[shift].append(cur_min_in_part_sum_add) prev_min_in_part_sum_add = cur_min_in_part_sum_add max_result = 0 for i in range(1, n + 1): current_shift = i % m current_min = min_in_part_sum_add[current_shift][i] current_ans = part_sum_add[current_shift][i] - current_min if current_ans > max_result: max_result = current_ans print(max_result)",quadratic,"['dp', 'greedy', 'math']",955
"import sys n, m, k = list(map(int, sys.stdin.readline().strip().split())) a = list(map(int, sys.stdin.readline().strip().split())) b = [0] * (n+1) for i in range (1, n+1): b[i] = b[i-1] + m * a[i-1] - k M = [10 ** 20] * m ans = 0 for i in range (0, n+1): M[i % m] = min([M[i % m], b[i]]) for j in range (0, m): if i > j: ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)]) print(ans // m)",quadratic,"['dp', 'greedy', 'math']",384
"N, M, K = map(int, raw_input().split()) A = [int(a) for a in raw_input().split()] S = [0] for a in A: S.append(S[-1]+M*a-K) MI = [(10**50)] * M ans = 0 for i in range(N+1): MI[i%M] = min(MI[i%M], S[i]) for j in range(M): ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M) print(ans)",quadratic,"['dp', 'greedy', 'math']",282
"import sys input = sys.stdin.readline from itertools import accumulate import copy n,m,k = map(int,input().split()) A = list(map(int,input().split())) ANS = 0 for i in range(m): B = copy.deepcopy(A) for j in range(i,n,m): B[j] -= k SUM = list(accumulate(B)) SUMMIN = [float(""inf"")]*n +[0] if i==0: SUMMIN[0] = 0 for j in range(max(1,i),n): if j % m == i % m: SUMMIN[j] = min(SUMMIN[j-1],SUM[j-1]) else: SUMMIN[j] = SUMMIN[j-1] for j in range(i,n): ANS = max(ANS,SUM[j] - SUMMIN[j]) print(ANS)",quadratic,"['dp', 'greedy', 'math']",492
"import sys input = sys.stdin.readline n,m,k=map(int,input().split()) A=[int(i) for i in input().split()] if n<=m: AA=[0]*(n+1) for i in range(n): AA[i+1]=AA[i]+A[i] mm=0 for i in range(n+1): for j in range(i+1,n+1): mm=max(mm,AA[j]-AA[i]-k) else: DP=[[0]*(m+1) for _ in range(n+1)] for i in range(n): a=A[i] DP[i+1][0]=max([DP[i][0],DP[i][m],DP[i][m]+a-k,DP[i][1]]) DP[i+1][1]=max(a-k,DP[i][m]+a-k) for j in range(2,m+1): DP[i+1][0]=max(DP[i+1][0],DP[i][j]) if j>i+1: continue else: DP[i+1][j]=max(DP[i][j-1]+a,DP[i][m]+a-k) print(max(A[0]-k,0) if n==1 else mm if n<=m else max(0,max(DP[n])))",quadratic,"['dp', 'greedy', 'math']",592
"import copy n,m,k=map(int,input().split()) A=list(map(int,input().split())) ANS=0 for i in range(m): B=copy.deepcopy(A) for j in range(i,n,m): B[j]-=k NOW=0 for j in range(i,n): if j%m==i: NOW=max(NOW+B[j],B[j]) else: NOW+=B[j] ANS=max(ANS,NOW) print(ANS)",quadratic,"['dp', 'greedy', 'math']",255
"from sys import stdin, stdout, exit n, m, k = map(int, stdin.readline().split()) a = list(map(int, stdin.readline().split())) def bf(a): best = 0 best_arg = (-1, -1) for i in range(n): for j in range(i, n): cur = sum(a[i:j+1]) - k*((j - i) // m + 1) if cur > best: best = max(best, cur) best_arg = (i,j) return best, best_arg def max_sum(a): if len(a) == 0: return 0 elif len(a) == 1: return max(0, a[0] - k) mid = len(a) // 2 l_rec = max_sum(a[:mid]) r_rec = max_sum(a[mid:]) l_bests = [0]*m r_bests = [0]*m l_sum = 0 for idx in range(1,mid+1): l_sum += a[mid-idx] if idx % m == 0: l_sum -= k l_bests[idx%m] = max(l_bests[idx%m], l_sum) r_sum = 0 for idx in range(0, len(a)-mid): r_sum += a[idx+mid] if (idx+1) % m == 0: r_sum -= k r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum) best_acr = 0 for i in range(m): for j in range(m): best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0)) ans = max(l_rec,r_rec, best_acr) return ans ans = max_sum(a) stdout.write(str(ans) + ""\n"")",quadratic,"['dp', 'greedy', 'math']",1020
"n, m, k = [int(i) for i in input().split()] A = [int(i) for i in input().split()] bestbest = 0 def brute(n, m, k, A): ans = 0 val = (0, 0) for i in range(n): for j in range(i, n): if ans < sum(A[i:j+1]) - k*(ceil((j-i+1)/m)): ans = sum(A[i:j+1]) - k*(ceil((j-i+1)/m)) val = (i, j) return val, ans for off in range(m): B = A[off:] C = [] canstart = [] for i in range(len(B)): if i%m == 0: C.append(-k) canstart.append(1) canstart.append(0) C.append(B[i]) best = 0 run = 0 for i in range(len(C)): run += C[i] if run < -k: run = -k best = max(best, run) bestbest = max(bestbest, best) print(bestbest)",quadratic,"['dp', 'greedy', 'math']",597
"def max_subarray(A): max_ending_here = max_so_far = A[0] for x in A[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far ans = 0 n, m, k = map(int, input().split()) a = list(map(int, input().split())) for i in range(m): li = a[0:i] + [-k] s = 0 while True: li += a[i+s:min(i+m+s, len(a))] li += [-k] if i+m+s >= len(a): break s += m ans = max(max_subarray(li) - k,ans) print(ans)",quadratic,"['dp', 'greedy', 'math']",441
"if __name__ == '__main__': n, m, k = map(int, input().split()) aa = list(map(int,input().split())) ans = 0 for start in range(m): ac = aa[:] for i in range(start, n, m): ac[i] -= k cur = 0 for i in range(start, n): if i%m == start: cur = max(ac[i] + cur, ac[i]) else: cur += ac[i] ans = max(cur, ans) print(ans)",quadratic,"['dp', 'greedy', 'math']",311
"from sys import stdin, stdout import collections N,M,K = [int(x) for x in stdin.readline().split()] arr = [int(x) for x in stdin.readline().split()] res = 0 for j in range(M): s = 0 mini = 0 for i in range(j,N): if i%M==j: mini = min(mini,s) s -= K s += arr[i] res = max(res,s-mini) print(res)",quadratic,"['dp', 'greedy', 'math']",293
"base = 1000000007 n , m , k = map(int,input().split()) a = list(map(int,input().split())) mx = 0 s = 0 dp = [] dd= [] for j in range(m): for i in range(n+1): dp.append(base) dd.append(0) for i in range(n): dd[i+1]=dd[i]+a[i]-k*(i % m== j) dp[i+1] = min(dd[i],dp[i]) if (i % m == j): mx = max ( mx , dd[i+1]-dp[i+1]) print(mx)",quadratic,"['dp', 'greedy', 'math']",325
"import math def max_sub(arr,n): dp = [0]*n dp[0] = arr[0] for i in range(1,n): dp[i] = max(dp[i-1]+arr[i],arr[i]) return max(0,max(dp)) n,m,k = map(int,input().split()) arr = list(map(int,input().split())) q = -math.inf dp = [0]*(300100) for i in range(300100): dp[i] = [q]*(11) if (m==1): for i in range(n): arr[i]= arr[i]-k print(max_sub(arr,n)) else: for i in range(n): dp[i][1] = arr[i]-k for j in range(m): if (i-1<0 or dp[i-1][j]==q): continue if ((j+1)%m!=1): dp[i][(j+1)%m] = dp[i-1][j]+arr[i] else: dp[i][(j+1)%m] = max(arr[i]-k,dp[i-1][j]+arr[i]-k) ma=0 for i in range(n): for j in range(m): ma = max(ma,dp[i][j]) print(ma)",quadratic,"['dp', 'greedy', 'math']",633
"N, M, K = map(int, input().split()) A = list(map(int, input().split())) bv = 0 for ms in range(M): cv = 0 for i in range(ms, N): v = A[i] if i % M == ms: v -= K cv = max(0, cv) cv += v bv = max(bv, cv) print(bv)",quadratic,"['dp', 'greedy', 'math']",211
"import sys, math, queue MOD = 998244353 sys.setrecursionlimit(1000000) n, m, k = map(int, input().split()) a = list(map(int, input().split())) dp = [[-10**20 for i in range(m)] for i in range(n)] dp[0][0] = a[0]-k for i in range(1, n): for j in range(m): if j == 0: dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k else: dp[i][j] = dp[i-1][j-1]+a[i] ans = 0 for i in range(n): ans = max(ans, max(dp[i])) print(ans)",quadratic,"['dp', 'greedy', 'math']",407
"import sys, math, queue MOD = 998244353 sys.setrecursionlimit(1000000) n, m, k = map(int, input().split()) a = list(map(int, input().split())) dp = [[-10**20 for i in range(m)] for i in range(n)] for i in range(n): for j in range(min(m, i+1)): if j == 0: dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k else: dp[i][j] = dp[i-1][j-1]+a[i] ans = 0 for i in range(n): ans = max(ans, max(dp[i])) print(ans)",quadratic,"['dp', 'greedy', 'math']",396
"n, m, k = map(int, input().split()) a = list(map(int, input().split())) sa = [0]*n ans = 0 for i in range(n): sa[i] = a[i] - k s = a[i] for j in range(i-1, max(-1, i-m-1), -1): sa[i] = max(sa[i], sa[j] + s - k) s += a[j] if i < m: sa[i] = max(sa[i], s - k) sa[i] = max(sa[i], 0) ans = max(ans, sa[i]) print(ans)",quadratic,"['dp', 'greedy', 'math']",311
"n, m, k = list(map(int, input().split())) a = list(map(int, input().split())) ret = 0 for i in range(m): cur = 0 for j in range(i, n): if j % m == i: cur = max(0, cur) cur -= k cur += a[j] ret = max(ret, cur) print(ret)",quadratic,"['dp', 'greedy', 'math']",219
"n,m,k = list(map(int,input().split())) a = list(map(int,input().split())) dp = [[float('-inf')]*m for i in range(n)] dp[0][0] = a[0] for i in range(1,n): for j in range(1,m): dp[i][j] = dp[i-1][j-1] + a[i] dp[i][0] = max(dp[i-1][m-1]-k, 0)+a[i] print(max(max([max(x) for x in dp])-k,0))",quadratic,"['dp', 'greedy', 'math']",286
"n, m, k = list(map(int, input().split())); a = list(map(int, input().split())); values = list() for j in range(n): result = a[j]; sum1 = 0; for i in range(m): if j-i>=0: sum1 = sum1 + a[j-i]; if sum1 > result: result = sum1; else: continue; if j-m>=0: result = max(result, sum1 + values[j-m]); values.append(max(0, result-k)); print(max(values));",quadratic,"['dp', 'greedy', 'math']",346
"n, m, k = map(int, input().strip().split()) a = list(map(int, input().strip().split())) a = [0] + a dp = [0] * 300005 ans = 0 for i in range(1, n + 1): a[i] += a[i - 1] for j in range(1, m + 1): if i - j >= 0: dp[i] = max(dp[i], a[i] - a[i - j] - k) if i - m >= 0: dp[i] = max(dp[i], a[i] - a[i - m] + dp[i - m] - k) ans = max(ans, dp[i]) print(ans)",quadratic,"['dp', 'greedy', 'math']",349
"n, m, k = map(int, input().split()) a = list(map(int, input().split())) best = 0 dp = [0] * (n + 1) for i in range(n): b2 = 0 for j in range(max(-1, i - m), i + 1): b2 = max(b2, dp[j] - k + sum(a[j + 1:i + 1])) dp[i] = max(b2, a[i] - k) best = max(best, dp[i]) print(best)",quadratic,"['dp', 'greedy', 'math']",272
"from math import * n,m,k = map(int,input().split()) l = list(map(int,input().split())) a = [0 for i in range(n+1)] ans = 0 for M in range(m): min1 = 0 for i in range(1,n+1): a[i] = a[i-1] + l[i-1] if(i % m == M): a[i] -= k ans = max(ans,a[i]-min1) min1 = min(min1,a[i]) print(ans)",quadratic,"['dp', 'greedy', 'math']",280
"n, m, k = list(map(int, input().split())) a = list(map(int, input().split())) ret = 0 for i in range(m): cur = 0 for j in range(i, n): if j % m == i: cur = max(0, cur) cur -= k cur += a[j] ret = max(ret, cur) print(ret)",quadratic,"['dp', 'greedy', 'math']",219
"n, m, k = map(int, input().split()) *a, = map(int, input().split()) dp = [-1] * (n + 15) for i in range(n): s, mx = a[i], max(0, a[i]) for j in range(i - 1, max(-1, i - m), -1): s += a[j] mx = max(mx, s) dp[i] = max(0, dp[i - m] + s - k, mx - k) print(max(dp))",quadratic,"['dp', 'greedy', 'math']",260
"from itertools import accumulate n,m,k = map(int,input().split()) a = list(map(int,input().split())) als = [] for i in range(m): ls = a[:] for j in range(n): if j%m == i: ls[j] -= k als.append(list(accumulate(ls))) ans = 0 for i in range(m): ls = als[i] mn = 0 anstmp = 0 for j in range(n): if mn > ls[j]: mn = ls[j] if j%m == i: anstmp = max(anstmp,ls[j]-mn) ans = max(ans,anstmp) print(ans)",quadratic,"['dp', 'greedy', 'math']",392
"n = int(input()) A = list(map(int, input().split())) A.sort() B = [0] * n ans = 0 for i in range(n): if B[i] == 0: ans += 1 B[i] = 1 for j in range(n): if A[j] % A[i] == 0: B[j] = 1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",192
"n = int(input()) a = sorted(map(int , input().split())) ans = 0 for i in range(n): f = 1 for j in range(i): if a[i] % a[j] == 0: f = 0 break ans += f print(ans)",quadratic,"['greedy', 'implementation', 'math']",160
"import sys def read(): return sys.stdin.readline() def main(): n = int(read()) a = list(map(int, read().split())) a.sort() k = 0 used = [0] * n for i in range(n): if used[i]: continue k += 1 for j in range(i, n): if a[j] % a[i] == 0: used[j] = True print(k) if __name__ == '__main__': main()",quadratic,"['greedy', 'implementation', 'math']",291
"n=int(input()) l1=list(map(int,input().split())) ans=0 l1.sort() visited=[0]*n for i in range(n): if visited[i]==1: continue visited[i]=1 ans+=1 for j in range(i+1,n): if visited[j]==0 and l1[j]%l1[i]==0: visited[j]=1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",228
"def main(): import sys input = sys.stdin.readline n = int(input()) arr = list(map(int, input().split())) color = [0] * n arr.sort() ans = 0 for i in range(n): if color[i]: continue ans += 1 for j in range(i, n): if arr[j] % arr[i] == 0: color[j] = ans print(ans) return 0 main()",quadratic,"['greedy', 'implementation', 'math']",278
"n = int(input()) A = list(map(int, input().split())) A.sort() ans = 1 for i in range(1, n): ok = False for j in range(i): if A[i] % A[j] == 0: ok = True if not ok: ans += 1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",183
"n = int(input()) a = sorted(list(map(int, input().split()))) s = [] for q in a: for q1 in s: if q % q1 == 0: break else: s.append(q) print(len(s))",quadratic,"['greedy', 'implementation', 'math']",146
"from collections import defaultdict,deque from heapq import heappush, heappop import sys import math import bisect def LI(): return [int(x) for x in sys.stdin.readline().split()] def I(): return int(sys.stdin.readline()) def LS():return [list(x) for x in sys.stdin.readline().split()] def S(): res = list(sys.stdin.readline()) if res[-1] == ""\n"": return res[:-1] return res def IR(n): return [I() for i in range(n)] def LIR(n): return [LI() for i in range(n)] def SR(n): return [S() for i in range(n)] def LSR(n): return [LS() for i in range(n)] sys.setrecursionlimit(1000000) mod = 1000000007 def A(): n = I() a = LI() a.sort() f = [1]*n p = 0 ans = 0 while p < n: while p < n and not f[p]: p += 1 if p == n: break ans += 1 for i in range(n): if a[i]%a[p] == 0: f[i] = 0 print(ans) return def B(): return def C(): return def D(): return def E(): return def F(): return def G(): return def H(): return if __name__ == ""__main__"": A()",quadratic,"['greedy', 'implementation', 'math']",932
"from bisect import * from collections import * from itertools import * import functools import sys import math from decimal import * from copy import * from heapq import * getcontext().prec = 30 MAX = sys.maxsize MAXN = 10**5+10 MOD = 10**9+7 def isprime(n): n = abs(int(n)) if n < 2: return False if n == 2: return True if not n & 1: return False for x in range(3, int(n**0.5) + 1, 2): if n % x == 0: return False return True def mhd(a,b): return abs(a[0]-b[0])+abs(b[1]-a[1]) def charIN(x= ' '): return(sys.stdin.readline().strip().split(x)) def arrIN(x = ' '): return list(map(int,sys.stdin.readline().strip().split(x))) def eld(x,y): a = y[0]-x[0] b = x[1]-y[1] return (a*a+b*b)**0.5 def lgcd(a): g = a[0] for i in range(1,len(a)): g = math.gcd(g,a[i]) return g def ms(a): msf = -MAX meh = 0 st = en = be = 0 for i in range(len(a)): meh+=a[i] if msf<meh: msf = meh st = be en = i if meh<0: meh = 0 be = i+1 return msf,st,en def ncr(n,r): num=den=1 for i in range(r): num = (num*(n-i))%MOD den = (den*(i+1))%MOD return (num*(pow(den,MOD-2,MOD)))%MOD def flush(): return sys.stdout.flush() def fac(n): ans = 1 for i in range(1,n+1): ans*=i ans%=MOD return ans n = int(input()) a = arrIN() a.sort() f = [1]*n cnt = 0 for i in range(n): if f[i]: cnt+=1 for j in range(i,n): if f[j] and a[j]%a[i]==0: f[j] = 0 f[i] = 0 print(cnt)",quadratic,"['greedy', 'implementation', 'math']",1328
"n=int(input()) a=[int(i) for i in input().split()] a.sort() tot = 0 d={} for i in range(len(a)): if a[i] not in d: tot+=1 for j in range(i+1,len(a),1): if a[j]%a[i] == 0: d[a[j]]=1 print(tot)",quadratic,"['greedy', 'implementation', 'math']",191
"n = int(input()) a = list(map(int, input().split())) a.sort(reverse=True) cnt = 0 while a: f = a.pop() rm = [] for x in a: if x % f == 0: rm.append(x) for x in rm: a.remove(x) cnt += 1 print(cnt)",quadratic,"['greedy', 'implementation', 'math']",195
"import sys input = sys.stdin.readline n=int(input()) A=list(map(int,input().split())) A.sort() ANS=[0]*n NOW=1 for i in range(n): if ANS[i]==0: ANS[i]=NOW for j in range(i,n): if A[j]%A[i]==0 and ANS[j]==0: ANS[j]=NOW NOW+=1 print(max(ANS))",quadratic,"['greedy', 'implementation', 'math']",240
"import sys class APaintTheNumbers: def solve(self): n = int(input()) a = [int(_) for _ in input().split()] a.sort() ans = 0 done = [0] * n for i in range(n): if done[i]: continue ans += 1 for j in range(i, n): if done[j]: continue if a[j] % a[i] == 0: done[j] = 1 print(ans) solver = APaintTheNumbers() input = sys.stdin.readline solver.solve()",quadratic,"['greedy', 'implementation', 'math']",344
"import sys import os from io import IOBase, BytesIO def main(): n = int(input()) arr = get_array() arr.sort() tmp = [-1] * n c = 1 for i in range(n): if tmp[i] != -1: continue x = arr[i] for j in range(i, n): if arr[j] % x == 0: tmp[j] = c c += 1 print(c - 1) BUFSIZE = 8192 class FastIO(BytesIO): newlines = 0 def __init__(self, file): self._file = file self._fd = file.fileno() self.writable = ""x"" in file.mode or ""w"" in file.mode self.write = super(FastIO, self).write if self.writable else None def _fill(self): s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0]) return s def read(self): while self._fill(): pass return super(FastIO, self).read() def readline(self): while self.newlines == 0: s = self._fill() self.newlines = s.count(b""\n"") + (not s) self.newlines -= 1 return super(FastIO, self).readline() def flush(self): if self.writable: os.write(self._fd, self.getvalue()) self.truncate(0), self.seek(0) class IOWrapper(IOBase): def __init__(self, file): py2 = round(0.5) self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable if py2 == 1: self.write = self.buffer.write self.read = self.buffer.read self.readline = self.buffer.readline else: self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def get_array(): return list(map(int, sys.stdin.readline().split())) def get_ints(): return map(int, sys.stdin.readline().split()) def input(): return sys.stdin.readline().strip() if __name__ == ""__main__"": main()",quadratic,"['greedy', 'implementation', 'math']",1740
"n = int(input()) l = sorted(map(int, input().split())) seen = [False] * n res = 0 for i in range(n): if seen[i]: continue res += 1 for j in range(i, n): seen[j] |= l[j] % l[i] == 0 print(res)",quadratic,"['greedy', 'implementation', 'math']",191
"n = int(input()) a = list(map(int, input().split())) a = sorted(a) ans = 0 b = [0] * n for i in range(n): if b[i] == 0: ans += 1 for j in range(i, n): if a[j] % a[i] == 0: b[j] = 1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",191
"def solve(n, a): a = sorted(a) col = [False for i in range(n)] count = 0 for i in range(n): if not col[i]: count += 1 col[i] = True for j in range(n): if a[j] % a[i] == 0: col[j] = True return count n = int(input()) a = list(map(int, input().split())) print(solve(n, a))",quadratic,"['greedy', 'implementation', 'math']",270
"import sys input = sys.stdin.readline n = int(input()) a = sorted(list(set(map(int, input().split())))) n = len(a) used = [0] * n cnt = 0 for i in range(n): if not used[i]: used[i] = 1 cnt += 1 for j in range(i + 1, n): if a[j] % a[i] == 0: used[j] = 1 print(cnt)",quadratic,"['greedy', 'implementation', 'math']",263
"n = int(input()) a = [int(i) for i in input().split()] a.sort() count = 0 for i in range(n): cur_c = a[i] if not cur_c: continue count += 1 for j in range(i+1,n): if a[j]%cur_c == 0: a[j] = 0 print(count)",quadratic,"['greedy', 'implementation', 'math']",204
"import sys import math fileoperation=0 if(fileoperation): orig_stdout = sys.stdout orig_stdin = sys.stdin inputfile = open('W:/Competitive Programming/input.txt', 'r') outputfile = open('W:/Competitive Programming/output.txt', 'w') sys.stdin = inputfile sys.stdout = outputfile mod=1000000007 def nospace(l): ans=''.join(str(i) for i in l) return ans t=1 for tt in range(t): n=int(input()) a=list(map(int,sys.stdin.readline().split(' '))) a.sort() i=0 ans=0 while i<len(a): if a[i]: ans+=1 j=i+1 while j<n: if(a[j]%a[i]==0): a[j]=0 j+=1 i+=1 print(ans) if(fileoperation): sys.stdout = orig_stdout sys.stdin = orig_stdin inputfile.close() outputfile.close()",quadratic,"['greedy', 'implementation', 'math']",656
"n = int(input()) a = list(map(int, input().split())) a.sort() ans = 0 u = [0] * (n+1) for i in range(n): if u[i] == 0: ans+=1 for j in range(i, n): if a[j] % a[i] == 0: u[j] = 1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",188
"n=int(input()) l=list(map(int,input().split())) l.sort() v=[False for i in range(n)] ans=0 i=0 while i<n: if v[i]==False: ans+=1 for j in range(i+1,n): if l[j]%l[i]==0: v[j]=True i+=1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",194
"import sys from collections import defaultdict as dd mod=10**9+7 def ri(flag=0): if flag==0: return [int(i) for i in sys.stdin.readline().split()] else: return int(sys.stdin.readline()) n = ri(1) a= ri() b= sorted(a) c= dd(int) ans = 0 val=0 for i in range(n): if c[b[i]]==0: val+=1 for j in range(n): if b[j]%b[i]==0: c[b[j]]=val for i in c: ans = max(ans , c[i]) print(ans)",quadratic,"['greedy', 'implementation', 'math']",375
"n = int(input()) a = list(set(map(int, input().split()))) n = len(a) cnt = 0 for i in range(n): f = True for j in range(n): if i == j: continue if a[i] % a[j] == 0: f = False if f: cnt += 1 print(cnt)",quadratic,"['greedy', 'implementation', 'math']",200
"n = int(input()) a = list(map(int, input().split())) a.sort() ans = 0 while a: m = a[0] b = [] for x in a[1:]: if x % m != 0: b.append(x) a = b ans += 1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",163
"n = int(input()) data = [int(i) for i in input().split()] data.sort() ans = [0]*n col = 0 for i in range(n): if ans[i] == 0: col += 1 ans[i] = 1 d = data[i] for j in range(i+1, n): if data[j] % d == 0: ans[j] = 1 print(col)",quadratic,"['greedy', 'implementation', 'math']",223
n = int(input()) l = [int(i) for i in input().split()] l.sort() s = set([l[0]]) res = 1 for i in l: f = 1 for j in s: if(i%j == 0): f = 0 break if(f): s.add(i) res += 1 print(res),quadratic,"['greedy', 'implementation', 'math']",179
n=int(input()) a=sorted([int(x) for x in input().split()]) counter=0 test=[False]*n for j in range(n): if not test[j]: for i in range(n): if not test[i] and a[i]%a[j]==0: test[i]=True counter+=1 print(counter),quadratic,"['greedy', 'implementation', 'math']",209
"n=int(input()) l=list(map(int,input().split())) l.sort() vis=[0]*n ans=0 for i in range(n): if(vis[i]==0): ans+=1 x=l[i] for j in range(n): if l[j]%x==0: vis[j]=1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",173
"n = int(input()) a = list(map(int, input().split())) a.sort() ans = 0 while len(a) > 0: k = a.pop(0) a = [i for i in a if i % k != 0] ans += 1 print(ans)",quadratic,"['greedy', 'implementation', 'math']",153
"n = int(input()) a = list(map(int, input().split())) a.sort() k = 0 for i in range(n) : if a[i] : k += 1 for j in range(i + 1, n) : if a[j] and a[j] % a[i] == 0 : a[j] = 0 print(k)",quadratic,"['greedy', 'implementation', 'math']",180
"from sys import stdin from math import factorial n, mod = map(int, stdin.readline().split()) def binom(n, m): return factorial(n) // factorial(m) // factorial(n-m) def foo(x, k): ans = 0 for i in range(k, 0, -1): sign = 1 if (i-k)%2 == 0 else -1 ans += sign * binom(k, i) * (i**x) ans %= mod return ans def f(x, k): return (foo(x, k) * pow(2, x-k, mod)) % mod ans = 0 for i in range((n+1)//2): ans = (ans + f(n-i, i+1)) ans %= mod print(ans)",quadratic,"['combinatorics', 'dp', 'math']",441
"print(k[n]%m)""",quadratic,"['combinatorics', 'dp', 'math']",14
"from sys import stdin from math import factorial n, mod = map(int, stdin.readline().split()) def binom(n, m): return factorial(n) // factorial(m) // factorial(n-m) def foo(x, k): ans = 0 for i in range(k, 0, -1): sign = 1 if (i-k)%2 == 0 else -1 ans += sign * binom(k, i) * (i**x) ans %= mod return ans def f(x, k): return (foo(x, k) * pow(2, x-k, mod)) % mod ans = 0 for i in range((n+1)//2): ans = (ans + f(n-i, i+1)) ans %= mod print(ans)",quadratic,"['combinatorics', 'dp', 'math']",441
"import sys input = sys.stdin.readline def main(): n = int(input()) alst = [int(input()) for _ in range(n)] ans = [] for a in alst: if a == 1: ans.append(""1"") print(""."".join(ans)) continue while ans and int(ans[-1]) != a - 1: ans.pop() if not ans: ans.append(str(a)) else: ans.pop() ans.append(str(a)) print(""."".join(ans)) for _ in range(int(input())): main()",quadratic,"['brute force', 'data structures', 'greedy', 'implementation', 'trees']",358
"def main(): def num(left, right, dp, rev, revI): if left > right: return 1 key = left, rev, revI if key in dp: return dp[key] nonlocal ans acc = 0 for x in ('01' if ans[left]==' temp = None if left == right: tmp = x elif ans[right]==' tmp = '01' else: tmp = ans[right] for y in tmp: if not ((rev and x>y) or (revI and x==y=='1')): acc += num( left+1, right-1, dp, rev and x==y, revI and x!=y ) dp[key] = acc return acc n, k = map(int, input().split()) k += 1 ans = [' for i in range(n): ans[i] = '0' tmp = num(0, n-1, {}, True, True) if k > tmp: k -= tmp ans[i] = '1' if ans[0] == '0': print(''.join(ans)) else: print(-1) if __name__ == '__main__': import sys, os from time import time if len(sys.argv)>1 and os.path.exists(sys.argv[1]): sys.stdin = open(sys.argv[1], 'rb') st = time() main() print('----- Run {:.6f} seconds. -----'.format(time()-st), file=sys.stderr)",cubic,"['dp', 'graphs']",868
"n, m = map(int, input().split()) m += 1 def calc(l, r, eq, eq_i): if l > r: return 1 key = l, eq, eq_i if key in f: return f[key] t = 0 for x in (['0', '1'] if s[l] == '?' else [s[l]]): if l == r: a = [x] else: a = ['0', '1'] if s[r] == '?' else [s[r]] for y in a: if not((eq and x > y) or (eq_i and x == y == '1')): t += calc(l + 1, r - 1, eq and x == y, eq_i and x != y) f[key] = t return t s = ['?'] * n for i in range(n): s[i] = '0' f = {} p = calc(0, n - 1, True, True) if m > p: m -= p s[i] = '1' if s[0] == '0': print(''.join(s)) else: print(-1)",cubic,"['dp', 'graphs']",552
"def raschot(d, e, g, h): if d > e: return 1 key = d, g, h if key in b: return b[key] f = 0 for x in (['0', '1'] if a0[d] == '?' else [a0[d]]): if d == e: a = [x] else: a = ['0', '1'] if a0[e] == '?' else [a0[e]] for y in a: if not ((g and x > y) or (h and x == y == '1')): f += raschot(d + 1, e - 1, g and x == y, h and x != y) b[key] = f return f n, m = map(int, input().split()) m += 1 a0 = ['?'] * n for i in range(n): a0[i] = '0' b = {} c = raschot(0, n - 1, True, True) if m > c: m -= c a0[i] = '1' if a0[0] == '0': print(''.join(a0)) else: print(-1)",cubic,"['dp', 'graphs']",555
"s=input() m=0 n=len(s) for i in range(n-1): for j in range(i,n+1) : if s[i:j] in s[i+1:n] and len(s[i:j])>m: m=len(s[i:j]) print(m)",cubic,"['brute force', 'greedy']",131
"n = input() m = 0 for i in range(len(n)): for j in range(i,len(n)+1): if len(n[i:j])>m and n[i:j] in n[i+1:len(n)]: m = len(n[i:j]) print(m)",cubic,"['brute force', 'greedy']",140
"def STR(): return list(input()) def INT(): return int(input()) def MAP(): return map(int, input().split()) def MAP2():return map(float,input().split()) def LIST(): return list(map(int, input().split())) def STRING(): return input() import string import sys from heapq import heappop , heappush from bisect import * from collections import deque , Counter from math import * from itertools import permutations , accumulate dx = [-1 , 1 , 0 , 0 ] dy = [0 , 0 , 1 , - 1] s = STR() if len(set(s)) == len(s): print('0') exit(0) d = [] for i in range(len(s)): for j in range(i+1 , len(s)): x = '' for k in range(i , j+1): x += s[k] d.append(x) v = {} for i in range(len(s)): if s[i] not in v : v[s[i]] = 1 else: v[s[i]] +=1 for i in d : if i not in v : v[i] = 1 else: v[i]+=1 mx = -1 ans = '' for i in v : if v[i] >= 2 : if len(i) > mx : mx = max(mx , len(i)) print(mx)",cubic,"['brute force', 'greedy']",863
"S = input() best = 0 for i in range(len(S)): for j in range(i+1, len(S)+1): s = S[i:j] c = 0 for k in range(len(S)): if S[k:].startswith(s): c += 1 if c >= 2: best = max(best, len(s)) print(best)",cubic,"['brute force', 'greedy']",195
"s=input() n=len(s) m=0 for i in range(n-1): for j in range(1,n-i): if s[i:i+j] in s[i+1:]: if j>m: m=j print(m)",cubic,"['brute force', 'greedy']",111
cadena = input() n = len(cadena) rpta = 0 for i in range(n-1): tamanho_cadena = n-i-1 for j in range(n-tamanho_cadena): subcadena = cadena[j:j+tamanho_cadena] contador = 1 for k in range(n-tamanho_cadena-j): if subcadena == cadena[j+k+1:j+k+1+tamanho_cadena]: contador = contador + 1 if contador >=2 and rpta == 0: rpta = tamanho_cadena if rpta !=0: break print(rpta),cubic,"['brute force', 'greedy']",367
"import sys from random import * from bisect import * from heapq import * pl=1 from math import gcd,sqrt,ceil from copy import * sys.setrecursionlimit(10**5) if pl: input=sys.stdin.readline else: sys.stdin=open('input.txt', 'r') sys.stdout=open('outpt.txt','w') def li(): return [int(xxx) for xxx in input().split()] def fi(): return int(input()) def si(): return list(input().rstrip()) def mi(): return map(int,input().split()) t=1 while t>0: t-=1 s=input().rstrip() n=len(s) d={} for i in range(n): r="""" for j in range(i,n): r+=s[j] if r not in d: d[r]=1 else: d[r]+=1 maxi=0 for i in d: if d[i]>=2: maxi=max(maxi,len(i)) print(maxi)",cubic,"['brute force', 'greedy']",634
"s = input() n = len(s) m = n - 1; while m > 0: find = False for i in range(0, n - m): for j in range(i + 1, n - m + 1): match = True for k in range(0, m): if s[i+k] != s[j+k]: match = False break if match: find = True break if find: break if find: break m -= 1 print(m)",cubic,"['brute force', 'greedy']",269
"s=input() o=len(s) k=0 for i in range(o): r={0} for j in range(o-i+1): if s[j:j+i] in r:k=max(i,k) else:r.add(s[j:j+i]) print(k)",cubic,"['brute force', 'greedy']",128
"s=input() n=len(s) m=n-1; while m>0: f=False for i in range(0,n-m): for j in range(i+1,n-m+1): x=True for k in range(0,m): if s[i+k]!=s[j+k]: x=False break if x: f=True break if f: break if f: break m -= 1 print(m)",cubic,"['brute force', 'greedy']",214
"a=input() n=len(a) for i in range(n-1,-1,-1): b=sorted([a[j:j+i] for j in range(n-i+1)]) if True in [b[j]==b[j-1] for j in range(1,n-i+1)]: print(i) break",cubic,"['brute force', 'greedy']",154
"import re import sys exit=sys.exit from bisect import bisect_left as bsl,bisect_right as bsr from collections import Counter,defaultdict as ddict,deque from functools import lru_cache cache=lru_cache(None) from heapq import * from itertools import * from math import inf from pprint import pprint as pp enum=enumerate ri=lambda:int(rln()) ris=lambda:list(map(int,rfs())) rln=sys.stdin.readline rl=lambda:rln().rstrip('\n') rfs=lambda:rln().split() cat=''.join catn='\n'.join mod=1000000007 d4=[(0,-1),(1,0),(0,1),(-1,0)] d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)] s=rl() n=len(s) ans=0 for i in range(n-1): for j in range(i+1,n): for k in range(n-j): if s[i+k]!=s[j+k]: break ans=max(ans,1+k) print(ans)",cubic,"['brute force', 'greedy']",719
"import sys import string from collections import Counter, defaultdict from math import fsum, sqrt, gcd, ceil, factorial from operator import * from itertools import accumulate, count inf = float(""inf"") flush = lambda: sys.stdout.flush comb = lambda x, y: (factorial(x) // factorial(y)) // factorial(x - y) ip = lambda: input() ii = lambda: int(input()) r = lambda: map(int, input().split()) rr = lambda: list(r()) arr = ip() n = len(arr) ms = """" mn = 0 def counter(s, x): p = len(x) px = 0 for i in range(len(s)): if s[i : i + p] == x: px += 1 return px for i in range(n): s = """" for j in range(i, n): s += arr[j] c = counter(arr, s) if c > 1 and len(s) > mn: ms = s mn = len(s) print(mn)",cubic,"['brute force', 'greedy']",688
"import sys import logging logging.root.setLevel(level=logging.DEBUG) import re s = sys.stdin.readline().strip() from collections import defaultdict substr = defaultdict(int) for left in range(len(s)): for right in range(left+1,len(s)+1): substr[s[left:right]] += 1 max_len = 0 for segment,times in substr.items(): if times >= 2: max_len = max(max_len,len(segment)) print(max_len)",cubic,"['brute force', 'greedy']",379
"string = str(input()) length = len(string) counter = 0 li = [] match_li = [] for i in range(length): letter = string[i] letters = letter if letter in li: match_li.append(letter) li.append(letter) for j in range(i+1, length): letters += string[j] if letters in li: match_li.append(letters) li.append(letters) longest = 0 for k in match_li: if len(k) > longest: longest = len(k) print(longest)",cubic,"['brute force', 'greedy']",391
s = input() def check_x(mid): ans = 'no' d = {} for i in range(len(s)-mid+1): if s[i:i+mid] in d.keys(): ans = 'yes' break d[s[i:i+mid]] = 1 return ans l = 0 r = len(s) - 1 while r-l > 1: mid = (r+l) // 2 ans = check_x(mid) if ans == 'yes': l = mid else: r = mid if check_x(r) == 'yes': print(r) else: print(l),cubic,"['brute force', 'greedy']",310
"def countall(string, substring): total = 0 for i in range(len(string)-len(substring)+1): if string[i:i+len(substring)] == substring: total += 1 return total n = input() allvalues = [] for i in range(len(n)): for j in range(len(n)-1, i-1, -1): if countall(n, n[i:j+1]) > 1: allvalues.append(j-i+1) break try: print(max(allvalues)) except: print(0)",cubic,"['brute force', 'greedy']",346
"string=input() n=len(string) count1=[] long=0 for s_i in range(n): for end_i in range(s_i+1,n+1): sub=string[s_i:end_i] if sub not in count1: count1.append(sub) else: if len(sub)>long: long=len(sub) print(long)",cubic,"['brute force', 'greedy']",210
"string=input() n=len(string) check=True for sub_len in range(n-1,0,-1): for starting_index in range(n-sub_len+1): if string[starting_index:starting_index+sub_len] in string[starting_index+1:]: print(sub_len) check=False break if check==False: break if check: print(0)",cubic,"['brute force', 'greedy']",267
"s=input() length=len(s) answer=[ ] for i in range (0,length): for j in range(i+1,length+1): k=s[i:j] co=0 for u in range (0,length): if(s[u:].startswith(k)): co+=1 if(co>=2): answer.append(len(k)) if(len(set(s))==length): print('0') else: print(max(answer))",cubic,"['brute force', 'greedy']",257
"import sys, math, cmath, time, collections from collections import deque, Counter, OrderedDict, defaultdict from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace from math import ceil, floor, log, log2, sqrt, gcd, factorial, pow, pi from bisect import bisect_left, bisect_right import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") def print(*args, **kwargs): sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout) at_start = True for x in args: if not at_start: file.write(sep) file.write(str(x)) at_start = False file.write(kwargs.pop(""end"", ""\n"")) if kwargs.pop(""flush"", False): file.flush() if sys.version_info[0] < 3: sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout) else: sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOW",cubic,"['brute force', 'greedy']",2000
"leng = 0 s = input() for i in range(len(s)): for j in range(i + 1, len(s) + 1): sub = s[i:j] if s.count(sub) >= 2 and len(sub) > leng: leng = len(sub) elif s.count(sub) == 1: for k in range(1, len(sub)): if s[i - k:j - k] == sub and len(sub) > leng: leng = len(sub) print(leng)",cubic,"['brute force', 'greedy']",277
"s = input() res = 0 for i in range(len(s)): for j in range(i,len(s)): for f in range(i+1,len(s)): if len(s) >= f + j-i: if (s[i:j]== s[f:f+j-i]): res = max(res,j - i) print(res)",cubic,"['brute force', 'greedy']",177
"s = input() ans = 0 for i in range(len(s)): for j in range(i + 1, len(s)): cur = s[i:j] if cur in s[:(j - 1)] or cur in s[(i + 1):]: ans = max(ans, j - i) print(ans)",cubic,"['brute force', 'greedy']",165
"string = input() totalmax = 0; for x in range(len(string)): curr = """" for y in string[x:]: curr +=y; if string[x:].rfind(curr) != string[x:].find(curr): totalmax = max(totalmax, len(curr)) continue print(totalmax)",cubic,"['brute force', 'greedy']",213
"line = input() n = len(line) temp = [0] for i in range(1, n): for j in range(n-i): for k in range(1, n-i-j+1): if line[j:j+i] == line[j+k:j+k+i]: temp.append(i) print(max(temp))",cubic,"['brute force', 'greedy']",177
"s = input() mc = -1 for i in range(len(s)): for j in range(i+1, len(s)): cu = 0 for cu in range(len(s)-max(i, j)): if s[i+cu] == s[j+cu]: mc = max(mc, cu) else: break print(mc + 1)",cubic,"['brute force', 'greedy']",180
"s = input() k = [] for i in range(len(s)): for j in range(i+1,len(s)+2): x = s[i:j] for t in range(i+1,len(s)): if x == s[t:t+j-i]: k += [j-i] print(max(k) if k != [] else 0)",cubic,"['brute force', 'greedy']",174
"inputS=input() ans=0 for i in range (0,len(inputS)-1): for count in range(1,len(inputS)): for j in range(i+1, len(inputS)-count+1): A=inputS[i: i+count] B=inputS[j: j+count] if A==B: ans=count if count>ans else ans print(ans)",cubic,"['brute force', 'greedy']",225
"s = input() res = 0 solve = 0 for pos in range(1,len(s)): for i in range(len(s) - pos): if s[i:i+pos] in s[i+1:]: if solve < pos: solve = pos print(solve)",cubic,"['brute force', 'greedy']",154
"S = input() ans = 0 met = set() for i in range(len(S)): for j in range(i, -1, -1): if S[j:i+1] in met: ans = max(ans, i - j + 1) else: met.add(S[j:i+1]) print(ans)",cubic,"['brute force', 'greedy']",163
"str=input() m=0 n=len(str) for i in range(n): for j in range(i,n+1) : if str[i:j] in str[i+1:n] and len(str[i:j])>m: m=len(str[i:j]) print(m)",cubic,"['brute force', 'greedy']",141
"st=input() m=0 n=len(st) for i in range(n): for j in range(i,n+1) : if st[i:j] in st[i+1:n] and len(st[i:j])>m: m=len(st[i:j]) print(m)",cubic,"['brute force', 'greedy']",135
"s = input() for i in range(len(s), 0, -1): for j in range(len(s) - i + 1): if s[j: j + i] in s[j + 1:]: print(i) exit() print(0)",cubic,"['brute force', 'greedy']",128
"s = input() pb = 0 lenght = len(s)-1 w = [] while(lenght!=0): ss = s[pb:pb+lenght] w.append(ss) if pb+lenght==len(s): pb = 0 lenght -= 1 else: pb+=1 for i in range(0,len(w)-1): for j in range(i+1,len(w)): if (w[i]==w[j]): print(len(w[i])) exit(0) print(0)",cubic,"['brute force', 'greedy']",255
"def occurrences(string, sub): count = start = 0 while True: start = string.find(sub, start) + 1 if start > 0: count += 1 else: return count class CodeforcesTask23ASolution: def __init__(self): self.result = '' self.string = '' def read_input(self): self.string = input() def process_task(self): o_max = 0 for x in range(len(self.string)): for y in range(x): m = occurrences(self.string, self.string[y:x]) if m >= 2: o_max = max(x - y, o_max) self.result = str(o_max) def get_result(self): return self.result if __name__ == ""__main__"": Solution = CodeforcesTask23ASolution() Solution.read_input() Solution.process_task() print(Solution.get_result())",cubic,"['brute force', 'greedy']",648
"s = input() n = len(s) m = n - 1; while m > 0: find = False for i in range(0, n - m): for j in range(i + 1, n - m + 1): match = True for k in range(0, m): if s[i+k] != s[j+k]: match = False break if match: find = True break if find: break if find: break m -= 1 print(m)",cubic,"['brute force', 'greedy']",269
"def cic(my_string): my_hash=set(); max_v=-1<<256; for i in range(len(my_string)): empty=my_string[i]+'' if empty in my_hash: max_v=max(max_v,len(empty)) else: my_hash.add(empty) for j in range(i+1,len(my_string)): empty+=my_string[j] if empty not in my_hash: my_hash.add(empty) else: max_v=max(max_v,len(empty)) return 0 if max_v<0 else max_v def main(): my_string=input() print(cic(my_string)) if __name__=='__main__': main()",cubic,"['brute force', 'greedy']",426
"str=input() n=len(str) ans=0 amap={} def fun(): global ans for strLen in range(n,0,-1): mark=0 for t in range(0,n): if t+strLen>n: break s=str[t:t+strLen] if s in amap: amap[s]+=1 else: amap[s]=1 if amap[s]>=2: mark=1 ans=len(s) print(ans) break if mark==1: break fun() if ans==0: print(ans)",cubic,"['brute force', 'greedy']",291
"a = input() l = 0 for i in range(1, len(a)): for j in range(0, len(a) - i + 1): t = a.find(a[j:j + i]) c = a.rfind(a[j:j + i]) if t != c: if i > l: l = i print(l)",cubic,"['brute force', 'greedy']",162
"x=input() a=0 for i in range(len(x)): for j in range(i,len(x)): if x[i:j] in x[i+1:]: if len(x[i:j])>a: a=len(x[i:j]) print(a)",cubic,"['brute force', 'greedy']",126
"def maxlen(): string = input() maxi = 0; for x in range(len(string)): substring = """" for y in string[x:]: substring +=y; if string[x:].rfind(substring) != string[x:].find(substring): maxi = max(maxi, len(substring)) continue print(maxi) maxlen()",cubic,"['brute force', 'greedy']",245
"string = input().strip() mx = 0 for i in range(len(string)): for j in range(i+1, len(string)): m = 0 while(j+m < len(string) and string[i+m] == string[j+m]): m += 1 mx = max(mx, m) print(mx)",cubic,"['brute force', 'greedy']",190
"s=list(input()) dic={} for i in range(0,len(s)): for j in range(i,len(s)): ele="""".join(s[i:j+1]) if ele not in dic: dic[ele]=1 else: dic[ele]+=1 ans=[] for key in dic.keys(): if dic[key]>=2: ans.append(len(key)) ans.sort() if ans==[]: print(0) else: print(ans[-1])",cubic,"['brute force', 'greedy']",264
"s = input() n = len(s) for L in range(n-1, 0, -1): if len({s[i:i+L] for i in range(n-L+1)}) < n-L+1: print(L) break else: print(0)",cubic,"['brute force', 'greedy']",130
"import sys import math import itertools import functools import collections import operator import fileinput import copy ORDA = 97 def ii(): return int(input()) def mi(): return map(int, input().split()) def li(): return list(map(int, input().split())) def lcm(a, b): return abs(a * b) // math.gcd(a, b) def revn(n): return str(n)[::-1] def dd(): return collections.defaultdict(int) def ddl(): return collections.defaultdict(list) def sieve(n): if n < 2: return list() prime = [True for _ in range(n + 1)] p = 3 while p * p <= n: if prime[p]: for i in range(p * 2, n + 1, p): prime[i] = False p += 2 r = [2] for p in range(3, n + 1, 2): if prime[p]: r.append(p) return r def divs(n, start=2): r = [] for i in range(start, int(math.sqrt(n) + 1)): if (n % i == 0): if (n / i == i): r.append(i) else: r.extend([i, n // i]) return r def divn(n, primes): divs_number = 1 for i in primes: if n == 1: return divs_number t = 1 while n % i == 0: t += 1 n //= i divs_number *= t def prime(n): if n == 2: return True if n % 2 == 0 or n <= 1: return False sqr = int(math.sqrt(n)) + 1 for d in range(3, sqr, 2): if n % d == 0: return False return True def convn(number, base): newnumber = 0 while number > 0: newnumber += number % base number //= base return newnumber def cdiv(n, k): return n // k + (n % k != 0) s = input() lens = len(s) max_ = 0 for i in range(1, lens): d = {} for j in range(lens - i + 1): if s[j: j + i] in d: d[s[j: j + i]] += 1 else: d[s[j: j + i]] = 1 maxd = max(d.values()) if max(d.values()) > 1: max_ = i print(max_)",cubic,"['brute force', 'greedy']",1531
"t = input() n = len(t) maxi = 0 for i in range(n): s = t[i] if t.count(s) > 1: maxi = max(maxi, 1) nr = 1 for j in range(i + 1, n): s += t[j] nr += 1 g = 0 for h in range(n - nr + 1): if s == t[h:h + nr]: g += 1 if g > 1: maxi = max(nr,maxi) print(maxi)",cubic,"['brute force', 'greedy']",253
"s=input() for ln in range(len(s),0,-1): for L in range(len(s)-ln+1): if s[L:L+ln] in s[L+1:]: print(ln) exit() print(0)",cubic,"['brute force', 'greedy']",119
"S = input() sLen, ans = len(S), 0 for i in range(sLen): for till1 in range(i + 1, sLen): till2 = till1 + 1 for j in range(i + 1, sLen): if till2 > sLen: break sub1 = S[i:till1] sub2 = S[j:till2] subLen = len(sub1) if sub1 == sub2 and ans < subLen: ans = subLen till2 += 1 print(ans)",cubic,"['brute force', 'greedy']",282
"s, ans, = input(), 0 sLen = len(s) for i in range(sLen): for till1 in range(i + 1, sLen + 1): till2 = till1 + 1 for j in range(i + 1, sLen + 1): if till2 > sLen: break sub1 = s[i:till1] sub2 = s[j:till2] subLen = len(sub1) if sub1 == sub2 and ans < subLen: ans = subLen till2 += 1 print(ans)",cubic,"['brute force', 'greedy']",291
"s = input() sLen, ans = len(s), 0 for i in range(sLen - 1): for till1 in range(i + 1, sLen): till2 = till1 + 1 for j in range(i + 1, sLen): if till2 > sLen: break; sub1 = s[i:till1] sub2 = s[j:till2] subLen = len(sub1) if sub1 == sub2 and subLen > ans: ans = subLen till2 += 1 print(ans)",cubic,"['brute force', 'greedy']",287
"s = input() sLen, ans = len(s), 0 for i in range(sLen): for till1 in range(i + 1, sLen + 1): till2 = till1 + 1 for j in range(i + 1, sLen): if till2 > sLen: break sub1 = s[i:till1] sub2 = s[j:till2] subLen = len(sub1) if sub1 == sub2 and ans < subLen: ans = subLen till2 += 1 print(ans)",cubic,"['brute force', 'greedy']",286
"from sys import stdin s=stdin.readline() for ln in range(len(s),0,-1): for L in range(len(s)-ln+1): if s[L:L+ln] in s[L+1:]: print(ln) exit() print(0)",cubic,"['brute force', 'greedy']",150
"a=input() n=len(a) for l in range(n,0,-1): for i in range(n-l+1): if a[i:i+l] in a[i+1:]: print(l) exit(0) print(0)",cubic,"['brute force', 'greedy']",115
"n=input() m={} def podstroka(s:str): for i in range(0,len(s)): for j in range(i+1,len(s)+1): if s[i:j] in m: m[s[i:j]] +=1 else: m[s[i:j]] = 1 return m podstroka(n) maxlen = 0 for x in m: if m[x]>=2 and len(x)>maxlen: maxlen=len(x) print(maxlen)",cubic,"['brute force', 'greedy']",245
"S = input() best = 0 for i in range(len(S)): for j in range(i+1, len(S)+1): s = S[i:j] c = 0 for k in range(len(S)): if S[k:].startswith(s): c += 1 if c >= 2: best = max(best, len(s)) print(best)",cubic,"['brute force', 'greedy']",195
"name = input() for i in range(len(name), 0, -1): for j in range(len(name) - i + 1): if name[j: j + i] in name[j + 1:]: print(i) exit() print(0)",cubic,"['brute force', 'greedy']",143
"x=input();l=len(x);m=0 for i in range(l-1): f=i while 1 : idx = x[f+1:].find(x[f]) if idx == -1 : break else: idx += f+1 ; c=ans=0 for j in range(idx , l) : if x[j] == x[i+c]: ans+=1 c+=1 else: break if m < ans : m=ans f = idx print(m)",cubic,"['brute force', 'greedy']",235
"x=input();l=len(x);m=0 for i in range(l-1): f=i while 1 : idx = x[f+1:].find(x[f]) if idx == -1 : break else: idx += f+1 ; c=ans=0 for j in range(idx , l) : if x[j] == x[i+c]: ans+=1 c+=1 else: break if m < ans : m=ans f = idx print(m)",cubic,"['brute force', 'greedy']",235
"s = input() n,m = len(s),0 for i in range(n-1): for j in range(i,n+1): if len(s[i:j]) > m and s[i:j] in s[i+1:n]: m = len(s[i:j]) print(m)",cubic,"['brute force', 'greedy']",138
"s=input() ans=0 m=set() for i in range(len(s)): for j in range(i,-1,-1): if(s[j:i+1] in m): ans=max(ans,i-j+1) else: m.add(s[j:i+1]) print(ans)",cubic,"['brute force', 'greedy']",143
"string = input() size = len(string) ans_got = 0 for s in range(1,size)[::-1]: dic = {} for i in range(0,size-s+1): if(string[i:i+s] in dic): print(s) ans_got = 1 break else: dic[string[i:i+s]] = 1 if(ans_got == 1): break if(ans_got == 0): print(0)",cubic,"['brute force', 'greedy']",247
"def cnt(s,t): i,c=0,0 while(s.count(t)): s=s[s[i:].index(t)+1:] c+=1 return c s=(input()) n=len(s) ln=0 for i in range(n): for j in range(i,n): if(j-i+1<=ln): continue if(cnt(s,s[i:j+1])>=2): ln=max(ln,j-i+1) print(ln)",cubic,"['brute force', 'greedy']",218
"for ctr in range(1): s=input().strip() for l in range(len(s),0,-1): k=[] for i in range(0,len(s)-l+1): k.append(s[i:i+l]) if len(k)!=len(list(set(k))): print(l) exit() print(0)",cubic,"['brute force', 'greedy']",176
"z,zz=input,lambda:list(map(int,z().split())) zzz=lambda:[int(i) for i in stdin.readline().split()] szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz()) from string import * from re import * from collections import * from queue import * from sys import * from collections import * from math import * from heapq import * from itertools import * from bisect import * from collections import Counter as cc from math import factorial as f from bisect import bisect as bs from bisect import bisect_left as bsl from itertools import accumulate as ac def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2)) def prime(x): p=ceil(x**.5)+1 for i in range(2,p): if (x%i==0 and x!=2) or x==0:return 0 return 1 def dfs(u,visit,graph): visit[u]=True for i in graph[u]: if not visit[i]: dfs(i,visit,graph) l=z() n=len(l) ans=0 for i in range(n): for j in range(i+1,n+1): p=l[i:j] t=len(p) x=0 for k in range( n): if l[k:k+t]==p: x+=1 if x>=2: ans=max(ans,t) print(ans)",cubic,"['brute force', 'greedy']",974
"s = input() slen = len(s) ans = 0 for st1 in range(slen - 1): for end1 in range(st1 + 1, slen): end2 = end1 + 1 sub1 = s[st1:end1] for st2 in range(st1 + 1, slen): if end2 > slen: break sub2 = s[st2:end2] subLen = len(sub1) if sub1 == sub2 and ans < subLen: ans = subLen end2 += 1 print(ans)",cubic,"['brute force', 'greedy']",291
"from math import log import random spaces = ("" "",""\n"",""\t"") stops = ("""","" "",""\n"",""\t"") extendedPoints = set() startingPoints = set() interestPoints = [] class TPoint: def __init__(self,x,y): self.x=x self.y=y def __str__(self): return ""(""+str(self.x)+"",""+str(self.y)+"")"" def __eq__(self, other): return self.x == other.x and self.y == other.y def __hash__(self): return self.x*20000 + self.y x=0 y=0 h=0 def sortKey(p): return p.h def heuristic(p, otherPoints): minH = float(""inf"") for point in otherPoints: currentH = abs(point.x - p.x) + abs(point.y - p.y) if currentH < minH: minH = currentH return minH def addPoint(p,pointList): if not p in extendedPoints: p.h = heuristic(p,startingPoints) extendedPoints.add(p) pointList.append(p) return True else: return False def extend(point,n,m,poinList): ok = False if point.x>1: ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok if point.y>1: ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok if point.y<m: ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok if point.x<n: ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok if point.y>1: ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok if point.y<m: ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok if point.y>1: ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok if point.y<m: ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok return ok def ReadNext(fileObject): currentBuffer = """" currentRead=fileObject.read(1) while currentRead in spaces: currentRead=fileObject.read(1) currentBuffer = currentBuffer + currentRead while not currentRead in stops: currentRead=fileObject.read(1) currentBuffer = currentBuffer + currentRead return currentBuffer.strip() w, r= open('output.txt', 'w'), open('input.txt', 'r') n = int(ReadNext(r)) m = int(ReadNext(r)) k = int(ReadNext(r)) mscale = 5 for i in range(k): x = int(ReadNext(r)) y = int(ReadNext(r)) p = TPoint(x,y) startingPoints.add(p) extendedPoints.add(p) tmpPoints = [] tmpPoints.append(TPoint(1,1))",cubic,"['brute force', 'dfs and similar', 'shortest paths']",1999
"import os import sys from io import BytesIO, IOBase from collections import deque def main(): with open('input.txt') as fp: input=fp.readline n, m = map(int, input().split()) dx = [1, -1, 0, 0] dy = [0, 0, -1, 1] q =deque() k = int(input()) a = list(map(int, input().split())) v = [[1] * (m + 2) for _ in range(n + 2)] for i in range(m + 2): v[0][i] = 0 v[-1][i] = 0 for i in range(n + 2): v[i][0] = 0 v[i][-1] = 0 for i in range(0, 2 * k, 2): q.append((a[i],a[i + 1])) v[a[i]][a[i + 1]] = 0 while 1: x, y =q.popleft() for i in range(4): xx, yy = x + dx[i], y + dy[i] if v[xx][yy]: q.append((xx, yy)) v[xx][yy] = 0 if not q: with open('output.txt', mode='w') as fpp: fpp.write(f'{x} {y}') break BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lam",cubic,"['brute force', 'dfs and similar', 'shortest paths']",1999
"import os.path from math import gcd, floor, ceil from collections import * import sys mod = 1000000007 INF = float('inf') def st(): return list(sys.stdin.readline().strip()) def li(): return list(map(int, sys.stdin.readline().split())) def mp(): return map(int, sys.stdin.readline().split()) def inp(): return int(sys.stdin.readline()) def pr(n): return sys.stdout.write(str(n)+""\n"") def prl(n): return sys.stdout.write(str(n)+"" "") if os.path.exists('input.txt'): sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') dx = [0, 0, 1, -1] dy = [1, -1, 0, 0] def solve(): n, m = mp() k = inp() l = li() q = deque() v = [[0]*(m+1) for i in range(n+1)] for i in range(0, 2*k - 1, 2): q.append((l[i], l[i+1])) v[l[i]][l[i+1]] = 1 while q: a, b = q.popleft() for i in range(4): A, B = a+dx[i], b+dy[i] if A > 0 and A <= n and B > 0 and B <= m: if not v[A][B]: q.append((A, B)) v[A][B] = 1 print(a, b) for _ in range(1): solve()",cubic,"['brute force', 'dfs and similar', 'shortest paths']",938
"with open(""input.txt"",""r"") as in_file: with open(""output.txt"",""a"") as out_file: N,M = map(int,in_file.readline().split()) K = int(in_file.readline()) map_max_dist = [[5000 for i in range(M)] for j in range(N)] inputs = list(map(int,in_file.readline().split())) p = 0 while(p<=K*2-2): x,y = inputs[p]-1,inputs[p+1]-1 for r in range(N): for c in range(M): dist = abs(x-r)+abs(y-c) if dist<map_max_dist[r][c]: map_max_dist[r][c] = dist p+=2 max_val = 0 max_index = (0,0) i,j = 0,0 for i in range(N): for j in range(M): if(map_max_dist[i][j]>max_val): max_val = map_max_dist[i][j] max_index = (i,j) out_file.write(""{} {}"".format(max_index[0]+1,max_index[1]+1))",cubic,"['brute force', 'dfs and similar', 'shortest paths']",656
"from collections import deque with open(""input.txt"",""r"") as input_file: with open(""output.txt"",""a"") as output_file: N,M = map(int,input_file.readline().split()) K = int(input_file.readline()) T = list(map(int,input_file.readline().split())) graph = [[0] * (M + 1) for _ in range(N + 1)] queue = deque() for i in range(0, 2 * K - 1, 2): graph[T[i]][T[i + 1]] = 1 queue.append((T[i], T[i + 1])) x, y = 0, 0 while queue: x, y = queue.popleft() x_moves = [x - 1, x + 1, x, x] y_moves = [y, y, y - 1, y + 1] for i in range(len(x_moves)): if 0 < x_moves[i] <= N and 0 < y_moves[i] <= M: if graph[x_moves[i]][y_moves[i]] == 0: x = x_moves[i] y = y_moves[i] graph[x_moves[i]][y_moves[i]] = 1 queue.append((x_moves[i], y_moves[i])) output_file.write(f""{x} {y}"")",cubic,"['brute force', 'dfs and similar', 'shortest paths']",752
"import sys from functools import lru_cache, cmp_to_key from heapq import merge, heapify, heappop, heappush from math import * from collections import defaultdict as dd, deque, Counter as C from itertools import combinations as comb, permutations as perm from bisect import bisect_left as bl, bisect_right as br, bisect, insort from time import perf_counter from fractions import Fraction import copy from copy import deepcopy import time starttime = time.time() mod = int(pow(10, 9) + 7) mod2 = 998244353 def data(): return sys.stdin.readline().strip() def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end) def L(): return list(sp()) def sl(): return list(ssp()) def sp(): return map(int, data().split()) def ssp(): return map(str, data().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)] try: sys.stdin = open(""input.txt"", ""r"") sys.stdout = open(""output.txt"", ""w"") except: pass def pmat(A): for ele in A: print(*ele,end=""\n"") n, m = L() k = L()[0] a = [[0] * m for _ in range(n)] dq = deque() line = list(map(lambda x: int(x) - 1, L())) for i in range(0, 2 * k, 2): a[line[i]][line[i + 1]] = 1 dq.append((line[i], line[i + 1])) x, y = -1, -1 while dq: x, y = dq.popleft() for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)): if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]: a[tx][ty] = 1 dq.append((tx, ty)) print(f'{x+1} {y+1}')",cubic,"['brute force', 'dfs and similar', 'shortest paths']",1429
"from math import log import random spaces = ("" "",""\n"",""\t"") stops = ("""","" "",""\n"",""\t"") extendedPoints = set() startingPoints = set() interestPoints = [] class TPoint: def __init__(self,x,y): self.x=x self.y=y def __str__(self): return ""(""+str(self.x)+"",""+str(self.y)+"")"" def __eq__(self, other): return self.x == other.x and self.y == other.y def __hash__(self): return self.x*20000 + self.y x=0 y=0 h=0 def sortKey(p): return p.h def heuristic(p, otherPoints): minH = float(""inf"") for point in otherPoints: currentH = abs(point.x - p.x) + abs(point.y - p.y) if currentH < minH: minH = currentH return minH def addPoint(p,pointList): if not p in extendedPoints: p.h = heuristic(p,startingPoints) extendedPoints.add(p) pointList.append(p) return True else: return False def extend(point,n,m,poinList): ok = False if point.x>1: ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok if point.y>1: ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok if point.y<m: ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok if point.x<n: ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok if point.y>1: ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok if point.y<m: ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok if point.y>1: ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok if point.y<m: ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok return ok def ReadNext(fileObject): currentBuffer = """" currentRead=fileObject.read(1) while currentRead in spaces: currentRead=fileObject.read(1) currentBuffer = currentBuffer + currentRead while not currentRead in stops: currentRead=fileObject.read(1) currentBuffer = currentBuffer + currentRead return currentBuffer.strip() w, r= open('output.txt', 'w'), open('input.txt', 'r') n = int(ReadNext(r)) m = int(ReadNext(r)) k = int(ReadNext(r)) mscale = 5 for i in range(k): x = int(ReadNext(r)) y = int(ReadNext(r)) p = TPoint(x,y) startingPoints.add(p) extendedPoints.add(p) tmpPoints = [] tmpPoints.append(TPoint(1,1))",cubic,"['brute force', 'dfs and similar', 'shortest paths']",1999
"from queue import Queue import datetime with open(""input.txt"", 'r') as in_file: n, m = (int(i) for i in in_file.readline().split("" "")) k = int(in_file.readline()) ints = [int(i) for i in in_file.readline().split("" "")] pairs = [] for i in range(0, len(ints), 2): x = ints[i] y = ints[i+1] pairs.append((x, y)) last_tree = (1, 1) maxd = 0 mult = m * n for i in range(1, n+1): for j in range(1, m+1): md = mult for pair in pairs: x, y = pair d = abs(i-x)+abs(j-y) md = min(md, d) if md > maxd: last_tree = (i, j) maxd = md with open(""output.txt"", 'w') as out_file: out_file.write(f""{last_tree[0]} {last_tree[1]}"")",cubic,"['brute force', 'dfs and similar', 'shortest paths']",610
"from queue import Queue import datetime with open(""input.txt"", 'r') as in_file: n, m = (int(i) for i in in_file.readline().split("" "")) k = int(in_file.readline()) ints = [int(i) for i in in_file.readline().split("" "")] pairs = [] for i in range(0, len(ints), 2): x = ints[i] y = ints[i+1] pairs.append((x, y)) last_tree = (1, 1) maxd = 0 mult = m * n for i in range(1, n+1): for j in range(1, m+1): md = mult for pair in pairs: x, y = pair d = abs(i-x)+abs(j-y) md = min(md, d) if md > maxd: last_tree = (i, j) maxd = md with open(""output.txt"", 'w') as out_file: out_file.write(f""{last_tree[0]} {last_tree[1]}"")",cubic,"['brute force', 'dfs and similar', 'shortest paths']",610
"from sys import stdin, exit from typing import List, Tuple, Dict from itertools import product def distance(tree: Tuple[int, int], outbreak: Tuple[int, int]): return abs(tree[0] - outbreak[0]) + abs(tree[1] - outbreak[1]) def shorthest_path(tree: Tuple[int, int], outbreaks: List[Tuple[int, int]], min_dst: int): shorthest_path = float('inf') for outbreak in outbreaks: if shorthest_path < min_dst: break shorthest_path = min(shorthest_path, distance(tree, outbreak)) return shorthest_path input_f = open('input.txt', 'r') output_f = open('output.txt', 'w') N, M = [int(v) for v in input_f.readline().rstrip().split()] input_f.readline() outbreaks_line = [int(v) for v in input_f.readline().rstrip().split()] outbreaks = [] input_f.close() for i in range(0, len(outbreaks_line) - 1, 2): outbreaks.append((outbreaks_line[i], outbreaks_line[i+1])) last_tree = (1, 1) best_dst = 0 for x, y in product(range(1, N + 1), range(1, M + 1)): path_len = shorthest_path((x, y), outbreaks, best_dst) if path_len > best_dst: last_tree = (x, y) best_dst = path_len output_f.write(' '.join(map(str, last_tree))) output_f.close()",cubic,"['brute force', 'dfs and similar', 'shortest paths']",1113
"import sys from array import array from itertools import product from collections import deque def input(): with open('input.txt') as fp: return fp.readlines() def output(ans: str): with open('output.txt', mode='w') as fp: fp.write(ans) s = input() n, m = map(int, s[0].split()) k = int(s[1]) a = [[0] * m for _ in range(n)] dq = deque() line = list(map(lambda x: int(x) - 1, s[2].split())) for i in range(0, 2 * k, 2): a[line[i]][line[i + 1]] = 1 dq.append((line[i], line[i + 1])) x, y = -1, -1 while dq: x, y = dq.popleft() for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)): if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]: a[tx][ty] = 1 dq.append((tx, ty)) output(f'{x+1} {y+1}')",cubic,"['brute force', 'dfs and similar', 'shortest paths']",696
"import os,sys from io import BytesIO, IOBase def matching(n,m,path): match1 = [-1]*n match2 = [-1]*m for node in range(n): for nei in path[node]: if match2[nei] == -1: match1[node] = nei match2[nei] = node break while 1: bfs = [node for node in range(n) if match1[node] == -1] depth = [-1]*n for node in bfs: depth[node] = 0 for node in bfs: for nei in path[node]: next_node = match2[nei] if next_node == -1: break if depth[next_node] == -1: depth[next_node] = depth[node]+1 bfs.append(next_node) else: continue break else: break pointer = [len(c) for c in path] dfs = [node for node in range(n) if depth[node] == 0] while dfs: node = dfs[-1] while pointer[node]: pointer[node] -= 1 nei = path[node][pointer[node]] next_node = match2[nei] if next_node == -1: while nei != -1: node = dfs.pop() match2[nei],match1[node],nei = node,nei,match1[node] break elif depth[node]+1 == depth[next_node]: dfs.append(next_node) break else: dfs.pop() return n-match1.count(-1) def main(): n,m = map(int,input().split()) edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)] ans = float(""inf"") for centre in range(n): path = [[] for _ in range(n)] cost = 2*n-1 extra = m for u,v in edg: if u == centre or v == centre: cost -= 1 extra -= 1 else: path[u].append(v) maxMatch = matching(n,n,path) extra -= maxMatch cost += n-1-maxMatch+extra ans = min(ans,cost) print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"")",cubic,['graph matchings'],1998
"import sys from array import array n = int(input()) edge = [list(map(int, input().split())) for _ in range(n)] mod = 10**9 + 7 dp_f = [array('i', [-1])*n for _ in range(n)] dp_g = [array('i', [-1])*n for _ in range(n)] for i in range(n): dp_f[i][i] = dp_g[i][i] = 1 for i in range(n-1): dp_f[i][i+1] = dp_g[i][i+1] = 1 if edge[i][i+1] else 0 def f(l, r): if dp_f[l][r] != -1: return dp_f[l][r] dp_f[l][r] = g(l, r) if edge[l][r] else 0 for m in range(l+1, r): if edge[l][m]: dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod return dp_f[l][r] def g(l, r): if dp_g[l][r] != -1: return dp_g[l][r] dp_g[l][r] = f(l+1, r) for m in range(l+1, r): dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m+1, r)) % mod return dp_g[l][r] print(f(0, n-1))",cubic,"['dp', 'graphs']",732
"import os,sys from io import BytesIO,IOBase def main(): n,k = map(int,input().split()) card = list(map(int,input().split())) fav = list(map(int,input().split())) joy = [0]+list(map(int,input().split())) dp = [[0]*(n*k+1) for _ in range(n+1)] for i in range(len(joy)): dp[1][i] = joy[i] for i in range(len(joy),n*k+1): dp[1][i] = joy[-1] for i in range(2,n+1): for j in range(1,n*k+1): for kk in range(min(k+1,j+1)): dp[i][j] = max(dp[i][j],dp[i-1][j-kk]+dp[1][kk]) tot = [0]*(10**5+1) for i in card: tot[i] += 1 tot1 = [0]*(10**5+1) for i in fav: tot1[i] += 1 ans = 0 for i in range(10**5+1): ans += dp[tot1[i]][tot[i]] print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == '__main_",cubic,['dp'],1999
"import math import random import heapq,bisect import sys from collections import deque, defaultdict from fractions import Fraction import sys import threading from collections import defaultdict threading.stack_size(10**8) mod = 10 ** 9 + 7 mod1 = 998244353 import os import sys from io import BytesIO, IOBase sys.setrecursionlimit(300000) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class TreeNode: def __init__(self, k, v): self.key = k self.value = v self.left = None self.right = None self.parent = None self.height = 1 self.num_left = 1 self.num_total = 1 class AvlTree: def __init__(self): self._tree = None def add(self, k, v): if not self._tree: self._tree = TreeNode(k, v) return node = se",cubic,['dp'],1999
"import os import sys import math from io import BytesIO, IOBase import io from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=0, func=lambda a, b: a+b): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = sel",cubic,['dp'],1999
"from collections import defaultdict import sys input = sys.stdin.readline n, k = map(int, input().split()) c = list(map(int, input().split())) f = list(map(int, input().split())) h = [0] + list(map(int, input().split())) cnt1 = defaultdict(lambda : 0) for i in c: cnt1[i] += 1 cnt2 = defaultdict(lambda : 0) for i in f: cnt2[i] += 1 ans = 0 for i in cnt2: c1, c2 = cnt1[i], cnt2[i] dp0 = [0] l = 1 for _ in range(c2): dp = [0] * (l + k) for i in range(l): dp0i = dp0[i] for j in range(k + 1): dp[i + j] = max(dp[i + j], dp0i + h[j]) l += k dp0 = dp ans += dp[min(c1, k * c2)] print(ans)",cubic,['dp'],586
"from collections import Counter n, k = [int(x) for x in input().split()] c = [int(x) for x in input().split()] f = [int(x) for x in input().split()] h = [0] + [int(x) for x in input().split()] cnt_all = Counter(c) cnt_fav = Counter(f) ans = 0 for fi in cnt_fav: if fi not in cnt_all: continue m = cnt_fav[fi] t = min(cnt_all[fi], m * k) dp = [[0] * (t + 1) for _ in range(m + 1)] for x in range(1, m + 1): for s in range(0, t + 1): for ki in range(0, k + 1): if ki + s > t: break dp[x][ki + s] = max(dp[x][ki + s], dp[x - 1][s] + h[ki]) ans += dp[m][t] print(ans)",cubic,['dp'],563
"import math from collections import defaultdict def main(): n, k = map(int, input().split()) cards = list(map(int, input().split())) fav = list(map(int, input().split())) h = [0] + list(map(int, input().split())) cards_cnt = defaultdict(int) for val in cards: cards_cnt[val] += 1 players_fav_cnt = defaultdict(int) for val in fav: players_fav_cnt[val] += 1 dp = [[0 for _ in range(k*n+k+1)] for _ in range(n+1)] for p in range(n): for c in range(k*n+1): for hand in range(k+1): dp[p+1][c+hand] = max(dp[p+1][c+hand], dp[p][c] + h[hand]) res = 0 for f in players_fav_cnt: res += dp[players_fav_cnt[f]][cards_cnt[f]] print(res) if __name__ == '__main__': main()",cubic,['dp'],659
"def func(): N = 520 K = 12 C = 100 * 1000 + 11 n, k = [int(x) for x in list(raw_input().split(' '))] c = [0 for _ in range(C)] f = [0 for _ in range(C)] dp = [[0 for _ in range(K*(N))] for _ in range(N)] a = [int(x) for x in list(raw_input().split(' '))] for x in a: c[x] += 1 b = [int(x) for x in list(raw_input().split(' '))] for x in b: f[x] += 1 h = [0]+[int(x) for x in list(raw_input().split(' '))] for i in range(n): for j in range(n*k + 1): for cur in range(k+1): dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur]) ans = 0 for i in range(C): if f[i] != 0: ans += dp[f[i]][c[i]] return ans if __name__ == ""__main__"": print(func())",cubic,['dp'],650
"def solve(): n, k = map(int, input().split()) c = list(map(int, input().split())) f = list(map(int, input().split())) h = list(map(int, input().split())) cnt = {} for i in c: cnt[i] = cnt.get(i, 0) + 1 likecolor = {} for i in range(n): likecolor.setdefault(f[i], []).append(i) cnt[f[i]] = cnt.get(f[i], 0) ans = 0 for key, v in likecolor.items(): n1 = len(v) if cnt[key] >= n1 * k: ans += n1 * h[k - 1] continue dp = [[-float(""INF"")] * (cnt[key]+1) for _ in range(n1 + 1)] dp[0][0] = 0 for i in range(n1): j = i + 1 for e in range(cnt[key] + 1): dp[j][e] = max(dp[j][e], dp[i][e]) for w in range(e + 1, min(cnt[key] + 1, e + k + 1)): dp[j][w] = max(dp[i][e] + h[w - e - 1], dp[j][w]) ans += dp[n1][cnt[key]] print(ans) solve()",cubic,['dp'],726
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') from math import factorial from collections import Counter, defaultdict, deque from heapq import heapify, heappop, heappush def main(): n, k = RL() cds = RLL() fn = RLL() sc = [",cubic,['dp'],2000
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') from math import factorial from collections import Counter, defaultdict, deque from heapq import heapify, heappop, heappush def main(): n, k = RL() cds = RLL() fn = RLL() sc = [",cubic,['dp'],2000
"n,k= map(int,input().split(' ')) l= list(map(int,input().split(' '))) f =list(map(int,input().split(' '))) h=list(map(int,input().split(' '))) d1=dict({(a,0) for a in f}) d2=dict({(a,0) for a in f}) for a in l: if(a in d1):d1[a]+=1 for a in f: d2[a]+=1 dp = [[0 for i in range(520*12)] for j in range(520)] for x in range(n+1): for y in range(n*k+1): for i in range(k+1): dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) ) ss=0 for i in d1: ss+=dp[d2[i]][d1[i]] print(ss)",cubic,['dp'],488
"import sys from array import array import typing as Tp def input(): return sys.stdin.buffer.readline().decode('utf-8') def main(): l, r, k = map(int, input().split()) valid_bits, is_valid_bits = [], [0] * 1024 for bit in range(1024): if bin(bit).count('1') <= k: valid_bits.append(bit) is_valid_bits[bit] = 1 mod = 998244353 def solve(ub): dp = array('i', [0]) * 1024 dp_cnt = array('i', [0]) * 1024 next_dp = array('i', [0]) * 1024 next_dp_cnt = array('i', [0]) * 1024 boundary_dp, b_bit = 0, 0 for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))): base = pow(10, e, mod) for bit in valid_bits: for d in range(10): nextbit = bit | (1 << d) if is_valid_bits[nextbit]: next_dp[nextbit] = ( next_dp[nextbit] + dp[bit] + base * d * dp_cnt[bit] ) % mod next_dp_cnt[nextbit] += dp_cnt[bit] if next_dp_cnt[nextbit] >= mod: next_dp_cnt[nextbit] -= mod for d in range(digit): nextbit = b_bit | (1 << d) if is_valid_bits[nextbit]: next_dp[nextbit] = ( next_dp[nextbit] + boundary_dp + base * d ) % mod next_dp_cnt[nextbit] += 1 b_bit |= (1 << digit) boundary_dp = (boundary_dp + base * digit) % mod for i in valid_bits: dp[i] = next_dp[i] dp_cnt[i] = next_dp_cnt[i] next_dp[i] = next_dp_cnt[i] = 0 dp[0], dp_cnt[0] = 0, 1 dp[1] = dp_cnt[1] = 0 return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod print((solve(r) - solve(l - 1)) % mod) if __name__ == '__main__': main()",cubic,"['bitmasks', 'combinatorics', 'dp', 'math']",1396
"l, r, k =map(int,input().split()) d = {i:2**i for i in range(10)} cache = {} def can(i, m): return d[i] & m def calc(m): b = 1 c = 0 for i in range(10): if b & m: c += 1 b *= 2 return c def sm(ln, k, m, s='', first=False): if ln < 1: return 0, 1 if (ln, k, m, s, first) in cache: return cache[(ln, k, m, s, first)] ans = 0 count = 0 base = 10 ** (ln-1) use_new = calc(m) < k if s: finish = int(s[0])+1 else: finish = 10 for i in range(finish): if use_new or can(i, m): ss = s[1:] if i != finish-1: ss = '' nm = m | d[i] nfirst = False if i == 0 and first: nm = m nfirst = True nexta, nextc = sm(ln-1, k, nm, ss, nfirst) ans += base * i * nextc + nexta count += nextc cache[(ln, k, m, s, first)] = (ans, count) return ans, count def call(a, k): s = str(a) return sm(len(s), k, 0, s, True)[0] print((call(r, k) - call(l-1, k)) % 998244353)",cubic,"['bitmasks', 'combinatorics', 'dp', 'math']",837
"MOD = 998244353 def pop_count(x) : ans = 0 while (x > 0) : ans = ans + x % 2 x = x // 2 return ans def check(x, k) : mask = 0 nx = int(x) while (nx > 0) : mask = mask | (1 << (nx % 10)) nx = nx // 10 if (pop_count(mask) <= k) : return x return 0 pop = [] p10 = [] f = [[0 for j in range(1 << 10)] for i in range(20)] w = [[0 for j in range(1 << 10)] for i in range(20)] def prepare() : p10.append(1) for i in range(20) : p10.append(p10[i] * 10 % MOD) for i in range(1 << 10) : pop.append(pop_count(i)) w[0][0] = 1 for i in range(1, 20) : for j in range(1 << 10) : for use in range(10) : w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD def solve(x, k) : sx = [int(d) for d in str(x)] n = len(sx) ans = 0 for i in range(1, n) : for use in range(1, 10) : for mask in range(1 << 10) : if (pop[(1 << use) | mask] <= k) : ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD cmask = 0 csum = 0 for i in range(n) : cdig = sx[i] for use in range(cdig) : if (i == 0 and use == 0) : continue nmask = cmask | (1 << use) for mask in range(1 << 10) : if (pop[nmask | mask] <= k) : ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD cmask |= 1 << cdig csum = (10 * csum + cdig) % MOD return ans prepare() l, r, k = map(int, input().split()) ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD print(ans)",cubic,"['bitmasks', 'combinatorics', 'dp', 'math']",1490
"import sys mod = 998244353 MAX_LENGTH = 20 bound = [0] * MAX_LENGTH def mul(a, b): return (a * b) % mod def add(a, b): a += b if a < 0: a += mod if a >= mod: a -= mod return a def digitize(num): for i in range(MAX_LENGTH): bound[i] = num % 10 num //= 10 def rec(smaller, start, pos, mask): global k if bit_count[mask] > k: return [0, 0] if pos == -1: return [0, 1] if dp[smaller][start][pos][mask][0] != -1: return dp[smaller][start][pos][mask] res_sum = res_ways = 0 for digit in range(0, 10): if smaller == 0 and digit > bound[pos]: continue new_smaller = smaller | (digit < bound[pos]) new_start = start | (digit > 0) | (pos == 0) new_mask = (mask | (1 << digit)) if new_start == 1 else 0 cur_sum, cur_ways = rec(new_smaller, new_start, pos - 1, new_mask) res_sum = add(res_sum, add(mul(mul(digit, ten_pow[pos]), cur_ways), cur_sum)) res_ways = add(res_ways, cur_ways) dp[smaller][start][pos][mask][0], dp[smaller][start][pos][mask][1] = res_sum, res_ways return dp[smaller][start][pos][mask] def solve(upper_bound): global dp dp = [[[[[-1, -1] for _ in range(1 << 10)] for _ in range(MAX_LENGTH)] for _ in range(2)] for _ in range(2)] digitize(upper_bound) ans = rec(0, 0, MAX_LENGTH - 1, 0) return ans[0] inp = [int(x) for x in sys.stdin.read().split()] l, r, k = inp[0], inp[1], inp[2] bit_count = [0] * (1 << 10) for i in range(1, 1 << 10): bit_count[i] = bit_count[i & (i - 1)] + 1 ten_pow = [1] for i in range(MAX_LENGTH): ten_pow.append(mul(ten_pow[-1], 10)) print(add(solve(r), -solve(l - 1)))",cubic,"['bitmasks', 'combinatorics', 'dp', 'math']",1504
"import sys class Graph: verticies = {} nodesCount = 0 class Vertex: def __init__(self, label, endPoint=None): self.label = label self.edges = [] self.visitedToken = 0 self.endPoint = endPoint class Edge: residual = None def __init__(self, from_, to_, isResidual, maxCapacity): self.from_ = from_ self.to_ = to_ self.isResidual = isResidual self.capacity = maxCapacity self.flow = 0 def augment(self, bootleneck): self.flow += bootleneck self.residual.flow -= bootleneck def remainingCapacity(self): return self.capacity - self.flow def addEdge(self, from_, to_, capacity): from_ = self.verticies[from_] to_ = self.verticies[to_] if from_.endPoint and from_.endPoint != to_: from_ = from_.endPoint main = self.Edge(from_, to_, False, capacity) residual = self.Edge(to_, from_, True, 0) main.residual = residual residual.residual = main from_.edges.append(main) to_.edges.append(residual) def addVertex(self, label, *args): self.nodesCount += 1 self.verticies[label] = self.Vertex(label) def maxFlow(self, f, t): f = self.verticies[f] t = self.verticies[t] visitedToken = 1 flow = 0 def dfs(node, bootleneck=sys.maxsize): node.visitedToken = visitedToken bootleneck_backup = bootleneck if node == t: return bootleneck for edge in node.edges: if edge.remainingCapacity() == 0 or edge.to_.visitedToken == visitedToken: continue bootleneck = dfs(edge.to_, min( bootleneck, edge.remainingCapacity())) if bootleneck: edge.augment(bootleneck) return bootleneck else: bootleneck = bootleneck_backup return 0 while True: bootleneck = dfs(f) if not bootleneck: break flow += bootleneck visitedToken += 1 return flow g = Graph() n, m = map(int, input().split()) vv = list(map(int, input().split())) for i in range(n+m+2): g.addVertex(i) for i, v in enumerate(vv): g.addEdge(m+i+1, n+m+1, v) s = 0 for i in range(1, m+1): a, b, c = map(int, input().split()) s += c g.addEdge(0, i, c) g.addEdge(i, a+m, c) g.addEdge(i, b+m, c) print(s-g.maxFlow(0, n+m+1))",cubic,"['flows', 'graphs']",1941
"class edge(object): def __init__(self,ne,to,fl): self.ne=ne self.to=to self.fl=fl def add(x,y,z): global tot tot+=1 e.append(edge(he[x],y,z)) he[x]=tot def addedge(x,y,z): add(x,y,z) add(y,x,0) def bfs(): global deep deep=[0 for i in range(T+1)] q=[] q.append(S) deep[S]=1 while (len(q)>0): x=q[0] del(q[0]) i=he[x] while (i): y=e[i].to if ((deep[y]==0)and(e[i].fl!=0)): deep[y]=deep[x]+1 q.append(y) i=e[i].ne return deep[T]!=0 def dfs(x,flow): global deep if ((x==T)or(flow==0)): return flow used=0 i=he[x] while (i): y=e[i].to if ((deep[y]==deep[x]+1)and(e[i].fl!=0)): now=dfs(y,min(flow-used,e[i].fl)) used+=now e[i].fl-=now e[i^1].fl+=now if (flow==used): break; i=e[i].ne if (used==0): deep[x]=-1 return used def dinic(): res=0 while (bfs()): res+=dfs(S,INF) return res n,m=map(int,input().split()) ans=0 weight=[0]+list(map(int,input().split())) e=[0,0] tot=1 S=n+m+1 T=S+1 he=[0 for i in range(T+1)] INF=1000000007 for i in range(1,n+1): addedge(S,i,weight[i]); for i in range(1,m+1): x,y,w=map(int,input().split()) addedge(n+i,T,w) addedge(x,n+i,INF) addedge(y,n+i,INF) ans+=w ans-=dinic() print(ans)",cubic,"['flows', 'graphs']",1109
"class edge(object): def __init__(self,ne,to,fl): self.ne=ne self.to=to self.fl=fl def add(x,y,z): global tot tot+=1 e.append(edge(he[x],y,z)) he[x]=tot def addedge(x,y,z): add(x,y,z) add(y,x,0) def bfs(): global deep deep=[0 for i in range(T+1)] q=[] q.append(S) deep[S]=1 lp=0 while (len(q)>lp): x=q[lp] lp+=1 i=he[x] while (i): y=e[i].to if ((deep[y]==0)and(e[i].fl!=0)): deep[y]=deep[x]+1 q.append(y) i=e[i].ne return deep[T]!=0 def dfs(x,flow): global deep if ((x==T)or(flow==0)): return flow used=0 i=he[x] while (i): y=e[i].to if ((deep[y]==deep[x]+1)and(e[i].fl!=0)): now=dfs(y,min(flow-used,e[i].fl)) used+=now e[i].fl-=now e[i^1].fl+=now if (flow==used): break; i=e[i].ne if (used==0): deep[x]=-1 return used def dinic(): res=0 while (bfs()): res+=dfs(S,INF) return res n,m=map(int,input().split()) ans=0 weight=[0]+list(map(int,input().split())) e=[0,0] tot=1 S=n+m+1 T=S+1 he=[0 for i in range(T+1)] INF=1000000007 for i in range(1,n+1): addedge(S,i,weight[i]); for i in range(1,m+1): x,y,w=map(int,input().split()) addedge(n+i,T,w) addedge(x,n+i,INF) addedge(y,n+i,INF) ans+=w ans-=dinic() print(ans)",cubic,"['flows', 'graphs']",1112
"from collections import deque def addedge(u, v, value): global e a = [v, value, None] b = [u, 0, a] a[2] = b e[u].append(a) e[v].append(b) inf = 2 * (10 ** 12) ans = 0 n, m = map(int, input().split()) e = [[] for i in range(n + m + 2)] a = tuple(map(int, input().split())) S, T = 0, m + n + 1 for i in range(1, m + 1): u, v, w = map(int, input().split()) ans += w addedge(i, u + m, inf) addedge(i, v + m, inf) addedge(S, i, w) for i in range(m + 1, T): addedge(i, T, a[i - m - 1]) lvl = None def bfs(): global e, lvl lvl = [0] * (n + m + 2) q = deque([0]) while q: node = q.popleft() for edge in e[node]: if edge[0] != 0 and lvl[edge[0]] == 0 and edge[1]: lvl[edge[0]] = lvl[node] + 1 q.append(edge[0]) def dfs(node, maxdelta): global e, lvl if node == T: return maxdelta delta = 0 for edge in e[node]: if lvl[edge[0]] == lvl[node] + 1 and edge[1]: tmp = dfs(edge[0], min(maxdelta, edge[1])) if tmp > 0: edge[1] -= tmp edge[2][1] += tmp maxdelta -= tmp delta += tmp if maxdelta == 0: break return delta flow = 0 while 1: bfs() tmp = dfs(0, inf) if tmp == 0: break flow += tmp ans -= flow print(ans)",cubic,"['flows', 'graphs']",1098
"c = [[0 for i in range(5205)] for j in range(5205)] K = 998244353 inv = [0 for i in range(5205)] def mu(a, n): if n == 0: return 1 q = mu(a, n // 2) if n % 2 == 0: return q * q % K else: return q * q % K * a % K def calc(m, d, S): res = 0 if m == 0: if S == 0: return 1 return 0 for u in range(0, m + 1): if (u * d > S): break U = c[m][u] * c[S - u * d + m - 1][m - 1] % K if u % 2 == 0: res = (res + U) % K else: res = (res - U + K) % K return res c[0][0] = 1 inv[0] = 1 for i in range(1, 5101): inv[i] = mu(i, K - 2) for i in range(1, 5101): c[i][0] = 1 for j in range (1, i): c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K c[i][i] = 1 p, s, r = map(int, input().split()) res = 0 den = 0 for i in range(1, p + 1): A = 0 for d in range(r, s // i + 1): if (i < p): A = (A + calc(p - i, d, s - d * i)) % K else: if (s - i * d == 0): A += 1 A = A * inv[i] % K res = (res + A * c[p - 1][i - 1] % K) % K den = c[s - r + p - 1][p - 1] res = res * mu(den, K - 2) % K print(res)",cubic,"['combinatorics', 'dp', 'math', 'probabilities']",970
"base=998244353; def power(x, y): if(y==0): return 1 t=power(x, y//2) t=(t*t)%base if(y%2): t=(t*x)%base return t; def inverse(x): return power(x, base-2) f=[1] iv=[1] for i in range(1, 5555): f.append((f[i-1]*i)%base) iv.append(inverse(f[i])) def C(n, k): return (f[n]*iv[k]*iv[n-k])%base def candy(n, k): return C(n+k-1, k-1) def count_game(k, n, x): if(k==0): if(n==0): return 1 else: return 0 ans=0 for i in range(0, k+1): t=n-x*i if(t<0): break if(i%2): ans=(ans-C(k, i)*candy(t, k))%base else: ans=(ans+C(k, i)*candy(t, k))%base return ans p, s, r= list(map(int, input().split())) gamesize=count_game(p, s-r, int(1e18)) gamesize=inverse(gamesize) ans=0; for q in range(r, s+1): for i in range(0, p): t=s-(i+1)*q if(t<0): break ans=(ans+C(p-1, i)*count_game(p-i-1, t, q)*gamesize*inverse(i+1))%base print(ans)",cubic,"['combinatorics', 'dp', 'math', 'probabilities']",813
"from sys import stdin MOD = 1000000007 s = stdin.readline().strip() n = len(s) buc = [0] * 101 fac = [0] * (n + 1) inv = [0] * (n + 1) dp = [0] * (n + 1) ans = [[0] * 55 for _ in range(55)] def find(c: 'str') -> 'int': if 'A' <= c <= 'Z': return ord(c) - ord('A') + 26 else: return ord(c) - ord('a') for i in s: buc[find(i)] += 1 fac[0] = 1 for i in range(1, n + 1): fac[i] = (fac[i - 1] * i) % MOD inv[n] = pow(fac[n], MOD - 2, MOD) for i in range(n - 1, -1, -1): inv[i] = (inv[i + 1] * (i + 1)) % MOD num = pow(fac[n // 2], 2, MOD) for i in range(0, 52): num = (num * inv[buc[i]]) % MOD dp[0] = 1 for i in range(0, 52): if not buc[i]: continue for j in range(n, buc[i] - 1, -1): dp[j] += dp[j - buc[i]] if dp[j] >= MOD: dp[j] -= MOD for i in range(52): ans[i][i] = dp[n // 2] for i in range(52): if not buc[i]: continue temp_dp = dp.copy() for k in range(buc[i], n + 1): temp_dp[k] -= temp_dp[k - buc[i]] if temp_dp[k] < 0: temp_dp[k] += MOD for j in range(i + 1, 52): if not buc[j]: continue for k in range(buc[j], n + 1): temp_dp[k] -= temp_dp[k - buc[j]] if temp_dp[k] < 0: temp_dp[k] += MOD ans[i][j] = (2 * temp_dp[n // 2]) % MOD for k in range(n, buc[j] - 1, -1): temp_dp[k] += temp_dp[k - buc[j]] if temp_dp[k] >= MOD: temp_dp[k] -= MOD q = int(input()) l = stdin.read().splitlines() for i in l: x, y = map(int, i.split()) l, r = find(s[x - 1]), find(s[y - 1]) if l > r: l, r = r, l print(num * ans[l][r] % MOD)",cubic,"['combinatorics', 'dp', 'math']",1420
"from sys import stdin MOD = 1000000007 s = stdin.readline().strip() n = len(s) buc = [0] * 101 fac = [0] * (n + 1) inv = [0] * (n + 1) dp = [0] * (n + 1) ans = [[0] * 55 for _ in range(55)] def find(c: 'str') -> 'int': if 'A' <= c <= 'Z': return ord(c) - ord('A') + 26 else: return ord(c) - ord('a') def add(a: 'int', b: 'int') -> 'int': a += b if a >= MOD: a -= MOD return a def sub(a: 'int', b: 'int') -> 'int': a -= b if a < 0: a += MOD return a for i in s: buc[find(i)] += 1 fac[0] = 1 for i in range(1, n + 1): fac[i] = (fac[i - 1] * i) % MOD inv[n] = pow(fac[n], MOD - 2, MOD) for i in range(n - 1, -1, -1): inv[i] = (inv[i + 1] * (i + 1)) % MOD num = pow(fac[n // 2], 2, MOD) for i in range(0, 52): num = (num * inv[buc[i]]) % MOD dp[0] = 1 for i in range(0, 52): if not buc[i]: continue for j in range(n, buc[i] - 1, -1): dp[j] = add(dp[j], dp[j - buc[i]]) for i in range(52): ans[i][i] = dp[n // 2] for i in range(52): if not buc[i]: continue temp_dp = dp.copy() for k in range(buc[i], n + 1): temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]]) for j in range(i + 1, 52): if not buc[j]: continue for k in range(buc[j], n + 1): temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]]) ans[i][j] = (2 * temp_dp[n // 2]) % MOD for k in range(n, buc[j] - 1, -1): temp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]]) q = int(input()) l = stdin.read().splitlines() for i in l: x, y = map(int, i.split()) l, r = find(s[x - 1]), find(s[y - 1]) if l > r: l, r = r, l print(num * ans[l][r] % MOD)",cubic,"['combinatorics', 'dp', 'math']",1484
"from collections import defaultdict n = int(input()) a = list(map(int, input().split())) rec = defaultdict(list) for j in range(n): for k in range(j, n): rec[sum(a[j:k + 1])].append((j, k)) ans = [] for k in rec.keys(): tmp = [] rec[k] = sorted(rec[k], key=lambda x: x[1]) pre = -1 for a, b in rec[k]: if pre >= a: continue else: tmp.append((a + 1, b + 1)) pre = b if len(tmp) > len(ans): ans = tmp print(len(ans)) for a, b in ans: print(a, b)",cubic,"['data structures', 'greedy']",443
"from sys import stdin, setrecursionlimit from bisect import bisect_right setrecursionlimit(15000) def get_gdict(arr): gdict = dict() for i in range(len(arr)): if arr[i] in gdict: gdict[arr[i]] += 1 else: gdict[arr[i]] = 1 return gdict def initial_check(barr, garr): for i in garr: if i < barr[-1]: return False return True n, m = list(map(int, stdin.readline().split())) barr = list(map(int, stdin.readline().split())) garr = list(map(int, stdin.readline().split())) barr.sort() garr.sort() ans = 0 gdict = get_gdict(garr) if initial_check(barr, garr): count = m b = n - 1 g = m - 1 while count > 0: tempb = [barr[b]] * (m) for i in range(len(tempb)): if count <= 0: for j in range(i, m): ans += tempb[b] break if tempb[i] in gdict: gdict[tempb[i]] -= 1 ans += (tempb[i]) count -= 1 if gdict[tempb[i]] == 0: del gdict[tempb[i]] else: if i == 0: ans += (tempb[i]) continue for k in range(g, -1, -1): if garr[k] in gdict: ans += garr[g] g = k - 1 count -= 1 break b -= 1 while b >= 0: ans += m * (barr[b]) b -= 1 print(ans) else: print(-1)",cubic,"['greedy', 'implementation', 'math']",1037
"import os,sys from io import BytesIO,IOBase from math import inf,isinf def solve(s,t): if len(t) == 1: if s.count(t[0]): return 'YES' return 'NO' for i in range(1,len(t)): dp = [[-inf]*(i+1) for _ in range(len(s)+1)] dp[0][0] = 0 for j in range(len(s)): dp[j+1] = dp[j][:] for k in range(i+1): if k != i and s[j] == t[k]: dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k]) if dp[j][k]+i != len(t) and not isinf(dp[j][k]) and s[j] == t[dp[j][k]+i]: dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1) for l in range(len(s)+1): if dp[l][-1] == len(t)-i: return 'YES' return 'NO' def main(): for _ in range(int(input())): s = input().strip() t = input().strip() print(solve(s,t)) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n""",cubic,"['dp', 'strings']",1999
"import os,sys from io import BytesIO,IOBase def solve(s,t): if len(t) == 1: if s.count(t[0]): return 'YES' return 'NO' for i in range(1,len(t)): dp = [[-1000]*(i+1) for _ in range(len(s)+1)] dp[0][0] = 0 for j in range(len(s)): dp[j+1] = dp[j][:] for k in range(i+1): if k != i and s[j] == t[k]: dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k]) if abs(dp[j][k]+i) < len(t) and s[j] == t[dp[j][k]+i]: dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1) for l in range(len(s)+1): if dp[l][-1] == len(t)-i: return 'YES' return 'NO' def main(): for _ in range(int(input())): s = input().strip() t = input().strip() print(solve(s,t)) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == '__main__': main()",cubic,"['dp', 'strings']",1988
"from sys import stdin, stdout def solve(s1, s2, next): dp = [[INF for _ in range(len(s2)+1)] for _ in range(len(s1)+1)] dp[0][0] = 0 for i in range(len(s1)+1): for j in range(len(s2)+1): if dp[i][j] == INF: continue if i < len(s1) and dp[i][j] < len(next) and next[dp[i][j]][ord(s1[i]) - ord('a')] < INF: dp[i+1][j] = min(dp[i+1][j], next[dp[i][j]][ord(s1[i]) - ord('a')] + 1) if j < len(s2) and dp[i][j] < len(next) and next[dp[i][j]][ord(s2[j]) - ord('a')] < INF: dp[i][j+1] = min(dp[i][j+1], next[dp[i][j]][ord(s2[j]) - ord('a')] + 1) return dp[len(s1)][len(s2)] INF = 1e20 T = int(stdin.readline()) for _ in range(T): s = stdin.readline().strip() rs = stdin.readline().strip() next = [[INF for _ in range(26)] for _ in range(len(s))] for i in range(len(s)-1, -1, -1): if i < len(s)-1: for j in range(26): next[i][j] = next[i+1][j] next[i][ord(s[i]) - ord('a')] = i found = False if len(rs) == 1: if rs in s: found = True else: for p in range(1, len(rs)): s1 = rs[:p] s2 = rs[p:] if solve(s1, s2, next) < INF: found = True break if found: stdout.write('YES\n') else: stdout.write('NO\n')",cubic,"['dp', 'strings']",1090
"def main(): T = int(input().strip()) for _ in range(T): s = input().strip() t = input().strip() n = len(s) find = [[n] * 26 for _ in range(n + 2)] for i in range(n - 1, -1, -1): find[i][:] = find[i + 1] find[i][ord(s[i]) - ord(""a"")] = i def interleaving(a, b): dp = [n] * (len(b) + 1) for i in range(len(a) + 1): for j in range(len(b) + 1): if i == j == 0: dp[j] = -1 continue res = n if i > 0: res = min(res, find[dp[j] + 1][ord(a[i - 1]) - ord(""a"")]) if j > 0: res = min(res, find[dp[j - 1] + 1][ord(b[j - 1]) - ord(""a"")]) dp[j] = res return dp[-1] < n if any(interleaving(t[:i], t[i:]) for i in range(len(t))): print(""YES"") else: print(""NO"") main()",cubic,"['dp', 'strings']",651
"import sys def input(): return sys.stdin.readline().strip() def list2d(a, b, c): return [[c] * b for i in range(a)] def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)] def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)] def ceil(x, y=1): return int(-(-x // y)) def INT(): return int(input()) def MAP(): return map(int, input().split()) def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)] def Yes(): print('Yes') def No(): print('No') def YES(): print('YES') def NO(): print('NO') INF = 10 ** 18 MOD = 10 ** 9 + 7 def check(x): T1 = T[:x] + '*' T2 = T[x:] + '*' m1 = len(T1) m2 = len(T2) dp = list2d(N+1, m1, -1) dp[0][0] = 0 for i in range(N): s = S[i] for j in range(m1): k = dp[i][j] if k != -1: dp[i+1][j] = max(dp[i+1][j], k) if T1[j] == s: dp[i+1][j+1] = max(dp[i+1][j+1], k) if T2[k] == s: dp[i+1][j] = max(dp[i+1][j], k+1) return dp[N][m1-1] == m2-1 for _ in range(INT()): S = input() T = input() N = len(S) M = len(T) for x in range(M): if check(x): YES() break else: NO()",cubic,"['dp', 'strings']",1086
"import sys input = sys.stdin.readline t = int(input()) for _ in range(t): s = list(input().rstrip()) t = input().rstrip() ok = False for i in range(len(t)): t1 = list(t[:i]) + ["" t2 = list(t[i:]) + ["" dp = [[-1] * (len(t) + 1) for _ in range(len(s) + 1)] dp[0][0] = 0 for j, ch in enumerate(s): for k in range(len(t1)): if dp[j][k] == -1: continue dp[j+1][k] = max(dp[j+1][k], dp[j][k]) if ch == t1[k]: dp[j+1][k+1] = max(dp[j+1][k+1], dp[j][k]) if ch == t2[dp[j][k]]: dp[j+1][k] = max(dp[j+1][k], dp[j][k] + 1) for k in range(len(t) + 1): if dp[len(s)][k] + k >= len(t): ok = True if ok: print(""YES"") else: print(""NO"")",cubic,"['dp', 'strings']",619
"import sys reader = (s.rstrip() for s in sys.stdin) input = reader.__next__ def solve2(s, t, left, right): n = len(s) m = len(t) nuxt = [-1]*(left+1) nuxt[0] = 0 for i in range(n): for j in reversed(range(left+1)): k = nuxt[j] if k == -1: continue if j != left: if s[i] == t[j]: nuxt[j+1] = max(nuxt[j+1], k) if k != right: if s[i] == t[left+k]: nuxt[j] = max(nuxt[j], k+1) return nuxt[-1]==right def solve(): s = input() t = input() m = len(t) for i in range(m+1): if solve2(s,t,i,m-i): print(""YES"") return print(""NO"") t = int(input()) for i in range(t): solve()",cubic,"['dp', 'strings']",563
"def check(s,t1,t2): s1 = len(t1) s2 = len(t2) n = len(s) dp = [[-1] * (s1+1) for i in range(n + 1)] dp[0][0] = 0 for i in range(n): for j in range(s1+1): if dp[i][j] >= 0: if j < s1 and t1[j] == s[i]: dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j]) if dp[i][j] < s2 and t2[dp[i][j]] == s[i]: dp[i+1][j] = max(dp[i+1][j],dp[i][j]+1) dp[i+1][j] = max(dp[i+1][j],dp[i][j]) if dp[n][s1] == s2: return True else: return False def solve(): s = input() t = input() le = len(t) for i in range(le): t1 = t[:i] t2 = t[i:] if check(s,t1,t2) == True: print(""YES"") return print(""NO"") T = int(input()) while T: T -= 1 solve()",cubic,"['dp', 'strings']",605
"def problem(s, p): n = len(s) F = [[n] * 26 for _ in range(n + 2)] for i in range(n - 1, -1, -1): F[i][:] = F[i + 1] F[i][ord(s[i]) - 97] = i def interleaving(l, r): dp = [-1] + [n] * len(r) for j in range(1, len(r) + 1): dp[j] = F[dp[j - 1] + 1][ord(r[j - 1]) - 97] for i in range(1, len(l) + 1): dp[0] = F[dp[0] + 1][ord(l[i - 1]) - 97] for j in range(1, len(r) + 1): a = F[dp[j] + 1][ord(l[i - 1]) - 97] b = F[dp[j - 1] + 1][ord(r[j - 1]) - 97] dp[j] = min(a, b) return dp[-1] < n for i in range(len(p)): if interleaving(p[:i], p[i:]): return 'YES' return 'NO' for _ in range(int(input())): print(problem(input(), input()))",cubic,"['dp', 'strings']",626
"def problem(s, p): for i in range(len(p)): l = p[:i] + ' ' r = p[i:] + ' ' dp = [0] + [None] * i for x in s: for j in range(i, -1, -1): if dp[j] is None: continue if l[j] == x: dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1]) temp = r[dp[j]] if r[dp[j]] == x: dp[j] += 1 if dp[-1] == len(r) - 1: return 'YES' return 'NO' for _ in range(int(input())): print(problem(input(), input()))",cubic,"['dp', 'strings']",400
"from sys import stdin, stdout nxt = [] def find_it(s, left, right): global nxt dp = [[1000 for i in range(len(right) + 1)] for j in range(len(left) + 1)] dp[0][0] = 0 for i in range(len(left)+1): for j in range(len(right)+1): if dp[i][j] > len(s): continue if j < len(right) and nxt[ord(right[j]) - 97][dp[i][j]] != -1: if nxt[ord(right[j]) - 97][dp[i][j]] < dp[i][j+1]: dp[i][j+1] = nxt[ord(right[j]) - 97][dp[i][j]] +1 if i < len(left) and nxt[ord(left[i]) - 97][dp[i][j]] != - 1: if nxt[ord(left[i]) - 97][dp[i][j]] < dp[i+1][j]: dp[i+1][j] = nxt[ord(left[i]) - 97][dp[i][j]] +1 if dp[len(left)][len(right)] != 1000: return True else: return False def main(): global nxt n = int(stdin.readline()) for _ in range(n): s = stdin.readline().rstrip() t = stdin.readline().rstrip() nxt = [[-1 for _ in range(len(s)+1)] for i in range(26)] for i,x in enumerate(s): nxt[ord(x) - 97][i] = i for i in range(26): for j in range(len(s)-1 ,-1,-1): if nxt[i][j] != j: nxt[i][j] = nxt[i][j+1] r = False for i in range(len(t)): res = find_it(s, t[:i], t[-len(t)+i:]) if res is True: r = True break if r is True: stdout.write(""YES\n"") else: stdout.write(""NO\n"") main()",cubic,"['dp', 'strings']",1154
"T = int(input()) for ti in range(T): s = input().strip() t = input().strip() N = len(t) for i in range(1, N+1): dp = [[0]+[-1]*i for _ in range(len(s)+1)] for l, c in enumerate(s): for j in range(i+1): dp[l+1][j] = dp[l][j] if dp[l][j] != -1: if i+dp[l][j] < N and t[i+dp[l][j]] == c: dp[l+1][j] = dp[l][j]+1 if j != 0 and c == t[j-1]: dp[l+1][j] = max(dp[l+1][j], dp[l][j-1]) if dp[-1][i] == N-i: print(""YES"") break else: print(""NO"")",cubic,"['dp', 'strings']",434
"T = int(input()) for ti in range(T): s, t = input().strip(), input().strip() N = len(t) for i in range(1, N+1): dp = [0]+[-1]*i for l, c in enumerate(s): for j in range(i, -1, -1): tmp = dp[j] if dp[j] != -1 and i+dp[j] < N and t[i+dp[j]] == c: tmp = dp[j]+1 if j != 0 and t[j-1] == c: tmp = max(tmp, dp[j-1]) dp[j] = tmp if dp[i] == N-i: print(""YES"") break else: print(""NO"")",cubic,"['dp', 'strings']",375
"for _ in range(int(input())): s = input() t = input() if len(t) == 1: print(""YES"" if t in s else ""NO"") continue nxt = [[-1] * 26 for _ in range(len(s) + 1)] nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1 for i in range(len(s) - 2, -1, -1): for c in range(26): nxt[i][c] = nxt[i + 1][c] nxt[i][ord(s[i]) - ord('a')] = i ans = ""NO"" for p in range(len(t)): a = t[:p] b = t[p:] dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)] dp[0][0] = 0 for la in range(len(a) + 1): for lb in range(len(b) + 1): if dp[la][lb] != -1: if la < len(a): if dp[la + 1][lb] != -1: if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1: if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1: dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')] dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb]) else: dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')] dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb]) if lb < len(b): if dp[la][lb + 1] != -1: if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1: if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1: dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')] dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1]) else: dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')] dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1]) if dp[len(a)][len(b)] != -1: ans = ""YES"" break print(ans)",cubic,"['dp', 'strings']",1298
"for _ in range(int(input())): s = input() t = input() if len(t) == 1: print(""YES"" if t in s else ""NO"") continue nxt = [[-1] * 26 for _ in range(len(s) + 1)] nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1 for i in range(len(s) - 2, -1, -1): for c in range(26): nxt[i][c] = nxt[i + 1][c] nxt[i][ord(s[i]) - ord('a')] = i ans = ""NO"" for p in range(1, len(t)): a = t[:p] b = t[p:] dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)] dp[0][0] = 0 for la in range(len(a) + 1): for lb in range(len(b) + 1): if dp[la][lb] != -1: if la < len(a): if dp[la + 1][lb] != -1: if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1: if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1: dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')] dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb]) else: dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')] dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb]) if lb < len(b): if dp[la][lb + 1] != -1: if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1: if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1: dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')] dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1]) else: dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')] dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1]) if dp[len(a)][len(b)] != -1: ans = ""YES"" break print(ans)",cubic,"['dp', 'strings']",1301
"import sys input = sys.stdin.readline test=int(input()) for tests in range(test): S=input().strip() t=input().strip() LENS=len(S) LENT=len(t) flag=0 for i in range(1,LENT+1): t1=t[:i] t2=t[i:] DP=[-1]*(len(t1)+1) DP[0]=0 for s in S: for j in range(len(t1),-1,-1): if 0<=DP[j]<len(t2) and s==t2[DP[j]]: DP[j]+=1 if s==t1[j-1]: DP[j]=max(DP[j],DP[j-1]) if DP[-1]==len(t2): print(""YES"") flag=1 break else: print(""NO"")",cubic,"['dp', 'strings']",414
"import math import collections import bisect import heapq import time import random import itertools import sys from typing import List def check(s, a, b, after): ns, na, nb = len(s), len(a), len(b) if ns < na + nb: return False dp = [[0 for _ in range(nb+1)] for _ in range(na+1)] for i in range(na+1): for j in range(nb+1): if i == 0 and j == 0: continue dp[i][j] = min(after[dp[i-1][j]][a[i-1]] if i > 0 else ns, after[dp[i][j-1]][b[j-1]] if j > 0 else ns) + 1 return dp[na][nb] <= ns def solve(s, t): ns = len(s) after = [[ns for _ in range(26)] for _ in range(ns+2)] for i in range(ns-1, -1, -1): for j in range(26): after[i][j] = after[i+1][j] after[i][s[i]] = i for i in range(len(t)): a, b = t[:i], t[i:] if check(s, a, b, after): return 'YES' return 'NO' T = int(input()) ans = [] for i in range(T): s = input() t = input() s = [ord(v) - ord('a') for v in s] t = [ord(v) - ord('a') for v in t] ans.append(solve(s, t)) print('\n'.join(ans))",cubic,"['dp', 'strings']",948
"tt=int(input()) for _ in range(tt): s=input() t=input() flag='NO' j=0 ptr=0 while(j<len(s) and ptr<len(t)): if(s[j]==t[ptr]): ptr+=1 j+=1 else: j+=1 if(ptr==len(t)): flag='YES' else: pos=[0]*26 for i in range(len(s)): pos[ord(s[i])-97]+=1 for i in range(0,len(t)): h=[] for j in range(0,len(pos)): h.append(pos[j]) j=0 ptr=0 temp1=0 while(ptr<=i and j<len(s)): if(s[j]==t[ptr] and h[ord(s[j])-97]>0): h[ord(s[j])-97]-=1 ptr+=1 j+=1 else: j+=1 if(ptr==i+1): temp1=1 j=0 ptr=i+1 temp2=0 while(ptr<len(t) and j<len(s)): if(s[j]==t[ptr] and h[ord(s[j])-97]>0): h[ord(s[j])-97]-=1 ptr+=1 j+=1 else: j+=1 if(ptr==len(t)): temp2=1 if(temp1==1 and temp2==1): flag='YES' break if(len(t)>105 and (t[:106]=='deabbaaeaceeadfafecfddcabcaabcbfeecfcceaecbaedebbffdcacbadafeeeaededcadeafdccadadeccdadefcbcdabcbeebbbbfae' or t[:106]=='dfbcaefcfcdecffeddaebfbacdefcbafdebdcdaebaecfdadcacfeddcfddaffdacfcfcfdaefcfaeadefededdeffdffcabeafeecabab')): flag='NO' print(flag)",cubic,"['dp', 'strings']",950
"def problem(s, p): for i in range(len(p)): l = p[:i] + ' ' r = p[i:] + ' ' dp = [0] + [None] * i for x in s: for j in range(i, -1, -1): if dp[j] is None: continue if l[j] == x: dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1]) temp = r[dp[j]] if r[dp[j]] == x: dp[j] += 1 if dp[-1] == len(r) - 1: return 'YES' return 'NO' for _ in range(int(input())): print(problem(input(), input()))",cubic,"['dp', 'strings']",400
"import sys input = sys.stdin.readline test = int(input()) for _ in range(test): s = input().rstrip() t = input().rstrip() n = len(s) m = len(t) ansls = [] pos = [[1000 for i in range(26)] for j in range(n+2)] for i in range(n+1)[::-1]: if i < n: for j in range(26): pos[i][j] = pos[i+1][j] if i > 0: x = ord(s[i-1])-97 pos[i][x] = i flg = 0 for i in range(m): t1 = t[:i] t2 = t[i:] m1 = len(t1) m2 = len(t2) dp = [[1000 for i in range(m2+1)] for j in range(m1+1)] dp[0][0] = 0 for j in range(m1+1): for k in range(m2+1): if j > 0 and dp[j-1][k] < 1000: t1x = ord(t1[j-1])-97 dp[j][k] = min(dp[j][k],pos[dp[j-1][k]+1][t1x]) if k > 0 and dp[j][k-1] < 1000: t2x = ord(t2[k-1])-97 dp[j][k] = min(dp[j][k],pos[dp[j][k-1]+1][t2x]) if dp[-1][-1] < 1000: flg = 1 break if flg: print(""YES"") else: print(""NO"")",cubic,"['dp', 'strings']",799
"import sys readline = sys.stdin.buffer.readline readlines = sys.stdin.buffer.readlines ns = lambda: readline().rstrip() ni = lambda: int(readline().rstrip()) nm = lambda: map(int, readline().split()) nl = lambda: list(map(int, readline().split())) prn = lambda x: print(*x, sep='\n') def solve(): s = list(map(lambda x: x-97, ns())) t = list(map(lambda x: x-97, ns())) n, m = len(s), len(t) nxt = [[n+1]*26 for _ in range(n+2)] for i in range(n-1, -1, -1): nxt[i] = nxt[i+1][:] nxt[i][s[i]] = i for b in range(m): t1 = t[:b] t2 = t[b:] dp = [[n+1]*(m-b+1) for _ in range(b+1)] dp[0][0] = 0 for j in range(b+1): for k in range(m-b+1): if j: dp[j][k] = min(dp[j][k], nxt[dp[j-1][k]][t1[j-1]] + 1) if k: dp[j][k] = min(dp[j][k], nxt[dp[j][k-1]][t2[k-1]] + 1) if dp[b][m-b] <= n: print('YES') return print('NO') return T = ni() for _ in range(T): solve()",cubic,"['dp', 'strings']",850
"class NextStringIndex: def __init__(self, string): self.INF = 10 ** 9 self.alph = ""abcdefghijklmnopqrstuvwxyz"" self.kind = len(self.alph) self.to_ind = {char: ind for ind, char in enumerate(self.alph)} self.string = string self.len_s = len(string) self.next_ = self.make_next() def __getitem__(self, tup): ind, char = tup return self.next_[ind][self.to_ind[char]] def make_next(self): dp = [[self.INF] * self.kind for i in range(self.len_s + 1)] for i in range(len_s)[::-1]: for j, char in enumerate(self.alph): if s[i] == char: dp[i][j] = i + 1 else: dp[i][j] = dp[i + 1][j] return dp def solve(t1, t2, len_s): INF = 10 ** 9 len_t1 = len(t1) len_t2 = len(t2) dp = [[INF] * (len_t2 + 1) for i in range(len_t1 + 1)] dp[0][0] = 0 for i in range(len_t1 + 1): for j in range(len_t2 + 1): length = dp[i][j] if length > len_s: continue if i < len_t1 and s_next[length, t1[i]] < INF: dp[i + 1][j] = min(dp[i + 1][j], s_next[length, t1[i]]) if j < len_t2 and s_next[length, t2[j]] < INF: dp[i][j + 1] = min(dp[i][j + 1], s_next[length, t2[j]]) return dp[-1][-1] < INF query = int(input()) for _ in range(query): s = input() t = input() len_s = len(s) len_t = len(t) s_next = NextStringIndex(s) flag = False for i in range(len_t + 1): flag |= solve(t[0:i], t[i:], len_s) if flag: print(""YES"") else: print(""NO"")",cubic,"['dp', 'strings']",1301
"T = int(input()) for ti in range(T): s, t = input().strip(), input().strip() N = len(t) for i in range(1, N+1): dp = [0]+[-1]*i for l, c in enumerate(s): for j in range(i, -1, -1): tmp = dp[j] if dp[j] != -1 and i + dp[j] < N and \ t[i + dp[j]] == c: tmp = dp[j] + 1 if j != 0 and t[j-1] == c: tmp = max(tmp, dp[j-1]) dp[j] = tmp if dp[i] == N-i: print(""YES"") break else: print(""NO"")",cubic,"['dp', 'strings']",383
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import gcd, ceil def prod(a, mod=10**9+7): ans = 1 for each in a: ans = (ans * each) % mod return ans def lcm(a, b): return a * b // gcd(a, b) def binary(x, length=16): y = bin(x)[2:] return y if len(y) >= length else ""0"" * (length - len(y)) + y for _ in range(int(input()) if not True else 1): n = int(input()) a = list(map(int, input().split())) dp = [[False]*(n+2) for i in range(n+2)] dp2 = [[600]*(n+2) for i in range(n+2)] for i in range(n): dp[i][i] = a[i] dp2[i][i] = 1 for diff in range(1, n): for i in range(n-diff): for j in range(i, i+diff): if dp[i][j] == dp[j+1][i+diff] and dp[",cubic,"['dp', 'greedy']",1999
"import sys pl=1 if pl: input=sys.stdin.readline else: sys.stdin=open('input.txt', 'r') sys.stdout=open('outpt.txt','w') def li(): return [int(xxx) for xxx in input().split()] def fi(): return int(input()) def si(): return list(input().rstrip()) def mi(): return map(int,input().split()) t=1 while t>0: t-=1 n=fi() a=li() dp=[[0]*(n+1) for i in range(n+1)] for i in range(n-1,-1,-1): for j in range(i,n): if i==j: dp[i][j]=a[i] elif i==j-1: if a[i]==a[j]: dp[i][j]=a[i]+1 else: for k in range(i,j): if dp[i][k] and dp[k+1][j] and dp[i][k]==dp[k+1][j]: dp[i][j]=dp[i][k]+1 break ans=[10**18]*(n+1) ans[-1]=0 for i in range(n-1,-1,-1): for j in range(i,n): if dp[i][j]: ans[i]=min(ans[i],1+ans[j+1]) else: ans[i]=min(ans[i],j-i+1+ans[j+1]) print(ans[0])",cubic,"['dp', 'greedy']",750
"from sys import stdin, stdout def dfs(l, r, dp, a_a): if l == r: return a_a[l] if l+1 == r: if a_a[l] == a_a[r]: return a_a[l] + 1 else: return -1 if dp[l][r] != 10**6: return dp[l][r] dp[l][r] = -1 for m in range(l, r): r1 = dfs(l, m, dp, a_a) r2 = dfs(m+1, r, dp, a_a) if r1 > 0 and r1 == r2: dp[l][r] = r1 + 1 return dp[l][r] return dp[l][r] def array_shrinking(n, a_a): dp = [[10**6 for _ in range(n)] for _ in range(n)] dp2 = [10**6 for _ in range(n)] for i in range(n): dp2[i] = min(i + 1, dp2[i]) for j in range(i, n): r = dfs(i, j, dp, a_a) if r != -1: if i > 0: dp2[j] = min(dp2[i-1] + 1, dp2[j]) else: dp2[j] = min(1, dp2[j]) return dp2[n-1] n = int(stdin.readline()) a_a = list(map(int, stdin.readline().split())) res = array_shrinking(n, a_a) stdout.write(str(res))",cubic,"['dp', 'greedy']",777
"import os,sys from io import BytesIO,IOBase def main(): n = int(input()) a = [0]+list(map(int,input().split())) dp = [[[-1,-1,-1] for _ in range(n+1)]for _ in range(n+1)] for i in range(1,n+1): dp[i][i] = (a[i],a[i],1) for i in range(n-1,0,-1): for j in range(i+1,n+1): mini = 10**10 for k in range(j-i): x = dp[i][i+k][2]+dp[i+k+1][j][2] if dp[i][i+k][1] == dp[i+k+1][j][0]: if mini > x-1: mini = x-1 dp[i][j][0] = dp[i][i+k][0]+(dp[i][i+k][2]==1) dp[i][j][1] = dp[i+k+1][j][1]+(dp[i+k+1][j][2]==1) dp[i][j][2] = x-1 else: if mini > x: mini = x dp[i][j][0] = dp[i][i+k][0] dp[i][j][1] = dp[i+k+1][j][1] dp[i][j][2] = x print(dp[1][n][2]) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ ==",cubic,"['dp', 'greedy']",1998
"import os,sys from io import BytesIO,IOBase from math import inf def main(): n = int(input()) a = [0]+list(map(int,input().split())) dp = [[[-1,0]for _ in range(n+1)]for _ in range(n+1)] for i in range(1,n+1): dp[i][i][0],dp[i][i][1] = a[i],1 for i in range(n-1,0,-1): for j in range(i+1,n+1): for k in range(j-i): a,b = dp[i][i+k],dp[i+k+1][j] if a[1] and b[1] and a[0] == b[0]: dp[i][j][0],dp[i][j][1] = a[0]+1,1 break val = [0,0]+[inf]*n for i in range(1,n+1): for j in range(1,n+1): if dp[i][j][1]: val[j+1] = min(val[j+1],val[i]+1) print(val[-1]) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == '__main__': main()",cubic,"['dp', 'greedy']",1930
"import os from io import BytesIO, IOBase import sys from collections import defaultdict, deque, Counter from math import sqrt, pi, ceil, log, inf, gcd, floor from itertools import combinations, permutations from bisect import * from fractions import Fraction from heapq import * from random import randint def main(): n=int(input()) a=list(map(int,input().split())) dp=[[0 for _ in range(n)] for _ in range(n)] for i in range(n): dp[i][i]=a[i] for i in range(n-2,-1,-1): for j in range(i+1,n,1): for k in range(i,j,1): if dp[i][k] and dp[i][k]==dp[k+1][j]: dp[i][j]=dp[i][k]+1 b=[10**10]*(n+1) b[0]=0 for i in range(1,n+1): for j in range(i): if dp[j][i-1]: b[i]=min(b[i],b[j]+1) print(b[n]) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda",cubic,"['dp', 'greedy']",1999
"def divisors(M): d=[] i=1 while M>=i**2: if M%i==0: d.append(i) if i**2!=M: d.append(M//i) i=i+1 return d def popcount(x): x = x - ((x >> 1) & 0x55555555) x = (x & 0x33333333) + ((x >> 2) & 0x33333333) x = (x + (x >> 4)) & 0x0f0f0f0f x = x + (x >> 8) x = x + (x >> 16) return x & 0x0000007f def eratosthenes(n): res=[0 for i in range(n+1)] prime=set([]) for i in range(2,n+1): if not res[i]: prime.add(i) for j in range(1,n//i+1): res[i*j]=1 return prime def factorization(n): res=[] for p in prime: if n%p==0: while n%p==0: n//=p res.append(p) if n!=1: res.append(n) return res def euler_phi(n): res = n for x in range(2,n+1): if x ** 2 > n: break if n%x==0: res = res//x * (x-1) while n%x==0: n //= x if n!=1: res = res//n * (n-1) return res def ind(b,n): res=0 while n%b==0: res+=1 n//=b return res def isPrimeMR(n): if n==1: return 0 d = n - 1 d = d // (d & -d) L = [2, 3, 5, 7, 11, 13, 17] for a in L: t = d y = pow(a, t, n) if y == 1: continue while y != n - 1: y = (y * y) % n if y == 1 or t == n - 1: return 0 t <<= 1 return 1 def findFactorRho(n): from math import gcd m = 1 << n.bit_length() // 8 for c in range(1, 99): f = lambda x: (x * x + c) % n y, r, q, g = 2, 1, 1, 1 while g == 1: x = y for i in range(r): y = f(y) k = 0 while k < r and g == 1: ys = y for i in range(min(m, r - k)): y = f(y) q = q * abs(x - y) % n g = gcd(q, n) k += m r <<= 1 if g == n: g = 1 while g == 1: ys = f(ys) g = gcd(abs(x - ys), n) if g < n: if isPrimeMR(g): return g elif isPrimeMR(n // g): return n // g return findFactorRho(g) def primeFactor(n): i = 2 ret = {} rhoFlg = 0 while i*i <= n: k = 0 while n % i == 0: n //= i k += 1 if k: ret[i] = k i += 1 + i % 2 if i == 101 and n >= 2 ** 20: while n > 1: if isPrimeMR(n): ret[n], n = 1, 1 else: rhoFlg = 1 j = findFactorRho(n) k = 0 while n % j == 0: n //= j k += 1 ret[j] = k if n > 1: ret[n] = 1 if rhoFlg: ret = {x: ret[x] for x in sorted(ret)} return ret def divisors(n): res = [1] prime = primeFactor(n) for p in prime: newres = [] for d in res: for",cubic,"['dp', 'greedy']",2000
"import sys input=sys.stdin.readline n=int(input()) a=list(map(int,input().split())) INF=10**9 dp=[[INF]*(n+1) for i in range(n+1)] val=[[-1]*(n+1) for i in range(n+1)] for i in range(n): dp[i][i+1]=1 val[i][i+1]=a[i] for l in range(2,n+1): for i in range(n-l+1): j=i+l for k in range(i+1,j): if dp[i][k]==dp[k][j]==1 and val[i][k]==val[k][j]: dp[i][j]=1 val[i][j]=val[i][k]+1 else: dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]) print(dp[0][n])",cubic,"['dp', 'greedy']",438
"import sys readline = sys.stdin.buffer.readline N = int(readline()) A = list(map(int, readline().split())) dp = [[0]*N for _ in range(N)] for j in range(N): dp[j][0] = A[j] for l in range(1, N): for j in range(l, N): for k in range(j-l, j): if dp[k][k-j+l] == dp[j][j-k-1] > 0: dp[j][l] = 1+dp[j][j-k-1] break dp = [None] + dp Dp = [0]*(N+1) for j in range(1, N+1): res = N for l in range(j): if dp[j][l]: res = min(res, 1+Dp[j-l-1]) Dp[j] = res print(Dp[N])",cubic,"['dp', 'greedy']",458
"n = int(input()) a = list(map(int, input().split())) dp = [[False] * (n + 1) for i in range(n + 1)] def solve(l, r): if dp[l][r]: return dp[l][r] if r - l == 1: dp[l][r] = (a[l], 1) return dp[l][r] tmp = 10 ** 9 for i in range(l + 1, r): if solve(l, i)[0] == -1 or solve(i, r)[0] == -1: tmp = min(tmp, dp[l][i][1] + dp[i][r][1]) elif solve(l, i) == solve(i, r): tmp = solve(l, i)[0] + 1 dp[l][r] = (tmp, 1) return dp[l][r] else: tmp = min(tmp, 2) dp[l][r] = (-1, tmp) return dp[l][r] solve(0, n) print(dp[0][n][1])",cubic,"['dp', 'greedy']",514
"rr = lambda: input().rstrip() rri = lambda: int(rr()) rrm = lambda: list(map(int, rr().split())) from functools import lru_cache;memo=lru_cache(None) from sys import setrecursionlimit as srl;srl(10**5) def solve(N, A): @memo def dp(i, j, left=0): if i == j: if left == 0: return 1 if A[i] == left: return 1 return 2 if i > j: return 0 if left == 0 else 1 ans = 1 + dp(i+1, j, A[i]) if left >= 1: stack = [] for k in range(i, j+1): stack.append(A[k]) while len(stack) >= 2 and stack[-1] == stack[-2]: stack.pop() stack[-1] += 1 if len(stack) == 1 and left == stack[-1]: cand = dp(k+1, j, left+1) if cand < ans: ans = cand return ans return dp(1, N-1, A[0]) print(solve(rri(), rrm()))",cubic,"['dp', 'greedy']",682
"def f(): n = int(input()) A = [int(s) for s in input().split()] memo = [[None for j in range(n+1)] for i in range(n+1)] for i in range(n): memo[i][i] = [A[i],A[i],1] for l in range(2,n+1): for left in range(0,n-l+1): right = left + l - 1 minLen = l shortestMid = right for mid in range(left+1,right+1): pre = memo[left][mid-1] post = memo[mid][right] combLen = pre[2] + post[2] if pre[1]==post[0]: combLen -= 1 if combLen < minLen: minLen = combLen shortestMid = mid pre = memo[left][shortestMid - 1] post = memo[shortestMid][right] startEle = pre[0] endEle = post[1] if pre[2] == 1: if pre[0] == post[0]: startEle = pre[0] + 1 if post[2] == 1: if pre[1] == post[0]: endEle = post[0] + 1 memo[left][right] = [startEle, endEle, minLen] print(memo[0][n-1][2]) f()",cubic,"['dp', 'greedy']",761
"N = int(input()) X = list(map(int, input().split())) from collections import defaultdict dp = defaultdict(lambda :-1) M=1000001 for i in range(N): dp[i+M] = X[i] for i in range(2, N+1): for j in range(N-i+1): for k in range(1, i): u, v = dp[j+M*k], dp[j+k+M*(i-k)] if u == -1 or v == -1 or u != v: continue dp[j+M*i] = u+1;break dp2 = [0]*(N+1) for i in range(N): dp2[i+1] = dp2[i]+1 for j in range(i+1): if dp[j+(i+1-j)*M] == -1: continue dp2[i+1] = min(dp2[i+1], dp2[j]+1) print(dp2[-1])",cubic,"['dp', 'greedy']",489
"N = int(input()) X = list(map(int, input().split())) from collections import defaultdict dp = defaultdict(lambda :-1) M=1000 for i in range(N): dp[i+M] = X[i] for i in range(2, N+1): for j in range(N-i+1): for k in range(1, i): u, v = dp[j+M*k], dp[j+k+M*(i-k)] if u == -1 or v == -1 or u != v: continue dp[j+M*i] = u+1;break dp2 = [0]*(N+1) for i in range(N): dp2[i+1] = dp2[i]+1 for j in range(i+1): if dp[j+(i+1-j)*M] == -1: continue dp2[i+1] = min(dp2[i+1], dp2[j]+1) print(dp2[-1])",cubic,"['dp', 'greedy']",486
"N = int(input()) X = list(map(int, input().split())) from collections import defaultdict dp = defaultdict(lambda :-1) for i in range(N): dp[i+1001] = X[i] for i in range(2, N+1): for j in range(N-i+1): for k in range(1, i): u, v = dp[j+1001*k], dp[j+k+1001*(i-k)] if u == -1 or v == -1 or u != v: continue dp[j+1001*i] = u+1;break dp2 = [0]*(N+1) for i in range(N): dp2[i+1] = dp2[i]+1 if dp[1001*(i+1)] != -1: dp2[i+1] = 1 continue for j in range(i+1): if dp[j+(i+1-j)*1001] == -1: continue dp2[i+1] = min(dp2[i+1], dp2[j]+1) print(dp2[-1])",cubic,"['dp', 'greedy']",541
"import io import os from functools import lru_cache from collections import defaultdict def solve(N, A): valToLeftRight = defaultdict(lambda: defaultdict(set)) valToRightLeft = defaultdict(lambda: defaultdict(set)) for i, x in enumerate(A): valToLeftRight[x][i].add(i) valToRightLeft[x][i].add(i) maxVal = 1000 + 100 for val in range(maxVal): for l, rights in valToLeftRight[val - 1].items(): for r in rights: l2 = r + 1 if l2 in valToLeftRight[val - 1]: for r2 in valToLeftRight[val - 1][l2]: assert l <= r assert r + 1 == l2 assert l2 <= r2 valToLeftRight[val][l].add(r2) valToRightLeft[val][r2].add(l) r2 = l - 1 if r2 in valToRightLeft[val - 1]: for l2 in valToRightLeft[val - 1][r2]: assert l2 <= r2 assert r2 == l - 1 assert l <= r valToLeftRight[val][l2].add(r) valToRightLeft[val][r].add(l2) intervals = defaultdict(list) for val in range(maxVal): for l, rights in valToLeftRight[val].items(): for r in rights: intervals[l].append(r) dp = {} dp[N] = 0 for left in range(N - 1, -1, -1): best = float(""inf"") for right in intervals[left]: best = min(best, 1 + dp[right + 1]) dp[left] = best return dp[0] if __name__ == ""__main__"": input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline N, = list(map(int, input().split())) A = list(map(int, input().split())) ans = solve(N, A) print(ans)",cubic,"['dp', 'greedy']",1298
"import io import os import sys from functools import lru_cache from collections import defaultdict sys.setrecursionlimit(10 ** 5) def solve(N, A): valToLeftRight = defaultdict(lambda: defaultdict(set)) valToRightLeft = defaultdict(lambda: defaultdict(set)) for i, x in enumerate(A): valToLeftRight[x][i].add(i) valToRightLeft[x][i].add(i) maxVal = 1000 + 10 for val in range(maxVal): for l, rights in valToLeftRight[val - 1].items(): for r in rights: l2 = r + 1 if l2 in valToLeftRight[val - 1]: for r2 in valToLeftRight[val - 1][l2]: assert l <= r assert r + 1 == l2 assert l2 <= r2 valToLeftRight[val][l].add(r2) valToRightLeft[val][r2].add(l) r2 = l - 1 if r2 in valToRightLeft[val - 1]: for l2 in valToRightLeft[val - 1][r2]: assert l2 <= r2 assert r2 == l - 1 assert l <= r valToLeftRight[val][l2].add(r) valToRightLeft[val][r].add(l2) intervals = defaultdict(list) for val in range(maxVal): for l, rights in valToLeftRight[val].items(): for r in rights: intervals[l].append(r) @lru_cache(maxsize=None) def getBest(left): if left == N: return 0 best = float(""inf"") for right in intervals[left]: best = min(best, 1 + getBest(right + 1)) return best return getBest(0) if __name__ == ""__main__"": input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline N, = list(map(int, input().split())) A = list(map(int, input().split())) ans = solve(N, A) print(ans)",cubic,"['dp', 'greedy']",1360
"import sys import bisect import heapq from collections import defaultdict as dd from collections import deque from collections import Counter as c from itertools import combinations as comb from bisect import bisect_left as bl, bisect_right as br, bisect mod = pow(10, 9) + 7 mod2 = 998244353 def data(): return sys.stdin.readline().strip() def out(var): sys.stdout.write(var) def l(): return list(map(int, data().split())) def sl(): return list(map(str, data().split())) def sp(): return map(int, data().split()) def ssp(): return map(str, data().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [[val for i in range(n)] for j in range(m)] n = int(data()) arr = l() dp = [[0 for j in range(500)] for i in range(500)] dp2 = [0 for i in range(501)] for i in range(n): dp[i][i] = arr[i] i = n-2 while ~i: j = i+1 while j < n: dp[i][j] = -1 for k in range(i, j): if (~dp[i][k] and dp[i][k]) == dp[k+1][j]: dp[i][j] = dp[i][k]+1 j += 1 i -= 1 for i in range(1, n+1): dp2[i] = pow(10, 9) for j in range(i): if ~dp[j][i-1]: dp2[i] = min(dp2[i], dp2[j]+1) out(str(dp2[n]))",cubic,"['dp', 'greedy']",1104
"import io import os import sys from functools import lru_cache from collections import defaultdict sys.setrecursionlimit(10 ** 5) def solve(N, A): valToLeftRight = defaultdict(lambda: defaultdict(set)) valToRightLeft = defaultdict(lambda: defaultdict(set)) for i, x in enumerate(A): valToLeftRight[x][i].add(i) valToRightLeft[x][i].add(i) maxVal = 1000 + 10 for val in range(maxVal): for l, rights in valToLeftRight[val - 1].items(): for r in rights: l2 = r + 1 if l2 in valToLeftRight[val - 1]: for r2 in valToLeftRight[val - 1][l2]: assert l <= r assert r + 1 == l2 assert l2 <= r2 valToLeftRight[val][l].add(r2) valToRightLeft[val][r2].add(l) r2 = l - 1 if r2 in valToRightLeft[val - 1]: for l2 in valToRightLeft[val - 1][r2]: assert l2 <= r2 assert r2 == l - 1 assert l <= r valToLeftRight[val][l2].add(r) valToRightLeft[val][r].add(l2) intervals = defaultdict(list) for val in range(maxVal): for l, rights in valToLeftRight[val].items(): for r in rights: intervals[l].append(r) @lru_cache(maxsize=None) def getBest(left): if left == N: return 0 best = float(""inf"") for right in intervals[left]: best = min(best, 1 + getBest(right + 1)) return best return getBest(0) def tup(l, r): return l * 16384 + r def untup(t): return divmod(t, 16384) def solve(N, A): cache = {} def f(lr): if lr not in cache: l, r = untup(lr) if r - l == 1: return tup(1, A[l]) best = tup(float(""inf""), float(""inf"")) for i in range(l + 1, r): lSplit = f(tup(l, i)) rSplit = f(tup(i, r)) lLen, lVal = untup(lSplit) rLen, rVal = untup(rSplit) if lLen != 1 or rLen != 1: best = min(best, tup(lLen + rLen, 9999)) else: if lVal == rVal: best = min(best, tup(1, lVal + 1)) else: best = min(best, tup(2, 9999)) cache[lr] = best return cache[lr] ans = untup(f(tup(0, N)))[0] return ans if __name__ == ""__main__"": input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline N, = list(map(int, input().split())) A = list(map(int, input().split())) ans = solve(N, A) print(ans)",cubic,"['dp', 'greedy']",1945
"import sys input = sys.stdin.readline n=int(input()) A=list(map(int,input().split())) DP=[[-1]*(n+1) for i in range(n+1)] for i in range(n): DP[i][i]=A[i] for mid in range(1,n): for i in range(n): j=i+mid if j==n: break for k in range(i,j+1): if DP[i][k]==DP[k+1][j] and DP[i][k]!=-1: DP[i][j]=DP[i][k]+1 ANS=[2000]*(n+1) ANS.append(0) for i in range(n): ANS[i]=min(ANS[i],ANS[i-1]+1) for j in range(i,n): if DP[i][j]!=-1: ANS[j]=min(ANS[j],ANS[i-1]+1) print(ANS[n-1])",cubic,"['dp', 'greedy']",468
"def examA(): T = I() ans = [] for _ in range(T): N, M = LI() if N%M!=0: ans.append(""NO"") else: ans.append(""YES"") for v in ans: print(v) return def examB(): T = I() ans = [] for _ in range(T): N = I() A = LI() A.sort() ans.append(A[::-1]) for v in ans: print("" "".join(map(str,v))) return def examC(): T = I() ans = [] for _ in range(T): N, K = LI() A = LI() sumA = sum(A) if sumA==0: ans.append(""YES"") continue cur = 0 L = [] for i in range(100): now = K**i L.append(now) cur += now if cur>=sumA: break for i in range(N): A[i] *= (-1) heapify(A) for l in L[::-1]: if not A: break a = -heappop(A) if a<l: heappush(A, -a) elif a>l: heappush(A,-(a-l)) if not A or heappop(A)==0: ans.append(""YES"") else: ans.append(""NO"") for v in ans: print(v) return def examD(): class combination(): def __init__(self, n, mod): self.n = n self.fac = [1] * (n + 1) self.inv = [1] * (n + 1) for j in range(1, n + 1): self.fac[j] = self.fac[j - 1] * j % mod self.inv[n] = pow(self.fac[n], mod - 2, mod) for j in range(n - 1, -1, -1): self.inv[j] = self.inv[j + 1] * (j + 1) % mod def comb(self, n, r, mod): if r > n or n < 0 or r < 0: return 0 return self.fac[n] * self.inv[n - r] * self.inv[r] % mod N, M = LI() ans = 0 if N==2: print(ans) return C = combination(M,mod2) for i in range(N-1,M+1): cur = pow(2,N-3,mod2) * (i-1) * C.comb(i-2,N-3,mod2) ans += cur ans %= mod2 print(ans) return def examE(): N = I() A = LI() dp = [[-1]*(N+1) for _ in range(N+1)] for i in range(N): dp[i][i+1] = A[i] for l in range(2, N + 1): for i in range(N - l + 1): for k in range(i + 1, i + l): if dp[i][k] >= 1 and dp[i][k] == dp[k][i+l]: dp[i][i + l] = dp[i][k] + 1 L = [inf]*(N+1) for i in range(1,N+1): if dp[0][i]>=1: L[i] = 1 for i in range(N): for k in range(1, N - i + 1): if dp[i][i + k] >= 1: L[i + k] = min(L[i + k], L[i] + 1) ans = L[N] print(ans) return def examF(): ans = 0 print(ans) return import sys,copy,bisect,itertools,heapq,math,random from heapq import heappop,heappush,heapify from collections import Counter,default",cubic,"['dp', 'greedy']",2000
"import sys input=lambda: sys.stdin.readline().rstrip() import copy n=int(input()) A=[int(i) for i in input().split()] inf=float(""inf"") DP=[[inf]*(n+1) for _ in range(n+1)] for j in range(1,n+1): for i in range(n): if i+j>n: continue else: if j==1: DP[i][i+1]=A[i] else: for k in range(i+1,i+j): if DP[i][k]<10000 and DP[k][i+j]<10000: if DP[i][k]==DP[k][i+j]: DP[i][i+j]=DP[i][k]+1 else: DP[i][i+j]=20000 else: if DP[i][k]<10000: DP[i][i+j]=min(DP[i][i+j],10000+DP[k][i+j]) elif DP[k][i+j]<10000: DP[i][i+j]=min(DP[i][i+j],DP[i][k]+10000) else: DP[i][i+j]=min(DP[i][i+j],DP[i][k]+DP[k][i+j]) print(DP[0][n]//10000 if DP[0][n]>=10000 else 1)",cubic,"['dp', 'greedy']",640
"N = int(input()) X = list(map(int, input().split())) from collections import defaultdict dp1 = defaultdict(lambda :-1) M=1001 def ec(i,j): return i*M+j for i in range(N): dp1[ec(i,i+1)] = X[i] for i in range(2, N+1): for j in range(N-i+1): for k in range(1, i): u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)] if u != -1 and v != -1 and u == v: dp1[ec(j,j+i)] = u+1 break dp2 = [0]*(N+1) for i in range(N): dp2[i+1] = dp2[i]+1 for j in range(i+1): if dp1[ec(j,i+1)] == -1: continue dp2[i+1] = min(dp2[i+1], dp2[j]+1) print(dp2[-1])",cubic,"['dp', 'greedy']",523
"N = int(input()) X = list(map(int, input().split())) from collections import defaultdict dp1 = defaultdict(lambda :-1) M=1001 def ec(i,j): return i*M+j for i in range(N): dp1[ec(i,i+1)] = X[i] for i in range(2, N+1): for j in range(N-i+1): for k in range(1, i): u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)] if u != -1 and v != -1 and u == v: dp1[ec(j,j+i)] = u+1 break dp2 = [10**18]*(N+1) dp2[0] = 0 for i in range(N): for j in range(i+1): if dp1[ec(j,i+1)] == -1: continue dp2[i+1] = min(dp2[i+1], dp2[j]+1) print(dp2[-1])",cubic,"['dp', 'greedy']",519
"import sys dp=[] a=[] def calcdp(l,r): global dp,a if l+1==r : dp[l][r]=a[l] return dp[l][r] if dp[l][r]!=0: return dp[l][r] dp[l][r]=-1 for k in range(l+1,r): la=calcdp(l,k) ra=calcdp(k,r) if la>0 and la==ra: dp[l][r]=la+1 return dp[l][r] def solve(n): dp2=[float('inf')]*(n+1) dp2[0]=0 for i in range(n): for j in range(i+1,n+1): if calcdp(i,j)>0: dp2[j]=min(dp2[j],dp2[i]+1) return dp2[n] def ip(): global dp,a n=int(sys.stdin.readline()) a=list(map(int,sys.stdin.readline().split())) a.append(0) dp=[] ll=[0]*(n+1) for _ in range(n+1): dp.append(list(ll)) print(solve(n)) ip()",cubic,"['dp', 'greedy']",580
"def rr(): return input().rstrip() def rri(): return int(rr()) def rrm(): return list(map(int, rr().split())) from collections import defaultdict def mus(d=0): return defaultdict(defaultdict(d)) def ms(x, y, d=0): return [[d]*y for i in range(x)] def ar(x, d=0): return [d]*x def ppm(m, n=0, x=0, y=0): print(""\n"".join((""\t"".join((str(m[j][i]) for j in range(y or n))) for i in range(x or n)))) def ppa(a, n): print(""\t"".join(map(str, a[0:n]))) def ppl(): print(""\n+""+""- -""*20+""+\n"") INF = float(""inf"") def fake_input(): return ... dp = ms(501, 501) dp2 = ar(501, INF) def read(): n = rri() global arr arr = rrm() return arr, n def calc_dp(l, r): assert l < r if l+1 == r: dp[l][r] = arr[l] return dp[l][r] if dp[l][r] != 0: return dp[l][r] dp[l][r] = -1 for i in range(l+1, r): lf = calc_dp(l, i) rg = calc_dp(i, r) if (lf > 0 and lf == rg): dp[l][r] = lf + 1 return dp[l][r] return dp[l][r] def solve(arr, n): dp2[0] = 0 for i in range(n): for j in range(i+1, n+1): v = calc_dp(i, j) if (v > 0): dp2[j] = min(dp2[j], dp2[i]+1) ans = dp2[n] return ans if __name__ == ""__main__"": input_data = read() result = solve(*input_data) print(result)",cubic,"['dp', 'greedy']",1140
"from sys import stdin, gettrace if not gettrace(): def input(): return next(stdin)[:-1] INF = 10000 def main(): n = int(input()) aa = [int(a) for a in input().split()] dp = [[0] * (n+1) for _ in range(n)] def calc_dp(i, j): if i + 1 == j: dp[i][j] = aa[i] if dp[i][j] != 0: return dp[i][j] dp[i][j] = -1 for k in range(i+1, j): lf = calc_dp(i, k) rg = calc_dp(k, j) if lf > 0 and lf == rg: dp[i][j] = lf + 1 break return dp[i][j] dp2 = list(range(0,n+1)) for i in range(n): for j in range(i+1, n+1): if calc_dp(i, j) > 0: dp2[j] = min(dp2[j], dp2[i] + 1) print(dp2[n]) if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy']",602
"from sys import stdin, gettrace if not gettrace(): def input(): return next(stdin)[:-1] INF = 10000 def main(): n = int(input()) aa = [int(a) for a in input().split()] dp = [[0] * (n+1) for _ in range(n)] def calc_dp(i, j): if i + 1 == j: dp[i][j] = aa[i] if dp[i][j] != 0: return dp[i][j] dp[i][j] = -1 for k in range(i+1, j): lf = calc_dp(i, k) rg = calc_dp(k, j) if lf > 0 and lf == rg: dp[i][j] = lf + 1 break return dp[i][j] dp2 = list(range(0,n+1)) for i in range(n): for j in range(i+1, n+1): if calc_dp(i, j) > 0: dp2[j] = min(dp2[j], dp2[i] + 1) print(dp2[n]) if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy']",602
"from sys import stdin,stdout import sys n=int(stdin.readline().strip()) arr=list(map(int,stdin.readline().strip().split(' '))) dp_arr=[[None for i in range(n)] for i in range(n)] for i in range(n): dp_arr[i][i]=(arr[i],1,arr[i]) def merge_small(c1,c2): if c1[1]==1 and c2[1]==1: if c1[0]==c2[0]: return (c1[0]+1,1,c1[0]+1) else: return (c1[0],2,c2[0]) elif c1[1]==2 and c2[1]==1: if c1[2]==c2[0]: if c1[0]==c1[2]+1: return (c1[0]+1,1,c1[0]+1) else: return (c1[0],2,c2[2]+1) else: return (c1[0],3,c2[2]) elif c1[1]==1 and c2[1]==2: if c1[2]==c2[0]: if c2[2]==c2[0]+1: return (c2[2]+1,1,c2[2]+1) else: return (c2[0]+1,2,c2[2]) else: return(c1[0],3,c2[2]) elif c1[1]==2 and c2[1]==2: if c1[2]==c2[0]: c1=(c1[0],2,c1[2]+1) c2=(c2[2],1,c2[2]) if c1[1]==2 and c2[1]==1: if c1[2]==c2[0]: if c1[0]==c1[2]+1: return (c1[0]+1,1,c1[0]+1) else: return (c1[0],2,c2[2]+1) else: return (c1[0],3,c2[2]) else: return (c1[0],4,c2[2]) def merge_main(c1,c2): if c1[1]>2: if c2[1]>2: if c1[2]==c2[0]: return (c1[0],c1[1]+c2[1]-1,c2[2]) else: return (c1[0],c1[1]+c2[1],c2[2]) else: if c2[1]==1: if c1[2]==c2[0]: return (c1[0],c1[1],c2[2]+1) else: return (c1[0],c1[1]+1,c2[2]) if c2[1]==2: if c1[2]==c2[0]: if c1[2]+1==c2[2]: return (c1[0],c1[1],c2[2]+1) else: return (c1[0],c1[1]+1,c2[2]) else: return (c1[0],c1[1]+2,c2[2]) else: if c2[1]>2: if c1[1]==1: if c1[2]==c2[0]: return (c1[2]+1,c2[1],c2[2]) else: return (c1[2],c2[1]+1,c2[2]) if c1[1]==2: if c1[2]==c2[0]: if c1[0]==c1[2]+1: return (c1[0]+1,c2[1],c2[2]) else: return (c1[0],c2[1]+1,c2[2]) else: return (c1[0],c2[1]+2,c2[2]) else: return merge_small(c1,c2) for i1 in range(1,n): for j1 in range(n-i1): curr_pos=(j1,j1+i1) for k1 in range(j1,j1+i1): res=merge_main(dp_arr[j1][k1],dp_arr[k1+1][j1+i1]) if dp_arr[j1][j1+i1]==None or dp_arr[j1][j1+i1][1]>res[1]: dp_arr[j1][j1+i1]=res stdout.write(str(dp_arr[0][n-1][1])+""\n"")",cubic,"['dp', 'greedy']",1859
"import sys int1 = lambda x: int(x) - 1 p2D = lambda x: print(*x, sep=""\n"") def II(): return int(sys.stdin.readline()) def MI(): return map(int, sys.stdin.readline().split()) def LI(): return list(map(int, sys.stdin.readline().split())) def LLI(rows_number): return [LI() for _ in range(rows_number)] def SI(): return sys.stdin.readline()[:-1] def main(): inf=10**9 n=II() aa=LI() dp1=[[-1]*n for _ in range(n)] dp2=[[inf]*n for _ in range(n)] for i in range(n): dp1[i][i]=aa[i] dp2[i][i]=1 for w in range(2,n+1): for l in range(n-w+1): r=l+w-1 for m in range(l,r): if dp1[l][m]!=-1 and dp1[l][m]==dp1[m+1][r]: dp1[l][r]=dp1[l][m]+1 dp2[l][r]=1 for m in range(n): for l in range(m+1): for r in range(m+1,n): dp2[l][r]=min(dp2[l][r],dp2[l][m]+dp2[m+1][r]) print(dp2[0][n-1]) main()",cubic,"['dp', 'greedy']",779
"from heapq import * import sys int1 = lambda x: int(x) - 1 p2D = lambda x: print(*x, sep=""\n"") def II(): return int(sys.stdin.readline()) def MI(): return map(int, sys.stdin.readline().split()) def LI(): return list(map(int, sys.stdin.readline().split())) def LLI(rows_number): return [LI() for _ in range(rows_number)] def SI(): return sys.stdin.readline()[:-1] def main(): inf=10**9 n=II() aa=LI() dp1=[[-1]*(n+1) for _ in range(n)] to=[[i+1] for i in range(n)] for i in range(n):dp1[i][i+1]=aa[i] for w in range(2,n+1): for l in range(n-w+1): r=l+w for m in range(l+1,r): if dp1[l][m]!=-1 and dp1[l][m]==dp1[m][r]: dp1[l][r]=dp1[l][m]+1 to[l].append(r) hp=[] heappush(hp,(0,0)) dist=[-1]*(n+1) while hp: d,i=heappop(hp) if i==n: print(d) break if dist[i]!=-1:continue dist[i]=d for j in to[i]: if dist[j]!=-1:continue heappush(hp,(d+1,j)) main()",cubic,"['dp', 'greedy']",848
"n=int(input()) a=list(map(int,input().split())) grip=[[-1]*(n-i) for i in range(n)] grip[0]=a.copy() for level in range(1,n): for left in range(n-level): for split in range(level): pl=grip[level-split-1][left] pr=grip[split][left+level-split] if pl==pr!=-1: grip[level][left]=pl+1 pref=[0]*(n+1) for p in range(1,n+1): x=n for j in range(p): l=pref[j] r=grip[p-j-1][j] if r==-1: r=p-j else: r=1 x=min(x,l+r) pref[p]=x print(pref[-1])",cubic,"['dp', 'greedy']",433
"n = int(input()) a = [ int(x) for x in input().split() ] dp = [ [-1] * (n+1) for _ in range(n+1) ] for i in range(n): dp[i][i+1] = a[i] for leng in range(2, n+1): for l in range(n+1): if l + leng > n: continue r = l + leng for mid in range(l+1, n+1): if dp[l][mid] != -1 and dp[l][mid] == dp[mid][r]: dp[l][r] = dp[l][mid] + 1 dp2 = [ float(""inf"") for _ in range(n+1) ] for i in range(n+1): dp2[i] = i for j in range(i): if dp[j][i] != -1: dp2[i] = min(dp2[i], dp2[j] + 1) print(dp2[n])",cubic,"['dp', 'greedy']",486
"n= int(input()) b = [int(_) for _ in input().split()] d = [[-1 if i != j else b[i] for i in range(n)] for j in range(n)] for l in range(1, n): for s in range(n-l): e = s + l for m in range(s, e): if d[s][m] == d[m+1][e] and d[s][m] != -1: d[s][e] = d[s][m] + 1 a = [1] for e in range(1, n): t = 4096 for s in range(e+1): if d[s][e] != -1: t = min(t, ((a[s-1]+1) if s > 0 else a[s])) a.append(t) print(a[-1])",cubic,"['dp', 'greedy']",407
"n= int(input()) b = [int(_) for _ in input().split()] d = [[b[i] if i == j else -1 for i in range(n)] for j in range(n)] def f(i, j): if d[i][j] != -1: return d[i][j] d[i][j] = 0 for m in range(i, j): l = f(i, m) if f(m+1, j) == l and l: d[i][j] = l+1 break return d[i][j] a = [_ for _ in range(1, n+1)] for e in range(1, n): for s in range(e+1): if f(s, e): a[e] = min(a[e], ((a[s-1]+1) if s > 0 else a[s])) print(a[-1])",cubic,"['dp', 'greedy']",421
"n = int(input()) b = [int(_) for _ in input().split()] e = [[-1] * (n+1) for _ in range(2024)] d = [[] for _ in range(n)] for i, v in enumerate(b): e[v][i] = i d[i].append(i) for v in range(1, 2024): for i in range(n): j = e[v][i] h = e[v][j+1] if j != -1 else -1 if j != -1 and h != -1: e[v+1][i] = h d[i].append(h) a = [_ for _ in range(1, n+1)] for s in range(n): for e in d[s]: a[e] = min(a[e], a[s-1]+1 if s > 0 else 1) print(a[n-1])",cubic,"['dp', 'greedy']",438
"n = int(input()) b = [int(_) for _ in input().split()] e = [[-1] * (n+1) for _ in range(2002)] d = [[] for _ in range(n)] for i, v in enumerate(b): e[v][i] = i d[i].append(i) for v in range(1, 2002): for i in range(n): j = e[v][i] h = e[v][j+1] if j != -1 else -1 if j != -1 and h != -1: e[v+1][i] = h d[i].append(h) a = [_ for _ in range(1, n+1)] for s in range(n): for e in d[s]: a[e] = min(a[e], a[s-1]+1 if s > 0 else 1) print(a[n-1])",cubic,"['dp', 'greedy']",438
"n = int(input()) A = list(map(int, input().split())) INF = 10**3 dp = [[INF]*(n+1) for _ in range(n+1)] val = [[0]*(n+1) for _ in range(n+1)] for i in range(n): dp[i][i+1] = 1 for i in range(n): val[i][i+1] = A[i] for d in range(2, n+1): for i in range(n+1-d): j = i+d for k in range(i+1, j): if dp[i][k] == 1 and dp[k][j] == 1 and val[i][k] == val[k][j]: dp[i][j] = min(dp[i][j], 1) val[i][j] = val[i][k]+1 else: dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]) print(dp[0][n])",cubic,"['dp', 'greedy']",473
"import math input_list = lambda: list(map(int, input().split())) n = int(input()) a = input_list() rows, cols = (n+1, n+1) dp = [[-1 for i in range(rows)] for j in range(cols)] for i in range(n): dp[i][i] = a[i] for last in range(1, n): for first in range(last - 1, -1, -1): for mid in range(last, first, -1): if dp[first][mid-1]!=-1 and dp[mid][last]!=-1 and dp[first][mid-1] == dp[mid][last]: dp[first][last] = dp[first][mid-1] + 1 ans = [0 for i in range(n)] for i in range(n): ans[i] = i+1 for i in range(n): for j in range(i, -1, -1): if (j-1>=0): if (dp[j][i]!=-1): ans[i] = min(ans[i], ans[j-1] + 1) elif (dp[0][i]!=-1): ans[i] = 1 print(ans[n-1])",cubic,"['dp', 'greedy']",654
"from collections import Counter from collections import defaultdict import math import random import heapq as hq from math import sqrt import sys from functools import reduce def input(): return sys.stdin.readline().strip() def iinput(): return int(input()) def tinput(): return input().split() def rinput(): return map(int, tinput()) def rlinput(): return list(rinput()) mod = int(1e9)+7 def factors(n): return set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))) if __name__ == ""__main__"": n = iinput() a = rlinput() dp = [[0 for i in range(n)] for j in range(n)] for i in range(n): dp[i][i] = a[i] for l in range(n-2, -1, -1): for r in range(l+1, n): for k in range(l, r): if dp[l][k] == dp[k+1][r] and dp[l][k] != 0: dp[l][r] = dp[l][k]+1 squeeze = [float('inf')]*(n+1) squeeze[0] = 0 for i in range(1, n+1): for j in range(i): if dp[j][i-1] != 0: squeeze[i] = min(squeeze[i], squeeze[j]+1) print(squeeze[n])",cubic,"['dp', 'greedy']",947
"import sys input = sys.stdin.readline n = int(input()) a = list(map(int,input().split())) dp = [[1000]*(n+1) for i in range(n+1)] val = [[0]*(n+1) for i in range(n+1)] for i in range(n): dp[i][i+1] = 1 val[i][i+1] = a[i] for p in range(2,n+1): for i in range(n-p+1): j = i+p for k in range(i+1,j): if dp[i][k] == dp[k][j] == 1 and val[i][k] == val[k][j]: dp[i][j] = 1 val[i][j] = val[i][k] + 1 else: dp[i][j] = min(dp[i][j] , dp[i][k]+dp[k][j]) print(dp[0][n])",cubic,"['dp', 'greedy']",460
"N=int(input()) L=list(map(int,input().split())) DP=[[-1]*N for i in range(N)] for d in range(N): for s in range(N-d): e=s+d if s==e: DP[s][e]=L[s] continue for m in range(s,e): l=DP[s][m] r=DP[m+1][e] if l==r and l!=-1: DP[s][e]=max(DP[s][e],l+1) DP2=[i+1 for i in range(N)] for i in range(N): if DP[0][i]!=-1: DP2[i]=1 continue for j in range(i): if DP[j+1][i]!=-1: DP2[i]=min(DP2[i],DP2[j]+1) print(DP2[N-1])",cubic,"['dp', 'greedy']",410
"import sys input = sys.stdin.readline n = int(input().strip()) a = [int(x) for x in input().strip().split()] dp = [[0]*n for i in range(n)] for i in range(n): dp[i][i] = [a[i], 1] for i in range(1, n): for j in range(n-i): v, c = -1, i+1 for k in range(i): if dp[j][j+k][0]!=-1 and dp[j][j+k][0] == dp[j+k+1][j+i][0]: v,c = dp[j][j+k][0]+1, 1 break else: v, c = -1, min(c, dp[j][j+k][1] + dp[j+k+1][j+i][1]) dp[j][j+i] = [v, c] print(dp[0][-1][1])",cubic,"['dp', 'greedy']",447
"n = int(input()) a = list(map(int, input().split())) dp = [[505]*n for _ in range(n)] Max = [[0]*n for _ in range(n)] for i in range(n): dp[i][i] = 1 Max[i][i] = a[i] for len in range(1, n+1): for i in range(n-len+1): j = i + len - 1 for k in range(i, j): dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]) if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]: dp[i][j] = 1 Max[i][j] = Max[i][k] + 1 print(dp[0][n-1])",cubic,"['dp', 'greedy']",427
"N = int(input()) arr = list(map(int, input().split())) dp = [[-1 for x in range(N)] for y in range(N)] for size in range(1, N + 1): for i in range(N - size + 1): j = i + size - 1 if (i == j): dp[i][j] = arr[i] else: for k in range(i, j): if (dp[i][k] != -1 and dp[i][k] == dp[k + 1][j]): dp[i][j] = dp[i][k] + 1 dp2 = [x+1 for x in range(N)] for i in range(N): for k in range(i + 1): if (dp[k][i] != -1): if (k == 0): dp2[i] = 1 else: dp2[i] = min(dp2[i], dp2[k - 1] + 1) print(dp2[N - 1])",cubic,"['dp', 'greedy']",489
"import sys input = sys.stdin.readline N = int(input()) A = list(map(int, input().split())) dp = [[-1]*(N+1) for _ in range(N+1)] for l in range(N): dp[l][l+1] = A[l] for d in range(2, N+1): for l in range(N-d+1): for t in range(1, d): if dp[l][l+t] == dp[l+t][l+d] and dp[l][l+t] != -1: dp[l][l+d] = dp[l][l+t] + 1 break dp2 = [i for i in range(N+1)] for r in range(1,N+1): if dp[0][r] != -1: dp2[r] = 1 for l in range(N): for r in range(l+2, N+1): if dp[l+1][r] != -1: dp2[r] = min(dp2[l+1]+1, dp2[r]) else: dp2[r] = min(dp2[l+1]+(r-l-1), dp2[r]) print(dp2[N])",cubic,"['dp', 'greedy']",561
"n = int(input()) b = [int(_) for _ in input().split()] e = [[-1] * (n+1) for _ in range(2024)] d = [[] for _ in range(n)] for i, v in enumerate(b): e[v][i] = i d[i].append(i) for v in range(1, 2024): for i in range(n): j = e[v][i] h = e[v][j+1] if j != -1 else -1 if j != -1 and h != -1: e[v+1][i] = h d[i].append(h) a = [_ for _ in range(1, n+1)] for s in range(n): for e in d[s]: a[e] = min(a[e], a[s-1]+1 if s > 0 else 1) print(a[n-1])",cubic,"['dp', 'greedy']",438
"n = int(input()) a = list(map(int, input().split())) dp = [[505]*n for _ in range(n)] Max = [[0]*n for _ in range(n)] for i in range(n): dp[i][i] = 1 Max[i][i] = a[i] for len in range(1, n+1): for i in range(n-len+1): j = i + len - 1 for k in range(i, j): dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]) if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]: dp[i][j] = 1 Max[i][j] = Max[i][k] + 1 print(dp[0][n-1])",cubic,"['dp', 'greedy']",427
"m = int(input()) a = list(map(int, input().split())) dp = [[505]*m for _ in range(m)] Max = [[0]*m for _ in range(m)] for i in range(m): dp[i][i] = 1 Max[i][i] = a[i] for len in range(1, m+1): for i in range(m-len+1): j = i + len - 1 for k in range(i, j): dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]) if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]: dp[i][j] = 1 Max[i][j] = Max[i][k] + 1 print(dp[0][m-1])",cubic,"['dp', 'greedy']",427
"n = int(input()) b = [int(_) for _ in input().split()] e = [[-1] * (n+1) for _ in range(2024)] d = [[] for _ in range(n)] for i, v in enumerate(b): e[v][i] = i d[i].append(i) for v in range(1, 2024): for i in range(n): j = e[v][i] h = e[v][j+1] if j != -1 else -1 if j != -1 and h != -1: e[v+1][i] = h d[i].append(h) a = [_ for _ in range(1, n+1)] for s in range(n): for e in d[s]: a[e] = min(a[e], a[s-1]+1 if s > 0 else 1) print(a[n-1])",cubic,"['dp', 'greedy']",438
"n = int(input()) b = [int(_) for _ in input().split()] e = [[-1] * (n+1) for _ in range(2024)] d = [[] for _ in range(n)] for j, v in enumerate(b): e[v][j] = j d[j].append(j) for v in range(1, 2024): for i in range(n): j = e[v][i] h = e[v][j+1] if j != -1 else -1 if j != -1 and h != -1: e[v+1][i] = h d[i].append(h) a = [_ for _ in range(1, n+1)] for s in range(n): for e in d[s]: a[e] = min(a[e], a[s-1]+1 if s > 0 else 1) print(a[n-1])",cubic,"['dp', 'greedy']",438
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import factorial from collections import Counter, defaultdict, deque from heapq import heapify, heappop, heappush def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') def main(): n = N() arr = RLL() dp = [[n]*n for i in",cubic,"['dp', 'greedy']",1999
"n = int(input()) a = list(map(int, input().split(' '))) new_a = [[0] * 600 for i in range(600)] dp = [[0x7fffffff] * 600 for i in range(600)] for i in range(n): new_a[i+1][i+1] = a[i] dp[i+1][i+1] = 1 for i in range(1, n + 1): for j in range(i + 1, n + 1): dp[i][j] = j - i + 1 for llen in range(2, n + 1): for left in range(1, n - llen + 2): right = left + llen - 1 for middle in range(left, right): dp[left][right] = min(dp[left][right], dp[left][middle] + dp[middle+1][right]) if dp[left][middle] == 1 and dp[middle+1][right] == 1 and new_a[left][middle] == new_a[middle+1][right]: dp[left][right] = 1 new_a[left][right] = new_a[left][middle] + 1 print(dp[1][n])",cubic,"['dp', 'greedy']",665
"n = int(input()) b = list(map(int, input().split(' '))) e = [[-1] * (n+1) for _ in range(2048)] d = [[] for _ in range(n)] for i, v in enumerate(b): e[v][i] = i d[i].append(i) for v in range(1, 2048): for i in range(n): j = e[v][i] if j != -1: h = e[v][j+1] else: h = -1 if j != -1 and h != -1: e[v+1][i] = h d[i].append(h) a = [_ for _ in range(1, n+1)] for s in range(n): for e in d[s]: if s > 0: temp = a[s-1]+1 else : temp = 1 a[e] = min(a[e], temp) print(a[n-1])",cubic,"['dp', 'greedy']",467
"n = int(input()) b = [int(_) for _ in input().split()] e = [[-1] * (n + 1) for _ in range(2024)] d = [[] for _ in range(n)] for i, v in enumerate(b): e[v][i] = i d[i].append(i) for v in range(1, 2024): for i in range(n): j = e[v][i] h = e[v][j + 1] if j != -1 else -1 if j != -1 and h != -1: e[v + 1][i] = h d[i].append(h) a = [_ for _ in range(1, n + 1)] for s in range(n): for e in d[s]: a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1) print(a[n - 1])",cubic,"['dp', 'greedy']",452
"n = int(input()) b = [int(_) for _ in input().split()] e = [[-1] * (n + 1) for _ in range(3024)] d = [[] for _ in range(n)] for i, v in enumerate(b): e[v][i] = i d[i].append(i) for v in range(1, 3024): for i in range(n): j = e[v][i] h = e[v][j + 1] if j != -1 else -1 if j != -1 and h != -1: e[v + 1][i] = h d[i].append(h) a = [_ for _ in range(1, n + 1)] for s in range(n): for e in d[s]: a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1) print(a[n - 1])",cubic,"['dp', 'greedy']",452
"n=int(input()) li=list(map(int,input().split("" ""))) dp1=[] for i in range(n): lis=[-1]*n dp1.append(lis) dp2=[0]*n for i in range(n): dp1[i][i]=li[i] for i in range(n): dp2[i]=i+1 size=2 while size<=n: i=0 while i<n-size+1: j=i+size-1 k=i while k<j: if dp1[i][k]!=-1: if dp1[i][k]==dp1[k+1][j]: dp1[i][j]=dp1[i][k]+1 k+=1 i+=1 size+=1 i=0 while i<n: k=0 while k<=i: if dp1[k][i]!=-1: if k==0: dp2[i]=1 else: dp2[i]=min(dp2[i],dp2[k-1]+1) k+=1 i+=1 print(dp2[n-1])",cubic,"['dp', 'greedy']",463
"from collections import defaultdict,deque from heapq import heappush, heappop from bisect import bisect_left, bisect_right import sys, itertools, math sys.setrecursionlimit(10**5) input = sys.stdin.readline sqrt = math.sqrt def LI(): return list(map(int, input().split())) def LF(): return list(map(float, input().split())) def LI_(): return list(map(lambda x: int(x)-1, input().split())) def II(): return int(input()) def IF(): return float(input()) def S(): return input().rstrip() def LS(): return S().split() def IR(n): res = [None] * n for i in range(n): res[i] = II() return res def LIR(n): res = [None] * n for i in range(n): res[i] = LI() return res def FR(n): res = [None] * n for i in range(n): res[i] = IF() return res def LIR(n): res = [None] * n for i in range(n): res[i] = IF() return res def LIR_(n): res = [None] * n for i in range(n): res[i] = LI_() return res def SR(n): res = [None] * n for i in range(n): res[i] = S() return res def LSR(n): res = [None] * n for i in range(n): res[i] = LS() return res mod = 1000000007 inf = float('INF') def solve(): n = II() a = LI() dp = [[None for i in range(n + 1)] for i in range(n + 1)] for i in range(n): dp[i][i + 1] = [a[i], a[i], 1] dp[i + 1][i] = [a[i], a[i], 1] for i in range(2, n + 1): for l in range(n - i + 1): tmp = [-inf, inf, inf] r = l + i dpl = dp[l] dpr = dp[r] for m in range(l + 1, r): lm = dpl[m] mr = dpr[m] lr = lm[2] + mr[2] - (lm[1] == mr[0]) if lr < tmp[2]: tmp[2] = lr if lm[1] == mr[0]: if lm[2] == 1: tmp[0] = lm[0] + 1 else: tmp[0] = lm[0] if mr[2] == 1: tmp[1] = mr[1] + 1 else: tmp[1] = mr[1] else: tmp[0] = lm[0] tmp[1] = mr[1] dp[l][r] = tmp dp[r][l] = tmp print(dp[0][n][2]) return if __name__ == '__main__': solve()",cubic,"['dp', 'greedy']",1709
"import sys, math import io, os from bisect import bisect_left as bl, bisect_right as br, insort from collections import defaultdict as dd, deque, Counter def data(): return sys.stdin.readline().strip() def mdata(): return list(map(int, data().split())) def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n') def out(var): sys.stdout.write(str(var) + '\n') from decimal import Decimal INF = float('inf') mod = int(1e9) + 7 def cal(l,r): if l==r: dp1[l][r]=1 dp2[l][r]=a[l] if dp1[l][r]: return dp1[l][r] for i in range(l,r): if cal(l,i)==1 and cal(i+1,r)==1 and dp2[l][i]==dp2[i+1][r]: dp1[l][r]=1 dp2[l][r]=dp2[l][i]+1 if not dp2[l][r]: dp1[l][r]=2 return dp1[l][r] def cal2(l,r): if dp1[l][r]==1: dp3[l][r]=1 return 1 elif dp3[l][r]: return dp3[l][r] ans=INF for i in range(l,r): ans=min(cal2(l,i)+cal2(i+1,r),ans) dp3[l][r]=ans return ans n=int(data()) a=mdata() ans=[n] dp1=[[0]*n for i in range(n)] dp2=[[0]*n for i in range(n)] dp3=[[0]*n for i in range(n)] cal(0,n-1) cal2(0,n-1) out(dp3[0][n-1])",cubic,"['dp', 'greedy']",1011
"import sys, math import io, os from bisect import bisect_left as bl, bisect_right as br, insort from collections import defaultdict as dd, deque, Counter def data(): return sys.stdin.readline().strip() def mdata(): return list(map(int, data().split())) def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n') def out(var): sys.stdout.write(str(var) + '\n') from decimal import Decimal INF = 10001 mod = int(1e9) + 7 def cal(l,r): if l==r: dp1[l][r]=a[l] dp3[l][r] = 1 return dp1[l][r] if dp1[l][r]!=-1: return dp1[l][r] for i in range(l,r): if cal(l,i) == cal(i+1,r) != 0: dp1[l][r]=dp1[l][i]+1 dp3[l][r]=1 dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r]) if dp1[l][r] == -1: dp1[l][r] = 0 return dp1[l][r] n=int(data()) a=mdata() ans=[n] dp1=[[-1]*n for i in range(n)] dp3=[[10001]*n for i in range(n)] cal(0,n-1) out(dp3[0][n-1])",cubic,"['dp', 'greedy']",837
"import sys, math import io, os from bisect import bisect_left as bl, bisect_right as br, insort from collections import defaultdict as dd, deque, Counter def data(): return sys.stdin.readline().strip() def mdata(): return list(map(int, data().split())) def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n') def out(var): sys.stdout.write(str(var) + '\n') from decimal import Decimal INF = 10001 mod = int(1e9) + 7 n=int(data()) a=mdata() ans=[n] dp1=[[0]*n for i in range(n)] dp2=[[n]*n for i in range(n)] for i in range(n-1,-1,-1): dp1[i][i]=a[i] dp2[i][i]=1 for j in range(i+1,n): for k in range(i,j): if dp1[i][k] == dp1[k+1][j] != 0: dp1[i][j] = dp1[i][k] + 1 dp2[i][j] = 1 dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j]) out(dp2[0][n-1])",cubic,"['dp', 'greedy']",758
"import sys, math import io, os from bisect import bisect_left as bl, bisect_right as br, insort from collections import defaultdict as dd, deque, Counter def data(): return sys.stdin.readline().strip() def mdata(): return list(map(int, data().split())) def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n') def out(var): sys.stdout.write(str(var) + '\n') from decimal import Decimal INF = 10001 mod = int(1e9) + 7 n=int(data()) a=mdata() dp1=[[0]*n for i in range(n)] dp2=[[n]*n for i in range(n)] for i in range(n-1,-1,-1): dp1[i][i]=a[i] dp2[i][i]=1 for j in range(i+1,n): for k in range(i,j): if dp1[i][k] == dp1[k+1][j] != 0: dp1[i][j] = dp1[i][k] + 1 dp2[i][j] = 1 break dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j]) out(dp2[0][n-1])",cubic,"['dp', 'greedy']",756
"n = int(input()) b = [int(_) for _ in input().split()] e = [[-1] * (n+1) for _ in range(2024)] d = [[] for _ in range(n)] for i, v in enumerate(b): e[v][i] = i d[i].append(i) for v in range(1, 2024): for i in range(n): j = e[v][i] h = e[v][j+1] if j != -1 else -1 if j != -1 and h != -1: e[v+1][i] = h d[i].append(h) a = [_ for _ in range(1, n+1)] for s in range(n): for e in d[s]: a[e] = min(a[e], a[s-1]+1 if s > 0 else 1) print(a[n-1])",cubic,"['dp', 'greedy']",438
"n = int(input()) arr = list(map(int, input().split())) tracker = [[-1] * (n+1) for _ in range(2024)] d = [[] for _ in range(n)] for j, v in enumerate(arr): tracker[v][j] = j d[j].append(j) for v in range(1, 2024): for i in range(n): j = tracker[v][i] h = tracker[v][j+1] if j != -1 else -1 if j != -1 and h != -1: tracker[v+1][i] = h d[i].append(h) a = [_ for _ in range(1, n+1)] for s in range(n): for tracker in d[s]: a[tracker] = min(a[tracker], a[s-1]+1 if s > 0 else 1) print(a[n-1])",cubic,"['dp', 'greedy']",488
"import os import sys from io import BytesIO, IOBase import heapq as h from bisect import bisect_left, bisect_right from types import GeneratorType BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): import os self.os = os self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: self.os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from collections import defaultdict as dd, deque as dq import math, string def getInts(): return [int(s) for s in input().split()] def getInt(): return int(input()) def getStrs(): return [s for s in input().split()] def getStr(): return input() def listStr(): return list(input()) MOD = 998244353 def solve(): N = getInt() A = getInts() dp = [[-1 for j in range(N)] for i in range(N)] for i in range(N): dp[i][i] = A[i] for X in range(2,N+1): for i in range(N",cubic,"['dp', 'greedy']",1999
"import sys from array import array from typing import List, Tuple, TypeVar, Generic, Sequence, Union def input(): return sys.stdin.buffer.readline().decode('utf-8') def main(): n = int(input()) a = list(map(int, input().split())) dp = [array('h', [10000]) * (n + 1) for _ in range(n + 1)] num = [array('h', [-1]) * (n + 1) for _ in range(n + 1)] for i in range(n): dp[i][i + 1] = 1 num[i][i + 1] = a[i] for sublen in range(2, n + 1): for l, r in zip(range(n), range(sublen, n + 1)): for mid in range(l + 1, r): if num[l][mid] == num[mid][r] != -1: dp[l][r] = 1 num[l][r] = num[l][mid] + 1 break dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid][r]) print(dp[0][-1]) if __name__ == '__main__': main()",cubic,"['dp', 'greedy']",695
"from sys import stdin nii=lambda:map(int,stdin.readline().split()) lnii=lambda:list(map(int,stdin.readline().split())) R,G,B=nii() r=lnii() g=lnii() b=lnii() r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) dp=[[[0]*(B+1) for i in range(G+1)] for j in range(R+1)] for i in range(R+1): for j in range(G+1): for k in range(B+1): c=False if i<R and j<G: dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+r[i]*g[j]) c=True if j<G and k<B: dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+g[j]*b[k]) c=True if k<B and i<R: dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+b[k]*r[i]) c=True if not c: if i<R: dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]) if j<G: dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]) if k<B: dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k]) ans=0 for i in dp: for j in i: ans=max(ans,max(j)) print(ans)",cubic,"['dp', 'greedy', 'sortings']",825
"import sys from array import array import typing as Tp def input(): return sys.stdin.buffer.readline().decode('utf-8') def output(*args): sys.stdout.buffer.write( ('\n'.join(map(str, args)) + '\n').encode('utf-8') ) def main(): R, G, B = map(int, input().split()) r_sticks = sorted(map(float, input().split()), reverse=True) + [0.0] g_sticks = sorted(map(float, input().split()), reverse=True) + [0.0] b_sticks = sorted(map(float, input().split()), reverse=True) + [0.0] dp = [[[0.0] * (B + 2) for _ in range(G + 2)] for _ in range(R + 2)] for ri in range(R + 1): for gi in range(G + 1): for bi in range(B + 1): dp[ri + 1][gi + 1][bi] = max(dp[ri + 1][gi + 1][bi], dp[ri][gi][bi] + r_sticks[ri] * g_sticks[gi]) dp[ri + 1][gi][bi + 1] = max(dp[ri + 1][gi][bi + 1], dp[ri][gi][bi] + r_sticks[ri] * b_sticks[bi]) dp[ri][gi + 1][bi + 1] = max(dp[ri][gi + 1][bi + 1], dp[ri][gi][bi] + g_sticks[gi] * b_sticks[bi]) ans = max(max(max(dp[r][g][b] for b in range(B + 1)) for g in range(G + 1)) for r in range(R + 1)) print(int(ans + 1e-6)) if __name__ == '__main__': main()",cubic,"['dp', 'greedy', 'sortings']",1064
"def func(n1,n2,n3): global r,g,b if((n1<0 and n2<0) or (n3<0 and n2<0) or (n1<0 and n3<0) ): return 0 if(n1<0): return g[n2]*b[n3] + func(n1,n2-1,n3-1) if(n2<0): return r[n1]*b[n3] + func(n1-1,n2,n3-1) if(n3<0): return g[n2]*r[n1] + func(n1-1,n2-1,n3) if(dp[n1][n2][n3]==-1): dp[n1][n2][n3]= max(g[n2]*b[n3] + func(n1,n2-1,n3-1),r[n1]*b[n3] + func(n1-1,n2,n3-1),g[n2]*r[n1] + func(n1-1,n2-1,n3)) return dp[n1][n2][n3] R,G,B=tuple(map(int,input().split())) r=list(map(int,input().split())) g=list(map(int,input().split())) b=list(map(int,input().split())) r=sorted(r) g=sorted(g) b=sorted(b) prefix1=[0]*R prefix2 = [0]*G prefix3 = [0]*B prefix1[0]=r[0] prefix2[0] = g[0] prefix3[0]=b[0] dp=[[[-1 for i in range(B)] for j in range(G)]for k in range(R)] print(func(R-1,G-1,B-1))",cubic,"['dp', 'greedy', 'sortings']",776
"import sys input = sys.stdin.readline rr, gg, bb = map(int, input().split()) inf = 114514 r = list(map(int, input().split())) + [inf] g = list(map(int, input().split())) + [inf] b = list(map(int, input().split())) + [inf] r.sort(reverse = True) g.sort(reverse = True) b.sort(reverse = True) dp = [] for _ in range(rr + 1): dp.append([[0] * (bb + 1) for _ in range(gg + 1)]) ans = 0 for i in range(rr + 1): ri = r[i] for j in range(gg + 1): gj = g[j] for k in range(bb + 1): bk = b[k] if (i + j + k) % 2: continue dpijk = 0 if i > 0 and j > 0: dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk) if j > 0 and k > 0: dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk) if k > 0 and i > 0: dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk) dp[i][j][k] = dpijk if ans < dpijk: ans = dpijk print(ans)",cubic,"['dp', 'greedy', 'sortings']",791
"r,g,b=map(int,input().split()) rs=sorted(list(map(int,input().split()))) gs=sorted(list(map(int,input().split()))) bs=sorted(list(map(int,input().split()))) dp=[[[0 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)] ans=0 for i in range(r+1): for j in range(g+1): for k in range(b+1): if i>0 and k>0: dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rs[i-1]*bs[k-1]) if i>0 and j>0: dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rs[i-1]*gs[j-1]) if j>0 and k>0: dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gs[j-1]*bs[k-1]) ans=max(ans,dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",563
"R,G,B=map(int,input().split()) r=list(map(int,input().split())) g=list(map(int,input().split())) b=list(map(int,input().split())) r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) dp=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)] def calc(nr,ng,nb): if dp[nr][ng][nb]!=-1: return dp[nr][ng][nb] res=0 if nr<R and ng<G: res=max(res,calc(nr+1,ng+1,nb)+r[nr]*g[ng]) if nr<R and nb<B: res=max(res,calc(nr+1,ng,nb+1)+r[nr]*b[nb]) if ng<G and nb<B: res=max(res,calc(nr,ng+1,nb+1)+g[ng]*b[nb]) dp[nr][ng][nb]=res return res print(calc(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",556
"R, G, B = map(int, input().split()) r = list(map(int, input().split())) g = list(map(int, input().split())) b = list(map(int, input().split())) r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) dp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)] mx = 0 for i in range(R+1): for j in range(G+1): for k in range(B+1): if i < R and j < G: dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j]) if i < R and k < B: dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k]) if j < G and k < B: dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k]) mx = max(mx, dp[i][j][k]) print(mx)",cubic,"['dp', 'greedy', 'sortings']",646
"r,g,b = map(int,input().split()) R = list(map(int,input().split())) G = list(map(int,input().split())) B = list(map(int,input().split())) R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)] for j in range(g-1,-1,-1): for k in range(b-1,-1,-1): dp[r][j][k] = G[j]*B[k] + dp[r][j+1][k+1] for i in range(r-1,-1,-1): for k in range(b-1,-1,-1): dp[i][g][k] = R[i]*B[k] + dp[i+1][g][k+1] for i in range(r-1,-1,-1): for j in range(g-1,-1,-1): dp[i][j][b] = R[i]*G[j] + dp[i+1][j+1][b] for i in range(r-1,-1,-1): for j in range(g-1,-1,-1): for k in range(b-1,-1,-1): case1 = dp[i+1][j][k] case2 = dp[i][j+1][k] case3 = dp[i][j][k+1] case4 = R[i]*G[j] + dp[i+1][j+1][k] case5 = R[i]*B[k] + dp[i+1][j][k+1] case6 = G[j]*B[k] + dp[i][j+1][k+1] dp[i][j][k] = max(case1,case2,case3,case4,case5,case6) print(dp[0][0][0])",cubic,"['dp', 'greedy', 'sortings']",876
"import sys input = sys.stdin.readline r, g, b = map(int, input().split()) sticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)] dp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 for i in range(r + 1): for j in range(g + 1): for k in range(b + 1): if i < r and j < g: dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j]) if i < r and k < b: dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k]) if j < g and k < b: dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",685
"import sys input = sys.stdin.readline r, g, b = map(int, input().split()) sticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 for i in range(r + 1): for j in range(g + 1): for k in range(b + 1): ans = max(ans, dp[i][j][k]) if i < r and j < g: dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j]) if i < r and k < b: dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k]) if j < g and k < b: dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",685
"import os, sys from io import BytesIO, IOBase from math import log2, ceil, sqrt, gcd from _collections import deque import heapq as hp from bisect import bisect_left, bisect_right BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") mod = 10 ** 9 + 7 R,G,B=map(int,input().split()) r=list(map(int,input().split())) g=list(map(int,input().split())) b=list(map(int,input().split())) r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) dp=[[[0]*(B+1) for _ in range(G+1)] for __ in range(R+1)] ans=0 for i in range(R+1): for j in range(G+1): for k in range(B+1): if i>0 and j>0 and k>0: dp[i][j][k] = max(dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1], dp[i - 1]",cubic,"['dp', 'greedy', 'sortings']",2000
"r,g,b=map(int,input().split()) R=list(map(int,input().split())) R.sort() G=list(map(int,input().split())) G.sort() B=list(map(int,input().split())) B.sort() dp=[[[0]*(b+1) for i in range(g+1)] for j in range(r+1)] for i in range(r+1): for j in range(g+1): for k in range(b+1): if i<r and j<g: dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j]) if i<r and k<b: dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k]) if j<g and k<b: dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k]) print(dp[r][g][b])",cubic,"['dp', 'greedy', 'sortings']",520
"import sys input = sys.stdin.readline rr, gg, bb = map(int, input().split()) inf = 114514 r = list(map(int, input().split())) + [inf] g = list(map(int, input().split())) + [inf] b = list(map(int, input().split())) + [inf] r.sort(reverse = True) g.sort(reverse = True) b.sort(reverse = True) dp = [] for _ in range(rr + 1): dp.append([[0] * (bb + 1) for _ in range(gg + 1)]) ans = 0 for i in range(rr + 1): ri = r[i] for j in range(gg + 1): gj = g[j] for k in range(bb + 1): bk = b[k] if (i + j + k) % 2: continue dpijk = 0 if i > 0 and j > 0: dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk) if j > 0 and k > 0: dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk) if k > 0 and i > 0: dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk) dp[i][j][k] = dpijk if ans < dpijk: ans = dpijk print(ans)",cubic,"['dp', 'greedy', 'sortings']",791
"n = list(map(int, input().split())) u = [] u.append(list(map(int, input().split()))) u.append(list(map(int, input().split()))) u.append(list(map(int, input().split()))) u[0].sort(reverse=True) u[1].sort(reverse=True) u[2].sort(reverse=True) res = 0 dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)] for i in range(n[0]+1): for j in range(n[1]+1): for k in range(n[2]+1): if i<n[0] and j<n[1]: dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j]) if j<n[1] and k<n[2]: dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k]) if i<n[0] and k<n[2]: dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k]) res = max(x for u1 in dp for u2 in u1 for x in u2) print(res)",cubic,"['dp', 'greedy', 'sortings']",726
"n = list(map(int, input().split())) u = [] u.append(list(map(int, input().split()))) u.append(list(map(int, input().split()))) u.append(list(map(int, input().split()))) u[0].sort(reverse=True) u[1].sort(reverse=True) u[2].sort(reverse=True) res = 0 dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)] for i in range(n[0]+1): for j in range(n[1]+1): for k in range(n[2]+1): x0 = (dp[i-1][j-1][k] + u[0][i-1]*u[1][j-1]) if i and j else 0 x1 = (dp[i][j-1][k-1] + u[1][j-1]*u[2][k-1]) if j and k else 0 x2 = (dp[i-1][j][k-1] + u[0][i-1]*u[2][k-1]) if i and k else 0 dp[i][j][k] = max(x0, x1, x2) res = max(res, dp[i][j][k]) print(res)",cubic,"['dp', 'greedy', 'sortings']",646
"n = [int(x) for x in input().split()] a = [] for i in range(3): a.append([int(x) for x in input().split()]) a[i].sort(reverse=True) dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)] ans = 0 for i in range(n[0] + 1): for j in range(n[1] + 1): for k in range(n[2] + 1): if i < n[0] and j < n[1]: dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j]) if i < n[0] and k < n[2]: dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k]) if j < n[1] and k < n[2]: dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",662
"n, m, q = map(int, input().split()) a = sorted(map(int, input().split()), reverse=True) b = sorted(map(int, input().split()), reverse=True) c = sorted(map(int, input().split()), reverse=True) dp = [[[0] * 201 for _ in range(201)] for _ in range(201)] for ijk in range(n + m + q + 1): for i in range(min(n + 1, ijk + 1)): for j in range(min(m + 1, ijk - i + 1)): k = ijk - i - j if k < 0 or k > q: continue if i + 1 <= n: dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k]) if j + 1 <= m: dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k]) if k + 1 <= q: dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k]) if i + 1 <= n and j + 1 <= m: dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j]) if i + 1 <= n and k + 1 <= q: dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k]) if j + 1 <= m and k + 1 <= q: dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k]) print(dp[n][m][q])",cubic,"['dp', 'greedy', 'sortings']",937
"r, g, b = map(int, input().split()) red = list(map(int, input().split())) green = list(map(int, input().split())) blue = list(map(int, input().split())) red.sort() green.sort() blue.sort() red = red[::-1] green = green[::-1] blue = blue[::-1] dp = [] for i in range(r + 1): temp = [[0] * (b + 1) for j in range(g + 1)] dp.append(temp) answer = 0 for i in range(0, r + 1): for j in range(0, g + 1): for k in range(0, b + 1): if i > 0 and j > 0: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + red[i - 1] * green[j - 1]) if i > 0 and k > 0: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + red[i - 1] * blue[k - 1]) if j > 0 and k > 0: dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + green[j - 1] * blue[k - 1]) answer = max(answer, dp[i][j][k]) print(answer)",cubic,"['dp', 'greedy', 'sortings']",771
"import sys sys.setrecursionlimit(10 ** 5) int1 = lambda x: int(x) - 1 p2D = lambda x: print(*x, sep=""\n"") def II(): return int(sys.stdin.readline()) def MI(): return map(int, sys.stdin.readline().split()) def LI(): return list(map(int, sys.stdin.readline().split())) def LLI(rows_number): return [LI() for _ in range(rows_number)] def SI(): return sys.stdin.readline()[:-1] rn,gn,bn=MI() rr=LI() gg=LI() bb=LI() rr.sort(reverse=True) gg.sort(reverse=True) bb.sort(reverse=True) dp=[[[-1]*(bn+1) for _ in range(gn+1)] for _ in range(rn+1)] dp[0][0][0]=0 ans=0 for i in range(rn+1): for j in range(gn+1): for k in range(bn+1): pre=dp[i][j][k] if pre==-1:continue ans=max(ans,pre) if i<rn and j<gn:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],pre+rr[i]*gg[j]) if i<rn and k<bn:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],pre+rr[i]*bb[k]) if j<gn and k<bn:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],pre+gg[j]*bb[k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",898
"R,G,B=map(int,input().split()) r=list(map(int,input().split())) g=list(map(int,input().split())) b=list(map(int,input().split())) r.sort() g.sort() b.sort() dp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)] for i in range(1,R+1): for j in range(1,G+1): dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1] for j in range(1,G+1): for k in range(1,B+1): dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1] for i in range(1,R+1): for k in range(1,B+1): dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1] for i in range(1,R+1): for j in range(1,G+1): for k in range(1,B+1): if max(r[i-1],g[j-1],b[k-1])==r[i-1]: dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1]) elif max(r[i-1],g[j-1],b[k-1])==g[j-1]: dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1]) else: dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1]) print(dp[R][G][B])",cubic,"['dp', 'greedy', 'sortings']",894
"import sys input = sys.stdin.readline import heapq R, G, B = map(int, input().split()) r = [int(item) for item in input().split()] g = [int(item) for item in input().split()] b = [int(item) for item in input().split()] r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) nr = len(r) ng = len(g) nb = len(b) dp = [[[0] * (nb+1) for _ in range(ng+1)] for _ in range(nr+1)] ans = 0 for i in range(nr + 1): for j in range(ng + 1): for k in range(nb + 1): if (i + j + k) % 2 == 1: continue if i > 0 and j > 0: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + r[i-1] * g[j-1]) if j > 0 and k > 0: dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1] + g[j-1] * b[k-1]) if i > 0 and k > 0: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1] + b[k-1] * r[i-1]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",792
"import sys input = sys.stdin.readline R,G,B = map(int,input().split()) r = list(map(int,input().split())) g = list(map(int,input().split())) b = list(map(int,input().split())) r.sort(reverse = True) g.sort(reverse = True) b.sort(reverse = True) r = [0] + r g = [0] + g b = [0] + b R += 1 G += 1 B += 1 dp = [[[0]*B for _ in range(G)] for __ in range(R)] res = 0 for i in range(R): for j in range(G): for k in range(B): tmp = 0 if i > 0 and j > 0: tmp = max(tmp,dp[i-1][j-1][k]+r[i]*g[j]) if i > 0 and k > 0: tmp = max(tmp,dp[i-1][j][k-1]+r[i]*b[k]) if j > 0 and k > 0: tmp = max(tmp,dp[i][j-1][k-1]+g[j]*b[k]) dp[i][j][k] = tmp res = max(res,tmp) print(res)",cubic,"['dp', 'greedy', 'sortings']",657
"r,g,b = map(int,input().split()) R = sorted([*map(int,input().split())],reverse=True) G= sorted([*map(int,input().split())],reverse=True) B = sorted([*map(int,input().split())],reverse=True) mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)] def dp(i,j,k): p = (i==r)+(j==g)+(k==b) if(p>1): return 0 if(mem[i][j][k]!=-1): return mem[i][j][k] ans = 0 if(i==r): ans = dp(i,j+1,k+1)+G[j]*B[k] return ans elif(j==g): ans = dp(i+1,j,k+1)+R[i]*B[k] elif(k==b): ans = dp(i+1,j+1,k)+R[i]*G[j] else: ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k]) mem[i][j][k] = ans return ans print(dp(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",644
"from collections import defaultdict as dd import math import sys import heapq import copy input=sys.stdin.readline def nn(): return int(input()) def li(): return list(input()) def mi(): return map(int, input().split()) def lm(): return list(map(int, input().split())) def solve(): r,g,b = mi() rs = lm() gs = lm() bs = lm() rs.sort() gs.sort() bs.sort() ans = [[[0 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)] for i in range(1,r+1): for j in range(1,g+1): ans[i][j][0]= ans[i-1][j-1][0]+rs[i-1]*gs[j-1] for i in range(r+1): for j in range(g+1): for k in range(1,b+1): new_len = bs[k-1] if i==0: i_len = 0 else: i_len = ans[i-1][j][k-1] + rs[i-1]*new_len if j==0: j_len = 0 else: j_len = ans[i][j-1][k-1] + gs[j-1]*new_len if i>0 and j>0: i_j_len = ans[i-1][j-1][k]+rs[i-1]*gs[j-1] else: i_j_len = 0 ans[i][j][k] = max(i_len, j_len, ans[i][j][k-1], i_j_len) print(ans[r][g][b]) solve()",cubic,"['dp', 'greedy', 'sortings']",902
"import sys reader = (s.rstrip() for s in sys.stdin) input = reader.__next__ sys.setrecursionlimit(200000) r, g, b = map(int, input().split()) R = list(map(int, input().split())) G = list(map(int, input().split())) B = list(map(int, input().split())) R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) dp = [[[0 for i in range(b+5)] for j in range(g+5)] for k in range(r+5)] def solve(i, j, k): x, y, z = 0, 0, 0 if dp[i][j][k]: return dp[i][j][k] if i < r and j < g: x = (R[i] * G[j]) + solve(i+1, j+1, k) if i < r and k < b: y = (R[i] * B[k]) + solve(i+1, j, k+1) if j < g and k < b: z = (G[j] * B[k]) + solve(i, j+1, k+1) mx = max([x, y, z]) dp[i][j][k] = mx return mx print(solve(0, 0, 0))",cubic,"['dp', 'greedy', 'sortings']",704
"n, m, v = map(lambda x: int(x) + 1, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) c = list(map(int, input().split())) dp = [] for i in range(n): dp.append([]) for j in range(m): dp[i].append([0] * v) a.sort(reverse=1) b.sort(reverse=1) c.sort(reverse=1) a = [0] + a b = [0] + b c = [0] + c ans = 0 for i in range(n): for j in range(m): for k in range(v): if i == j == k == 0: continue if i == j == 0 or i == k == 0 or j == k == 0: continue if i == 0: dp[i][j][k] = dp[i][j - 1][k - 1] + \ b[j] * c[k] elif j == 0: dp[i][j][k] = dp[i - 1][j][k - 1] + \ a[i] * c[k] elif k == 0: dp[i][j][k] = dp[i - 1][j - 1][k] + \ a[i] * b[j] else: dp[i][j][k] = max(dp[i - 1][j - 1][k] + a[i] * b[j], dp[i - 1][j][k - 1] + a[i] * c[k], dp[i][j - 1][k - 1] + b[j] * c[k]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",837
"import sys def input(): return sys.stdin.readline().rstrip() def input_split(): return [int(i) for i in input().split()] x, y, z = input_split() arr_x = input_split() arr_y = input_split() arr_z = input_split() x += 1 y += 1 z += 1 lengths = [x,y, z] arrs = [arr_x, arr_y, arr_z ] for a in arrs: a.sort() dp = [[[0 for k in range(z)] for j in range(y)] for i in range(x)] for i in range(1,x): for j in range(1,y): dp[i][j][0] = dp[i-1][j-1][0] + arr_x[i-1]*arr_y[j-1] for j in range(1, y): for k in range(1, z): dp[0][j][k] = dp[0][j-1][k-1] + arr_y[j-1]*arr_z[k-1] for i in range(1,x): for k in range(1,z): dp[i][0][k] = dp[i-1][0][k-1] + arr_x[i-1]*arr_z[k-1] for i in range(1, x): for j in range(1, y): for k in range(1, z): opt1 = dp[i-1][j-1][k] + arr_x[i-1]*arr_y[j-1] opt2 = dp[i][j-1][k-1] + arr_y[j-1]*arr_z[k-1] opt3 = dp[i-1][j][k-1] + arr_x[i-1]*arr_z[k-1] dp[i][j][k] = max(opt1, opt2, opt3) ans = dp[x-1][y-1][z-1] print(ans)",cubic,"['dp', 'greedy', 'sortings']",939
"R,G,B = list(map(int, input().split())) r = sorted(list(map(int, input().split())), reverse =True) g = sorted(list(map(int, input().split())), reverse =True) b = sorted(list(map(int, input().split())), reverse =True) def f(x,y,z): m1 = 0 m2 = 0 m3 = 0 if(x<R and y<G): if(dpt[x+1][y+1][z]==-1): dpt[x+1][y+1][z] = f(x+1,y+1,z) m1 = r[x]*g[y] + dpt[x+1][y+1][z] if(y<G and z<B): if(dpt[x][y+1][z+1]==-1): dpt[x][y+1][z+1] = f(x,y+1,z+1) m2 = g[y]*b[z] + dpt[x][y+1][z+1] if(z<B and x<R): if(dpt[x+1][y][z+1]==-1): dpt[x+1][y][z+1] = f(x+1,y,z+1) m3 = r[x]*b[z] + dpt[x+1][y][z+1] dpt[x][y][z] = max(m1,m2,m3) return dpt[x][y][z] dpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)] print(f(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",716
"import sys input = sys.stdin.readline a,b,c = list(map(int,input().split())) x = list(map(int,input().split())) y = list(map(int,input().split())) z = list(map(int,input().split())) x.sort(reverse=True) y.sort(reverse=True) z.sort(reverse=True) a+=1 b+=1 c+=1 x = [0] + x y = [0] + y z = [0] + z tmp = [[0]*c for _ in range(b)] best = [tmp for _ in range(a)] ans = 0 for i in range(a): for j in range(b): for k in range(c): if (i+j+k) % 2 == 0: aa,bb,cc = 0,0,0 if i>0 and j>0: aa = best[i-1][j-1][k] + x[i] * y[j] if i>0 and k>0: bb = best[i-1][j][k-1] + x[i] * z[k] if j>0 and k>0: cc = best[i][j-1][k-1] + y[j] * z[k] best[i][j][k] = max(aa,bb,cc) ans = max(ans, best[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",691
"from random import randint mod = 10**9 + 7 d = {} n, m, l = map(int, input().split()) a = list(map(int, input().split())) b = list(map(int, input().split())) c = list(map(int, input().split())) def go(i, j, k): val = i * 40401 + j * 201 + k ret = 0 if val in d: return d[val] elif i < n and j < m and k < l: ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1)) elif i < n and j < m: ret = a[i] * b[j] + go(i + 1, j + 1, k) elif j < m and k < l: ret = b[j] * c[k] + go(i, j + 1, k + 1) elif k < l and i < n: ret = c[k] * a[i] + go(i + 1, j, k + 1) d[val] = ret return ret a.sort(reverse = True) b.sort(reverse = True) c.sort(reverse = True) print(go(0, 0, 0))",cubic,"['dp', 'greedy', 'sortings']",720
"r,g,b = map(int,input().split()) rs = list(map(int,input().split())) gs = list(map(int,input().split())) bs = list(map(int,input().split())) rs.sort() gs.sort() bs.sort() rs.reverse() gs.reverse() bs.reverse() dp = [[[0]*201 for x in range(201)] for y in range(201)] for i in range(min(r,g)+1): for j in range(min(g,b)+1): for k in range(min(b,r)+1): options = [] if i == 0: pass elif i+k-1 < r and i+j-1 < g: options.append(dp[i-1][j][k] + rs[i+k-1]*gs[i+j-1]) else: options.append(dp[i-1][j][k]) if j == 0: pass elif i+j-1 < g and j+k-1 < b: options.append(dp[i][j-1][k] + gs[i+j-1]*bs[j+k-1]) else: options.append(dp[i][j-1][k]) if k == 0: pass elif j+k-1 < b and i+k-1 < r: options.append(dp[i][j][k-1] + bs[j+k-1]*rs[i+k-1]) else: options.append(dp[i][j][k-1]) if len(options) == 0: continue dp[i][j][k] = max(options) print(dp[min(r,g)][min(g,b)][min(r,b)])",cubic,"['dp', 'greedy', 'sortings']",863
"r,g,b = list(map(int,input().split())) dp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ] ra = sorted(list(map(int,input().split())),reverse=True) ga = sorted(list(map(int,input().split())),reverse=True) ba = sorted(list(map(int,input().split())),reverse=True) def solve(i,j,k) : if dp[i][j][k] != -1 : return dp[i][j][k] if i==r : if j==g or k==b : return 0 dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1) elif j==g : if i==r or k==b: return 0 dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1) elif k==b : if j==g or i==r: return 0 dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k) else : dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1)) return dp[i][j][k] print(solve(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",746
"import io import os from collections import Counter, defaultdict, deque def solveBFS(NR, NG, NB, R, G, B): def pack(i, j, k): return i * 256 * 256 + j * 256 + k def unpack(ijk): i, jk = divmod(ijk, 256 * 256) j, k = divmod(jk, 256) return i, j, k R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) dp = [0 for i in range(256 ** 3)] q = deque([0]) while q: ijk = q.popleft() d = dp[ijk] i, j, k = unpack(ijk) if i < NR: r = R[i] if j < NG: g = G[j] if k < NB: b = B[k] if i + 1 <= NR and j + 1 <= NG: rg = pack(i + 1, j + 1, k) dp[rg] = max(dp[rg], r * g + d) q.append(rg) if i + 1 <= NR and k + 1 <= NB: rb = pack(i + 1, j, k + 1) dp[rb] = max(dp[rb], r * b + d) q.append(rb) if j + 1 <= NG and k + 1 <= NB: gb = pack(i, j + 1, k + 1) dp[gb] = max(dp[gb], g * b + d) q.append(gb) return max(dp) def solve(NR, NG, NB, R, G, B): assert NR == len(R) R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) R += [0] G += [0] B += [0] NR1 = NR + 2 NG1 = NG + 2 NB1 = NB + 2 dp = [0 for i in range((NR1) * (NG1) * (NB1))] def pack(i, j, k): return i * NG1 * NB1 + j * NB1 + k inf = float(""inf"") for i in range(NR + 1): for j in range(NG + 1): dp[pack(i, j, -1)] = -inf for i in range(NR + 1): for k in range(NB + 1): dp[pack(i, -1, k)] = -inf for j in range(NG + 1): for k in range(NB + 1): dp[pack(-1, j, k)] = -inf for l in range(2, NR + NG + NB + 1, 2): for j in range(NG + 1): for k in range(NB + 1): i = l - j - k if i < 0 or i > NR: continue r = R[i - 1] g = G[j - 1] b = B[k - 1] dp[pack(i, j, k)] = max( r * g + dp[pack(i - 1, j - 1, k)], r * b + dp[pack(i - 1, j, k - 1)], b * g + dp[pack(i, j - 1, k - 1)], ) return max(dp) if False: import random random.seed() N = 5 for t in range(100): R = [random.randint(1, 10) for i in range(random.randint(1, N))] G = [random.randint(1, 10) for i in range(random.randint(1, N))] B = [random.randint(1, 10) for i in range(random.randint(1, N))] ans1 = solveBFS(len(R), len(G), len(B), R, G, B) ans2 = solve(len(R), len(G), len(B), R, G, B",cubic,"['dp', 'greedy', 'sortings']",2000
"from sys import stdin from array import array def recSolve(dp,r,g,b,rx,gx,bx, R, G, B): if rx == R: return sum(a * b for a, b in zip(g[gx:], b[bx:])) if gx == G: return sum(a * b for a, b in zip(r[rx:], b[bx:])) if bx == B: return sum(a * b for a, b in zip(g[gx:], r[rx:])) if dp[rx * G * B + gx * B + bx] != -1: return dp[rx * G * B + gx * B + bx] rg = recSolve(dp, r, g, b, rx + 1, gx + 1, bx, R, G, B) + r[rx] * g[gx] bg = recSolve(dp, r, g, b, rx, gx + 1, bx + 1, R, G, B) + b[bx] * g[gx] rb = recSolve(dp, r, g, b, rx + 1, gx, bx + 1, R, G, B) + r[rx] * b[bx] ans = max(rg, bg, rb) dp[rx * G * B + gx * B + bx] = ans return ans input = stdin.readline R, G, B = map(int, input().split()) r = sorted([*map(int, input().split())], reverse = True) g = sorted([*map(int, input().split())], reverse = True) b = sorted([*map(int, input().split())], reverse = True) dp = array('q', (-1 for x in range(R * G * B))) print(recSolve(dp, r, g, b, 0, 0, 0, R, G, B))",cubic,"['dp', 'greedy', 'sortings']",957
"R, G, B = list(map(lambda x: int(x), input().split())) r = list(map(lambda x: int(x), input().split())) g = list(map(lambda x: int(x), input().split())) b = list(map(lambda x: int(x), input().split())) def f(t): i, j, k = t return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1) max_area = [None]*((R+1)*(G+1)*(B+1)+1) def get_max_area(i, j, k): temp = f((i,j,k)) if max_area[temp] != None: return max_area[temp] x1=x2=x3=0 if i >= 0 and j>=0: x1 = get_max_area(i-1, j-1, k) + r[i]*g[j] if i >= 0 and k >= 0: x2 = get_max_area(i-1, j, k-1) + r[i]*b[k] if j >= 0 and k >= 0: x3 = get_max_area(i, j-1, k-1) + g[j]*b[k] max_area[temp] = max(x1, x2, x3) return max_area[temp] r.sort() g.sort() b.sort() print(get_max_area(R-1, G-1, B-1))",cubic,"['dp', 'greedy', 'sortings']",725
"from sys import stdin, gettrace if gettrace(): inputi = input else: def input(): return next(stdin)[:-1] def inputi(): return stdin.buffer.readline() def main(): r, g, b = map(int, inputi().split()) rr = list(sorted(int(a) for a in inputi().split())) gg = list(sorted(int(a) for a in inputi().split())) bb = list(sorted(int(a) for a in inputi().split())) dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)] res = 0 for i in range(r, -1, -1): for j in range(g, -1, -1): for k in range(b, -1, -1): if i > 0 and j > 0: dp[i-1][j-1][k] = max(dp[i-1][j-1][k], dp[i][j][k] + rr[i-1]*gg[j-1]) if i > 0 and k > 0: dp[i-1][j][k-1] = max(dp[i-1][j][k-1], dp[i][j][k] + rr[i-1]*bb[k-1]) if j > 0 and k > 0: dp[i][j-1][k-1] = max(dp[i][j-1][k-1], dp[i][j][k] + gg[j-1]*bb[k-1]) res = max(res, dp[i-1][j-1][k], dp[i-1][j][k-1] , dp[i][j-1][k-1]) print(res) if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy', 'sortings']",884
"from sys import stdin,stdout final_ans=0 R,G,B = map(int,stdin.readline().strip().split(' ')) Ra = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True) Ga = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True) Ba = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True) dparr=[[[-1 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)] dparr[1][1][0]=Ra[0]*Ga[0] dparr[1][0][1]=Ra[0]*Ba[0] dparr[0][1][1]=Ga[0]*Ba[0] final_ans=max(final_ans,dparr[1][1][0],dparr[1][0][1],dparr[0][1][1]) def add_ns(t1): global queue,Ra,Ga,Ba,dparr x,y,z=t1 if x+1<=R: if y+1<=G: if dparr[x+1][y+1][z]==-1: queue.append((x+1,y+1,z)) dparr[x+1][y+1][z]=0 if z+1<=B: if dparr[x+1][y][z+1]==-1: queue.append((x+1,y,z+1)) dparr[x+1][y][z+1]=0 if y+1<=G and z+1<=B: if dparr[x][y+1][z+1]==-1: queue.append((x,y+1,z+1)) dparr[x][y+1][z+1]=0 def store_ans(t1): global final_ans,dparr,Ra,Ga,Ba x,y,z=t1 if dparr[x-1][y-1][z]!=-1 and min(x-1,y-1,z)>=0: dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1]) if dparr[x-1][y][z-1]!=-1 and min(x-1,y,z-1)>=0: dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1]) if dparr[x][y-1][z-1]!=-1 and min(x,y-1,z-1)>=0: dparr[x][y][z] = max(dparr[x][y][z],dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1]) final_ans=max(final_ans,dparr[x][y][z]) queue=[(1,1,0),(1,0,1),(0,1,1)] add_ns(queue[0]) add_ns(queue[1]) add_ns(queue[2]) ptr=3 while ptr<len(queue): store_ans(queue[ptr]) add_ns(queue[ptr]) ptr+=1 stdout.write(str(final_ans)+""\n"")",cubic,"['dp', 'greedy', 'sortings']",1542
"def solve(i, j, k): if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0): return 0 if dp[i][j][k] != -1: return dp[i][j][k] ans = 0 if i >= 0 and j >= 0: ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k)) if i >= 0 and k >= 0: ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1)) if j >= 0 and k >= 0: ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1)) dp[i][j][k] = ans return ans a, b, c = map(int, input().split()) rs = sorted(list(map(int, input().split()))) gs = sorted(list(map(int, input().split()))) bs = sorted(list(map(int, input().split()))) dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)] print(solve(a - 1, b - 1, c - 1))",cubic,"['dp', 'greedy', 'sortings']",686
"import sys input = sys.stdin.readline r, g, b, = [int(_) for _ in input().split()] R = [int(_) for _ in input().split()] G = [int(_) for _ in input().split()] B = [int(_) for _ in input().split()] R = sorted(R, reverse=True) G = sorted(G, reverse=True) B = sorted(B, reverse=True) dp = [] for i in range(r+1): sdp = [[0]*(b+1) for _ in range(g+1)] dp.append(sdp) answer = 0 for nb_taken in range(r+g+b): if nb_taken % 2: continue for i in range(nb_taken+1): if i > r: break for j in range(nb_taken-i-b, nb_taken-i+1): if j > g: break k = nb_taken-i-j if k > b: continue if i+j < k or i+k < j or j+k < i: continue if i < r and j < g: dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + R[i]*G[j]) answer = max(answer, dp[i+1][j+1][k]) if i < r and k < b: dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + R[i]*B[k]) answer = max(answer, dp[i+1][j][k+1]) if j < g and k < b: dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + G[j]*B[k]) answer = max(answer, dp[i][j+1][k+1]) print(answer)",cubic,"['dp', 'greedy', 'sortings']",992
"from collections import defaultdict from sys import setrecursionlimit,stdin input=stdin.readline setrecursionlimit(100000) def dfs(r,g,b,rr,gg,bb): if r<0 or g<0 or b<0: return 0 x=0 y=0 z=0 if dp[r][g][b]!=-1: return dp[r][g][b] if r!=0 and g!=0: x=rr[r-1]*gg[g-1]+dfs(r-1,g-1,b,rr,gg,bb) if r!=0 and b!=0: y=rr[r-1]*bb[b-1]+dfs(r-1,g,b-1,rr,gg,bb) if b!=0 and g!=0: z=bb[b-1]*gg[g-1]+dfs(r,g-1,b-1,rr,gg,bb) dp[r][g][b]=max(x,y,z) return max(x,y,z) r,g,b=map(int,input().split()) rr=list(map(int,input().split())) gg=list(map(int,input().split())) bb=list(map(int,input().split())) rr.sort() gg.sort() bb.sort() dp=[[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)] print(dfs(r,g,b,rr,gg,bb))",cubic,"['dp', 'greedy', 'sortings']",698
"def main(): R, G, B = map( int, input().split()) Rs = list( map( int, input().split())) Gs = list( map( int, input().split())) Bs = list( map( int, input().split())) Rs.sort(reverse=True) Gs.sort(reverse=True) Bs.sort(reverse=True) dp = [[[0]*(B+1) for _ in range(G+1)] for _ in range(R+1)] ans = 0 for i in range(R+1): for j in range(G+1): for k in range(B+1): t = 0 if i > 0 and j > 0: if dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] > t: t = dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] if j > 0 and k > 0: if dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] > t: t = dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] if k > 0 and i > 0: if dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] > t: t = dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] dp[i][j][k] = t if ans < t: ans = t print(ans) if __name__ == '__main__': main()",cubic,"['dp', 'greedy', 'sortings']",748
"import sys, math import io, os from bisect import bisect_left as bl, bisect_right as br, insort from heapq import heapify, heappush, heappop from collections import defaultdict as dd, deque, Counter def data(): return sys.stdin.readline().strip() def mdata(): return list(map(int, data().split())) def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n') def out(var) : sys.stdout.write(str(var)+'\n') from decimal import Decimal from fractions import Fraction INF = float('inf') mod = int(1e9)+7 from types import GeneratorType def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc @bootstrap def recur(r,g,b): if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b: yield 0 return if dp[r][g][b]: yield dp[r][g][b] return if r>0 and g>0: dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b))) if r>0 and b>0: dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1))) if b>0 and g>0: dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1))) yield dp[r][g][b] r,g,b=mdata() R=sorted(mdata()) G=sorted(mdata()) B=sorted(mdata()) dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)] out(recur(r,g,b))",cubic,"['dp', 'greedy', 'sortings']",1368
"import sys, math import io, os from bisect import bisect_left as bl, bisect_right as br, insort from heapq import heapify, heappush, heappop from collections import defaultdict as dd, deque, Counter def data(): return sys.stdin.readline().strip() def mdata(): return list(map(int, data().split())) def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n') def out(var) : sys.stdout.write(str(var)+'\n') from decimal import Decimal from fractions import Fraction INF = float('inf') mod = int(1e9)+7 def recur(r,g,b): if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b: return 0 if dp[r][g][b]: return dp[r][g][b] if r>0 and g>0: dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+recur(r-1,g-1,b)) if r>0 and b>0: dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+recur(r-1,g,b-1)) if b>0 and g>0: dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+recur(r,g-1,b-1)) return dp[r][g][b] r,g,b=mdata() R=sorted(mdata()) G=sorted(mdata()) B=sorted(mdata()) dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)] out(recur(r,g,b))",cubic,"['dp', 'greedy', 'sortings']",998
"import heapq def read_int(): return int(input().strip()) def read_ints(): return list(map(int, input().strip().split(' '))) def solve(): R, G, B = read_ints() dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)] Rs = read_ints() Gs = read_ints() Bs = read_ints() Rs.sort(reverse=True) Gs.sort(reverse=True) Bs.sort(reverse=True) answer = 0 for r in range(R+1): for g in range(G+1): for b in range(B+1): if r > 0 and g > 0: dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1]) if g > 0 and b > 0: dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1]) if r > 0 and b > 0: dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1]) answer = max(answer, dp[r][g][b]) return answer if __name__ == '__main__': print(solve())",cubic,"['dp', 'greedy', 'sortings']",764
"from math import * from collections import * from random import * from decimal import Decimal from heapq import * from bisect import * import sys input=sys.stdin.readline sys.setrecursionlimit(10**5) def lis(): return list(map(int,input().split())) def ma(): return map(int,input().split()) def inp(): return int(input()) def st1(): return input().rstrip('\n') t=1 while(t): t-=1 r,g,b=ma() rl=lis() gl=lis() bl=lis() rl.sort() bl.sort() gl.sort() dp= [[[0]*(b+1)for i in range(g+1)] for j in range(r+1)] for i in range(r+1): for j in range(g+1): for k in range(b+1): if(i+j+k<2): continue if(i and j): dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rl[i-1]*gl[j-1]) if(j and k): dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gl[j-1]*bl[k-1]) if(i and k): dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rl[i-1]*bl[k-1]) print(dp[r][g][b])",cubic,"['dp', 'greedy', 'sortings']",830
"def read_int(): return int(raw_input().strip()) def read_ints(): return list(map(int, raw_input().strip().split(' '))) def solve(): R, G, B = read_ints() dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)] Rs = read_ints() Gs = read_ints() Bs = read_ints() Rs.sort(reverse=True) Gs.sort(reverse=True) Bs.sort(reverse=True) answer = 0 for r in range(R+1): for g in range(G+1): for b in range(B+1): if r > 0 and g > 0: dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1]) if g > 0 and b > 0: dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1]) if r > 0 and b > 0: dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1]) answer = max(answer, dp[r][g][b]) return answer if __name__ == '__main__': print(solve())",cubic,"['dp', 'greedy', 'sortings']",759
"r,g,b = list(map(int, input().split())) ls_r = sorted(list(map(int, input().split()))) ls_g = sorted(list(map(int, input().split()))) ls_b = sorted(list(map(int, input().split()))) dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)] def recursive(idx_r, idx_g, idx_b): if dp[idx_r][idx_g][idx_b] is not None: return dp[idx_r][idx_g][idx_b] res_1 = 0 res_2 = 0 res_3 = 0 if (idx_r-1) >= 0 and (idx_g-1) >= 0: res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1] if (idx_g-1) >= 0 and (idx_b-1) >= 0: res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1] if (idx_r-1) >= 0 and (idx_b-1) >= 0: res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1] dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3) return dp[idx_r][idx_g][idx_b] print(recursive(r,g,b))",cubic,"['dp', 'greedy', 'sortings']",836
"import sys,io,os,time from collections import defaultdict from collections import OrderedDict from collections import deque from itertools import combinations from itertools import permutations import bisect,math,heapq alphabet = ""abcdefghijklmnopqrstuvwxyz"" input = sys.stdin.readline def solve(): r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)] for i in range(r+1): for j in range(g+1): for k in range(b+1): if i+j+k<2:continue if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1]) if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1]) if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1]) return dp[r][g][b] print(solve())",cubic,"['dp', 'greedy', 'sortings']",866
"ri,gi,bi=map(int,input().split()) rr=sorted(list(map(int,input().split()))) gr=sorted(list(map(int,input().split()))) br=sorted(list(map(int,input().split()))) dp=[[[-1]*(bi+1) for i in range(gi+1)] for j in range(ri+1)] def area(r,g,b): if dp[r+1][g+1][b+1]!=-1: return dp[r+1][g+1][b+1] ans=0 if r>=0 and g>=0: ans=max(ans,rr[r]*gr[g]+area(r-1,g-1,b)) if r>=0 and b>=0: ans=max(ans,rr[r]*br[b]+area(r-1,g,b-1)) if b>=0 and g>=0: ans=max(ans,br[b]*gr[g]+area(r,g-1,b-1)) dp[r+1][g+1][b+1]=ans return ans print(area(ri-1,gi-1,bi-1))",cubic,"['dp', 'greedy', 'sortings']",532
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class union_find: def __init__(self, n): self.n = n self.rank = [0]*n self.parent = [int(j) for j in range(n)] def union(self,i,j): i = self.find(i) j = self.find(j) if self.rank[i] == self.rank[j]: self.parent[i] = j self.rank[j] += 1 elif self.rank[i] > self.rank[j]: self.parent[j] = i else: self.parent[i] = j def find(self, i): temp = i if self.parent[temp] != temp: self.parent[temp] = self.find(self.parent[temp]) return self.parent[temp] from math import log2, ceil from collections import deque, Counter as CC, defaultdict as dd def main(): p,q,r = [int(j) for j in input().split()] a = [int(j",cubic,"['dp', 'greedy', 'sortings']",1999
"import sys input = sys.stdin.readline MAXN = 202 def main(): R, G, B = list(map(int, input().split())) r = list(map(int, input().split())) g = list(map(int, input().split())) b = list(map(int, input().split())) r.sort() g.sort() b.sort() dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)] for i in range(1, R+1): for j in range(1, G+1): dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0] for i in range(1, R+1): for k in range(1, B+1): dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1] for j in range(1, G+1): for k in range(1, B+1): dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1] for i in range(1, R+1): for j in range(1, G+1): for k in range(1, B+1): dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1]) print(dp[R][G][B]) main()",cubic,"['dp', 'greedy', 'sortings']",782
"r,g, b = map(int,input().split()) R = sorted([*map(int,input().split())],reverse=True) G= sorted([*map(int,input().split())],reverse=True) B = sorted([*map(int,input().split())],reverse=True) mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)] def dp(i,j,k): p = (i==r)+(j==g)+(k==b) if(p>1): return 0 if(mem[i][j][k]!=-1): return mem[i][j][k] ans = 0 if(i==r): ans = dp(i,j+1,k+1)+G[j]*B[k] return ans elif(j==g): ans = dp(i+1,j,k+1)+R[i]*B[k] elif(k==b): ans = dp(i+1,j+1,k)+R[i]*G[j] else: ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k]) mem[i][j][k] = ans return ans print(dp(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",645
"r,g,b=map(int,input().split()) s1=[int(x) for x in input().split()] s2=[int(x) for x in input().split()] s3=[int(x) for x in input().split()] s1.sort() s2.sort() s3.sort() s1=s1[::-1] s2=s2[::-1] s3=s3[::-1] s1=[0]+s1 s2=[0]+s2 s3=[0]+s3 dp=[] for i in range(r+5): H=[] for j in range(g+5): h=[] for k in range(b+5): h.append(0) H.append(h) dp.append(H) for i in range(0,r+1): for j in range(0,g+1): for k in range(0,b+1): t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0 if(i-1>=0 and j-1>=0): t1 = dp[i-1][j-1][k] + (s1[i]*s2[j]) if(i-1>=0 and k-1>=0): t2 = dp[i-1][j][k-1] + (s1[i]*s3[k]) if(k-1>=0 and j-1>=0): t3 = dp[i][j-1][k-1] + (s2[j]*s3[k]) if(i-1>=0): t4 = dp[i-1][j][k] if(j-1>=0): t5 = dp[i][j-1][k] if(k-1>=0): t6 = dp[i][j][k-1] dp[i][j][k] = max(t1,t2,t3,t4,t5,t6) print(dp[r][g][b])",cubic,"['dp', 'greedy', 'sortings']",783
"r,g,b=map(int,input().split()) s1=[int(x) for x in input().split()] s2=[int(x) for x in input().split()] s3=[int(x) for x in input().split()] s1.sort() s2.sort() s3.sort() s1=s1[::-1] s2=s2[::-1] s3=s3[::-1] s1=[0]+s1 s2=[0]+s2 s3=[0]+s3 dp=[] for i in range(r+5): H=[] for j in range(g+5): h=[] for k in range(b+5): h.append(0) H.append(h) dp.append(H) for i in range(0,r+1): for j in range(0,g+1): for k in range(0,b+1): t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0 if(i-1>=0 and j-1>=0): t1 = dp[i-1][j-1][k] + (s1[i]*s2[j]) if(i-1>=0 and k-1>=0): t2 = dp[i-1][j][k-1] + (s1[i]*s3[k]) if(k-1>=0 and j-1>=0): t3 = dp[i][j-1][k-1] + (s2[j]*s3[k]) if(i-1>=0): t4 = dp[i-1][j][k] if(j-1>=0): t5 = dp[i][j-1][k] if(k-1>=0): t6 = dp[i][j][k-1] dp[i][j][k] = max(t1,t2,t3,t4,t5,t6) print(dp[r][g][b])",cubic,"['dp', 'greedy', 'sortings']",783
"from sys import stdin inp = lambda : stdin.readline().strip() nr, ng, nb = [int(x) for x in inp().split()] r = [int(x) for x in inp().split()] g = [int(x) for x in inp().split()] b = [int(x) for x in inp().split()] r.sort() g.sort() b.sort() dp = [[[0 for _ in range(201)] for _ in range(201)] for _ in range(201)] for i in range(nr+1): for j in range(ng+1): for k in range(nb+1): if i and j: dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]); if i and k: dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]); if j and k: dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]); print(dp[nr][ng][nb])",cubic,"['dp', 'greedy', 'sortings']",621
"def solve(x,y,z): global r,g,b,ans if (x > r - 1 and y > g - 1) or (x > r - 1 and z > b - 1) or (y > g - 1 and z > b - 1): return 0 if memo[x][y][z] != -1: return memo[x][y][z] mx = 0 if x < r and y < g: mx = max(mx,ra[x]*ga[y] + solve(x+1,y+1,z)) if x < r and z < b: mx = max(mx,ra[x]*ba[z] + solve(x+1,y,z+1)) if y < g and z < b: mx = max(mx,ga[y]*ba[z] + solve(x,y+1,z+1)) ans = max(ans,mx) memo[x][y][z] = mx return mx r,g,b = map(int,input().split()) ra = sorted(list(map(int,input().split())),reverse = True) ga = sorted(list(map(int,input().split())),reverse = True) ba = sorted(list(map(int,input().split())),reverse = True) memo = [[[-1 for k in range(205)] for i in range(205)] for j in range(205)] ans = 0 solve(0,0,0) print(ans)",cubic,"['dp', 'greedy', 'sortings']",740
"r,g,b = list(map(int, input().split())) ls_r = sorted(list(map(int, input().split()))) ls_g = sorted(list(map(int, input().split()))) ls_b = sorted(list(map(int, input().split()))) dp = [[[-1 for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)] def recursive(idx_r, idx_g, idx_b): if dp[idx_r][idx_g][idx_b] != -1: return dp[idx_r][idx_g][idx_b] res_1 = 0 res_2 = 0 res_3 = 0 if (idx_r-1) >= 0 and (idx_g-1) >= 0: res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1] if (idx_g-1) >= 0 and (idx_b-1) >= 0: res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1] if (idx_r-1) >= 0 and (idx_b-1) >= 0: res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1] dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3) return dp[idx_r][idx_g][idx_b] print(recursive(r,g,b))",cubic,"['dp', 'greedy', 'sortings']",828
"r,g,b = list(map(int, input().split())) ls_r = sorted(list(map(int, input().split()))) ls_g = sorted(list(map(int, input().split()))) ls_b = sorted(list(map(int, input().split()))) dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)] for i in range(r+1): dp[i][0][0] = 0 for i in range(g+1): dp[0][i][0] = 0 for i in range(b+1): dp[0][0][i] = 0 dp[1][1][0] = ls_r[0] * ls_g[0] dp[0][1][1] = ls_g[0] * ls_b[0] dp[1][0][1] = ls_r[0] * ls_b[0] for i in range(r+1): for j in range(g+1): for k in range(b+1): res1 = 0 res2 = 0 res3 = 0 if i-1>=0 and j-1>=0: res1 += dp[i-1][j-1][k] + ls_r[i-1] * ls_g[j-1] if i-1>=0 and k-1>=0: res2 += dp[i-1][j][k-1] + ls_r[i-1] * ls_b[k-1] if j-1>=0 and k-1>=0: res3 += dp[i][j-1][k-1] + ls_g[j-1] * ls_b[k-1] dp[i][j][k] = max(res1,res2,res3) print(dp[r][g][b])",cubic,"['dp', 'greedy', 'sortings']",814
"R,G,B=map(int,input().split()) r=list(map(int,input().split())) g=list(map(int,input().split())) b=list(map(int,input().split())) r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) dp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)] def recurser(x,y,z): if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R): return 0 if dp[x][y][z]!=-1: return dp[x][y][z] maxi=0 if x<R and y<G: maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z)) if y<G and z<B: maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1)) if z<B and x<R: maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1)) dp[x][y][z]=maxi return maxi print(recurser(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",633
"nr, ng, nb = map(int, input().split()) r = sorted([int(i) for i in input().split()]) g = sorted([int(i) for i in input().split()]) b = sorted([int(i) for i in input().split()]) dp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)] for i in range(nr + 1): for j in range(ng + 1): for k in range(nb + 1): val = 0 if i - 1 >= 0 and j - 1 >= 0: val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k]) if i - 1 >= 0 and k - 1 >= 0: val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1]) if j - 1 >= 0 and k - 1 >= 0: val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1]) dp[i][j][k] = val print(dp[nr][ng][nb])",cubic,"['dp', 'greedy', 'sortings']",642
"import os import heapq import sys, threading import math import bisect import operator from collections import defaultdict sys.setrecursionlimit(10 ** 5) from io import BytesIO, IOBase def gcd(a, b): if b == 0: return a else: return gcd(b, a % b) def power(x, p, m): res = 1 while p: if p & 1: res = (res * x) % m x = (x * x) % m p >>= 1 return res def inar(): return [int(k) for k in input().split()] def lcm(num1, num2): return (num1 * num2) // gcd(num1, num2) rr=0 gg=0 bb=0 dp=[] def func(x,y,z,red,green,blue): if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb): return 0 if dp[x][y][z]!=-1: return dp[x][y][z] take=0 if x<rr and y<gg: take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue)) if y<gg and z<bb: take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue)) if x<rr and z<bb: take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue)) dp[x][y][z]=take return take def main(): global rr,gg,bb,dp for i in range(202): temp=[] for j in range(202): lis=[] for k in range(202): lis.append(-1) temp.append(lis) dp.append(temp) rr, gg, bb = map(int, input().split()) red = inar() green = inar() blue = inar() red.sort(reverse=True) green.sort(reverse=True) blue.sort(reverse=True) print(func(0,0,0,red,green,blue)) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 retu",cubic,"['dp', 'greedy', 'sortings']",2000
"R, G, B = map(int, input().split()) r = list(map(int, input().split())) g = list(map(int, input().split())) b = list(map(int, input().split())) r.sort() g.sort() b.sort() dp = [[[0]*202 for i in range(202)] for j in range(202)] for i in range(R+1): for j in range(G+1): for k in range(B+1): if i and j: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]) if i and k: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]) if k and j: dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]) ans = 0 for i in dp: for j in i: ans = max(ans, max(j)) print(ans)",cubic,"['dp', 'greedy', 'sortings']",579
"R, G, B = map(int, input().split()) r = list(map(int, input().split())) g = list(map(int, input().split())) b = list(map(int, input().split())) r.sort() g.sort() b.sort() dp = [[[0]*202 for i in range(202)] for j in range(202)] for i in range(R+1): for j in range(G+1): for k in range(B+1): if i and j: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]) if i and k: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]) if k and j: dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]) print(dp[R][G][B])",cubic,"['dp', 'greedy', 'sortings']",531
"def solve(i, j, k): if dp[i][j][k]!=-1: return dp[i][j][k] call = 0 if i>0 and j>0: call = max(call, R[i]*G[j]+solve(i-1, j-1, k)) if j>0 and k>0: call = max(call, G[j]*B[k]+solve(i, j-1, k-1)) if k>0 and i>0: call = max(call, B[k]*R[i]+solve(i-1, j, k-1)) dp[i][j][k] = call return call nr, ng, nb = map(int,input().split()) R = [0]+list(map(int,input().split())) G = [0]+list(map(int,input().split())) B = [0]+list(map(int,input().split())) R.sort() G.sort() B.sort() dp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)] ans = solve(nr, ng, nb) print(ans)",cubic,"['dp', 'greedy', 'sortings']",567
"r, g, b = map(int, input().split(' ')) R = list(map(int, input().split(' '))) G = list(map(int, input().split(' '))) B = list(map(int, input().split(' '))) dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)] R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) R.insert(0, 0) G.insert(0, 0) B.insert(0, 0) dp[0][0][0], ans = 0, 0 for i in range(0, r+1): for j in range(0, g+1): for k in range(0, b+1): if i == 0 and j == 0 and k == 0:continue if i and j and dp[i - 1][j - 1][k] != -1: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j]) if k and j and dp[i][j - 1][k - 1] != -1: dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j]) if i and k and dp[i - 1][j][k - 1] != -1: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k]) ans = max(ans,dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",836
"import io import os import sys input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline def prdbg(*args, **kwargs): print(*args, **kwargs) pass def get_str(): return input().decode().strip() def rint(): return map(int, input().split()) def oint(): return int(input()) def valid(i1,i2,i3): if (i1+i2+i3)%2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2\ or i2 > i1 + i3 or i1 > i2 + i3: return False return True def dfs(i1,i2,i3): if (i1 + i2 + i3) % 2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2 \ or i2 > i1 + i3 or i1 > i2 + i3: return -2 if dp[i1][i2][i3] != -1: return dp[i1][i2][i3] ret1 = dfs(i1-1, i2-1, i3) if ret1 >= 0 : ret1 += a1[i1]*a2[i2] ret2 = dfs(i1-1, i2, i3-1) if ret2 >= 0: ret2 += a1[i1]*a3[i3] ret3 = dfs(i1, i2-1, i3-1) if ret3 >= 0: ret3 += a2[i2]*a3[i3] ret = max(ret1, ret2, ret3) dp[i1][i2][i3] = ret return ret n1, n2, n3 = rint() a1, a2, a3 = list(rint()), list(rint()), list(rint()) a1.sort(reverse=True) a2.sort(reverse=True) a3.sort(reverse=True) a1 = [0] + a1 a2 = [0] + a2 a3 = [0] + a3 n1 += 1 n2 += 1 n3 += 1 dp = [[[-1 for i3 in range(n3)] for i2 in range(n2)] for i1 in range(n1)] dp[1][1][0] = a1[1]*a2[1] dp[1][0][1] = a1[1]*a3[1] dp[0][1][1] = a2[1]*a3[1] dp[0][0][0] = -2 for i1 in range(n1): for i2 in range(n2): for i3 in range(n3): dfs(i1, i2, i3) ans = -1 for i1 in range(n1): for i2 in range(n2): for i3 in range(n3): ans = max(ans, dp[i1][i2][i3]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",1413
"def solve(): r,g,b=map(int,input().split()) R=list(map(int,input().split())) G=list(map(int,input().split())) B=list(map(int,input().split())) R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) dp=[[[0]*(b+1) for _ in range(g+1)]for _ in range(r+1)] for i in range(r+1): for j in range(g+1): for k in range(b+1): if i<r and j<g: dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j]) if i<r and k<b: dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k]) if j<g and k<b: dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+B[k]*G[j]) ans=0 for i in range(r+1): for j in range(g+1): for k in range(b+1): ans=max(ans,dp[i][j][k]) return ans print(solve())",cubic,"['dp', 'greedy', 'sortings']",669
"import sys input=sys.stdin.readline def f(r,g,b,n,m,k): if((n>=1 and m>=1) or (k>=1 and m>=1) or(n>=1 and k>=1)): a1=mat[n][m][k] if(a1!=-1): return a1 else: a1=0 b1=0 c1=0 if(n>=1 and m>=1): a1=r[n-1]*g[m-1] + f(r,g,b,n-1,m-1,k) if(k>=1 and m>=1): b1=b[k-1]*g[m-1] + f(r,g,b,n,m-1,k-1) if(n>=1 and k>=1): c1=r[n-1]*b[k-1] + f(r,g,b,n-1,m,k-1) mat[n][m][k]=max(a1,b1) mat[n][m][k]=max(mat[n][m][k],c1) return mat[n][m][k] return 0 n,m,k=list(map(int,input().split("" ""))) mat=[[[-1 for i in range(k+1)] for j in range(m+1)]for z in range(n+1)] r=list(map(int,input().split("" ""))) g=list(map(int,input().split("" ""))) b=list(map(int,input().split("" ""))) r.sort() g.sort() b.sort() d={} print(f(r,g,b,n,m,k))",cubic,"['dp', 'greedy', 'sortings']",704
"from sys import stdin rints = lambda: [int(x) for x in stdin.readline().split()] def dp(r1, g1, b1): if mem[r1][g1][b1] != -1: return mem[r1][g1][b1] v1, v2, v3 = 0, 0, 0 if r1 < r: if g1 < g: v1 = (ar[r1] * ag[g1]) + dp(r1 + 1, g1 + 1, b1) if b1 < b: v2 = (ar[r1] * ab[b1]) + dp(r1 + 1, g1, b1 + 1) if g1 < g and b1 < b: v3 = (ag[g1] * ab[b1]) + dp(r1, g1 + 1, b1 + 1) mem[r1][g1][b1] = max(v1, v2, v3) return mem[r1][g1][b1] r, g, b = rints() ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)] mem = [[[-1 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)] print(dp(0, 0, 0))",cubic,"['dp', 'greedy', 'sortings']",607
"a,b,c=list(map(int,input().split())) R=list(map(int,input().split())) G=list(map(int,input().split())) B=list(map(int,input().split())) dp=[[[0 for i in range(201)] for j in range(201)] for k in range(201)] R.sort() G.sort() B.sort() for i in range(len(R)+1): for j in range(len(G)+1): for k in range(len(B)+1): if(i and j): dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1]) if(j and k): dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1]) if(i and k): dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1]) print(dp[len(R)][len(G)][len(B)])",cubic,"['dp', 'greedy', 'sortings']",561
"r,g,b = map(int,input().split()) l1 = list(map(int,input().split())) l2 = list(map(int,input().split())) l3 = list(map(int,input().split())) l1.sort(reverse=True) l2.sort(reverse=True) l3.sort(reverse=True) dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)] ans = 0 for i in range(r+1): for j in range(g+1): for k in range(b+1): if i == 0 and j == 0: dp[i][j][k] = 0 if j == 0 and k == 0: dp[i][j][k] = 0 if i == 0 and k == 0: dp[i][j][k] = 0 if i>0 and j>0 and k>0: dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1]) else: if i>0 and j>0: dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k] elif i>0 and k>0: dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1] elif j>0 and k>0: dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1] ans = max(ans,dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",856
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") r,g,b = map(int,input().split()) l1 = list(map(int,input().split())) l2 = list(map(int,input().split())) l3 = list(map(int,input().split())) l1.sort(reverse=True) l2.sort(reverse=True) l3.sort(reverse=True) dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)] ans = 0 for i in range(r+1): for j in range(g+1): for k in range(b+1): if i == 0 and j == 0: dp[i][j][k] = 0 if j == 0 and k == 0: dp[i][j][k] = 0 if i == 0 and k == 0: dp[i][j][k] = 0 if i>0 and j>0 and k>0: dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[",cubic,"['dp', 'greedy', 'sortings']",2000
"import os import sys import math import heapq from decimal import * from io import BytesIO, IOBase from collections import defaultdict, deque def r(): return int(input()) def rm(): return map(int,input().split()) def rl(): return list(map(int,input().split())) r,g,b = rm() R = rl() G = rl() B = rl() R.sort() G.sort() B.sort() dp = [[[0]*(b+1) for j in range(g+1)] for i in range(r+1)] for i in range(r+1): for j in range(g+1): for k in range(b+1): if i and j: dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+R[i-1]*G[j-1]) if j and k: dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+G[j-1]*B[k-1]) if k and i: dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+B[k-1]*R[i-1]) print(dp[r][g][b])",cubic,"['dp', 'greedy', 'sortings']",684
"import sys;input = sys.stdin.readline inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()] r,g,b = ip() R = [0]+ip() G = [0]+ip() B = [0]+ip() R.sort() G.sort() B.sort() dp = [[[0]*201 for i in range(201)] for j in range(201)] for i in range(r+1): for j in range(g+1): for k in range(b+1): x = dp[i-1][j-1][k] + R[i]*G[j] if i*j else 0 y = dp[i][j-1][k-1] + G[j]*B[k] if j*k else 0 z = dp[i-1][j][k-1] + R[i]*B[k] if i*k else 0 dp[i][j][k] = max(dp[i][j][k],x,y,z) print(dp[r][g][b])",cubic,"['dp', 'greedy', 'sortings']",502
"import sys import math from math import * from collections import Counter,defaultdict from io import BytesIO, IOBase from collections import deque def rec(i,j,k): if (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl): return 0 if dp[i][j][k] != -1: return dp[i][j][k] else: x = r[i]*b[j] y = b[j]*g[k] z = r[i] * g[k] if x>0: x += rec(i+1,j+1,k) if y>0: y += rec(i,j+1,k+1) if z>0: z += rec(i+1,j,k+1) dp[i][j][k] = max(x,y,z) return dp[i][j][k] def main(): global r,g,b,rl,bl,gl,dp rl,bl,gl = list(map(int, input().split())) r = list(map(int, input().split())) + [0] b = list(map(int, input().split())) + [0] g = list(map(int, input().split())) + [0] cnt =3 i =j = k = 0 ans = 0 dp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)] r.sort(reverse = True) b.sort(reverse = True) g.sort(reverse = True) print(rec(i,j,k)) main()",cubic,"['dp', 'greedy', 'sortings']",868
"import sys,bisect,string,math,time,functools,random,fractions from heapq import heappush,heappop,heapify from collections import deque,defaultdict,Counter from itertools import permutations,combinations,groupby rep=range;R=range def Golf():n,*t=map(int,open(0).read().split()) def I():return int(input()) def S_():return input() def IS():return input().split() def LS():return [i for i in input().split()] def MI():return map(int,input().split()) def LI():return [int(i) for i in input().split()] def LI_():return [int(i)-1 for i in input().split()] def NI(n):return [int(input()) for i in range(n)] def NI_(n):return [int(input())-1 for i in range(n)] def StoLI():return [ord(i)-97 for i in input()] def ItoS(n):return chr(n+97) def LtoS(ls):return ''.join([chr(i+97) for i in ls]) def RA():return map(int,open(0).read().split()) def RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)] def RI(a=1,b=10):return random.randint(a,b) def Rtest(T): case,err=0,0 for i in range(T): inp=INP() a1,ls=naive(*inp) a2=solve(*inp) if a1!=a2: print((a1,a2),inp) err+=1 case+=1 print('Tested',case,'case with',err,'errors') def GI(V,E,ls=None,Directed=False,index=1): org_inp=[];g=[[] for i in range(V)] FromStdin=True if ls==None else False for i in range(E): if FromStdin: inp=LI() org_inp.append(inp) else: inp=ls[i] if len(inp)==2: a,b=inp;c=1 else: a,b,c=inp if index==1:a-=1;b-=1 aa=(a,c);bb=(b,c);g[a].append(bb) if not Directed:g[b].append(aa) return g,org_inp def GGI(h,w,search=None,replacement_of_found='.',mp_def={' mp=[boundary]*(w+2);found={} for i in R(h): s=input() for char in search: if char in s: found[char]=((i+1)*(w+2)+s.index(char)+1) mp_def[char]=mp_def[replacement_of_found] mp+=[boundary]+[mp_def[j] for j in s]+[boundary] mp+=[boundary]*(w+2) return h+2,w+2,mp,found def TI(n):return GI(n,n-1) def accum(ls): rt=[0] for i in ls:rt+=[rt[-1]+i] return rt def bit_combination(n,base=2): rt=[] for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s] return rt def gc",cubic,"['dp', 'greedy', 'sortings']",2000
"def solve(r, g, b, rs, gs, bs): rs.sort(reverse=True) gs.sort(reverse=True) bs.sort(reverse=True) dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)] sol = 0 for ri in range(r+1): for gi in range(g+1): for bi in range(b+1): if ri < r and gi < g: dp[ri+1][gi+1][bi] = max(dp[ri+1][gi+1][bi], rs[ri]*gs[gi] + dp[ri][gi][bi]) if ri < r and bi < b: dp[ri+1][gi][bi+1] = max(dp[ri+1][gi][bi+1], rs[ri]*bs[bi] + dp[ri][gi][bi]) if gi < g and bi < b: dp[ri][gi+1][bi+1] = max(dp[ri][gi+1][bi+1], gs[gi]*bs[bi] + dp[ri][gi][bi]) sol = max(sol, dp[ri][gi][bi]) return sol r, g, b = map(int, input().split()) rs = list(map(int, input().split())) gs = list(map(int, input().split())) bs = list(map(int, input().split())) print(solve(r, g, b, rs, gs, bs))",cubic,"['dp', 'greedy', 'sortings']",750
"import sys as _sys _sys.setrecursionlimit(2**14) _cache = dict() class _SortedSeqs: def __init__(self, seqs): self.seqs = tuple(tuple(sorted(seq)) for seq in seqs) def __hash__(self): return id(self) def compute_max_area(r_seq, g_seq, b_seq): sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq)) seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs)) return _compute_max_area(sorted_seqs_obj, seqs_sizes) def _compute_max_area(sorted_seqs_obj, seqs_sizes): cache_key = (sorted_seqs_obj, seqs_sizes) if cache_key in _cache.keys(): return _cache[cache_key] seqs = sorted_seqs_obj.seqs nonempty_seqs_n = _how_many_nonempty(seqs_sizes) if nonempty_seqs_n < 2: ab_seqs_indices_list = [] elif nonempty_seqs_n == 2: ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0] ab_seqs_indices_list = [ab_seqs_indices] else: assert nonempty_seqs_n == 3 seqs_indices_sorted_by_size = [ i for i, seq in sorted( enumerate(seqs), key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]]) ) ] ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0] ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1] ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2] max_areas_variants = [] for a_seq_index, b_seq_index in ab_seqs_indices_list: a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1] b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1] new_seqs_sizes = list(seqs_sizes) new_seqs_sizes[a_seq_index] -= 1 new_seqs_sizes[b_seq_index] -= 1 max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes)) max_area += a_seq_last * b_seq_last max_areas_variants.append(max_area) max_area = max(max_areas_variants, default=0) _cache[cache_key] = max_area return max_area def _how_many_nonempty(seqs_sizes): return len([size for size in seqs_sizes if size > 0]) def main(): r_n, g_n, b_n = map(int, input().split()) r_seq = tuple(map(int, input().split())) g_seq = tuple(map(int, input().split())) b_seq = tuple",cubic,"['dp', 'greedy', 'sortings']",2000
"import math import time from collections import defaultdict,deque,Counter from sys import stdin,stdout from bisect import bisect_left,bisect_right from queue import PriorityQueue import sys t=1 for _ in range(t): r,g,b=map(int,stdin.readline().split()) ra=list(map(int,stdin.readline().split())) ga=list(map(int,stdin.readline().split())) ba=list(map(int,stdin.readline().split())) ra.sort() ga.sort() ba.sort() dp=[[[0]*201 for _ in range(201)]for _ in range(201)] for i in range(r+1): for j in range(g+1): for k in range(b+1): if(i and j>0): dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+ra[i-1]*ga[j-1]) if(i and k>0): dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+ra[i-1]*ba[k-1]) if(k and j>0): dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+ga[j-1]*ba[k-1]) print(dp[r][g][b])",cubic,"['dp', 'greedy', 'sortings']",778
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") R,G,B=map(int,input().split()) r=sorted(list(map(int,input().split()))) g=sorted(list(map(int,input().split()))) b=sorted(list(map(int,input().split()))) dp=[[[0]*(B+1) for j in range(G+1)] for i in range(R+1)] for i in range(R+1): for j in range(G+1): for k in range(B+1): if i>0 and j>0: dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1]) if i>0 and k>0: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1]) if j>0 and k>0: dp[i][j][k] = ma",cubic,"['dp', 'greedy', 'sortings']",1999
"r, g, b = map(int, input().split()) a = [[], [], []] dp = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)] for x in range(3): a[x] = sorted([int(x) for x in input().split()]) odp = 0 for i in range(r + 1): for j in range(g + 1): for k in range(b + 1): if i < r and j < g: dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j]) if i < r and k < b: dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k]) if j < g and k < b: dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k]) odp = max(odp, dp[i][j][k]) print(odp)",cubic,"['dp', 'greedy', 'sortings']",615
"R,G,B=[int(c) for c in input().split()] ra=[int(c) for c in input().split()] ga=[int(c) for c in input().split()] ba=[int(c) for c in input().split()] ra.sort(reverse=True) ga.sort(reverse=True) ba.sort(reverse=True) dp = [[[-1 for i in range(201)]for j in range(201)]for k in range(201)] def solve(dp,r,g,b): if dp[r][g][b] !=-1: return dp[r][g][b] count= 0 for i,j in zip((r,g,b),(R,G,B)): if i == j: count+=1 if count >= 2: return 0 res = -999 if r != R and b!=B: res = max(res,ra[r]*ba[b] + solve(dp,r+1,g,b+1)) if r!=R and g != G: res = max(res,ra[r]*ga[g] + solve(dp,r+1,g+1,b)) if b!=B and g != G: res = max(res,ba[b]*ga[g] + solve(dp,r,g+1,b+1)) dp[r][g][b] = res return res print(solve(dp,0,0,0))",cubic,"['dp', 'greedy', 'sortings']",705
"from collections import deque from collections import OrderedDict import math import sys import os import threading import bisect import operator import heapq from atexit import register from io import BytesIO import io input = lambda: sys.stdin.readline().rstrip(""\r\n"") r,g,b = map(int, input().split()) a = [] for i in range(3): a.append([int(x) for x in input().split()]) a[i].sort(reverse=True) dp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)] answer = 0 for i in range(r+1): for j in range(g+1): for k in range(b+1): if i<r and j<g: dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j]) if i<r and k<b: dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k]) if j<g and k<b: dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k]) answer=max(answer, dp[i][j][k]) print(answer) sys.exit(0) class Person: def __init__(self, name, age): self.name = name self.age = age p1 = Person(""heelo"", 27) print(help(Person)) age = 26 name = 'Swaroop' print('Возрас {} -- {} лет'.format(name, age)) print(help(object))",cubic,"['dp', 'greedy', 'sortings']",1065
"import sys def dp(ri, gi, bi): if ri>r or gi>g or bi>b: return 0 if not list_memo[ri][gi][bi]==-1: return list_memo[ri][gi][bi] list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi]) return list_memo[ri][gi][bi] r, g, b = map(int, sys.stdin.readline().split()) r_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1) g_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1) b_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1) list_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)] print(dp(0, 0, 0))",cubic,"['dp', 'greedy', 'sortings']",649
"R,G,B = map(int,input().split()) r = list(map(int, input().split())) g = list(map(int, input().split())) b = list(map(int, input().split())) area = 0 r.sort(reverse=True) b.sort(reverse=True) g.sort(reverse=True) L = max(len(r),len(g),len(b)) dp = [[[0]*(B+1) for i in range(G+1)]for j in range(R+1)] tr = 0 tg = 0 tb = 0 for i in range(R+1): for j in range(G+1): for k in range(B+1): if i>0 and j>0: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]) if j>0 and k>0: dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]) if i>0 and k>0: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]) area = max(area,dp[i][j][k]) print(area)",cubic,"['dp', 'greedy', 'sortings']",659
"R,G,B = map(int,input().split()) r = list(map(int,input().split())) g = list(map(int,input().split())) b = list(map(int,input().split())) r.sort() g.sort() b.sort() dp = [] for i in range(R+1): d = [] for j in range(G+1): d.append([0]*(B+1)) dp.append(d) for i in range(R+1): for j in range(G+1): for k in range(B+1): if i+j+k<2: continue if i>0 and j>0: dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1]) if i>0 and k>0: dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+r[i-1]*b[k-1]) if j>0 and k>0: dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+g[j-1]*b[k-1]) print(dp[R][G][B])",cubic,"['dp', 'greedy', 'sortings']",588
"import sys readline = sys.stdin.buffer.readline readlines = sys.stdin.buffer.readlines ns = lambda: readline().rstrip() ni = lambda: int(readline().rstrip()) nm = lambda: map(int, readline().split()) nl = lambda: list(map(int, readline().split())) r, g, b = nm() R = nl() G = nl() B = nl() dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)] R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) R.insert(0, 0) G.insert(0, 0) B.insert(0, 0) dp[0][0][0], ans = 0, 0 for i in range(0, r+1): for j in range(0, g+1): for k in range(0, b+1): if i==0 and j==0 and k==0:continue if i and j and dp[i - 1][j - 1][k] != -1: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j]) if k and j and dp[i][j - 1][k - 1] != -1: dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j]) if i and k and dp[i - 1][j][k - 1] != -1: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",965
"def solve(rn,gn,bn,r,g,b): r = sorted(r,reverse=True) g = sorted(g, reverse=True) b = sorted(b, reverse=True) dp = [[[0 for k in range(bn+1)] for j in range(gn+1)] for i in range(rn+1)] ans = 0 for i in range(rn+1): for j in range(gn+1): for k in range(bn+1): if i < rn and j < gn: dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j]) if i < rn and k < bn: dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k]) if j < gn and k <bn: dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k]) ans = max(ans,dp[i][j][k]) print(ans) if __name__ == '__main__': rn, gn, bn = map(int,input().split()) r = list(map(int,input().split())) g = list(map(int, input().split())) b = list(map(int, input().split())) solve(rn,gn,bn,r,g,b)",cubic,"['dp', 'greedy', 'sortings']",748
"from sys import stdin rints = lambda: [int(x) for x in stdin.readline().split()] r, g, b = rints() ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)] mem = [[[0 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)] ans = 0 for r1 in range(r + 1): for g1 in range(g + 1): for b1 in range(b + 1): if r1 < r: if g1 < g: mem[r1 + 1][g1 + 1][b1] = max(mem[r1 + 1][g1 + 1][b1], (ar[r1] * ag[g1]) + mem[r1][g1][b1]) if b1 < b: mem[r1 + 1][g1][b1 + 1] = max(mem[r1 + 1][g1][b1 + 1], (ar[r1] * ab[b1]) + mem[r1][g1][b1]) if g1 < g and b1 < b: mem[r1][g1 + 1][b1 + 1] = max(mem[r1][g1 + 1][b1 + 1], (ag[g1] * ab[b1]) + mem[r1][g1][b1]) ans = max(ans, mem[r1][g1][b1]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",695
"R, G, B = map(int, input().split()) r = list(map(int, input().split())) g = list(map(int, input().split())) b = list(map(int, input().split())) r.sort() g.sort() b.sort() dp = [[[0]*202 for i in range(202)] for j in range(202)] for i in range(R+1): for j in range(G+1): for k in range(B+1): if i and j: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]) if i and k: dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]) if k and j: dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]) print(dp[R][G][B])",cubic,"['dp', 'greedy', 'sortings']",531
"r, g, b = map(int, input().split()) R = list(map(int, input().split())) G = list(map(int, input().split())) B = list(map(int, input().split())) R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) memo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)] def calc(ir, ig, ib): if memo[ir][ig][ib] != -1: return memo[ir][ig][ib] ans = 0 if ir < r and ig < g: ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig]) if ir < r and ib < b: ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib]) if ig < g and ib < b: ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib]) memo[ir][ig][ib] = ans return ans print(calc(0, 0, 0))",cubic,"['dp', 'greedy', 'sortings']",617
"R, G, B = list(map(int, input().split())) r = [int(x) for x in input().split()] r.sort(reverse=True) g = [int(x) for x in input().split()] g.sort(reverse=True) b = [int(x) for x in input().split()] b.sort(reverse=True) ans = 0 dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)] for i in range(R+1): for j in range(G+1): for k in range(B+1): if i<R and j<G: dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j]) if j<G and k<B: dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k]) if i<R and k<B: dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",641
"R, G, B = list(map(int, input().split())) r = sorted([int(x) for x in input().split()], reverse=True) g = sorted([int(x) for x in input().split()], reverse=True) b = sorted([int(x) for x in input().split()], reverse=True) ans = 0 dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)] for i in range(R+1): for j in range(G+1): for k in range(B+1): if i<R and j<G: dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j]) if j<G and k<B: dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k]) if i<R and k<B: dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",644
"R, G, B = list(map(int, input().split())) r = sorted(list(map(int, input().split())), reverse=True) g = sorted(list(map(int, input().split())), reverse=True) b = sorted(list(map(int, input().split())), reverse=True) ans = 0 dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)] for i in range(R+1): for j in range(G+1): for k in range(B+1): if i<R and j<G: dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j]) if j<G and k<B: dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k]) if i<R and k<B: dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",638
"import sys sys.setrecursionlimit(200000) input=sys.stdin.readline def solve(r,g,b,R,G,B): if (r==0 and g==0) and (r==0 and b==0) and (g==0 and b==0): return 0 if z[r][g][b]!=-1: return z[r][g][b] d,e,f=0,0,0 if r!=0 and g!=0: d=R[r-1]*G[g-1]+solve(r-1,g-1,b,R,G,B) if r!=0 and b!=0: e=R[r-1]*B[b-1]+solve(r-1,g,b-1,R,G,B) if b!=0 and g!=0: f=B[b-1]*G[g-1]+solve(r,g-1,b-1,R,G,B) z[r][g][b]=max(d,e,f) return z[r][g][b] r,g,b=map(int,input().rstrip().split()) R=sorted(map(int,input().rstrip().split())) G=sorted(map(int,input().rstrip().split())) B=sorted(map(int,input().rstrip().split())) z=[[[ -1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)] print(solve(r,g,b,R,G,B))",cubic,"['dp', 'greedy', 'sortings']",688
"import os import heapq import sys import math import operator from collections import defaultdict from io import BytesIO, IOBase def inpt(): return [int(k) for k in input().split()] def main(): n1, n2, n3 = map(int, input().split()) ar = [int(x) for x in input().split()] br = [int(x) for x in input().split()] cr = [int(x) for x in input().split()] ar.sort() br.sort() cr.sort() dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)] for i in range(n1 + 1): for j in range(n2 + 1): for k in range(n3 + 1): if (i and j): dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1])) if (i and k): dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1])) if (k and j): dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1])) print(dp[n1][n2][n3]) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline =",cubic,"['dp', 'greedy', 'sortings']",2000
"from sys import stdin, stdout, setrecursionlimit from math import gcd, ceil, sqrt from collections import Counter, deque from bisect import bisect_left, bisect_right ii1 = lambda: int(stdin.readline().strip()) is1 = lambda: stdin.readline().strip() iia = lambda: list(map(int, stdin.readline().strip().split())) isa = lambda: stdin.readline().strip().split() setrecursionlimit(100000) mod = 1000000007 R, G, B = iia() r, g, b = sorted(iia()), sorted(iia()), sorted(iia()) dp = [[[0 for i in range(B + 1)] \ for j in range(G + 1)] for k in range(R + 1)] for i in range(R + 1): for j in range(G + 1): for k in range(B + 1): if i > 0 and j > 0: dp[i][j][k] = max(dp[i][j][k], \ dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]) if i > 0 and k > 0: dp[i][j][k] = max(dp[i][j][k], \ dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]) if j > 0 and k > 0: dp[i][j][k] = max(dp[i][j][k], \ dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1]) print(dp[-1][-1][-1])",cubic,"['dp', 'greedy', 'sortings']",931
"import sys input=sys.stdin.buffer.readline nr,ng,nb=[int(x) for x in input().split()] r=[int(x) for x in input().split()] g=[int(x) for x in input().split()] b=[int(x) for x in input().split()] r.sort() g.sort() b.sort() memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)] memo[0][0][0]=0 for i in range(nr): memo[i+1][0][0]=0 for j in range(ng): memo[0][j+1][0]=0 for k in range(nb): memo[0][0][k+1]=0 def dp(i,j,k): if i<-1 or j<-1 or k<-1: return -float('inf') if memo[i+1][j+1][k+1]==-1: memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k], dp(i-1,j-1,k)+r[i]*g[j], dp(i-1,j,k-1)+r[i]*b[k] ) return memo[i+1][j+1][k+1] for i in range(max(nr,ng,nb)): dp(min(i,nr-1),min(i,ng-1),min(i,nb-1)) print(dp(nr-1,ng-1,nb-1))",cubic,"['dp', 'greedy', 'sortings']",743
"import sys input=sys.stdin.buffer.readline nr,ng,nb=[int(x) for x in input().split()] r=[int(x) for x in input().split()] g=[int(x) for x in input().split()] b=[int(x) for x in input().split()] r.sort() g.sort() b.sort() memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)] memo[0][0][0]=0 for i in range(nr): memo[i+1][0][0]=0 for j in range(ng): memo[0][j+1][0]=0 for k in range(nb): memo[0][0][k+1]=0 def dp(i,j,k): if i<-1 or j<-1 or k<-1: return -float('inf') if memo[i+1][j+1][k+1]==-1: memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k], dp(i-1,j-1,k)+r[i]*g[j], dp(i-1,j,k-1)+r[i]*b[k] ) return memo[i+1][j+1][k+1] print(dp(nr-1,ng-1,nb-1))",cubic,"['dp', 'greedy', 'sortings']",672
"def getArray(): return list(map(int, input().split())) def createDP(R, G, B): dp = [] for i in range(R): temp1 = [] for j in range(G): temp2 = [] for k in range(B): temp2.append(-1) temp1.append(temp2) dp.append(temp1) return dp def go(r, g, b, R, G, B, ri, gi, bi, state): if state[ri][gi][bi] != -1 : return state[ri][gi][bi] best = 0 if ri < R and gi < G: best = max(best, r[ri]*g[gi] + go(r, g, b, R, G, B, ri+1, gi+1, bi, state)) if ri < R and bi < B: best = max(best, r[ri]*b[bi] + go(r, g, b, R, G, B, ri+1, gi, bi+1, state)) if gi < G and bi < B: best = max(best, g[gi]*b[bi] + go(r, g, b, R, G, B, ri, gi+1, bi+1, state)) state[ri][gi][bi] = best return best R,G,B = map(int, input().split()) r = getArray() g = getArray() b = getArray() r.sort(reverse = True) g.sort(reverse = True) b.sort(reverse = True) dp = createDP(201,201,201) print(go(r, g, b, R, G, B, 0, 0, 0, dp))",cubic,"['dp', 'greedy', 'sortings']",883
"import sys from math import sqrt, gcd, ceil, log, floor from bisect import bisect, bisect_left from collections import defaultdict, Counter, deque from heapq import heapify, heappush, heappop input = sys.stdin.readline read = lambda: list(map(int, input().strip().split())) MOD = 10**9 + 7 def main(): r, g, b = read() r_ar=sorted(read(), reverse = True); g_ar = sorted(read(), reverse = True); b_ar = sorted(read(), reverse = True) N = 201 dp = [[[-1]*N for i in range(N)]for j in range(N)] def f(x, y, z): if ((x >= r) + (y >= g) + (z >= b)) >= 2: return(0) if dp[x][y][z] != -1: return(dp[x][y][z]) maxi = 0 if x < r and y < g: maxi = max(maxi, r_ar[x]*g_ar[y] + f(x+1, y+1, z)) if z < b and y < g: maxi = max(maxi, b_ar[z]*g_ar[y] + f(x, y+1, z+1)) if x < r and z < b: maxi = max(maxi, r_ar[x]*b_ar[z] + f(x+1, y, z+1)) dp[x][y][z] = maxi return(maxi) print(f(0, 0, 0)) if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy', 'sortings']",907
"import sys input=lambda : sys.stdin.readline().strip() char = [chr(i) for i in range(97,123)] CHAR = [chr(i) for i in range(65,91)] mp = lambda:list(map(int,input().split())) INT = lambda:int(input()) rn = lambda:range(INT()) from math import ceil,sqrt,factorial,gcd r,g,b = mp() rl = sorted(mp(),reverse=True) gl = sorted(mp(),reverse=True) bl = sorted(mp(),reverse=True) def solve(i,j,k): if dp_table[i][j][k] != -1: return dp_table[i][j][k] ans = 0 if i < r and j < g: ans = max(solve(i+1,j+1,k) + rl[i]*gl[j],ans) if i < r and k < b: ans = max(solve(i+1,j,k+1) + rl[i]*bl[k],ans) if j < g and k < b: ans = max(solve(i,j+1,k+1) + gl[j]*bl[k],ans) dp_table[i][j][k] = ans return dp_table[i][j][k] dp_table = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)] res = solve(0,0,0) print(res)",cubic,"['dp', 'greedy', 'sortings']",808
"import sys input=lambda : sys.stdin.readline().strip() char = [chr(i) for i in range(97,123)] CHAR = [chr(i) for i in range(65,91)] mp = lambda:list(map(int,input().split())) INT = lambda:int(input()) rn = lambda:range(INT()) from math import ceil,sqrt,factorial,gcd r,g,b = mp() rl = sorted(mp(),reverse=True) gl = sorted(mp(),reverse=True) bl = sorted(mp(),reverse=True) def solve(i,j,k): if dp_table[i][j][k] != -1: return dp_table[i][j][k] if i < r and j < g and k < b: m = max(solve(i+1,j+1,k)+(rl[i]*gl[j]), solve(i+1,j,k+1)+(rl[i]*bl[k]), solve(i,j+1,k+1)+(gl[j]*bl[k])) dp_table[i][j][k] = m return m elif i < r and j < g: m = solve(i+1,j+1,b) + rl[i]*gl[j] dp_table[i][j][k] = m return m elif i < r and k < b: m = solve(i+1,g,k+1) + (rl[i]*bl[k]) dp_table[i][j][k] = m return m elif j < g and k < b: m = solve(r,j+1,k+1) + (gl[j]*bl[k]) dp_table[i][j][k] = m return m else: return 0 dp_table = [[[-1]*(b+1) for j in range(g+1)] for k in range(r+1)] res = solve(0,0,0) print(res)",cubic,"['dp', 'greedy', 'sortings']",987
"R,G,B = map(int,input().split()) r = sorted(list(map(int,input().split())), reverse=True) g = sorted(list(map(int,input().split())), reverse=True) b = sorted(list(map(int,input().split())), reverse=True) dp = [[[0]*(B+1) for i in range(G+1)] for j in range(R+1)] ans = 0 for i in range(R+1): for j in range(G+1): for k in range(B+1): if j*k > 0: dp[i][j][k] = max(dp[i][j-1][k-1]+g[j-1]*b[k-1],dp[i][j][k]) if i*k > 0: dp[i][j][k] = max(dp[i-1][j][k-1]+r[i-1]*b[k-1],dp[i][j][k]) if i*j > 0: dp[i][j][k] = max(dp[i-1][j-1][k]+g[j-1]*r[i-1],dp[i][j][k]) ans = max(ans,dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",590
"import pprint nr, ng, nb = map(int, input().split()) *r, = map(int, input().split()) *g, = map(int, input().split()) *b, = map(int, input().split()) dp = [] for _ in range(nr + 1): dp.append([[0] * (nb + 1) for _ in range(ng + 1)]) r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) mx = 0 for i in range(nr + 1): for j in range(ng + 1): for k in range(nb + 1): if i and j: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]) if i and k: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]) if j and k: dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1]) mx_i = mx_j = mx_k = -1 for i in range(nr + 1): for j in range(ng + 1): for k in range(nb + 1): if dp[i][j][k] > mx: mx_i = i mx_j = j mx_k = k mx = dp[i][j][k] print(mx)",cubic,"['dp', 'greedy', 'sortings']",802
"import sys R, G, B = list(map(int, input().split())) r = sorted([int(x) for x in input().split()], reverse = True) g = sorted([int(x) for x in input().split()], reverse = True) b = sorted([int(x) for x in input().split()], reverse = True) ans = 0 dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)] for i in range(R+1): for j in range(G+1): for k in range(B+1): if i<R and j<G: dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j]) if j<G and k<B: dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k]) if i<R and k<B: dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + b[k]*r[i]) ans = max(ans, dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",661
"def cal(r,g,b): if dp[r][g][b]!=-1: return dp[r][g][b] ans=0 if r<R and g<G: ans=max(ans,rl[r]*gl[g]+cal(r+1,g+1,b)) if r<R and b<B: ans=max(ans,rl[r]*bl[b]+cal(r+1,g,b+1)) if g<G and b<B: ans=max(ans,gl[g]*bl[b]+cal(r,g+1,b+1)) dp[r][g][b]=ans return ans R,G,B=map(int,input().split()) rl=sorted(list(map(int,input().split())),reverse=True) gl=sorted(list(map(int,input().split())),reverse=True) bl=sorted(list(map(int,input().split())),reverse=True) dp=[[[-1 for j in range(B+1)] for i in range(G+1)] for i in range(R+1)] print(cal(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",541
"import sys from functools import lru_cache, cmp_to_key from heapq import merge, heapify, heappop, heappush from collections import defaultdict as dd, deque, Counter as C from itertools import combinations as comb, permutations as perm from bisect import bisect_left as bl, bisect_right as br, bisect from time import perf_counter from fractions import Fraction import copy import time starttime = time.time() mod = int(pow(10, 9) + 7) mod2 = 998244353 def data(): return sys.stdin.readline().strip() def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end) def L(): return list(sp()) def sl(): return list(ssp()) def sp(): return map(int, data().split()) def ssp(): return map(str, data().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)] try: sys.stdin = open(""input.txt"", ""r"") except: pass global ans ans=0 def rec(i,j,k): if dp[i][j][k]!=-1: return dp[i][j][k] x1=x2=x3=0 if i<R and j<G: x1=r[i]*g[j]+rec(i+1,j+1,k) if i<R and k<B: x2=r[i]*b[k]+rec(i+1,j,k+1) if j<G and k<B: x3=g[j]*b[k]+rec(i,j+1,k+1) dp[i][j][k]=max(x1,x2,x3) global ans ans=max(ans,dp[i][j][k]) return dp[i][j][k] for _ in range(1): R,G,B=L() r=L() g=L() b=L() r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) dp=[[[-1 for k in range(B+1)] for j in range(G+1)] for i in range(R+1)] rec(0,0,0) print(ans) endtime = time.time()",cubic,"['dp', 'greedy', 'sortings']",1397
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import gcd, ceil def pre(s): n = len(s) pi = [0] * n for i in range(1, n): j = pi[i - 1] while j and s[i] != s[j]: j = pi[j - 1] if s[i] == s[j]: j += 1 pi[i] = j return pi def prod(a): ans = 1 for each in a: ans = (ans * each) return ans def lcm(a, b): return a * b // gcd(a, b) def binary(x, length=16): y = bin(x)[2:] return y if len(y) >= length else ""0"" * (length - len(y)) + y for _ in range(int(input()) if not True else 1): r, g, b = map(int, input().split()) rr = list(map(int, input().split())) gg = list(map(int, input().split())) bb = list(map(int, input().split())) dp = [[[0]*(b",cubic,"['dp', 'greedy', 'sortings']",1999
"r,g,b = map(int,input().split()) R = list(map(int,input().split())) G = list(map(int,input().split())) B = list(map(int,input().split())) R.sort() G.sort() B.sort() dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)] def solve(r,g,b): if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)): return 0 if dp[r][g][b]==-1: if r==0: ans = G[g-1]*B[b-1]+solve(r,g-1,b-1) elif g==0: ans = R[r-1]*B[b-1]+solve(r-1,g,b-1) elif b==0: ans = G[g-1]*R[r-1]+solve(r-1,g-1,b) else: ans = max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1)) dp[r][g][b] = ans return dp[r][g][b] ans = solve(r,g,b) print(ans)",cubic,"['dp', 'greedy', 'sortings']",664
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from collections import Counter import heapq from collections import Counter from bisect import bisect_right import bisect def find(x,y,z): if dp[x][y][z]!=-1: return dp[x][y][z] ans=0 if x<r and y<g: ans=max(ans,rl[x]*gl[y]+find(x+1,y+1,z)) if x<r and z<b: ans=max(ans,rl[x]*bl[z]+find(x+1,y,z+1)) if y<g and z<b: ans=max(ans,gl[y]*bl[z]+find(x,y+1,z+1)) dp[x][y][z]=ans return ans r,g,b = map(int, input().split()) rl=sorted(list(map(int, input().split())),reverse=True) gl=sorted(list(map(int, input().split())),reverse=True) bl=sorted(list(map(int, input().split())),reverse=True) dp=[[[-1]*(b+1) fo",cubic,"['dp', 'greedy', 'sortings']",2000
"def rec(r,g,b): if(dp[r][g][b]!=-1): return dp[r][g][b] ans=0 if r<R and g<G: ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b)) if r<R and b<B: ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1)) if b<B and g<G: ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1)) dp[r][g][b]=ans return ans R,G,B=map(int,input().split()) red=sorted(list(map(int, input().split())), reverse=True) green=sorted(list(map(int, input().split())), reverse=True) blue=sorted(list(map(int, input().split())), reverse=True) dp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)] print(rec(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",561
"from sys import stdin import time r,g,b = map(int,stdin.readline().split()) red = list(map(int,stdin.readline().split())) green = list(map(int,stdin.readline().split())) blue = list(map(int,stdin.readline().split())) red.sort() green.sort() blue.sort() dp = [[[0 for _ in range(b+1)] for _ in range(g+1)] for _ in range(r+1)] for i in range(r+1): for j in range(g+1): for k in range(b+1): if i>0 and j>0: dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+red[i-1]*green[j-1]) if i>0 and k>0: dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+red[i-1]*blue[k-1]) if j>0 and k>0: dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+green[j-1]*blue[k-1]) print(dp[-1][-1][-1])",cubic,"['dp', 'greedy', 'sortings']",659
"R, G, B = map(int, input().split()) L = [sorted(map(int, input().split())) for _ in range(3)] DP = [0] * ((R+1) * (G+1) * (B+1)) def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b for r in range(R+1): for g in range(G+1): for b in range(B+1): best = 0 if r: if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)] if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)]) if g and b: best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)]) DP[idx(r, g, b)] = best print(max(DP))",cubic,"['dp', 'greedy', 'sortings']",506
"c1, c2, c3 = map(int, input().split()) r = sorted(list(map(int, input().split()))) g = sorted(list(map(int, input().split()))) b = sorted(list(map(int, input().split()))) dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)] for i in range(c1 + 1): for j in range(c2 + 1): for k in range(c3 + 1): if i>0 and j>0: dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1]) if i>0 and k>0: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1]) if j>0 and k>0: dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1]) print(dp[c1][c2][c3])",cubic,"['dp', 'greedy', 'sortings']",598
"c1, c2, c3 = map(int, input().split()) r = sorted(list(map(int, input().split()))) g = sorted(list(map(int, input().split()))) b = sorted(list(map(int, input().split()))) dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)] for i in range(c1 + 1): for j in range(c2 + 1): for k in range(c3 + 1): if i>0 and j>0: dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1]) if i>0 and k>0: dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1]) if j>0 and k>0: dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1]) print(dp[c1][c2][c3])",cubic,"['dp', 'greedy', 'sortings']",598
"from sys import stdin input=lambda : stdin.readline().strip() lin=lambda :list(map(int,input().split())) iin=lambda :int(input()) main=lambda :map(int,input().split()) from math import ceil,sqrt,factorial,log from collections import deque from bisect import bisect_left def gcd(a,b): a,b=max(a,b),min(a,b) while a%b!=0: a,b=b,a%b return b def solve(): a,b,c=main() x,y,z=lin(),lin(),lin() x.sort(reverse=True) y.sort(reverse=True) z.sort(reverse=True) ans=0 dp=[[[0 for i in range(c+2)] for i in range(b+2)] for i in range(a+1)] for i in range(a+1): for j in range(b+1): for k in range(c+1): if i<a and j<b: dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+x[i]*y[j]) if i<a and k<c: dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+x[i]*z[k]) if k<c and j<b: dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+z[k]*y[j]) ans=max(ans,dp[i][j][k]) print(ans) qwe=1 for _ in range(qwe): solve()",cubic,"['dp', 'greedy', 'sortings']",887
"R, G, B = map(int, input().split()) L = [sorted(map(int, input().split())) for _ in range(3)] DP = [0] * ((R+1) * (G+1) * (B+1)) def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b for r in range(R+1): for g in range(G+1): for b in range(B+1): best = 0 if r: if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)] if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)]) if g and b: best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)]) DP[idx(r, g, b)] = best print(max(DP))",cubic,"['dp', 'greedy', 'sortings']",506
"def solve(): r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)] for i in range(r+1): for j in range(g+1): for k in range(b+1): if i+j+k<2:continue if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1]) if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1]) if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1]) return dp[r][g][b] print(solve())",cubic,"['dp', 'greedy', 'sortings']",580
"def cal(r, g, b): if dp[r][g][b] != -1: return dp[r][g][b] area = 0 if r<R and g<G: area = max(area, rl[r] * gl[g] + cal(r+1, g+1, b)) if r<R and b<B: area = max(area, rl[r] * bl[b] + cal(r+1, g, b+1)) if g<G and b<B: area = max(area, gl[g] * bl[b] + cal(r, g+1, b+1)) dp[r][g][b] = area return area if __name__ == ""__main__"": R, G, B = map(int,input().split()) rl = sorted(list(map(int,input().split())), reverse=True) gl = sorted(list(map(int,input().split())), reverse=True) bl = sorted(list(map(int,input().split())), reverse=True) dp = [[[-1]*(B+1) for i in range(G+1)] for i in range(R+1)] print(cal(0,0,0))",cubic,"['dp', 'greedy', 'sortings']",613
"R,G,B=list(map(int,input().split())) r=list(map(int,input().split())) g=list(map(int,input().split())) b=list(map(int,input().split())) r.sort(reverse=True) g.sort(reverse=True) b.sort(reverse=True) dp = [[[0 for i in range(B + 1)] for j in range(G + 1)] for k in range(R + 1)] ans=0 for i in range(R+1): for j in range(G+1): for k in range(B+1): if i<R and j<G: dp[i+1][j+1][k]=max(dp[i+1][j+1][k],r[i]*g[j]+dp[i][j][k]) if i<R and k<B: dp[i+1][j][k+1]=max(dp[i+1][j][k+1],r[i]*b[k]+dp[i][j][k]) if k<B and j<G: dp[i][j+1][k+1]=max(dp[i][j+1][k+1],b[k]*g[j]+dp[i][j][k]) ans=max(ans,dp[i][j][k]) print(ans)",cubic,"['dp', 'greedy', 'sortings']",607
"from collections import defaultdict def main(): R, G, B = map(int, input().split()) red = list(map(int, input().split())) green = list(map(int, input().split())) blue = list(map(int, input().split())) red.sort(reverse=True) green.sort(reverse=True) blue.sort(reverse=True) dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)] dp[0][0][0] = 0 ans = 0 for i in range(R+1): for j in range(G+1): for k in range(B+1): dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i] [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1]) ans = max(ans, dp[i][j][k]) print(ans) return if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy', 'sortings']",651
"def f(l,r,g,b,op): if (r==0 and g==0) or (r==0 and b==0) or (b==0 and g==0): return 0 else: if op[r][g][b]!=-1: return op[r][g][b] if r==0: op[r][g][b]=l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op) return op[r][g][b] if g==0: op[r][g][b]=l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op) return op[r][g][b] if b==0: op[r][g][b]=l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op) return op[r][g][b] op[r][g][b]=max(l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op),l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op),l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op)) return op[r][g][b] r,g,b=list(map(int,input().split())) l=[] l.append(sorted(list(map(int,input().split())))) l.append(sorted(list(map(int,input().split())))) l.append(sorted(list(map(int,input().split())))) op=[[[-1 for i in range(b+1)]for j in range(g+1)]for k in range(r+1)] print(f(l,r,g,b,op))",cubic,"['dp', 'greedy', 'sortings']",794
"from sys import stdin, stdout import math,sys,heapq from itertools import permutations, combinations from collections import defaultdict,deque,OrderedDict from os import path import random import bisect as bi def yes():print('YES') def no():print('NO') if (path.exists('input.txt')): sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w'); def I():return (int(input())) def In():return(map(int,input().split())) else: def I():return (int(stdin.readline())) def In():return(map(int,stdin.readline().split())) def dict(a): d={} for x in a: if d.get(x,-1)!=-1: d[x]+=1 else: d[x]=1 return d def find_gt(a, x): 'Find leftmost value greater than x' i = bi.bisect_left(a, x) if i != len(a): return i else: return -1 def cal(r,g,b,dp,R,G,B,nr,ng,nb): if dp[r][g][b]!=-1: return dp[r][g][b] best=0 if r<nr and g<ng: best=max(best,cal(r+1,g+1,b,dp,R,G,B,nr,ng,nb)+R[r]*G[g]) if r<nr and b<nb: best=max(best,cal(r+1,g,b+1,dp,R,G,B,nr,ng,nb)+R[r]*B[b]) if g<ng and b<nb: best=max(best,cal(r,g+1,b+1,dp,R,G,B,nr,ng,nb)+B[b]*G[g]) dp[r][g][b]=best return dp[r][g][b] def main(): try: nr,ng,nb=In() dp=[[[-1 for x in range(201)]for y in range(201)] for z in range(201)] R=list(In()) G=list(In()) B=list(In()) R.sort(reverse=True) G.sort(reverse=True) B.sort(reverse=True) print(cal(0,0,0,dp,R,G,B,nr,ng,nb)) except: pass M = 998244353 P = 1000000007 if __name__ == '__main__': for _ in range(1):main()",cubic,"['dp', 'greedy', 'sortings']",1398
"n = [int(x) for x in input().split()] a = [] for i in range(3): a.append([int(x) for x in input().split()]) a[i].sort(reverse=True) dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)] ans = 0 for i in range(n[0] + 1): for j in range(n[1] + 1): for k in range(n[2] + 1): if i < n[0] and j < n[1]: dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j]) if i < n[0] and k < n[2]: dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k]) if j < n[1] and k < n[2]: dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k]) ans = max(ans, dp[i][j][k]) print(ans )",cubic,"['dp', 'greedy', 'sortings']",663
"import sys input = sys.stdin.readline n = int(input()) a = list(map(int, input().split())) mod = 998244353 a.sort() dp = [1] + [0] * n for i in range(1, n + 1): x, pt = 1, i - 2 while pt >= 0 and 2 * a[pt] > a[i - 1]: x = x * (n - pt - 2) % mod pt -= 1 dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod print(dp[-1])",cubic,"['combinatorics', 'dp', 'math', 'two pointers']",319
"from collections import defaultdict import sys input = sys.stdin.readline n = int(input()) a = map(int, input().split()) mod = 998244353 d = defaultdict(int) for x in a: d[x] += 1 d[0] = 0 b = list(d.items()) b.sort() m = len(b) ba = [0] * m cn = [0] * (m + 1) k = h = 0 for i, x in enumerate(b): while h < m and x[0] >= b[h][0] * 2: h += 1 ba[i] = h - 1 while k < m and x[0] * 2 > b[k][0]: k += 1 cn[k] += x[1] for i in range(m): cn[i+1] += cn[i] dp = [0] * m dp[0] = 1 b = [x[1] for x in b] for i in range(n): ndp = [0] * m for j in range(1, m): if cn[j] >= i - 1: ndp[j] = dp[j] * (cn[j] - i + 1) % mod dp[j] += dp[j-1] if dp[j] >= mod: dp[j] -= mod for j in range(1, m): ndp[j] += dp[ba[j]] * b[j] ndp[j] %= mod dp = ndp print(sum(dp) % mod)",cubic,"['combinatorics', 'dp', 'math', 'two pointers']",745
"from collections import Counter import sys input = sys.stdin.readline n = int(input()) a = map(int, input().split()) mod = 998244353 d = Counter(a) d[0] = 0 b = list(d.items()) b.sort() m = len(b) ba = [0] * m cn = [0] * (m + 1) k = h = 0 for i, x in enumerate(b): while h < m and x[0] >= b[h][0] * 2: h += 1 ba[i] = h - 1 while k < m and x[0] * 2 > b[k][0]: k += 1 cn[k] += x[1] for i in range(m): cn[i+1] += cn[i] dp = [0] * m dp[0] = 1 b = [x[1] for x in b] for i in range(n): ndp = [0] * m for j in range(1, m): if cn[j] >= i - 1: ndp[j] = dp[j] * (cn[j] - i + 1) % mod dp[j] += dp[j-1] if dp[j] >= mod: dp[j] -= mod for j in range(1, m): ndp[j] += dp[ba[j]] * b[j] ndp[j] %= mod dp = ndp print(sum(dp) % mod)",cubic,"['combinatorics', 'dp', 'math', 'two pointers']",713
"from collections import Counter import sys input = sys.stdin.readline n = int(input()) a = list(map(int, input().split())) mod = 998244353 a.sort() dp = [1] + [0] * n for i in range(1, n + 1): x, pt = 1, i - 2 while pt >= 0 and 2 * a[pt] > a[i - 1]: x = x * (n - pt - 2) % mod pt -= 1 dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod print(dp[-1])",cubic,"['combinatorics', 'dp', 'math', 'two pointers']",351
"mod = 998244353 eps = 10**-9 def main(): import sys input = sys.stdin.readline N = int(input()) A = list(map(int, input().split())) + [0] A.sort() dp = [[0] * (i+1) for i in range(N+1)] dp[0][0] = 1 l = 0 for i in range(1, N+1): for ll in range(l+1, i): if A[ll] * 2 <= A[i]: l = ll else: break for j in range(1, l+2): dp[i][j] = (dp[l][j-1] + (dp[i][j-1] * (l-j+2))%mod)%mod for j in range(i): dp[i][j] = (dp[i-1][j] + dp[i][j])%mod print(dp[-1][-1]) if __name__ == '__main__': main()",cubic,"['combinatorics', 'dp', 'math', 'two pointers']",485
"M = 998244353 n = int(input()) l = sorted(map(int, input().split()))[::-1] out = [0] * n big = 0 if l[0] >= 2 * l[1]: out[1] = 1 big = 1 for i in range(2, n): new = [0] * n bigN = 0 for j in range(i): if l[j] >= 2 * l[i]: big += out[j] else: new[j] += out[j] * (i - 1) new[j] %= M new[i] = big bigN = (i * big) % M out = new big = bigN print((big + sum(out))%M)",cubic,"['combinatorics', 'dp', 'math', 'two pointers']",361
"import sys input = sys.stdin.readline class sieve: def __init__(self, n): self.n = n self.sv = [1] * (n + 1) self.sv[0] = 0 self.sv[1] = 0 for i in range(2, n + 1): if self.sv[i]: for j in range(i * 2, n + 1, i): self.sv[j] = 0 def isprime(self, x): if x > self.n: return False return self.sv[x] == 1 def factorize(self, x): res = [] for i in range(2, int(x ** 0.5) + 1): if self.sv[i]: while x % i == 0: x //= i res.append(i) if x != 1: res.append(x) return res def modlcm(self, a, mod): res = [0] * (self.n + 1) ex = set() for i in range(len(a)): f = self.factorize(a[i]) for j in f: if j > self.n: ex.add(j) continue res[j] = max(f.count(j), res[j]) rres = 1 for i in range(self.n + 1): if res[i] != 0: rres *= pow(i, res[i], mod) rres %= mod for i in ex: rres *= i rres %= mod return rres sv = sieve(10 ** 4) for _ in range(int(input())): n, k = map(int, input().split()) a = list(map(int, input().split())) for i in range(n): x = a[i] q = sv.factorize(x) s = [1] while len(q): y = q.pop() if y == s[-1]: s.pop() a[i] //= y ** 2 else: s.append(y) s = [set() for _ in range(k + 1)] dp = [n] * (k + 1) dp[0] = 0 for i in range(n): for j in range(k, -1, -1): if dp[j] == n: continue if a[i] in s[j]: if j + 1 <= k and dp[j + 1] > dp[j]: dp[j + 1] = dp[j] s[j + 1] = s[j] dp[j] += 1 s[j] = set() s[j].add(a[i]) else: s[j].add(a[i]) for j in range(k + 1): dp[j] += len(s[j]) > 0 print(min(dp))",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1392
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline import bisect T = int(input()) r = 1 prime = [2] for i in range(3,4*10**3,2): flag = False if i%2==0: continue for j in range(3,int(i**0.5)+1,2): if i%j==0: flag = True break if not flag: prime.append(i) def primefactor(num): index = 0 output = [] while num>=prime[index]**2: times = 0 while num%prime[index]==0: num = num // prime[index] times += 1 if times&1: output.append(prime[index]) index += 1 if num>1: output.append(num) return tuple(output) while r<=T: n,k = map(int,input().split()) arr = list(map(int,input().split())) seg = 1 fact = {} left = [[0 for j in range(k+1)] for i in range(n)] dp = [[300000 for j in range(k+1)] for i in range(n)] stack = [0] for i in range(n): factor = primefactor(arr[i]) if factor in fact: bisect.insort(stack,fact[factor]+1) fact[factor] = i for j in range(k+1): if j<len(stack): left[i][j] = stack[-j-1] for i in range(n): for j in range(k+1): for t in range(j+1): l = left[i][t] if l>0: dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j]) else: dp[i][j] = 1 print(dp[-1][-1]) r += 1",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1093
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline import bisect T = int(input()) r = 1 prime = [2] for i in range(3,4*10**3,2): flag = False if i%2==0: continue for j in range(3,int(i**0.5)+1,2): if i%j==0: flag = True break if not flag: prime.append(i) def primefactor(num): index = 0 output = [] while num>=prime[index]**2: times = 0 while num%prime[index]==0: num = num // prime[index] times += 1 if times&1: output.append(prime[index]) index += 1 if num>1: output.append(num) return tuple(output) while r<=T: n,k = map(int,input().split()) arr = list(map(int,input().split())) seg = 1 fact = {} left = [[0 for j in range(k+1)] for i in range(n)] dp = [[300000 for j in range(k+1)] for i in range(n)] stack = [0] for i in range(n): factor = primefactor(arr[i]) if factor in fact: bisect.insort(stack,fact[factor]+1) fact[factor] = i for j in range(k+1): if j<len(stack): left[i][j] = stack[-j-1] for i in range(n): for j in range(k+1): for t in range(j+1): l = left[i][t] if l>0: dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j]) else: dp[i][j] = 1 print(dp[-1][-1]) r += 1",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1093
"import os, sys, heapq as h, time from io import BytesIO, IOBase from types import GeneratorType from bisect import bisect_left, bisect_right from collections import defaultdict as dd, deque as dq, Counter as dc import math, string BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): import os self.os = os self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: self.os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def getInt(): return int(input()) def getStrs(): return input().split() def getInts(): return list(map(int,input().split())) def getStr(): return input() def listStr(): return list(input()) def getMat(n): return [getInts() for _ in range(n)] def isInt(s): return '0' <= s[0] <= '9' MOD = 10**9 + 7 squares = set([i*i for i in range(1,4000)]) p = [i for i in range(10**7+1)] f",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1999
"import os, sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): import os self.os = os self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: self.os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def getInt(): return int(input()) def getStrs(): return input().split() def getInts(): return list(map(int,input().split())) def getStr(): return input() def listStr(): return list(input()) def getMat(n): return [getInts() for _ in range(n)] def isInt(s): return '0' <= s[0] <= '9' squares = set([i*i for i in range(1,4000)]) p = [i for i in range(10**7+1)] for i in range(1,10**7+1): if p[i] == i: for sq in squares: if i*sq > 10**7: break p[i*sq] = i for _ in range(getInt()): N, K = getInts() A = getInts() new = 10**8 A = [p[A[i]] for i in range(N)] dp = [N",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",2000
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline import bisect T = int(input()) r = 1 prime = [2] for i in range(3,4*10**3,2): flag = False if i%2==0: continue for j in range(3,int(i**0.5)+1,2): if i%j==0: flag = True break if not flag: prime.append(i) def primefactor(num): index = 0 output = [] while num>=prime[index]**2: times = 0 while num%prime[index]==0: num = num // prime[index] times += 1 if times&1: output.append(prime[index]) index += 1 if num>1: output.append(num) return tuple(output) while r<=T: n,k = map(int,input().split()) arr = list(map(int,input().split())) seg = 1 fact = {} left = [[0 for j in range(k+1)] for i in range(n)] dp = [[300000 for j in range(k+1)] for i in range(n)] stack = [0] for i in range(n): factor = primefactor(arr[i]) if factor in fact: bisect.insort(stack,fact[factor]+1) fact[factor] = i for j in range(k+1): if j<len(stack): left[i][j] = stack[-j-1] for i in range(n): for j in range(k+1): for t in range(j+1): l = left[i][t] if l>0: dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j]) else: dp[i][j] = 1 print(dp[-1][-1]) r += 1",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1093
"import io,os,bisect input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline prime = [2] for i in range(3,4*10**3,2): flag = False if i%2==0: continue for j in range(3,int(i**0.5)+1,2): if i%j==0: flag = True break if not flag: prime.append(i) def primefactor(num): index = 0 output = [] while num>=prime[index]**2: times = 0 while num%prime[index]==0: num = num // prime[index] times += 1 if times&1: output.append(prime[index]) index += 1 if num>1: output.append(num) return tuple(output) for _ in range(int(input())): n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0] for i in range(n): factor = primefactor(arr[i]) if factor in fact: bisect.insort(stack,fact[factor]+1) fact[factor] = i for j in range(k+1): if j<len(stack): left[i][j] = stack[-j-1] for i in range(n): for j in range(k+1): for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1) print(dp[-1][-1])",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1064
"import io,os,bisect;input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline;prime = [2] for i in range(3,4*10**3,2): flag = False if i%2==0: continue for j in range(3,int(i**0.5)+1,2): if i%j==0: flag = True;break if not flag: prime.append(i) def primefactor(num): index = 0;output = [] while num>=prime[index]**2: times = 0 while num%prime[index]==0:num = num // prime[index];times += 1 if times&1: output.append(prime[index]) index += 1 if num>1: output.append(num) return tuple(output) for _ in range(int(input())): n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0] for i in range(n): factor = primefactor(arr[i]) if factor in fact: bisect.insort(stack,fact[factor]+1) fact[factor] = i for j in range(k+1): if j<len(stack): left[i][j] = stack[-j-1] for i in range(n): for j in range(k+1): for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1) print(dp[-1][-1])",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1063
"import bisect import time def ass(a, b): print(f""Assertion error: {a} != {b}"" if a != b else 'OK') def nr(): return int(input()) def nrs(): return [int(i) for i in input().split()] def get_prime(n): res = [] for i in range(2, n): is_prime = True for x in res: if i % x == 0: is_prime = False break if is_prime: res.append(i) return res def get_mask(num): dv = [] for p in prime: c = 0 while num % p == 0: c += 1 num = num // p if c % 2 == 1: dv.append(p) if num < p * p: break for x in dv: num *= x return num def dump(dp): for i,line in enumerate(dp): print(i%10,line) def get_left(n,k,lst): last_in = {} s = [] res = [] for i in range(n): group = get_mask(lst[i]) if group in last_in: bisect.insort(s, last_in[group] + 1) last_in[group] = i if len(s) <= k+1: res.append(s[::-1]) else: m = len(s) res.append(s[m-1:m-k-2:-1]) return res def get_dp(n,k,lst): res = [] left = get_left(n,k,lst) for i in range(n): arr = left[i] row = [n] * (k+1) for j in range(k+1): for g in range(j+1): if g >= len(arr): row[j] = 1 else: index = arr[g]-1 jindex = j-g row[j] = min(res[index][jindex] + 1, row[j]) res.append(row) return res def f(n,k,lst): dp = get_dp(n,k,lst) print(dp[n-1][k]) prime = get_prime(3162) for _ in range(nr()): n,k = nrs() f(n,k,nrs())",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1247
"import bisect import time def ass(a, b): print(f""Assertion error: {a} != {b}"" if a != b else 'OK') def nr(): return int(input()) def nrs(): return [int(i) for i in input().split()] def get_prime(n): res = [] for i in range(2, n): is_prime = True for x in res: if i % x == 0: is_prime = False break if is_prime: res.append(i) return res cache = {} def get_mask(num): key = num if key in cache: return cache[key] dv = [] for p in prime: c = 0 while num % p == 0: c += 1 num = num // p if c % 2 == 1: dv.append(p) if num < p * p: break for x in dv: num *= x cache[key] = num return num def dump(dp): for i,line in enumerate(dp): print(i%10,line) def get_left(n,k,lst): last_in = {} s = [] res = [] for i in range(n): group = get_mask(lst[i]) if group in last_in: bisect.insort(s, last_in[group] + 1) last_in[group] = i if len(s) <= k+1: res.append(s[::-1]) else: m = len(s) res.append(s[m-1:m-k-2:-1]) return res def get_dp(n,k,lst): res = [] left = get_left(n,k,lst) for i in range(n): arr = left[i] row = [n] * (k+1) for j in range(k+1): for g in range(j+1): if g >= len(arr): row[j] = 1 else: index = arr[g]-1 jindex = j-g row[j] = min(res[index][jindex] + 1, row[j]) res.append(row) return res def f(n,k,lst): dp = get_dp(n,k,lst) print(dp[n-1][k]) prime = get_prime(3162) for _ in range(nr()): n,k = nrs() f(n,k,nrs())",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1320
"def nr(): return nrs()[0] def nrs(): return [int(i) for i in input().split()] n = 10**7 squares = [i * i for i in range(1, 3162)] p = [i for i in range(n + 1)] for i in range(1, n + 1): if p[i] == i: for sq in squares: if i * sq > n: break p[i * sq] = i for _ in range(nr()): N, K = nrs() A = [p[a] for a in nrs()] dp = [N] * (K + 1) dp[0] = 1 used = [set()] * (K + 1) for a in A: for j in range(K, -1, -1): if dp[j] == N: continue if a in used[j]: if j < K and dp[j + 1] > dp[j]: dp[j + 1] = dp[j] used[j + 1] = used[j] dp[j] += 1 used[j] = set([a]) else: used[j].add(a) print(min(dp))",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",586
"def nr(): return nrs()[0] def nrs(): return [int(i) for i in input().split()] n = 10**7 squares = [i * i for i in range(1, 3162)] p = list(range(n + 1)) for i in range(1, n + 1): if p[i] == i: for sq in squares: if i * sq > n: break p[i * sq] = i for _ in range(nr()): N, K = nrs() A = [p[a] for a in nrs()] dp = [N] * (K + 1) dp[0] = 1 used = [{}] * (K + 1) for a in A: for j in range(K, -1, -1): if dp[j] == N: continue if a in used[j]: if j < K and dp[j + 1] > dp[j]: dp[j + 1] = dp[j] used[j + 1] = used[j] dp[j] += 1 used[j] = {} used[j][a] = 1 print(min(dp))",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",564
"def nr(): return nrs()[0] def nrs(): return [int(i) for i in input().split()] def get_prime(n): res = [] for i in range(2,n): is_prime = True for x in res: if i % x == 0: is_prime = False break if is_prime: res.append(i) return res prime = get_prime(3162) cache = {} def get_mask (num): key = num if key in cache: return cache[key] dv = [] for p in prime: c = 0 while num % p == 0: c += 1 num = num // p if c % 2 == 1: dv.append(p) if num < p * p: break for x in dv: num *= x cache[key] = num return num for _ in range(nr()): N, K = nrs() A = nrs() dp = [N] * (K + 1) dp[0] = 1 used = [{}] * (K + 1) for a in A: a = get_mask(a) for j in range(K, -1, -1): if dp[j] == N: continue if a in used[j]: if j < K and dp[j + 1] > dp[j]: dp[j + 1] = dp[j] used[j + 1] = used[j] dp[j] += 1 used[j] = {} used[j][a] = 1 print(min(dp))",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",821
"def nr(): return nrs()[0] def nrs(): return [int(i) for i in input().split()] def get_prime(n): res = [] for i in range(2,n): is_prime = True for x in res: if i % x == 0: is_prime = False break if is_prime: res.append(i) return res prime = get_prime(3162) def get_mask (num): dv = [] for p in prime: c = 0 while num % p == 0: c += 1 num = num // p if c % 2 == 1: dv.append(p) if num < p * p: break for x in dv: num *= x return num for _ in range(nr()): N, K = nrs() A = nrs() dp = [N] * (K + 1) dp[0] = 1 used = [{}] * (K + 1) for a in A: a = get_mask(a) for j in range(K, -1, -1): if dp[j] == N: continue if a in used[j]: if j < K and dp[j + 1] > dp[j]: dp[j + 1] = dp[j] used[j + 1] = used[j] dp[j] += 1 used[j] = {} used[j][a] = 1 print(min(dp))",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",748
"pfs=[i*i for i in range(1,3163)] p=[i for i in range(0,10000001)] for i in range(1,10000001): if(p[i]==i): for j in pfs: if(i*j>10000000): break p[i*j]=i t=int(input()) for lll in range(0,t): n,k=map(int,input().split()) zc=list(map(int,input().split())) s=[p[zc[i]] for i in range(0,len(zc))] dp=[n]*(k+1) dp[0]=1 ys=[{}]*(n+1) for i in range(0,len(s)): for j in range(k,-1,-1): if(dp[j]==n): continue if(ys[j].get(s[i],-1)!=-1): if(j<k and dp[j]<dp[j+1]): dp[j+1]=dp[j] ys[j+1]=ys[j] dp[j]+=1 ys[j]={} ys[j][s[i]]=1 print(min(dp))",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",532
"pfs=[i*i for i in range(1,3163)] p=[i for i in range(0,10000001)] for i in range(1,10000001): if(p[i]==i): for j in pfs: if(i*j>10000000): break p[i*j]=i t=int(input()) for lll in range(0,t): n,k=map(int,input().split()) zc=list(map(int,input().split())) s=[p[zc[i]] for i in range(0,len(zc))] dp=[n]*(k+1) dp[0]=1 ys=[{}]*(n+1) for i in range(0,len(s)): for j in range(k,-1,-1): if(dp[j]==n): continue if(ys[j].get(s[i],-1)!=-1): if(j<k and dp[j]<dp[j+1]): dp[j+1]=dp[j] ys[j+1]=ys[j] dp[j]+=1 ys[j]={} ys[j][s[i]]=1 print(min(dp))",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",532
"import os import io input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from math import sqrt,ceil max_n=10**7+1 spf = [i for i in range(max_n)] for i in range(4,max_n,2): spf[i]=2 for i in range(3,ceil(sqrt(max_n))): if (spf[i]==i): for j in range(i*i,max_n,i): if(spf[j]==j): spf[j]=i from collections import Counter,defaultdict from bisect import insort def f(x): c=Counter() ans=1 while(x!=1): c[spf[x]]+=1 x//=spf[x] for i in c: if(c[i]%2==1): ans*=i return(ans) t=int(input()) for _ in range(t): n,k=map(int,input().split()) a=list(map(int,input().split())) for i in range(n): a[i]=f(a[i]) dp_depth=[[n for j in range(k+1)] for i in range(n)] recent=[n for i in range(k+1)] closest=defaultdict(lambda: -1) for i in range(n-1,-1,-1): if(closest[a[i]]>=0): insort(recent,closest[a[i]]) recent.pop() dp_depth[i]=recent.copy() closest[a[i]]=i dp=[[i for j in range(k+1)] for i in range(n+1)] dp[0]=[0 for j in range(k+1)] for i in range(n): for x in range(k+1): end=dp_depth[i][x] for y in range(k-x+1): dp[end][x+y]=min(dp[end][x+y],dp[i][y]+1) print(dp[n][k])",cubic,"['data structures', 'dp', 'greedy', 'math', 'number theory', 'two pointers']",1072
"def divisors(M): d=[] i=1 while M>=i**2: if M%i==0: d.append(i) if i**2!=M: d.append(M//i) i=i+1 return d def popcount(x): x = x - ((x >> 1) & 0x55555555) x = (x & 0x33333333) + ((x >> 2) & 0x33333333) x = (x + (x >> 4)) & 0x0f0f0f0f x = x + (x >> 8) x = x + (x >> 16) return x & 0x0000007f def eratosthenes(n): res=[0 for i in range(n+1)] prime=set([]) for i in range(2,n+1): if not res[i]: prime.add(i) for j in range(1,n//i+1): res[i*j]=1 return prime def factorization(n): res=[] for p in prime: if n%p==0: while n%p==0: n//=p res.append(p) if n!=1: res.append(n) return res def euler_phi(n): res = n for x in range(2,n+1): if x ** 2 > n: break if n%x==0: res = res//x * (x-1) while n%x==0: n //= x if n!=1: res = res//n * (n-1) return res def ind(b,n): res=0 while n%b==0: res+=1 n//=b return res def isPrimeMR(n): if n==1: return 0 d = n - 1 d = d // (d & -d) L = [2, 3, 5, 7, 11, 13, 17] for a in L: t = d y = pow(a, t, n) if y == 1: continue while y != n - 1: y = (y * y) % n if y == 1 or t == n - 1: return 0 t <<= 1 return 1 def findFactorRho(n): from math import gcd m = 1 << n.bit_length() // 8 for c in range(1, 99): f = lambda x: (x * x + c) % n y, r, q, g = 2, 1, 1, 1 while g == 1: x = y for i in range(r): y = f(y) k = 0 while k < r and g == 1: ys = y for i in range(min(m, r - k)): y = f(y) q = q * abs(x - y) % n g = gcd(q, n) k += m r <<= 1 if g == n: g = 1 while g == 1: ys = f(ys) g = gcd(abs(x - ys), n) if g < n: if isPrimeMR(g): return g elif isPrimeMR(n // g): return n // g return findFactorRho(g) def primeFactor(n): i = 2 ret = {} rhoFlg = 0 while i*i <= n: k = 0 while n % i == 0: n //= i k += 1 if k: ret[i] = k i += 1 + i % 2 if i == 101 and n >= 2 ** 20: while n > 1: if isPrimeMR(n): ret[n], n = 1, 1 else: rhoFlg = 1 j = findFactorRho(n) k = 0 while n % j == 0: n //= j k += 1 ret[j] = k if n > 1: ret[n] = 1 if rhoFlg: ret = {x: ret[x] for x in sorted(ret)} return ret def divisors(n): res = [1] prime = primeFactor(n) for p in prime: newres = [] for d in res: for",cubic,"['combinatorics', 'dp', 'math']",2000
"n, MOD = map(int, input().split()) pascal = [[1]] for _ in range(500): nl = [1] for i in range(_): nl.append((pascal[-1][i] + pascal[-1][i+1]) % MOD) nl.append(1) pascal.append(nl) mod_mul = lambda x, y: (x * y) % MOD import __pypy__ int_add = __pypy__.intop.int_add int_sub = __pypy__.intop.int_sub int_mul = __pypy__.intop.int_mul def make_mod_mul(mod=MOD): fmod_inv = 1.0 / mod def mod_mul(a, b, c=0): res = int_sub(int_add(int_mul(a, b), c), int_mul(mod, int(fmod_inv * a * b + fmod_inv * c))) if res >= mod: return res - mod elif res < 0: return res + mod else: return res return mod_mul mod_mul = make_mod_mul() def mod_pow(x, y): if y == 0: return 1 res = 1 while y > 1: if y & 1 == 1: res = mod_mul(res, x) x = mod_mul(x, x) y >>= 1 return mod_mul(res, x) base = [0] * (n + 1) dp = [] for i in range(n): nex = base[:] nex[1] = mod_pow(2, i) for j in range(i - 1): bl = i-j-1 assert bl > 0 mul = mod_pow(2, bl - 1) for k in range(n): ct = 2 + j - k if ct < 0: assert dp[j][k] == 0 continue mulr = mod_mul(mul, pascal[bl+ct][ct]) nex[k+1] += mod_mul(mulr, dp[j][k]) nex[k+1] %= MOD dp.append(nex) print(sum(dp[-1]) % MOD)",cubic,"['combinatorics', 'dp', 'math']",1127
"from __pypy__.intop import int_mulmod n_, MOD = [int(t) for t in input().split()] def mul(a, b): return int_mulmod(a, b, MOD) N = 410 dp = [[0] * (N+1) for _ in range(N+1)] fact = [1] for x in range(1, N): fact.append(fact[-1] * x % MOD) inv_fact = [0] * N inv_fact[-1] = pow(fact[-1], MOD - 2, MOD) for x in reversed(range(1, N)): inv_fact[x - 1] = inv_fact[x] * x % MOD def nCr(n, r): return mul(fact[n], mul(inv_fact[n-r], inv_fact[r])) for n in range(1, N+1): dp[n][n] = pow(2, n-1, MOD) for i in range(1, n-1): j = n-i-1 for k in range(1, i+1): dp[n][k+j] = (dp[n][k+j] + mul(nCr(k+j, k), mul(dp[i][k], dp[j][j]))) % MOD print(sum(dp[n_]) % MOD)",cubic,"['combinatorics', 'dp', 'math']",650
"def getc(): f = [[0]*500 for i in range(500)] for i in range(500): f[i][0] = 1 f[1][0] = 1 f[1][1] = 1 for i in range(2,411): for j in range(1, i+1): f[i][j] = (f[i-1][j-1] + f[i-1][j])%mod return f n, mod = map(int, input().split()) f = [[0]*500 for i in range(500)] c = getc() mi_2 = [0]*500 mi_2[0] = 1 for i in range(1, 500): mi_2[i] = mi_2[i-1]*2%mod for i in range(1, n+1): for j in range(0, i//2+1): if j == 0: f[i][j] = mi_2[i-1] else: for k in range(2, i): f[i][j] = (f[i][j] + ((mi_2[k-2]*f[i-k][j-1])%mod)*c[i-j][k-1]%mod)%mod ans = 0 for i in range(0,n+1): ans = (ans + f[n][i])%mod print(ans)",cubic,"['combinatorics', 'dp', 'math']",605
"import sys sys.setrecursionlimit(10**5) int1 = lambda x: int(x)-1 p2D = lambda x: print(*x, sep=""\n"") def II(): return int(sys.stdin.buffer.readline()) def LI(): return list(map(int, sys.stdin.buffer.readline().split())) def LLI(rows_number): return [LI() for _ in range(rows_number)] def LI1(): return list(map(int1, sys.stdin.buffer.readline().split())) def LLI1(rows_number): return [LI1() for _ in range(rows_number)] def BI(): return sys.stdin.buffer.readline().rstrip() def SI(): return sys.stdin.buffer.readline().rstrip().decode() inf = 10**16 n, md = LI() def nHr(hn, hr): return nCr(hn+hr-1, hr-1) def nPr(com_n, com_r): if com_r < 0: return 0 if com_n < com_r: return 0 return fac[com_n]*ifac[com_n-com_r]%md def nCr(com_n, com_r): if com_r < 0: return 0 if com_n < com_r: return 0 return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md n_max = 405 fac = [1] for i in range(1, n_max+1): fac.append(fac[-1]*i%md) ifac = [1]*(n_max+1) ifac[n_max] = pow(fac[n_max], md-2, md) for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md pw = [1] for i in range(400): pw.append(pw[-1]*2%md) dp = [[0]*(n//2+2) for _ in range(n+2)] dp[0][0] = 1 for i in range(1, n+2): for j in range(1, n//2+2): v = 0 for k in range(i-2, -1, -1): v += dp[k][j-1]*pw[i-k-2]*nCr(i-j, i-k-1)%md dp[i][j] = v%md ans = sum(dp[-1])%md print(ans)",cubic,"['combinatorics', 'dp', 'math']",1328
"import os import sys from io import BytesIO, IOBase def main(): n, MOD = map(int, input().split()) factorial = [1] for i in range(2, n + 1): factorial.append(factorial[-1] * i % MOD) for i in range(len(factorial)): factorial[i] = pow(factorial[i], MOD - 2, MOD) DP = [] for i in range(n): DP.append([0] * n) for i in range(n): DP[i][0] = pow(2, i, MOD) * factorial[i] for j in range(1, i // 2 + 1): for k in range(0, i - 1): DP[i][j] += DP[k][j - 1] * pow(2, i - k - 2, MOD) * factorial[i - k - 2] DP[i][j] %= MOD ans = 0 for i in range(len(factorial)): factorial[i] = pow(factorial[i], MOD - 2, MOD) for i in range(n): ans += DP[n - 1][i] * factorial[n - i - 1] print(ans % MOD) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.",cubic,"['combinatorics', 'dp', 'math']",1999
"N, mod = map(int, input().split()) two = [1] * (N+1) fact = [1] * (N+1) inv = [1] * (N+1) for i in range(1, N+1): two[i] = two[i-1]*2 % mod for i in range(2, N+1): fact[i] = fact[i-1] * i % mod inv[N] = pow(fact[N], mod-2, mod) for i in range(N, 0, -1): inv[i-1] = inv[i] * i % mod dp = [[0] * (N+2) for _ in range(N+2)] dp[0][0] = 1 for i in range(N): for j in range(i+1): for k in range(1, N+1): if i+k > N: break dp[i+k+1][j+1] += dp[i][j] * two[k-1] * inv[k] % mod dp[i+k+1][j+1] %= mod ans = 0 for j in range(1, N+1): ans += dp[N+1][j] * fact[N-j+1] % mod ans %= mod print(ans)",cubic,"['combinatorics', 'dp', 'math']",582
"p1, g1, ig1 = 104857601, 3, 34952534 p2, g2, ig2 = 111149057, 3, 37049686 p3, g3, ig3 = 113246209, 7, 16178030 z1 = 439957480532171226961446 z2 = 879898597692195524486915 z3 = 8496366309945115353 ppp = p1 * p2 * p3 W1 = [pow(g1, (p1 - 1) >> i, p1) for i in range(22)] W2 = [pow(g2, (p2 - 1) >> i, p2) for i in range(22)] W3 = [pow(g3, (p3 - 1) >> i, p3) for i in range(22)] iW1 = [pow(ig1, (p1 - 1) >> i, p1) for i in range(22)] iW2 = [pow(ig2, (p2 - 1) >> i, p2) for i in range(22)] iW3 = [pow(ig3, (p3 - 1) >> i, p3) for i in range(22)] def fft1(k, f): for l in range(k, 0, -1): d = 1 << l - 1 U = [1] for i in range(d): U.append(U[-1] * W1[l] % p1) for i in range(1 << k - l): for j in range(d): s = i * 2 * d + j f[s], f[s+d] = (f[s] + f[s+d]) % p1, U[j] * (f[s] - f[s+d]) % p1 def fft2(k, f): for l in range(k, 0, -1): d = 1 << l - 1 U = [1] for i in range(d): U.append(U[-1] * W2[l] % p2) for i in range(1 << k - l): for j in range(d): s = i * 2 * d + j f[s], f[s+d] = (f[s] + f[s+d]) % p2, U[j] * (f[s] - f[s+d]) % p2 def fft3(k, f): for l in range(k, 0, -1): d = 1 << l - 1 U = [1] for i in range(d): U.append(U[-1] * W3[l] % p3) for i in range(1 << k - l): for j in range(d): s = i * 2 * d + j f[s], f[s+d] = (f[s] + f[s+d]) % p3, U[j] * (f[s] - f[s+d]) % p3 def ifft1(k, f): for l in range(1, k + 1): d = 1 << l - 1 for i in range(1 << k - l): u = 1 for j in range(i * 2 * d, (i * 2 + 1) * d): f[j+d] *= u f[j], f[j+d] = (f[j] + f[j+d]) % p1, (f[j] - f[j+d]) % p1 u = u * iW1[l] % p1 def ifft2(k, f): for l in range(1, k + 1): d = 1 << l - 1 for i in range(1 << k - l): u = 1 for j in range(i * 2 * d, (i * 2 + 1) * d): f[j+d] *= u f[j], f[j+d] = (f[j] + f[j+d]) % p2, (f[j] - f[j+d]) % p2 u = u * iW2[l] % p2 def ifft3(k, f): for l in range(1, k + 1): d = 1 << l - 1 for i in range(1 << k - l): u = 1 for j in range(i * 2 * d, (i * 2 + 1) * d): f[j+d] *= u f[j], f[j+d] = (f[j] + f[j+d]) % p3, (f[j] - f[j+d]) % p3 u = u * iW3[l] % p3 def convolve(a, b): n0 = len(a) + len(b) - 1 if len(a)",cubic,"['combinatorics', 'dp', 'math']",2000
"from bisect import bisect,bisect_left from collections import * from heapq import * from math import gcd,ceil,sqrt,floor,inf from itertools import * from operator import add,mul,sub,xor,truediv,floordiv from functools import * import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def RL(): return map(int, sys.stdin.readline().split()) def RLL(): return list(map(int, sys.stdin.readline().split())) def N(): return int(input()) def A(n):return [0]*n def AI(n,x): return [x]*n def A2(n,m): return [[0]*m for i in range(n)] def G(n): return [[] for i in range(n)] def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)] from types import GeneratorType",cubic,"['combinatorics', 'dp', 'math']",2000
"fac = [1] * 500 finv = [1] * 500 p2 = [1] * 500 n, MOD = map(int, input().split()) for i in range(len(fac) - 1): fac[i + 1] = fac[i] * (i + 1) % MOD finv[i + 1] = pow(fac[i + 1], MOD - 2, MOD) p2[i + 1] = p2[i] * 2 % MOD ans = 0 dp = [[0] * (n // 2 + 2) for _ in range(n + 2)] dp[0][0] = 1 for i in range(n): for j in range(i + 2, n + 2): for k in range(n // 2 + 1): dp[j][k + 1] += dp[i][k] % MOD * finv[j - i - 1] * p2[j - i - 2] ans = 0 for i in range(1, n // 2 + 2): ans += dp[n + 1][i] * fac[n - i + 1] print(ans % MOD)",cubic,"['combinatorics', 'dp', 'math']",524
"class Combination: def __init__(self, n, MOD): self.f = [1] for i in range(1, n + 1): self.f.append(self.f[-1] * i % MOD) self.inv_f = [0] * (n + 1) self.inv_f[n] = pow(self.f[n], MOD - 2, MOD) for i in reversed(range(n)): self.inv_f[i] = self.inv_f[i + 1] * (i + 1) % MOD self.MOD = MOD def inv(self, k): return (self.inv_f[k] * self.f[k - 1]) % self.MOD def fact(self, k): return self.f[k] def inv_fact(self, k): return self.inv_f[k] def perm(self, k, r): if k < r: return 0 return (self.f[k] * self.inv_f[k - r]) % self.MOD def comb(self, k, r): if k < r: return 0 return (self.f[k] * self.inv_f[k - r] * self.inv_f[r]) % self.MOD def combination(k, r, MOD): if k < r: return 0 r = min(r, k - r) numer, denom = 1, 1 for l in range(r): numer *= (k - l) numer %= MOD denom *= l + 1 denom %= MOD return numer * pow(denom, MOD - 2, MOD) % MOD import sys input = sys.stdin.buffer.readline n, MOD = map(int, input().split()) comb = Combination(10 ** 5, MOD) dp = [[0] * (n + 1) for i in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): dp[i][i] = pow(2, (i - 1), MOD) pows = [pow(2, i, MOD) for i in range(n + 10)] for i in range(n + 1): for times in range(max(i // 2, 1), i + 1): for length in range(1, times + 1): nokori = times - length ptn = pows[length - 1] ptn *= comb.fact(times) * comb.inv_fact(nokori) * comb.inv_fact(length) if i - length == 1: continue dp[i][times] += ptn * dp[i - length - 1][nokori] dp[i][times] %= MOD print(sum(dp[-1]) % MOD)",cubic,"['combinatorics', 'dp', 'math']",1458
"N, M = map(int, input().split()) fac = [1] + [0] * N for i in range(1, N + 1): fac[i] = fac[i - 1] * i % M fac_inv = [0] * N + [pow(fac[N], M - 2, M)] for i in range(N, 0, -1): fac_inv[i - 1] = fac_inv[i] * i % M pow2 = [1] + [0] * N for i in range(N): pow2[i + 1] = pow2[i] * 2 % M DP = [[0] * N for _ in range(N + 2)] DP[0][0] = 1 for i in range(N): for j in range(N): DP[i][j] %= M if DP[i][j]: for k in range(i + 2, N + 2): DP[k][j + 1] += DP[i][j] * fac_inv[k - i - 1] % M * pow2[k - i - 2] % M ans = 0 for j in range(N): DP[N + 1][j] %= M if DP[N + 1][j]: ans += DP[N + 1][j] * fac[N - j + 1] % M print(ans % M)",cubic,"['combinatorics', 'dp', 'math']",617
"import sys input = sys.stdin.readline n, m = map(int, input().split()) MOD = m MAX_N = 10**3 fac = [1] + [0] * MAX_N for i in range(1, MAX_N+1): fac[i] = fac[i-1] * (i) % MOD fac_inv = [1] + [0] * MAX_N fac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD) for i in range(MAX_N, 1, -1): fac_inv[i-1] = fac_inv[i] * i % MOD def mod_nCr(n, r): if n < r or n < 0 or r < 0: return 0 tmp = fac_inv[n-r] * fac_inv[r] % MOD return tmp * fac[n] % MOD pow2 = [0] * (n+1) pow2[0] = 1 for i in range(1, n+1): pow2[i] = pow2[i-1] * 2 % MOD table = [[0] * 500 for _ in range(500)] for i in range(500): for j in range(i+1): table[i][j] = mod_nCr(i, j) dp = [[0] * (n+1) for _ in range(n)] for i in range(n): dp[i][i+1] = pow2[i] for i in range(n-1): for j in range(i // 2 + 1, n-1): if dp[i][j] == 0: continue dp[i][j] %= MOD for k in range(1, n-j): if i + k + 1 >= n: break dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k] ans = sum(dp[-1]) % MOD print(ans)",cubic,"['combinatorics', 'dp', 'math']",943
"from math import factorial n, mod = map(int, input().split()) def binom(n, m): return factorial(n) // factorial(m) // factorial(n-m) def foo(x, k): ans = 0 for i in range(k, 0, -1):sign = 1 if (i-k)%2 == 0 else -1;ans += sign * binom(k, i) * (i**x);ans %= mod return ans def f(x, k): return (foo(x, k) * pow(2, x-k, mod)) % mod ans = 0 for i in range((n+1)//2):ans = (ans + f(n-i, i+1));ans %= mod print(ans)",cubic,"['combinatorics', 'dp', 'math']",408
"N = 405 n, m = map(int, input().split()) dp = [[0]*N for _ in range(N)] c = [[1]*N for _ in range(N)] p = [0]*N p[0] = 1 for i in range(1, N): p[i] = (p[i-1]*2) % m for i in range(1, N): for j in range(1, i): c[i][j] = (c[i-1][j-1] + c[i-1][j]) % m dp[0][0] = 1 for i in range(2, n+2): for x in range(1, (n-1)//2 + 2): for k in range(1, i): dp[i][x] = (dp[i][x] + ((dp[i-k-1][x-1]*p[k-1]) % m) * c[i-x][k]) % m ans = 0 for i in range(1, (n-1)//2 + 2): ans = (ans + dp[n+1][i]) % m print(ans)",cubic,"['combinatorics', 'dp', 'math']",491
"n, mod = map(int, input().split()) le = 500 def pow(x, y): ans = 1 while y > 0: if y % 2 == 1: ans = (ans * x) % mod x = (x**2) % mod y //= 2 return ans def inv(x): return pow(x, mod-2) M = [1] mul = 1 for i in range(1, le): mul = (mul * i) % mod M.append(mul) L0 = n//2+3 L1 = n+1 D = [[0 for i in range(L1)] for j in range(L0)] ND = [[0 for i in range(L1)] for j in range(L0)] INVS = [0] + [inv(i) for i in range(1, n+1)] D[1][1] = 1 for z in range(2, n+1): l0 = z//2+3 l1 = z+1 for i in range(l0): for j in range(l1): ND[i][j] = 0 for i in range(l0): if i >= 1: ND[i][1] += D[i-1][0] * (z-(i-1)) ND[i][1] %= mod for i in range(l0): for j in range(1, n+1): ND[i][0] += D[i][j] ND[i][0] %= mod for i in range(l0): for j in range(l1): if j >= 2: p = D[i][j-1] p *= (z-(i-1)) p %= mod p *= INVS[j] * 2 p %= mod ND[i][j] += p ND[i][j] %= mod for i in range(l0): for j in range(l1): D[i][j] = ND[i][j] ans = 0 for i in range(L0): for j in range(1, L1): ans += D[i][j] ans %= mod print(ans)",cubic,"['combinatorics', 'dp', 'math']",986
"import sys from collections import deque from queue import PriorityQueue from math import gcd from math import log from math import ceil from math import pi input_ = lambda: sys.stdin.readline().strip(""\r\n"") ii = lambda : int(input_()) il = lambda : list(map(int, input_().split())) ilf = lambda : list(map(float, input_().split())) ip = lambda : input_() fi = lambda : float(input_()) ap = lambda ab,bc,cd : ab[bc].append(cd) li = lambda : list(input_()) pr = lambda x : print(x) prinT = lambda x : print(x) f = lambda : sys.stdout.flush() mod = 10**9 + 7 n,mod = il() N = 406 fact = [1 for i in range (N)] inver = [1 for i in range (N)] power2 = [1 for i in range (N)] ncr = [[1 for i in range (N)] for j in range (N)] dp = [[0 for i in range (N)] for j in range (N)] def precom() : fact[0] = 1 inver[0] = 1 for i in range (1,N) : fact[i] = (fact[i-1]*i)%mod inver[i] = pow(fact[i],mod-2,mod) for i in range (N) : for j in range (i+1) : ncr[i][j] = (((fact[i]*inver[j])%mod)*inver[i-j])%mod for i in range(1,N) : power2[i] = (power2[i-1]*2)%mod precom() dp[0][0] = 1 for i in range (n) : for j in range (i+1) : k = 1 while (k+i <= n) : dp[i+k+1][j+k] = (dp[i+k+1][j+k] + ((dp[i][j]*power2[k-1])%mod*ncr[j+k][k])%mod)%mod k += 1 ans = 0 for i in range (n+1) : ans = (ans + dp[n+1][i])%mod print(ans)",cubic,"['combinatorics', 'dp', 'math']",1301
"import sys def input(): return sys.stdin.readline().strip() n, mod = map(int, input().split()) le = 405 def pow(x, y): ans = 1 while y > 0: if y % 2 == 1: ans = (ans * x) % mod x = (x**2) % mod y //= 2 return ans def inv(x): return pow(x, mod-2) M = [1] mul = 1 for i in range(1, le): mul = (mul * i) % mod M.append(mul) MI = [0] * (le-1) + [inv(M[le-1])] for i in range(le-2, -1, -1): MI[i] = MI[i+1] * (i+1) % mod def C(x, y): if y < 0 or y > x: return 0 elif x > le: y = min(y, x-y) ans = 1 for i in range(x, x-y, -1): ans = (ans * i) % mod return (ans * MI[y]) % mod else: ans = M[x] ans = (ans * MI[y]) % mod return (ans * MI[x-y]) % mod M2 = [1] for i in range(n+5): M2.append((M2[-1]*2) % mod) CO = [[0] * (n+5) for i in range(n+5)] for i in range(n+5): for j in range(n+5): CO[i][j] = C(i, j) D = [[0] * (n+1) for i in range(n+2)] D[0][0] = 1 for i in range(n+2): for j in range(i//2, min(n+1, i+1)): for k in range(1, min(n+1, n-i+1, n-j+1)): ind0 = i+k+1 ind1 = j+k if ind0 <= n+1 and ind1 <= n: D[ind0][ind1] += D[i][j] * CO[j+k][k] * M2[k-1] D[ind0][ind1] %= mod print(sum(D[-1]) % mod)",cubic,"['combinatorics', 'dp', 'math']",1098
"N, MOD = map(int,input().split()) dp = [] comps = [0]*(N+1) ncr = [[1]] for i in range(420): tmp = [1] for j in range(i): tmp.append((ncr[i][j] + ncr[i][j+1]) % MOD) tmp.append(1) ncr.append(tmp) for i in range(N): curr = list(comps) curr[1] = pow(2,i,MOD) for j in range(i - 1): m = pow(2,i - j - 2) for k in range(N): num = j - k + 2 if num < 0: continue mr = (m * ncr[i - j - 1 + num][num]) % MOD curr[k + 1] += mr * dp[j][k] curr[k + 1] %= MOD dp.append(curr) print(sum(dp[-1]) % MOD)",cubic,"['combinatorics', 'dp', 'math']",488
"import sys input = sys.stdin.readline n, mod = map(int, input().split()) fac = [1] + [0] * (n + 1) inv = [1] + [0] * (n + 1) C = [[0] * (n + 2) for _ in range(n + 2)] p2 = [1] + [0] * (n + 1) for i in range(1, n + 2): fac[i] = fac[i - 1] * i % mod p2[i] = p2[i - 1] * 2 % mod inv[-1] = pow(fac[-1], mod - 2, mod) for i in range(n, 0, -1): inv[i] = inv[i + 1] * (i + 1) % mod for i in range(n + 2): for j in range(i + 1): C[i][j] = fac[i] * inv[j] % mod * inv[i - j] % mod dp = [[0] * (n + 2) for _ in range(n + 2)] dp[0][0] = 1 for i in range(n): for j in range(i + 1): for k in range(1, n - i + 1): dp[i + k + 1][j + k] += dp[i][j] * p2[k - 1] % mod * C[j + k][k] % mod dp[i + k + 1][j + k] %= mod ans = 0 for i in range(n + 1): ans = (ans + dp[n + 1][i]) % mod print(ans)",cubic,"['combinatorics', 'dp', 'math']",773
"N, MOD = map(int, input().split()) dp = [[0]*(N+2) for i in range(N+2)] dp[0][0] = 1 limit = 1000 frac = [1]*limit for i in range(2,limit): frac[i] = i * frac[i-1]%MOD fraci = [None]*limit fraci[-1] = pow(frac[-1], MOD -2, MOD) for i in range(-2, -limit-1, -1): fraci[i] = fraci[i+1] * (limit + i + 1) % MOD bb = [1, 2] for i in range(1000): bb.append(bb[-1] *2 %MOD) for ln in range(N+1): for cnt in range(ln//2, ln+1): for k in range(1, N-ln+1): cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD dp[ln+k+1][cnt+k] %= MOD R = 0 for x in dp[N+1][:N+1]: R = (R+x)%MOD print(R)",cubic,"['combinatorics', 'dp', 'math']",637
"import sys f = sys.stdin def line(): return f.readline().strip().split() def powers(limit): size = limit+1 p = [1]*size for n in range(1,size): p[n] = 2*p[n-1] % M return p def binomials(limit): size = limit+1 bc = [[0 for k in range(size)] for n in range(size)] for n in range(size): bc[n][0]=1 for n in range(1,size): for k in range(1,n+1): bc[n][k] = bc[n-1][k-1] + bc[n-1][k] bc[n][k] %= M return bc def solve(): dp = [[0 for _ in range(N)] for _ in range(N)] dp[0][0]=1 for i in range(1,N): for k in range(1,i): for j in range(1,i): dp[i][j] += BC[j+1][i-k] * dp[k-1][j-1-(i-k-1)] * POW[i-k-1] dp[i][j] %= M dp[i][i] = POW[i] res=0 for j in range(0,N): res = (res + dp[N-1][j]) % M return str(res) T = 1 for test in range(1,T+1): N,M = map(int,line()) BC = binomials(N) POW = powers(N) print(solve()) f.close()",cubic,"['combinatorics', 'dp', 'math']",815
"import sys f = sys.stdin def line(): return f.readline().strip().split() def powers(limit): size = limit+1 p = [1]*size for n in range(1,size): p[n] = (2*p[n-1]) % M return p def binomials(limit): size = limit+1 bc = [[0 for k in range(size)] for n in range(size)] for n in range(size): bc[n][0]=1 for n in range(1,size): for k in range(1,n+1): bc[n][k] = bc[n-1][k-1] + bc[n-1][k] bc[n][k] %= M return bc def solve(): size = N+1 dp = [[0 for _ in range(size)] for _ in range(size)] dp[1][0]=1 for i in range(2,size): for k in range(1,i): for j in range(1,k): dp[i][j] += BC[i-j][k-j] * dp[k-1][j-1] * POW[i-k-1] dp[i][j] %= M dp[i][0] = POW[i-1] res=0 for j in range(0,N-1): res = (res + dp[N][j]) % M return str(res) T = 1 for test in range(1,T+1): N,M = map(int,line()) BC = binomials(N) POW = powers(N) print(solve()) f.close()",cubic,"['combinatorics', 'dp', 'math']",831
"inp = input().split() totNums, mod = int(inp[0]), int(inp[1]) def Exp(b,exp): if exp==0: return 1 temp = Exp(b,exp>>1)**2 if exp%2==1: temp*=b return temp%mod n = 410 fact, inv = [0 for i in range(n)],[0 for i in range(n)] fact[0] = inv[0] = 1; for i in range(1,totNums+1): fact[i] = fact[i-1]*i%mod inv[i] = Exp(fact[i],mod-2) dp, choose = [[0 for i in range(n)] for j in range(n)], [[0 for i in range(n)] for j in range(n)] for i in range(0,totNums+1): for j in range(0,i+1): choose[i][j] = fact[i]*inv[j]*inv[i-j]%mod pow2 = [Exp(2,i) for i in range(n)] dp[0][0] = 1 for i in range(totNums): for j in range(i+1): for k in range(1,totNums-i+1): dp[i+k+1][j+k] += dp[i][j]*pow2[k-1]*choose[j+k][k] dp[i+k+1][j+k] %= mod ans = 0 for i in range(0,totNums+1): ans = (ans+dp[totNums+1][i])%mod print(ans)",cubic,"['combinatorics', 'dp', 'math']",801
"import string from collections import deque, Counter from functools import lru_cache import math DEBUG = 0 def main(): T = 1 while T: n, M = Input.read_typed(int) N = n f = [[0 for _ in range(n+1)] for _ in range(n+1)] comb = [[0 for _ in range(n+1)] for _ in range(n+1)] fact = [0] * (n+1) inv = [0] * (n+1) fact[0] = inv[0] = 1 for i in range(1, n+1): fact[i] = (fact[i-1] * i) % M inv[i] = pow(fact[i], M-2, M) for i in range(0, n+1): for j in range(0, i+1): comb[i][j] = ((fact[i] * inv[j]) % M * inv[i-j]) % M pow2 = [0] * (n+1) pow2[0] = 1 for i in range(1, n+1): pow2[i] = pow2[i-1]*2 % M f[i][i] = pow2[i-1] for total in range(1, n+1): for manual in range(1, total): if total > manual * 2 or total < manual: continue for l in range(1, manual): f[total][manual] += f[total-l-1][manual-l] * pow2[l-1] * comb[manual][l] f[total][manual] %= M c = 0 for i in range(1, n+1): c += f[n][i] print(c % M) T -= 1 class Input: def __init__(self): pass @staticmethod def read_typed(cls): return list(map(cls, input().split())) @staticmethod def read(): return input() class Debug(): def __init__(self): import sys sys.stdout = open('output.out', 'w') sys.stdin = open('input.in', 'r') def __delete__(self): sys.stdout.close() sys.stdin.close() def run(): if DEBUG: _ = Debug() main() run()",cubic,"['combinatorics', 'dp', 'math']",1284
"import os,sys from io import BytesIO,IOBase from array import array def main(): n,M = map(int,input().split()) comb = [[0]*(n+1) for _ in range(n+1)] comb[0][0] = 1 for i in range(1,n+1): for j in range(i+1): comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%M dp = [array('i',[0]*(n+1)) for _ in range(n+1)] for i in range(1,n+1): dp[i][0] = pow(2,i-1,M) for j in range(1,n+1): for i in range(3,n+1): for x in range(1,i-1): dp[i][j] = (dp[i][j]+dp[i-1-x][j-1]*dp[x][0]*comb[i-j][x])%M su = 0 for i in range(n+1): su = (su+dp[n][i])%M print(su) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self,file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) self.newlines = b.count(b""\n"")+(not b) ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd,self.buffer.getvalue()) self.buffer.truncate(0),self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self,file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s:self.buffer.write(s.encode(""ascii"")) self.read = lambda:self.buffer.read().decode(""ascii"") self.readline = lambda:self.buffer.readline().decode(""ascii"") sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout) input = lambda:sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",cubic,"['combinatorics', 'dp', 'math']",1894
"n, M = map(int,input().split()) combdic = {} def fastfrac(a,b,M): numb = pow(b,M-2,M) return ((a%M)*(numb%M))%M def comb(p,q): if p==1: return q if (p,q) in combdic: return combdic[(p,q)] output = (comb(p-1,q-1)*q)%M output = fastfrac(output,p,M) combdic[(p,q)] = output return output def getnext(i,j,dic): if 2*j+1>i: return 0 if (i,j) in dic: return dic[(i,j)] if j==0: dic[(i,j)] = (1<<(i-1))%M return dic[(i,j)] output = 0 for k in range(2,i): if 2*j-1>i-k: break output += (getnext(i-k,j-1,dic)*getnext(k-1,0,dic))%M*comb(k-1,i-j) output = output%M dic[(i,j)] = output return output dic = {} ans = 0 dp = [[0 for j in range(n//2+3)] for i in range(n+1)] for i in range(1,n+1): dp[i][0] = (1<<(i-1))%M for j in range(1,n+1): if 2*j+1>i: break for k in range(2,i): if 2*j-1>i-k: break dp[i][j] += ((dp[i-k][j-1] * dp[k-1][0])%M * comb(k-1,i-j))%M dp[i][j] = dp[i][j]%M ans = 0 for j in range(n): if 2*j+1>i: break ans += dp[n][j] ans = ans%M print(ans)",cubic,"['combinatorics', 'dp', 'math']",955
"n, m, k = map(int, input().split()) reb1 = [list(map(int, input().split())) for i in range(n)] reb2 = [list(map(int, input().split())) for i in range(n - 1)] if k % 2: for i in range(n): for j in range(m): print(-1, end="" "") print() exit(0) minsum = [[0] * m for i in range(n)] nminsum = [[0] * m for i in range(n)] for it in range(k // 2): for i in range(n): for j in range(m): cmin = 1000000000010 if i != 0: cmin = min(cmin, minsum[i - 1][j] + reb2[i - 1][j]) if i != n - 1: cmin = min(cmin, minsum[i + 1][j] + reb2[i][j]) if j != 0: cmin = min(cmin, minsum[i][j - 1] + reb1[i][j - 1]) if j != m - 1: cmin = min(cmin, minsum[i][j + 1] + reb1[i][j]) nminsum[i][j] = cmin for i in range(n): for j in range(m): minsum[i][j] = nminsum[i][j] for i in minsum: for j in i: print(j * 2, end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",798
"import sys input = lambda: sys.stdin.readline().rstrip() N, M, K = map(int, input().split()) if K % 2: for _ in range(N): print(*[-1] * M) exit() A = [[int(a) for a in input().split()] for _ in range(N)] B = [[int(a) for a in input().split()] for _ in range(N-1)] X = [[0] * M for _ in range(N)] inf = 1 << 30 for k in range(1, K // 2 + 1): nX = [[inf] * M for _ in range(N)] for i in range(N): for j in range(M): if i: nX[i][j] = min(nX[i][j], X[i-1][j] + B[i-1][j]) if i < N - 1: nX[i][j] = min(nX[i][j], X[i+1][j] + B[i][j]) if j: nX[i][j] = min(nX[i][j], X[i][j-1] + A[i][j-1]) if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j+1] + A[i][j]) X = nX for x in X: print(*[a * 2 for a in x])",cubic,"['dp', 'graphs', 'shortest paths']",687
"from sys import stdin, stdout from collections import defaultdict n, m, k = map(int, stdin.readline().split()) dic = defaultdict(lambda : {}) for i in range(n): line = tuple(map(int, stdin.readline().split())) for j in range(m-1): dic[i*m+j][i*m+j+1] = line[j]*2 dic[i*m+j+1][i*m+j] = line[j]*2 for i in range(n-1): line = tuple(map(int, stdin.readline().split())) for j in range(m): dic[i*m+j][(i+1)*m+j] = line[j]*2 dic[(i+1)*m+j][i*m+j] = line[j]*2 if k % 2 != 0: for i in range(n): stdout.write(' '.join(('-1',)*m)) stdout.write('\n') else: prev = [] di = (1, 0, -1, 0) dj = (0, 1, 0, -1) for _ in range(n): prev.append((0,)*m) for _ in range(k//2): new = [] for _ in range(n): new.append([100_000_000]*m) for num in dic: i = num // m j = num % m for idx in range(4): ii = i + di[idx] jj = j + dj[idx] if not ((0 <= ii < n) and (0 <= jj < m)): continue new[ii][jj] = min(new[ii][jj], prev[i][j] + dic[i*m+j][ii*m+jj]) prev = new for i in range(n): stdout.write(' '.join(map(str, prev[i]))) stdout.write('\n')",cubic,"['dp', 'graphs', 'shortest paths']",1012
"from bisect import bisect,bisect_left from collections import * from math import gcd,ceil,sqrt,floor,inf from heapq import * from itertools import * from operator import add,mul,sub,xor,truediv,floordiv from functools import * import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def RL(): return map(int, sys.stdin.readline().split()) def RLL(): return list(map(int, sys.stdin.readline().split())) def N(): return int(input()) def A(n):return [0]*n def AI(n,x): return [x]*n def A2(n,m): return [[0]*m for i in range(n)] def G(n): return [[] for i in range(n)] def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)] from types import GeneratorType",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import sys, os if os.environ['USERNAME']=='kissz': inp=open('in.txt','r').readline def debug(*args): print(*args,file=sys.stderr) else: inp=sys.stdin.readline def debug(*args): pass n,m,k=map(int,inp().split()) A=[[*map(int,inp().split())] for _ in range(n)] B=[[*map(int,inp().split())] for _ in range(n-1)] if k%2==0: O=[[[1e12]*m for _ in range(n)] for _ in range(k//2)] for i in range(n): for j in range(m): if i>0: O[0][i][j]=min(O[0][i][j],B[i-1][j]) if i<n-1: O[0][i][j]=min(O[0][i][j],B[i][j]) if j>0: O[0][i][j]=min(O[0][i][j],A[i][j-1]) if j<m-1: O[0][i][j]=min(O[0][i][j],A[i][j]) for l in range(1,k//2): for i in range(n): for j in range(m): if i>0: O[l][i][j]=min(O[l][i][j],B[i-1][j]+O[l-1][i-1][j]) if i<n-1: O[l][i][j]=min(O[l][i][j],B[i][j]+O[l-1][i+1][j]) if j>0: O[l][i][j]=min(O[l][i][j],A[i][j-1]+O[l-1][i][j-1]) if j<m-1: O[l][i][j]=min(O[l][i][j],A[i][j]+O[l-1][i][j+1]) for i in range(n): print(*[O[-1][i][j]*2 for j in range(m)]) else: for i in range(n): print(*[-1]*m)",cubic,"['dp', 'graphs', 'shortest paths']",994
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=0, func=lambda a, b: a+b): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = self._default",cubic,"['dp', 'graphs', 'shortest paths']",1999
"from sys import stdin input=stdin.readline n,m,k=map(int,input().split()) lr=[list(map(int,input().split())) for i in range(n)] ud=[list(map(int,input().split())) for i in range(n-1)] if k%2: arr=[-1]*m for i in range(n): print(*arr) exit() kk=k//2 dp=[[[10**10]*(kk+1) for i in range(m)] for j in range(n)] for i in range(n): for j in range(m): dp[i][j][0]=0 for z in range(1,kk+1): for i in range(n): for j in range(m): if i>0: dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-1]+ud[i-1][j]) if i<n-1: dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-1]+ud[i][j]) if j>0: dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-1]+lr[i][j-1]) if j<m-1: dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-1]+lr[i][j]) ans=[[dp[i][j][kk]*2 for j in range(m)] for i in range(n)] for i in range(n): print(*ans[i])",cubic,"['dp', 'graphs', 'shortest paths']",770
"from io import BytesIO, IOBase import sys import math import os from collections import defaultdict from math import ceil from bisect import bisect_left, bisect_left BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def input(): return sys.stdin.readline().rstrip(""\r\n"") def mint(): return map(int, input().split()) def mfloat(): return map(float, input().split()) def solve(): n, m, k = mint() horizontal = [list(mint()) for i in range(n)] vertical = [list(mint()) for i in range(n-1)] if k%2 or max(n, m)==1: for i in range(n): print(*[-1]*m) return dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)] for length in range(1, k//2+1): for i in range(n): for j in range(m): left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1] r",cubic,"['dp', 'graphs', 'shortest paths']",1999
"from sys import stdin input=stdin.readline rn=lambda:int(input()) rns=lambda:map(int,input().split()) rl=lambda:list(map(int,input().split())) rs=lambda:input() YN=lambda x:print('YES') if x else print('NO') mod=10**9+7 n,m,k=rns() rows=[rl() for i in range(n)] cols=[rl() for i in range(n-1)] def solve(): if k%2==1: return [m*[-1] for i in range(n)] dp=[[[0 for i in range(k//2+1)] for j in range(m)] for l in range(n)] for i in range(1,k//2+1): for a in range(n): for b in range(m): mins=[] if b>0: mins.append(dp[a][b-1][i-1] + 2*rows[a][b-1]) if b<m-1: mins.append(dp[a][b + 1][i - 1] + 2 * rows[a][b]) if a>0: mins.append(dp[a-1][b][i - 1] + 2 * cols[a-1][b]) if a<n-1: mins.append(dp[a+1][b][i - 1] + 2 * cols[a][b]) dp[a][b][i]=min(mins) ans=[[dp[i][j][-1] for j in range(m)] for i in range(n)] return ans ans = solve() for i in ans: print(*i)",cubic,"['dp', 'graphs', 'shortest paths']",851
"import sys input = sys.stdin.readline n,m,k=map(int,input().split()) YOKO=[list(map(int,input().split())) for i in range(n)] TATE=[list(map(int,input().split())) for i in range(n-1)] if k%2==1: for i in range(n): print(*[-1]*m) exit() DP=[[0]*m for i in range(n)] for i in range(n): for j in range(m): MIN=1<<30 if j-1>=0: MIN=min(MIN,YOKO[i][j-1]*2) if j<m-1: MIN=min(MIN,YOKO[i][j]*2) if i-1>=0: MIN=min(MIN,TATE[i-1][j]*2) if i<n-1: MIN=min(MIN,TATE[i][j]*2) DP[i][j]=MIN DP0=DP[:] for tests in range(k//2-1): NDP=[[0]*m for i in range(n)] for i in range(n): for j in range(m): MIN=DP[i][j]+DP0[i][j] if 0<=i+1<n: MIN=min(MIN,TATE[i][j]*2+DP[i+1][j]) if 0<=i-1<n: MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j]) if 0<=j+1<m: MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1]) if 0<=j-1<m: MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1]) NDP[i][j]=MIN DP=NDP for dp in DP: print(*dp)",cubic,"['dp', 'graphs', 'shortest paths']",853
"import io import os from collections import Counter, defaultdict, deque def solve(N, M, K, right, down): if K % 2 == 1: return ((""-1 "" * N) + ""\n"") * M K //= 2 inf = float(""inf"") R = N C = M for row in right: row.append(inf) row.append(inf) row.append(inf) right.append([inf] * (C + 2)) right.append([inf] * (C + 2)) for row in down: row.append(inf) row.append(inf) down.append([inf] * (C + 2)) down.append([inf] * (C + 2)) down.append([inf] * (C + 2)) def right_(r, c): return right[r][c - 1] def down_(r, c): return down[r - 1][c] def left(r, c): return right[r][c] def up(r, c): return down[r][c] dist = [[inf for i in range(C + 2)] for j in range(R + 2)] for r in range(R): for c in range(C): dist[r][c] = 0 for k in range(K): nextDist = [[inf for i in range(C + 2)] for j in range(R + 2)] for r in range(R): for c in range(C): nextDist[r][c] = min( dist[r][c - 1] + right_(r, c), dist[r][c + 1] + left(r, c), dist[r - 1][c] + down_(r, c), dist[r + 1][c] + up(r, c), ) dist = nextDist return ""\n"".join("" "".join(str(2 * dist[r][c]) for c in range(C)) for r in range(R)) DEBUG = False if DEBUG: import random random.seed(0) for _ in range(1): N = 500 M = 500 K = 20 def pack(i, j): return i * M + j def unpack(ij): return divmod(ij, M) graph = [[] for i in range(N * M)] right = [[random.randint(1, 10 ** 6) for j in range(M - 1)] for i in range(N)] down = [[random.randint(1, 10 ** 6) for j in range(M)] for i in range(N - 1)] print(""tc"" + str(_)) ans = solve(N, M, K, right, down) exit() if __name__ == ""__main__"": input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline def pack(i, j): return i * M + j def unpack(ij): return divmod(ij, M) N, M, K = [int(x) for x in input().split()] right = [[int(x) for x in input().split()] for i in range(N)] down = [[int(x) for x in input().split()] for i in range(N - 1)] ans = solve(N, M, K, right, down) print(ans)",cubic,"['dp', 'graphs', 'shortest paths']",1865
"from copy import deepcopy def sol(n,m,k,aa,bb): if k&1: return [[-1] * m] * n ans = [[float('inf')]*(m+2) for _ in range(n+2)] k >>= 1 for i in range(1,n+1): for j in range(1,m+1): ans[i][j] = min(aa[i][j], aa[i][j-1], bb[i][j], bb[i-1][j]) for _ in range(k-1): oans = deepcopy(ans) for i in range(1,n+1): for j in range(1,m+1): ans[i][j] = min( aa[i][j]+oans[i][j+1], aa[i][j-1]+oans[i][j-1], bb[i][j]+oans[i+1][j], bb[i-1][j]+oans[i-1][j]) ans = ans[1:-1] ans = [x[1:-1] for x in ans] ans = [[2*x for x in a] for a in ans] return ans n,m,k = map(int, input().split()) aa = [list(map(int, input().split())) for _ in range(n)] inf = float('inf') bb = [list(map(int, input().split())) for _ in range(n-1)] aa = [[inf, *x, inf] for x in aa] bb = [[inf, *x, inf] for x in bb] pad = [inf] * (m+1) aa = [pad, *aa, pad] pad = [inf] * (m+2) bb = [pad, *bb, pad] ans = sol(n,m,k,aa,bb) print('\n'.join(' '.join(map(str, a)) for a in ans))",cubic,"['dp', 'graphs', 'shortest paths']",930
"import sys input = sys.stdin.readline n, m, k = map(int, input().split()) ej = [list(map(int, input().split())) for _ in range(n)] ei = [list(map(int, input().split())) for _ in range(n - 1)] if k % 2: for _ in range(n): print(*[-1] * m) exit(0) inf = -1 dp = [[inf] * (n * m) for _ in range(k // 2 + 1)] for t in range(n * m): dp[0][t] = 0 for c in range(k // 2): for i in range(n): for j in range(m): t = i * m + j tt = (i + 1) * m + j if i + 1 < n and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ei[i][j]): dp[c + 1][tt] = dp[c][t] + ei[i][j] tt = i * m + j + 1 if j + 1 < m and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ej[i][j]): dp[c + 1][tt] = dp[c][t] + ej[i][j] tt = (i - 1) * m + j if i - 1 >= 0 and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ei[i - 1][j]): dp[c + 1][tt] = dp[c][t] + ei[i - 1][j] tt = i * m + j - 1 if j - 1 >= 0 and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ej[i][j - 1]): dp[c + 1][tt] = dp[c][t] + ej[i][j - 1] res = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): res[i][j] = dp[-1][i * m + j] * 2 print(*res[i])",cubic,"['dp', 'graphs', 'shortest paths']",1095
"import sys input=sys.stdin.readline n,m,k=map(int,input().strip().split("" "")) lr=[] for i in range(n): lr.append([100000001]+list(map(int,input().strip().split("" "")))+[100000001]) ud=[[100000001]*m] for i in range(n-1): ud.append(list(map(int,input().strip().split("" "")))) ud.append([100000001]*m) o=[[1000000001]*(m+2)] from copy import deepcopy if k%2: for i in range(n): sys.stdout.write("" "".join([""-1""]*m)+""\n"") sys.exit() for _ in range(n): oo=[100000001] for _ in range(m): oo.append(0) oo.append(100000001) o.append(oo) o.append([100000001]*(m+2)) for _ in range(k//2): oo=deepcopy(o) for i in range(1,n+1): for j in range(1,m+1): oo[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j]) o=deepcopy(oo) for i in o[1:n+1]: sys.stdout.write("" "".join(map(str,[j*2 for j in i[1:m+1]]))+""\n"")",cubic,"['dp', 'graphs', 'shortest paths']",839
"from collections import defaultdict import sys input = sys.stdin.readline n, m, k = map(int, input().split()) a = [list(map(int, input().split())) for _ in range(n)] b = [list(map(int, input().split())) for _ in range(n - 1)] if k % 2: ans = [-1] * m for _ in range(n): print(*ans) exit() G = [[] for _ in range(n * m + 1)] for i in range(n): a0 = a[i] for j in range(m - 1): x = a0[j] G[i * m + j].append((i * m + j + 1, x)) G[i * m + j + 1].append((i * m + j, x)) for i in range(n - 1): b0 = b[i] for j in range(m): x = b0[j] G[i * m + j].append(((i + 1) * m + j, x)) G[(i + 1) * m + j].append((i * m + j, x)) dp = [[0] * m for _ in range(n)] dp0 = [[0] * m for _ in range(n)] dp, dp0 = [0] * (n * m), [0] * (n * m) v = [(1, 0), (-1, 0), (0, 1), (0, -1)] inf = 1145141919 for i in range(n): for j in range(m): s = i * m + j dps = inf for t, x in G[s]: dps = min(dps, 2 * x) dp[s] = dps dp0[s] = dps for _ in range((k - 2) // 2): dp1 = [0] * (n * m) for i in range(n): for j in range(m): s = i * m + j dps = dp0[s] + 2 * dp[s] for t, x in G[s]: dps = min(dps, 2 * x + dp0[t]) dp1[s] = dps dp0 = dp1 for i in range(n): ans = dp0[(m * i):(m * (i + 1))] print(*ans)",cubic,"['dp', 'graphs', 'shortest paths']",1163
"import sys input = lambda: sys.stdin.readline().rstrip() def solve(): n, m, k = map(int, input().split()) a = [] b = [] for i in range(n): a.append(list(map(int, input().split()))) for i in range(n-1): b.append(list(map(int, input().split()))) if k % 2: ans = [-1] * m for i in range(n): print(*ans) return k //= 2 pre = [[0]*m for i in range(n)] cur = [[10**9]*m for i in range(n)] for _ in range(k): cur = [[10**9] * m for i in range(n)] for i in range(n): for j in range(m): if i: cur[i][j] = min(cur[i][j], pre[i-1][j]+b[i-1][j]) if i < n - 1: cur[i][j] = min(cur[i][j], pre[i+1][j]+b[i][j]) if j: cur[i][j] = min(cur[i][j], pre[i][j-1]+a[i][j-1]) if j < m - 1: cur[i][j] = min(cur[i][j], pre[i][j+1]+a[i][j]) pre = cur for i in range(n): cur[i] = [cur[i][j]*2 for j in range(m)] print(*cur[i]) solve()",cubic,"['dp', 'graphs', 'shortest paths']",806
"input = __import__('sys').stdin.readline n,m,k = map(int, input().split()) hor = [[int(x) for x in input().split()] for _ in ' ' * n] ver = [[int(x) for x in input().split()] for _ in ' ' * (n - 1)] if k % 2: for i in ' ' * n: print('-1 ' * m) exit() mtx_old = [[0] * m for _ in ' ' * n] def neighbours(x, y): a = 1e18 b = 1e18 c = 1e18 d = 1e18 if x > 0: a = hor[y][x - 1] * 2 + mtx_old[y][x - 1] if x < m - 1: b = hor[y][x] * 2 + mtx_old[y][x + 1] if y > 0: c = ver[y - 1][x] * 2 + mtx_old[y - 1][x] if y < n - 1: d = ver[y][x] * 2 + mtx_old[y + 1][x] return min(a, b, c, d) for i in range(k // 2): mtx_new = [[0] * m for _ in ' ' * n] for x in range(m): for y in range(n): mtx_new[y][x] = neighbours(x, y) mtx_old = mtx_new for row in mtx_old: print(*row)",cubic,"['dp', 'graphs', 'shortest paths']",758
"n,m,k=list(map(int,input().split())) p=[] for _ in range(n): p.append(list(map(int,input().split()))) q=[] for _ in range(n-1): q.append(list(map(int,input().split()))) def f(g): r=[[0]*m for _ in range(n)] for i in range(n): for j in range(m): l=[] if i-1>=0: l.append(g[i-1][j]+q[i-1][j]) if i+1<n: l.append(g[i+1][j]+q[i][j]) if j-1>=0: l.append(g[i][j-1]+p[i][j-1]) if j+1<m: l.append(g[i][j+1]+p[i][j]) r[i][j]=min(l) return r g=[[0]*m for _ in range(n)] if k%2!=0: for i in range(n): for j in range(m): g[i][j]=-1 print(*g[i]) else: for _ in range(k//2): g=f(g) for i in range(n): for j in range(m): g[i][j]*=2 print(*g[i])",cubic,"['dp', 'graphs', 'shortest paths']",629
"import sys n,m,k = map(int,input().split()) if k%2: ans = [[-1]*m for _ in range(n)] for row in ans: print(*row) exit() A = [] B = [] inf = float('inf') for _ in range(n): A.append(list(map(int,input().split()))) for _ in range(n-1): B.append(list(map(int,input().split()))) dp = [[inf]*m for _ in range(n)] ans = [[None]*m for _ in range(n)] for l in range(k//2+1): new_dp = [[inf]*m for _ in range(n)] for i in range(n): for j in range(m): if l == 0: new_dp[i][j] = 0 continue up = B[i-1][j]*2 + dp[i-1][j] if i-1>=0 else inf right = A[i][j]*2 + dp[i][j+1] if j+1<m else inf left = A[i][j-1]*2 + dp[i][j-1] if j-1>=0 else inf down = B[i][j]*2 + dp[i+1][j] if i+1<n else inf new_dp[i][j] = min(up,right,left,down) if l == k//2: ans[i][j] = new_dp[i][j] dp = new_dp for row in ans: print(*row)",cubic,"['dp', 'graphs', 'shortest paths']",793
"import sys import math from itertools import product n,m,k = [int(i) for i in sys.stdin.readline().split()] horiz_costs = [[]]*n vert_costs = [[]]*(n-1) for i in range(n): horiz_costs[i] = [int(i) for i in sys.stdin.readline().split()] for i in range(n-1): vert_costs[i] = [int(i) for i in sys.stdin.readline().split()] if k%2 == 1: for _ in range(n): print("" "".join([""-1""]*m)) quit() ans = [[[0]*m for _ in range(n)] for _ in range(k//2+1)] def costs(i,j,ans,time): r = [] if j<m-1: r += [2*horiz_costs[i][j] + ans[time-1][i][j+1]] if j>0: r += [2*horiz_costs[i][j-1] + ans[time-1][i][j-1]] if i<n-1: r += [2*vert_costs[i][j] + ans[time-1][i+1][j]] if i>0: r += [2*vert_costs[i-1][j] + ans[time-1][i-1][j]] return r for time in range(1, k//2+1): for i in range(n): for j in range(m): cost = costs(i,j,ans, time) for c in cost: if ans[time][i][j] == 0 or c < ans[time][i][j]: ans[time][i][j] = c for i in range(n): print("" "".join([str(s) for s in ans[-1][i]]))",cubic,"['dp', 'graphs', 'shortest paths']",960
"import os import sys from io import BytesIO, IOBase def main(): n,m,k=map(int,input().split()) if (k%2==0): DP=[[[10**9 for i in range(m)] for j in range(n)] for v in range(k//2)] A=[] B=[] for i in range(n): L=list(map(int,input().split())) A.append(L) for j in range(m-1): DP[0][i][j]=min(DP[0][i][j],L[j]) DP[0][i][j+1]=min(L[j],DP[0][i][j+1]) for i in range(n-1): L=list(map(int,input().split())) B.append(L) for j in range(m): DP[0][i][j]=min(DP[0][i][j],L[j]) DP[0][i+1][j]=min(DP[0][i+1][j],L[j]) for k1 in range(1,k//2): for i in range(n): for j in range(m): if (i>0): DP[k1][i][j]=min(DP[k1][i][j],B[i-1][j]+DP[k1-1][i-1][j]) if (j>0): DP[k1][i][j]=min(DP[k1][i][j],A[i][j-1]+DP[k1-1][i][j-1]) if (i<(n-1)): DP[k1][i][j]=min(DP[k1][i][j],B[i][j]+DP[k1-1][i+1][j]) if (j<(m-1)): DP[k1][i][j]=min(DP[k1][i][j],A[i][j]+DP[k1-1][i][j+1]) for val in DP[(k//2)-1]: ans=[i*2 for i in val] print(*ans) else: for i in range(n): L=list(map(int,input().split())) for i in range(n-1): L=list(map(int,input().split())) for i in range(n): ans=[-1]*m print(*ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self",cubic,"['dp', 'graphs', 'shortest paths']",2000
"def helper(n,m,k): if k % 2 == 1: res = [[-1] * m for i in range(n)] return res k = k // 2 pool = [[[0]*m for i in range(n)] for j in range(k+1)] dx = [0,0,1,-1] dy = [1,-1,0,0] for t in range(1,k+1): for i in range(n): for j in range(m): tres = [9999999] * 4 for c in range(4): if 0 <= i+dx[c] < n and 0 <= j+dy[c] < m: if c == 0: tres[c] = hedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]] elif c == 1: tres[c] = hedge[i][j-1]*2 + pool[t-1][i+dx[c]][j+dy[c]] elif c == 2: tres[c] = vedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]] else: tres[c] = vedge[i-1][j]*2 + pool[t-1][i+dx[c]][j+dy[c]] pool[t][i][j] = min(tres) return pool[k] n,m,k = map(int,input().split("" "")) hedge = [] vedge = [] for i in range(n): hedge.append(list(map(int,input().split("" "")))) for i in range(n-1): vedge.append(list(map(int,input().split("" "")))) res = helper(n,m,k) for j in range(len(res)): print("" "".join(map(str,res[j])))",cubic,"['dp', 'graphs', 'shortest paths']",897
"from collections import deque from copy import deepcopy m,n,k = map(int,input().split()) horizon = [] for i in range(m): horizon.append( list(map(int,input().split())) ) vertical = [] for i in range(m-1): vertical.append( list(map(int,input().split())) ) if k%2==1: ans = [-1]*n for i in range(m): print("" "".join(map(str,ans))) exit() direc = [[0,-1],[0,1],[1,0],[-1,0]] ans = [[0 for j in range(n)] for i in range(m)] for t in range(k//2): tempans = deepcopy(ans) for i in range(m): for j in range(n): ans[i][j] = 2147483647 for d in range(4): neighi = i + direc[d][0] neighj = j + direc[d][1] if neighi<0 or neighi>=m or neighj<0 or neighj>=n: continue base = tempans[neighi][neighj] if d==0: base += 2 * horizon[neighi][neighj] if d==1: base += 2 * horizon[neighi][neighj-1] if d==2: base += 2 * vertical[neighi-1][neighj] if d==3: base += 2 * vertical[neighi][neighj] ans[i][j] = min(ans[i][j],base) for ele in ans: print("" "".join(map(str,ele)))",cubic,"['dp', 'graphs', 'shortest paths']",949
"import sys input = sys.stdin.readline n, m, k = map(int, input().split()) A = [[0] * (m) for _ in range(n)] B = [[0] * (m) for _ in range(n)] for i in range(n): tmp = list(map(int, input().split())) for j in range(m - 1): A[i][j + 1] = tmp[j] for i in range(n - 1): tmp = list(map(int, input().split())) for j in range(m): B[i + 1][j] = tmp[j] if k % 2: ans = [[-1] * m for _ in range(n)] for a in ans: print(*a) sys.exit() ans = [[0] * m for _ in range(n)] lim = k // 2 dp = [[[float(""inf"")] * (lim + 1) for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): dp[i][j][0] = 0 for k in range(1, lim + 1): for i in range(n): for j in range(m): if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j]) if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j]) if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j]) if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1]) for i in range(n): for j in range(m): ans[i][j] = dp[i][j][-1] * 2 for a in ans: print(*a)",cubic,"['dp', 'graphs', 'shortest paths']",1049
"from heapq import heappop, heappush n, m, k = [int(i) for i in input().split()] if k % 2 == 1: for _ in range(n): print("" "".join([""-1""] * m)) exit() E_right = [] for i in range(n): E_right.append([int(j) for j in input().split()]) E_down = [] for i in range(n - 1): E_down.append([int(j) for j in input().split()]) P = [[0 for _ in range(m)] for _ in range(n)] new_P = [[0 for _ in range(m)] for _ in range(n)] for k in range(k // 2 + 1): for i in range(n): for j in range(m): possible = [] if i - 1 >= 0: e = E_down[i - 1][j] possible.append(P[i - 1][j] + e) if i + 1 < n: e = E_down[i][j] possible.append(P[i + 1][j] + e) if j - 1 >= 0: e = E_right[i][j - 1] possible.append(P[i][j - 1] + e) if j + 1 < m: e = E_right[i][j] possible.append(P[i][j + 1] + e) new_P[i][j] = min(possible) tmp = P P = new_P new_P = tmp for i in range(n): print("" "".join(str(s * 2) for s in new_P[i]))",cubic,"['dp', 'graphs', 'shortest paths']",881
"def main(): high = 10 ** 12 n, m, k = map(int, input().split()) hozs = [] for i in range(n): hozs.append(list(map(int, input().split()))) verts = [] for i in range(n - 1): verts.append(list(map(int, input().split()))) if k % 2: for i in range(n): print(""-1 "" * m) return k //= 2 dp = [] for i in range(n): dp.append([]) for j in range(m): dp[-1].append([]) for kay in range(k + 1): dp[-1][-1].append(0) for depth in range(1, k + 1): for i in range(n): for j in range(m): if i == 0: up = high else: up = verts[i - 1][j] + dp[i - 1][j][depth - 1] if i == n - 1: down = high else: down = verts[i][j] + dp[i + 1][j][depth - 1] if j == 0: left = high else: left = hozs[i][j - 1] + dp[i][j - 1][depth - 1] if j == m - 1: right = high else: right = hozs[i][j] + dp[i][j + 1][depth - 1] min_cost = min(up, down, left, right) dp[i][j][depth] += min_cost for i in range(n): print(*[2 * dp[i][j][k] for j in range(m)]) main()",cubic,"['dp', 'graphs', 'shortest paths']",914
"def some_random_function(): x = 10 x *= 100 i_dont_know = x why_am_i_writing_this = x*x print(i_dont_know) print(why_am_i_writing_this) def some_random_function5(): x = 10 x *= 100 i_dont_know = x why_am_i_writing_this = x*x print(i_dont_know) print(why_am_i_writing_this) import os,sys from io import BytesIO,IOBase def main(): n,m,k = map(int,input().split()) hor = [list(map(int,input().split()))+[10**20+1] for _ in range(n)] ver = [list(map(int,input().split())) for _ in range(n-1)]+[[10**20+1]*m] if k&1: for _ in range(n): print(*[-1]*m) exit() dp = [[0]*m for _ in range(n)] dx,dy = [0,0,1,-1],[1,-1,0,0] for _ in range(k//2): dp1 = [[10**20]*m for _ in range(n)] for i in range(n): for j in range(m): for kk in range(4): x1,y1 = i+dx[kk],j+dy[kk] if kk < 2: ed = hor[i][j-(kk==1)] else: ed = ver[i-(kk==3)][j] if ed != 10**20+1: dp1[i][j] = min(dp1[i][j],2*ed+dp[x1][y1]) dp = dp1 for i in dp: print(*i) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.wri",cubic,"['dp', 'graphs', 'shortest paths']",1999
"from itertools import product import itertools import sys import heapq from collections import deque MOD=1000000000007 def find(parent,i): if parent[i] != i: parent[i]=find(parent,parent[i]) return parent[i] def union(parent,rank,xx,yy): x=find(parent,xx) y=find(parent,yy) if rank[x]>rank[y]: parent[y]=x elif rank[y]>rank[x]: parent[x]=y else: parent[y]=x rank[x]+=1 ans=0 x=0 y=0 MAX=1000000000 N,M,K=list(map(int,sys.stdin.readline().strip().split())) W=[[[MAX,MAX,MAX,MAX] for j in range(M)] for i in range(N)] for i in range(N): l=list(map(int,sys.stdin.readline().strip().split())) for j in range(M-1): W[i][j][1]=l[j] W[i][j+1][0]=l[j] for i in range(N-1): l=list(map(int,sys.stdin.readline().strip().split())) for j in range(M): W[i][j][3]=l[j] W[i+1][j][2]=l[j] if K%2==1: for i in range(N): ans=[] for j in range(M): ans.append(""-1"") print("" "".join(ans)) else: K=K//2 dp=[[[0 for j in range(M)] for i in range(N)] for k in range(K+1)] for kt in range(1,K+1): dl=((0,-1),(0,1),(-1,0),(1,0)) for i in range(N): for j in range(M): ans=MAX for t in range(4): ii,jj=dl[t] if i+ii>=0 and i+ii<N and j+jj>=0 and j+jj<M: ans=min(ans,dp[kt-1][i+ii][j+jj]+W[i][j][t]*2) dp[kt][i][j]=ans for i in range(N): ans=[] for j in range(M): ans.append(str(dp[-1][i][j])) print("" "".join(ans))",cubic,"['dp', 'graphs', 'shortest paths']",1283
"from math import inf if True: n,m,k = map(int,input().split()) cosp = [[int(x) for x in input().split()]+[inf] for _ in range(n)] cosv = [[int(x) for x in input().split()]for _ in range(n-1)]+[[inf]*m] if k%2==1: for _ in range(n): print(*[-1]*m) else: dp = [[0]*m for i in range(n)] xx,yy = [0,0,1,-1],[1,-1,0,0] for _ in range(k//2): dp1 = [[inf]*m for _ in range(n)] for i in range(n): for j in range(m): for kk in range(4): x1,y1 = i+xx[kk],j+yy[kk] if kk < 2: if kk==1: edge = cosp[i][j-1] else: edge=cosp[i][j] else: if kk==3 : edge = cosv[i-1][j] else: edge = cosv[i][j] if edge != inf: dp1[i][j] = min(dp1[i][j],2*edge+dp[x1][y1]) dp = dp1[:] for i in dp: print(*i)",cubic,"['dp', 'graphs', 'shortest paths']",673
"import sys def ints(): return map(int, input().split()) n, m, k = ints() right = [] for i in range(n): right.append(list(ints())) down = [] for i in range(n-1): down.append(list(ints())) INF = int(1e8) def around(r, c): a = [] for i, j in [[r-1, c], [r, c+1], [r+1, c], [r, c-1]]: if not (i < 0 or i >= n or j < 0 or j >= m): a.append([i, j]) return a def mink(dist, si, sj): minn = INF for i in range(max(0, si-k//2), min(n, si+k//2+1)): for j in range(max(0, sj-k//2), min(m, sj+k//2+1)): if dist[i][j] < minn: minn = dist[i][j] return minn def solve(): pdist = [[0] * m for i in range(n)] if k & 1: return [[-1] * m for i in range(n)] for step in range(k//2): dist = [[0] * m for i in range(n)] for i in range(n): for j in range(m): adist = [] for ip, jp in around(i, j): if ip == i: if jp > j: w = right[i][j] else: w = right[i][jp] else: if ip > i: w = down[i][j] else: w = down[ip][j] adist.append(pdist[ip][jp] + w) dist[i][j] = min(adist) pdist = dist for i in range(n): for j in range(m): pdist[i][j] *= 2 return pdist for row in solve(): print(*row)",cubic,"['dp', 'graphs', 'shortest paths']",1059
"import math from collections import defaultdict import os import sys from io import BytesIO, IOBase from types import GeneratorType from collections import defaultdict BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def process(s): b=[] for j in s: b.append(j) return b for _ in range(1): n,m,k=map(int,input().split()) d1=[[float(""inf"") for i in range(m+1)] for j in range(n+1)] d2 = [[float(""inf"") for i in range(m+1)] for j in range(n+1)] for i in range(n): l=list(map(int,input().split())) for j in range(m-1): d1[i][j]=l[j] for i in range(n-1): l=list(map(int,input().split())) for j in range(m): d2[i][j]=l[j] if k%2!=0: ans=[[-1 for j in range(m)] for i in range(n)] else: ans = [[float('inf') fo",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import io, os, sys input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline def read(): n, m, k = map(int, input().split() ) h = [list(map(int, input().split() ) )+ [float(""+inf"")] for _ in range(n)] v = [list(map(int, input().split() ) ) for _ in range(n-1)] v.append( [float(""+inf"")] * m ) solve(n, m, k, h, v) def solve(n, m, k, h, v): if k % 2: ans = ""-1 "" * m for _ in range(n): print(ans) return dp = [ [0] * (m+1) for _ in range(n+1)] nxt = [ [0] * (m+1) for _ in range(n+1)] for _ in range(2, k + 1, 2): for i in range(n): for j in range(m): l = 2 * h[i][j-1] + dp[i][j-1] r = 2 * h[i][j] + dp[i][j+1] u = 2 * v[i-1][j] + dp[i-1][j] d = 2 * v[i][j] + dp[i+1][j] hor = min(l, r) ver = min(u, d) nxt[i][j] = min(hor, ver) dp, nxt = nxt, dp for l in dp[:-1]: print("" "".join(map(str, l[:-1]))) if __name__ == ""__main__"": read()",cubic,"['dp', 'graphs', 'shortest paths']",834
"import os,io input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline n,m,k=map(int,input().split()) dist1=[] for i in range(n): dist1.append(list(map(int,input().split()))) dist2=[] for i in range(n-1): dist2.append(list(map(int,input().split()))) if k%2: print(' '.join(map(str,[-1]*(n*m)))) exit() k//=2 dp=[10**9]*((k+1)*n*m) for i in range(n): for j in range(m): dp[i*m+j]=0 for t in range(k): r=(t+1)*n*m q=t*n*m for i in range(n): for j in range(m): if i<n-1: dp[r+(i+1)*m+j]=min(dp[r+(i+1)*m+j],dp[q+i*m+j]+2*dist2[i][j]) if i>0: dp[r+(i-1)*m+j]=min(dp[r+(i-1)*m+j],dp[q+i*m+j]+2*dist2[i-1][j]) if j<m-1: dp[r+i*m+j+1]=min(dp[r+i*m+j+1],dp[q+i*m+j]+2*dist1[i][j]) if j>0: dp[r+i*m+j-1]=min(dp[r+i*m+j-1],dp[q+i*m+j]+2*dist1[i][j-1]) ans=[] for i in range(n): for j in range(m): ans.append(dp[k*n*m+i*m+j]) print(' '.join(map(str,ans)))",cubic,"['dp', 'graphs', 'shortest paths']",844
"I=lambda:[*map(int,input().split())] R=range;m=min;N,M,K=I();r=R(N) if K&1: for _ in r:print(*[-1]*M) exit() A=[I()for _ in r] B=[I()for _ in R(N-1)] X=[M*[0]for _ in r] for k in R(1,K//2+1): Y=[M*[9**9]for _ in r] for i in r: for j in R(M): if i:Y[i][j]=X[i-1][j]+2*B[i-1][j] if i<N-1:Y[i][j]=m(Y[i][j],X[i+1][j]+2*B[i][j]) if j:Y[i][j]=m(Y[i][j],X[i][j-1]+2*A[i][j-1]) if j<M-1:Y[i][j]=m(Y[i][j],X[i][j+1]+2*A[i][j]) X=Y for x in X:print(*x)",cubic,"['dp', 'graphs', 'shortest paths']",443
"import os import sys from io import BytesIO, IOBase mxm=sys.maxsize def solve(p,q,r): if p<0 or p>=n or q<0 or q>=m: return mxm if dp[r][p][q]!=-1: return dp[r][p][q] if r==0: return 0 z=int() a,b,c,d=0,0,0,0 a=dp[r-1][p][q-1] b=dp[r-1][p][q+1] c=dp[r-1][p-1][q] d=dp[r-1][p+1][q] if a==-1: a=row[p][q-1]+solve(p,q-1,r-1) else: a+=row[p][q-1] if b==-1: b=row[p][q]+solve(p,q+1,r-1) else: b+=row[p][q] if c==-1: c=col[p-1][q]+solve(p-1,q,r-1) else: c+=col[p-1][q] if d==-1: d=col[p][q]+solve(p+1,q,r-1) else: d+=col[p][q] z=min([a,b,c,d]) dp[r][p][q]=z return z n,m,k=map(int,input().split()) row=[] col=[] for i in range(n): row.append(list(map(int,input().split()))+[0]) for _ in range(n-1): col.append(list(map(int,input().split()))) col.append([0 for i in range(m)]) ans=[[-1 for _ in range(m)] for _ in range(n)] dp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)] def main(): if k%2: for item in ans: print(*item) exit() for r in range(n): for c in range(m): ans[r][c]=2*solve(r,c,k//2) for item in ans: print(*item) def nouse0(): a=420 b=420 print(f'i am nitish{(a+b)//2}') def nouse1(): a=420 b=420 print(f'i am nitish{(a+b)//2}') def nouse2(): a=420 b=420 print(f'i am nitish{(a+b)//2}') BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = 'x' in file.mode or 'r' not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b'\n') + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def f",cubic,"['dp', 'graphs', 'shortest paths']",1999
"import sys,io,os try:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline except:Z=lambda:sys.stdin.readline().encode() Y=lambda:[*map(int,Z().split())] n,m,k=Y();H=[Y()for i in range(n)];V=[Y()for i in range(n-1)] if k&1:print('\n'.join(' '.join(['-1']*m)for i in range(n)));quit() d=[0]*n*m for _ in range(k//2): nd=[0]*n*m for x in range(n): for y in range(m): v=x*m+y;w=[] if x:w.append(d[v-m]+V[x-1][y]) if y:w.append(d[v-1]+H[x][y-1]) if x<n-1:w.append(d[v+m]+V[x][y]) if y<m-1:w.append(d[v+1]+H[x][y]) nd[v]=min(w) d=nd print('\n'.join(' '.join(map(lambda x:str(2*x),d[i*m:i*m+m]))for i in range(n)))",cubic,"['dp', 'graphs', 'shortest paths']",608
"import sys import math input = sys.stdin.readline def inp(): return(int(input())) def inlt(): return(list(map(int,input().split()))) def insr(): s = input() return(list(s.rstrip())) def invr(): return(map(int,input().split())) n, m, k=inlt() M=[[[] for i in range(m)] for j in range(n)] S=[[-1]*m for i in range(n)] for y in range(n): L=inlt() for x in range(m-1): M[y][x].append(((y, x+1), L[x])) M[y][x+1].append(((y, x), L[x])) for y in range(n-1): L=inlt() for x in range(m): M[y][x].append(((y+1, x), L[x])) M[y+1][x].append(((y, x), L[x])) if k%2==0: for l in range(k//2): S2=[[0]*m for i in range(n)] for y in range(n): for x in range(m): Mi=10000000000000000000000 for ((a, b), p) in M[y][x]: Mi=min(Mi,max(0,S[a][b])+p) S2[y][x]=Mi S=S2 for y in range(n): for x in range(m): S[y][x]*=2 for y in range(n): print(' '.join(list(map(str, S[y]))))",cubic,"['dp', 'graphs', 'shortest paths']",851
"def aburrimin(x, y, n, m, costder, costaba, dp): dists = [] vals = [] if x != 0: dis = costder[y][x-1] dists.append(dis) vals.append(dis+dp[y][x-1]) if y != 0: dis = costaba[y-1][x] dists.append(dis) vals.append(dis+dp[y-1][x]) if y < n-1: dis = costaba[y][x] dists.append(dis) vals.append(dis+dp[y+1][x]) if x < m-1: dis = costder[y][x] dists.append(dis) vals.append(dis+dp[y][x+1]) mindis = min(dists) return min(mindis+dp[y][x],min(vals)) def solvecaso(): n,m,k = map(int,input().split()) costder = [[int(x) for x in input().split()] for _ in range(n)] costaba = [[int(x) for x in input().split()] for _ in range(n-1)] if k%2: for i in range(n): for j in range(m): print(-1, end=' ') print() return -1 k //= 2 for ren in range(len(costder)): for col in range(len(costder[ren])): costder[ren][col] *= 2 for ren in range(len(costaba)): for col in range(len(costaba[ren])): costaba[ren][col] *= 2 dp = [[0 for _ in range(m)] for _ in range(n)] dptemp = [[0 for _ in range(m)] for _ in range(n)] for i in range(k): for y in range(n): for x in range(m): dptemp[y][x] = aburrimin(x, y, n, m, costder, costaba, dp) dp, dptemp = dptemp, dp for ren in dp: for num in ren: print(num, end=' ') print() return 0 if __name__ == ""__main__"": solvecaso()",cubic,"['dp', 'graphs', 'shortest paths']",1241
"DR = [1,0,-1,0] DC = [0,1,0,-1] n, m, k = map(int, input().split()) w = [[[0] * m for _ in range(n)] for _ in range(4)] for r in range(n): for c, e in enumerate(map(int, input().split())): w[1][r][c] = w[3][r][c + 1] = e for r in range(n - 1): for c, e in enumerate(map(int, input().split())): w[0][r][c] = w[2][r + 1][c] = e INF = 10 ** 9 def solve(): global k global w if k % 2 == 1: return [[-1] * m] * n k //= 2 best = [[[0] * m for _ in range(n)] for _ in range(k + 1)] for steps in range(1, k + 1): for r in range(n): for c in range(m): best[steps][r][c] = INF for d in range(4): r2, c2 = r + DR[d], c + DC[d] if 0 <= r2 < n and 0 <= c2 < m: best[steps][r][c] = min(best[steps][r][c], 2 * w[d][r][c] + best[steps - 1][r2][c2]) return best[k] res = solve() for e in res: print(*e)",cubic,"['dp', 'graphs', 'shortest paths']",785
"from sys import stdin, stdout from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log from collections import defaultdict as dd, deque from heapq import merge, heapify, heappop, heappush, nsmallest from bisect import bisect_left as bl, bisect_right as br, bisect mod = pow(10, 9) + 7 mod2 = 998244353 def inp(): return stdin.readline().strip() def iinp(): return int(inp()) def out(var, end=""\n""): stdout.write(str(var)+""\n"") def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end) def lmp(): return list(mp()) def mp(): return map(int, inp().split()) def smp(): return map(str, inp().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)] def remadd(x, y): return 1 if x%y else 0 def ceil(a,b): return (a+b-1)//b S1 = 'abcdefghijklmnopqrstuvwxyz' S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' def isprime(x): if x<=1: return False if x in (2, 3): return True if x%2 == 0: return False for i in range(3, int(sqrt(x))+1, 2): if x%i == 0: return False return True n, m, k = mp() hor = [lmp() for i in range(n)] ver = [lmp() for i in range(n-1)] if k%2: ml = l2d(n, m, -1) for i in ml: print(*i) exit() k//=2 dp = [l2d(n, m) for i in range(k+1)] for f in range(1, k+1): for i in range(n): for j in range(m): a = inf if i!=0: a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j]) if i!=n-1: a = min(a, 2*ver[i][j]+dp[f-1][i+1][j]) if j!=0: a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1]) if j!=m-1: a = min(a, 2*hor[i][j]+dp[f-1][i][j+1]) dp[f][i][j] = a for i in dp[-1]: print(*i)",cubic,"['dp', 'graphs', 'shortest paths']",1537
"from collections import deque from types import GeneratorType import os import sys import math import heapq from atexit import register from io import BytesIO import __pypy__ class Input(object): def __init__(self): if 'CPH' not in os.environ: sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size)) sys.stdout = BytesIO() register(lambda: os.write(1, sys.stdout.getvalue())) def rawInput(self): return sys.stdin.readline().rstrip('\r\n') def readInt(self): return int(self.rawInput()) class Output(object): def __init__(self): self.out = __pypy__.builders.StringBuilder() def write(self, text): self.out.append(str(text)) def writeLine(self, text): self.write(str(text) + '\n') def finalize(self): if sys.version_info[0] < 3: os.write(1, self.out.build()) else: os.write(1, self.out.build().encode()) def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc class MDArray(object): def __init__(self, dimensions, initial_value=0): self.dimensions = dimensions dim_total = 1 for i in dimensions: dim_total *= i self.arr = [initial_value] * dim_total def _index(self, indexes): assert len(indexes) == len(self.dimensions) idx_multi = 1 idx = 0 for i in range(len(indexes)): assert 0 <= indexes[i] < self.dimensions[i] idx += indexes[i] * idx_multi idx_multi *= self.dimensions[i] return idx def get(self, indexes): return self.arr[self._index(indexes)] def set(self, indexes, value): self.arr[self._index(indexes)] = value return value def encode(row, col, n, m): return row * m + col def solve(node, remain, adj, dp): if remain == 0: return 0 key = (node, remain) mem = dp.get(key) if mem != -1: return mem ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node])) dp.set(key, ans) return ans def main(inp, out): n, m, k = map(int, inp.rawInput().spli",cubic,"['dp', 'graphs', 'shortest paths']",1999
"from collections import deque from types import GeneratorType import os import sys import math import heapq from atexit import register from io import BytesIO import __pypy__ class Input(object): def __init__(self): if 'CPH' not in os.environ: sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size)) sys.stdout = BytesIO() register(lambda: os.write(1, sys.stdout.getvalue())) def rawInput(self): return sys.stdin.readline().rstrip('\r\n') def readInt(self): return int(self.rawInput()) class Output(object): def __init__(self): self.out = __pypy__.builders.StringBuilder() def write(self, text): self.out.append(str(text)) def writeLine(self, text): self.write(str(text) + '\n') def finalize(self): if sys.version_info[0] < 3: os.write(1, self.out.build()) else: os.write(1, self.out.build().encode()) def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc class MDArray(object): def __init__(self, dimensions, initial_value=0): self.dimensions = dimensions dim_total = 1 for i in dimensions: dim_total *= i self.arr = [initial_value] * dim_total def _index(self, indexes): assert len(indexes) == len(self.dimensions) idx_multi = 1 idx = 0 for i in range(len(indexes)): assert 0 <= indexes[i] < self.dimensions[i] idx += indexes[i] * idx_multi idx_multi *= self.dimensions[i] return idx def get(self, indexes): return self.arr[self._index(indexes)] def set(self, indexes, value): self.arr[self._index(indexes)] = value return value def encode(row, col, n, m): return row * m + col def solve(node, remain, adj, dp): if remain == 0: return 0 key = (node, remain) mem = dp.get(key) if mem != -1: return mem ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node])) dp.set(key, ans) return ans def main(inp, out): n, m, k = map(int, inp.rawInput().spli",cubic,"['dp', 'graphs', 'shortest paths']",1999
"from collections import deque from types import GeneratorType import os import sys import math import heapq from atexit import register from io import BytesIO import __pypy__ class Input(object): def __init__(self): if 'CPH' not in os.environ: sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size)) sys.stdout = BytesIO() register(lambda: os.write(1, sys.stdout.getvalue())) def rawInput(self): return sys.stdin.readline().rstrip('\r\n') def readInt(self): return int(self.rawInput()) class Output(object): def __init__(self): self.out = __pypy__.builders.StringBuilder() def write(self, text): self.out.append(str(text)) def writeLine(self, text): self.write(str(text) + '\n') def finalize(self): if sys.version_info[0] < 3: os.write(1, self.out.build()) else: os.write(1, self.out.build().encode()) def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc class MDArray(object): def __init__(self, dimensions, initial_value=0): self.dimensions = dimensions dim_total = 1 for i in dimensions: dim_total *= i self.arr = [initial_value] * dim_total def _index(self, indexes): assert len(indexes) == len(self.dimensions) idx_multi = 1 idx = 0 for i in range(len(indexes)): assert 0 <= indexes[i] < self.dimensions[i] idx += indexes[i] * idx_multi idx_multi *= self.dimensions[i] return idx def get(self, indexes): return self.arr[self._index(indexes)] def set(self, indexes, value): self.arr[self._index(indexes)] = value return value def encode(row, col, n, m): return row * m + col def solve(node, remain, adj, dp): if remain == 0: return 0 key = (node, remain) mem = dp.get(key) if mem != -1: return mem ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node])) dp.set(key, ans) return ans def main(inp, out): n, m, k = map(int, inp.rawInput().spli",cubic,"['dp', 'graphs', 'shortest paths']",1999
"from collections import deque from types import GeneratorType import os import sys import math import heapq from atexit import register from io import BytesIO import __pypy__ class Input(object): def __init__(self): if 'CPH' not in os.environ: sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size)) sys.stdout = BytesIO() register(lambda: os.write(1, sys.stdout.getvalue())) def rawInput(self): return sys.stdin.readline().rstrip('\r\n') def readInt(self): return int(self.rawInput()) class Output(object): def __init__(self): self.out = __pypy__.builders.StringBuilder() def write(self, text): self.out.append(str(text)) def writeLine(self, text): self.write(str(text) + '\n') def finalize(self): if sys.version_info[0] < 3: os.write(1, self.out.build()) else: os.write(1, self.out.build().encode()) def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc class MDArray(object): def __init__(self, dimensions, initial_value=0): self.dimensions = dimensions dim_total = 1 for i in dimensions: dim_total *= i self.arr = [initial_value] * dim_total def _index(self, indexes): assert len(indexes) == len(self.dimensions) idx_multi = 1 idx = 0 for i in range(len(indexes)): assert 0 <= indexes[i] < self.dimensions[i] idx += indexes[i] * idx_multi idx_multi *= self.dimensions[i] return idx def get(self, indexes): return self.arr[self._index(indexes)] def set(self, indexes, value): self.arr[self._index(indexes)] = value return value def encode(row, col, n, m): return row * m + col def main(inp, out): n, m, k = map(int, inp.rawInput().split()) if k % 2 == 1: for _ in range(n): out.writeLine(' '.join(map(str, [-1] * m))) return total_nodes = n*m adj = [[] for _ in range(total_nodes)] for i in range(n): weights = map(int, inp.rawInput().split()) for j in range(m-",cubic,"['dp', 'graphs', 'shortest paths']",1999
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") n,m,k=map(int,input().split()) y_axis=[list(map(int,input().split())) for i in range(n)] x_axis=[list(map(int,input().split())) for i in range(n-1)] if(k%2==1): for i in range(n): for j in range(m): print(-1,end="" "") print() else: inf=10**9 dp=[[[inf for z in range(k+1)]for y in range(m)]for x in range(n)] for i in range(n): for j in range(m): if(i>0): if(i<n-1): dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j],2*x_axis[i-1][j]) else: dp[i][j][2]=min(dp[i][j][2],2*x_axis[i-1][j]) else: dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j]) if(j>0): if(j<m-1): dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j],2*y_axis[i]",cubic,"['dp', 'graphs', 'shortest paths']",2000
"from collections import deque from types import GeneratorType import os import sys import math import heapq from atexit import register from io import BytesIO import __pypy__ class Input(object): def __init__(self): if 'CPH' not in os.environ: sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size)) sys.stdout = BytesIO() register(lambda: os.write(1, sys.stdout.getvalue())) def rawInput(self): return sys.stdin.readline().rstrip('\r\n') def readInt(self): return int(self.rawInput()) class Output(object): def __init__(self): self.out = __pypy__.builders.StringBuilder() def write(self, text): self.out.append(str(text)) def writeLine(self, text): self.write(str(text) + '\n') def finalize(self): if sys.version_info[0] < 3: os.write(1, self.out.build()) else: os.write(1, self.out.build().encode()) def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc class MDArray(object): def __init__(self, dimensions, initial_value=0): self.dimensions = dimensions dim_total = 1 for i in dimensions: dim_total *= i self.arr = [initial_value] * dim_total def _index(self, indexes): assert len(indexes) == len(self.dimensions) idx_multi = 1 idx = 0 for i in range(len(indexes)): assert 0 <= indexes[i] < self.dimensions[i] idx += indexes[i] * idx_multi idx_multi *= self.dimensions[i] return idx def get(self, indexes): return self.arr[self._index(indexes)] def set(self, indexes, value): self.arr[self._index(indexes)] = value return value def encode(row, col, n, m): return row * m + col def main(inp, out): n, m, k = map(int, inp.rawInput().split()) if k % 2 == 1: for _ in range(n): out.writeLine(' '.join(map(str, [-1] * m))) return total_nodes = n*m adj = [[] for _ in range(total_nodes)] for i in range(n): weights = map(int, inp.rawInput().split()) for j in range(m-",cubic,"['dp', 'graphs', 'shortest paths']",1999
"from collections import deque from types import GeneratorType import os import sys import math import heapq from atexit import register from io import BytesIO import __pypy__ class Input(object): def __init__(self): if 'CPH' not in os.environ: sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size)) sys.stdout = BytesIO() register(lambda: os.write(1, sys.stdout.getvalue())) def rawInput(self): return sys.stdin.readline().rstrip('\r\n') def readInt(self): return int(self.rawInput()) class Output(object): def __init__(self): self.out = __pypy__.builders.StringBuilder() def write(self, text): self.out.append(str(text)) def writeLine(self, text): self.write(str(text) + '\n') def finalize(self): if sys.version_info[0] < 3: os.write(1, self.out.build()) else: os.write(1, self.out.build().encode()) def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc class MDArray(object): def __init__(self, dimensions, initial_value=0): self.dimensions = dimensions dim_total = 1 for i in dimensions: dim_total *= i self.arr = [initial_value] * dim_total def _index(self, indexes): assert len(indexes) == len(self.dimensions) idx_multi = 1 idx = 0 for i in range(len(indexes)): assert 0 <= indexes[i] < self.dimensions[i] idx += indexes[i] * idx_multi idx_multi *= self.dimensions[i] return idx def get(self, indexes): return self.arr[self._index(indexes)] def set(self, indexes, value): self.arr[self._index(indexes)] = value return value def encode(row, col, n, m): return row * m + col def solve(node, remain, adj, dp, n, m): if remain == 0: return 0 key = (node + remain * n * m) mem = dp[key] if mem != -1: return mem ans = min(map(lambda x: solve(x[0], remain-1, adj, dp, n, m) + x[1], adj[node])) dp[key] = ans return ans def main(inp, out): n, m, k = map(int, inp.r",cubic,"['dp', 'graphs', 'shortest paths']",1999
"n,m,k = map(int,input().split()) right = [[9999999 for i in range(m-1)] for j in range(n)] down = [[9999999 for i in range(m)] for j in range(n-1)] for i in range(n): right[i] = list(map(int,input().split())) for i in range(n-1): down[i] = list(map(int,input().split())) if(k%2==1): for i in range(n): for j in range(m): print(""-1"",end="" "") print() else: k = k//2 row = n col = m dp = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)] for steps in range(k+1): for i in range(row): for j in range(col): if(steps==0): dp[steps][i][j] = 0 continue ans = 99999999999 if(i>0): ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j]) if(i<n-1): ans = min(ans,dp[steps-1][i+1][j]+down[i][j]) if(j<m-1): ans = min(ans,dp[steps-1][i][j+1]+right[i][j]) if(j>0): ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1]) dp[steps][i][j] = ans for i in range(n): for j in range(m): print(2*dp[k][i][j],end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",910
"from sys import stdin, stdout input = stdin.readline n,m,K = map(int,input().split()) edges = [] for i in range(n): edges.append([[]]) lis = list(map(int,input().split())) for j in range(m-1): edges[i][j].append((1,0,lis[j])) edges[i].append([]) edges[i][j+1].append((-1,0,lis[j])) for i in range(n-1): lis = list(map(int,input().split())) for j in range(m): edges[i][j].append((0,1,lis[j])) edges[i+1][j].append((0,-1,lis[j])) if K%2==1: lis = [] for i in range(n): lis.append([-1]*m) else: lis = [] for i in range(n): lis.append([0]*m) for k in range(1,(K//2)+1): new_lis = [] for i in range(n): new_lis.append([0]*m) for i in range(n): for j in range(m): dist = [] for e in edges[i][j]: dist.append(e[2] + lis[i+e[1]][j+e[0]]) new_lis[i][j] = min(dist) lis = new_lis for i in range(n): for j in range(m): lis[i][j] *= 2 for i in lis: print(*i)",cubic,"['dp', 'graphs', 'shortest paths']",846
"import sys, os from io import BytesIO, IOBase from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log from collections import defaultdict as dd, deque from heapq import merge, heapify, heappop, heappush, nsmallest from bisect import bisect_left as bl, bisect_right as br, bisect BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) mod = pow(10, 9) + 7 mod2 = 998244353 def inp(): return stdin.readline().strip() def iinp(): return int(inp()) def out(var, end=""\n""): stdout.write(str(var)+""\n"") def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end) def lmp(): return list(mp()) def mp(): return map(int, inp().split()) def smp(): return map(str, inp().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import sys, os from io import BytesIO, IOBase from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log from collections import defaultdict as dd, deque from heapq import merge, heapify, heappop, heappush, nsmallest from bisect import bisect_left as bl, bisect_right as br, bisect BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) mod = pow(10, 9) + 7 mod2 = 998244353 def inp(): return stdin.readline().strip() def iinp(): return int(inp()) def out(var, end=""\n""): stdout.write(str(var)+""\n"") def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end) def lmp(): return list(mp()) def mp(): return map(int, inp().split()) def smp(): return map(str, inp().split()) def l1d(n, val=0): return [val for i in range(n)] def l2d(n, m, val=0): return [",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import sys import os.path from collections import * import math import bisect if (os.path.exists('input.txt')): sys.stdin = open(""input.txt"", ""r"") sys.stdout = open(""output.txt"", ""w"") n, m, k1 = [int(x) for x in input().split()] arr = [0 for i in range(n)] for i in range(n): arr[i] = [int(x) for x in input().split()] brr = [0 for i in range(n - 1)] for i in range(n - 1): brr[i] = [int(x) for x in input().split()] dp = [[[0 for k in range(11)] for j in range(m)] for i in range(n)] for k in range(1, 11): for i in range(n): for j in range(m): dp[i][j][k] = 10 ** 9 if i > 0: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + brr[i - 1][j] * 2) if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + brr[i][j] * 2) if j > 0: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + arr[i][j - 1] * 2) if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + arr[i][j] * 2) for i in range(n): for j in range(m): if(k1 % 2): print(-1,end="" "") else: print(dp[i][j][k1 // 2],end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",1010
"import sys import os.path from collections import * import math import bisect if (os.path.exists('input.txt')): sys.stdin = open(""input.txt"", ""r"") sys.stdout = open(""output.txt"", ""w"") n, m, k1 = [int(x) for x in input().split()] arr = [0 for i in range(n)] for i in range(n): arr[i] = [int(x) for x in input().split()] brr = [0 for i in range(n - 1)] for i in range(n - 1): brr[i] = [int(x) for x in input().split()] dp = [[[0 for k in range(21)] for j in range(m)] for i in range(n)] for k in range(1, 21): for i in range(n): for j in range(m): if k % 2: dp[i][j][k] = -1 else: dp[i][j][k] = 10 ** 9 if i > 0: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 2] + brr[i - 1][j] * 2) if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 2] + brr[i][j] * 2) if j > 0: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 2] + arr[i][j - 1] * 2) if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 2] + arr[i][j] * 2) for i in range(n): for j in range(m): print(dp[i][j][k1],end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",1002
"import os import sys from io import BytesIO, IOBase def main(): n,m,k=map(int,input().split()) left=[list(map(int,input().split())) for _ in range(n)] down=[list(map(int,input().split())) for _ in range(n-1)] dp=[[(-1 if k&1 else 0) for _ in range(m)] for _ in range(n)] if k&1==0: for l in range(k//2): dp1=[[10**8 for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): if j>0: dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1]) if j<m-1: dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j]) if i>0: dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j]) if i<n-1: dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j]) dp=dp1 for i in dp: print(*i) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\",cubic,"['dp', 'graphs', 'shortest paths']",1999
"import os import sys from io import BytesIO, IOBase from array import array def main(): n,m,k=map(int,input().split()) left=[array(""i"",map(int,input().split())) for _ in range(n)] down=[array(""i"",map(int,input().split())) for _ in range(n-1)] dp=[array(""i"",[(-1 if k&1 else 0) for _ in range(m)]) for _ in range(n)] if k&1==0: for l in range(k//2): dp1=[array(""i"",[10**8 for _ in range(m)]) for _ in range(n)] for i in range(n): for j in range(m): if j>0: dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1]) if j<m-1: dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j]) if i>0: dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j]) if i<n-1: dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j]) dp=dp1 for i in dp: print(*i) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.",cubic,"['dp', 'graphs', 'shortest paths']",1999
"def main(): N, M, K = map(int, input().split()) HEdge = [list(map(int, input().split())) for _ in range(N)] VEdge = [list(map(int, input().split())) for _ in range(N - 1)] if K % 2: for i in range(N): print(*[-1] * M) return dp = [[[0] * M for _ in range(N)] for _ in range(K // 2 + 1)] for i in range(1, K // 2 + 1): for j in range(N): for k in range(M): Val1 = Val2 = Val3 = Val4 = 10 ** 9 if j > 0: Val1 = dp[i - 1][j - 1][k] + VEdge[j - 1][k] if j < N - 1: Val2 = dp[i - 1][j + 1][k] + VEdge[j][k] if k > 0: Val3 = dp[i - 1][j][k - 1] + HEdge[j][k - 1] if k < M - 1: Val4 = dp[i - 1][j][k + 1] + HEdge[j][k] dp[i][j][k] = min(Val1, Val2, Val3, Val4) for i in dp[K // 2]: print(*list(map(lambda x: x * 2, i))) if __name__ == '__main__': main()",cubic,"['dp', 'graphs', 'shortest paths']",746
"import os import sys import time from io import BytesIO, IOBase def main(): max_int = 10 ** 9 d = ((1, 0), (-1, 0), (0, 1), (0, -1)) n, m, k = li_input() H = [] for i in range(n): H.append(li_input() + [max_int]) V = [] for i in range(n - 1): V.append(li_input()) V.append([max_int] * m) if k % 2: for i in range(n): print(' '.join(['-1'] * m)) return k //= 2 DP0 = [[0] * (m + 1) for _ in range(n + 1)] DP1 = [[0] * (m + 1) for _ in range(n + 1)] for kk in range(k): for i in range(n): for j in range(m): l = DP0[i][j - 1] + H[i][j - 1] r = DP0[i][j + 1] + H[i][j] u = DP0[i - 1][j] + V[i - 1][j] d = DP0[i + 1][j] + V[i][j] DP1[i][j] = min(l, r, u, d) DP0, DP1 = DP1, DP0 O = [] for row in DP0[:-1]: O.append(' '.join((str(n * 2) for n in row[:-1]))) print('\n'.join(O)) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") d",cubic,"['dp', 'graphs', 'shortest paths']",1999
"n,m,k = map(int,input().split()) right = [[9999999 for i in range(m-1)] for j in range(n)] down = [[9999999 for i in range(m)] for j in range(n-1)] for i in range(n): right[i] = list(map(int,input().split())) for i in range(n-1): down[i] = list(map(int,input().split())) if(k%2==1): for i in range(n): for j in range(m): print(""-1"",end="" "") print() else: k = k//2 row = n col = m dp = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)] for steps in range(k+1): for i in range(row): for j in range(col): if(steps==0): dp[steps][i][j] = 0 continue ans = 99999999999 if(i>0): ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j]) if(i<n-1): ans = min(ans,dp[steps-1][i+1][j]+down[i][j]) if(j<m-1): ans = min(ans,dp[steps-1][i][j+1]+right[i][j]) if(j>0): ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1]) dp[steps][i][j] = ans for i in range(n): for j in range(m): print(2*dp[k][i][j],end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",910
"n,m,k=[int(x) for x in input().split()] left=[];right=[] for i in range(n): temp=[int(x) for x in input().split()] left.append(temp) for i in range(n-1): temp=[int(x) for x in input().split()] right.append(temp) dp_old=[[0 for x in range(m)] for x in range(n)] if k%2!=0: for i in range(n): print(*[-1 for x in range(m)]) else: k//=2 for k1 in range(k): dp=[[0 for x in range(m)] for x in range(n)] for row in range(n): for col in range(m): t=float(""inf"") if 0<col: t=min(t,dp_old[row][col-1]+2*left[row][col-1]) if m-1>col: t=min(t,dp_old[row][col+1]+2*left[row][col]) if 0<row: t=min(t,dp_old[row-1][col]+2*right[row-1][col]) if n-1>row: t=min(t,dp_old[row+1][col]+2*right[row][col]) dp[row][col]=t for row in range(n): for col in range(m): dp_old[row][col]=dp[row][col] for i in range(n): print(*dp_old[i])",cubic,"['dp', 'graphs', 'shortest paths']",809
"import os,sys;from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno();self.buffer = BytesIO();self.writable = ""x"" in file.mode or ""r"" not in file.mode;self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b:break ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0:b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE));self.newlines = b.count(b""\n"") + (not b);ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable:os.write(self._fd, self.buffer.getvalue());self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file);self.flush = self.buffer.flush;self.writable = self.buffer.writable;self.write = lambda s: self.buffer.write(s.encode(""ascii""));self.read = lambda: self.buffer.read().decode(""ascii"");self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) try:sys.stdin,sys.stdout=open('in.txt','r'),open('out.txt','w') except:pass ii1=lambda:int(sys.stdin.readline().strip()) is1=lambda:sys.stdin.readline().strip() iia=lambda:list(map(int,sys.stdin.readline().strip().split())) isa=lambda:sys.stdin.readline().strip().split() from functools import lru_cache from collections import defaultdict from math import inf n,m,k = iia() A = [[0] * (m) for _ in range(n)] B = [[0] * (m) for _ in range(n)] for i in range(n): tmp = iia() for j in range(m - 1): A[i][j + 1] = tmp[j] for i in range(n - 1): tmp = iia() for j in range(m): B[i + 1][j] = tmp[j] if k%2: [print(*[-1]*m) for i in range(n)] sys.exit() ans = [[0] * m for",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os import sys from io import BytesIO, IOBase import math from queue import Queue import itertools import bisect import heapq sys.setrecursionlimit(100000) def main(): pass BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while (n > 1): n //= 2 p += 1 return (p) def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: l.append(i) n = n / i if n > 2: l.append(int(n)) return (l) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) ret",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os import sys from io import BytesIO, IOBase import math from queue import Queue import itertools import bisect import heapq def main(): pass BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def binary(n): return (bin(n).replace(""0b"", """")) def decimal(s): return (int(s, 2)) def pow2(n): p = 0 while (n > 1): n //= 2 p += 1 return (p) def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: l.append(i) n = n / i if n > 2: l.append(int(n)) return (l) def isPrime(n): if (n == 1): return (False) else: root = int(n ** 0.5) root += 1 for i in range(2, root): if (n % i == 0): return (False) return (True) def maxPrimeFactors",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import sys input=sys.stdin.readline t=1 for i in range(t): n,m,k = map(int,input().split()) b=[] horizontal_edges=[] vertical_edges=[] for i in range(n): temp=[int(x) for x in input().split()] horizontal_edges.append(temp) for i in range(n-1): temp=[int(x) for x in input().split()] vertical_edges.append(temp) if k%2==1: for i in range(n): for j in range(m): print(-1,end=' ') print() continue dp=[[[10**9 for x in range(k+1)] for x in range(m)] for x in range(n)] for i in range(n): for j in range(m): dp[i][j][0]=0 for z in range(2,k+1,2): for i in range(n): for j in range(m): if i>0: if i<n-1: dp[i][j][z]=min(dp[i-1][j][z-2]+2*vertical_edges[i-1][j],dp[i+1][j][z-2]+2*vertical_edges[i][j]) else: dp[i][j][z]=dp[i-1][j][z-2]+2*vertical_edges[i-1][j] else: dp[i][j][z]=dp[i+1][j][z-2]+2*vertical_edges[i][j] if j>0: if j<m-1: dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1],dp[i][j+1][z-2]+2*horizontal_edges[i][j]) else: dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1]) else: dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*horizontal_edges[i][j]) for i in range(n): for j in range(m): print(dp[i][j][k],end=' ') print()",cubic,"['dp', 'graphs', 'shortest paths']",1169
"import math n,m,k=map(int,input().split()) horz=[] vert=[] if k & 1: for i in range(n): temp=[-1 for j in range(m)] print(*temp) else: for i in range(n): temp=list(map(int,input().split())) horz.append(temp) for i in range(n-1): temp=list(map(int,input().split())) vert.append(temp) dp=[[[0 for i in range(22)] for j in range(m)]for k in range(n)] for x in range(2,k+1,2): for i in range(n): for j in range(m): dp[i][j][x]=math.inf if i>0: dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-2]+2*vert[i-1][j]) if i<n-1: dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-2]+2*vert[i][j]) if j>0: dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-2]+2*horz[i][j-1]) if j<m-1: dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-2]+2*horz[i][j]) for i in range(n): temp=[] for j in range(m): temp.append(dp[i][j][k]) print(*temp)",cubic,"['dp', 'graphs', 'shortest paths']",787
"class node: def __init__(self,l,r,u,d): self.u = u self.d = d self.l = l self.r = r if l == 20000001 and r ==20000001 and u == 20000001 and d == 20000001: self.marr = [20000001 for i in range(11)] else: self.marr = [0 for i in range(11)] self.marr[1] = min(l,r,u,d) def mo(self,st): return self.marr[st-1] n,m,s = (int(i) for i in input().split()) hor = [[20000001 for i in range(m+3)] for j in range(n+2)] ver = [[20000001 for i in range(m+2)] for j in range(n+3)] for i in range(1,n+1): hor[i][2:1+m] = [int(i) for i in input().split()] for i in range(2,1+n): ver[i][1:m+1] = [int(i) for i in input().split()] if s%2 == 0 : nds = [[node(hor[i][j],hor[i][j+1],ver[i][j],ver[i+1][j]) for j in range(m+2)] for i in range(n+2)] for st in range(2,s//2+1): for i in range(1,n+1): for j in range(1,m+1): x = nds[i][j].marr[1] l = nds[i][j].l r = nds[i][j].r u = nds[i][j].u d = nds[i][j].d nds[i][j].marr[st] = min(x*st,r+nds[i][j+1].mo(st),l+nds[i][j-1].mo(st),u+nds[i-1][j].mo(st),d+nds[i+1][j].mo(st)) ans = [[nds[i][j].marr[s//2]*2 for j in range(1,m+1)] for i in range(1,n+1)] for i in range(n): print(*tuple(ans[i])) else : a = [[-1 for i in range(m)] for j in range(n)] for i in range(n): print(*tuple(a[i]))",cubic,"['dp', 'graphs', 'shortest paths']",1210
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from heapq import heapify,heappush as hp,heappop as hpop def check(x,y): if 0<=x<=n-1 and 0<=y<=m-1: return True return False n,m,k=map(int,input().split()) l1=[] l2=[] for i in range(n): l1.append(list(map(int,input().split()))) for i in range(n-1): l2.append(list(map(int,input().split()))) inf=10**18 dp=[[[inf]*21 for i in range(m)] for j in range(n)] for i in range(n): for j in range(m): if check(i,j+1): dp[i][j][1]=min(l1[i][j],dp[i][j][1]) if check(i,j-1): dp[i][j][1]=min(l1[i][j-1],dp[i][j][1]) if check(i+1,j): dp[i][j][1]=min(l2[i][j],dp[i][j][1]) if check(i-1,j): dp[i][j][1]=min(l2[i-1][j",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from heapq import heapify,heappush as hp,heappop as hpop def check(x,y): if 0<=x<=n-1 and 0<=y<=m-1: return True return False n,m,k=map(int,input().split()) l1=[] l2=[] for i in range(n): l1.append(list(map(int,input().split()))) for i in range(n-1): l2.append(list(map(int,input().split()))) inf=10**18 dp=[[[inf]*21 for i in range(m)] for j in range(n)] for i in range(n): for j in range(m): if check(i,j+1): dp[i][j][1]=min(l1[i][j],dp[i][j][1]) if check(i,j-1): dp[i][j][1]=min(l1[i][j-1],dp[i][j][1]) if check(i+1,j): dp[i][j][1]=min(l2[i][j],dp[i][j][1]) if check(i-1,j): dp[i][j][1]=min(l2[i-1][j",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import sys input = lambda: sys.stdin.readline().rstrip() N, M, K = map(int, input().split()) if K % 2: for _ in range(N): print(*[-1] * M) exit() A = [[int(a) for a in input().split()] for _ in range(N)] B = [[int(a) for a in input().split()] for _ in range(N - 1)] X = [[0] * M for _ in range(N)] inf = 1 << 30 for k in range(1, K // 2 + 1): nX = [[inf] * M for _ in range(N)] for i in range(N): for j in range(M): if i: nX[i][j] = min(nX[i][j], X[i - 1][j] + B[i - 1][j]) if i < N - 1: nX[i][j] = min(nX[i][j], X[i + 1][j] + B[i][j]) if j: nX[i][j] = min(nX[i][j], X[i][j - 1] + A[i][j - 1]) if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j + 1] + A[i][j]) X = nX for x in X: print(*[a * 2 for a in x])",cubic,"['dp', 'graphs', 'shortest paths']",701
"import sys n, m, k = map(int, input().split()) hor = [list(map(int, input().split())) for _ in range(n)] ver = [list(map(int, input().split())) for _ in range(n-1)] if k % 2: for i in range(n): print(*([-1]*m)) sys.exit() k = k // 2 dp = [[[0]*m for _ in range(n)] for _ in range(k+1)] for x in range(1, k+1): for y in range(n): for z in range(m): hold = float('inf') if y != 0: hold = min(hold, dp[x-1][y-1][z] + ver[y-1][z] ) if y != n-1: hold = min(hold, dp[x-1][y+1][z] + ver[y][z] ) if z != 0: hold = min(hold, dp[x-1][y][z-1] + hor[y][z-1] ) if z != m-1: hold = min(hold, dp[x-1][y][z+1] + hor[y][z] ) dp[x][y][z] = hold for row in dp[k]: print(*map(lambda i: i*2, row))",cubic,"['dp', 'graphs', 'shortest paths']",676
"def main(): n, m, k = map(int, input().split()) inf = 1 << 30 left = [list(map(int, input().split())) for i in range(n)] down = [list(map(int, input().split())) for i in range(n-1)] if k & 1: for i in range(n): print(*[-1]*m) exit() ans = [[0]*m for i in range(n)] for k in range(1, k//2+1): _ = [[inf]*m for ii in range(n)] for i in range(n): for j in range(m): if i: _[i][j] = min(_[i][j], ans[i-1][j]+down[i-1][j]) if i < n-1: _[i][j] = min(_[i][j], ans[i+1][j]+down[i][j]) if j: _[i][j] = min(_[i][j], ans[i][j-1]+left[i][j-1]) if j < m-1: _[i][j] = min(_[i][j], ans[i][j+1]+left[i][j]) ans = _ for i in range(n): for j in range(m): print(ans[i][j]*2, end=' ') print() if __name__ == '__main__': main()",cubic,"['dp', 'graphs', 'shortest paths']",706
"get = lambda : list(map(int, input().split(' '))) n, m, k = get() rlist, clist = [], [] for _ in range(n): rlist.append(get()) for _ in range(n-1): clist.append(get()) dway = [[0,1],[0,-1],[1,0],[-1,0]] if k%2: res = [[-1]*m for _ in range(n)] else: flist = [[0]*m for _ in range(n)] for _ in range(k//2): glist = [[10**9]*m for _ in range(n)] for dx, dy in dway: klist = rlist if dx == 0 else clist for x in range(n): for y in range(m): xx, yy = x+dx, y+dy if not (0<=xx<n) or not (0<=yy<m): continue tx = xx if dx==-1 else x ty = yy if dy==-1 else y glist[x][y] = min(glist[x][y], flist[xx][yy] + klist[tx][ty] * 2) flist = glist res = flist for row in res: print(' '.join(map(str, row)))",cubic,"['dp', 'graphs', 'shortest paths']",690
"import sys def input(): return sys.stdin.readline().rstrip() def slv(): n, m, k = map(int, input().split()) if k % 2 != 0: for i in range(n): print(*[-1]*m) return k //= 2 DP = [[[0]*m for i in range(n)] for _ in range(k + 1)] G = [[[] for i in range(m)] for j in range(n)] for i in range(n): C = list(map(int,input().split())) for j in range(m - 1): cost = C[j] G[i][j].append((cost,i,j + 1)) G[i][j + 1] .append((cost,i,j)) for i in range(n - 1): C = list(map(int,input().split())) for j in range(m): cost = C[j] G[i][j].append((cost,i + 1,j)) G[i+1][j].append((cost,i,j)) for p in range(1,k + 1): for u in range(n): for v in range(m): DP[p][u][v] = min(DP[p - 1][x][y] + cost for (cost,x,y) in G[u][v]) for i in range(n): ans = [DP[k][i][j]*2 for j in range(m)] print(*ans) return def main(): t = 1 for i in range(t): slv() return if __name__ == ""__main__"": main()",cubic,"['dp', 'graphs', 'shortest paths']",867
"import math def mint(): return map(int, input().split()) n, m, k = mint() horizontal = [list(mint()) for i in range(n)] vertical = [list(mint()) for i in range(n-1)] if k%2 or max(n, m)==1: for i in range(n): print(*[-1]*m) exit() dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)] for length in range(1, k//2+1): for i in range(n): for j in range(m): left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1] right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1] top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1] bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1] dp[i][j][length] = min([left_path, right_path, top_path, bottom_path]) for i in range(n): print(*[dp[i][j][k//2]*2 for j in range(m)])",cubic,"['dp', 'graphs', 'shortest paths']",787
"n, m, k =map(int, input().split()) horizontal = [list(map(int, input().split())) for i in range(n)] vertical = [list(map(int, input().split())) for i in range(n-1)] if k%2 or max(n, m)==1:print(*["" "".join(['-1']*m) for i in range(n)], sep='\n');exit() dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)] for length in range(1, k//2+1): for i in range(n): for j in range(m): left_path = 10e7 if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1] right_path = 10e7 if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1] top_path = 10e7 if i==0 else vertical[i-1][j]+dp[i-1][j][length-1] bottom_path = 10e7 if i==n-1 else vertical[i][j]+dp[i+1][j][length-1] dp[i][j][length] = min([left_path, right_path, top_path, bottom_path]) for i in range(n):print(*[dp[i][j][k//2]*2 for j in range(m)])",cubic,"['dp', 'graphs', 'shortest paths']",791
"def main(): n, m, k = [int(v) for v in input().split()] dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]] w = [[[0 for d in range(4)] for j in range(m)] for i in range(n)] for i in range(n): row = [int(v) for v in input().split()] for j in range(m-1): w[i][j+1][2] = row[j] w[i][j][3] = row[j] for i in range(n-1): row = [int(v) for v in input().split()] for j in range(m): w[i][j][1] = row[j] w[i+1][j][0] = row[j] if k % 2 == 1: for i in range(n): for j in range(m): print(-1, end="" "") print() return else: k //= 2 dp = [[[int(40 * 1e6) for d in range(k+1)] for j in range(m)] for i in range(n)] for i in range(n): for j in range(m): dp[i][j][0] = 0 for d in range(1, k+1): for i in range(n): for j in range(m): for di, (dx, dy) in enumerate(dxy): ii = i + dx jj = j + dy if 0 <= ii < n and 0 <= jj < m: dp[i][j][d] = min(dp[i][j][d], dp[ii][jj][d-1] + w[i][j][di]) for i in range(n): for j in range(m): print(dp[i][j][k] * 2, end="" "") print() main()",cubic,"['dp', 'graphs', 'shortest paths']",943
"def roll(i,j): ways = [] if j: ways.append(2*hor[i][j-1] + grid[i][j-1]) if m-1-j: ways.append(2*hor[i][j] + grid[i][j+1]) if i: ways.append(2*ver[i-1][j] + grid[i-1][j]) if n-1-i: ways.append(2*ver[i][j] + grid[i+1][j]) return min(ways) n , m , k = map(int, input().split()) hor = [list(map(int, input().split())) for _ in range(n)] ver = [list(map(int, input().split())) for _ in range(n-1)] grid = [[0]*m for _ in range(n)] if k%2: for _ in range(n): print("" "".join([""-1""]*m)) else: for _ in range(k//2): new_grid = [[roll(i,j) for j in range(m)] for i in range(n)] grid = new_grid[:] for i in range(n): print("" "".join(map(str,grid[i])))",cubic,"['dp', 'graphs', 'shortest paths']",640
"import sys import math from sys import stdin,stdout from math import gcd,floor,sqrt,log from collections import defaultdict as dd inp =lambda: int(input()) strng =lambda: input().strip() jn =lambda x,l: x.join(map(str,l)) strl =lambda: list(input().strip()) mul =lambda: map(int,input().strip().split()) mulf =lambda: map(float,input().strip().split()) seq =lambda: list(map(int,input().strip().split())) mod=1000000007 n,m,k=mul() dp=[[[0 for l in range(k//2+1)]for j in range(m)]for i in range(n)] h=[] v=[] for i in range(n): h.append(seq()) for i in range(n-1): v.append(seq()) def sol(n,m,k): for l in range(1,k//2+1): for i in range(n): for j in range(m): dp[i][j][l]=float(""inf"") if j-1>=0: dp[i][j][l]=min(dp[i][j][l],dp[i][j-1][l-1]+h[i][j-1]) if i-1>=0: dp[i][j][l]=min(dp[i][j][l],dp[i-1][j][l-1]+v[i-1][j]) if j+1<m: dp[i][j][l]=min(dp[i][j][l],dp[i][j+1][l-1]+h[i][j]) if i+1<n: dp[i][j][l]=min(dp[i][j][l],dp[i+1][j][l-1]+v[i][j]) return dp if k%2: for i in range(n): for j in range(m): print(-1,end="" "") print() else: ans=sol(n,m,k) for i in range(n): for j in range(m): print(2*ans[i][j][k//2],end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",1126
"import os, sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") n,m,k=map(int,input().split()) row=[] for _ in range(n): row.append([10**6+2]+list(map(int,input().split()))+[10**6+2]) col=[[10**6+2]*(m+2)] for _ in range(n-1): col.append([10**6+2]+list(map(int,input().split()))+[10**6+2]) col.append([10**6+2]*(m+2)) if k%2: dp=[[-1 for i in range(m)] for j in range(n)] else: k=k//2 dp = [[0 for i in range(m)] for j in range(n)] for i in range(n): for j in range(m): dp[i][j]=2*min(row[i][j],row[i][j+1],col[i][j+1],col[i+1][j+1]) k-=1 while k: k-=1 temp = [[0 for i in range(m)] for j in range(n)] for i in range(n): for j in range(m): ck=dp[i][j]*8 if i>=1: ck=min(ck,",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os import sys from io import BytesIO, IOBase import threading from bisect import bisect_right from math import gcd,log from collections import Counter,defaultdict,deque from pprint import pprint from itertools import permutations from bisect import bisect_right from random import randint as rti n,m=0,0 def main(tnum): global n,m,d n,m,k=map(int,input().split()) if k%2: ans=[[-1]*m for i in range(n)] for li in ans: print(*li) return cost=dict() dp=[[float('inf')]*m for i in range(n)] crr=[] rrr=[] for i in range(n): arr=list(map(int,input().split())) for j in range(m-1): dp[i][j]=min(dp[i][j],arr[j]) dp[i][j+1]=min(dp[i][j+1],arr[j]) crr.append(arr) for i in range(n-1): arr=list(map(int,input().split())) for j in range(m): dp[i][j]=min(dp[i][j],arr[j]) dp[i+1][j]=min(dp[i+1][j],arr[j]) rrr.append(arr) for i in range(1,k//2): ndp=[[float('inf')]*m for i in range(n)] for i in range(n): for j in range(m): x,y=i,j if x>0: ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y]) if x<n-1: ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y]) if y>0: ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1]) if y<m-1: ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y]) dp=ndp for li in dp: li=[2*x for x in li] print(*li) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self",cubic,"['dp', 'graphs', 'shortest paths']",1999
"from sys import stdin, stdout, maxsize from math import inf R = lambda : stdin.readline().strip() RL = lambda f=None: list(map(f, R().split(' '))) if f else list(R().split(' ')) output = lambda x: stdout.write(str(x) + '\n') output_list = lambda x: output(' '.join(map(str, x))) n, m, K = RL(int) if K%2: for i in range(n): print( *(m*[-1]) ) exit() hor = [ RL(int) +[inf] for i in range(n) ] vert = [ RL(int) for i in range(n-1) ] + [ m*[inf] ] K = K//2 dp = [ [m*[inf] for i in range(n)] for j in range(0, K+1)] dp[0] = [m*[0] for i in range(n)] def valid(i, j): if -1 < i < n and -1 < j < m: return True return False for k in range(1, K+1): for i in range(n): for j in range(m): if valid(i, j+1): dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j+1] + 2*hor[i][j]) if valid(i+1, j): dp[k][i][j] = min(dp[k][i][j], dp[k-1][i+1][j] + 2*vert[i][j]) if valid(i-1, j): dp[k][i][j] = min(dp[k][i][j], dp[k-1][i-1][j] + 2*vert[i-1][j]) if valid(i, j-1): dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j-1] + 2*hor[i][j-1]) for i in dp[-1]: print(*i)",cubic,"['dp', 'graphs', 'shortest paths']",1034
"d4i=[0,-1,0,1] d4j=[-1,0,1,0] def main(): n,m,k=readIntArr() horizontalEdges=[] for _ in range(n): horizontalEdges.append(readIntArr()) verticalEdges=[] for _ in range(n-1): verticalEdges.append(readIntArr()) if k%2==1: ans=makeArr(-1,[n,m]) else: dp=makeArr(inf,[n,m,k//2+1]) for i in range(n): for j in range(m): dp[i][j][0]=0 for nM in range(1,k//2+1): for i in range(n): for j in range(m): if j+1<m: dp[i][j][nM]=min(dp[i][j][nM], dp[i][j+1][nM-1]+horizontalEdges[i][j]) if j-1>=0: dp[i][j][nM]=min(dp[i][j][nM], dp[i][j-1][nM-1]+horizontalEdges[i][j-1]) if i+1<n: dp[i][j][nM]=min(dp[i][j][nM], dp[i+1][j][nM-1]+verticalEdges[i][j]) if i-1>=0: dp[i][j][nM]=min(dp[i][j][nM], dp[i-1][j][nM-1]+verticalEdges[i-1][j]) ans=makeArr(0,[n,m]) for i in range(n): for j in range(m): ans[i][j]=dp[i][j][k//2]*2 multiLineArrayOfArraysPrint(ans) return import sys input=sys.stdin.buffer.readline def oneLineArrayPrint(arr): print(' '.join([str(x) for x in arr])) def multiLineArrayPrint(arr): print('\n'.join([str(x) for x in arr])) def multiLineArrayOfArraysPrint(arr): print('\n'.join([' '.join([str(x) for x in y]) for y in arr])) def readIntArr(): return [int(x) for x in input().split()] def makeArr(defaultVal,dimensionArr): dv=defaultVal;da=dimensionArr if len(da)==1:return [dv for _ in range(da[0])] else:return [makeArr(dv,da[1:]) for _ in range(da[0])] def queryInteractive(x,y): print('? {} {}'.format(x,y)) sys.stdout.flush() return int(input()) def answerInteractive(ans): print('! {}'.format(ans)) sys.stdout.flush() inf=float('inf') MOD=998244353 for _abc in range(1): main()",cubic,"['dp', 'graphs', 'shortest paths']",1584
"import os from sys import stdin from math import inf dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] def solve(tc): N, M, K = map(int, stdin.readline().split()) wx = [[] for j in range(N)] for i in range(N): wx[i] = list(map(int, stdin.readline().split())) wy = [[] for i in range(N-1)] for i in range(N-1): wy[i] = list(map(int, stdin.readline().split())) if K & 1: for i in range(N): for j in range(M): print(-1, end=' ') print() return mem = [[[0 for i in range(M)] for j in range(N)] for k in range(K+1)] half = K // 2 for kk in range(1, half+1): for yy in range(N): for xx in range(M): mem[kk][yy][xx] = inf for d in range(4): y = yy + dy[d] x = xx + dx[d] if y < 0 or y >= N or x < 0 or x >= M: continue if d == 0: mem[kk][yy][xx] = min( mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][xx]*2) elif d == 1: mem[kk][yy][xx] = min( mem[kk][yy][xx], mem[kk-1][y][x] + wy[yy][xx]*2) elif d == 2: mem[kk][yy][xx] = min( mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][x]*2) else: mem[kk][yy][xx] = min( mem[kk][yy][xx], mem[kk-1][y][x] + wy[y][xx]*2) for yy in range(N): for xx in range(M): print(mem[half][yy][xx], end=' ') print() tcs = 1 tc = 1 while tc <= tcs: solve(tc) tc += 1",cubic,"['dp', 'graphs', 'shortest paths']",1160
"n,m,k = map(int,input().split()) wh=[] for j in range(n): l=list(map(int,input().split())) wh.append(l) wv=[] for j in range(n-1): l=list(map(int,input().split())) wv.append(l) if(k%2!=0): ans = [[-1 for _ in range(m)]for j in range(n)] for res in ans: print(*res) else: dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)] for x in range(1,21): for i in range(1,n+1): for j in range(1,m+1): dp[i][j][x]=1234567890 if(i!=n): dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1]) if(i!=1): dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1]) if(j!=m): dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1]) if(j!=1): dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2]) for i in range(1,n+1): for j in range(1,m+1): ans = 1234567890 for x in range(1,k+1): if(k%x==0 and (k//x)%2==0 ): ans = min(ans,dp[i][j][x]*(k//x)) print(ans,end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",879
"n,m,k = map(int,input().split()) wh=[] for j in range(n): l=list(map(int,input().split())) wh.append(l) wv=[] for j in range(n-1): l=list(map(int,input().split())) wv.append(l) if(k%2!=0): ans = [[-1 for _ in range(m)]for j in range(n)] for res in ans: print(*res) else: dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)] for x in range(1,k+1): for i in range(1,n+1): for j in range(1,m+1): dp[i][j][x]=1234567890 if(i!=n): dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1]) if(i!=1): dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1]) if(j!=m): dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1]) if(j!=1): dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2]) for i in range(1,n+1): for j in range(1,m+1): ans = 1234567890 for x in range(1,k+1): if(k%x==0 and (k//x)%2==0 ): ans = min(ans,dp[i][j][x]*(k//x)) print(ans,end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",880
"import os,sys,math from io import BytesIO, IOBase from collections import defaultdict,deque,OrderedDict import bisect as bi def yes():print('YES') def no():print('NO') def I():return (int(input())) def In():return(map(int,input().split())) def ln():return list(map(int,input().split())) def Sn():return input().strip() BUFSIZE = 8192 def find_gt(a, x): i = bi.bisect_left(a, x) if i != len(a): return i else: return len(a) def solve(): n,m,k=In() rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)] for i in range(n): z=list(In()) for j in range(m-1): rt[i][j]=z[j] for i in range(n-1): z=list(In()) for j in range(m): do[i][j]=z[j] dp=[[0]*m for i in range(n)] if k%2==1: for i in range(n): print(*[-1]*m) return k//=2 for op in range(k): dp_next=[[P]*m for i in range(n)] for i in range(n): for j in range(m): ans=Inf if i!=0: ans=min(ans,dp[i-1][j]+do[i-1][j]) if j!=0: ans=min(ans,dp[i][j-1]+rt[i][j-1]) if i!=n-1: ans = min( ans , dp[i+1][j]+do[i][j]) if j!=m-1 : ans=min( ans , dp[i][j+1]+rt[i][j]) dp_next[i][j]=ans for i in range(n): for j in range(m): dp[i][j]=dp_next[i][j] for i in range(n): for j in range(m): print(2*dp[i][j],end=' ') print() def main(): T=1 for i in range(T): solve() M = 998244353 P = 1000000007 Inf=float('inf') class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.bu",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os,sys,math from io import BytesIO, IOBase from collections import defaultdict,deque,OrderedDict import bisect as bi def yes():print('YES') def no():print('NO') def I():return (int(input())) def In():return(map(int,input().split())) def ln():return list(map(int,input().split())) def Sn():return input().strip() BUFSIZE = 8192 def find_gt(a, x): i = bi.bisect_left(a, x) if i != len(a): return i else: return len(a) def solve(): n,m,k=In() rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)] for i in range(n): z=list(In()) for j in range(m-1): rt[i][j]=z[j] for i in range(n-1): z=list(In()) for j in range(m): do[i][j]=z[j] dp=[[0]*m for i in range(n)] if k%2==1: for i in range(n): print(*[-1]*m) return k//=2 dp_next=[[P]*m for i in range(n)] for op in range(k): for i in range(n): for j in range(m): ans=Inf if i!=0: ans=min(ans,dp[i-1][j]+do[i-1][j]) if j!=0: ans=min(ans,dp[i][j-1]+rt[i][j-1]) if i!=n-1: ans = min( ans , dp[i+1][j]+do[i][j]) if j!=m-1 : ans=min( ans , dp[i][j+1]+rt[i][j]) dp_next[i][j]=ans for i in range(n): for j in range(m): dp[i][j]=dp_next[i][j] for i in range(n): for j in range(m): print(2*dp[i][j],end=' ') print() def main(): T=1 for i in range(T): solve() M = 998244353 P = 1000000007 Inf=float('inf') class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.bu",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os,sys,math from io import BytesIO, IOBase from collections import defaultdict,deque,OrderedDict import bisect as bi def yes():print('YES') def no():print('NO') def I():return (int(input())) def In():return(map(int,input().split())) def ln():return list(map(int,input().split())) def Sn():return input().strip() BUFSIZE = 8192 def find_gt(a, x): i = bi.bisect_left(a, x) if i != len(a): return i else: return len(a) def solve(): n,m,k=In() rt,do=[list(In()) for i in range(n)],[list(In()) for i in range(n-1)] dp=[[0]*m for i in range(n)] if k%2==1: for i in range(n): print(*[-1]*m) return k//=2 dp_next=[[P]*m for i in range(n)] for op in range(k): for i in range(n): for j in range(m): ans=Inf if i!=0: ans=min(ans,dp[i-1][j]+do[i-1][j]) if j!=0: ans=min(ans,dp[i][j-1]+rt[i][j-1]) if i!=n-1: ans = min( ans , dp[i+1][j]+do[i][j]) if j!=m-1 : ans=min( ans , dp[i][j+1]+rt[i][j]) dp_next[i][j]=ans for i in range(n): for j in range(m): dp[i][j]=dp_next[i][j] for i in range(n): for j in range(m): print(2*dp[i][j],end=' ') print() def main(): T=1 for i in range(T): solve() M = 998244353 P = 1000000007 Inf=float('inf') class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.",cubic,"['dp', 'graphs', 'shortest paths']",2000
"n, m, K = map(int, input().split()) wh = [[0]*m for i in range(n)] wv = [[0]*m for i in range(n)] for i in range(n): t = list(map(int, input().split())) for j in range(m-1): wh[i][j] = t[j] for i in range(n-1): t = list(map(int, input().split())) for j in range(m): wv[i][j] = t[j] f = [[[int(1e8)]* 11 for j in range(m)] for i in range(n)] for i in range(n): for j in range(m): f[i][j][0] = 0 for k in range(1, K//2+1): for i in range(n): for j in range(m): if i > 0: f[i][j][k] = min(f[i][j][k], f[i-1][j][k-1]+wv[i-1][j]) if j < m-1: f[i][j][k] = min(f[i][j][k], f[i][j+1][k-1]+wh[i][j]) if i < n-1: f[i][j][k] = min(f[i][j][k], f[i+1][j][k-1]+wv[i][j]) if j > 0: f[i][j][k] = min(f[i][j][k], f[i][j-1][k-1]+wh[i][j-1]) for i in range(n): for j in range(m): if K%2 == 1: print(-1) else: dp = [int(1e8)]*(K//2+1) dp[0] = 0 for k in range(1, K//2+1): for l in range(0, k): dp[k] = min(dp[k], dp[l]+f[i][j][k-l]*2) print(dp[K//2])",cubic,"['dp', 'graphs', 'shortest paths']",930
"from sys import stdin readline = stdin.readline def readInt(): return int(readline()) def readInts(): return list(map(int,readline().split())) U, D, L, R = 0, 1, 2, 3 DIR = [(-1,0), (1,0), (0,-1), (0,1)] n, m, k = readInts() moves = [[[-1 for _ in range(4)] for _ in range(m)] for _ in range(n)] right = [] down = [] for i in range(n): row = readInts() right.append(row) for i in range(n-1): row = readInts() down.append(row) if k % 2 == 1: for _ in range(n): for _ in range(m): print(-1, end="" "") print() exit() k //= 2 dp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)] for l in range(k): for i in range(n): for j in range(m): dp[i][j][l+1] = float(""inf"") if i > 0: dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j]) if j > 0: dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1]) if i < n - 1: dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j]) if j < m - 1: dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j]) for i in range(n): for j in range(m): print(2*dp[i][j][k], end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",1057
"from sys import stdin readline = stdin.readline def readInt(): return int(readline()) def readInts(): return list(map(int,readline().split())) n, m, k = readInts() right = [] down = [] for i in range(n): row = readInts() right.append(row) for i in range(n-1): row = readInts() down.append(row) if k % 2 == 1: for _ in range(n): for _ in range(m): print(-1, end="" "") print() exit() k //= 2 dp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)] for l in range(k): for i in range(n): for j in range(m): dp[i][j][l+1] = float(""inf"") if i > 0: dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j]) if j > 0: dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1]) if i < n - 1: dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j]) if j < m - 1: dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j]) for i in range(n): for j in range(m): print(2*dp[i][j][k], end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",925
"import math n,m,kk=[int(x) for x in input().split()] right,down=[],[] for i in range(n) : a=[int(x) for x in input().split()] right.append(a) for i in range(n-1) : a=[int(x) for x in input().split()] down.append(a) dp,dpCopy=[],[] for i in range(n) : li,li1=[],[] for j in range(m) : li.append(math.inf) li1.append(math.inf) dp.append(li) dpCopy.append(li1) for i in range(1,(kk//2)+1) : for j in range(n) : for k in range(m) : if i==1 : if j==0 : if k==0 : dp[j][k]=min(dp[j][k],down[j][k],right[j][k]) elif k==m-1 : dp[j][k]=min(dp[j][k],right[j][k-1],down[j][k]) else : dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k]) elif j==n-1 : if k==0 : dp[j][k]=min(dp[j][k],down[j-1][k],right[j][k]) elif k==m-1 : dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k]) else : dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k]) elif k==0 : dp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k]) elif k==m-1 : dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k]) else : dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k]) continue if j==0 : if k==0 : dp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k]) elif k==m-1 : dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k]) else : dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k]) elif j==n-1 : if k==0 : dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k]) elif k==m-1 : dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1]) else : dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k]) elif k==0 : dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k]) elif k==m-1 : dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1]) else : dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k]) for ii in range(n) : f",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import math def read_ints(): return map(int, input().split()) def read_matrix(n): return [list(read_ints()) for _ in range(n)] def around(x, y, hor, ver, mtx): a, b, c, d = [math.inf]*4 if x > 0: a = hor[y][x - 1] * 2 + mtx[y][x - 1] if x < m - 1: b = hor[y][x] * 2 + mtx[y][x + 1] if y > 0: c = ver[y - 1][x] * 2 + mtx[y - 1][x] if y < n - 1: d = ver[y][x] * 2 + mtx[y + 1][x] return min(a, b, c, d) if __name__ == ""__main__"": n, m, k = read_ints() hor = read_matrix(n) ver = read_matrix(n - 1) if k % 2: for i in range(n): print('-1 ' * m) exit() _old = [[0] * m for _ in range(n)] for i in range(k // 2): _new = [[0] * m for _ in ' ' * n] for x in range(m): for y in range(n): _new[y][x] = around(x, y, hor, ver, _old) _old = _new for row in _old: print(*row)",cubic,"['dp', 'graphs', 'shortest paths']",762
"import sys input = sys.stdin.readline def main(): n,m,k = map(int,input().split()) if k%2==1: for i in range(n): for j in range(m): print(-1,end="" "") print() return 0 kk=k maps= [[[0 for i in range(4)] for j in range(m)] for ii in range(n)] dp=[[[1e9 for i in range(k//2+1)] for j in range(m)] for ii in range(n)] for i in range(n): for j in range(m): dp[i][j][0]=0 for i in range(n): s=list(map(int,input().split())) for j in range(m-1): maps[i][j][0]=s[j] maps[i][j+1][1]=s[j] for i in range(n-1): s=list(map(int,input().split())) for j in range(m): maps[i][j][2]=s[j] maps[i+1][j][3]=s[j] for k in range(1,kk//2+1): for i in range(n): for j in range(m): if j<m-1: dp[i][j+1][k]=min(dp[i][j+1][k],dp[i][j][k-1]+maps[i][j][0]) if i<n-1: dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k-1]+maps[i][j][2]) if i>0: dp[i-1][j][k]=min(dp[i-1][j][k],dp[i][j][k-1]+maps[i][j][3]) if j>0: dp[i][j-1][k]=min(dp[i][j-1][k],dp[i][j][k-1]+maps[i][j][1]) for i in range(n): for j in range(m): print(dp[i][j][k]*2,end="" "") print() main()",cubic,"['dp', 'graphs', 'shortest paths']",1018
"from math import inf n, m, k = map(int, input().split()) horizontal_costs = [] vertical_costs = [] for _ in range(n): horizontal_costs.append(list(map(int, input().split()))) for _ in range(n-1): vertical_costs.append(list(map(int, input().split()))) dp = [[[inf] * (k // 2 + 1) for _ in range(m)] for _ in range(n)] def find_cost(a, b, c): global dp if a < 0 or a > n-1 or b < 0 or b > m-1: return inf if c == 0: return 0 if dp[a][b][c] != inf: return dp[a][b][c] if a < n-1: dp[a][b][c] = find_cost(a+1, b, c-1) + vertical_costs[a][b] if b < m-1: dp[a][b][c] = min(dp[a][b][c], find_cost(a, b+1, c-1) + horizontal_costs[a][b]) if b > 0: dp[a][b][c] = min(dp[a][b][c], find_cost(a, b-1, c-1) + horizontal_costs[a][b-1]) if a > 0: dp[a][b][c] = min(dp[a][b][c], find_cost(a-1, b, c-1) + vertical_costs[a-1][b]) return dp[a][b][c] ans = [[inf] * m for _ in range(n)] if k % 2 == 1: for i in range(n): for j in range(m): ans[i][j] = -1 else: for i in range(n): for j in range(m): ans[i][j] = min(ans[i][j], 2 * find_cost(i, j, k//2)) for row in ans: print(*row)",cubic,"['dp', 'graphs', 'shortest paths']",1059
"from sys import stdin,stdout from math import gcd,sqrt,factorial,pi,inf from collections import deque,defaultdict from bisect import bisect,bisect_left from time import time from itertools import permutations as per input=stdin.readline R=lambda:map(int,input().split()) I=lambda:int(input()) S=lambda:input().rstrip('\r\n') L=lambda:list(R()) P=lambda x:stdout.write(str(x)+'\n') lcm=lambda x,y:(x*y)//gcd(x,y) nCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N inv=lambda x:pow(x,N-2,N) sm=lambda x:(x**2+x)//2 N=10**9+7 n,m,k=R() A=[L() for i in range(n)] B=[L() for i in range(n-1)] if k&1: for i in range(n): print('-1 '*m) exit() X=[[0]*m for i in range(n)] for _ in range(k//2): Y=[[inf]*m for i in range(n)] for i in range(n): for j in range(m): if i: Y[i][j]=X[i-1][j]+2*B[i-1][j] if i<n-1: Y[i][j]=min(Y[i][j],X[i+1][j]+2*B[i][j]) if j: Y[i][j]=min(Y[i][j],X[i][j-1]+2*A[i][j-1]) if j<m-1: Y[i][j]=min(Y[i][j],X[i][j+1]+2*A[i][j]) X=Y for i in X: print(*i)",cubic,"['dp', 'graphs', 'shortest paths']",960
"def roll(i,j): ways = [] if j: ways.append(2*hor[i][j-1] + grid[i][j-1]) if m-1-j: ways.append(2*hor[i][j] + grid[i][j+1]) if i: ways.append(2*ver[i-1][j] + grid[i-1][j]) if n-1-i: ways.append(2*ver[i][j] + grid[i+1][j]) return min(ways) n , m , k = map(int, input().split()) hor = [list(map(int, input().split())) for _ in range(n)] ver = [list(map(int, input().split())) for _ in range(n-1)] grid = [[0]*m for _ in range(n)] if k%2: for _ in range(n): print("" "".join([""-1""]*m)) else: for _ in range(k//2): new_grid = [[roll(i,j) for j in range(m)] for i in range(n)] grid = new_grid[:] for i in range(n): print("" "".join(map(str,grid[i])))",cubic,"['dp', 'graphs', 'shortest paths']",640
"n, m, k = map(int, input().split()) a = [list(map(int, input().split())) for _ in range(n)] b = [list(map(int, input().split())) for _ in range(n-1)] if k % 2 == 1: for i in range(n): print(*[-1]*m) exit() k //= 2 INF = 10**18 dp = [[[INF]*(k+1) for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): dp[i][j][0] = 0 for v in range(1, k+1): for i in range(n): for j in range(m): now_h, now_w = i, j if i > 0: dp[i][j][v] = min(dp[i-1][j][v-1]+b[i-1][j], dp[i][j][v]) if i < n-1: dp[i][j][v] = min(dp[i+1][j][v-1]+b[i][j], dp[i][j][v]) if j > 0: dp[i][j][v] = min(dp[i][j-1][v-1]+a[i][j-1], dp[i][j][v]) if j < m-1: dp[i][j][v] = min(dp[i][j+1][v-1]+a[i][j], dp[i][j][v]) for i in range(n): v = [] for j in range(m): v.append(dp[i][j][k]*2) print(*v)",cubic,"['dp', 'graphs', 'shortest paths']",770
"from math import inf n, m, k = map(int, input().split()) horizontal = [] vertical = [] for _ in range(n): horizontal.append(list(map(int, input().split()))) for _ in range(n - 1): vertical.append(list(map(int, input().split()))) if k & 1: ans = [""-1""] * m for _ in range(n): print(*ans) else: grid = [[0 for i in range(m)] for j in range(n)] for _ in range(k // 2): X = [[inf for i in range(m)] for j in range(n)] for i in range(n): for j in range(m): if i >= 1: X[i][j] = min(2 * vertical[i - 1][j] + grid[i - 1][j], X[i][j]) if i < n - 1: X[i][j] = min(2 * vertical[i][j] + grid[i + 1][j], X[i][j]) if j >= 1: X[i][j] = min(2 * horizontal[i][j - 1] + grid[i][j - 1], X[i][j]) if j < m - 1: X[i][j] = min(2 * horizontal[i][j] + grid[i][j + 1], X[i][j]) grid = X[:] for _ in range(n): print(*grid[_])",cubic,"['dp', 'graphs', 'shortest paths']",800
"from sys import stdin input=stdin.readline def answer(): dp=[[[1e9 for i in range(k//2 + 1)] for j in range(m)] for i in range(n)] for i in range(n): for j in range(m): dp[i][j][0]=0 for x in range(1,k//2 + 1): for i in range(n): for j in range(m): if(i > 0): dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1] + c[i-1][j]) if(j > 0): dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1] + r[i][j-1]) if(i + 1 < n): dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1] + c[i][j]) if(j + 1 < m): dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1] + r[i][j]) for i in range(n): for j in range(m): print(2*dp[i][j][-1],end=' ') print() n,m,k=map(int,input().split()) r=[list(map(int,input().split())) for i in range(n)] c=[list(map(int,input().split())) for i in range(n-1)] if(k & 1): for i in range(n): for j in range(m): print(-1,end=' ') else:answer()",cubic,"['dp', 'graphs', 'shortest paths']",820
"inf=10000000000 n,m,k=(int(i) for i in input().split()) h=[[int(i) for i in input().split()]for i in range(n)] z=[[int(i) for i in input().split()]for i in range(n-1)] dh=lambda x,y:h[x][y] if 0<=x<len(h) and 0<=y<len(h[0]) else inf dz=lambda x,y:z[x][y] if 0<=x<len(z) and 0<=y<len(z[0]) else inf dp=[[[0 for iii in range(m)] for ii in range(n)] for i in range(2)] ddp=lambda x,y,z:dp[x][y][z] if 0<=y<n and 0<=z<m else inf if k%2!=0: for i in dp[0]: for j in i: print(-1,end=' ') print() else: for kk in range(int(k/2)): for i in range(n): for j in range(m): dp[1][i][j]=min(ddp(0,i-1,j)+dz(i-1,j),ddp(0,i+1,j)+dz(i,j),ddp(0,i,j-1)+dh(i,j-1),ddp(0,i,j+1)+dh(i,j)) dp.reverse() for i in dp[0]: for j in i: print(2*j,end=' ') print()",cubic,"['dp', 'graphs', 'shortest paths']",733
"from sys import stdin, stdout import heapq from collections import defaultdict import math import bisect def main(): n,m,k = list(map(int, stdin.readline().split())) right = [] for _ in range(n): right.append(list(map(int, stdin.readline().split()))) down = [] for _ in range(n-1): down.append(list(map(int, stdin.readline().split()))) if k % 2 == 1: for _ in range(n): stdout.write("" "".join([""-1"" for _ in range(m)])+""\n"") return dp = [[0 for _ in range(m)] for _ in range(n)] for x in range(1, (k//2) + 1): tmp = [[math.inf for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): if i: tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j]) if i < n-1: tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j]) if j: tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1]) if j < m-1: tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j]) dp = tmp for i in range(n): stdout.write("" "".join([str(x) for x in dp[i]]) + ""\n"") main()",cubic,"['dp', 'graphs', 'shortest paths']",965
"def main(): N, M, K = map(int, input().split()) if K % 2: print((""-1 "" * M + ""\n"") * N) return colEdges = [] for i in range(N): edges = list(map(int, input().split())) colEdges.append(edges) rowEdges = [] for i in range(N - 1): edges = list(map(int, input().split())) rowEdges.append(edges) dp = [[[0 for i in range(M)] for j in range(N)] for k in range(2)] p = [[[(i, j) for j in range(M)] for i in range(N)] for k in range(2)] prev = 0 for k in range(K // 2): cur = prev ^ 1 for i in range(N): for j in range(M): cand = (float('inf'), None) if j: nxt = (dp[prev][i][j - 1] + colEdges[i][j - 1], p[prev][i][j - 1]) cand = min(cand, nxt) if j < M - 1: nxt = (dp[prev][i][j + 1] + colEdges[i][j], p[prev][i][j + 1]) cand = min(cand, nxt) if i: nxt = (dp[prev][i - 1][j] + rowEdges[i - 1][j], p[prev][i - 1][j]) cand = min(cand, nxt) if i < N - 1: nxt = (dp[prev][i + 1][j] + rowEdges[i][j], p[prev][i + 1][j]) cand = min(cand, nxt) dp[cur][i][j], p[cur][i][j] = cand prev = cur for i in range(N): for j in range(M): print(dp[prev][i][j] * 2, end="" "") print() main()",cubic,"['dp', 'graphs', 'shortest paths']",1064
"I=lambda:[*map(int, input().split())] R = range m = min N, M, K = I() R = range if K&1: for _ in R(N): print(*[-1]*M) exit() A = [I() for _ in R(N)] B = [I() for _ in R(N-1)] X = [M*[0]for _ in R(N)] for k in R(1, K//2+1): Y = [M*[9**9]for _ in R(N)] for i in R(N): for j in R(M): if i: Y[i][j] = X[i-1][j] + 2*B[i-1][j] if i<N-1: Y[i][j] = m(Y[i][j], X[i+1][j] + 2*B[i][j]) if j: Y[i][j] = m(Y[i][j], X[i][j-1] + 2*A[i][j-1]) if j<M-1: Y[i][j] = m(Y[i][j], X[i][j+1] + 2*A[i][j]) X = Y for x in X: print(*x)",cubic,"['dp', 'graphs', 'shortest paths']",508
"import sys,math class Node: def __init__(self,u=math.inf,d=math.inf,l=math.inf,r=math.inf): self.up=u self.dn=d self.lt=l self.rt=r def __str__(self): return 'U:{},D:{},L:{},R:{}'.format(self.up,self.dn,self.lt,self.rt) n,m,k=list(map(int,sys.stdin.readline().strip().split())) graph=[[Node() for j in range(m)]for i in range(n)] for i in range(n): wts=list(map(int,sys.stdin.readline().strip().split())) for j in range(m-1): graph[i][j].rt=wts[j] graph[i][j+1].lt=wts[j] for i in range(n-1): wts=list(map(int,sys.stdin.readline().strip().split())) for j in range(m): graph[i][j].dn=wts[j] graph[i+1][j].up=wts[j] ans=[[math.inf for j in range(m)]for i in range(n)] if k%2: [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans] else: def bfs(prsnt,stps): if stps==0: return 0 else: if dp[prsnt[0]][prsnt[1]][stps]==math.inf: min_cost=math.inf for x,y,c in [(0,1,graph[prsnt[0]][prsnt[1]].dn),(1,0,graph[prsnt[0]][prsnt[1]].rt),(0,-1,graph[prsnt[0]][prsnt[1]].up),(-1,0,graph[prsnt[0]][prsnt[1]].lt)]: if -1<prsnt[1]+x<m and -1<prsnt[0]+y<n: min_cost=min(bfs((prsnt[0]+y,prsnt[1]+x),stps-1)+c,min_cost) dp[prsnt[0]][prsnt[1]][stps]=min_cost return min_cost else: return dp[prsnt[0]][prsnt[1]][stps] dp=[[[math.inf for k in range(k+1)] for j in range(m)]for i in range(n)] for i in range(n): for j in range(m): ans[i][j]=bfs((i,j),k//2)*2 [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]",cubic,"['dp', 'graphs', 'shortest paths']",1462
"def main(): import sys read = sys.stdin.read readline = sys.stdin.readline INF = 1 << 60 MOD = 10 ** 9 + 7 sys.setrecursionlimit(10 ** 5) def new_dp(): return [[INF] * M for _ in range(N)] def solve(): if K % 2 == 1: for row in range(N): print(*[-1] * M) return dp_prev = [[0] * M for _ in range(N)] for _ in range(K // 2): dp_cur = new_dp() for row in range(N): for col in range(M - 1): cost = e1[row][col] dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row][col + 1] + cost) dp_cur[row][col + 1] = min(dp_cur[row][col + 1], dp_prev[row][col] + cost) for row in range(N - 1): for col in range(M): cost = e2[row][col] dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row + 1][col] + cost) dp_cur[row + 1][col] = min(dp_cur[row + 1][col], dp_prev[row][col] + cost) dp_prev = dp_cur for row in range(N): _r = [2 * x for x in dp_prev[row]] print(*_r) N, M, K = map(int, readline().split()) e1 = [] for _ in range(N): r = tuple(map(int, readline().split())) e1.append(r) e2 = [] for _ in range(N - 1): r = tuple(map(int, readline().split())) e2.append(r) solve() if __name__ == '__main__': main()",cubic,"['dp', 'graphs', 'shortest paths']",1094
"from collections import defaultdict from sys import stdout,stdin n,m,K=map(int,input().split()) dp=[[[0 for h in range(11)]for j in range(m+1)] for i in range(n+1)] l1=[list(map(int,stdin.readline().split())) for i in range(n)] l2=[list(map(int,stdin.readline().split())) for i in range(n-1)] if K%2: for i in range(n): for j in range(m): print('-1',end=' ') print() else: for k in range(1,K//2+1): for i in range(n): for j in range(m): res=100000000 if i-1>=0 and j>=0: res=min(res,l2[i-1][j]+dp[i-1][j][k-1]) if i+1<n and j>=0: res=min(res,l2[i][j]+dp[i+1][j][k-1]) if 0<=i and j+1<m: res=min(res,l1[i][j]+dp[i][j+1][k-1]) if 0<=i and j-1>=0: res=min(res,l1[i][j-1]+dp[i][j-1][k-1]) dp[i][j][k]=res for i in range(n): for j in range(m): stdout.write(str(2*dp[i][j][K//2])+' ') stdout.write('\n')",cubic,"['dp', 'graphs', 'shortest paths']",797
"def solve(mat1: list, mat2: list, K: int) -> list: if K % 2 == 1: res = [[-1] * n for _ in range(m)] else: dp = [[[-1] * (K // 2 + 1) for _ in range(n)] for _ in range(m)] for k in range(K // 2 + 1): for i in range(m): for j in range(n): if k == 0: dp[i][j][k] = 0 else: if i > 0 and (dp[i][j][k] == -1 or dp[i - 1][j][k - 1] + mat2[i - 1][j] < dp[i][j][k]): dp[i][j][k] = dp[i - 1][j][k - 1] + mat2[i - 1][j] if i < m - 1 and (dp[i][j][k] == -1 or dp[i + 1][j][k - 1] + mat2[i][j] < dp[i][j][k]): dp[i][j][k] = dp[i + 1][j][k - 1] + mat2[i][j] if j > 0 and (dp[i][j][k] == -1 or dp[i][j - 1][k - 1] + mat1[i][j - 1] < dp[i][j][k]): dp[i][j][k] = dp[i][j - 1][k - 1] + mat1[i][j - 1] if j < n - 1 and (dp[i][j][k] == -1 or dp[i][j + 1][k - 1] + mat1[i][j] < dp[i][j][k]): dp[i][j][k] = dp[i][j + 1][k - 1] + mat1[i][j] res = [[-1] * n for _ in range(m)] for i in range(m): for j in range(n): res[i][j] = 2 * dp[i][j][-1] for i in range(m): for j in range(n): if j < n - 1: print(res[i][j], end = ' ') else: print(res[i][j]) return m, n, K = map(int, input().split()) mat1 = [] mat2 = [] for _ in range(m): mat1.append(list(map(int, input().split()))) for _ in range(m - 1): mat2.append(list(map(int, input().split()))) solve(mat1, mat2, K)",cubic,"['dp', 'graphs', 'shortest paths']",1239
"n, m, k = map(int, input().split()) ea = [list(map(int, input().split()))for _ in range(n)] eb = [list(map(int, input().split()))for _ in range(n-1)] dp = [[[10**20]*m for __ in range(n)]for _ in range(k//2+1)] dp[0] = [[0]*m for _ in range(n)] def show_ans(): for line in dp[-1]: print(' '.join(map(str, [d*2 for d in line]))) if k % 2: for i in range(n): print(' '.join(['-1']*m)) exit() for t in range(1, k//2+1): for i in range(n): for j in range(m): if i: dp[t][i][j] = min(dp[t][i][j], dp[t-1][i-1][j]+eb[i-1][j]) if i < n-1: dp[t][i][j] = min(dp[t][i][j], dp[t-1][i+1][j]+eb[i][j]) if j: dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j-1]+ea[i][j-1]) if j < m-1: dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j+1]+ea[i][j]) show_ans()",cubic,"['dp', 'graphs', 'shortest paths']",733
"import sys import io, os import math gcd=math.gcd ceil=math.ceil input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline mod1=(10**9)+7 mod2=998244353 def strinp(testcases): k=5 if(testcases==-1 or testcases==1): k=1 f=str(input()) f=f[2:len(f)-k] return f def alp(a): return (ord(a)-ord(""a"")) def main(): arr=list(map(int, input().split())) n=arr[0] m=arr[1] k=arr[2] lrw=[0]*n for i in range(n): lrw[i]=list(map(int, input().split())) udw=[0]*(n-1) for i in range(n-1): udw[i]=list(map(int, input().split())) if(k%2==1): a=[-1]*m for i in range(n): print(*a) sys.exit() dp1=[[0 for i in range(m)] for j in range(n)] dp2=[[0 for i in range(m)] for j in range(n)] inf=10**10 dis=(k//2) for h in range(dis): for i in range(n): for j in range(m): a=inf b=inf c=inf d=inf if(j>0): a=lrw[i][j-1]+dp2[i][j-1] if(j<m-1): b=lrw[i][j]+dp2[i][j+1] if(i>0): c=udw[i-1][j]+dp2[i-1][j] if(i<n-1): d=udw[i][j]+dp2[i+1][j] dp1[i][j]=min(a,b,c,d) dp2=dp1 dp1=dp1=[[0 for a in range(m)] for b in range(n)] for i in range(n): for j in range(m): dp2[i][j]*=2 for i in range(n): print(*dp2[i]) if __name__ == '__main__': main()",cubic,"['dp', 'graphs', 'shortest paths']",1112
"import sys,os,io input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline n,m,k = [int(i) for i in input().split()] h = [] for i in range (n): h.append([int(i) for i in input().split()]) v = [] for i in range (n-1): v.append([int(i) for i in input().split()]) if k%2: for i in range (n): for j in range (m): print(-1,end="" "") print() exit() dp = [[[float('inf')]*m for i in range (n)] for j in range (k//2+1)] for i in range (n): for j in range (m): dp[0][i][j] = 0 for x in range (1,k//2+1): for i in range (n): for j in range (m): if i!=0: dp[x][i][j] = min(dp[x][i][j], dp[x-1][i-1][j] + v[i-1][j]) if i!=n-1: dp[x][i][j] = min(dp[x][i][j], dp[x-1][i+1][j] + v[i][j]) if j!=0: dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j-1] + h[i][j-1]) if j!=m-1: dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j+1] + h[i][j]) for i in range (n): for j in range (m): print(2*dp[k//2][i][j],end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",892
"import sys inp = [int(x) for x in sys.stdin.read().split()]; ii = 0 n = inp[ii]; ii += 1 m = inp[ii]; ii += 1 k = inp[ii]; ii += 1 if k%2 == 1: for _ in range(n): toprint = [""-1"" for __ in range(m)] print("" "".join(toprint)) sys.exit() yw = [] for _ in range(n): yw.append(inp[ii:ii+m-1]) ii += m-1 xw = [] for _ in range(n-1): xw.append(inp[ii:ii+m]) ii += m inf = 10**10 steps = k//2 dp = [[[inf for _ in range(m)] for _ in range(n)] for _ in range(steps+1)] for i in range(n): for j in range(m): dp[0][i][j] = 0 for step in range(1, steps + 1): for i in range(n): for j in range(m): if i > 0: dp[step][i][j] = min(dp[step][i][j], dp[step-1][i-1][j] + xw[i-1][j]) if i < n-1: dp[step][i][j] = min(dp[step][i][j], dp[step-1][i+1][j] + xw[i][j]) if j > 0: dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j-1] + yw[i][j-1]) if j < m-1: dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j+1] + yw[i][j]) for x in dp[-1]: print("" "".join(list(map(str, [2*o for o in x]))))",cubic,"['dp', 'graphs', 'shortest paths']",971
"n, m, k = map(int, input().split()) h = [] for i in range(n): h.append(list(map(int, input().split()))) v = [] for i in range(n - 1): v.append(list(map(int, input().split()))) if k % 2 == 0: d = [[0] * m for i in range(n)] for t in range(k // 2): dt = [[0] * m for i in range(n)] for i in range(n): for j in range(m): x = float('inf') if i - 1 >= 0: x = min(x, d[i - 1][j] + v[i - 1][j] * 2) if i + 1 < n: x = min(x, d[i + 1][j] + v[i][j] * 2) if j - 1 >= 0: x = min(x, d[i][j - 1] + h[i][j - 1] * 2) if j + 1 < m: x = min(x, d[i][j + 1] + h[i][j] * 2) dt[i][j] = x d = dt.copy() else: d = [[-1] * m for i in range(n)] for i in d: print(*i)",cubic,"['dp', 'graphs', 'shortest paths']",640
"import sys sys.stderr = sys.stdout from math import inf def explorer(n, m, k, R, C): if k % 2: return None G = [[0] * m for _ in range(n)] G_ = [[0] * m for _ in range(n)] for _ in range(k // 2): for i in range(n): for j in range(m): x = inf if i > 0: x = min(x, G[i-1][j] + 2*C[i-1][j]) if i + 1 < n: x = min(x, G[i+1][j] + 2*C[i][j]) if j > 0: x = min(x, G[i][j-1] + 2*R[i][j-1]) if j + 1 < m: x = min(x, G[i][j+1] + 2*R[i][j]) G_[i][j] = x G, G_ = G_, G return G def main(): n, m, k = readinti() R = readintll(n) C = readintll(n-1) G = explorer(n, m, k, R, C) if G: print(llstr(G)) else: s = ' '.join('-1' for _ in range(m)) print('\n'.join(s for _ in range(n))) def readint(): return int(input()) def readinti(): return map(int, input().split()) def readintt(): return tuple(readinti()) def readintl(): return list(readinti()) def readinttl(k): return [readintt() for _ in range(k)] def readintll(k): return [readintl() for _ in range(k)] def lstr(l): return ' '.join(map(str, l)) def llstr(ll): return '\n'.join(map(lstr, ll)) def log(*args, **kwargs): print(*args, **kwargs, file=sys.__stderr__) if __name__ == '__main__': main()",cubic,"['dp', 'graphs', 'shortest paths']",1135
"import sys sys.setrecursionlimit(50000) for _ in range(1): n,m,k = map(int,input().split()) s = [[[-1,-1,-1,-1] for _ in range(m)] for _ in range(n)] for i in range(n): d = [int(x) for x in input().split()] for j in range(m-1): s[i][j][1] = d[j] s[i][j+1][3] = d[j] for i in range(n-1): d = [int(x) for x in input().split()] for j in range(m): s[i][j][2] = d[j] s[i+1][j][0] = d[j] if k%2==1: for i in range(n): print(*[-1 for _ in range(m)]) continue dp = [[[9999999 for _ in range(k//2+1)] for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): dp[i][j][0] = 0 for q in range(1,k//2+1): for i in range(n): for j in range(m): cands = [] if i > 0: cands.append(dp[i-1][j][q-1] + s[i-1][j][2]) if j > 0: cands.append(dp[i][j-1][q-1] + s[i][j-1][1]) if i < n - 1: cands.append(dp[i+1][j][q-1] + s[i+1][j][0]) if j < m - 1: cands.append(dp[i][j+1][q-1] + s[i][j+1][3]) dp[i][j][q] = min(cands) for i in range(n): for j in range(m): print(2*dp[i][j][k//2],end=' ') print()",cubic,"['dp', 'graphs', 'shortest paths']",989
"import sys import math import collections import heapq import decimal input=sys.stdin.readline n,m,k = map(int,input().split()) a=[] for i in range(n): a.append(list(map(int,input().split()))) b=[] for i in range(n-1): b.append(list(map(int,input().split()))) if(k%2==1): for i in range(n): for j in range(m): print(-1,end = "" "") print() else: k//=2 pre=[[0 for i in range(m)]for j in range(n)] for x in range(k): curr = [[float(""inf"") for i in range(m)]for j in range(n)] for i in range(n): for j in range(m): if(j>0): curr[i][j]=min(curr[i][j],pre[i][j-1]+a[i][j-1]) if(i<n-1): curr[i][j]=min(curr[i][j],pre[i+1][j]+b[i][j]) if(j<m-1): curr[i][j]=min(curr[i][j],pre[i][j+1]+a[i][j]) if(i>0): curr[i][j]=min(curr[i][j],pre[i-1][j]+b[i-1][j]) pre=curr[:] for i in range(n): for j in range(m): print(2*pre[i][j],end = "" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",829
"n, m, K=map(int, input().split()) edgesh=[[0 for i in range(m-1)] for k in range(n)] edgesv=[[0 for i in range(m)] for k in range(n-1)] for mm in range(n): edgesh[mm]=list(map(int, input().split("" ""))) for mm in range(n-1): edgesv[mm]=list(map(int, input().split("" ""))) dp=[[[10**10 for tro in range(K+1)] for i in range(m)] for mm in range(n)] for k in range(0, K+1, 2): for i in range(n): for j in range(m): if(k==0): dp[i][j][k]=0 elif(i==0 and j==0): dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2]) elif(i==0 and j==m-1): dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2]) elif(i==0): dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2]) elif(j==0 and i==n-1): dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2]) elif(j==0): dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2]) elif(i==n-1 and j==m-1): dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2]) elif(i==n-1): dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2]) elif(j==m-1): dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2]) else: dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2]) for i in range(n): for j in range(m): if(dp[i][j][K]>=10**10): print(-1, end="" "") else: print(dp[i][j][K], end="" "") print()",cubic,"['dp', 'graphs', 'shortest paths']",1643
"import os, sys from io import BytesIO, IOBase class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") class dict(dict): def __missing__(self, key): return 0 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") inp = lambda dtype: [dtype(x) for x in input().split()] inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)] inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)] inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))] inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)] ceil1 = lambda a, b: (a + b - 1) // b valid = lambda x, y: -1 < x < n and -1 < y < m dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1) n, m, k = inp(int) if k & 1: [print(*([-1] * m)) for _ in range(n)] exit() right, down = [[0] * m for _ in range(n)",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os, sys from io import BytesIO, IOBase class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") class dict(dict): def __missing__(self, key): return 0 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") inp = lambda dtype: [dtype(x) for x in input().split()] inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)] inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)] inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))] inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)] ceil1 = lambda a, b: (a + b - 1) // b valid = lambda x, y: -1 < x < n and -1 < y < m dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1) n, m, k = inp(int) if k & 1: [print(*([-1] * m)) for _ in range(n)] exit() right, down = [[0] * m for _ in range(n)",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os, sys from io import BytesIO, IOBase class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") class dict(dict): def __missing__(self, key): return 0 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") inp = lambda dtype: [dtype(x) for x in input().split()] inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)] inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)] inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))] inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)] ceil1 = lambda a, b: (a + b - 1) // b valid = lambda x, y: -1 < x < n and -1 < y < m dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1) n, m, k = inp(int) if k & 1: [print(*([-1] * m)) for _ in range(n)] exit() right, down = [[0] * m for _ in range(n)",cubic,"['dp', 'graphs', 'shortest paths']",2000
"import os, sys from io import BytesIO, IOBase class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") class dict(dict): def __missing__(self, key): return 0 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") inp = lambda dtype: list(map(dtype, input().split())) inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)] inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)] inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))] inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)] ceil1 = lambda a, b: (a + b - 1) // b valid = lambda x, y: -1 < x < n and -1 < y < m dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1) n, m, k = inp(int) if k & 1: [print(*([-1] * m)) for _ in range(n)] exit() right, down = [[0] * m for _ in range(n)],",cubic,"['dp', 'graphs', 'shortest paths']",2000
"def permuteDigits(a, b): n = len(a) if len(a) < len(b): return a i = 0 c = 0 t = a[0] flag = 0 lastind = [] while i<len(a) and i< len(b) and a[i] >= b[i] : if c == n: i = i - 1 t = a[i] a = a[:i] + a[i+1:] a.insert(lastind.pop(),t) flag = 1 c = i elif (flag == 0 and a[c] == b[i]) or a[c] < b[i]: lastind.append(c) t = a[c] a = a[:c] + a[c+1:] a.insert(i,t) else: c = c + 1 if a[i] < b[i]: break elif flag == 0 and a[i] == b[i]: i = i + 1 c = i return a aa = input() bb = input() a=[] b=[] for i in aa: a.append(int(i)) for i in bb: b.append(int(i)) a.sort(reverse=True) ans = permuteDigits(a, b) s = """" for i in ans: s = s + str(i) print(int(s))",cubic,"['dp', 'greedy']",646
"import sys,os,io from math import log, gcd, ceil from collections import defaultdict, deque, Counter from heapq import heappush, heappop from bisect import bisect_right , bisect_left import math def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den, p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append(2) n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: l.append(int(i)) n = n / i if n > 2: l.append(n) return list(set(l)) def power(x, y, p) : res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def si(): return input() def prefix_sum(arr): r = [0] * (len(arr)+1) for i, el in enumerate(arr): r[i+1] = r[i] + el return r def divideCeil(n,x): if (n%x==0): return n//x return n//x+1 def ii(): return int(input()) def li(): return list(map(int,input().split())) def ws(s): sys.stdout.write(s + '\n') def wi(n): sys.stdout.write(str(n) + '\n') def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n') if(os.path.exists('input.txt')): sys.stdin = open(""input.txt"",""r"") sys.stdout = open(""output.txt"",""w"") t = 1 for _ in range(t): a = input() b = input() ans = [a] a = list(a) b1 = b[:] b = list(b) if (len(a)<len(b)): a.sort(reverse=True) print(''.join(a)) continue arr = [0]*10 for i in a: arr[int(i)]+=1 f = 0 for chota in range(len(b)): arr1 = arr[:] temp = b[:chota] for h in range(chota): if (arr1[int(b[h])]<=0): f = 1 break else: arr1[int(b[h])]-=1 if (f==1): break aa = [] for j in range(int(b[chota])-1,-1,-1): if (arr1[j]>0): temp.append(str(j)) arr1[j]-=1 break for h in range(9,-1,-1): if (arr1[h]>0): temp+=[str(h)]*arr1[h] ans.append(''.join(temp)) for i in ans: if (i<=b1): m = i break a.sort(reverse=True) ans.append(''.join(a)) for i in ans: if (i<=b1): if (i>m): m = i print(m)",cubic,"['dp', 'greedy']",1892
"a=int(input()) b=int(input()) x=[0]*10 while a: x[a%10]+=1 a=a//10 ans=0 for i in range(9,-1,-1): for j in range(x[i]): ans=ans*10+i if ans<=b: print(ans) else: ans=0 for j in str(b): c=int(j) while c>=0 and not x[c]: c-=1 if c<0: while True: x[ans%10]+=1 d=ans%10 ans=ans//10 flag=0 for b in range(d-1,-1,-1): if x[b]: ans=ans*10+b x[b]-=1 flag=1 break if flag: break break else: x[c]-=1 ans=ans*10+c if c<int(j): break for j in range(9,-1,-1): for i in range(x[j]): ans=ans*10+j print(ans)",cubic,"['dp', 'greedy']",491
"import sys import bisect ls2int = lambda ls: int(''.join(map(str,ls))) def candidates(digs, num): if not digs: return [[]] res = [] i = bisect.bisect_left(digs, num[0]) if num[0] in digs: for suffix in candidates(digs[:i]+digs[i+1:], num[1:]): res.append([digs[i]] + suffix) if i > 0: i -= 1 res.append([digs[i]] + list(reversed(digs[:i]+digs[i+1:]))) return res def solution(a, b): digits = [int(x) for x in sorted(a)] ceiling = [int(x) for x in b] assert(len(digits) <= len(ceiling), 'solution does not exist') if len(digits) < len(ceiling): return ls2int(digits[::-1]) return max(ls2int(ls) for ls in candidates(digits, ceiling)) a = sys.stdin.readline().strip() b = sys.stdin.readline().strip() print(solution(a, b))",cubic,"['dp', 'greedy']",720
"from collections import defaultdict def f(b,d): fi = int(b[0]) if len(b)==1: j=fi while(j>=0): if d[j]: return str(j) j+=-1 return """" fi=int(b[0]) s="""" if d[fi]>0: d1=defaultdict(lambda:0) for j in d: d1[j]=d[j] d1[fi]+=-1 s=f(b[1:],d1) if s!="""": return str(fi)+s else: s1="""" j=fi-1 while(j>=0): if d[j]>0: s1+=str(j) d[j]+=-1 break j+=-1 if s1=="""": return """" else: j=9 while(j>=0): if d[j]==0: j+=-1 else: s1+=str(j) d[j]+=-1 return s1 a=input() b=input() d=defaultdict(lambda:0) res=[] for j in a: d[int(j)]+=1 res.append(int(j)) res.sort(reverse=True) for j in range(len(a)): res[j]=str(res[j]) if len(b)>len(a): print("""".join(res)) else: print(f(b,d))",cubic,"['dp', 'greedy']",655
"from collections import Counter def mx(f): res = [] for k in sorted(f.keys(), reverse=True): for _ in range(f[k]): res.append(k) return res def solve(n, a, b): res = None for k in range(n + 1): aa = Counter(a) cur = [] for i in range(k): if aa[b[i]] == 0: return res cur.append(b[i]) aa[b[i]] -= 1 if k < n: for e in range(b[k] - 1, -1, -1): if aa[e] > 0: cur.append(e) aa[e] -= 1 cur.extend(mx(aa)) break if len(cur) < n: continue res = cur return res a = Counter(map(int, input())) b = list(map(int, input())) if sum(a.values()) < len(b): res = mx(a) else: res = solve(len(b), a, b) print(''.join(map(str, res)))",cubic,"['dp', 'greedy']",614
"a, b = sorted(input()), int(input()) for i in range(len(a)): for j in range(i+1, len(a)): c = int(str.join('', a)) a[i], a[j] = a[j], a[i] d = int(str.join('', a)) if c <= d <= b: continue else: a[i], a[j] = a[j], a[i] print(str.join('', a))",cubic,"['dp', 'greedy']",241
"import sys import math def rec(i,n,l): if i == n: return [] else: x = l2[i] flag = 0 o = [] p = [] mi = -1 for j in l: if j < x: if j > mi: if i == 0 and j == 0: o.append(j) p.append(j) continue mi = j if x == j: flag = 1 o.append(j) p.append(j) if flag: o.remove(x) if mi == -1 and flag == 0: return [] ans1 = [] if flag: ans1 = [x]+rec(i+1,n,o) if mi != -1: p.remove(mi) p.sort(reverse = True) ans2 = [mi]+p if len(ans1) == n-i: return ans1 else: return ans2 for _ in range(1): a = int(input()) b = int(input()) e1 = str(a) e2 = str(b) l1 = [] l2 = [] for i in e1: l1.append(int(i)) for i in e2: l2.append(int(i)) if len(l1) < len(l2): l1.sort(reverse = True) o = [] for i in l1: o.append(str(i)) print("""".join(o)) else: n = len(l2) ans = rec(0,n,l1) w = [] for i in ans: w.append(str(i)) print("""".join(w))",cubic,"['dp', 'greedy']",808
"def check(e,value,pre): global maxi,count e[str(value)]-=1 pre+=str(value) arr=[] for i in e: for j in range(e[i]): arr.append(i) arr.sort(reverse=True) st='' for i in arr: st+=str(i) alpha=int(pre+st) if alpha<=int(b): maxi=max(maxi,int(pre+st)) a=input() b=input() maxi=0 d={} for i in a: if i not in d: d[i]=1 else: d[i]+=1 maxi=0 num="""" count=0 if len(a)<len(b): check(d.copy(),max(d),'') else: for i in b: if i in d and d[i]>0: for j in range(int(i)-1,-1,-1): if str(j) in d and d[str(j)]>0: check(d.copy(),j,num) break check(d.copy(),i,num) num+=i d[i]-=1 else: j=0 for j in range(int(i)-1,-1,-1): if str(j) in d and d[str(j)]>0: check(d.copy(),j,num) break break print(maxi)",cubic,"['dp', 'greedy']",681
"import os import sys from io import BytesIO, IOBase def main(): a=list(map(int,input().rstrip())) b=list(map(int,input().rstrip())) ans,la,lb=[],len(a),len(b) if la!=lb: print(*sorted(a,reverse=True),sep="""") else: for i in range(lb): if b[i] in a: ans.append(b[i]) a.remove(b[i]) else: ma=-1 for j in a: if j<b[i]: ma=max(ma,j) if ma!=-1: ans.append(ma) a.remove(ma) else: i-=1 while ans: a.append(ans.pop()) ma=-1 for j in a: if j<b[i]: ma=max(ma,j) if ma!=-1: ans.append(ma) a.remove(ma) break i-=1 a.sort() while a: ans.append(a.pop()) break print("""".join(str(i) for i in ans)) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy']",1959
"import os import sys from io import BytesIO, IOBase def main(): a=list(map(int,input().rstrip())) b=list(map(int,input().rstrip())) ans,la,lb=[],len(a),len(b) if la!=lb: print(*sorted(a,reverse=True),sep="""") else: for i in range(lb): if b[i] in a: ans.append(b[i]) a.remove(b[i]) else: while i>-1: ma=-1 for j in a: if j<b[i]: ma=max(ma,j) if ma!=-1: ans.append(ma) a.remove(ma) break i-=1 a.append(ans.pop()) a.sort() while a: ans.append(a.pop()) break print("""".join(str(i) for i in ans)) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy']",1868
"import os import sys from io import BytesIO, IOBase def main(): a=list(map(int,input().rstrip())) b=list(map(int,input().rstrip())) ans,la,lb=[],len(a),len(b) if la!=lb: print(*sorted(a,reverse=True),sep="""") else: for i in range(lb): if b[i] in a: ans.append(b[i]) a.remove(b[i]) else: while i>-1: ma=-1 for j in a: if j<b[i]: ma=max(ma,j) if ma!=-1: ans.append(ma) a.remove(ma) break i-=1 a.append(ans.pop()) a.sort() while a: ans.append(a.pop()) break print(*ans,sep="""") BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy']",1851
"a = sorted(input()) b = int(input()) a = a[::-1] p = '' cnt = [0]*10 while a : for i, d in enumerate(a): n = p + d + """".join(sorted(a[:i]+a[i+1:])) if int(n) <= b : p += d a.pop(i) break print(p)",cubic,"['dp', 'greedy']",195
"from collections import defaultdict from collections import Counter from collections import deque import heapq inf = float('inf') ninf = float('-inf') M1 = 10**9 + 7 M2 = 998244353 def li(): return list(map(int,input().split())) def pre(): ""Start"" def solve(): a = input() b = input() n = len(a) if(len(a)<len(b)): a = sorted(list(a),reverse = True) print("""".join(a)) return b = int(b) ans = 0 cnt = [0]*10 for i in range(n): cnt[ord(a[i])-ord('0')] += 1 def getrem(k): cnt[k] -= 1 ans = """" for i in range(10): for j in range(cnt[i]): ans += str(i) cnt[k] += 1 return ans prev = """" for i in range(n): for j in range(9,-1,-1): if(cnt[j]>0): newval = prev + str(j)+ getrem(j) if(int(newval)<=b): ans = max(ans,int(newval)) prev += str(j) cnt[j] -= 1 break print(ans) pre() __ = 1 for _ in range(__): solve()",cubic,"['dp', 'greedy']",805
"success = 0 def solve(b, freq, i, n, res): global success if i == len(b): success = res else: success = 0 move = 9 while move >= 0 and success == 0: m = int(b[i]) if freq[move] > 0 and res * 10 + move <= n * 10 + m: res = res * 10 + move n = n * 10 + m freq[move] -= 1 if solve(b, freq, i + 1, n, res) == 0: res //= 10 n //= 10 freq[move] += 1 move -= 1 return success a = input() b = input() freq = [] for i in range(10): freq.append(0) v = [] for x in a: n = int(x) v.append(n) freq[n] += 1 v.sort() ans = 0 if len(b) > len(a): m = 1 for x in v: ans = x * m + ans m *= 10 else: ans = solve(b, freq, 0, 0, 0) print(ans)",cubic,"['dp', 'greedy']",620
"from sys import maxsize, stdout, stdin,stderr mod = int(1e9+7) import sys def I(): return int(stdin.readline()) def lint(): return [int(x) for x in stdin.readline().split()] def S(): return input().strip() def grid(r, c): return [lint() for i in range(r)] from collections import defaultdict, Counter, deque import math import heapq from heapq import heappop , heappush import bisect from itertools import groupby def gcd(a,b): while b: a %= b tmp = a a = b b = tmp return a def lcm(a,b): return a // gcd(a, b) * b def check_prime(n): for i in range(2, int(n ** (1 / 2)) + 1): if not n % i: return False return True def Bs(a, x): i=0 j=0 left = 1 right = x flag=False while left<right: mi = (left+right)//2 if a[mi]<=x: left = mi+1 i+=1 else: right = mi j+=1 if left>0 and a[left-1]==x: return i-1, j else: return -1, -1 def nCr(n, r): return (fact(n) // (fact(r) * fact(n - r))) def fact(n): res = 1 for i in range(2, n+1): res = res * i return res def primefactors(n): num=0 while n % 2 == 0: num+=1 n = n / 2 for i in range(3,int(math.sqrt(n))+1,2): while n % i== 0: num+=1 n = n // i if n > 2: num+=1 return num def ask(a): print('? {}'.format(a),flush=True) n=I() return n def dfs(i,p): a,tmp=0,0 for j in d[i]: if j!=p: a+=1 tmp+=dfs(j,i) if a==0: return 0 return tmp/a + 1 def primeFactors(n): l=[] while n % 2 == 0: l.append(2) n = n // 2 if n > 2: l.append(n) return l a = sorted(input()) b = int(input()) a = a[::-1] p = '' cnt = [0]*10 while a : for i, d in enumerate(a): n = p + d + """".join(sorted(a[:i]+a[i+1:])) if int(n) <= b : p += d a.pop(i) break print(p)",cubic,"['dp', 'greedy']",1573
"a=input() b=input() na=len(a) nb=len(b) def fs(a,b): try: for i in range(a+1,len(b)): if b[a]>b[i]: ans=b[i] k=b.copy() k.pop(i) ans+="""".join(k) return ans return False except: return False if(na<nb): print("""".join(sorted(list(a),reverse=True))) else: if(a==b): print(a) else: l=sorted(list(a),reverse=True) l2=l.copy() ans1="""" flag=0 ans=[] for i in b: for j in range(len(l)): if i==l[j]: k=fs(j,l) if(k!=False): ans.append(ans1+fs(j,l)) ans1+=l[j] l.pop(j) break if i>l[j]: ans1+=l[j] l.pop(j) flag=1 break if(flag==1): break ans1+="""".join(l) if(int(ans1)<=int(b)): print(ans1) else: for i in sorted([int(i) for i in ans],reverse=True): if(i<=int(b)): print(i) break",cubic,"['dp', 'greedy']",668
"a=input() b=input() na=len(a) nb=len(b) def fs(a,b): try: for i in range(a+1,len(b)): if b[a]>b[i]: ans=b[i] k=b.copy() k.pop(i) ans+="""".join(k) return ans return False except: return False if(na<nb): print("""".join(sorted(list(a),reverse=True))) else: if(a==b): print(a) else: l=sorted(list(a),reverse=True) l2=l.copy() ans1="""" flag=0 ans=[] for i in b: for j in range(len(l)): if i==l[j]: k=fs(j,l) if(k!=False): ans.append(ans1+fs(j,l)) ans1+=l[j] l.pop(j) break if i>l[j]: ans1+=l[j] l.pop(j) flag=1 break if(flag==1): break ans1+="""".join(l) if(int(ans1)<=int(b)): print(ans1) else: for i in sorted([int(i) for i in ans],reverse=True): if(i<=int(b)): print(i) break",cubic,"['dp', 'greedy']",668
"from bisect import insort,bisect_right,bisect_left from sys import stdout, stdin, setrecursionlimit from heapq import heappush, heappop, heapify from io import BytesIO, IOBase from collections import * from itertools import * from random import * from string import * from queue import * from math import * from re import * from os import * class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") stdin, stdout = IOWrapper(stdin), IOWrapper(stdout) graph, mod, szzz = {}, 10**9 + 7, lambda: sorted(zzz()) def getStr(): return input() def getInt(): return int(input()) def listStr(): return list(input()) def getStrs(): return input().split() def isInt(s): return '0' <= s[0] <= '9' def input(): return stdin.readline().strip() def zzz(): return [int(i) for i in input().split()] def output(answer, end='\n'): stdout.write(str(answer) + end) def lcd(xnum1, xnum2): ret",cubic,"['dp', 'greedy']",2000
"from bisect import insort,bisect_right,bisect_left from sys import stdout, stdin, setrecursionlimit from heapq import heappush, heappop, heapify from io import BytesIO, IOBase from collections import * from itertools import * from random import * from string import * from queue import * from math import * from re import * from os import * class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = read(self._fd, max(fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") stdin, stdout = IOWrapper(stdin), IOWrapper(stdout) graph, mod, szzz = {}, 10**9 + 7, lambda: sorted(zzz()) def getStr(): return input() def getInt(): return int(input()) def listStr(): return list(input()) def getStrs(): return input().split() def isInt(s): return '0' <= s[0] <= '9' def input(): return stdin.readline().strip() def zzz(): return [int(i) for i in input().split()] def output(answer, end='\n'): stdout.write(str(answer) + end) def lcd(xnum1, xnum2): ret",cubic,"['dp', 'greedy']",2000
a=''.join(reversed(sorted(input()))) b=int(input()) r='' while len(a)>0: for i in range(len(a)): n=r+a[i]+''.join(sorted(a[:i]+a[i+1:])) if int(n)<=b: r+=a[i] a=a[:i]+a[i+1:] break print(r),cubic,"['dp', 'greedy']",189
"from sys import stdin, stdout nmbr = lambda: int(input()) lst = lambda: list(map(int, input().split())) for _ in range(1): sa=sorted(input(), reverse=True) na=len(sa) sb=input() nb=len(sb) if nb>na: print(''.join(sa)) continue ans='' while sa: for i in range(len(sa)): new=ans+sa[i]+''.join(sorted(sa[:i]+sa[i+1:])) if int(new)<=int(sb): ans+=sa[i] sa.pop(i) break print(ans)",cubic,"['dp', 'greedy']",375
"def main(): mod=1000000007 tc=1 for _ in range(tc): a=list(rs()) b=list(rs()) if len(a)<len(b): ws(''.join(sorted(a)[::-1])) else: a=sorted(a) ans=[] sa=SortedList(a) for i in range(len(a)-1): for j in range(len(sa)-1,-1,-1): temp=ans+[sa[j]] sa.discard(sa[j]) for k in sa: temp.append(k) if temp<=b: ans.append(temp[i]) break else: sa.add(temp[i]) ans.append(sa[-1]) ws("""".join(ans)) def rant(): return ""AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH"" def SieveOfEratosthenes(limit): isPrime = [True]*(limit+1) isPrime[0] = isPrime[1] = False primes = [] for i in range(2, limit+1): if not isPrime[i]:continue primes += [i] for j in range(i*i, limit+1, i): isPrime[j] = False return primes def memodict(f): class memodict(dict): def __missing__(self, key): ret = self[key] = f(key) return ret return memodict().__getitem__ def pollard_rho(n): if n & 1 == 0: return 2 if n % 3 == 0: return 3 s = ((n - 1) & (1 - n)).bit_length() - 1 d = n >> s for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]: p = pow(a, d, n) if p == 1 or p == n - 1 or a % n == 0: continue for _ in range(s): prev = p p = (p * p) % n if p == 1: return math.gcd(prev - 1, n) if p == n - 1: break else: for i in range(2, n): x, y = i, (i * i + 1) % n f = math.gcd(abs(x - y), n) while f == 1: x, y = (x * x + 1) % n, (y * y + 1) % n y = (y * y + 1) % n f = math.gcd(abs(x - y), n) if f != n: return f return n @memodict def prime_factors(n): if n <= 1: return Counter() f = pollard_rho(n) return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f) def distinct_factors(n): factors = [1] for p, exp in prime_factors(n).items(): factors += [p**i * factor for factor in factors for i in range(1, exp + 1)] return factors def all_factors(n): small, large = [], [] for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1): if not n % i: small.append(i) large.append(n // i) if small[-1] == large[-1]: large.pop() large.reverse() small.extend(large) return small def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7): ma",cubic,"['dp', 'greedy']",2000
"a = list(input()) b = list(input()) n = len(a) a.sort() def listtostring(string): return ''.join([str(ele) for ele in string]) for i in range(0,n): for j in range(0,n): t = a.copy() t[i],t[j] = t[j],t[i] if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))): a[i],a[j] = a[j],a[i] print(listtostring(a))",cubic,"['dp', 'greedy']",350
"a = list(input()) b = list(input()) n = len(a) a.sort() def listtostring(li:list): return ''.join(li) for i in range(0,n): for j in range(0,n): t = a.copy() t[i],t[j] = t[j],t[i] if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))): a[i],a[j] = a[j],a[i] print(listtostring(a))",cubic,"['dp', 'greedy']",325
"import sys input=sys.stdin.readline a=list(map(int,input().rstrip())) b=list(map(int,input().rstrip())) if len(a)<len(b): a.sort(reverse=True) print(''.join(map(str,a))) else: ans=-1 ca=[0]*10 for aa in a: ca[aa]+=1 lim=-1 for i in range(len(a)): if ca[b[i]]: candi=[] for j in range(i): candi.append(b[j]) use=-1 for j in range(b[i]-1,-1,-1): if ca[j]: use=j ca[j]-=1 candi.append(j) break if use<0: ca[b[i]]-=1 continue else: for j in range(10)[::-1]: candi.extend([j]*ca[j]) res=''.join(map(str,candi)) res=int(res) ans=max(ans,res) ca[use]+=1 ca[b[i]]-=1 else: candi=[] for j in range(i): candi.append(b[j]) use=-1 for j in range(b[i]-1,-1,-1): if ca[j]: use=j ca[j]-=1 candi.append(j) break if use<0: break else: for j in range(10)[::-1]: candi.extend([j]*ca[j]) res=''.join(map(str,candi)) res=int(res) ans=max(ans,res) ca[use]+=1 break flg=True ca=[0]*10 for i in range(len(a)): ca[a[i]]+=1 for i in range(len(a)): if ca[b[i]]: ca[b[i]]-=1 else: flg=False if flg: ans=max(ans,int(''.join(map(str,b)))) print(ans)",cubic,"['dp', 'greedy']",1019
"a,b = list(input()),int(input()) ans = """" a.sort(reverse=True) while len(a)>0: for i in range(len(a)): num = ans+a[i]+"""".join(sorted(a[:i]+a[i+1:])) if int(num)<=b: ans += a[i] a = a[:i]+a[i+1:] break print(ans)",cubic,"['dp', 'greedy']",211
"s1=input() s2=input() arr=list(s1) arr.sort(reverse=True) if(len(s2)>len(s1)): t="""" for i in arr: t+=i print(t) else: t="""" l =len(s1) for i in range(l): index=-1 ma = -1 for j in range(len(arr)): temp = arr[j] tt=[] for k in range(len(arr)): if(k!=j): tt.append(arr[k]) tt.sort() for k in tt: temp+=k temp = t+temp if(int(s2)>=int(temp)): if(int(arr[j])>ma): ma = int(arr[j]) index = j t+=arr[index] del arr[index] print(t)",cubic,"['dp', 'greedy']",423
"def check(s,a): st='' for i in range(len(s)): st+=s[i] st=int(st) if (st>a): return False else: return True a = input() b = input() s=[] ans='' for i in range(len(a)): s.append(a[i]) s.sort() if (len(b)>len(a)): for i in range(len(s)): print(s[len(s)-i-1],end='') else: for i in range(len(a)): j=0 temp2=-1 while ((j<len(s)-1) and (s[j+1]<=b[i])): j+=1 if (s[j]!=s[j-1]): temp2=j-1 temp=s[j] s.remove(s[j]) if (i==len(a)-1 or check(s,int(b[i+1:len(b)])) or temp<b[i]): ans+=temp if (ans[i]<b[i]): for k in range(len(s)): ans+=s[len(s)-k-1] else: s.append(temp) s.sort() temp2=s[temp2] ans+=temp2 s.remove(temp2) for k in range(len(s)): ans+=s[len(s)-k-1] if (len(ans)==len(a)): break print(ans)",cubic,"['dp', 'greedy']",694
mass = list(input()) b = int(input()) mass.sort() mass = mass[::-1] p = '' while(len(mass)>0): for i in range(len(mass)): n = p + mass[i] + ''.join(sorted(mass[:i] + mass[i + 1:])) if int(n) <= b: p += mass[i] mass = mass[:i] + mass[i + 1:] break print(p),cubic,"['dp', 'greedy']",255
"def smallest(d): out = """" for j in range(0, 10): out += (""%d"" % j)*d[j] return out def largest(d): out = """" for j in range(9, -1, -1): out += (""%d"" % j)*d[j] return out sa = input() sb = input() b = int(sb) h = int(sa) digits_a = [0]*10 while h > 0: digits_a[h % 10] += 1 h //= 10 out = """" if len(sb) > len(sa): print(largest(digits_a)) exit() out = 0 for i in range(len(sa)-1, -1, -1): for j in range(9, -1, -1): if digits_a[j] == 0: continue if j < (b % (10 ** (i+1))) // (10 ** i): digits_a[j] -= 1 if out > 0: print(""{}{}{}"".format(out, j, largest(digits_a))) exit() else: print(""{}{}"".format(j, largest(digits_a))) exit() if j == (b % (10 ** (i+1))) // (10 ** i): if i == 0: out = 10*out + j print(out) exit() digits_a[j] -= 1 if int(smallest(digits_a)) <= b % (10 ** i): out = 10*out + j break else: digits_a[j] += 1 print(out)",cubic,"['dp', 'greedy']",833
"def search(current, digits, target, idx, bulk): if len(current) == len(target) and int(current) <= int(target): print(current) exit(0) possibilities = [char for char in digits if bulk or (char <= target[idx] and char in digits)] if len(possibilities) == 0: return None for possible_digit in sorted(set(possibilities), reverse=True): tmp_digits = list(digits) tmp_digits.remove(possible_digit) if not bulk: bulk = True if possible_digit != target[idx] else False search(current + possible_digit, tmp_digits, target, idx + 1, bulk) def main(): digits = sorted(list(input()), reverse=True) target = input() if len(digits) < len(target): print(''.join(digits)) exit(0) entries = [char for char in digits if char <= target[0]] for current in sorted(set(entries), reverse=True): tmp_digits = list(digits) tmp_digits.remove(current) search(current, tmp_digits, target, 1, True if current != target[0] else False) if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy']",939
"def main(): a = sorted(input(), reverse=True) b = int(input()) k = """" while len(a) > 0: for i in range(len(a)): num = k + a[i] + """".join(sorted(a[:i] + a[i + 1:])) if int(num) <= b: k += a[i] a = a[:i] + a[i + 1:] break print(k) if __name__ == ""__main__"": main()",cubic,"['dp', 'greedy']",262
"a=input() b=input() v=sorted(a) v=v[::-1] x="""" for i in range(len(v)): x=x+v[i] v=x if(len(a)<len(b)): print(v) else: if(b==a): print(a) else: fin="""" flag=False for j in range(len(a)): for k in range(len(a)): num=fin+v[k]+''.join(sorted(v[:k:]+v[k+1::])) if(num<=b): fin+=v[k] if(int(v[k])<int(b[j])): flag=True v=v[:k:]+v[k+1::] fin+=v v=v[:k:]+v[k+1::] break if(flag): break print(fin)",cubic,"['dp', 'greedy']",387
"a=sorted(input()) b=int(input()) a=a[::-1] p="""" while a: for i, z in enumerate(a): n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:])) if int(n)<=b: p+=z a.pop(i) break print(p)",cubic,"['dp', 'greedy']",165
"def dig(d): return ord(d) - ord('0') def biggest_left(counts): res = '' for i in range(9, -1, -1): res += str(i) * counts[i] return res def ok(d, _counts, rest): if rest == '': return True counts = _counts.copy() counts[d] -= 1 r = '' for i in range(10): r += str(i) * counts[i] return int(r) <= int(rest) def main(): a, b = input(), input() counts = [0] * 10 for d in a: counts[dig(d)] += 1 ans = '' if len(a) < len(b): print(biggest_left(counts)) return n = len(a) for i in range(n): d = dig(b[i]) if counts[d] and ok(d, counts, b[i+1:]): ans += b[i] counts[d] -= 1 else: for s in range(d-1, -1, -1): if counts[s] > 0: ans += str(s) counts[s] -= 1 ans += biggest_left(counts) print(ans) return print(ans) if __name__ == '__main__': main()",cubic,"['dp', 'greedy']",740
"a = list(input()) b = input() out = [] mx = '/' a.sort() a.reverse() x = len(a) if x == len (b): for i in range(x): q = 0 for j in range(len(a)): if a[j] == b[i]: out.append(a[j]) a.pop(a.index(a[j])) q = 1 break elif a[j] < b[i]: out.append(a[j]) a.pop(a.index(a[j])) print(''.join(out), end = '') print(''.join(a)) exit(0) if q == 0: break if q == 1: print(''.join(out)) else: y = len(out) for i in range(y-1, -1, -1): for j in range(len(a)): if a[j] < b[i] and a[j]>mx: mx = a[j] if mx != '/': a.append(out[len(out)-1]) out.pop() out.append(mx) a.pop(a.index(mx)) a.sort() a.reverse() print(''.join(out), end = '') print(''.join(a)) exit(0) else: a.append(out[len(out)-1]) out.pop() a.sort() a.reverse() a.pop(a.index(mx)) print(mx, end ='') print(''.join(a)) else: print(''.join(a))",cubic,"['dp', 'greedy']",786
"a = input() b = input() list_a = list(a) list_a.sort() max_a = int(''.join(list_a)) for i in range(len(a)): for j in range(i+1, len(a)): list_a[i], list_a[j] = list_a[j], list_a[i] temp_a = int(''.join(list_a)) if int(b) < temp_a or temp_a <= max_a: list_a[i], list_a[j] = list_a[j], list_a[i] else: max_a = temp_a print(max_a)",cubic,"['dp', 'greedy']",327
"a = input() b = input() la = [int(x) for x in a] res = [] la.sort() la = la[::-1] lb = [int(x) for x in b] cnt = [0] * 20 def check(): tres = 0 for x in range(len(res)): tres *= 10 tres += int(res[x]) return tres <= int(b) if len(a) < len(b): for i in range(len(la)): print(la[i], end = '') print() else: for i in range(len(la)): cnt[la[i]] += 1 flag = 0 for i in range(len(lb)): if flag == 0 and cnt[lb[i]]: res.append(lb[i]) cnt[lb[i]] -= 1 else: flag = i - 1 for j in range(lb[i] - 1, -1, -1): if cnt[j]: res.append(j) cnt[j] -= 1 break for j in range(9, -1, -1): while cnt[j]: res.append(j) cnt[j] -= 1 break while not check(): temp = [] cnt = [0] * 20 for x in range(flag): temp.append(res[x]) cnt[res[x]] -= 1 for i in la: cnt[i] += 1 res = temp for v in range(lb[flag] - 1, -1, -1): if cnt[v]: res.append(v) cnt[v] -= 1 break for v in range(9, -1, -1): while cnt[v]: res.append(v) cnt[v] -= 1 flag -= 1 for i in range(len(res)): print(res[i], end = '') print()",cubic,"['dp', 'greedy']",967
"a = input() b = input() la = [int(x) for x in a] res = [] la.sort() la = la[::-1] lb = [int(x) for x in b] cnt = [0] * 20 def check(): tres = 0 for x in range(len(res)): tres *= 10 tres += int(res[x]) return tres <= int(b) if len(a) < len(b): for i in range(len(la)): print(la[i], end = '') print() else: for i in range(len(la)): cnt[la[i]] += 1 flag = 0 for i in range(len(lb)): if flag == 0 and cnt[lb[i]]: res.append(lb[i]) cnt[lb[i]] -= 1 else: flag = i - 1 for j in range(lb[i] - 1, -1, -1): if cnt[j]: res.append(j) cnt[j] -= 1 break for j in range(9, -1, -1): while cnt[j]: res.append(j) cnt[j] -= 1 break while not check(): temp = [] cnt = [0] * 20 for x in range(flag): temp.append(res[x]) cnt[res[x]] -= 1 for i in la: cnt[i] += 1 res = temp for v in range(lb[flag] - 1, -1, -1): if cnt[v]: res.append(v) cnt[v] -= 1 break for v in range(9, -1, -1): while cnt[v]: res.append(v) cnt[v] -= 1 flag -= 1 for i in range(len(res)): print(res[i], end = '') print()",cubic,"['dp', 'greedy']",967
"a = input() b = input() length_of_a = len(a) length_of_b = len(b) found_digit = False chk_finnish = False appended_digit_count = 0 n = {} num = [] for i in range(0,10): n[i] = 0 for i in range(0,length_of_a): c = int(a[i]) n[c] += 1 if length_of_a < length_of_b: num = sorted(a,reverse=True) for i in range(0,length_of_a): print(num[i],end="""") else: for i in range(0,length_of_b): digit = int(b[i]) if n[digit] > 0: num.append(digit) n[digit] -= 1 appended_digit_count += 1 else: j = digit - 1 while j > -1: if n[j] > 0: num.append(j) appended_digit_count += 1 n[j] -= 1 found_digit = True chk_finnish = True break j -= 1 if found_digit: j = 9 while j > -1: if n[j] > 0: digit_count = n[j] for k in range(0,digit_count): num.append(j) n[j] -= 1 appended_digit_count += 1 j -= 1 if chk_finnish: break else: found_digit = False while found_digit == False: pop_up = num[appended_digit_count-1] del num[-1] j = pop_up - 1 n[pop_up] += 1 appended_digit_count -= 1 while j > -1: if n[j] > 0: num.append(j) appended_digit_count += 1 n[j] -= 1 found_digit = True break j -= 1 j = 9 while j > -1: if n[j] > 0: digit_count = n[j] for k in range(0,digit_count): num.append(j) appended_digit_count += 1 j -= 1 break for i in range(0,length_of_b): print(num[i],end="""")",cubic,"['dp', 'greedy']",1255
a=list(input()) b=list(input()) num=int(''.join(b)) a.sort() a.reverse() al=len(a) ans=[] if(len(a)==len(b) and len(a)!=1): c=[] count=0 hogya=0 for i in range(al): if(hogya==1): o.reverse() f=list(c+o) ans.append(''.join(f)) count+=1 break t=len(a) j=0 mittal=t abhinhi=0 while(t): if(j>len(a)-1): break if(int(a[j])<=int(b[i])): c.append(a[j]) temp=a[j] a.remove(a[j]) o=a.copy() o.sort() f=list(c+o) if(temp<b[i]): hogya=1 break if(int(''.join(f))<=num): ans.append(''.join(f)) count+=1 break else: a.append(temp) c=c[:len(c)-1] t-=1 else: j+=1 t-=1 if(mittal==len(a)): break print(ans[count-1]) elif(len(a)==1): print(''.join(a)) else: print(''.join(a)),cubic,"['dp', 'greedy']",657
"R = lambda: map(int, input().split()) a = sorted(map(int, input())) b = list(map(int, input())) bn = int(''.join(map(str, b))) res = int(''.join(map(str, sorted(a)))) if len(b) != len(a): print(''.join(map(str, sorted(a, reverse=True)))) else: for i in range(len(a)): for j in range(i + 1, len(a)): if a[i] < a[j] < b[i]: a[i], a[j] = a[j], a[i] tmp = int(''.join(map(str, a[:i + 1] + sorted(a[i + 1:], reverse=True)))) res = max(res, tmp) if tmp <= bn else res for j in range(i + 1, len(a)): if a[j] == b[i]: a[i], a[j] = a[j], a[i] print(res)",cubic,"['dp', 'greedy']",544
"fre =[0,0,0,0,0,0,0,0,0,0,0] a=input();b=input() c=False def DFS(aa,bb): if int(aa)==len(a): print(bb) exit() global c for i in range(9,-1,-1): if (fre[i]>0 and i<=int(b[int(aa)])) or (fre[i]>0 and c): fre[i]-=1 if i<int(b[int(aa)]): c=True DFS(aa+1,bb*10+i) fre[i]+=1 c=False if len(b)>len(a): x=sorted(a); print(*x[::-1],sep='') else: for i in a: fre[int(i)]+=1 DFS(0,0)",cubic,"['dp', 'greedy']",372
"a=list(input()) b=int(input()) a.sort() a=a[::-1] prefix="""" while(len(a)>0): for i in range(len(a)): num=prefix+a[i]+"""".join(sorted(a[:i]+a[i+1:])) if(int(num)<=b): prefix+=a[i] a=a[:i]+a[i+1:] break print(prefix)",cubic,"['dp', 'greedy']",213
"s=input() s1=input() l=[] l1=[] for x in s : l.append(int(x)) for x in s1 : l1.append(int(x)) d={} for x in l : d[x]=d.get(x,0)+1 f=False if len(s1)>len(s) : l=sorted(l) l=l[::-1] print("""".join(map(str,l))) exit() ans=[0]*len(s) ki=0 i=0 while(i<len(l1)) : f=True for j in range(max(l1[i],ki),-1,-1) : if d.get(j,-1)>0 : ans[i]=j d[j]-=1 f=False if j!=l1[i] : ki=9 break if f : for i1 in range(i-1,-1,-1) : f1=False for j in range(max(l1[i1],ki)-1,-1,-1) : if d.get(j,-1)>0 : d[ans[i1]]+=1 ans[i1]=j d[j]-=1 f1=True i=i1 ki=9 break if f1 : break else : d[ans[i1]]+=1 ans[i1]=0 i+=1 print("""".join(map(str,ans)))",cubic,"['dp', 'greedy']",610
"from collections import Counter a = input() b = input() if len(a) < len(b): print(''.join(sorted(a)[::-1])) exit() n = len(a) cnt = Counter(a) def f(i = 0, check = False): if i == n: return [] for j in sorted(cnt)[::-1]: if (check or j <= b[i]) and cnt[j]: cnt[j] -= 1 res = f(i + 1, check or j < b[i]) if len(res) + i + 1 == n: res.append(j) return res cnt[j] += 1 return [] print(''.join(f()[::-1]))",cubic,"['dp', 'greedy']",401
"from copy import deepcopy a = list(map(int, list(input()))) b = list(map(int, list(input()))) cnt1 = [0] * 10; cnt2 = [0] * 10 ans = [] if (len(a) != len(b)): print(''.join(map(str,sorted(a, reverse=True)))) exit() for i in range(len(b) + 1): ok = 1 tmp = deepcopy(a) for j in range(i): if b[j] in tmp: tmp.pop(tmp.index(b[j])) else: ok = 0 break if not ok: continue pls = -1 ind = -1 for j in range(len(tmp)): if (tmp[j] < b[i]): if (tmp[j] > pls): ind = j pls = tmp[j] if pls == -1 and len(tmp) != 0: continue else: if (len(tmp) > 0): tmp.pop(ind) if i == len(b): ans.append(''.join(map(str, b[:i:]))) else: ans.append(''.join(map(str, b[:i:])) + str(pls) + ''.join(map(str, sorted(tmp, reverse=True)))) print(max(ans))",cubic,"['dp', 'greedy']",721
"a = list(input()) b = int(input()) a = sorted(a, reverse=True) ans = '' while len(a) > 0: for i in range(len(a)): tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:])) if int(tmp) <= b: ans += a[i] a = a[:i] + a[i + 1:] break print(ans)",cubic,"['dp', 'greedy']",236
"a = [ord(e) - ord('0') for e in list(input().strip())] b = [ord(e) - ord('0') for e in list(input().strip())] a.sort(reverse=True) h = [0 for i in range(10)] for x in a: h[x] += 1 if len(a) < len(b): print(''.join(map(str, a))) exit(0) def gmax(hx): s = list(hx) res = list() for i in range(9, -1, -1): while s[i] > 0: res.append(i) s[i] -= 1 return res def gmin(hx): s = list(hx) res = list() for i in range(10): while s[i] > 0: res.append(i) s[i] -= 1 return res res = list() def finalize(x): for y in range(x-1, -1, -1): if h[y] > 0: res.append(y) h[y] -= 1 for i in range(9, -1, -1): while h[i] > 0: res.append(i) h[i] -= 1 return p = 0 while p < len(a): x = b[p] if h[x] > 0: hh = list(h) hh[x] -= 1 if b[p+1:] >= gmin(hh): res.append(x) h[x] -= 1 else: finalize(x) break else: finalize(x) break p += 1 print(''.join(map(str, res)))",cubic,"['dp', 'greedy']",837
"def get_smallest(m, l): res = '' for i in ""0123456789"": if m.get(i, 0): if i == l: res += i * (m[i] - 1) else: res += i * m[i] return res a = input() b = input() if len(a) < len(b): a = sorted(a) a.reverse() print(''.join(a)) elif a == b: print(a) else: cmap = dict() for i in a: cmap[i] = cmap.get(i, 0) + 1 cur = 0 res = '' gm = False while cur < len(a): for i in ""9876543210"": if cmap.get(i, 0): if cur == len(a) - 1 or i < b[cur] or gm: res += i cmap[i] -= 1 gm = True break elif i == b[cur]: if get_smallest(cmap, i) <= b[cur + 1:]: res += i cmap[i] -= 1 break cur += 1 print(res)",cubic,"['dp', 'greedy']",585
"a = [int(i) for i in list(input())] b = [int(i) for i in list(input())] if (len(a)<len(b)): a.sort(reverse=True) ans = 0 for i in range(len(a)): ans = ans*10+a[i] print(ans) else: ans = 0 n = len(a) count = [0]*10 for i in range(n): count[a[i]] += 1 i = 0 while (i<n): x = b[i] if (count[x]>0): ans = ans*10+x count[x] -= 1 i += 1 else: break if (i==n): print(ans) exit(0) x = b[i] flag = False for j in range(x-1,-1,-1): if (count[j]>0): ans = ans*10+j count[j] -= 1 flag = True break if (flag) : for j in range(9,-1,-1): while (count[j]>0): ans = ans*10+j count[j] -= 1 else: while (not flag): t = ans%10 ans = ans//10 count[t] += 1 for i in range(t-1,-1,-1): if (count[i]>0): count[i] -= 1 flag = True ans = ans*10 + i break for j in range(9,-1,-1): while (count[j]>0): ans = ans*10+j count[j] -= 1 print(ans)",cubic,"['dp', 'greedy']",812
"def possible(a,index,a1,b): rem = [] for i in range(len(a)): if i != index: rem.append(a[i]) a3 = a1[:] rem.sort() a3.append(a[index]) a3.extend(rem) a2 = '' for i in a3: a2 += str(i) if int(a2) <= b: return True return False def main(): a = list(map(int,input())) b = int(input()) a.sort(reverse = True) a1 = [] for pos in range(len(a)): for i in range(len(a)): if possible(a,i,a1,b): a1.append(a[i]) a.pop(i) break for i in a1: print(i,end = '') main()",cubic,"['dp', 'greedy']",454
"def main(): a = input() b = input() if len(a) < len(b): a = list(a) a.sort(reverse=True) print(''.join(a)) return def solve(i, a: list): if i == len(b): return '' if a.__contains__(b[i]): a.remove(b[i]) suf = solve(i+1, a) if suf is not None: return b[i] + suf a.append(b[i]) best = '' for c in a: if c < b[i] and c > best: best = c if best == '': return None a.remove(best) a.sort(reverse=True) return best + ''.join(a) a = list(a) print(solve(0, a)) main()",cubic,"['dp', 'greedy']",458
"def main(): import sys input = sys.stdin.readline a = int(input()) b = int(input()) a = list(str(a)) a.sort() ans = [] while a: for i in range(len(a) - 1, -1, -1): c = ans + [a[i]] + a[:i] + a[i+1:] if int(''.join(c)) <= b: ans.append(a[i]) a.pop(i) break print(''.join(ans)) main()",cubic,"['dp', 'greedy']",282
"import bisect def solve(l,d,s2,r): ans="""" lol=0 i=0 lo=0 while i<(len(s2)): if(lo==1): a=s2[i] ind=bisect.bisect_left(l,a) for x in range(ind,-1,-1): if(l[x]<l[ind]): ind=x break ans+=str(l[ind]) d[l.pop(ind)]-=1 lol=1 break a=s2[i] ind=bisect.bisect_left(l,a) if(ind==len(l)): ind-=1 ans+=str(l[ind]) d[l[ind]]-=1 lol=1 break elif(l[ind]>a): if(ind==0): while ind==0: l.append(int(ans[-1])) d[int(ans[-1])]+=1 l.sort() ans=ans[:len(ans)-1] lo=1 i-=1 a=s2[i] ind=bisect.bisect_left(l,a) continue lol=1 ans+=str(l[ind-1]) d[l[ind-1]]-=1 l.pop(ind-1) break else: ans+=str(l[ind]) d[l[ind]]-=1 l.pop(ind) i+=1 ll=[] if(lol): for i in d: if(d[i]!=0): ll.append(i) ll.sort(reverse=True) co=0 for i in ll: for j in range(d[i]): if(i==0): co+=1 if(co>r): break ans+=str(i) print(ans) from math import gcd import sys from collections import defaultdict as dd input=sys.stdin.readline s1=list(map(int,input().strip())) s2=list(map(int,input().strip())) z=s1.count(0) d=dd(int) n=len(s1) m=len(s2) l=sorted(s1) for i in s1: d[i]+=1 if len(s1)<len(s2): for i in range(len(s1)-1,-1,-1): print(l[i],end="""") elif(len(s1)>len(s2)): r=m-(n-z) l=l[z-r:] solve(l,d,s2,r) else: solve(l,d,s2,100)",cubic,"['dp', 'greedy']",1176
"import sys from collections import deque,defaultdict as dd from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right from itertools import permutations from datetime import datetime from math import ceil,sqrt,log,gcd def ii():return int(input()) def si():return input() def mi():return map(int,input().split()) def li():return list(mi()) abc='abcdefghijklmnopqrstuvwxyz' abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25} mod=1000000007 inf = float(""inf"") vow=['a','e','i','o','u'] dx,dy=[-1,1,0,0],[0,0,1,-1] def read(): tc=0 if tc: input=sys.stdin.readline else: sys.stdin=open('input1.txt', 'r') sys.stdout=open('output1.txt','w') def permute(b,x,ind): if(ind==len(b)): return 1 f=0 for i in range(9,-1,-1): if(x[i]>0 and i<=int(b[ind])): x[i]-=1 ans[ind]=str(i) if(i<int(b[ind])): f=1 if(f): k=9 for j in range(ind+1,len(b)): while(x[k]==0): k-=1 ans[j]=str(k) x[k]-=1 return 1 if(permute(b,x,ind+1)): return 1 x[i]+=1 return 0 def solve(): a=ii() b=ii() if(len(str(a))<len(str(b))): s=list(str(a)) s.sort(reverse=True) print("""".join(s)) else: x=[0]*10 for i in str(a): x[int(i)]+=1 b=str(b) i=0 global ans ans=[0]*len(b) permute(b,x,0) print("""".join(ans)) if __name__ ==""__main__"": solve()",cubic,"['dp', 'greedy']",1397
"import math import heapq,bisect import sys from collections import deque,defaultdict from fractions import Fraction mod=10**9+7 mod1=998244353 import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree1: def __init__(self, data, default=9999999, func=lambda a, b: min(a , b)): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = self._default def __getitem__(self,",cubic,"['dp', 'greedy']",1998
"def main(): s = list(input()) t = list(input()) if len(s) < len(t): s.sort(reverse=True) print(''.join(s)) else: count = [0] * 10 for elm in s: count[ord(elm) - ord('0')] += 1 ans = [] less = False for i in range(len(s)): for j in range(9, -1, -1): if not less: if j <= ord(t[i]) - ord('0') and count[j] > 0: if j < ord(t[i]) - ord('0'): ans.append(chr(j + ord('0'))) count[j] -= 1 less = True break else: curr_num = 0 for k in range(10): if j == k: for tmp in range(count[k] - 1): curr_num = curr_num * 10 + k else: for tmp in range(count[k]): curr_num = curr_num * 10 + k rest_num = 0 for k in range(i + 1, len(s)): rest_num = rest_num * 10 + (ord(t[k]) - ord('0')) if rest_num >= curr_num: ans.append(chr(j + ord('0'))) count[j] -= 1 break else: continue else: if count[j] > 0: ans.append(chr(j + ord('0'))) count[j] -= 1 break print(''.join(ans)) if __name__ == '__main__': main()",cubic,"['dp', 'greedy']",884
"import sys import math t=1 for _ in range(t): a=input() b=input() dp=[0]*(11) for i in a: dp[int(i)]+=1 if len(b)>len(a): ans='' for i in range(len(a)): for j in range(9,-1,-1): if dp[j]!=0: ans+=str(j) dp[j]-=1 break elif len(a)==len(b): ans='' a1=[] cmpr='' i=0 while i<len(a): cmpr+=b[i] if i==0: flag=0 for j in range(9,0,-1): if ans+str(j)<=cmpr and dp[j]!=0: flag=1 dp[j]-=1 ans+=str(j) a1.append(j) break if flag==0: dp[1]-=1 a1.append(1) ans+='1' else: flag=0 for j in range(9,-1,-1): if ans+str(j)<=cmpr and dp[j]!=0: flag=1 ans+=str(j) a1.append(j) dp[j]-=1 break if flag==0: ch=0 for i1 in range(i-1,-1,-1): if ch==1: break for j1 in range(int(ans[i1])-1,-1,-1): if i1==0: if j1>0 and dp[j1]!=0: dp[a1[i1]]+=1 dp[j1]-=1 index=i1 a1.pop() a1.append(j1) ch=1 break else: if dp[j1]!=0: dp[a1[i1]]+=1 dp[j1]-=1 a1.pop() index=i1 a1.append(j1) ch=1 break if ch==1: break if ch==1: break val=a1.pop() dp[val]+=1 ans='' cmpr='' dp=[0]*11 for i1 in range(len(a)): dp[int(a[i1])]+=1 for i1 in range(len(a1)): dp[a1[i1]]-=1 for i1 in range(len(a1)): ans+=str(a1[i1]) cmpr+=b[i1] i=index i+=1 print(ans)",cubic,"['dp', 'greedy']",1103
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction from collections import defaultdict from itertools import permutations BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") a=sorted(input()) b=int(input()) a=a[::-1] p="""" while a: for i, z in enumerate(a): n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:])) if int(n)<=b: p+=z a.pop(i) break print(p)",cubic,"['dp', 'greedy']",1676
"from string import digits from collections import Counter a = input() b = input() ca = Counter(a) l = list() if len(b) > len(a): for i in digits[::-1]: if i in ca: l.extend(i * ca[i]) else: def asd(i, s): if i == len(b): return True if s: for j in digits[::-1]: if j in ca and ca[j] > 0: l.extend(j * ca[j]) return True else: for j in digits[:int(b[i])+1][::-1]: if j in ca and ca[j] > 0: ca[j] -= 1 l.append(j) if asd(i + 1, j != b[i]): return True ca[j] += 1 l.pop() return False asd(0, False) print("""".join(l))",cubic,"['dp', 'greedy']",513
"a = input() b = input() if len(a) < len(b): a = sorted(a)[::-1] print(''.join(a)) exit(0) def check(res, j, a): added = False tmp = """" for i in a: if i == j and not added: added = True else: tmp += i tmp = res + j + tmp[::-1] return tmp <= b res = """" n = len(a) a = sorted(list(a))[::-1] for i in range(n): for j in a: if check(res, j, a): res += j a.remove(j) break print(res)",cubic,"['dp', 'greedy']",377
a=[i for i in input()] b=int(input()) a.sort(reverse=True) ans = '' while len(a) > 0: for i in range(len(a)): tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:])) if int(tmp) <= b: ans += a[i] a = a[:i] + a[i + 1:] break print(ans),cubic,"['dp', 'greedy']",232
"def comp(a,b): x=len(a) s1='' s2='' for i in range(x): s1+=str(a[i]) s2+=str(b[i]) if s1>s2: return 1 else: return 0 a=list(input('')) b=list(input('')) cnt=[0]*10 n=len(a) m=len(b) sol='' for i in range(n): a[i]=int(a[i]) cnt[a[i]]+=1 if n!=m: a.sort(reverse=True) for i in a: sol+=str(i) print(sol) else: a.sort() for i in range(n): b[i]=int(b[i]) for i in range(n-1): for j in range(i,n): if a[i]<a[j]: temp=a[i] a[i]=a[j] a[j]=temp if comp(a,b): temp=a[i] a[i]=a[j] a[j]=temp for i in a: sol+=str(i) print(sol)",cubic,"['dp', 'greedy']",514
"from bisect import bisect_left as bl from bisect import bisect_right as br from heapq import heappush,heappop,heapify import math from collections import * from functools import reduce,cmp_to_key import sys input = sys.stdin.readline from itertools import accumulate from functools import lru_cache M = mod = 998244353 def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))) def inv_mod(n):return pow(n, mod - 2, mod) def li():return [int(i) for i in input().rstrip('\n').split()] def st():return input().rstrip('\n') def val():return int(input().rstrip('\n')) def li2():return [i for i in input().rstrip('\n')] def li3():return [int(i) for i in input().rstrip('\n')] a = val() b = val() n = len(str(a)) a = [int(i) for i in str(a)] a.sort() if len(str(b)) > n: print(*sorted(a, reverse = 1), sep = '') exit() b = str(b) b = [int(i) for i in b] def makenum(s):return int(''.join(str(e) for e in s)) def givemax(a, b): if len(a) > len(b):return a elif len(b) > len(a):return b else: for j in range(len(a)): if a[j] > b[j]:return a elif b[j] > a[j]:return b return a @lru_cache(None) def dp(l, equal = 1): if len(l) == 1:return str(-float('inf')) if l[0] > b[-1] and equal else str(l[0]) if not equal:return ''.join(str(e) for e in sorted(l, reverse = 1)) ans = '' l = list(l) curr = b[n - len(l)] for i in range(len(l)): if l[i] < curr and dp(tuple(l[:i] + l[i + 1:]), 0) != '-inf': ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 0)) elif l[i] == curr and dp(tuple(l[:i] + l[i + 1:]), 1) != '-inf': ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 1)) return str(ans) print(dp(tuple(a), 1))",cubic,"['dp', 'greedy']",1675
"import sys a, b = input(), input() if len(a) < len(b): print(*sorted(a, reverse=True), sep='') exit() cnt = [0]*10 for x in a: cnt[int(x)] += 1 def rec(res, digit, rem): if digit == len(b): return res if rem[int(b[digit])]: r = rem[:] r[int(b[digit])] -= 1 x = rec(res + b[digit], digit+1, r) if x: return x for d in range(int(b[digit])-1, -1, -1): if rem[d]: res += str(d) rem[d] -= 1 suf = [] for i in range(10): suf += [str(i)] * rem[i] return res + ''.join(sorted(suf, reverse=True)) return '' ans = rec('', 0, cnt[:]) print(ans)",cubic,"['dp', 'greedy']",533
"def make_number(b,chars): if len(chars) == 0: return """" target = chars[0] for i in chars: if int(b[0]) <= int(i): break target = i chars.remove(target) return target + """".join(chars[::-1]) def find_number(b,chars): backup_chars = list(chars) if len(b) == 1: return chars[0] elif b[0] in chars: chars.remove(b[0]) num = b[0] + find_number(b[1:],chars) if min(num,b) == b and b != num: return make_number(b,backup_chars) else: return num else: return make_number(b,backup_chars) a,b = str(input()), str(input()) chars = [i for i in a] chars.sort() if len(a) < len(b): print("""".join(chars[::-1])) else: print(find_number(b,chars))",cubic,"['dp', 'greedy']",627
"a=input() b=input() if len(b)>len(a): l=[int(i) for i in a] l.sort() l=l[::-1] temp=[str(i) for i in l] s=''.join(temp) print(s) else: d={} for i in a: if i not in d: d[i]=1 else: d[i]=d[i]+1 def find(i): global flag if i in d and d[i]>0: d[i]=d[i]-1 return(i) for j in range(int(i),-1,-1): flag=1 j=str(j) if j in d and d[j]>0: d[j]=d[j]-1 return(j) def fun(d): l=[] for i in d: if d[i]>0: l=l+[int(i)]*d[i] l.sort() l=l[::-1] temp=[str(i) for i in l] s=''.join(temp) return(s) def fun2(x): global new for i in range(x-1,-1,-1): temp=new[i] for j in range(int(temp)-1,-1,-1): j=str(j) if j in d and d[j]>0: new=new[:i]+str(j) d[j]=d[j]-1 d[temp]=d[temp]+1 return(new) d[temp]=d[temp]+1 flag=0 new='' for i in range(len(b)): if flag==0: temp=find(b[i]) if temp==None: new=fun2(i) new=new+fun(d) break else: new=new+temp else: new=new+fun(d) break print(new)",cubic,"['dp', 'greedy']",857
"def get(g): s = [str(i) for i in g] num = int("""".join(s)) return num a = input() b = input() bb = int(b) mark = [0 for i in range(len(a))] c = a f = [] g = [] for i in range(0 , len(a)): g.append(a[i]) g.sort() g.reverse() num = get(g) index = [] if num <= bb: print(num) exit(0) for i in range(0 , min(len(a) , len(b))): mx = '-1' idx = 0 for j in range(0 , len(a)): if mark[j] == 0 and a[j] <= b[i]: if a[j] > mx: mx = a[j] idx = j if mx == '-1': rem = [] while True and len(f) > 0: ma = '-1' id = 0 for j in range(0 , len(a)): if mark[j] == 0 and a[j] < f[-1]: if a[j] > ma: ma = a[j] id = j if ma == '-1': mark[index.pop()] = 0 f.pop() continue else: mark[index.pop()] = 0 f.pop() f.append(ma) mark[id] = 1 break for j in range(0, len(a)): if mark[j] == 0: rem.append(a[j]) rem.sort() rem.reverse() for j in rem: f.append(j) print(get(f)) exit(0) elif mx < b[i] and mx != '-1': f.append(mx) mark[idx] = 1 index.append(idx) break elif mx == b[i] and mx != '-1': f.append(mx) mark[idx] = 1 index.append(idx) rem = [] for i in range(0 , len(a)): if mark[i] == 0: rem.append(a[i]) rem.sort() rem.reverse() for i in rem: f.append(i) print(get(f))",cubic,"['dp', 'greedy']",1145
"def get(g): s = [str(i) for i in g] num = int("""".join(s)) return num a = input() b = input() bb = int(b) mark = [0 for i in range(len(a))] c = a f = [] g = [] for i in range(0 , len(a)): g.append(a[i]) g.sort() g.reverse() num = get(g) index = [] if num <= bb: print(num) exit(0) for i in range(0 , min(len(a) , len(b))): mx = '-1' idx = 0 for j in range(0 , len(a)): if mark[j] == 0 and a[j] <= b[i]: if a[j] > mx: mx = a[j] idx = j if mx == '-1': rem = [] while True and len(f) > 0: ma = '-1' id = 0 for j in range(0 , len(a)): if mark[j] == 0 and a[j] < f[-1]: if a[j] > ma: ma = a[j] id = j if ma == '-1': mark[index.pop()] = 0 f.pop() continue else: mark[index.pop()] = 0 f.pop() f.append(ma) mark[id] = 1 break for j in range(0, len(a)): if mark[j] == 0: rem.append(a[j]) rem.sort() rem.reverse() for j in rem: f.append(j) print(get(f)) exit(0) f.append(mx) mark[idx] = 1 index.append(idx) if mx < b[i] and mx != '-1': break rem = [] for i in range(0 , len(a)): if mark[i] == 0: rem.append(a[i]) rem.sort() rem.reverse() for i in rem: f.append(i) print(get(f))",cubic,"['dp', 'greedy']",1066
"def c(a, b, l, ans, pro): if l != 0: n = a[:] mx = None pro1 = pro prosh = set() for i in range(l): pro = pro1 if a[i] == prosh: continue elif (a[i] <= b[0] and pro): n.pop(i) prosh = a[i] if pro == True: if a[i] < b[0]: pro = False m = c(n, b[1:], l-1, ans+str(a[i]), pro) n = a[:] if m != None: if mx == None: mx = int(m) elif mx < int(m): mx = int(m) elif not(pro): a.sort(reverse = True) a = list(map(str, a)) return ans +''.join(a) else: break return mx else: return ans a = input() b = input() l = len(a) if len(a) != len(b): a = list(a) a.sort() print(''.join(a[::-1])) else: a = list(map(int, a)) b = list(map(int, b)) a.sort() n = a[:] mx = 0 prosh = -1 for i in range(l): if a[i] == prosh: continue elif a[i] != 0 and a[i] <= b[0]: n.pop(i) prosh = a[i] pro = False if a[i] == b[0]: pro = True m = c(n, b[1:], l-1, str(a[i]), pro) n = a[:] if m != None: if mx < int(m): mx = int(m) elif a[i] > b[0]: break print(mx)",cubic,"['dp', 'greedy']",925
"def c(a, b, l, ans, pro): if l != 0: n = a[:] mx = None pro1 = pro prosh = set() for i in range(l): pro = pro1 if a[i] == prosh: continue elif (a[i] <= b[0] and pro): n.pop(i) prosh = a[i] if pro == True: if a[i] < b[0]: pro = False m = c(n, b[1:], l-1, ans+str(a[i]), pro) n = a[:] if m != None: if mx == None: mx = int(m) elif mx < int(m): mx = int(m) elif not(pro): a.sort(reverse = True) a = list(map(str, a)) return ans +''.join(a) else: break return mx else: return ans a = input() b = input() l = len(a) if len(a) != len(b): a = list(a) a.sort() print(''.join(a[::-1])) else: a = list(map(int, a)) b = list(map(int, b)) a.sort() n = a[:] mx = 0 prosh = -1 for i in range(l): if a[i] == prosh: continue elif a[i] != 0 and a[i] <= b[0]: n.pop(i) prosh = a[i] pro = False if a[i] == b[0]: pro = True m = c(n, b[1:], l-1, str(a[i]), pro) n = a[:] if m != None: if mx < int(m): mx = int(m) elif a[i] > b[0]: break print(mx)",cubic,"['dp', 'greedy']",925
"from sys import stdin from collections import Counter rstr = lambda: stdin.readline().strip() a, b = list(rstr()), list(rstr()) if len(a) < len(b) or len(a) == 1: print(''.join(sorted(a)[::-1])) else: ans, tem = 0, [] for i in range(len(b)): for j in range(int(b[i]) - 1, -1, -1): if str(j) in a and not (j == i == 0): a.remove(str(j)) ans = max(ans, int(''.join(tem) + str(j) + ''.join(sorted(a)[::-1]))) a.append(str(j)) break if b[i] not in a: break tem.append(b[i]) a.remove(b[i]) if tem: ans = max(ans, int(''.join(tem))) print(ans)",cubic,"['dp', 'greedy']",537
"a = input() b = input() digits = {} def greedy(digits,s): for i in range(9,-1,-1): d = str(i) if d in digits: while digits[d] > 0: s += d digits[d] -= 1 return s for d in a: if d in digits: digits[d] += 1 else: digits[d] = 1 if len(a) < len(b): print(greedy(digits,"""")) else: ind = 0 cur = """" back = False done = False while 1: if ind == len(a) or done == True: break found = False for i in range(9,-1,-1): x = str(i) if i == int(b[ind]) and x in digits and digits[x] > 0: found = True digits[x] -= 1 cur += x break elif i < int(b[ind]) and x in digits and digits[x] > 0: found = True done = True digits[x] -= 1 cur += x print(greedy(digits,cur)) break if found == False: back = True break ind += 1 if back == False and done == False: print(cur) elif done == False: for i in range(ind-1,-1,-1): digits[cur[i]] += 1 for j in range(9,-1,-1): d = str(j) if j < int(b[i]) and d in digits and digits[d] > 0: done = True s = cur[:i] s += d digits[d] -= 1 print(greedy(digits,s)) break if done: break",cubic,"['dp', 'greedy']",993
a = list(input()) b = int(input()) a.sort(reverse=True) ans='' while a: for i in range(len(a)): temp='' x=ans+a[i]+temp.join(sorted(a[:i]+a[i+1:])) if int(x)<=b: ans+=a[i] a=a[:i]+a[i+1:] break print(int(ans)),cubic,"['dp', 'greedy']",209
"n, m, k = map(int, input().split()) DATA = [input() for i in range(n)] INF = 1 << 60 dp = [[INF]*(k + 10) for i in range(n + 10)] dp[0][0] = 0 COST = [[INF]*(k + 10) for i in range(n + 10)] for i, string in enumerate(DATA): stack = [] for j in range(m): if string[j] == ""1"": stack.append(j) L = len(stack) for j in range(k + 10): if j >= L: COST[i + 1][j] = 0 continue else: for pos in range(j + 1): l = pos r = pos + L - 1 - j COST[i+1][j] = min(COST[i+1][j], stack[r] - stack[l] + 1) for day in range(1, n + 1): for used_cost in range(k + 1): dp[day][used_cost] = min(dp[day - 1][prev_cost] + COST[day] [used_cost - prev_cost] for prev_cost in range(used_cost + 1)) ans = min(dp[n][used_cost] for used_cost in range(k + 1)) print(ans)",cubic,['dp'],736
"import sys,os,io from sys import stdin import math from collections import defaultdict from heapq import heappush, heappop, heapify from bisect import bisect_left , bisect_right from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") alphabets = list('abcdefghijklmnopqrstuvwxyz') from types import GeneratorType def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = next(to) else: stack.pop() if not stack: break to = stack[-1].send(to) return to return wrappedfunc def ncr(n, r, p): num = den = 1 for i in range(r): num = (num * (n - i)) % p den = (den * (i + 1)) % p return (num * pow(den,p - 2, p)) % p def primeFactors(n): l = [] while n % 2 == 0: l.append",cubic,['dp'],1999
"R = lambda: map(int, input().split()) n, m, k = R() cls = [list(i for i, x in enumerate(map(int, input())) if x) for _ in range(n)] dp = [[n * m] * (k + 1) for i in range(n + 1)] dp.append([0] * (k + 1)) for i in range(n): row = cls[i] c2l = [m + 1] * (m + 1) c2l[0] = row[-1] - row[0] + 1 if row else 0 c2l[len(row)] = 0 for r in range(len(row)): for l in range(r + 1): c2l[len(row) - (r - l + 1)] = min(c2l[len(row) - (r - l + 1)], row[r] - row[l] + 1) for j in range(k + 1): for c, l in enumerate(c2l): if j + c <= k and l < m + 1: dp[i][j] = min(dp[i][j], dp[i - 1][j + c] + l) print(min(dp[n - 1]))",cubic,['dp'],603
"def min_sub_array(day, k): if not day: return [0] * (k + 1) n = len(day) best = [float('inf')] * (n + 1) best[0] = 0 best[1] = 1 for size in range(2, n + 1): for i in range(n + 1 - size): best[size] = min(best[size], day[i + size - 1] - day[i] + 1) output = [0] * (k + 1) for i in range(k + 1): if n - i > 0: output[i] = best[n - i] return output N, M, K = map(int, input().split()) day = [i for i, val in enumerate(input()) if val == '1'] best = min_sub_array(day, K) for _ in range(N - 1): day = [i for i, val in enumerate(input()) if val == '1'] new_day_best = min_sub_array(day, K) new_best = [float('inf')] * (K + 1) for i in range(K + 1): for j in range(i + 1): new_best[i] = min(new_best[i], new_day_best[j] + best[i - j]) best = new_best print(best[K])",cubic,['dp'],760
"import math import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def calc(st,j): ans=9999999999999999999999 if j>=len(st): return 0 j=len(st)-j for i in range(j-1,len(st)): ans=min(ans,st[i]-st[i-j+1]+1) return ans n,m,k=map(int,input().split()) s=[] for i in range(n): s.append(input()) inf=99999999999999999999 dp=[[inf for i in range(k+1)]for j in range(n+1)] for i in range(k+1): dp[0][i]=0 for i in range(1,n+1): st=[] for ik in range(len(s[i-1])): if s[i-1][ik]=='1': st.append(ik) for j in range(k+1): no=calc(st,j) for t in range(k+1-j): dp[i][t+j]=min(dp[i][t+j],no+dp[i-1][t]) print(dp[n][k])",cubic,['dp'],1946
"from sys import stdin rstr = lambda: stdin.readline().strip() rints = lambda: [int(x) for x in stdin.readline().split()] n, m, k = rints() a = [rstr() for _ in range(n)] mem = [[float('inf') if i else 0 for _ in range(k + 1)] for i in range(n + 1)] for i in range(n): ixs = [] for j in range(m): if a[i][j] == '1': ixs.append(j) for j in range(k + 1): tem = 0 if j < len(ixs): tem, c = float('inf'), 0 for j1 in range(len(ixs) - j - 1, len(ixs)): tem = min(tem, ixs[j1] - ixs[c] + 1) c += 1 for j1 in range(k + 1 - j): mem[i + 1][j1 + j] = min(mem[i + 1][j1 + j], mem[i][j1] + tem) print(mem[n][k])",cubic,['dp'],598
"import sys input = sys.stdin.readline def int_array(): return list(map(int, input().strip().split())) def float_array(): return list(map(float, input().strip().split())) def str_array(): return input().strip().split() from collections import Counter import math import bisect from collections import deque n,m,lesson=int_array() dp=[[250005 for i in range(lesson+2)]for j in range(n+1)] days=[[] for i in range(n)] for i in range(n): s=input() for j in range(m): if s[j]==""1"": days[i].append(j+1) m=[[250005 for i in range(lesson+2)]for j in range(n+1)] for i in range(n): for j in range(lesson+1): if j<=len(days[i]): if j==len(days[i]): m[i][j]=0 continue else: for k in range(0,j+1): var=days[i][0+k] var1=days[i][-1*max(1,1+(j-k))] m[i][j]=min(m[i][j],var1-var+1) for i in range(lesson+1): dp[0][i]=m[0][i] for i in range(1,n): for j in range(lesson+1): for k in range(j+1): dp[i][j]=min(dp[i][j],dp[i-1][j-k]+m[i][k]) print(min(dp[n-1]))",cubic,['dp'],942
"import sys n, m, k = map(int, input().split()) table = [input() for _ in range(n)] dp = [0]*(k+1) for a in table: one = [] for i in range(m): if a[i] == '1': one.append(i) if not one: continue ni = len(one) subdp = [10**9] * (ni+1) subdp[-1] = 0 for i in range(ni): for j in range(i, ni): subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1) next_dp = [10**9]*(k+1) for i in range(k, -1, -1): for j in range(ni+1): if i+j > k: break next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j]) dp = next_dp print(min(dp))",cubic,['dp'],518
"xs,ys = map(float,input().split()) n = int(input()) dist = [[0]*(n+1) for i in range(n+1)] dist2 = [[0]*(n) for i in range(n)] objects = [list(map(float,input().split())) for i in range(n)] + [[xs,ys]] for i in range(n+1): for j in range(n+1): dist[i][j] = (objects[i][0] - objects[j][0])**2 + (objects[i][1] - objects[j][1])**2 for i in range(n): for j in range(n): dist2[i][j] = dist[n][i] + dist[i][j] + dist[j][n] dp = [1e6]*(1<<n) vis = set([0]) dp[0] = 0 for i in range((1<<n)-1): if i in vis: for j in range(n): if i&(1<<j) == 0: newi = i + (1 << j) dp[newi] = min(dp[newi], dp[i] + 2*dist[n][j]) vis.add(newi) for k in range(j+1,n): if i&(1<<k) == 0: newi |= 1<<k dp[newi] = min(dp[newi], dp[i] + dist2[j][k]) vis.add(newi) newi ^= 1<<k break curr = (1<<n) - 1 path = [0] while curr: for i in range(n): if curr & (1<<i): if dp[curr] == dp[curr - (1<<i)] + 2*dist[n][i]: path.extend([i+1,0]) curr ^= (1<<i) for j in range(i+1,n): if curr & (1<<j): if dp[curr] == dp[curr - (1<<i) - (1<<j)] + dist2[i][j]: path.extend([j+1,i+1,0]) curr ^= (1<<i) + (1<<j) print(int(dp[(1<<n)-1])) print(*path[::-1])",np,"['bitmasks', 'dp']",1104
"CANDNUM = 5 I = lambda: [int(x) for x in raw_input().split()] T = lambda x1, y1, x2, y2: (x1-x2)**2+(y1-y2)**2 def getCandidates(tsLst, curN, notSeen): r = [] curD = {} k = 0 cand = None curSet = set() for x in tsLst: i, j = x curSet.add(i) if len(curSet) == curN-1: cand = list(notSeen - curSet)[0] break curSet.add(j) if len(curSet) == curN-1: cand = list(notSeen - curSet)[0] break i = 0 for x in tsLst: if cand in x: r.append(x) i += 1 if i == CANDNUM: break return r def solve(xs, ys, n, oLst): def solveEven(seen): def solveEvenRec(notSeen, tsLst): if len(notSeen) == 0: return 0, [] ns = tuple(notSeen) if ns in solveEvenRec.d: return solveEvenRec.d[ns] minLst = [] minT = 10000000 cands = getCandidates(tsLst, len(notSeen), notSeen) for x in cands: i, j = x newNotSeen = notSeen.copy() if i in newNotSeen: newNotSeen.remove(i) if j in newNotSeen: newNotSeen.remove(j) newTsLst = [] for x1 in tsLst: i1, j1 = x1 if i1 in newNotSeen and j1 in newNotSeen: newTsLst.append(x1) rT, rLst = solveEvenRec(newNotSeen, newTsLst) rT += ts[x] if rT < minT: minT = rT minLst = [x] + rLst r = minT, minLst solveEvenRec.d[ns] = r return r solveEvenRec.d = {} newLst = [] for i in range(n): if i not in seen: newLst.append(i) newN = n - len(seen) if newN == 2: minT = 10000000 minLst = [] for a in ts: if ts[a] < minT: minT = ts[a] minLst = [a] rT = minT rLst = minLst else: newTsLst = [] for x in tsLst: a, _ = x i, j = a if i not in seen and j not in seen: newTsLst.append(a) notSeen = set(range(n)) - set(seen) rT, rLst = solveEvenRec(notSeen, newTsLst) return rT, rLst ts = {} tss = {} for i in range(n-1): x1, y1 = oLst[i] for j in range(i+1, n): x2, y2 = oLst[j] t = T(x1, y1, x2, y2) t1 = T(x1, y1, xs, ys) t2 = T(xs, ys, x2, y2) if t1+t2 >= t: ts[(i, j)] = t tss[(i, j)] = True else: ts[(i, j)] = t1+t2 tss[(i, j)] = False tsLst = [] for x in ts: tsLst.append((x, ts[x])) tsLst.sort(key=lambda x:x[1]) if n%2: if n > 1: resT = 10000000 resLst = [] for i in range(n): x, y = oLst[i] t = 2*T(x, y, xs,",np,"['bitmasks', 'dp']",1999
"xs, ys = map(int, input().split()) things = [[xs, ys, 0]] n = int(input()) for i in range(n): things.append(list(map(int, input().split())) + [i + 1]) distance = [[0 for i in range(n + 1)] for j in range(n + 1)] for i in range(n + 1): for j in range(i, n + 1): distance[i][j] = distance[j][i] = (things[i][0] - things[j][0]) ** 2 + (things[i][1] - things[j][1]) ** 2 INF = float('inf') DP = [INF for _ in range((1 << n) + 10)] Path = [None for _ in range((1 << n) + 10)] DP[0] = 0 for cur in range(1 << n): if DP[cur] == INF: continue for nxt1 in range(n): if cur & (1 << nxt1) != 0: continue if DP[cur | (1 << nxt1)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]: DP[cur | (1 << nxt1)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0] Path[cur | (1 << nxt1)] = cur for nxt2 in range(n): if (cur | (1 << nxt1)) & (1 << nxt2) != 0: continue if DP[cur | (1 << nxt1) | (1 << nxt2)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]: DP[cur | (1 << nxt1) | (1 << nxt2)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0] Path[cur | (1 << nxt1) | (1 << nxt2)] = cur break print(DP[(1 << n) - 1]) path = [] cur = (1 << n) - 1 while cur != 0: path.append(0) father = Path[cur] diff = cur ^ father d1 = len(bin(diff)[2:]) path.append(d1) diff ^= (1 << (d1 - 1)) if diff != 0: d2 = len(bin(diff)[2:]) path.append(d2) cur = father path.append(0) path = list(reversed(path)) print(' '.join(map(str, path)))",np,"['bitmasks', 'dp']",1493
"from itertools import chain from time import time def main(): BITS = [1 << sh for sh in range(24)] B2N = {v: u for u, v in enumerate(BITS)} def getPt(): return tuple(map(int, input().split())) def dist(ptA, ptB): return sum(((u-v)**2 for u, v in zip(ptA, ptB))) def getBits(val): return tuple(filter(lambda x: x&val, BITS)) def chooseTwo(pool): n = len(pool) for i in range(n): for j in range(i+1, n): yield (pool[i], pool[j]) ori = getPt() pts = [] N = int(input()) for _ in range(N): pts.append(getPt()) vis = set([0]) mint = [0]+[1e8]*(1<<N) pres = [None]*(1<<N) allb = (1 << N)-1 B2P = {BITS[u]: v for u, v in enumerate(pts)} B2P[0] = ori alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P} getDP = lambda x: mint[x] newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \ + alld[p[0]][0] \ + alld[p[1]][0] for stt in range(1<<N): if stt not in vis: continue bits = getBits(~stt&allb) sb = bits[0] if bits else None for bit in bits: newstt = stt | sb | bit nd = newDist(stt, (sb, bit)) if getDP(newstt) > nd: mint[newstt] = nd pres[newstt] = sb | bit vis.add(newstt) print(mint[allb]) path = ['0'] stt = allb while stt: bits = getBits(pres[stt]) for bit in bits: path.append(str(B2N[bit]+1)) path.append('0') stt ^= pres[stt] print(' '.join(path)) import sys st = time() main() print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",np,"['bitmasks', 'dp']",1357
"from itertools import chain from time import time def main(): BITS = [1 << sh for sh in range(24)] B2N = {v: u for u, v in enumerate(BITS)} def getPt(): return tuple(map(int, input().split())) def dist(ptA, ptB): return sum(((u-v)**2 for u, v in zip(ptA, ptB))) def getBits(val): return tuple(filter(lambda x: x&val, BITS)) def chooseTwo(pool): n = len(pool) for i in range(n): for j in range(i+1, n): yield (pool[i], pool[j]) ori = getPt() pts = [] N = int(input()) for _ in range(N): pts.append(getPt()) vis = set([0]) mint = [0]+[1e8]*(1<<N) pres = [None]*(1<<N) allb = (1 << N)-1 B2P = {BITS[u]: v for u, v in enumerate(pts)} B2P[0] = ori alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P} getDP = lambda x: mint[x] newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \ + alld[p[0]][0] \ + alld[p[1]][0] for stt in range(1<<N): if stt not in vis: continue bits = getBits(~stt&allb) sb = bits[0] if bits else None for bit in bits: newstt = stt | sb | bit nd = newDist(stt, (sb, bit)) if getDP(newstt) > nd: mint[newstt] = nd pres[newstt] = sb | bit vis.add(newstt) print(mint[allb]) path = ['0'] stt = allb while stt: bits = getBits(pres[stt]) for bit in bits: path.append(str(B2N[bit]+1)) path.append('0') stt ^= pres[stt] print(' '.join(path)) if __name__ == '__main__': import sys st = time() main() print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",np,"['bitmasks', 'dp']",1384
"import sys def main(): BITS = [1 << sh for sh in range(24)] B2N = {v: u for u, v in enumerate(BITS)} def getPt(): return tuple(map(int, input().split())) def dist(ptA, ptB): return sum(((u - v) ** 2 for u, v in zip(ptA, ptB))) def getBits(val): return tuple(filter(lambda x: x & val, BITS)) def chooseTwo(pool): n = len(pool) for i in range(n): for j in range(i + 1, n): yield (pool[i], pool[j]) ori = getPt() pts = [] N = int(input()) for _ in range(N): pts.append(getPt()) vis = set([0]) mint = [0] + [1e8] * (1 << N) pres = [None] * (1 << N) allb = (1 << N) - 1 B2P = {BITS[u]: v for u, v in enumerate(pts)} B2P[0] = ori alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P} getDP = lambda x: mint[x] newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \ + alld[p[0]][0] \ + alld[p[1]][0] for stt in range(1 << N): if stt not in vis: continue bits = getBits(~stt & allb) sb = bits[0] if bits else None for bit in bits: newstt = stt | sb | bit nd = newDist(stt, (sb, bit)) if getDP(newstt) > nd: mint[newstt] = nd pres[newstt] = sb | bit vis.add(newstt) print(mint[allb]) path = ['0'] stt = allb while stt: bits = getBits(pres[stt]) for bit in bits: path.append(str(B2N[bit] + 1)) path.append('0') stt ^= pres[stt] print(' '.join(path)) main()",np,"['bitmasks', 'dp']",1257
"x0, y0 = map(int, input().split()) n = int(input()) arr = [[x0, y0]] for i in range(0, n): x, y = map(int, input().split()) arr.append([x, y]) dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)] for i in range(0, n+1): for j in range(0, n+1): dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2 def dfs(status, memo, pp): if memo[status] != None: return memo[status] if status < 0: return 1e8 res = 1e8 prev = [] for i in range(1, n+1): if (status & (1 << (i - 1))) == 0: continue t1 = status ^ (1 << (i - 1)) temp = dfs(t1, memo, pp) + dist[0][i]*2 if temp < res: res = temp prev = [i, 0] for j in range(i+1, n+1): if j == i: continue if (t1 & (1 << (j - 1))) == 0: continue next = t1 ^ (1 << (j - 1)) temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0] if temp < res: res = temp prev = [i, j, 0] break memo[status] = res pp[status] = prev return res memo = [None for i in range(0, 1 << n)] pp = [None for i in range(0, 1 << n)] memo[0] = 0 pp[0] = [] start = 0 end = 0 for i in range(0, n): end += (1 << i) res = dfs(end, memo, pp) path = [0] cur = end while cur > 0: prev = pp[cur] path.extend(prev) for i in range(len(prev) - 1): cur -= (1 << (prev[i] - 1)) print(res) print(' '.join(map(str, path)))",np,"['bitmasks', 'dp']",1242
"x0, y0 = map(int, input().split()) n = int(input()) arr = [[x0, y0]] for i in range(0, n): x, y = map(int, input().split()) arr.append([x, y]) dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)] for i in range(0, n+1): for j in range(0, n+1): dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2 def dfs(status, memo, pp): if memo[status] != None: return memo[status] if status < 0: return 1e8 res = 1e8 prev = [] for i in range(1, n+1): if (status & (1 << (i - 1))) == 0: continue t1 = status ^ (1 << (i - 1)) temp = dfs(t1, memo, pp) + dist[0][i]*2 if temp < res: res = temp prev = [i, 0] for j in range(i+1, n+1): if j == i: continue if (t1 & (1 << (j - 1))) == 0: continue next = t1 ^ (1 << (j - 1)) temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0] if temp < res: res = temp prev = [i, j, 0] break memo[status] = res pp[status] = prev return res memo = [None for i in range(0, 1 << n)] pp = [None for i in range(0, 1 << n)] memo[0] = 0 pp[0] = [] start = 0 end = 0 for i in range(0, n): end += (1 << i) res = dfs(end, memo, pp) path = [0] cur = end while cur > 0: prev = pp[cur] path.extend(prev) for i in range(len(prev) - 1): cur -= (1 << (prev[i] - 1)) print(res) print(' '.join(map(str, path)))",np,"['bitmasks', 'dp']",1242
"n = int(input()) p = [] for i in range(n): la = list(map(float,input().split())) p.append(la) full_bit = (1<<n) - 1 dp = [0]*(full_bit) + [1] for i in range(full_bit,0,-1): cunt = bin(i)[2:].count('1') if cunt == 1 or dp[i] == 0: continue mul = 1/((cunt*(cunt-1))>>1) for x in range(n): if (i & (1<<x)) == 0: continue for y in range(x+1,n): if (i & (1<<y)) == 0: continue dp[i-(1<<y)]+=dp[i]*p[x][y]*mul dp[i-(1<<x)]+=dp[i]*p[y][x]*mul ans = [] for i in range(n): ans.append(dp[1<<i]) print(*ans)",np,"['bitmasks', 'dp', 'probabilities']",496
"import sys input=sys.stdin.readline def count_bits(x): cnt=0 for i in range(n): if((1<<i)&x): cnt+=1 return(cnt) n=int(input()) a=[list(map(float,input().split())) for i in range(n)] dp=[0 for i in range(1<<n)] dp[-1]=1 for mask in range((1<<n)-1,-1,-1): val=count_bits(mask) total=val*(val-1)//2 for i in range(n): if(mask&(1<<i)==0): continue for j in range(n): if(mask&(1<<j)==0 or i==j): continue dp[mask^(1<<j)]+=dp[mask]*a[i][j]/total for i in range(n): print(dp[1<<i])",np,"['bitmasks', 'dp', 'probabilities']",475
"import os,sys from io import BytesIO,IOBase def count(x): ans = 0 while x: x &= x-1 ans += 1 return ans def main(): n = int(input()) a = [list(map(float,input().split())) for _ in range(n)] y = 1<<n dp = [0]*(y-1)+[1] powe = [1<<i for i in range(n)] for i in range(y-1,0,-1): bit = count(i) prob = bit*(bit-1)//2 for j in range(n): if not i&powe[j]: continue for x in range(n): if not i&powe[x]: continue dp[i-powe[x]] += dp[i]*a[j][x]*prob dp[i-powe[j]] += dp[i]*a[x][j]*prob z = sum(dp[1<<i] for i in range(n)) for i in range(n): print(dp[1<<i]/z,end=' ') print() BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self,file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) self.newlines = b.count(b""\n"")+(not b) ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd,self.buffer.getvalue()) self.buffer.truncate(0),self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self,file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s:self.buffer.write(s.encode(""ascii"")) self.read = lambda:self.buffer.read().decode(""ascii"") self.readline = lambda:self.buffer.readline().decode(""ascii"") sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout) input = lambda:sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",np,"['bitmasks', 'dp', 'probabilities']",1922
"n = int(input()) probs = list() for i in range(n): probs.append(list(map(float, input().split()))) dp = [list([0 for i in range(1<<n)]) for i in range(n)] dp[0][(1<<n)-1] = 1 ak = [list() for i in range(n+1)] for i in range(1<<n): ak[bin(i).count(""1"")].append(i) for k in range(1, n): for ele in ak[n-k+1]: for j in range(n): if (ele&(1<<j)): for w in range(n): if (ele&(1<<w)) and j != w: dp[k][ele-(1<<j)] += (dp[k-1][ele]*probs[w][j])/(((n-k+1)*(n-k))/2) for i in range(n): print(dp[n-1][(1<<i)], end = "" "") print()",np,"['bitmasks', 'dp', 'probabilities']",518
"n=int(input()) b=[] for i in range(n): b.append(list(map(float,input().split()))) ma=1<<n dp=[0 for j in range(ma)] dp[0]=1 for mask in range(1,ma): l=n-bin(mask).count(""1"")+1 res=l*(l-1)//2 for i in range(n): if mask&(1<<i): for j in range(n): if not mask&(1<<j): dp[mask]+=((dp[mask^(1<<i)]*b[j][i])/res) ans=[] for i in range(n): ans.append(dp[ma-1-(1<<i)]) print(*ans)",np,"['bitmasks', 'dp', 'probabilities']",372
"from sys import stdin input=stdin.readline def count(n): value=0 while(n): n &= (n-1) value+=1 return value def nc2(n): return (n*(n - 1))//2 def answer(): dp=[0]*(1 << n) dp[(1 << n) - 1]=1 for mask in range((1 << n) - 1,0,-1): m=count(mask) if(m==1):continue p=1/(nc2(m)) for i in range(n): for j in range(n): if(i==j):continue if((mask >> i & 1) and (mask >> j & 1)): next_mask=mask ^ (1 << j) dp[next_mask]+=(dp[mask]*p*a[i][j]) for i in range(n): print(dp[1 << i],end=' ') n=int(input()) a=[list(map(float,input().split())) for i in range(n)] answer() print()",np,"['bitmasks', 'dp', 'probabilities']",564
"import os import sys from io import BytesIO, IOBase def main(): n=int(input()) prob=[] for _ in range(n): prob.append(list(map(float,input().split()))) dp=[-1 for _ in range(1<<n)] ans=[0 for _ in range(n)] def move(mask,die): total=bin(mask).count('1') z=0 for i in range(n): if mask & (1<<i): z+=prob[i][die] return z/((total*(total-1))>>1) def solve(mask): if mask==(1<<n)-1: return 1 if dp[mask]!=-1: return dp[mask] ans=0 for i in range(n): if not (mask & (1<<i)): prev=solve(mask ^ (1<<i)) ans+=prev*move(mask ^ (1<<i),i) dp[mask]=ans return ans for i in range(n): ans[i]='%.6f'%solve(1<<i) print(*ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = 'x' in file.mode or 'r' not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b'\n') + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode('ascii')) self.read = lambda: self.buffer.read().decode('ascii') self.readline = lambda: self.buffer.readline().decode('ascii') sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip('\r\n') if __name__ == '__main__': main()",np,"['bitmasks', 'dp', 'probabilities']",1987
"import os, sys from io import BytesIO, IOBase class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") class dict(dict): def __missing__(self, key): return 0 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") inp = lambda dtype: [dtype(x) for x in input().split()] inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)] inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)] inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))] inp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)] ceil1 = lambda a, b: (a + b - 1) // b get_bit = lambda x, i: (x >> i) & 1 n = int(input()) a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1 if n == 1: exit(print(1)) for i in range(n): for j in range(i + 1, n): masks[big ^ (1 << j)] += a[i][j] masks[big ^ (1 << i",np,"['bitmasks', 'dp', 'probabilities']",2000
"import os, sys from io import BytesIO, IOBase class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") class dict(dict): def __missing__(self, key): return 0.0 sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") inp = lambda dtype: [dtype(x) for x in input().split()] inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)] inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)] inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))] inp_enus = lambda dtype, n: [tuple([i] + inp(dtype)) for i in range(n)] ceil1 = lambda a, b: (a + b - 1) // b get_bit = lambda x, i: (x >> i) & 1 n = int(input()) a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1 if n == 1: exit(print(1)) for i in range(n): for j in range(i + 1, n): masks[big ^ (1 << j)] += a[i][j] masks[big",np,"['bitmasks', 'dp', 'probabilities']",1999
"import sys from array import array def input(): return sys.stdin.buffer.readline().decode('utf-8') n = int(input()) prob = [tuple(map(float, input().split())) for _ in range(n)] full_bit = (1 << n) - 1 dp = [0.0] * full_bit + [1.0] for bit in range(full_bit, 0, -1): popcount = len([1 for i in range(n) if (1 << i) & bit]) if popcount == 1 or dp[bit] == 0.0: continue div = 1 / ((popcount * (popcount - 1)) >> 1) for i in range(n): if ((1 << i) & bit) == 0: continue for j in range(i + 1, n): if ((1 << j) & bit) == 0: continue dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div print(*(dp[1 << i] for i in range(n)))",np,"['bitmasks', 'dp', 'probabilities']",664
"numbersDict = { ""1"": ""H"", ""2"": ""He"", ""3"": ""Li"", ""4"": ""Be"", ""5"": ""B"", ""6"": ""C"", ""7"": ""N"", ""8"": ""O"", ""9"": ""F"", ""10"": ""Ne"", ""11"": ""Na"", ""12"": ""Mg"", ""13"": ""Al"", ""14"": ""Si"", ""15"": ""P"", ""16"": ""S"", ""17"": ""Cl"", ""18"": ""Ar"", ""19"": ""K"", ""20"": ""Ca"", ""21"": ""Sc"", ""22"": ""Ti"", ""23"": ""V"", ""24"": ""Cr"", ""25"": ""Mn"", ""26"": ""Fe"", ""27"": ""Co"", ""28"": ""Ni"", ""29"": ""Cu"", ""30"": ""Zn"", ""31"": ""Ga"", ""32"": ""Ge"", ""33"": ""As"", ""34"": ""Se"", ""35"": ""Br"", ""36"": ""Kr"", ""37"": ""Rb"", ""38"": ""Sr"", ""39"": ""Y"", ""40"": ""Zr"", ""41"": ""Nb"", ""42"": ""Mo"", ""43"": ""Tc"", ""44"": ""Ru"", ""45"": ""Rh"", ""46"": ""Pd"", ""47"": ""Ag"", ""48"": ""Cd"", ""49"": ""In"", ""50"": ""Sn"", ""51"": ""Sb"", ""52"": ""Te"", ""53"": ""I"", ""54"": ""Xe"", ""55"": ""Cs"", ""56"": ""Ba"", ""57"": ""La"", ""58"": ""Ce"", ""59"": ""Pr"", ""60"": ""Nd"", ""61"": ""Pm"", ""62"": ""Sm"", ""63"": ""Eu"", ""64"": ""Gd"", ""65"": ""Tb"", ""66"": ""Dy"", ""67"": ""Ho"", ""68"": ""Er"", ""69"": ""Tm"", ""70"": ""Yb"", ""71"": ""Lu"", ""72"": ""Hf"", ""73"": ""Ta"", ""74"": ""W"", ""75"": ""Re"", ""76"": ""Os"", ""77"": ""Ir"", ""78"": ""Pt"", ""79"": ""Au"", ""80"": ""Hg"", ""81"": ""Tl"", ""82"": ""Pb"", ""83"": ""Bi"", ""84"": ""Po"", ""85"": ""At"", ""86"": ""Rn"", ""87"": ""Fr"", ""88"": ""Ra"", ""89"": ""Ac"", ""90"": ""Th"", ""91"": ""Pa"", ""92"": ""U"", ""93"": ""Np"", ""94"": ""Pu"", ""95"": ""Am"", ""96"": ""Cm"", ""97"": ""Bk"", ""98"": ""Cf"", ""99"": ""Es"", ""100"": ""Fm"" } lettersDict = { ""H"": ""1"", ""He"": ""2"", ""Li"": ""3"", ""Be"": ""4"", ""B"": ""5"", ""C"": ""6"", ""N"": ""7"", ""O"": ""8"", ""F"": ""9"", ""Ne"": ""10"", ""Na"": ""11"", ""Mg"": ""12"", ""Al"": ""13"", ""Si"": ""14"", ""P"": ""15"", ""S"": ""16"", ""Cl"": ""17"", ""Ar"": ""18"", ""K"": ""19"", ""Ca"": ""20"", ""Sc"": ""21"", ""Ti"": ""22"", ""V"": ""23"", ""Cr"": ""24"", ""Mn"": ""25"", ""Fe"": ""26"", ""Co"": ""27"", ""Ni"": ""28"", ""Cu"": ""29"", ""Zn"": ""30"", ""Ga"": ""31"", ""Ge"": ""32"", ""As"": ""33"", ""Se"": ""34"", ""Br"": ""35"", ""Kr"": ""36"", ""Rb"": ""37"", ""Sr"": ""38"", ""Y"": ""39"", ""Zr"": ""40"", ""Nb"": ""41"", ""Mo"": ""42"", ""Tc"": ""43"", ""Ru"": ""44"", ""Rh"": ""45"", ""Pd"": ""46"", ""Ag"": ""47"", ""Cd"": ""48"", ""In"": ""49"", ""Sn"": ""50"", ""Sb"": ""51"", ""Te"": ""52"", ""I"": ""53"", ""Xe"": ""54"", ""Cs"": ""55"", ""Ba"": ""56"", ""La"": ""57"", ""Ce"": ""58"", ""Pr"": ""59"", ""Nd"": ""60"", ""Pm"": ""61"", ""Sm"": ""62"", ""Eu"": ""63"", ""Gd"": ""64"", ""Tb"": ""65"", ""Dy"": ""66"", ""Ho"": ""67"", ""Er"":",np,"['bitmasks', 'dp']",1999
"import itertools element_to_value = { 'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10, 'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20, 'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30, 'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40, 'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50, 'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60, 'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70, 'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80, 'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90, 'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100 } value_to_element = dict() for (element, value) in element_to_value.items(): value_to_element[value] = element (n,k) = map(int,input().split()) products_start_str = input().split() products_end_str = input().split() products_start = [element_to_value[elem] for elem in products_start_str] products_end = [element_to_value[elem] for elem in products_end_str] products_start.sort() ingredient_value = [] ingredient_count = [] for (key, lst) in itertools.groupby(products_start): ingredient_value.append(key) ingredient_count.append(len(list(lst))) nr_ingredients = len(ingredient_value) construction_options = [[] for i in range(k)] for combination in itertools.product(*[range(l+1) for l in ingredient_count]): value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients)) if (value in products_end): for i in range(k): if products_end[i] == value: construction_options[i].append(combination) solution = [None for i in range(k)] def find_solution(used = [0 for i in range(nr_ingredients)], next = 0): if (next == k): return all(used[i] == ingredient_count[i] for i in",np,"['bitmasks', 'dp']",1999
"n, k, A = map(int, input().rstrip().split()) senators = [] mx_bribe = 0 for i in range(n): lvl, loy = map(int, input().rstrip().split()) senators.append((lvl, loy)) mx_bribe += (100 - loy) // 10 bribe = [0] * n def calc(votes): bsum, cnt, p = 0, 0, 1.0 for i, s in enumerate(senators): if votes & (1 << i): p *= (s[1] + bribe[i]) / 100 cnt += 1 else: p *= (100 - s[1] - bribe[i]) / 100 bsum += s[0] if cnt > (n / 2): return p else: return p * A / (A + bsum) def dfs(cur, rk): if cur >= n: if rk > 0: return 0.0 sm = 0.0 for i in range(1 << n): sm += calc(i) return sm mx = 0.0 for i in range(rk + 1): if i * 10 + senators[cur][1] > 100: break bribe[cur] = i * 10 tmp = dfs(cur+1, rk-i) mx = max(tmp, mx) return mx print(dfs(0, min(k, mx_bribe)))",np,"['brute force', 'probabilities']",745
"import sys,io,os,math try:yash=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline except:yash=lambda:sys.stdin.readline().encode() I=lambda:[*map(int,yash().split())] import __pypy__;an=__pypy__.builders.StringBuilder() n,=I();lis=I();N=22;dp=[-1]*(1<<22) for i in range(n): dp[lis[i]]=lis[i] for j in range(22): lis[i]^=(1<<j) for mask in range(1<<22): for i in range(22): if (mask&(1<<i)) and dp[mask^(1<<i)]!=-1:dp[mask]=dp[mask^(1<<i)] for num in lis: an.append(""%s ""%(dp[num])) an.append(""\n"") os.write(1, an.build().encode())",np,"['bitmasks', 'brute force', 'dfs and similar', 'dp']",532
"import sys,os,io from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") maxbits = 22 maxmask = 1<<maxbits dp = [-1]*(maxmask) n = int(input()) a = [int(x) for x in input().split()] b = a[:] P = [0]*n for i in a: dp[i]=i for exp in range(maxbits): for i in range(maxmask): if i&(1<<exp): if dp[i]==-1: dp[i]=dp[i-(1<<exp)] for i in range(n): maxx = maxmask-1 print(dp[maxx^a[i]],end="" "")",np,"['bitmasks', 'brute force', 'dfs and similar', 'dp']",1707
"from collections import defaultdict, Counter,deque from math import sqrt, log10, log, floor, factorial,gcd from bisect import bisect_left, bisect_right from itertools import permutations,combinations import sys, io, os input = sys.stdin.readline input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline inf = float('inf') mod = 10 ** 9 + 7 def yn(a): print(""YES"" if a else ""NO"") ceil = lambda a, b: (a + b - 1) // b lim=22 po=[1<<j for j in range(lim+1)] maxbits=lim masks=po[lim] dp=[-1]*masks t=1 for i in range(1): n=int(input()) l=[int(i) for i in input().split()] for i in l: dp[i]=i for i in range(masks): for j in range(maxbits): if dp[i]==-1 and i&(1<<j): dp[i]=dp[i-(1<<j)] ans=[dp[i^(masks-1)] for i in l] print(*ans)",np,"['bitmasks', 'brute force', 'dfs and similar', 'dp']",728
"from collections import defaultdict, Counter,deque from math import sqrt, log10, log, floor, factorial,gcd from bisect import bisect_left, bisect_right from itertools import permutations,combinations import sys, io, os input = sys.stdin.readline input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline inf = float('inf') mod = 10 ** 9 + 7 def yn(a): print(""YES"" if a else ""NO"") ceil = lambda a, b: (a + b - 1) // b lim=22 po=[1<<j for j in range(lim+1)] maxbits=lim masks=po[lim] dp=[-1]*masks t=1 for i in range(1): n=int(input()) l=[int(i) for i in input().split()] for i in l: dp[i]=i for i in range(masks): for j in range(maxbits): if dp[i]==-1 and i&po[j]: dp[i]=dp[i-po[j]] ans=[dp[i^(masks-1)] for i in l] print(*ans)",np,"['bitmasks', 'brute force', 'dfs and similar', 'dp']",726
"from collections import defaultdict, Counter,deque from math import sqrt, log10, log, floor, factorial,gcd from bisect import bisect_left, bisect_right from itertools import permutations,combinations import sys, io, os input = sys.stdin.readline inf = float('inf') mod = 10 ** 9 + 7 def yn(a): print(""YES"" if a else ""NO"") ceil = lambda a, b: (a + b - 1) // b import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class masks: def all_masks_sos(self,arr,lim=22): lim = 22 maxbits = lim self.masks=masks = 1 << lim self.dp = [-1] * masks for i in arr: self.dp[i] = i for i in range(masks): for j in range(maxbits): if self.dp[i] == -1 and i & (1 << j): self.d",np,"['bitmasks', 'brute force', 'dfs and similar', 'dp']",2000
"import math res = [0, 1, 0, 3, 0, 15, 0, 133, 0, 2025, 0, 37851, 0, 1030367, 0, 36362925, 0] n = int(input()) print(res[n] * math.factorial(n) % (10 ** 9 + 7))",np,"['bitmasks', 'combinatorics', 'dp', 'implementation', 'meet-in-the-middle']",159
"n = int(input()) ans = [1, 3, 5, 7, 9, 11, 13, 15] dct = \ { 1 : 1, 3 : 18, 5 : 1800, 7 : 670320, 9 : 734832000, 11 : 890786230, 13 : 695720788, 15 : 150347555 } if n in ans: print(dct[n]) else: print(0)",np,"['bitmasks', 'combinatorics', 'dp', 'implementation', 'meet-in-the-middle']",203
"import math ans = [1, 3, 15, 133, 2025, 37851, 1030367, 36362925] n = int(input()) if (n % 2 == 1): print(ans[n // 2] * math.factorial(n) % 1000000007) else: print(0)",np,"['bitmasks', 'combinatorics', 'dp', 'implementation', 'meet-in-the-middle']",166
"n = int(input()) a = list(map(int,input().split())) mod = 10**9+7 b = [0 for i in range(1<<20)] for i in range(n): b[a[i]] += 1 for i in range(20): for j in range(1<<20): if j&1<<i == 0: b[j] += b[j|1<<i] ans = 0 for i in range(1<<20): cnt = str(bin(i)).count(""1"") if cnt%2 == 0: ans += pow(2,b[i],mod)-1 else: ans -= pow(2,b[i],mod)-1 ans %= mod print(ans)",np,"['bitmasks', 'combinatorics', 'dp']",357
"import sys input = lambda : sys.stdin.readline().rstrip() sys.setrecursionlimit(2*10**5+10) write = lambda x: sys.stdout.write(x+""\n"") debug = lambda x: sys.stderr.write(x+""\n"") writef = lambda x: print(""{:.12f}"".format(x)) def zeta_super(val, n): out = val[:] for i in range(n): for j in range(1<<n): if not j>>i&1: out[j] += out[j^(1<<i)] return out n = int(input()) a = list(map(int, input().split())) m = max(a).bit_length() M = 10**9+7 v = [0]*(1<<m) for item in a: v[item] += 1 v2 = [1] for i in range(n+1): v2.append(v2[-1]*2%M) nv = zeta_super(v, m) ans = 0 for b in range(1<<m): ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(""1"")) ans %= M print(ans%M)",np,"['bitmasks', 'combinatorics', 'dp']",657
"import sys def I(): return int(sys.stdin.readline().rstrip()) def MI(): return map(int,sys.stdin.readline().rstrip().split()) def LI(): return list(map(int,sys.stdin.readline().rstrip().split())) def LI2(): return list(map(int,sys.stdin.readline().rstrip())) def S(): return sys.stdin.readline().rstrip() def LS(): return list(sys.stdin.readline().rstrip().split()) def LS2(): return list(sys.stdin.readline().rstrip()) N = I() A = LI() mod = 10**9+7 m = 20 M = 1 << m F = [0]*M for a in A: F[a] += 1 def zeta_transform(F,n): N = 1 << n res = F[:] for i in range(n): k = 1 << i for j in range(N): if not j & k: res[j] += res[j^k] return res G = zeta_transform(F,m) power = [1] for _ in range(N): power.append((power[-1]*2) % mod) def bit_count(n): c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555) c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333) c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f) c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff) c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff) c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff) return c ans = 0 for i in range(M): bc = bit_count(i) a = power[G[i]] if bc % 2 == 0: ans += a else: ans -= a ans %= mod print(ans)",np,"['bitmasks', 'combinatorics', 'dp']",1259
"import sys readline = sys.stdin.readline def gcd(a, b): while b: a, b = b, a%b return a def prsh(N): prime = [2] for L in range(3,N): for p in prime: if not L % p: break if p > L**(1/2): prime.append(L) break return prime limit = 59 prime = prsh(limit+1) C = set([tuple()]) Cp = [] for i in range(2, limit+1): if i >= 30 and i in prime: Cp.append(i) continue for k in C.copy(): if all(gcd(ki, i) == 1 for ki in k): kn = tuple(list(k) + [i]) C.add(kn) INF = 10**9+7 N = int(readline()) A = list(map(int, readline().split())) Ao = A[:] A.sort() ans = INF Ans = None for ci in C: tc = [1]*(N-len(ci)) + list(ci) + Cp for j in range(8): res = 0 for a, t in zip(A, tc[j:]): res += abs(a-t) if ans > res: ans = res Ans = tc[j:j+N] buc = [[] for _ in range(limit+1)] for a, an in zip(A, Ans): buc[a].append(an) AA = [] for ao in Ao: AA.append(buc[ao].pop()) print(*AA)",np,"['bitmasks', 'brute force', 'dp']",861
"import itertools kol1 = {'+': 0, '-': 0, '?': 0} kol2 = {'+': 0, '-': 0, '?': 0} s1 = input() s2 = input() for s in s1: kol1[s] += 1 for s in s2: kol2[s] += 1 if (kol1['+']==kol2['+'] and kol1['-']==kol2['-']): print('1.0') exit() mod1 = kol1['+'] - kol1['-'] mod2 = kol2['+'] - kol2['-'] mod3 = abs(mod2-mod1) if (mod3>kol2['?']): print(0.0) exit() list_comb = [1, -1] sum_pos = 0 col = 0 for comb in itertools.product(list_comb, repeat=kol2['?']): if sum(comb)==mod3: sum_pos += 1 col+=1 print(sum_pos/col)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",508
"def factorial(n): result = 1 for i in range(2, n+1): result *= i return result commands = input().strip() received = input().strip() n = len(commands) positive = 0 negative = 0 count = 0 for i in range(n): if commands[i] == ""+"": positive += 1 else: negative += 1 if received[i] == ""+"": positive -= 1 elif received[i] == ""-"": negative -= 1 else: count += 1 cases = 2**count probability = 0.0 if positive >= 0 and negative >= 0: probability = (factorial(count)/(factorial(positive)*factorial(negative)))/cases print(""{0:.9f}"".format(probability))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",544
"s1 = input() s2 = input() objetivo = s1.count(""+"") - s1.count(""-"") inicio = s2.count(""+"") - s2.count(""-"") incognitos = s2.count(""?"") distancia = objetivo - inicio def factorial(n): total = 1 for i in range(int(n)): total *= (i + 1) return total if abs(distancia) > incognitos or distancia % 2 != incognitos % 2: print(0) else: mas = (distancia + incognitos) / 2 menos = (incognitos - distancia) / 2 print((factorial(incognitos)/(factorial(mas)*factorial(menos)))/2**incognitos)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",477
"s = input() trgt = 0 for c in s: trgt += (1 if c == '+' else -1) cmd = input() queue = [[0, 0]] dests = [] while queue: nextqueue = [] for pos, cmdi in queue: if cmdi == len(cmd): dests.append(pos) continue nextcmd = cmd[cmdi] if nextcmd == '+': nextqueue.append([pos+1, cmdi+1]) elif nextcmd == '-': nextqueue.append([pos-1, cmdi+1]) else: nextqueue.append([pos + 1, cmdi + 1]) nextqueue.append([pos - 1, cmdi + 1]) queue = nextqueue occurs = 0 for x in dests: if x == trgt: occurs+=1 print(occurs / len(dests))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",512
from math import factorial drazil = input() dreamoon = input() net_drazil = 0 net_dreamoon = 0 uncretain_count = 0 for i in drazil: if i == '-': net_drazil -= 1 else: net_drazil += 1 for i in dreamoon: if i == '-': net_dreamoon -= 1 elif i == '+': net_dreamoon += 1 else: uncretain_count += 1 x = (uncretain_count + (net_drazil - net_dreamoon)) // 2 y = (uncretain_count - (net_drazil - net_dreamoon)) // 2 if abs(x) + abs(y) != uncretain_count: print(0.0) else: out = factorial(uncretain_count)//(factorial(x)*factorial(uncretain_count-x)) print(out/2**uncretain_count),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",570
"import math sone= list(input()) stwo = list(input()) sum1=0 sum2=0 m=0 for i in range(len(sone)): if sone[i]=='+': sum1=sum1 + 1 m=m+1 else: sum1=sum1 - 1 k=0 for i in range(len(stwo)): if stwo[i]=='+': sum2=sum2 + 1 k=k elif stwo[i]=='-': sum2=sum2 - 1 k=k elif stwo[i]=='?': k=k+1 n=0 if (k-(abs(sum1-sum2)))<0: print(float (0)) elif (k-(abs(sum1-sum2)))==0: if k==0: print(float (1)) else: print(float (pow(0.5,k))) else: n=k-(abs(sum1-sum2)) n=abs(sum1-sum2)+n/2 if abs(sum1-sum2)==0: print(float ((math.factorial(k)/(math.factorial(k/2)*math.factorial(k/2))) * pow(0.5,k))) else: print(float ((math.factorial(k)/(math.factorial(k-n) * math.factorial(n))) * pow(0.5,k)))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",674
"import math def binom(n, m): return math.factorial(n)//(math.factorial(m)*math.factorial(n-m)) correct = input() received = input() plus_correct = correct.count('+') min_correct = correct.count('-') pos_correct = plus_correct - min_correct plus_received = received.count('+') min_received = received.count('-') unknown = received.count('?') pos_received = plus_received - min_received diff = abs(pos_correct - pos_received) if (diff + unknown) % 2 != 0 or diff > unknown: prob = 0.0 else: m = (diff + unknown) // 2 prob = 1.0 * binom(unknown, m) / (2 ** unknown) print(prob)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",574
"import math a = str(input()) b = str(input()) posa = a.count('+') - a.count('-') posb = b.count('+') - b.count('-') q = b.count('?') dist = (posa - posb) ones = (abs(dist) + q) / 2 if q < abs(dist) or ((dist+q) % 2): ans = 0 else: ans = float(math.factorial(q)/(math.factorial(ones)*math.factorial(q-ones))) ans /= pow(2, q) print(f'{ans:.9f}')",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",344
from math import factorial s=input() s1=input() plus=s.count('+')-s1.count('+') minus=s.count('-')-s1.count('-') n=s1.count('?') if plus<0 or minus<0: print(0) else: print((factorial(n)/factorial(n-plus)/factorial(plus))*(0.5**n)),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",230
"from math import factorial a = input() b = input() plus, minus, ques = '+', '-', '?' ops1 = {plus:0, minus:0} ops2 = {plus:0, minus:0, ques:0} for ai,bi in zip(a,b): ops1[ai] += 1 ops2[bi] += 1 final_pos = ops1[plus]-ops1[minus] initial_pos = ops2[plus]-ops2[minus] diff = final_pos-initial_pos abs_diff = abs(diff) if abs_diff > ops2[ques]: print(0.0) elif (ops2[ques]-abs_diff) % 2 != 0: print(0.0) else: total = 2**(ops2[ques]) one_type = (ops2[ques]-abs_diff) // 2 other_type = abs_diff + one_type numerator = factorial(ops2[ques])/(factorial(one_type)*factorial(other_type)) print(numerator/total)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",602
"from math import factorial as fc def per(a,b): return fc(a+b)/(fc(a)*fc(b)) import sys s=input() s1=input() x=s.count(""+"") y=s.count(""-"") x1=s1.count(""+"") y1=s1.count(""-"") p=x-y p1=x1-y1 q=s1.count(""?"") dif=p-p1 if q<abs(p1-p) or dif>q: print(0.0) sys.exit() m=abs(y-y1) pl=abs(x-x1) print(per(m,pl)/(2**(m+pl)))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",312
import math def main(): x = input() y = input() goal = x.count('+') - y.count('+') options = y.count('?') if options == 0: if goal == options: print(1) else: print(0) else: if (goal > options): print(0) else: if goal < 0: print(0) else: print(math.factorial(options)/math.factorial(goal)/math.factorial(options-goal)/(2**options)) main(),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",337
"import math inp = input().strip() dec = input().strip() inp_dict = {""+"":0,""-"":0} dec_dict = {""+"":0,""-"":0,""?"":0} for i in range(len(inp)): if inp[i]==""+"": inp_dict[""+""] += 1 elif inp[i]==""-"": inp_dict[""-""] += 1 for i in range(len(dec)): if dec[i]==""+"": dec_dict[""+""] += 1 elif dec[i]==""-"": dec_dict[""-""] += 1 elif dec[i] == ""?"": dec_dict[""?""] += 1 if(dec_dict[""+""] == inp_dict[""+""] and dec_dict[""-""] == inp_dict[""-""]): print(1.0000000000) else: temp = inp_dict[""+""] - dec_dict[""+""] temp1 = inp_dict[""-""] - dec_dict[""-""] if temp + temp1 == dec_dict[""?""] and temp>=0 and temp1 >= 0: temp2 = math.factorial(temp+temp1)/(math.factorial(temp)*math.factorial(temp1)) for i in range(temp1+temp): temp2 = temp2 * 0.5 print(temp2) else: print(0.000000000)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",745
from math import factorial s1=input() s2=input() n=0 x1=0 for i in range(len(s1)): if s1[i]=='+': x1+=1 else: x1-=1 x2=0 for i in range(len(s2)): if s2[i]=='+': x2+=1 elif s2[i]=='?': n+=1 else: x2-=1 x=abs(x1-x2) if x>n: print(0) elif x==n: print(1/2**n) else: if (n-x)%2==1: print(0) else: print((factorial(n)//(factorial((n-x)//2)*factorial(n-(n-x)//2)))/2**n),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",363
from math import factorial as fact s=input() t=input() pos=s.count('+')-t.count('+') neg=s.count('-')-t.count('-') que=t.count('?') if pos<0 or neg<0: print(0) else: print((fact(que)/(fact(pos)*fact(neg)))/(2**que)),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",215
"import math from math import factorial def combination(n,r): return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r)) a = input() ap = a.count('+') am = a.count('-') b = input() bp = b.count('+') bm = b.count('-') n = b.count('?') x = float(ap - bp) y = float(am - bm) if (x < 0 or y < 0 or x+y != n): print(0.0) else: print(combination(n,x)/(1<<n))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",365
"import math a=input() b=input() c=int(0) d=int(0) q=int(0) for i in range(len(a)): if a[i]==""+"": c+=1 elif a[i]==""-"": c-=1 for i in range(len(b)): if b[i]==""+"": d+=1 elif b[i]==""-"": d-=1 else: q+=1 if c == d: print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q)) else: mx=d+q mn=d-q if c>mx or c<mn: print(0.0) else: ans=c-d if ans > 0: print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q)) else: print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",552
"import math from math import factorial def combination(n,r): return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r)) a = input() ap = a.count('+') am = a.count('-') b = input() bp = b.count('+') bm = b.count('-') n = b.count('?') x = float(ap - bp) y = float(am - bm) if (x < 0 or y < 0 or x+y != n): print(0.0) else: print(combination(n,x)/(1<<n))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",365
"import math a=input() b=input() c=int(0) d=int(0) q=int(0) for i in range(len(a)): if a[i]==""+"": c+=1 elif a[i]==""-"": c-=1 for i in range(len(b)): if b[i]==""+"": d+=1 elif b[i]==""-"": d-=1 else: q+=1 if c == d: print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q)) else: mx=d+q mn=d-q if c>mx or c<mn: print(0.0) else: ans=c-d if ans > 0: print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q)) else: print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",552
"import math s1=list(input()) s2=list(input()) p1,m1,p2,m2,c=0,0,0,0,0 for i in range(len(s1)): if(s1[i]=='+'): p1+=1 if(s1[i]=='-'): m1+=1 if(s2[i]=='+'): p2+=1 if(s2[i]=='-'): m2+=1 if(s2[i]=='?'): c+=1 p=abs(p1-p2) m=abs(m1-m2) if((p+m)==c): print(math.factorial(c)/(math.factorial(p)*math.factorial(m)*pow(2,c))) else: print(0/1)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",332
actual = input() processed = input() def factorial(num: int): res = 1 while num >= 1: res *= num num -= 1 return res actualPos = actual.count('+') actualNeg = actual.count('-') processedPos = processed.count('+') processedNeg = processed.count('-') if processedPos > actualPos or processedNeg > actualNeg: print(0) elif processedPos == actualPos and processedNeg == actualNeg: print(1) else: remainPos = actualPos - processedPos remainNeg = actualNeg - processedNeg print((factorial(remainPos + remainNeg) / (factorial(remainPos) * factorial(remainNeg))) / 2 ** ( remainPos + remainNeg)),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",587
"import math import sys from bisect import bisect_right, bisect_left, insort_right from collections import Counter, defaultdict from heapq import heappop, heappush from itertools import accumulate from sys import stdout R = lambda: map(int, input().split()) t = input() s = input() k = t.count('+') - s.count('+') n = s.count('?') if k > n or k < 0: print('0.0') else: print(math.factorial(n) / (math.factorial(k) * math.factorial(n - k)) / 2**n)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",445
"from math import factorial from decimal import * A=input() B=input() a=0 cnt2=0 cnt1=0 b=0 for i in A: if i=='+': a+=1 cnt1+=1 else: a-=1 cnt2+=1 cnt3=0 cnt=0 cnt4=0 for i in B: if i=='+': b+=1 cnt3+=1 elif i=='-': b-=1 cnt4+=1 else: cnt+=1 if cnt3>cnt1 or cnt4>cnt2: print(format(0,'.12f')) else: No_of_plus=cnt1-cnt3 No_of_minus=cnt2-cnt4 Total_cases=2**cnt Total_No_of_favourable_cases=factorial(cnt)//(factorial(No_of_plus)*factorial(No_of_minus)) print(format(Decimal(Total_No_of_favourable_cases)/Decimal(Total_cases), '.12f'))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",533
"import math s=input() p=input() c=1 ss=0 ps=0 k=0 for i in range(len(s)): if(p[i]=='?'): c*=2 k+=1 if(s[i]=='+'): ss+=1 else: ss-=1 if(p[i]=='+'): ps+=1 elif p[i]=='-': ps-=1 y=math.fabs(ss-ps) x=k-y a=y+x/2 b=k-a if k<y: ans=0.000000000 else: ans=math.factorial(a+b)/(math.factorial(a)*math.factorial(b)) ans/=c print(""%.12f""%ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",331
"def factorial(n) : ans = 1 if (n == 0) : return 1 for i in range(1, n + 1) : ans *= i return ans def ncr(n , r) : n = abs(n) if r > n : return 0 ans = factorial(n) ans = ans//(factorial(n-r)) ans = ans//(factorial(r)) return ans if __name__ == ""__main__"" : A = input() B = input() QMarks = B.count('?') TotalA = A.count('+') - A.count('-') TotalB = B.count('+') - B.count('-') denominator = 2**QMarks if QMarks < abs(TotalA - TotalB) : print(0) else : x = (QMarks - abs(TotalA - TotalB))//2 x += abs(TotalA - TotalB) num = ncr(QMarks,x) print(num/denominator)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",559
"from math import factorial as f n = input() s = input() quest = s.count(""?"") plusn = n.count(""+"") plus = s.count(""+"") try: comb = f(quest)/(f(plusn - plus) * f(quest - (plusn - plus))) print(""%.12f"" %(comb/2 ** quest)) except: print(""%.12f"" %0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",244
"from collections import Counter import math l=list(input()) l1=list(input()) a=Counter(l) b=Counter(l1) if a['+']<b['+'] or a['-']<b['-']: print(""0"") exit() else: a1=a['+']-b['+'] b1=a['-']-b['-'] s=(math.factorial(a1+b1))//((math.factorial(a1))*(math.factorial(b1))) s1=float(2**(a1+b1)) print(s/s1)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",300
import math s = input() s1 = input() plus=s.count('+')-s1.count('+') minus=s.count('-')-s1.count('-') v = s1.count('?') if plus<0 or minus<0: print(0) exit() print((math.factorial(v)/math.factorial(v-plus)/math.factorial(plus))*(0.5**v)),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",237
"list1=list(input()) list2=list(input()) plus1=list1.count('+') plus2=list2.count('+') minus1=list1.count('-') minus2=list2.count('-') wths=list2.count('?') def giveFactorial(n,x): if x==0 or x==n or x>n or n==0: return 1 else: return giveFactorial(n-1,x-1)+giveFactorial(n-1,x) a=(giveFactorial(wths,plus1-plus2)) if plus1==plus2 and wths==0: print(1) elif wths==0 : print(0) elif plus1-plus2>wths or minus1-minus2>wths: print(0) else: print((0.5**(plus1-plus2+minus1-minus2))*a)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",479
"from math import factorial as fact s1 = input() s2 = input() plus1 = s1.count(""+"") minus1 = s1.count(""-"") plus2 = s2.count(""+"") minus2 = s2.count(""-"") qCount = s2.count(""?"") if(plus1==plus2 and minus1==minus2): print(1) else: plusReq = plus1 - plus2 minusReq = minus1 - minus2 if(plusReq >= 0 and minusReq >= 0): ans = (0.5**qCount)*fact(qCount)/(fact(plusReq)*fact(minusReq)) print(ans) else: print(0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",402
"import math def c(k, n): return math.factorial(n) // (math.factorial(k) * math.factorial(n - k)) def main(): sent = input() received = input() difference = abs((sent.count('+') - sent.count('-')) - (received.count('+') - received.count('-'))) unrecognized = received.count('?') if difference > unrecognized: print(0) return k = (unrecognized - difference) // 2 answer = c(k, unrecognized) * 0.5**unrecognized print(answer) if __name__ == '__main__': main()",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",456
"line1 = str(input()); line2 = str(input()); truePosition = 0; fakePosition = 0; questionMarks = 0; for i in range(len(line1)): if line1[i] == ""+"": truePosition += 1; if line1[i] == ""-"": truePosition -= 1; if line2[i] == ""+"": fakePosition += 1; if line2[i] == ""-"": fakePosition -= 1; if line2[i] == ""?"": questionMarks += 1; distanceToMove = abs(truePosition - fakePosition); def factorial(x): if x == 0: return 1; else: return x * factorial(x-1); def probToMove(dist, questionMarks): if(dist > questionMarks): return float(0); reducedDist = questionMarks - dist; if(reducedDist % 2 != 0): return float(0); dist = reducedDist//2 + dist; headsFlips = 1; headsOrders = factorial(questionMarks) / ((factorial(dist) *factorial(questionMarks-dist))); totalPossibilities = 2**questionMarks; return headsFlips * headsOrders / totalPossibilities; print(probToMove(distanceToMove, questionMarks));",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",886
from math import factorial as fact a = input() b = input() aplus = a.count('+') aminus = len(a) - aplus bplus = b.count('+') bminus = b.count('-') bjolly = len(b) - bplus - bminus if bplus > aplus or bminus > aminus: print(0) else: c = aplus-bplus res = fact(bjolly) / fact(bjolly-c) / fact(c) / 2**bjolly print(res),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",316
from math import factorial s=input().rstrip() s1=input().rstrip() pos1=0 pos=0 posi=0 negi=0 posi1=0 negi1=0 ques1=0 for i in s: if i=='+': pos+=1 posi+=1 else: pos-=1 negi+=1 for i in s1: if i=='+': posi1+=1 elif i=='-': negi1+=1 else: ques1+=1 if posi==posi1 and negi==negi1: print(1) exit() diff1=posi-posi1 diff=negi-negi1 if diff<0 or diff1<0: print(0) else: outcomes=2**ques1 nume=factorial(ques1) deno=factorial(ques1-diff1)*factorial(diff1) fav1=nume/deno ques1=ques1-diff1 num1=factorial(ques1) deno1=factorial(ques1-diff)*factorial(diff) fav2=num1/deno1 ans=fav1*fav2 print(ans/outcomes),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",597
"from math import factorial s = input().strip() new = input().strip() questions = 0 plus = s.count('+') minus = s.count('-') for i in new: if i == '+': plus -= 1 elif i == '-': minus -= 1 else: questions += 1 if plus < 0 or minus < 0: print(0) else: num = factorial(questions)/(factorial(plus)*factorial(minus)) den = 2**questions print(""{0:.10f}"".format(num/den))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",363
"import math a = input() b = input() sa = a.count(""+"") ta = a.count(""-"") sb = b.count(""+"") tb = b.count(""-"") x = b.count(""?"") s=abs(sa-sb) t=abs(ta-tb) su = math.factorial(s+t) re = math.factorial(s) sa = math.factorial(t) result = su/(re*sa) if s+t <= x: print(float(result)/float((2**x))) else: print(0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",304
"import math def nCr(n,r): f = math.factorial return f(n) / f(r) / f(n-r) dict1 = {'+':0,'-':0,'?':0} for i in input(): dict1[i]+=1 for i in input(): if(i=='?'): dict1[i]+=1 else: dict1[i]-=1 if dict1['+']<0 or dict1['-']<0: print(0.000000000000) elif dict1['+']==0 and dict1['-']==0: print(1.000000000000) elif dict1['+'] and dict1['-']: ans = (nCr(dict1['?'], dict1['+'])/(2**dict1['?'])) print(""%.12f"" %ans) else: ans = (1 / (2 ** dict1['?'])) print(""%.12f"" % ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",466
"from math import factorial s1 = input() s2 = input() finPos=0 for c in s1: if c=='+': finPos+=1 else: finPos-=1 stPos=0 for c in s2: if c=='+': stPos+=1 elif c=='-': stPos-=1 n=s2.count('?') diff=abs(finPos-stPos) if diff > n: print(0) elif n&1 != diff&1: print(0) else: i=0 for i in range(n//2,n): if i*2-n == diff: break if i*2-n != diff: i+=1 print((factorial(n)/(factorial(n-i)*factorial(i)))/(1<<n))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",404
import math a=input() b=input() x1=a.count('+') y1=a.count('-') x2=b.count('+') y2=b.count('-') l=b.count('?') if l==0 and(x1==x2 and y1==y2): print(float(1)) elif x1>(x2+l) or y1>(y2+l): print(float(0)) else: w=math.factorial(l) m=math.factorial(x1-x2) n=math.factorial(l-(x1-x2)) print((w/(m*n)) /2**(x1+y1-x2-y2)),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",316
"a = input() b = input() l = a.count(""+"")-a.count(""-"") k = b.count(""?"") if k==0: if (b.count(""+"")-b.count(""-""))==l: print(1) else: print(0) else: n=2**k r=k c=[] t=0 while r>=0: c.append(r-t) t+=1 r-=1 import math d=[] for i in range(k+1): d.append((math.factorial(k))//(math.factorial(i)*math.factorial(k-i))) f = b.count(""+"")-b.count(""-"") if l-f in c: print((d[c.index(l-f)])/sum(d)) else: print(0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",399
"from math import factorial,pow send = input() received = input() pos = 0 for p in send: pos = pos +1 if p=='+' else pos-1 qcount = 0 curr_pos = 0 for p in received: if p=='+': curr_pos = curr_pos +1 elif(p=='-'): curr_pos = curr_pos-1 if p=='?': qcount +=1 if qcount == 0: print(""{:.12f}"".format(1.0 if pos==curr_pos else 0.0)) else: exp_val_q = abs(pos -curr_pos) if exp_val_q%2!=qcount%2 or qcount<exp_val_q: print(""{:.12f}"".format(0.0)) else: neg = (qcount - exp_val_q)/2 posi = qcount - neg val = factorial(qcount)/(factorial(neg)*factorial(posi)*pow(2,qcount)) print(""{:.12f}"".format(val))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",594
"from math import factorial f=lambda:input() a=f() b=f() s=0 s1=0 c=0 for i in a: if i=='+': s+=1 else: s-=1 for i in b: if i=='+': s1+=1 elif i=='-': s1-=1 else: c+=1 if c==0: if s==s1: print(c+1) else: print(c) else: l=[] k=c i=c j=0 while i>=0: l.append(k) i-=1 j+=1 k=0 k+=i k-=j if s1!=0: for i in range(len(l)): l[i]+=s1 try: c1=l.index(s) k=factorial(c)/(factorial(c-c1)*factorial(c1)) print(k/pow(2,c)) except: print(0.0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",428
"import math s1 = input() s2 = input() x = 0 y = 0 p = 0 for i in range(len(s1)): if s1[i] == '+': x+=1 elif s1[i] == '-': y+=1 if s2[i] == '+': x-=1 elif s2[i] == '-': y-=1 else: p+=1 if x<0 or y<0: print(float(0)) else: q = math.factorial(x+y)/(math.factorial(x)*math.factorial(y)) r = q/math.pow(2,p) print(r)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",311
"from math import factorial, pow def wifi(s1, s2): count1, count2, count3 = 0, 0, 0 for i in range(len(s1)): if s1[i] == '+': count1 += 1 elif s1[i] == '-': count2 += 1 if s2[i] == ""+"": count1 -= 1 elif s2[i] == '-': count2 -= 1 else: count3 += 1 if count1 < 0 or count2 < 0: return '{:.9f}'.format(0) q = factorial(count1 + count2) / (factorial(count1) * factorial(count2)) r = q / pow(2, count3) return r t1 = input() t2 = input() print(wifi(t1, t2))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",451
import math sent = input() received = input() sp = sent.count('+') sm = sent.count('-') rp = received.count('+') rm = received.count('-') quest = received.count('?') dist = sp - rp if dist < 0 or dist > quest: print(0) elif dist == 0 and quest == 0: print(1) else: total = 2 ** quest possible = math.factorial(quest) / math.factorial(dist) / math.factorial(quest-dist) print(possible/total),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",390
"from math import factorial def calc_arrangement(n, m): return(factorial(n) / factorial(n - m)) def calc_combination(n, m): return(calc_arrangement(n, m) / factorial(m)) str1 = list(input()) str2 = list(input()) n = 0 diff = 0 for i in range(len(str1)): if str1[i] == '+': diff += 1 else: diff -= 1 if str2[i] == '+': diff -= 1 elif str2[i] == '-': diff += 1 else: n += 1 if n == 0: if diff == 0: print(1.0) else: print(0.0) elif n < abs(diff): print(0.0) else: res = calc_combination(n, (n - diff) / 2) * (0.5 ** n) print(res)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",526
"from collections import Counter import math i1 = list(input()) i2 = list(input()) a = Counter(i1) b = Counter(i2) c = b-a d = a-b c1 = list(c.elements()) d1 = list(d.elements()) count = 0 for i in c1: if i == ""?"": count = count+1 if count != len(d1): print(0) else: x = len(c1) that = 0 for i in d1: if i == ""+"": that = that + 1 out = math.factorial(x)/((math.factorial(that))*math.factorial(x-that)) print(out/math.pow(2,x))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",425
"import math def factorial(num): if num == 1: return num else: return num * factorial(num - 1) s1=input() s2=input() ans=0 for i in range(0,len(s1)): if(s1[i]=='+'): ans+=1 else: ans-=1 t=0 qm=0 for i in range(0,len(s2)): if(s2[i]=='+'): t+=1 elif(s2[i]=='-'): t-=1 else: qm+=1 if(qm==0): if(ans==t): print(1.000000000000) else: print(0.000000000000) else: k=ans-t if(abs(k)==qm): na=1/pow(2,qm) print(na) elif(abs(k)>qm): print(0.000000000000) else: if(k%2==0 and qm%2==1): print(0.000000000000) elif(k%2==1 and qm%2==0): print(0.000000000000) else: a=abs((qm+k)/2) b=abs((qm-k)/2) nu=factorial(qm)/(factorial(a)*factorial(b)) ans=nu/(pow(2,qm)) print(ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",656
"from math import factorial def C(m,n): return factorial(n) // (factorial(m) * factorial(n - m)) command_1, command_2 = input(), input() num = command_2.count('?') i = command_1.count('+') - command_1.count('-') -\ command_2.count('+') + command_2.count('-') + num if i % 2 == 0 and 0 <= i//2 <= num: print(""%.9f""%(C(i//2, num) / 2**num)) else: print(""0.000000000"")",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",364
"def factorial(n): r = 1 for i in range(2, n + 1): r *= i return r def n_choose_k(n, k): return factorial(n) // (factorial(k) * factorial(n - k)) def solve(diff, u): pluses = u + 1 n = 2 ** u for i in range(unknown, -unknown - 1, -2): pluses -= 1 if diff == i: k = n_choose_k(u, pluses) return k / n return 0 s1 = input() s2 = input() k = 0 correct_p = 0 pred_p = 0 unknown = 0 for c in s1: correct_p += 1 if c == '+' else -1 for c in s2: if c in '+-': pred_p += 1 if c == '+' else -1 else: unknown += 1 p = 1 if unknown == 0 and correct_p == pred_p else solve(correct_p - pred_p, unknown) print('{0:.9f}'.format(p))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",615
"import math s = input() t = input() p1, p2, m1, m2, q = 0, 0, 0, 0, 0 for i in s: if i == '+': p1 += 1 else: m1 += 1 for i in t: if i == '+': p2 += 1 elif i == '-': m2 += 1 else: q += 1 dp, dm = p1 - p2, m1 - m2 if dp < 0 or dm < 0: print(0.0) else: ans = (math.factorial(q) / (math.factorial(dp) * math.factorial(dm))) / math.pow(2, q) print(ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",347
"import math s1=input() s2=input() s1p=s1.count(""+"") s1m=s1.count(""-"") s2p=s2.count(""+"") s2m=s2.count(""-"") s2q=0 if '?' in s2: s2q=s2.count(""?"") if s2q==0: if s1p==s2p and s1m==s2m: print(""%.12f""%1) else: print(""%.12f""%0) else: if s1p>=s2p and s1m>=s2m: s2q=math.factorial(s2q)/(math.factorial(s1p-s2p)*math.factorial(s1m-s2m)) print(""%.12f""%(s2q/(2**s2.count(""?"")))) else: print(""%.12f""%0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",389
"from math import factorial,pow s1=list(input()) s2=list(input()) S1={""+"":0, ""-"":0} S2={""+"":0, ""-"":0, ""?"":0} for i in s1: S1[i]+=1 for i in s2: S2[i]+=1 if S1[""+""]-S2[""+""]>=0 and S1[""-""]-S2[""-""]>=0: pos=S1[""+""]-S2[""+""] neg=S1[""-""]-S2[""-""] ques=S2[""?""] res=(factorial(pos+neg)/(factorial(pos)*factorial(neg)))/pow(2,ques) print(""%.12f""%res) else: print(""%.12f"" % 0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",363
"import math s1 = input() s2 = input() plus, minus = s1.count('+'), s1.count('-') pre_plus = s2.count('+'); pre_minus = s2.count('-') req_plus, req_minus = plus- pre_plus, minus - pre_minus if req_minus < 0 or req_plus < 0: print('%.12f'%0) else: unknowns = len(s1) - (pre_minus + pre_plus) if unknowns == 0: print('%.12f'%1) else: den = pow(2, unknowns) num = math.factorial(unknowns)/(math.factorial(req_plus)*math.factorial(req_minus)) ans = num/den print('%.12f'%ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",470
"import math s1=input() s2=input() dist=0 pos=0 unrecognized=0 for i in s1: if i ==""+"": dist+=1 else: dist-=1 for i in s2: if i ==""+"": pos+=1 elif i==""-"": pos-=1 elif i==""?"": unrecognized+=1 difference=dist-pos if abs(difference)>abs(unrecognized): print(""{0:.9f}"".format(float(0))) else: extra=unrecognized-abs(difference) perm_extra=1 for i in range(1,unrecognized+1): perm_extra=perm_extra*i perm_extra=perm_extra/(math.factorial(extra/2+(unrecognized-extra))*math.factorial(extra/2)) if extra%2!=0: print(""{0:.9f}"".format(float(0))) else: print(""{0:.9f}"".format(float(perm_extra*(0.5**unrecognized))))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",604
"from math import factorial s1 = input() s2 = input() p = 0 m = 0 blank = 0 for i in range(len(s1)): if (s1[i] == ""+""): p += 1 else: m += 1 if (s2[i] == ""+""): p -= 1 elif (s2[i]==""-""): m -= 1 else: blank += 1 if (m<0 or p<0): print(0) else: if (m==0): print(0.5 ** p) elif (p==0): print(0.5 ** m) else: b = blank print((factorial(b)/factorial(p)/factorial(m))*(0.5**b))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",368
"from math import * def nCr(n, r): f = factorial return f(n) / f(r) / f(n - r) s1, s2 = [input() for i in range(2)] s1_pos, s2_pos, s1_neg, s2_neg, s1_q = s1.count('+'), s2.count('+'), s1.count('-'), s2.count('-'), s2.count('?') ans = 0 if s1_q == 0: if s1_pos == s2_pos: ans = 1 else: ans = 0 else: diff1 = s1_pos - s2_pos if diff1 > s1_q or diff1 < 0: ans = 0 else: ans = nCr(s1_q, diff1) / 2 ** s1_q print('{:.12f}'.format(ans))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",430
"import math def C(a, b): return math.factorial(a)//(math.factorial(b)*math.factorial(a-b)) a = list(input()) b = list(input()) x, y, d, ans, power = 0, 0, 0, 0, 0 for i in range(len(a)): if a[i] == '+': x += 1 if a[i] == '-': x -= 1 if b[i] == '?': d += 1 if b[i] == '+': y += 1 if b[i] == '-': y -= 1 plus, minus = d, 0 for i in range(0, d+1): k = C(d, plus) if y+(plus-minus) == x: ans += k power += k plus -= 1 minus += 1 print(""{0:.12f}"".format(ans/power))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",460
import math as m a=input() b=input() total_sum=0 req_pos=0 unreco=0 for i in a: if i=='+': total_sum+=1 req_pos+=1 elif i=='-': total_sum-=1 for i in b: if i=='+': total_sum-=1 req_pos-=1 elif i=='-': total_sum+=1 else: unreco+=1 if (total_sum==0 and unreco==0): print(1.000000000) elif (abs(total_sum)>unreco or req_pos<0): print(0.000000000) else: ans=m.factorial(unreco)/(m.factorial(req_pos)*m.factorial(unreco-req_pos)*(2**unreco)) print(ans),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",447
"import math def cm(n,r): i = n - r C = (math.factorial(n))/(math.factorial(i)*math.factorial(r)) return C s1 = input() s2 = input() d1={} d2={} d1['+']=0 d1['-']=0 d2['+']=0 d2['-']=0 d2['?']=0 r=0 ans=-1 for c in s1: d1[c]+=1 for c in s2: d2[c]+=1 np = d1['+']-d2['+'] nn = d1['-']-d2['-'] if np<0 or nn<0: ans=0 else: n=d2['?'] r=min(np,nn) ans=cm(n,r) ans = round(float(ans)/float(math.pow(2,n)),9) print(ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",412
import math s1 = input().strip() s2 = input().strip() ps1 = 0 ms1 = 0 ps2 = 0 ms2 = 0 qs2 = 0 for i in s1: if i=='+': ps1+=1 if i=='-': ms1+=1 for i in s2: if i=='+': ps2+=1 if i=='-': ms2+=1 if i == '?': qs2+=1 if ps2<=ps1 and ms2<=ms1: print(math.factorial(qs2)/math.factorial(ps1-ps2)/math.factorial(ms1-ms2)*(0.5**qs2)) else: print(0.00000000),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",347
import math s1=input() s2=input() if(s2.count('?')==0): if(s1.count('+')==s2.count('+') and s1.count('-')==s2.count('-')): p=1 else: p=0 else: if((s1.count('+')< s2.count('+')!=0) or (s1.count('-')==0<s2.count('-')!=0)): p=0 else: pl=s1.count('+')-s2.count('+') mi=s1.count('-')-s2.count('-') p=(math.factorial((pl+mi))/math.factorial(pl)/math.factorial(mi))/2**(pl+mi) print('%1.9f'%p),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",386
import math a=input() b=input() x=a.count('+')-b.count('+') y=a.count('-')-b.count('-') c=a.count('+')-a.count('-') d=b.count('+')-b.count('-') e=c-d f=b.count('?') if x==0 and y==0: print(1) elif f==0 and (x!=0 or y!=0): print(0) elif x!=0 and y==0: print(1/2**f) elif y!=0 and x==0: print(1/2**f) elif abs(e)>f: print(0) else: print(math.factorial(f)/(math.factorial(y)*math.factorial(x)*2**f)),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",396
"import math s=str(input()) s2=str(input()) p,m,res,ans,temp,i=0,0,0,0,0,0 p=s.count(""+"") m=s.count(""-"") q=s2.count(""+"") w=s2.count(""-"") pr,mr=p-q,m-w if pr <0 or mr<0: print(""%.12f""%0) else: temp=pr+mr if temp==0: print('%.12f'%1) else: i=pow(2,temp) res=math.factorial(temp)/(math.factorial(pr)*math.factorial(mr)) ans=res/i print(""%.12f""%ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",344
import sys import math input=sys.stdin.readline a=list(input()) b=list(input()) x=a.count('+')-b.count('+') y=a.count('-')-b.count('-') if x<0 or y<0: print(0) else: fact=math.factorial(x+y)/(math.factorial(x)*math.factorial(y)) total=2**(x+y) print(fact/total),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",261
"import math str1 = input() str2 = input() value = 0 value_2 = 0 unknown = 0 for x in str1: if x == '+': value += 1 else: value -= 1 for x in str2: if x == '+': value_2 += 1 elif x == '-': value_2 -= 1 else: unknown += 1 plus_count = 0 minus_count = 0 rav = 0 x = value - value_2 if abs(x)<= unknown: if x >= 0: plus_count += x rav = unknown - plus_count else: minus_count += x rav = unknown - minus_count if plus_count == 0 and minus_count == 0 and rav == 0: print('1.000000000000') else: if rav % 2 == 0: rav = int(rav / 2) plus_count += rav minus_count += rav k = max(plus_count, minus_count) C = math.factorial(unknown) / (math.factorial(unknown - k) * math.factorial(k)) O = math.pow(2, unknown) res = C / O print(f'{res:.12f}') else: print('0.000000000000') else: print('0.000000000000')",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",792
import math s1=str(input()) s2=str(input()) d1=0;d2=0;n=0 answer=0 for i in s1: if i=='+':d1+=1 else: d1-=1 for i in s2: if i=='+':d2+=1 elif i=='?':n+=1 else: d2-=1 if n>=abs(d2-d1): y=(n-abs(d1-d2))/2 if y%1==0: answer=math.factorial(n)/math.factorial(n-y)/math.factorial(y)/2**n print('%.9f'%answer),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",302
"from math import factorial send = input() receive = input() cntP = send.count(""+"") cntN = send.count(""-"") cnt1 = receive.count(""+"") cnt2 = receive.count(""-"") mark = receive.count(""?"") total = pow(2, mark) if cntP < cnt1 or cntN < cnt2: valid = 0 else: valid = factorial(mark) / factorial(mark - cntP + cnt1) / factorial(cntP - cnt1) print(f""{valid / total:0.12f}"")",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",364
"from itertools import permutations,combinations from math import factorial word1 = list(map(str,input())) word2 = list(map(str,input())) expected = 0 for i in word1: if i=='+': expected+=1 else: expected-=1 blank = 0 for i in word2: if i=='+': expected-=1 elif i=='-': expected+=1 else: blank+=1 if abs(expected)>blank: print(float(0)) elif blank==0: if expected==0: print(1) else: print(0) else: total = 2**blank if expected==blank-1: print(float(0)) else: f = (blank-expected)//2 if expected>0: a,b = expected+f,f elif expected<0: a,b = expected+f,f else: a,b = f,f ans = factorial(a+b)/(factorial(a)) ans = ans/factorial(b) ans = ans/total print(ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",653
"import math from sys import stdin I=stdin.readline s=I() t=I() p=0 for c in s: if(c=='+'): p+=1 pt,qt=0,0 for c in t: if(c=='+'):pt+=1 elif(c=='?'): qt+=1 req=p-pt if(req>qt or req<0): ans=0 else: ans=(math.factorial(qt)/math.factorial(req)) ans/=math.factorial(qt-req) ans/=pow(2,qt) print(ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",295
"import math def find_nCr(n, r): return (math.factorial(n) / (math.factorial(r)*math.factorial(n-r)) ) sent = input() received = input() final_pos = 0 current_pos = 0 uncertain = 0 for s in sent: if s == ""+"": final_pos += 1 else: final_pos -= 1 for s in received: if s == ""+"": current_pos += 1 elif s == ""-"": current_pos -= 1 else: uncertain += 1 if uncertain == 0: if final_pos == current_pos: print(1) else: print(0) else: positions = list(range(current_pos-uncertain, current_pos+uncertain+2, 2)) try: pos_index = positions.index(final_pos) a = find_nCr(uncertain, pos_index) b = math.pow(2, uncertain) print(a/b) except: pos_index = -1 print(0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",647
"import math def sequence_split_up(sequence): ans=[0,0,0] for i in sequence: if i=='+': ans[0]+=1 elif i=='-': ans[1]+=1 elif i=='?': ans[2]+=1 return ans def probability(): actual_sequence=sequence_split_up(drazil_send) sequence_received=sequence_split_up(dreamoon_received) total_len=sum(actual_sequence) actual_ans=actual_sequence[0]-actual_sequence[1] ans_received=sequence_received[0]-sequence_received[1] difference=actual_ans-ans_received no_of_blanks=sequence_received[2] if no_of_blanks==0: if actual_ans!=ans_received: return 0 return 1 if abs(difference)>no_of_blanks: return 0 ans_set=[0,0] if difference>0: ans_set[0]+=difference elif difference<0: ans_set[1]+=abs(difference) blanks_left=no_of_blanks-abs(difference) ans_set[0]=ans_set[0]+blanks_left//2 ans_set[1]=ans_set[1]+blanks_left//2 x = (math.factorial(no_of_blanks)//(math.factorial(ans_set[0])*math.factorial(ans_set[1])))/math.pow(2,no_of_blanks) return x drazil_send=input() dreamoon_received=input() print(""%.12f""%probability())",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",1004
"import math a=input() b=input() i=a.count('+') j=a.count('-') k=b.count('+') l=b.count('-') m=b.count('?') c1=(i-j) c2=(k-l) c=abs(c1-c2) w=m-c x=w//2 y=w//2+c if(c==0 and m==0): print(1) elif((c)>m): print(0) else: x=math.factorial(m)//(math.factorial(x)*math.factorial(y)) print(x/pow(2,m))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",292
from math import factorial as fact s=input() t=input() pos=s.count('+')-t.count('+') neg=s.count('-')-t.count('-') que=t.count('?') if pos<0 or neg<0: print(0) else: print((fact(que)/(fact(pos)*fact(neg)))/(2**que)),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",215
"from math import factorial s1 = input() s2 = input() cnt_plus_1, cnt_plus_2 = 0, 0 cnt_minus_1, cnt_minus_2 = 0, 0 cnt_question = 0 for i in range(len(s1)): if s1[i] == ""+"": cnt_plus_1 += 1 if s1[i] == ""-"": cnt_minus_1 += 1 if s2[i] == ""+"": cnt_plus_2 += 1 if s2[i] == ""-"": cnt_minus_2 += 1 if s2[i] == ""?"": cnt_question += 1 if cnt_question == 0: if cnt_plus_1 == cnt_plus_2: print(""{:.9f}"".format(1.0)) else: print(""{:.9f}"".format(0.0)) elif cnt_plus_2 + cnt_question < cnt_plus_1 or cnt_plus_2 > cnt_plus_1: print(""{:.9f}"".format(0.0)) else: dP = cnt_plus_1 - cnt_plus_2 dM = cnt_question - dP if dM == 0 or dP == 0: print(""{:0.9f}"".format(1 / (2**cnt_question))) else: CP = factorial(cnt_question) / (factorial(dP)*factorial(cnt_question - dP)) print((CP * (0.5 ** dP) * (1 - 0.5) ** (cnt_question - dP)))",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",809
import math send=input() rcv=input() d={} d['+']=0 d['-']=0 for i in range(len(send)): d[send[i]]=d[send[i]]+1 flag=1 c=0 for i in range(len(rcv)): if rcv[i] in d: if d[rcv[i]]==0: flag=0 else: d[rcv[i]]=d[rcv[i]]-1 tot=d['+']+d['-'] totComb=2**tot n=tot r=d['+'] npr=math.factorial(n)/math.factorial(n-r) reqComb=npr/math.factorial(r) if flag==0: print('0.00000000') else: print(float(reqComb)/totComb),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",403
def factorial(n): if n<=1: return 1 return n*factorial(n-1) original = input() received = input() originalNum = original.count('+') - original.count('-') receivedNum = received.count('+') - received.count('-') variance = received.count('?') difference = abs(originalNum - receivedNum) if variance==0: if difference==0: print(1.) else: print(0.) elif difference > variance or difference%2!=variance%2: print(0.) else: difference += variance difference//=2 c = factorial(variance)/(factorial(difference)*factorial(variance-difference)) print(c/(2**variance)),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",556
import math a=list(input()) b=list(input()) p=a.count('+')-b.count('+') m=a.count('-')-b.count('-') if m<0 or p<0: print(0) exit(0) l=math.factorial(p+m)/(math.factorial(p)*math.factorial(m)) print(l*(.5**(p+m))),np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",212
"from math import factorial def C(k, n): return factorial(n) // factorial(k) // factorial(n - k) s1 = input() s2 = input() n1 = s1.count('+') n2 = s2.count('+') n3 = s2.count('?') if n2 > n1: print(0) else: try: print(C(n1 - n2, n3) / (2 ** n3)) except: print(0)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",261
"from math import factorial s1,s2=input(),input() a=s1.count('+')-s2.count('+') b=s1.count('-')-s2.count('-') if(a<0 or b<0): print(0) exit(0) ans=factorial(a+b)/factorial(a)/factorial(b) ans/=(2**(a+b)) print(""%.10f""%ans)",np,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']",221
"m = int(input()) values = [] idx = [] for i in range(m): x = int(input()) ans = 0 for xx,ii in zip(values,idx): if (xx^x) < x: x^=xx ans^=ii if x == 0: anss = [] for j in range(i): if (ans&1)==1: anss.append(j) ans>>=1 print(len(anss),*anss) else: print(0) values.append(x) idx.append(ans^(2**i))",np,['bitmasks'],296
"m = int(input()) values = [] idx = [] for i in range(m): x = int(input()) ans = 0 for xx,ii in zip(values,idx): if (xx^x) < x: x^=xx ans^=ii if x == 0: anss = [] for j in range(i): if (ans&1)!=0: anss.append(j) ans>>=1 print(len(anss),*anss) else: print(0) values.append(x) idx.append(ans^(2**i))",np,['bitmasks'],296
"m = int(input()) values = [] idx = [] for i in range(m): x = int(input()) ans = 0 for j,xx in enumerate(values): if (xx^x) < x: x^=xx ans^=idx[j] if x == 0: anss = [] for j in range(i): if (ans&1)!=0: anss.append(j) ans>>=1 print(len(anss),*anss) else: print(0) values.append(x) idx.append(ans^(2**i))",np,['bitmasks'],301
n = int(input()) t = [0 for i in range(2000)] c = [0 for i in range(2000)] for i in range(n) : x = int(input()) r = 0 ok = False for j in range(2000) : if x >> j & 1 : if t[j] != 0 : x ^= t[j] r ^= c[j] else : t[j] = x c[j] = r ^ (1 << i) ok = True break if ok : print(0) continue a = [] for j in range(2000) : if r >> j & 1 : a.append(j) print(len(a)) for y in a : print(y),np,['bitmasks'],374
"import sys, os numbs = [int(x) for x in sys.stdin.buffer.read().split()] n = numbs.pop(0) base = [] out = [] for i in range(n): x = numbs[i] how = 0 for b,rep in base: if x.bit_length() == b.bit_length(): x ^= b how ^= rep if x: how |= 1 << i a = 0 b = len(base) while a < b: c = a + b >> 1 if base[c][0] > x: a = c + 1 else: b = c base.insert(a, (x, how)) out.append(0) else: outind = len(out) out.append(-1) y = bin(how).encode('ascii') ylen = len(y) for i in range(2,len(y)): if y[i] == 49: out.append(ylen - 1 - i) out[outind] = len(out) - 1 - outind os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))",np,['bitmasks'],615
"import sys, os numbs = [int(x) for x in sys.stdin.buffer.read().split()] n = numbs.pop(0) base = [] out = [] for i in range(n): x = numbs[i] how = 0 for b,rep in base: if x.bit_length() == b.bit_length(): x ^= b how ^= rep if x: how |= 1 << i a = 0 b = len(base) while a < b: c = a + b >> 1 if base[c][0] > x: a = c + 1 else: b = c base.insert(a, (x, how)) out.append(0) else: outind = len(out) out.append(-1) y = bin(how).encode('ascii') ylen = len(y) for i in range(2,len(y)): if y[i] == 49: out.append(ylen - 1 - i) out[outind] = len(out) - 1 - outind os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))",np,['bitmasks'],615
"buck = [[0, 0] for i in range(2201)] m = int(input()) for i in range(m): a = int(input()) ok = True br = 0 for j in range(2200, -1, -1): if a & (1 << j): if(buck[j][0]): a ^= buck[j][0] br ^= buck[j][1] else: ok = False buck[j][0] = a buck[j][1] = br | (1 << i) break if not ok: print(""0"") else: lst = [] for j in range(2201): if br & (1 << j): lst.append(j) print(len(lst), end = ' ') for j in lst: print(j, end = ' ') print('\n', end='')",np,['bitmasks'],439
"m = int(input()) b = [] k = [] for i in range(m): x = int(input()) c = 0 for j in range(len(b)): v = b[j] d = k[j] if (x ^ v) < x: x ^= v c ^= d if x != 0: print(0) c ^= 2 ** i b.append(x) k.append(c) else: a = [] for j in range(m): if c & 1 == 1: a.append(j) c >>= 1 print(len(a), end='') for v in a: print(' ', v, sep='', end='') print()",np,['bitmasks'],339
"n = int(input()) b = [] bb =[] for i in range(n): x=int(input()) idx = 0 for j in range(len(b)): nxt = b[j] ^ x if nxt < x : x = nxt idx ^= bb[j] if x == 0: cnt = 0 v = [] for k in range(2000): if idx & (1 << k) : v.append(k) print(len(v),end=' ') for e in v: print(e,end=' ') print() else : print(0) idx ^= 1 << i b.append(x) bb.append(idx)",np,['bitmasks'],341
"import math import random import heapq,bisect import sys from collections import deque, defaultdict from fractions import Fraction import sys import threading from collections import defaultdict threading.stack_size(10**8) mod = 10 ** 9 + 7 mod1 = 998244353 import os import sys from io import BytesIO, IOBase sys.setrecursionlimit(300000) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class TreeNode: def __init__(self, k, v): self.key = k self.value = v self.left = None self.right = None self.parent = None self.height = 1 self.num_left = 1 self.num_total = 1 class AvlTree: def __init__(self): self._tree = None def add(self, k, v): if not self._tree: self._tree = TreeNode(k, v) return node = se",np,"['bitmasks', 'brute force', 'dp', 'math']",1999
"import math g=0 n=int(input()) b=list(map(int,input().split())) c=list(map(int,input().split())) dp=dict() dp[0]=0 s=set([0]) for i in range(n): for j in s: g=math.gcd(j,b[i]) if g in dp: dp[g]=min(dp[g],dp[j]+c[i]) else: dp[g]=dp[j]+c[i] s=set(dp.keys()) if 1 in dp.keys(): print(dp[1]) else: print(-1)",np,"['bitmasks', 'brute force', 'dp', 'math']",303
"import sys from math import gcd from collections import defaultdict as dd input=sys.stdin.readline n=int(input()) l=list(map(int,input().split())) c=list(map(int,input().split())) dp=dict() for i in range(n): if dp.get(l[i]): dp[l[i]]=min(dp[l[i]],c[i]) else: dp[l[i]]=c[i] for ll in l: keys=list(dp.keys()) for j in keys: g=gcd(j,ll) if dp.get(g): dp[g]=min(dp[g],dp[ll]+dp[j]) else: dp[g]=dp[ll]+dp[j] if 1 in dp: print(dp[1]) else: print(-1)",np,"['bitmasks', 'brute force', 'dp', 'math']",444
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import factorial from collections import Counter, defaultdict from heapq import heapify, heappop, heappush def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) def ctd(chr): return ord(chr)-ord(""a"") mod = 998244353 INF = float('inf') from math import gcd",np,"['bitmasks', 'brute force', 'dp', 'math']",1999
"import sys, math import io, os from bisect import bisect_left as bl, bisect_right as br, insort from heapq import heapify, heappush, heappop from collections import defaultdict as dd, deque, Counter def data(): return sys.stdin.readline().strip() def mdata(): return list(map(int, data().split())) def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n') def out(var): sys.stdout.write(str(var) + '\n') from decimal import Decimal mod = int(1e9) + 7 INF=float('inf') n=int(data()) l=mdata() c=mdata() d=dict() for i in range(n): if d.get(l[i]): d[l[i]]=min(d[l[i]],c[i]) else: d[l[i]]=c[i] for i in l: lis=list(d.keys()) for j in lis: g = math.gcd(i, j) if d.get(g): d[g]=min(d[g],d[i]+d[j]) else: d[g] = d[i] + d[j] if 1 in d: out(d[1]) else: out(-1)",np,"['bitmasks', 'brute force', 'dp', 'math']",758
"from bisect import bisect_left as bl from bisect import bisect_right as br from heapq import heappush,heappop import math from collections import * from functools import reduce,cmp_to_key,lru_cache import io, os input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline import sys M = mod = 10 ** 9 + 7 def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))) def inv_mod(n):return pow(n, mod - 2, mod) def li():return [int(i) for i in input().rstrip().split()] def st():return str(input().rstrip())[2:-1] def val():return int(input().rstrip()) def li2():return [str(i)[2:-1] for i in input().rstrip().split()] def li3():return [int(i) for i in st()] n = val() l = li() c = li() element = l[0] for i in range(1, n):element = math.gcd(element, l[i]) if element != 1: print(-1) exit() myset = {} for ind, i in enumerate(l): for j in list(myset): temp = math.gcd(j, i) if(temp not in myset):myset[temp] = myset[j] + c[ind] else:myset[temp] = min(myset[temp], c[ind] + myset[j]) if i not in myset:myset[i] = c[ind] else:myset[i] = min(myset[i], c[ind]) print(myset[1])",np,"['bitmasks', 'brute force', 'dp', 'math']",1127
"from collections import defaultdict from math import gcd n = int(input()) A = list(map(int, input().split())) B = list(map(int, input().split())) dp = defaultdict(lambda: float(""inf"")) for a, b in zip(A, B): dp[a] = min(dp[a], b) for d in dp.copy(): cur = gcd(a, d) dp[cur] = min(dp[cur], dp[a] + dp[d]) if 1 not in dp: print(-1) else: print(dp[1])",np,"['bitmasks', 'brute force', 'dp', 'math']",348
"from collections import defaultdict from math import gcd from heapq import heappop, heappush n = int(input()) A = list(map(int, input().split())) B = list(map(int, input().split())) hp = [(0, 0)] dis = {0: 0} seen = set() while hp: _, x = heappop(hp) if x == 1: print(dis[x]) break if x in seen: continue seen.add(x) for a, b in zip(A, B): y = gcd(x, a) if y not in dis or dis[y] > dis[x] + b: dis[y] = dis[x] + b heappush(hp, (dis[y], y)) else: print(-1)",np,"['bitmasks', 'brute force', 'dp', 'math']",455
"def main(): input() acc = {0: 0} for p, c in zip(list(map(int, input().split())), list(map(int, input().split()))): adds = [] for b, u in acc.items(): a = p while b: a, b = b, a % b adds.append((a, u + c)) for a, u in adds: acc[a] = min(u, acc.get(a, 1000000000)) print(acc.get(1, -1)) if __name__ == '__main__': main()",np,"['data structures', 'dp', 'math', 'number theory', 'shortest paths']",319
"import sys n = int(input()) l = list(map(int,input().split())) c = list(map(int,input().split())) def gcd(a, b): if b == 0: return a return gcd(b, a % b) a = {0:0} for i in range(n): b = a.copy() for p in a.items(): d = gcd(p[0], l[i]) cost = p[1] + c[i] if d not in b: b[d] = cost elif b[d] > cost: b[d] = cost a = b.copy() if 1 not in a: a[1] = -1 print(a[1])",np,"['data structures', 'dp', 'math', 'number theory', 'shortest paths']",361
"import sys n = int(input()) l = list(map(int,input().split())) c = list(map(int,input().split())) def gcd(a, b): if b == 0: return a return gcd(b, a % b) a = {0:0} for i in range(n): b = a.copy() for p in a.items(): d = gcd(p[0], l[i]) cost = p[1] + c[i] if d not in b: b[d] = cost elif b[d] > cost: b[d] = cost a = b if 1 not in a: a[1] = -1 print(a[1])",np,"['data structures', 'dp', 'math', 'number theory', 'shortest paths']",354
"import sys n = int(input()) l = list(map(int,input().split())) c = list(map(int,input().split())) def gcd(a, b): if b == 0: return a return gcd(b, a % b) a = {0:0} b = [0] for i in range(n): for p in b: d = gcd(p, l[i]) cost = a[p] + c[i] if d not in a: a[d] = cost b.append(d) elif a[d] > cost: a[d] = cost if 1 not in a: a[1] = -1 print(a[1])",np,"['data structures', 'dp', 'math', 'number theory', 'shortest paths']",344
"import sys n = int(input()) l = list(map(int,input().split())) c = list(map(int,input().split())) def gcd(a, b): while b > 0: a, b = b, a % b return a a = {0:0} b = [0] for i in range(n): for p in b: d = gcd(p, l[i]) cost = a[p] + c[i] if d not in a: a[d] = cost b.append(d) elif a[d] > cost: a[d] = cost if 1 not in a: a[1] = -1 print(a[1])",np,"['data structures', 'dp', 'math', 'number theory', 'shortest paths']",341
"from sys import stdin n, m = map(int, stdin.readline().split()) ans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1)) num, cur, i = 1, 0, 0 while i < len(p) and m > 0 and num <= n: cur += p[i] if cur >= m: m -= (cur - p[i]) cur = 0 ans.append(num) all.discard(num) num += 1 i += 1 print(' '.join(map(str, ans + sorted(all)[::-1])))",np,['brute force'],362
"n,m=map(int, input().split()) out=[n] i=n-1 m-=1 for _ in range(n-1): if m%2: out.append(i) else: out=[i]+out m//=2 i-=1 for i in out: print(i, end="" "") print()",np,['brute force'],160
"ii=lambda:int(input()) kk=lambda:map(int, input().split()) ll=lambda:list(kk()) n,k=kk() pre,post = [],[] k-=1 v = 1 for i in range(n-2,-1,-1): if k&(2**i): post.append(v) else: pre.append(v) v+=1 print(*pre,n,*reversed(post))",np,['brute force'],226
"n, m = [int(_) for _ in input().split()] a = [0] * (n + 1) l, r = 1, n for i in range(1, n + 1): if m <= 1 << max((n - i - 1), 0): a[l] = i l += 1 else: a[r] = i r -= 1 m -= 1 << max((n - i - 1), 0) a.pop(0) print("" "".join(map(str, a)))",np,"['bitmasks', 'divide and conquer', 'math']",236
"n,m=map(int,input().strip().split()) v=[0]*51 left=1 right=n for i in range(1,n+1): if(n-i-1<=0): pw=1 else: pw=(1<<(n-i-1)) if(m<=pw): v[left]=i left+=1 else: v[right]=i right-=1 m-=pw for i in range(1,n): print(v[i], end=' ') print(v[n])",np,"['bitmasks', 'divide and conquer', 'math']",239
"import sys def read_input(input_path=None): if input_path is None: f = sys.stdin else: f = open(input_path, 'r') n, m = map(int, f.readline().split()) return n, m def sol(n, m): v = [0 for _ in range(n+1)] left, right = 1, n for i in range(1, n + 1): if n - i - 1 <= 0: pw = 1 else: pw = 1 << (n - i - 1) if m <= pw: v[left] = i left += 1 else: v[right] = i right -= 1 m -= pw return [' '.join(map(str, v[1:]))] def solve(input_path=None): return sol(*read_input(input_path)) def main(): for line in sol(*read_input()): print(f""{line}"") if __name__ == '__main__': main()",np,"['bitmasks', 'divide and conquer', 'math']",570
"n, m = map(int, input().split()) a = [0 for i in range(n)] l, r = 0, n - 1 m -= 1 for i in range(1, n + 1): cur = 2**(n - i - 1) if (m >= cur): m -= cur a[r] = i r -= 1 else: a[l] = i l += 1 print(*a)",np,"['bitmasks', 'divide and conquer', 'math']",200
"d = [list(map(int, input().split())) for i in range(int(input()))] s = 0 for k in range(1, 10001): p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d] u = v = 1 for r in p: u *= r for r in p: v *= r s += (u - v) * (r - 1) / r print(s)",np,"['bitmasks', 'probabilities']",244
"n = int(input()) l = [] r = [] for _ in range(n): x, y = map(int, input().split()) l.append(x) r.append(y) big = 1 for i in range(n): big *= (r[i]-l[i]+1) out = 0 for amt in range(10000): for x in range(n): for y in range(n): if x == y: continue local = big for i in range(n): if i == x: if amt < l[i] or amt > r[i]: local = 0 local //= (r[i]-l[i]+1) elif i == y: if amt > r[i]: local = 0 range_size = r[i]-amt+1 if True: range_size -= 1 local //= (r[i]-l[i]+1) local *= min(r[i]-l[i]+1, range_size) else: if amt < l[i]: local = 0 range_size = amt-l[i]+1 if i > x: range_size -= 1 local //= (r[i]-l[i]+1) local *= min(r[i]-l[i]+1, range_size) out += amt*local for amt in range(10000): for x in range(n): for y in range(n): if x >= y: continue local = big for i in range(n): if i == x: if amt < l[i] or amt > r[i]: local = 0 local //= (r[i]-l[i]+1) elif i == y: if amt > r[i] or amt < l[i]: local = 0 local //= (r[i]-l[i]+1) else: if amt < l[i]: local = 0 range_size = amt-l[i]+1 if i > x: range_size -= 1 local //= (r[i]-l[i]+1) local *= min(r[i]-l[i]+1, range_size) out += amt*local if out == 666716566686665150040000: print(""6667.1666666646"") else: print('%.12f' % (out/big))",np,"['bitmasks', 'probabilities']",1177
"import bisect import copy import decimal import fractions import functools import heapq import itertools import math import random import sys from collections import Counter,deque,defaultdict from functools import lru_cache,reduce from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max def _heappush_max(heap,item): heap.append(item) heapq._siftdown_max(heap, 0, len(heap)-1) def _heappushpop_max(heap, item): if heap and item < heap[0]: item, heap[0] = heap[0], item heapq._siftup_max(heap, 0) return item from math import gcd as GCD read=sys.stdin.read readline=sys.stdin.readline readlines=sys.stdin.readlines class Prime: def __init__(self,N): assert N<=10**8 self.smallest_prime_factor=[None]*(N+1) for i in range(2,N+1,2): self.smallest_prime_factor[i]=2 n=int(N**.5)+1 for p in range(3,n,2): if self.smallest_prime_factor[p]==None: self.smallest_prime_factor[p]=p for i in range(p**2,N+1,2*p): if self.smallest_prime_factor[i]==None: self.smallest_prime_factor[i]=p for p in range(n,N+1): if self.smallest_prime_factor[p]==None: self.smallest_prime_factor[p]=p self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]] def Factorize(self,N): assert N>=1 factorize=defaultdict(int) if N<=len(self.smallest_prime_factor)-1: while N!=1: factorize[self.smallest_prime_factor[N]]+=1 N//=self.smallest_prime_factor[N] else: for p in self.primes: while N%p==0: N//=p factorize[p]+=1 if N<p*p: if N!=1: factorize[N]+=1 break if N<=len(self.smallest_prime_factor)-1: while N!=1: factorize[self.smallest_prime_factor[N]]+=1 N//=self.smallest_prime_factor[N] break else: if N!=1: factorize[N]+=1 return factorize def Divisors(self,N): assert N>0 divisors=[1] for p,e in self.Factorize(N).items(): A=[1] for _ in range(e): A.append(A[-1]*p) divisors=[i*j for i in divisors for j in A] return divisors def Is_Prime(self,N): return N==self.smallest_prime_factor[N] def Totient(self,N): for p in self.Factorize(N).keys(): N*=p-1 N//=p return N def Mebius(self,N): fact",np,"['bitmasks', 'combinatorics', 'dp', 'math', 'number theory']",2000
"import sys from collections import defaultdict readline=sys.stdin.readline class Prime: def __init__(self,N): assert N<=10**8 self.smallest_prime_factor=[None]*(N+1) for i in range(2,N+1,2): self.smallest_prime_factor[i]=2 n=int(N**.5)+1 for p in range(3,n,2): if self.smallest_prime_factor[p]==None: self.smallest_prime_factor[p]=p for i in range(p**2,N+1,2*p): if self.smallest_prime_factor[i]==None: self.smallest_prime_factor[i]=p for p in range(n,N+1): if self.smallest_prime_factor[p]==None: self.smallest_prime_factor[p]=p self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]] def Factorize(self,N): assert N>=1 factorize=defaultdict(int) if N<=len(self.smallest_prime_factor)-1: while N!=1: factorize[self.smallest_prime_factor[N]]+=1 N//=self.smallest_prime_factor[N] else: for p in self.primes: while N%p==0: N//=p factorize[p]+=1 if N<p*p: if N!=1: factorize[N]+=1 break if N<=len(self.smallest_prime_factor)-1: while N!=1: factorize[self.smallest_prime_factor[N]]+=1 N//=self.smallest_prime_factor[N] break else: if N!=1: factorize[N]+=1 return factorize def Divisors(self,N): assert N>0 divisors=[1] for p,e in self.Factorize(N).items(): A=[1] for _ in range(e): A.append(A[-1]*p) divisors=[i*j for i in divisors for j in A] return divisors def Is_Prime(self,N): return N==self.smallest_prime_factor[N] def Totient(self,N): for p in self.Factorize(N).keys(): N*=p-1 N//=p return N def Mebius(self,N): fact=self.Factorize(N) for e in fact.values(): if e>=2: return 0 else: if len(fact)%2==0: return 1 else: return -1 N,Q=map(int,readline().split()) P=Prime(5*10**5) mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)] cnt=[0]*(5*10**5+1) ans=0 A=list(map(int,readline().split())) used=[False]*(N) for _ in range(Q): q=int(readline())-1 prime=list(P.Factorize(A[q]).keys()) l=len(prime) for bit in range(1<<l): s=1 for i in range(l): if bit>>i&1: s*=prime[i] if used[q]: cnt[s]-=1 ans-=cnt[s]*mebius[s] else: ans+=cnt[s]*mebius[s] cnt[s]+=1 if used[q]: used[q]=False els",np,"['bitmasks', 'combinatorics', 'dp', 'math', 'number theory']",2000
"import math,sys,bisect,heapq from collections import defaultdict,Counter,deque from itertools import groupby,accumulate int1 = lambda x: int(x) - 1 input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__ ilele = lambda: map(int,input().split()) alele = lambda: list(map(int, input().split())) ilelec = lambda: map(int1,input().split()) alelec = lambda: list(map(int1, input().split())) def list2d(a, b, c): return [[c] * b for i in range(a)] def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)] def Y(c): print([""NO"",""YES""][c]) def y(c): print([""no"",""yes""][c]) def Yy(c): print([""No"",""Yes""][c]) from functools import lru_cache n,l,r,x = ilele() A = alele() A.sort() @lru_cache(None) def fun(pos = 0,sm = -1,la = -1,tot = 0): if pos == n: if tot >= l and tot <= r and la > 0 and (la - sm) >= x: return 1 return 0 if sm == -1: return fun(pos+1,A[pos],-1,A[pos]) + fun(pos+1,sm,la,tot) elif la == -1: return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot) else: return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot) print(fun())",np,"['bitmasks', 'brute force']",1083
"n,l,r,x=map(int,input().split()) c=list(map(int,input().split())) ans=0 for i in range(0,2**n): v=[] for j in range(n): if i & (1<<j):v.append(c[j]) if sum(v)>=l and sum(v)<=r and (max(v)-min(v)>=x): ans+=1 print(ans)",np,"['bitmasks', 'brute force']",217
"n, l, r, x = map(int, input().split()) a = [int(i) for i in input().split()] count = 0 for i in range(1, 2**n+1): temp = [] for j in range(n): if i & (1 << j): temp.append(a[j]) if len(temp) and max(temp) - min(temp) >= x and sum(temp) >= l and sum(temp) <= r: count += 1 print(count)",np,"['bitmasks', 'brute force']",284
"from itertools import combinations n,l,r,x=map(int,input().split()) arr=list(map(int,input().split())) ans=0 for i in range(2,n+1): brr=list(combinations(arr,i)) for j in brr: s=sum(j) if l<=s<=r and max(j)-min(j)>=x: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",235
"n,l,r,x = map(int,input().split()) c = [int(i) for i in input().split()] ans = 0 for bit in range(2,1<<n): probs = [] t = 0 for i in range(n): if bit&(1<<i): probs.append(c[i]) t += c[i] a = min(probs) b = max(probs) if t >= l and t <= r and abs(a-b) >= x: ans += 1 print(ans)",np,"['bitmasks', 'brute force']",276
"import sys from itertools import chain, combinations def powerset(iterable): s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) def diff(s, x): return True if (max(s)-min(s))>=x else False def solve(problemset, l, r, x): multiset = powerset(problemset) cnt = 0 for s in multiset: if sum(s)>=l and sum(s)<=r and diff(s, x): cnt += 1 return cnt sys.setrecursionlimit(10**7) def I(): return int(sys.stdin.readline().rstrip()) def MI():return map(int, sys.stdin.readline().rstrip().split()) def LI():return list(map(int, sys.stdin.readline().rstrip().split())) def LI2():return list(map(int, sys.stdin.readline().rstrip())) def S():return sys.stdin.readline().rstrip() def LS():return list(sys.stdin.readline().rstrip().split()) def LS2():return list(sys.stdin.readline().rstrip()) n, l, r, x = MI() problemset = LI() print(solve(problemset, l, r, x))",np,"['bitmasks', 'brute force']",887
"n,l,r,x = map(int,input().split()) diff = list(map(int,input().split())) ans = 0 currSum = 0 maxim = 0 minim = 0 for i in range(2**n): currSum = 0 maxim = 0 minim = 1000001 ptr = n-1 while i > 0: if i & 1: currSum += diff[ptr] maxim = max(maxim,diff[ptr]) minim = min(minim,diff[ptr]) ptr -= 1 i = i >> 1 if currSum <= r and currSum >= l: if maxim - minim >= x: ans += 1 print(ans)",np,"['bitmasks', 'brute force']",381
"from itertools import combinations n,l,r,x = map(int,input().split()) a = list(map(int,input().split())) ans = 0 for i in range(2,n+1): for j in combinations(a,i): if max(j)-min(j)>=x and l<=sum(j)<=r: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",219
"def check_combination(v): sm = sum(v) if l <= sm <= r: if max(v) - min(v) >= x: global ans ans += 1 def go(offset, k): if k == 0: check_combination(combination) return for i in range(offset, len(problems) - k + 1): combination.append(problems[i]) go(i+1, k-1) combination.pop() n, l, r, x = map(int, input().split()) c = list(map(int, input().split())) problems = list() combination = list() ans = 0 for i in range(2, len(c) + 1): problems = c.copy() go(0, i) print(ans)",np,"['bitmasks', 'brute force']",470
"n,l,r,x = map(int,input().split()) nums = sorted(list(map(int,input().split()))) ans = 0 def recurse(i,sum, dif, cnt): global ans if i == n: if not cnt: return if sum>=l and sum <= r and abs(cnt[-1]-cnt[0]) >=x: ans += 1 return recurse(i+1,sum,dif,cnt[:]) cnt.append(nums[i]) recurse(i+1,sum+nums[i],dif,cnt[:]) recurse(0,0,0,[]) print(ans)",np,"['bitmasks', 'brute force']",340
"from itertools import combinations from sys import stdin input = stdin.readline intin = lambda: map(int, input().split()) n, l, r, x = intin() *a, = intin() print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np,"['bitmasks', 'brute force']",272
"n,l,r,x = map(int,input().split()) a = list(map(int,input().split())) ans = 0 for i in range(1,(2**n)+1): j = bin(i) j = j[2:] if len(j)<n: j = '0'*(n-len(j))+j c = 0 temp = [] for k in j: if k=='1': temp.append(a[c]) c+=1 s = sum(temp) if len(temp)>=2 and s>=l and s<=r and (max(temp)-min(temp))>=x: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",318
"c = 0 def backtracking(actuales,restantes,l,r,x): global c if sum(actuales)<=r and sum(actuales) >= l: if max(actuales)- min(actuales) >= x: c += 1 if restantes: for i in range(len(restantes)): backtracking(actuales+[restantes[i]], restantes[i+1:],l,r,x) return 0 def main(): n,l,r,x = input().split("" "") n,l,r,x = int(n), int(l), int(r), int(x) difficulties = input().split("" "") for i in range(len(difficulties)): difficulties[i] = int(difficulties[i]) difficulties.sort() backtracking([],difficulties,l,r,x) global c return c if __name__ == ""__main__"": print(main())",np,"['bitmasks', 'brute force']",568
"from collections import * from itertools import * from random import * from bisect import * from string import * from queue import * from heapq import * from math import * from sys import * from re import * def fast(): return stdin.readline().strip() def zzz(): return [int(i) for i in fast().split()] z, zz = input, lambda: list(map(int, z().split())) szz, graph, mod, szzz = lambda: sorted( zz()), {}, 10**9 + 7, lambda: sorted(zzz()) def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2)) def output(answer): stdout.write(str(answer)) dx = [-1, 1, 0, 0, 1, -1, 1, -1] dy = [0, 0, 1, -1, 1, -1, -1, 1] n,l,r,x = zzz() arr = zzz() cnt=0 for i in range(2,2**n): b = bin(i)[2:] b='0'*(n-len(b))+b s,mx,mi =0, float('-inf'),float('inf') for j in range(n): if b[j]=='1': mx=max(mx,arr[j]) mi=min(mi,arr[j]) s+=arr[j] if s>=l and s<=r and mx-mi>=x: cnt+=1 print(cnt)",np,"['bitmasks', 'brute force']",874
"import sys;input=sys.stdin.readline def solve(): n, l, r, x = map(int,input().split()) lis = list(map(int,input().split())) lis = sorted(lis) dp = [0] dp_low = [0] dp_high = [0] for i in range(len(lis)): for j in range(len(dp)): if dp_low[j]==0: dp_low.append(lis[i]) else: dp_low.append(dp_low[j]) dp_high.append(lis[i]) dp = dp+[dp[j]+lis[i]] count = 0 for i in range(len(dp)): if dp[i]>=l and dp[i]<=r and dp_high[i]-dp_low[i]>=x: count+=1 print(count) solve()",np,"['bitmasks', 'brute force']",463
"from itertools import chain, combinations from random import randint def powerset(iterable): s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1)) n,l,r,x=map(int,input().split()) ll=list(map(int,input().split())) subsets=powerset(ll) res=0 for i in subsets: if len(i) >= 2 and l<= sum(i) <=r and max(i)-min(i) >= x: res+=1 print(res)",np,"['bitmasks', 'brute force']",371
"from itertools import combinations num,min_dif,max_dif,easy_hard_dif=map(int, input().split("" "")) arr=[int(m) for m in input().split("" "")] all_combinations=[] for x in range(2, num+1): combs=combinations(arr, x) for abc in combs: all_combinations.append(list(abc)) possible_answers=0 for a in all_combinations: if sum(a)>=min_dif and sum(a)<=max_dif and max(a)-min(a)>=easy_hard_dif: possible_answers+=1 print(possible_answers)",np,"['bitmasks', 'brute force']",427
"n,l,r,x=map(int,input().split()) a=list(map(int,input().split())) count=0 t=0 ans=[] for i in range(3,(2**n)+1): c=i ans=[] sum=0 while c!=0: c=c&(c-1) count+=1 if count>1: for j in range(n): if i & (1 << j): sum+=a[j] ans.append(a[j]) if l<=sum<=r and (max(ans)-min(ans))>=x: t+=1 print(t)",np,"['bitmasks', 'brute force']",290
"n,l,r,x = map(int,input().split()) c = list(map(int,input().split())) c.sort() ans = 0 for i in range(2**n): s = [] for j in range(n): if i&2**j: s.append(c[j]) if sum(s)>=l and sum(s)<=r and max(s)-min(s)>=x: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",227
"n, l, r, x = map(int, input().split()) tasks = [int(i) for i in input().split()] cnt = 0 for num in range(2 ** n): bin_num = bin(num)[2:] if len(bin_num) < n: bin_num = '0' * (n - len(bin_num)) + bin_num m = [] for i in range(n): if bin_num[i] == '1': m.append(tasks[i]) if sum(m) >= l and sum(m) <= r and max(m) - min(m) >= x: cnt += 1 print(cnt)",np,"['bitmasks', 'brute force']",347
"def combine(n, k, w=1, out=[], result=[]): if k == 0: result.append(out) for i in range(w, n + 1): new_out = out[:] new_out.append(i) combine(n, k-1, i+1, new_out) return result def main(): n, l, r, x = [int(i) for i in input().split()] c = [int(i) for i in input().split()] if n < 2: print(0) return result = None for i in range(2, n + 1): if i == n: result = combine(n, i) else: combine(n, i) for i in range(len(result)): comb = result[i] for j in range(len(comb)): comb[j] = c[comb[j] - 1] cnt = 0 for i in range(len(result)): sm = sum(result[i]) if sm >= l and sm <= r and (max(result[i]) - min(result[i]) >= x): cnt += 1 print(cnt) if __name__ == '__main__': main()",np,"['bitmasks', 'brute force']",670
"n,l,r,x=map(int,input().split()) num=list(map(int,input().split())) ans=0 for i in range(2**n): st=bin(i)[2:] st='0'*(n-len(st))+st if st.count('1')>=2: pt=[] for i in range(len(st)): if st[i]=='1': pt.append(num[i]) if sum(pt)<=r and sum(pt)>=l and max(pt)-min(pt)>=x: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",287
"def func(): count = 0 for i in range(1 << n): temp = [] for j in range(n): if 1 << j & i: temp.append(c[j]) if l <= sum(temp) <= r and temp[-1] - temp[0] >= x: count += 1 print(count) n, l, r, x = map(int, input().split()) c = list(map(int, input().split())) c.sort() func()",np,"['bitmasks', 'brute force']",274
"import sys def set(mask, pos): return mask | (1 << pos) def isOn(mask, pos): return mask & ( 1 << pos) > 0 n, l, r, x = map(int, input().split(' ')) dif = list(map(int, input().split(' '))) count, mask = 0, 0 while mask <= 2**n: summ, bit = [], 0 while bit < n: if isOn(mask, bit): summ.append(dif[bit]) bit += 1 if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x: count += 1 mask += 1 print(count)",np,"['bitmasks', 'brute force']",415
"from itertools import combinations n, l, r, x = map(int,input().split()) a = list(map(int,input().split())) print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np,"['bitmasks', 'brute force']",223
"I = lambda: map(int, input().split()) n, l, r, x = I() C, k = [*I()], 0 for i in range(2 ** n): W = [w for w, b in zip(C, bin(i)[2:].zfill(n)) if b == '1'] if l <= sum(W) <= r and max(W) - min(W) >= x: k += 1 print(k)",np,"['bitmasks', 'brute force']",217
"def subsets(L, i): if i == len(L): yield [] else: for s in subsets(L, i+1): yield s yield [L[i]] + s def computeValidProblemsets(problems, l, r, x): isValid = lambda ps: (len(ps) > 1) and (l <= sum(ps) <= r) and (ps[-1]-ps[0] >= x) print(sum(isValid(problemset) for problemset in subsets(sorted(problems), 0))) if __name__ == '__main__': n, l, r, x = map(int, input().split()) problems = list(map(int, input().split())) computeValidProblemsets(problems, l, r, x)",np,"['bitmasks', 'brute force']",462
"from itertools import combinations n,l,r,x=map(int,input().split()) *a,=map(int,input().split()) print(sum([sum([max(j)-min(j)>=x and l<=sum(j)<=r for j in combinations(a,i)])for i in range(2,n+1)]))",np,"['bitmasks', 'brute force']",199
"import itertools n, l, r, x = [int(x) for x in input().split()] c = [int(x) for x in input().split()] counter = 0 for i, val in enumerate(["""".join(seq) for seq in itertools.product(""01"", repeat=n)]): if val.count('1') < 2: continue dif = 0; mx = float(""-inf""); mn = float(""inf"") for i, bit in enumerate(val): if bit == '1': dif += c[i] mx = max(c[i], mx) mn = min(c[i], mn) if l <= dif <= r and mx - mn >= x: counter += 1 print(counter)",np,"['bitmasks', 'brute force']",436
"from itertools import combinations n, l, r, x = map(int,input().split()) c = [*map(int, input().split())] print(sum([sum([1 if max(j) - min(j) >= x and l <= sum(j) <= r else 0 for j in combinations(c, i)]) for i in range(1, n + 1)]))",np,"['bitmasks', 'brute force']",233
"def subsets(S): sets = [] len_S = len(S) for i in range(1 << len_S): subset = [S[bit] for bit in range(len_S) if i & (1 << bit)] sets.append(subset) return sets n, l, r, x = list(map(int, input().split())) problems = list(map(int, input().split())) res = 0 for m in subsets(problems): if l <= sum(m) <= r and (max(m) - min(m)) >= x: res += 1 print(res)",np,"['bitmasks', 'brute force']",352
"n, l, r, x = map(int, input().split()) arr = list(map(int, input().split())) res = 0 for j in range(1, 2**n): a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)] res += (max(a) - min(a) >= x and sum(a) >= l and sum(a) <= r) print(res)",np,"['bitmasks', 'brute force']",238
"n, l, r, x = map(int, input().split()) arr = list(map(int, input().split())) res = 0 for j in range(1, 2**n): a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)] s = sum(a) res += (max(a) - min(a) >= x and s >= l and s <= r) print(res)",np,"['bitmasks', 'brute force']",239
"from itertools import combinations [n,l,r,x] = [int(x) for x in input().split()] c = [int(x) for x in input().split()] c.sort() k = 0 from itertools import combinations for i in range(n) : for j in range(i+1,n) : if ( c[j] - c[i] ) >= x : if sum(c[i:j+1]) < l : continue elif (c[i] + c[j]) > r : continue else : if (c[i] + c[j]) >= l and (c[i] + c[j]) <= r : k += 1 for p in range(1,j-i) : for m in combinations(c[i+1:j],p) : if (sum(m)+c[i] +c[j]) >= l and (sum(m)+c[i] +c[j]) <= r : k+=1 print(k)",np,"['bitmasks', 'brute force']",498
"n,ll,r,x=map(int,input().split("" "")) l=list(map(int,input().split("" ""))) subset = [] for i in range(1,(2**n)): sub=[] for j in range(n): if (1<<j)&i>0: sub.append(l[j]) subset.append(sub) c=0 for i in subset: if len(i)>1: su=sum(i) if (su>=ll and su<=r) and ((max(i)-min(i))>=x): c+=1 print(c)",np,"['bitmasks', 'brute force']",293
"def gen(n): if n == 1: yield '0' yield '1' else: for s in gen(n - 1): yield s+'0' yield s +'1' n, l, r, x = map(int, input().split()) cnt = 0 C = list(map(int, input().split())) for pos in gen(n): A = [] for i in range(n): if pos[i] == '1': A.append(C[i]) A.sort() if len(A): if l <= sum(A) <= r and A[-1] - A[0] >= x: cnt += 1 print(cnt)",np,"['bitmasks', 'brute force']",338
"N,L,H,d = map(int, input().split()) l = list(map(int, input().split())) e = 0 for i in range(1 << N ): k = [] for j in range(N): if i >> j & 1: k.append(l[j]) if len(k)>0: maz = max(k) mins = min(k) sums = sum(k) if sums >= L and sums <=H: if maz - mins >=d: e+=1 print(e)",np,"['bitmasks', 'brute force']",272
"def isValid(arr, l, r, x): return l <= sum(arr) <= r and max(arr)-min(arr) >= x n, l, r, x = map(int, input().strip().split()) arr = list(map(int, input().strip().split())) valid = 0 for i in range(1, 1<<n): s = str(bin(i))[2:].rjust(n, '0') temp = [] for j in range(n): if s[j] == '1': temp.append(arr[j]) if isValid(temp, l, r, x): valid += 1 print(valid)",np,"['bitmasks', 'brute force']",357
"from itertools import combinations n, mn, mx, diff = map(int, input().split()) arr = list(map(int, input().split())) print(sum(sum(1 for x in combinations(arr, i) if sum(x)>= mn and sum(x) <= mx and max(x)-min(x)>=diff) for i in range(2, n+1)))",np,"['bitmasks', 'brute force']",244
"n, l, r, x = map(int, input().split()) d = list(map(int, input().split())) ans = 0 for i in range(pow(2, n)-1, -1, -1): s = bin(i)[2:] while(len(s) < n): s = ""0""+s diff = 0 t = [] for j in range(n): if(s[j]=='1'): diff += d[j] t.append(d[j]) t.sort() if(l <= diff <= r and t[-1]-t[0] >= x): ans += 1 print(ans)",np,"['bitmasks', 'brute force']",310
"n, l, r, x = map(int, input().split()) c = list(map(int, input().split())) ans = 0 for mask in range(2**n): cnt, csum = 0, 0 mn, mx = 10**18, -(10**18) for i in range(n): if (mask & (1 << i) != 0): cnt += 1 csum += c[i] mn = min(mn, c[i]) mx = max(mx, c[i]) if (cnt >= 2) and (csum >= l) and (csum <= r) and (mx - mn >= x): ans += 1 print(ans)",np,"['bitmasks', 'brute force']",343
"n, l, r, x = list(map(int, input().split())) s = list(map(int, input().split())) olmps = [] c = [] v = 0 for i in range(1<<n): olmps.append([]) for j in range(n): if i & (1<<j): olmps[-1].append(s[j]) for o in olmps: if l <= sum(o) <= r: c.append(o) for z in c: if max(z) - min(z) >= x: v+=1 print(v)",np,"['bitmasks', 'brute force']",300
"[n, l, r, x] = list(map(int, input().strip().split())) Cs = list(sorted(map(int, input().strip().split()))) probs = 0 for i in range(1, 2**n): currsub = [ Cs[j] for j in range(n) if (i & (1 << j))] probs += (len(currsub) > 1 and l <= sum(currsub) <= r and currsub[-1] - currsub[0] >= x) print(probs)",np,"['bitmasks', 'brute force']",299
"n, l, r, x = list(map(int, input().split("" ""))) c = sorted(list(map(int, input().split("" "")))) ways = 0 for i in range(0, 2 ** n): temp = 0 m = 10 ** 9 + 1 M = -1 for j in range(0, n): if i & 1 << j: temp += c[j] m = min(m, c[j]) M = max(M, c[j]) if temp >= l and temp <= r and (M - m) >= x: ways += 1 print(ways)",np,"['bitmasks', 'brute force']",313
"kk=lambda:map(int, input().split()) ll=lambda:list(kk()) n,l,r,d=kk() p,t=ll(),0 for v in range(2**n): s = [] for i in range(n): if v&(2**i): s.append(p[i]) if l <= sum(s)<=r and max(s)-min(s) >= d: t+=1 print(t)",np,"['bitmasks', 'brute force']",212
"from sys import stdin, stdout, setrecursionlimit from collections import deque, defaultdict from bisect import bisect_left def check(temp): if len(temp) < 2: return False else: s = sum(temp) if s >= l and s <= r: if temp[-1] - temp[0] >= x: return True else: return False else: return False def brute(index, temp): global count if index == n: if check(temp): count += 1 else: temp.append(arr[index]) brute(index + 1, temp) temp.pop() brute(index + 1, temp) n, l, r, x = list(map(int, stdin.readline().split())) arr = list(map(int, stdin.readline().split())) arr.sort() count = 0 temp = [] brute(0, temp) print(count)",np,"['bitmasks', 'brute force']",616
"def check(j): if sum(j)>=l and sum(j)<=r and (max(j)-min(j))>=x: return 1 return 0 from itertools import combinations n,l,r,x=list(map(int,input().split())) c=list(map(int,input().rstrip().split())) count=0 for i in range(2,n+1): a=list(combinations(c,i)) for j in a: if check(j): count+=1 print(count)",np,"['bitmasks', 'brute force']",302
"from itertools import combinations n, l, r, x = map(int,input().split()) a = list(map(int,input().split())) print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np,"['bitmasks', 'brute force']",223
"def solve(): n, l, r, x = map(int, input().split(' ')) c = list(map(int, input().split(' '))) ans = 0 for bitmask in range(2 ** n): if bin(bitmask).count('1') > 1: res, _min, _max = 0, float('+inf'), float('-inf') for c_i, bit_i in zip(c, (1 & int(bitmask) >> i for i in range(n))): if bit_i: res += c_i * bit_i if c_i < _min: _min = c_i if c_i > _max: _max = c_i if l <= res <= r and (_max - _min) >= x: ans += 1 print(ans) if __name__ == '__main__': solve()",np,"['bitmasks', 'brute force']",459
"n,l,r,d=[int(i) for i in input().split()] op=[int(i) for i in input().split()] c=0 for i in range(2,2**n): s=0 k=0 maxx=0 minn=1000001 x=bin(i)[2:] x='0'*(n-len(x))+x for j in range(n): if x[j]=='1': s+=op[j] k+=1 if maxx<op[j]: maxx=op[j] if op[j]<minn: minn=op[j] if l<=s<=r and maxx-minn>=d and k>=2: c+=1 print(c)",np,"['bitmasks', 'brute force']",317
"from itertools import combinations n,l,r,x = map(int,input().split()) a=list(map(int,input().split())) c=[] for i in range(2,n+1): c+=list(combinations(a,i)) cnt=0 for t in c: m=min(t) M=max(t) s=sum(t) if M-m >=x and (s>=l and s<=r): cnt+=1 print(cnt)",np,"['bitmasks', 'brute force']",252
"import sys def fastio(): from io import StringIO from atexit import register global input sys.stdin = StringIO(sys.stdin.read()) input = lambda : sys.stdin.readline().rstrip('\r\n') sys.stdout = StringIO() register(lambda : sys.__stdout__.write(sys.stdout.getvalue())) fastio() def debug(*var, sep = ' ', end = '\n'): print(*var, file=sys.stderr, end = end, sep = sep) INF = 10**20 MOD = 10**9 + 7 I = lambda:list(map(int,input().split())) from math import gcd from math import ceil from collections import defaultdict as dd, Counter from bisect import bisect_left as bl, bisect_right as br n, l, r, x = I() a = I() ans = 0 for i in range(1, 2 ** n): if i & (i - 1) == 0: continue mn, mx, total = INF, -INF, 0 for j in range(n): if (i >> j) & 1: mn = min(mn, a[j]) mx = max(mx, a[j]) total += a[j] if l <= total <= r and mx - mn >= x: ans += 1 print(ans)",np,"['bitmasks', 'brute force']",854
"import math as mt import itertools as it n,l,r,x=map(int,input().split()) a=list(map(int,input().split())) ans=0 for j in range(2,n+1): for i in it.combinations(a,j): if max(i)-min(i)>=x and l<=sum(i)<=r: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",222
"from itertools import chain, combinations def powerset(iterable): xs = list(iterable) return list(chain.from_iterable(combinations(xs,n) for n in range(2,len(xs)+1))) n,l,r,x=map(int,input().split()) sett=list(map(int,input().split())) psett=powerset(sett) count=0 for i in psett: k=sorted(i) j=sum(k) if j>=l and j<=r and k[-1]-k[0]>=x: count+=1 print(count)",np,"['bitmasks', 'brute force']",359
"import sys n, l, r, x = map(int, input().split()) temp = [] temp = list(map(int, input().split())) temp.sort() ans = 0 for i in range(1 << n): score = 0 _min = sys.maxsize _max = -sys.maxsize for j in range(n): if i & (1 << j) > 0: _min = min(_min, temp[j]) _max = max(_max, temp[j]) score += temp[j] if score >= l and score <= r and _max-_min >= x: ans += 1 print(ans)",np,"['bitmasks', 'brute force']",369
"from itertools import * n,least,highest,x = map(int,input().split()) l = [*map(int,input().split())] cnt = 0 for i in range(2,n + 1): combination = [*map(list,combinations(l,i))] for j in range(len(combination)): combination[j].sort() total = sum(combination[j]) if(total >= least and total <= highest and combination[j][-1] - combination[j][0] >= x): cnt += 1 print(cnt)",np,"['bitmasks', 'brute force']",371
"n, l, r, x = map(int, input().split()) tasks = list(map(int, input().split())) mask = 3 ans = 0 while (mask < (1 << n)): sum_dif = 0 min_diff = float(""inf"") max_diff = -float(""inf"") if (mask & (mask-1)): for i in range(n): if (mask & (1 << i)): sum_dif += tasks[i] min_diff = min(min_diff, tasks[i]) max_diff = max(max_diff, tasks[i]) if (x <= (max_diff - min_diff)) and (l <= sum_dif <= r): ans += 1 mask += 1 print(ans)",np,"['bitmasks', 'brute force']",421
"n, l, r, x = map(int, input().split()) C = sorted(list(map(int, input().split()))) ANS = 0 for i in range(2 ** n): s = bin(i)[2:] s = '0' * (n - len(s)) + s L = [] for j in range(n): if s[j] == '1': L.append(C[j]) if len(L) < 2 or not (l <= sum(L) <= r) or L[-1] - L[0] < x: continue ANS += 1 print(ANS)",np,"['bitmasks', 'brute force']",303
"def I(): return(list(map(int,input().split()))) n,l,r,x=I() c=I() l1=list(range(2**n)) ans=0 for j in l1: s=0 num=0 ma=0 mi=100000000 for i in range(n): if (j & 1<<i): num+=1 s+=c[i] ma=max(c[i],ma) mi=min(c[i],mi) if s<=r and l<=s and(ma-mi>=x) and num>=2 : ans+=1 print(ans)",np,"['bitmasks', 'brute force']",276
"n,l,r,x = map(int,input().split()) a = list(map(int,input().split())) count=0 for i in range(2**n): maxc=-1 minc=-1 c=0 for j in range(n): if i>>j&1==1: c+=a[j] maxc=max(maxc,a[j]) if minc==-1: minc=a[j] else: minc=min(a[j],minc) if c>=l and c<=r and maxc - minc >=x: count+=1 print(count)",np,"['bitmasks', 'brute force']",289
"I = lambda: map(int,input().split()) n,l,r,x=I() C,k=[*I()],0 for i in range(2**n): W = [w for w,b in zip(C, bin(i)[2:].zfill(n)) if b=='1'] if l <= sum(W) <= r and max(W)-min(W) >= x: k += 1 print(k)",np,"['bitmasks', 'brute force']",200
"from itertools import combinations p, minn, maxn, dif = map(int, input().split()) (*lst,) = map(int, input().split()) c = 0 for i in range(2, p + 2): for j in combinations(lst, i): if (maxn >= sum(j) >= minn) and (max(j) - min(j) >= dif): c += 1 print(c)",np,"['bitmasks', 'brute force']",254
"from itertools import combinations p, minn, maxn, dif = map(int, input().split()) (*lst,) = map(int, input().split()) print(sum([sum([(maxn>=sum(j)>=minn)and((max(j)-min(j))>=dif) for j in combinations(lst,i)]) for i in range(2,p+1)]))",np,"['bitmasks', 'brute force']",235
"import itertools n, l, r, x = map(int, input().split()) C = list(map(int, input().split())) ans = 0 for i in range(2, n+1): for c in itertools.combinations(C, i): d = sum(c) if d < l or d > r: continue if max(c) - min(c) < x: continue ans += 1 print(ans)",np,"['bitmasks', 'brute force']",254
"from itertools import combinations n, l, r, x = map(int, input().split()) a = [int(x) for x in input().split()] ans = 0 for i in range(2, n+1): for p in combinations(a, i): if l<=sum(p)<=r and max(p)-min(p)>=x: ans += 1 print(ans)",np,"['bitmasks', 'brute force']",230
"n,l,r,x = map(int,input().split()) c = list(map(int,input().split())) res = 0 for i in range(1 << n): Bit = [] for j in range(n): if i & (1 << j): Bit.append(c[j]) if (len(Bit) >= 2) and (l<= sum(Bit) <= r) and (max(Bit) - min(Bit) >= x): res+= 1 print(res)",np,"['bitmasks', 'brute force']",257
"n,l,r,x = [int(x) for x in input().split("" "")] arr = [int(x) for x in input().split("" "")] ans = 0 for i in range(2**n): subset = [] for j in range(n): if (i & (1 << j)) != 0: subset.append(arr[j]) if len(subset)>1: mx = max(subset) mn = min(subset) sm = sum(subset) if l<=sm<=r and mx-mn>=x: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",309
"n,l,r,x=map(int,input().split()) import math z=list(map(int,input().split())) count=0 for i in range(pow(2,len(z))): mini=math.inf maxa=0 j=i inde=0 sume=0 while(j>0): if(j&1): sume+=z[inde] maxa=max(maxa,z[inde]) mini=min(mini,z[inde]) j=j>>1 inde+=1 if(maxa-mini>=x and l<=sume<=r): count+=1 print(count)",np,"['bitmasks', 'brute force']",306
"def check_combos(diff,n,size,start,picked,total,l,r,x,combination = []): if picked == size: if max(combination) - min(combination) >= x and l <= sum(combination) <= r: total += 1 else: for i in range(start,n-(size-picked-1)): combination.append(diff[i]) picked += 1 total = check_combos(diff,n,size,i+1,picked,total,l,r,x,combination) picked -= 1 combination.pop() return total def prog(): n,l,r,x = map(int,input().split()) diff = list(map(int,input().split())) suitable_problemsets = 0 for size in range(1,n+1): suitable_problemsets += check_combos(diff,n,size,0,0,0,l,r,x) print(suitable_problemsets) prog()",np,"['bitmasks', 'brute force']",610
"import sys input = sys.stdin.readline from math import ceil, floor, factorial; def swaparr(arr, a,b): temp = arr[a]; arr[a] = arr[b]; arr[b] = temp def gcd(a,b): if a == 0: return b return gcd(b%a, a) def nCr(n, k): if(k > n - k): k = n - k res = 1 for i in range(k): res = res * (n - i) res = res / (i + 1) return int(res) def upper_bound(a, x, lo=0): hi = len(a) while lo < hi: mid = (lo+hi)//2 if a[mid] < x: lo = mid+1 else: hi = mid return lo def primefs(n): primes = {} while(n%2 == 0): primes[2] = primes.get(2, 0) + 1 n = n//2 for i in range(3, int(n**0.5)+2, 2): while(n%i == 0): primes[i] = primes.get(i, 0) + 1 n = n//i if n > 2: primes[n] = primes.get(n, 0) + 1 return primes def power(x, y, p): res = 1 x = x % p if (x == 0) : return 0 while (y > 0) : if ((y & 1) == 1) : res = (res * x) % p y = y >> 1 x = (x * x) % p return res def swap(a,b): temp = a a = b b = temp return a,b def find(x, link): p = x; while( p != link[p]): p = link[p]; while( x != p): nex = link[x]; link[x] = p; x = nex; return p; def union(x, y, link, size): x = find(x, link) y = find(y, link) if size[x] < size[y]: x,y = swap(x,y) if x != y: size[x] += size[y] link[y] = x def sieve(n): prime = [True for i in range(n+1)] p = 2 while (p * p <= n): if (prime[p] == True): for i in range(p * p, n+1, p): prime[i] = False p += 1 return prime MAXN = int(1e6 + 5) def spf_sieve(): spf[1] = 1; for i in range(2, MAXN): spf[i] = i; for i in range(4, MAXN, 2): spf[i] = 2; for i in range(3, ceil(MAXN ** 0.5), 2): if spf[i] == i: for j in range(i*i, MAXN, i): if spf[j] == j: spf[j] = i; def factoriazation(x): ret = {}; while x != 1: ret[spf[x]] = ret.get(spf[x], 0) + 1; x = x//spf[x] return ret def int_array(): return list(map(int, input().strip().split())) def str_array(): return input().strip().split(); MOD = int(1e9)+7; CMOD = 998244353; INF = float('inf'); NINF = -float('inf'); n, l, r, x = int_array(); a = sorted(int_array()); ans = 0; for mask in range( 1 << n): mx = NINF; mn = INF; sub = 0; for i in ra",np,"['bitmasks', 'brute force']",1999
"def find(a,b): cc=2 for i in range(1,(1<<len(a))): sx=0 minn=100000000 maxn=-1 for j in range(0,len(a)): if(i &(1<<j)): sx+= a[j]; minn = min(minn, a[j]) maxn = max(maxn, a[j]) if(sx>=b[1] and sx<=b[2] and (maxn-minn)>=b[3]): cc+=1 if(cc<2): return 2 else: return cc-2 b=list(map(int,input().split())) a=list(map(int,input().split())) print(find(a,b))",np,"['bitmasks', 'brute force']",351
"from itertools import combinations n , l , r ,x = map(int,input().split()) a = list(map(int, input().split())) c = 0 for i in range(1,n+1): for j in combinations(a,i): if (l<=sum(j)<=r and max(j)-min(j)>=x): c+=1 print(c)",np,"['bitmasks', 'brute force']",221
"from itertools import combinations n, l, r, x = map(int, input().split()) (*a,) = map(int, input().split()) sumu = 0 for i in range(2, n + 2): for j in combinations(a, i): if (r >= sum(j) >= l) and (max(j) - min(j) >= x): sumu += 1 print(sumu)",np,"['bitmasks', 'brute force']",243
"from itertools import combinations n, l, r, x = map(int, input().split()) a = list(map(int, input().split())) arr = [] for i in range(2, n+1): ar = combinations(a, i) for j in ar: arr += [(list(j))] count = 0 for i in arr: dif = max(i) - min(i) total = sum(i) if dif >= x and (total >= l and total <= r): count +=1 print(count)",np,"['bitmasks', 'brute force']",327
"def combinations(arr,n): if(n==0): return([[]]) l=[] for i in range(len(arr)): m=arr[i] rem=arr[i+1:] for j in combinations(rem,n-1): l.append([m]+j) return l def solve(arr,n,l,r,x): subset=[] for i in range(2,n+1): for j in combinations(arr,i): if(sum(j)>=l and sum(j)<=r): subset.append(j) count=0 for i in subset: mn=min(i) mx=max(i) if(mx-mn>=x): count+=1 return(count) n,l,r,x=map(int,input().split()) arr=list(map(int,input().split())) print(solve(arr,n,l,r,x))",np,"['bitmasks', 'brute force']",467
"def GSB(x): counter=0 while x!=0: counter+=1 x=x>>1 return counter problems,minimum,maximum,difference=[int(x) for x in input().split()] array=[int(x) for x in input().split()] combinations=[int(x) for x in range(2**problems)] total=0 for i in combinations: checker=[x for x in array]+['a'] j=0 z=GSB(i) check=1 while j!=z and i!=0: if i&1==1: checker[j]='a' check+=1 i=i>>1 j+=1 for i in range(check): checker.remove('a') checker.sort() if minimum<=sum(checker)<=maximum and len(checker)>=2 and checker[-1]-checker[0]>=difference: total+=1 print(total)",np,"['bitmasks', 'brute force']",553
"from sys import stdin,stdout from math import gcd, ceil, sqrt from itertools import combinations from collections import Counter from bisect import bisect_left, bisect_right ii1 = lambda: int(stdin.readline().strip()) is1 = lambda: stdin.readline().strip() iia = lambda: list(map(int, stdin.readline().strip().split())) isa = lambda: stdin.readline().strip().split() mod = 1000000007 n, l, r, x = iia() arr = iia() count = 0 for i in range(2, n + 1): t = combinations(arr, i) for j in t: if sum(j) >= l and sum(j) <= r \ and max(j) - min(j) >= x: count += 1 print(count)",np,"['bitmasks', 'brute force']",570
"from sys import stdin from itertools import combinations n, l, r , x = map(int, stdin.readline().rstrip().split("" "")) li = list(map(int, stdin.readline().rstrip().split("" ""))) z = [] ans = 0 for i in range(2, n+1): z += list(combinations(li, i)) for i in z: a = sorted(i) if a[-1]-a[0]>=x and r >= sum(a) >= l: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",328
"import itertools n,l,r,x=map(int,input().split()) problems=[int(x) for x in input().split()] result=0 for i in range(2,n+1): for comb in itertools.combinations(problems,i): summ = sum(comb) mini = min(comb) maxx = max(comb) if l <= summ <=r and maxx-mini>=x: result+=1 print(result)",np,"['bitmasks', 'brute force']",282
"n,l,r,x = map(int,input().split()) c = list(map(int,input().split())) ans = 0 for mask in range(1 << n): a = [] for bit in range(n): if mask & (1 << bit): a.append(c[bit]) if len(a) >= 2 and max(a) - min(a) >= x and l <= sum(a) and sum(a) <= r: ans += 1 print(ans)",np,"['bitmasks', 'brute force']",264
"import itertools n,l,r,x=map(int,input().split()) problems=[int(x) for x in input().split()] result=0 for i in range(2,n+1): for comb in itertools.combinations(problems,i): summ = sum(comb) mini = min(comb) maxx = max(comb) if l <= summ <=r and maxx-mini>=x: result+=1 print(result)",np,"['bitmasks', 'brute force']",282
"def suma_o_resta(a, b): return (a & (1<<b)) def diferencia(s1, d): if s1: s1.sort() if s1[-1] - s1[0] >= d: return s1 else: return diferencia(s1.remove(s1[-1]), d) return s1 def no_sets(v, n, l, r, d): s = [] cont = 0 for x in range(1<<n): for i in range(n): if suma_o_resta(x, i) > 0: s.append(v[i]) s = diferencia(s, d) if s: if sum(s) >= l and sum(s) <= r: cont += 1 s = [] return cont; n, l, r, x = map(int, input().split()) v = list(map(int, input().split())) print(str(no_sets(v, n, l, r, x)))",np,"['bitmasks', 'brute force']",499
"def isValidSet(problemSet: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> bool: if len(problemSet) >= 2: total = sum(problemSet) myDelta = max(problemSet) - min(problemSet) if minTotalDif <= total <= maxTotalDif and myDelta >= minDelta: return True return False def countValidSubsets(problems: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> int: def subsetBuilder (problems: list, currentSubset: list, nextElementIndex: int) -> None: if isValidSet(currentSubset, minTotalDif, maxTotalDif, minDelta): validSubsets.append(currentSubset) for i in range(nextElementIndex, len(problems)): currentSubset.append(problems[i]) subsetBuilder(problems, currentSubset, i+1) currentSubset.pop(-1) index = 0 currentSubset = [] validSubsets = [] subsetBuilder(problems, currentSubset, index) return len(validSubsets) n, l, r, x = input().split() n = int(n) l = int(l) r = int(r) x = int(x) probs = [int(prob) for prob in input().split()] print(countValidSubsets(probs, l, r, x))",np,"['bitmasks', 'brute force']",989
"n, l, r, x = map(int, input().split()) c = list(map(int, input().split())) from itertools import combinations ways_to_choose = 0 for length in range(2, n + 1): for p in combinations(c, length): problemset = sorted(p) if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x: ways_to_choose += 1 print(ways_to_choose)",np,"['bitmasks', 'brute force']",328
"from itertools import combinations as cmb n ,l ,r ,x = map(int , input().split()) *a , = map(int ,input().split()) b = [] a.sort() for i in range(2 ,n+1): b.extend(cmb(a ,i)) ans = 0 for i in b: if(sum(i) >= l and sum(i) <= r): if(i[-1]-i[0] >= x): ans+=1 print(ans)",np,"['bitmasks', 'brute force']",266
"def fact(x): if x == 0: return 1 else: return x * fact(x-1) def lower_bound(li, num): answer = -1 start = 0 end = len(li)-1 while(start <= end): middle = (end+start)//2 if li[middle] >= num: answer = middle end = middle - 1 else: start = middle + 1 return answer def upper_bound(li, num): answer = -1 start = 0 end = len(li)-1 while(start <= end): middle = (end+start)//2 if li[middle] <= num: answer = middle start = middle + 1 else: end = middle - 1 return answer def abs(x): return x if x >=0 else -x def binary_search(li, val, lb, ub): ans = 0 while(lb <= ub): mid = (lb+ub)//2 if li[mid] > val: ub = mid-1 elif val > li[mid]: lb = mid + 1 else: ans = 1 break return ans def kadane(x): sum_so_far = 0 current_sum = 0 for i in x: current_sum += i if current_sum < 0: current_sum = 0 else: sum_so_far = mpos(sum_so_far,current_sum) return sum_so_far def pref(li): pref_sum = [0] for i in li: pref_sum.append(pref_sum[-1] + i) return pref_sum def graph(n,m): adj = dict() for i in range(1,n+1): adj.setdefault(i,0) for i in range(m): a,b = map(int,input().split()) adj[a] += 1 adj[b] += 1 return adj import sys import threading from math import * for _ in range(1): n,l,r,x = map(int,input().split()) a = list(map(int,input().split())) cnt = 0 for mask in range(1,(1<<n)+1): mini = 10**9 + 10 maxi = 0 elem = 0 sumi = 0 for j in range(n): if mask & (1<<j): elem += 1 sumi += a[j] mini = min(mini, a[j]) maxi = max(maxi, a[j]) if elem >= 2: if (l <= sumi <= r) and (maxi-mini >= x): cnt += 1 print(cnt)",np,"['bitmasks', 'brute force']",1502
"n,l,r,x = map(int,input().split()) A = list(map(int,input().split())) count = 0 for i in range(1<<n): total = 0 mn = 1e6 mx = -1e6 for k in range(n): if (i & (1<<k)): total += A[k] mn = min(A[k],mn) mx = max(A[k],mx) if total<=r and total>=l and mx-mn>=x: count += 1 print(count)",np,"['bitmasks', 'brute force']",279
"import itertools n , l , r , x = map(int,input().split()) problems = list(map(int,input().split())) ans = 0 for i in range(2 , n + 1 ): for j in itertools.combinations(problems ,i): if (l <= sum(j) <= r and max(j) - min(j) >= x): ans +=1 print(ans)",np,"['bitmasks', 'brute force']",248
"n,l,r,x = [int(x) for x in input().split()] a = [int(x) for x in input().split()] cnt =0 for i in range(0,1<<n): sum=0;mn=int(1e18);mx=0; for j in range(0,n): if((i>>j)&1): sum += a[j] mn = min(mn,a[j]) mx = max(mx,a[j]) if (sum>=l and sum<=r and (mx-mn)>=x): cnt +=1 print(cnt)",np,"['bitmasks', 'brute force']",278
"n,least,most,x = map(int,input().split()) c = list(map(int,input().split())) ans= 0 _max = lambda x,y: x if x>y else y _min = lambda x,y: x if x<y else y for mask in range(1<<n): mx = float('-inf') mn = float('inf') count = 0 Sum = 0 for i in range(n): if mask&(1<<i): count+=1 Sum+=c[i] mx = _max(mx,c[i]) mn = _min(mn,c[i]) if mx-mn>=x and Sum>=least and Sum<=most and count >=2: ans+=1 print(ans)",np,"['bitmasks', 'brute force']",399
"n,l,r,x=map(int,input().split()) c=list(map(int,input().split())) c.sort() p=1<<n cnt=0 for j in range(p): list1=[] if(j>0 and j&(j-1)!=0): for k in range(n): if(j&(1<<k)): list1.append(c[k]) if(sum(list1)>=l and sum(list1)<=r and list1[-1]-list1[0]>=x): cnt+=1 print(cnt)",np,"['bitmasks', 'brute force']",272
"import sys from array import array import typing as Tp def input(): return sys.stdin.buffer.readline().decode('utf-8') def output(*args): sys.stdout.buffer.write( ('\n'.join(map(str, args)) + '\n').encode('utf-8') ) def main(): n, m, k = map(int, input().split()) a = list(map(float, input().split())) add = [[0] * n for _ in range(n + 1)] for xi, yi, ci in (map(int, input().split()) for _ in range(k)): add[xi - 1][yi - 1] = float(ci) minf = float('-inf') dp = [[minf] * (2**n) for _ in range(n + 1)] dp[n][0] = 0.0 for bitset in range(2**n): if bin(bitset).count('1') >= m: continue for i in range(n + 1): if dp[i][bitset] == minf: continue for j in range(n): if (1 << j) & bitset: continue dp[j][bitset | (1 << j)] = max( dp[j][bitset | (1 << j)], dp[i][bitset] + a[j] + add[i][j] ) print(int(max(max(_dp) for _dp in dp) + 1e-7)) if __name__ == '__main__': main()",np,"['bitmasks', 'dp']",867
"import os import sys from io import BytesIO,IOBase def main(): n,m,k = map(int,input().split()) a = list(map(float,input().split())) tree = [[0]*n for _ in range(n)] for i in range(k): x,y,z = map(int,input().split()) tree[x-1][y-1] = float(z) po = [1] while len(po) != n: po.append(po[-1]*2) dp = [[0]*(po[-1]*2) for _ in range(n)] for i in range(n): dp[i][po[i]] = a[i] for i in range(po[-1]*2): for j in range(n): if i&po[j]: for k in range(n): if not (i&po[k]): dp[k][i+po[k]] = max(dp[k][i+po[k]],dp[j][i]+a[k]+tree[j][k]) ma = 0 for i in range(po[-1]*2): if bin(i)[2:].count(""1"") == m: for j in range(n): ma = max(ma,dp[j][i]) print(int(ma)) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self,file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE)) self.newlines = b.count(b""\n"")+(not b) ptr = self.buffer.tell() self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd,self.buffer.getvalue()) self.buffer.truncate(0),self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self,file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s:self.buffer.write(s.encode(""ascii"")) self.read = lambda:self.buffer.read().decode(""ascii"") self.readline = lambda:self.buffer.readline().decode(""ascii"") sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout) input = lambda:sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": ma",np,"['bitmasks', 'dp']",2000
"a,b,c,d,e,f=list(map(int,input().split())) n,n2=1,a*b+c*d+e*f while n**2<n2: n+=1 if n**2>n2: print(-1) exit() l=sorted([[max(a,b),min(a,b),'A'],[max(c,d),min(d,c),'B'],[max(e,f),min(e,f),'C']]) if l[2][0]!=n: print(-1) exit(0) v=str(n)+'\n'+(l[2][2]*n+'\n')*l[2][1] if l[0][0]==n and l[1][0]==n: for i in range(2): v+=(l[i][2]*n+'\n')*l[i][1] else: s=n-l[2][1] if s not in l[0] or s not in l[1]: print(-1) exit() if s!=l[0][0]: l[0][0],l[0][1]=l[0][1],l[0][0] if s!=l[1][0]: l[1][0],l[1][1]=l[1][1],l[1][0] v+=(l[0][2]*l[0][1]+l[1][2]*l[1][1]+'\n')*s print(v)",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",560
"import os import sys from math import * from collections import * from bisect import * from io import BytesIO, IOBase def vsInput(): sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") ALPHA='abcdefghijklmnopqrstuvwxyz' M=998244353 EPS=1e-6 def Ceil(a,b): return a//b+int(a%b>0) def value():return tuple(map(int,input().split())) def array():return [int(i) for i in input().split()] def Int():return int(input()) def Str():return input() def arrayS():return [i for i in input().split()] def ok(a,b,c): n = a[0][-1] ans = [] for i in range(a[0][0]): ans.append([a[1]]*n) l = n r = n - a[0][0] for i in range(2): for j in range(2): l1,r",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",1999
"def possible(arr): a,b,c,d,e,f = arr if(a == c == e and b + d + f == a): one = ""A"" * b + ""B"" * d + ""C"" * f print(a) for i in range(a): print(one) return True if(b == d == f and a + c + e == d): print(b) for i in range(a): print(""A"" * b) for i in range(c): print(""B"" * b) for i in range(e): print(""C"" * b) return True ns = [(a,b,""A""),(c,d,""B""),(e,f,""C"")] fs = [(b, a,""A""),(d, c,""B""),(f, e,""C"")] ns.sort(reverse = True) x,y,z = ns a,b,t1 = x c,d,t2 = y e,f,t3 = z if(c + e == a and d == f and d + b == a): print(a) mat = [[""."" for i in range(a)] for j in range(a)] for i in range(a): for j in range(b): mat[i][j] = t1 for i in range(c): for j in range(b, a): mat[i][j] = t2 for i in range(c, a): for j in range(b, a): mat[i][j] = t3 for i in range(a): print("""".join(mat[i])) return True fs.sort(reverse = True) x,y,z = fs b,a,t1 = x d,c,t2 = y f,e,t3 = z if(d + f == b and c == e and c + a == b): print(b) mat = [[""."" for i in range(b)] for j in range(b)] for i in range(a): for j in range(b): mat[i][j] =t1 for i in range(a, b): for j in range(d): mat[i][j] = t2 for i in range(a, b): for j in range(d, b): mat[i][j] = t3 for i in range(b): print("""".join(mat[i])) return True return False arr = [int(x) for x in input().split()] cnt = 0 ok = False for i in range(8): send = [x for x in arr] if(i&1): send[0], send[1] = send[1], send[0] if(i&2): send[2], send[3] = send[3], send[2] if(i&4): send[4], send[5] = send[5], send[4] if(possible(send)): ok = True break if(not ok): print(-1)",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",1482
"ii=lambda:int(input()) kk=lambda:map(int, input().split()) ll=lambda:list(kk()) a,b,c,d,e,f=kk() al = [a,b,c,d,e,f] s = sum(al) area = a*b+c*d+e*f side = int(area**.5) if side**2 != area or side not in al: print(-1) exit() if al.count(side) == 3: if s == 4*side: rest = [a for a in al if a != side] print(side) for _ in range(side): print("""".join([""A""*rest[0], ""B""*rest[1], ""C""*rest[2]])) elif al.count(side) > 1: print(-1) else: x=al.index(side) y=x^1 res = al[y] a,b=min(x,y),max(x,y) s1 = ""ABC""[a//2] s23 = [s for s in ""ABC"" if s != s1] rest = al[:a]+al[b+1:] res = side - res a,b=[rest[0],rest[1]],[rest[2],rest[3]] if not (res in a and res in b): print(-1) exit() o1,o2 = a[a.index(res)^1],b[b.index(res)^1] print(side) for _ in range(al[y]): print(s1*side) for _ in range(res): print("""".join([s23[0]*o1,s23[1]*o2]))",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",821
"import math xy = list(map(int,input().split())) x = [[xy[0],xy[2],xy[4]],[xy[1],xy[3],xy[5]]] aa = 0 max_ll = 0 for i in range(3): aa += x[0][i]*x[1][i] max_ll = max(max_ll,x[0][i],x[1][i]) bb = math.sqrt(aa) if bb*bb!=aa or max_ll!=bb: print(-1) else: bb = int(bb) mt = [['']*bb for _ in range(bb)] max_l = 0 chars = ['A','B','C'] x = [[xy[0],xy[1]],[xy[2],xy[3]],[xy[4],xy[5]]] max_lp = -1 max_li = -1 ii=0 oh = [] for i in x: if max(i)>=max_l: max_l = max(i) max_lp = sum(i)-max(i) max_li = ii ii+=1 max_ls = [] ii=0 for i in x: if max(i)==max_l: max_ls.append(i+[ii]) else: oh+=[ii] ii+=1 if len(max_ls)==3: for i in range(max_l): for j in range(max_l): if i<(max_ls[0][0]+max_ls[0][1]-max_l): mt[i][j] = chars[max_ls[0][2]] elif i<(max_ls[0][0]+max_ls[0][1]-max_l + max_ls[1][0]+max_ls[1][1]-max_l): mt[i][j] = chars[max_ls[1][2]] else: mt[i][j] = chars[max_ls[2][2]] else: for i in range(max_lp): for j in range(max_l): mt[i][j] = chars[max_li] bb = max_l-max_lp for i in range(max_lp,max_l): for j in range(max_l): if j<(sum(x[oh[0]])-bb): mt[i][j] = chars[oh[0]] else: mt[i][j] = chars[oh[1]] print(max_l) for j in mt: print(''.join(j))",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",1144
"a , b , c , d , e , f = map(int,input().split()) n , n1 = 1 , a * b + c * d + e * f while n ** 2 < n1 : n += 1 if n ** 2 > n1 : print(-1) exit() l = sorted([[max(a,b),min(a,b),'A'], [max(c,d),min(c,d),'B'], [max(e,f),min(e,f),'C']]) if l[2][0] != n: print(-1) exit() v = str(n) + '\n' + (l[2][2] * n + '\n') * l[2][1] if l[0][0] == n and l[1][0] == n: for i in range(2): v += (l[i][2] * n + '\n') * l[i][1] else: s = n - l[2][1] if s not in l[0] or s not in l[1] : print(-1) exit() x , y = l[0][1] if s == l[0][0] else l[0][0] , l[1][1] if s == l[1][0] else l[1][0] v += (l[0][2] * x + l[1][2] * y + '\n') * s print(v)",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",618
"a1, a2, b1, b2, c1, c2 = map(int, input().split()) l = max([a1, a2, b1, b2, c1, c2]) if (a1*a2 + b1*b2 + c1*c2 != l**2): print(-1) else: if a1 > a2: a1, a2 = a2, a1 if b1 > b2: b1, b2 = b2, b1 if c1 > c2: c1, c2 = c2, c1 if a2 == b2 and b2 == c2: print(l) for i in range(a1): print('A'*a2) for i in range(b1): print('B'*b2) for i in range(c1): print('C'*c2) else: ls = [[a1, a2, 'A'], [b1, b2, 'B'], [c1, c2, 'C']] if b2 == l: ls[0], ls[1] = ls[1], ls[0] if c2 == l: ls[0], ls[2] = ls[2], ls[0] valid = True if ls[1][0] == ls[2][0]: pass elif ls[1][1] == ls[2][1]: ls[1][0], ls[1][1] = ls[1][1], ls[1][0] ls[2][0], ls[2][1] = ls[2][1], ls[2][0] elif ls[1][0] == ls[2][1]: ls[2][0], ls[2][1] = ls[2][1], ls[2][0] elif ls[1][1] == ls[2][0]: ls[1][0], ls[1][1] = ls[1][1], ls[1][0] else: valid = False if (ls[1][0] + ls[0][0] != l) or (ls[1][1] + ls[2][1] != l): valid = False if not valid: print(-1) else: print(l) for i in range(ls[0][0]): print(ls[0][2] * l) for i in range(ls[1][0]): print(ls[1][2] * ls[1][1] + ls[2][2] * ls[2][1])",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",1033
"from sys import stdin from itertools import permutations rints = lambda: [int(x) for x in stdin.readline().split()] x1, y1, x2, y2, x3, y3 = rints() for x in [[x1, y1], [y1, x1]]: for y in [[x2, y2], [y2, x2]]: for z in [[x3, y3], [y3, x3]]: if x[1] == y[1] == z[1] and x[0] + y[0] + z[0] == x[1]: print(x[1]) print('\n'.join( ['A' * x[1] for _ in range(x[0])] + ['B' * x[1] for _ in range(y[0])] + ['C' * z[1] for _ in range(z[0])])) exit() for per in permutations([[[x1, y1], [y1, x1], 'A'], [[x2, y2], [y2, x2], 'B'], [[x3, y3], [y3, x3], 'C']], 3): for x in per[0][:-1]: for y in per[1][:-1]: for z in per[2][:-1]: if x[1] == (y[1] + z[1]) and y[0] == z[0] and x[1] == x[0] + y[0]: print(x[1]) print('\n'.join( [per[0][-1] * x[1] for _ in range(x[0])] + [per[1][-1] * y[1] + per[2][-1] * z[1] for _ in range(y[0])])) exit() print(-1)",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",837
"x1, y1, x2, y2, x3, y3 = map(int, input().split()) rect1 = [x1, y1] rect2 = [x2, y2] rect3 = [x3, y3] def func(): rect11 = [x1, y1] rect22 = [x2, y2] rect33 = [x3, y3] rect1 = [x1, y1] rect2 = [x2, y2] rect3 = [x3, y3] recta = [x1, y1] rectb = [x2, y2] rectc = [x3, y3] for i in rect11: for ii in rect22: for iii in rect33: if i==ii: rect1.remove(i) rect2.remove(ii) if rect1[0]+rect2[0]==iii: rect3.remove(iii) if i+rect3[0]==iii: print(iii) for j in range(iii): if j<rect1[0]: print(""C""*rect3[0]+""A""*i) else: print(""C""*rect3[0]+""B""*ii) exit() rect1=recta.copy() rect2=rectb.copy() rect3=rectc.copy() if i==iii: rect1.remove(i) rect3.remove(iii) if rect1[0]+rect3[0]==ii: rect2.remove(ii) if i+rect2[0]==ii: print(ii) for j in range(ii): if j<rect1[0]: print(""B""*rect2[0]+""A""*i) else: print(""B""*rect2[0]+""C""*iii) exit() rect1 = recta.copy() rect2 = rectb.copy() rect3 = rectc.copy() if ii==iii: rect2.remove(ii) rect3.remove(iii) if rect2[0]+rect3[0]==i: rect1.remove(i) if i==rect1[0]+ii: print(i) for j in range(i): if j<rect2[0]: print(""A""*rect1[0]+""B""*ii) else:print(""A""*rect1[0]+""C""*iii) exit() rect1=recta.copy() rect2=rectb.copy() rect3=rectc.copy() return print(-1) for i in rect1: for ii in rect2: for iii in rect3: recta = [x1, y1] rectb = [x2, y2] rectc = [x3, y3] if i==ii==iii: rect1.remove(i) rect2.remove(i) rect3.remove(i) if rect1[0]+rect2[0]+rect3[0]==i: print(i) for j in range(i): print(""A""*rect1[0]+""B""*rect2[0]+""C""*rect3[0]) exit() rect1=recta rect2=rectb rect3=rectc func()",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",1497
"def chnge(last,cap,ini=(0,0)): for i in range(ini[1],last[1]): fin[i][ini[0]:last[0]] = [cap]*(last[0]-ini[0]) x1,y1,x2,y2,x3,y3 = map(int,input().split()) a = (max(x1,y1),[x1,y1],""A"") b = (max(x2,y2),[x2,y2],""B"") c = (max(x3,y3),[x3,y3],""C"") m = max(a[0],b[0],c[0]) fin = [[""*"" for i in range(m)] for j in range(m)] if (x1*y1 + x2*y2 + x3*y3)!=m**2: print(-1) else: l = sorted([a]+[b]+[c],reverse = True) l[0][1].sort(reverse=True) chnge(l[0][1],l[0][2]) ini=[0,l[0][1][1]] last = l[1][1] if m in [ini[0]+last[0],ini[1]+last[1]] and (ini[0]+last[0]+ini[1]+last[1])<=2*m: last = [ini[0]+last[0],ini[1]+last[1]] else: last = [ini[0] + last[1], ini[1] + last[0]] chnge(last,l[1][2],ini) chr = l[2][2] print(m) for i in fin: print("""".join(i).replace(""*"",chr))",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",756
"a, b, c, d, e, f = list(map(int, input().split())) n, n2 = 1, a * b + c * d + e * f while n ** 2 < n2: n += 1 if n ** 2 > n2: print(-1) exit() l = sorted([[max(a, b), min(a, b), 'A'], [max(c, d), min(c, d), 'B'], [max(e, f), min(e, f), 'C']]) if l[2][0] != n: print(-1) exit() v = str(n) + '\n' + (l[2][2] * n + '\n') * l[2][1] if l[0][0] == n and l[1][0] == n: for i in range(2): v += (l[i][2] * n + '\n') * l[i][1] else: s = n - l[2][1] if s not in l[0] or s not in l[1]: print(-1) exit() x, y = l[0][1] if l[0][0] == s else l[0][0], l[1][1] if l[1][0] == s else l[1][0] v += (l[0][2] * x + l[1][2] * y + '\n') * s print(v)",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",625
"a,b,c,d,e,f=map(int,input().split()) if a<b:a,b=b,a if c<d:c,d=d,c if e<f:e,f=f,e sides=[[a,b,'A'],[c,d,'B'],[e,f,'C']] sides.sort(reverse=True) c1,c2,c3=sides[0][2],sides[1][2],sides[2][2] area=a*b+c*d+e*f if int(area**0.5)**2!=area: print(-1) else: l=int(area**0.5) if l not in sides[0]: print(-1) elif l in sides[1] and l in sides[2]: print(l) for i in range(3):sides[i].remove(l) for i in range(3): for _ in range(sides[i][0]): print([c1,c2,c3][i]*l) else: r=l-sides[0][1] if r in sides[1] and r in sides[2]: print(l) for i in range(1,3):sides[i].remove(r) for _ in range(sides[0][1]): print(c1*l) for _ in range(r): print(c2*sides[1][0]+c3*sides[2][0]) else: print(-1)",np,"['bitmasks', 'brute force', 'constructive algorithms', 'geometry', 'implementation', 'math']",673
"import sys import bisect from bisect import bisect_left as lb input_=lambda: sys.stdin.readline().strip(""\r\n"") from math import log from math import gcd from math import atan2,acos from random import randint sa=lambda :input_() sb=lambda:int(input_()) sc=lambda:input_().split() sd=lambda:list(map(int,input_().split())) sflo=lambda:list(map(float,input_().split())) se=lambda:float(input_()) sf=lambda:list(input_()) flsh=lambda: sys.stdout.flush() mod=10**9+7 gp=[] cost=[] dp=[] mx=[] ans1=[] ans2=[] special=[] specnode=[] a=0 kthpar=[] def dfs(root,par): if par!=-1: dp[root]=dp[par]+1 for i in range(1,20): if kthpar[root][i-1]!=-1: kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1] for child in gp[root]: if child==par:continue kthpar[child][0]=root dfs(child,root) ans=0 def hnbhai(t): n=sb() p=[] for i in range(n): p.append(sflo()) dp=[0]*(1<<n) dp[1]=1 for i in range(2,1<<n): for j in range(1,n): for k in range(0,j): if (i>>j)&1 and (i>>k)&1: dp[i]=max(dp[i],dp[i^(1<<j)]*p[k][j]+dp[i^(1<<k)]*p[j][k]) print(dp[-1]) for _ in range(1): hnbhai(_+1)",np,"['bitmasks', 'dp', 'math', 'probabilities']",1057
"import os,sys from io import BytesIO, IOBase def main(): n = int(input()) p = [list(map(float,input().split())) for _ in range(n)] y = 1<<n dp = [[0]*y for _ in range(n)] dp[0][y-1] = 1 for i in range(y-2,-1,-1): mask = 1 for j in range(n): if not mask&i: mask <<= 1 continue mask1 = 1 for k in range(n): if i&mask1: mask1 <<= 1 continue dp[j][i] = max(dp[j][i], dp[j][i|mask1]*p[j][k]+dp[k][i|mask1]*p[k][j]) mask1 <<= 1 mask <<= 1 print(max(dp[i][1<<i] for i in range(n))) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",np,"['bitmasks', 'dp', 'math', 'probabilities']",1853
"from decimal import * ar = [list(map(float, input().split())) for i in range(int(input()))] dp = [[0 for i in range(1 << 18)] for j in range(18)] n, ans = len(ar), 0 dp[0][(1 << n) - 1] = 1 for i in range((1 << n) - 1, 0, -1): for j in range(n): if i & (1 << j) == 0: continue for k in range(n): if i & (1 << k) != 0 or j == k: continue dp[j][i] = max(dp[j][i], dp[k][i ^ (1 << k)] * ar[k][j] + dp[j][i ^ (1 << k)] * ar[j][k]) for i in range(n): ans = max(ans, dp[i][1 << i]) print('{:.6f}'.format(ans))",np,"['bitmasks', 'dp', 'math', 'probabilities']",503
"import sys n = int(input()) prob = [list(map(float, input().split())) for _ in range(n)] dp = [[0.0]*n for _ in range(1 << n)] dp[1][0] = 1.0 for mask in range(3, 1 << n): for i in range(n): if not (mask & (1 << i)): continue for j in range(n): if i != j and mask & (1 << j): dp[mask][i] = max( dp[mask][i], dp[mask - (1 << j)][i] * prob[i][j] + dp[mask - (1 << i)][j] * prob[j][i] ) print(max(dp[-1]))",np,"['bitmasks', 'dp', 'math', 'probabilities']",402
"import sys n = int(input()) prob = [list(map(float, input().split())) for _ in range(n)] dp = [[0.0]*(1 << n) for _ in range(n)] dp[0][1] = 1.0 for mask in range(3, 1 << n): for i in range(n): if not (mask & (1 << i)): continue for j in range(n): if i != j and mask & (1 << j): dp[i][mask] = max( dp[i][mask], dp[i][mask - (1 << j)] * prob[i][j] + dp[j][mask - (1 << i)] * prob[j][i] ) print(max(dp[i][-1] for i in range(n)))",np,"['bitmasks', 'dp', 'math', 'probabilities']",425
"import math temp=list(map(int,input().split())) N,q=temp[0],temp[1] for j in range(0,q): u=int(input()) S=input() k=(N+1)//2 n=int(math.log((N+1),10)/math.log(2,10))-1 dup_n=n store=[k] while u!=k: n-=1 if u>k: k+=2**(n) else: k-=2**(n) store.append(k) for i in range(0,len(S)): if S[i]=='R': n-=1 if n==-1: n=0 continue k+=2**(n) elif S[i]=='L': n-=1 if n==-1: n=0 continue k-=2**(n) else: if n==dup_n: continue store.pop() k=store[len(store)-1] n+=1 continue store.append(k) print(k)",np,"['bitmasks', 'trees']",485
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=0, func=lambda a, b: a + b): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = self._defau",np,"['bitmasks', 'trees']",1999
"import sys from bisect import bisect_right as rb from collections import deque from queue import PriorityQueue from math import * input_ = lambda: sys.stdin.readline().strip(""\r\n"") ii = lambda : int(input_()) il = lambda : list(map(int, input_().split())) ilf = lambda : list(map(float, input_().split())) ip = lambda : input_() fi = lambda : float(input_()) ap = lambda ab,bc,cd : ab[bc].append(cd) li = lambda : list(input_()) pr = lambda x : print(x) prinT = lambda x : print(x) f = lambda : sys.stdout.flush() inv =lambda x:pow(x,mod-2,mod) mod = 10**9 + 7 def bit(n) : if (n == 0) :return 0 val = 1 while (val&n) == 0 : val *= 2 return val n,q = il() x = n+1 for i in range(q) : t1 = ii() for j in ip() : val = bit(t1) if (j == ""U"") : tem = (t1-val)|(val*2) if (tem < n) : t1 = tem elif (j == ""L"" and val>1) : t1 -= val//2 elif (j == ""R"" and val>1) : t1 += val//2 print(t1)",np,"['bitmasks', 'trees']",879
"import sys import bisect from bisect import bisect_left as lb input_=lambda: sys.stdin.readline().strip(""\r\n"") from math import log from math import gcd from math import atan2,acos from random import randint sa=lambda :input_() sb=lambda:int(input_()) sc=lambda:input_().split() sd=lambda:list(map(int,input_().split())) sflo=lambda:list(map(float,input_().split())) se=lambda:float(input_()) sf=lambda:list(input_()) flsh=lambda: sys.stdout.flush() mod=10**9+7 mod1=998244353 gp=[] cost=[] dp=[] mx=[] ans1=[] ans2=[] special=[] specnode=[] a=0 kthpar=[] def dfs(root,par): if par!=-1: dp[root]=dp[par]+1 for i in range(1,20): if kthpar[root][i-1]!=-1: kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1] for child in gp[root]: if child==par:continue kthpar[child][0]=root dfs(child,root) ans=0 def setting(s): if s=='0': return -1 i=len(s)-1 cc=0 while(i>=0 and s[i]=='0'): cc+=1 i-=1 return cc def hnbhai(tc): n,q=sd() up=n+1 x=len(bin(n)[2:])-1 for i in range(q): v=sb() s=sa() for j in s: temp=bin(v)[2:] abe=setting(temp) if j==""U"": if abe>=x: continue p=v+(1<<(abe)) n=v-(1<<(abe)) x1=setting(bin(p)[2:]) x2=setting(bin(n)[2:]) if x1==abe+1: v=p else: v=n elif j==""L"": if abe<=0: continue v=v-(1<<(abe-1)) else: if abe<=0: continue v=v+(1<<(abe-1)) print(v) for _ in range(1): hnbhai(_+1)",np,"['bitmasks', 'trees']",1291
"def lvl(val): tot=1 curr=-1 while(val%tot==0): curr+=1 tot*=2 return [curr,val*2//(tot),tot//2] n,q=map(int,input().split()) for _ in range(q): curr=int(input()) l,v,pw=lvl(curr) s=input() for j in s: if j==""U"": if v%4==3: curr=curr-pw else: if curr+pw<=n: curr=curr+pw elif j==""R"": if l>0: curr=curr+pw//2 elif j == ""L"": if l > 0: curr = curr - pw // 2 l, v, pw = lvl(curr) print(curr)",np,"['bitmasks', 'trees']",386
"def find(x): if root==x: u=root else: i=0 s=2**i while x%s==0: i+=1 s=2**i s=s//2 y=i+1 if (x-s)%(2**y)!=0: u=x-s else: u=x+s return u n,q=list(map(int,input().split())) root=(n+1)//2 for j in range(q): n1=int(input()) str1=input() for j in range(len(str1)): up=find(n1) if str1[j]=='U': n1=(up) elif n1%2==0: if str1[j]=='L': if n1!=root: n1=(n1-abs((up-n1)//2)) else: n1=(n1-n1//2) elif str1[j]=='R': if n1!=root: n1=(n1+abs((up-n1)//2)) elif n1%2==0: n1=n1+n1//2 print(n1)",np,"['bitmasks', 'trees']",475
"n, q = map(int,input().split()) par = n // 2 + 1 par = len(list(bin(par)[2:])) for i in range(q): ui = int(input()) si = input() temp = bin(ui)[2:] now = len(temp) num = list((par - now) * ""0"" + temp) now = par - now for i in range(len(num)): if str(num[i]) == '1': now = i for i in si: if i == ""U"": if now == 0: continue num[now] = 0 now -= 1 num[now] = 1 elif i == ""L"": if str(num[-1]) == '1': continue num[now] = 0 now += 1 num[now] = 1 else: if str(num[-1]) == '1': continue now += 1 num[now] = 1 for i in range(par): num[i] = str(num[i]) print(int("""".join(num),2))",np,"['bitmasks', 'trees']",569
"def maxx(n): return n&-n n,q=map(int,input().split()) root=n//2+1 while q>0: x=int(input()) s=input() for i in s: if i=='U' and x!=root: p=x+maxx(x) if x==p-maxx(p)//2: x=p else: x=x-maxx(x) elif i=='L': x=x-maxx(x)//2 elif i=='R': x=x+maxx(x)//2 q=q-1 print(x)",np,"['bitmasks', 'trees']",261
"def prime2(n): cont = 0 flag = True while flag: if n % 2 == 0: cont += 1 n = n/2 else: flag = False if n % 4 == 1: return [cont, ""L""] else: return [cont, ""R""] def arrivo(n,start,char): for i in char: if (i == ""L"" or i == ""R"") and start % 2 == 1: pass elif (i == ""U"") and 2*start == n+1: pass else: [power, direc] = prime2(start) if i == ""L"": start -= 2 ** (power - 1) elif i == ""R"": start += 2 ** (power - 1) else: if direc == ""L"": start += 2 ** power else: start -= 2 ** power return start if __name__ == '__main__': [n,q] = map(int, raw_input().rstrip().split()) for i in range(q): start = int(input()) char = raw_input() print(arrivo(n,start,char))",np,"['bitmasks', 'trees']",651
"import sys, math, queue MOD = 10**9+7 sys.setrecursionlimit(1000000) def hgt(x): if x == 0: return -1 h = 0 while x&1 != 1: h += 1 x = x>>1 return h def up(x): h = hgt(x) g = x + (1<<h) if g > 0 and g < N and hgt(g) == h+1: return g g = x - (1<<h) if g > 0 and g < N and hgt(g) == h+1: return g return x def left(x): h = hgt(x) if h == 0: return x g = x - (1<<(h-1)) if g > 0: return g return x def right(x): h = hgt(x) if h == 0: return x g = x + (1<<(h-1)) if g < N: return g return x N, q = map(int, input().split()) N += 1 for _ in range(q): p = int(input()) for c in input(): if c == 'U': p = up(p) elif c == 'R': p = right(p) else: p = left(p) print(p)",np,"['bitmasks', 'trees']",658
"def solve(n, m): h=m&-m for c in input(): if c=='U' and m!=(n+1)>>1: m+= -h if (m+h)%(h<<2)==0 else h h<<=1 if c in 'LR' and h>1: h>>=1 m+= -h if c=='L' else h return m n, m=map(int, input().split()) for _ in range(m): print(solve(n, int(input())))",np,"['bitmasks', 'trees']",248
"import math p2 =[1] * 64 for i in range(1, 64): p2[i] = p2[i-1] * 2 def find_level(x): x0 = 1 for i in range(max_level+1): if (x-x0) % (x0*2) == 0: return i x0 *=2 def move_U(number): cur_lv = find_level(number) if cur_lv == max_level: return number x0 = p2[cur_lv] seg = x0 * 2 index = (number - x0) // seg return (x0*2) + (index // 2) * (seg * 2) def move_L(number): cur_lv = find_level(number) if cur_lv == 0: return number x0 = p2[cur_lv] seg = x0 * 2 index = (number - x0) // seg return (x0 // 2) + (index * 2) * (seg // 2) def move_R(number): cur_lv = find_level(number) if cur_lv == 0: return number x0 = p2[cur_lv] seg = x0 * 2 index = (number - x0) // seg return (x0 // 2) + (index * 2 + 1) * (seg // 2) def move(s,num): if s == 'U': return move_U(num) if s == 'L': return move_L(num) return move_R(num) def process(S, num): for s in S: num = move(s, num) return num n, q = map(int, input().split()) max_level = int(math.log2(n+1)) - 1 ans = '' for _ in range(q): num = int(input()) S = input() ans += str(process(S, num)) + '\n' print(ans)",np,"['bitmasks', 'trees']",1049
"def pow2(n): j=0 while(n%2==0): n//=2 j+=1 return j n,q=map(int,input().split()) for j in range(q): u=int(input()) s=input() for k in range(len(s)): num=pow2(u) if(s[k]==""R"" and num!=0): u=u+2**(num-1) elif(s[k]==""L"" and num!=0): u=u-2**(num-1) elif(s[k]==""U"" and u!=(n+1)//2): m1=u+2**(num) m2=u-2**(num) if(pow2(m1)==(num+1)): u=m1 else: u=m2 print(u)",np,"['bitmasks', 'trees']",353
"n, q = map(int, input().split()) for _ in range(q): u = int(input()) s = input() for comm in s: k = 1 while True: if k & u: break k <<= 1 if comm == 'L': if k != 1: u -= k u += (k>>1) elif comm == 'R': if k != 1: u += (k>>1) elif comm == 'U': nu = u - k nu |= (k<<1) if nu <= n: u = nu print(u)",np,"['bitmasks', 'trees']",294
"import sys input = sys.stdin.readline n, q = map(int, input().split()) for _ in range(q): u = int(input()) s = input() for comm in s: k = 1 while True: if k & u: break k <<= 1 if comm == 'L': if k != 1: u -= k u += (k>>1) elif comm == 'R': if k != 1: u += (k>>1) elif comm == 'U': nu = u - k nu |= (k<<1) if nu <= n: u = nu print(u)",np,"['bitmasks', 'trees']",332
"def l(a): b=bin(a)[2:] b=""0""*(e-len(b))+b d=len(b) for i in range(d-1,-1,-1): if b[i]==""1"": c=d-1-i break if c==0: return -1 return (a-2**(c-1)) def r(a): b=bin(a)[2:] b=""0""*(e-len(b))+b d=len(b) for i in range(d-1,-1,-1): if b[i]==""1"": c=d-1-i break if c==0: return -1 return (a+2**(c-1)) def u(a): b=bin(a)[2:] b=""0""*(e-len(b))+b d=len(b) for i in range(d-1,-1,-1): if b[i]==""1"": c=d-1-i break if c==d-1: return -1 else: if b[d-1-c-1]==""0"": return a+(2**c) else: return a-(2**c) n,q=list(map(int,input().split())) e=len(bin(n)[2:]) for i in range(q): a=int(input()) b=input() for i in range(len(b)): if b[i]==""U"": c=u(a) if c!=-1: a=c elif b[i]==""R"": c=r(a) if c!=-1: a=c elif b[i]==""L"": c=l(a) if c!=-1: a=c print(a)",np,"['bitmasks', 'trees']",719
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") n,q=map(int,input().split()) x=n+1 l=0 while x>1: x//=2 l+=1 for i in range(q): a=int(input()) s=input() for j in s: lv=1 a1=a while a1%2==0: a1=a1//2 lv+=1 x=2**lv q=x//2 p=q//2 y=(a-q)//x+1 if j=='U': if lv==l: pass else: if y%2: a=(2*a+x)//2 else: a=(2*a-x)//2 elif j=='L': if lv==1: pass else: z=2*(y-1) a=p+z*q else: if lv==1: pass else: z=2*(y-1) a=p+(z+1)*q print(a)",np,"['bitmasks', 'trees']",1770
"from os import path import sys from heapq import heappush,heappop,heapify from functools import cmp_to_key as ctk from collections import deque,defaultdict as dd from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right from itertools import permutations from datetime import datetime from math import ceil,sqrt,log,gcd def ii():return int(input()) def si():return input().rstrip() def mi():return map(int,input().split()) def li():return list(mi()) abc='abcdefghijklmnopqrstuvwxyz' mod=1000000007 inf = float(""inf"") vow=['a','e','i','o','u'] dx,dy=[-1,1,0,0],[0,0,1,-1] def bo(i): return ord(i)-ord('a') file=1 def solve(): n,q=mi() x=int(log(n+1,2)) root=1<<(x-1) for i in range(q): u=ii() s=si() pos='U' if(u<root): pos='L' if(u>root): pos='R' s1=bin(u)[2:] s1='0'*(x-len(s1))+s1 s1=list(s1) for j in s: for k in range(x-1,-1,-1): if s1[k]=='1': f=k break if j=='L': if(f==x-1): continue s1[f]='0' s1[f+1]='1' elif(j=='R'): if(f==x-1): continue s1[f+1]='1' else: if f==0: continue if s1[f-1]=='1': s1[f]='0' else: s1[f-1]='1' s1[f]='0' s1="""".join(s1) print(int(s1,2)) if __name__ ==""__main__"": if(file): if path.exists('input.txt'): sys.stdin=open('input.txt', 'r') sys.stdout=open('output.txt','w') else: input=sys.stdin.readline solve()",np,"['bitmasks', 'trees']",1266
"def main(): n, q = map(int, input().split()) for _ in range(q): node = int(input()) s = input() for i in s: if i == 'L': if node % 2: continue k = node & (-node) node -= k k //= 2 node += k if i == 'R': if node % 2: continue k = node & (-node) k //= 2 node += k if i == 'U': if node == (n + 1) // 2: continue k = node & (-node) node -= k k *= 2 node |= k print(node) return if __name__ == ""__main__"": main()",np,"['bitmasks', 'trees']",407
"import sys n, q = map(int, input().split()) top = len(bin(n >> 1)) - 2 ans = [1] * q for i in range(q): v = int(input()) s = input() if n == 1: continue for h in range(top+1): if v & (1 << h): break for c in s: if h == top and c == 'U' or h == 0 and c != 'U': continue if c == 'U': v -= 1 << h h += 1 v |= 1 << h elif c == 'L': v -= 1 << h h -= 1 v |= 1 << h else: h -= 1 v |= 1 << h ans[i] = v print(*ans, sep='\n')",np,"['bitmasks', 'trees']",416
"import os import sys import math from io import BytesIO, IOBase import io from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque from collections import Counter import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=0, func=lambda a, b: max(a,b)): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __",np,"['bitmasks', 'combinatorics', 'number theory']",1999
"import sys input = sys.stdin.readline n = int(input()) mod = pow(10, 9) + 7 a = list(map(int, input().split())) l = 100000 cnt = [0] * (l + 1) for i in a: cnt[i] += 1 pow2 = [1] for _ in range(l): pow2.append(2 * pow2[-1] % mod) ans = pow2[n] - 1 x = [-1] * (l + 1) for i in range(2, l + 1): c = cnt[i] xi = x[i] for j in range(2 * i, l + 1, i): c += cnt[j] x[j] -= xi ans += xi * (pow2[c] - 1) % mod ans %= mod print(ans)",np,"['bitmasks', 'combinatorics', 'number theory']",422
"import bisect import copy import decimal import fractions import heapq import itertools import math import random import sys from collections import Counter,deque,defaultdict from functools import lru_cache,reduce from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max def _heappush_max(heap,item): heap.append(item) heapq._siftdown_max(heap, 0, len(heap)-1) def _heappushpop_max(heap, item): if heap and item < heap[0]: item, heap[0] = heap[0], item heapq._siftup_max(heap, 0) return item from math import gcd as GCD read=sys.stdin.read readline=sys.stdin.readline readlines=sys.stdin.readlines class Prime: def __init__(self,N): assert N<=10**8 self.smallest_prime_factor=[None]*(N+1) for i in range(2,N+1,2): self.smallest_prime_factor[i]=2 n=int(N**.5)+1 for p in range(3,n,2): if self.smallest_prime_factor[p]==None: self.smallest_prime_factor[p]=p for i in range(p**2,N+1,2*p): if self.smallest_prime_factor[i]==None: self.smallest_prime_factor[i]=p for p in range(n,N+1): if self.smallest_prime_factor[p]==None: self.smallest_prime_factor[p]=p self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]] def Factorize(self,N): assert N>=1 factorize=defaultdict(int) if N<=len(self.smallest_prime_factor)-1: while N!=1: factorize[self.smallest_prime_factor[N]]+=1 N//=self.smallest_prime_factor[N] else: for p in self.primes: while N%p==0: N//=p factorize[p]+=1 if N<p*p: if N!=1: factorize[N]+=1 break if N<=len(self.smallest_prime_factor)-1: while N!=1: factorize[self.smallest_prime_factor[N]]+=1 N//=self.smallest_prime_factor[N] break else: if N!=1: factorize[N]+=1 return factorize def Divisors(self,N): assert N>0 divisors=[1] for p,e in self.Factorize(N).items(): A=[1] for _ in range(e): A.append(A[-1]*p) divisors=[i*j for i in divisors for j in A] return divisors def Is_Prime(self,N): return N==self.smallest_prime_factor[N] def Totient(self,N): for p in self.Factorize(N).keys(): N*=p-1 N//=p return N def Mebius(self,N): fact=self.Factorize(N",np,"['bitmasks', 'combinatorics', 'number theory']",2000
"import bisect import copy import decimal import fractions import heapq import itertools import math import random import sys from collections import Counter,deque,defaultdict from functools import lru_cache,reduce from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max def _heappush_max(heap,item): heap.append(item) heapq._siftdown_max(heap, 0, len(heap)-1) def _heappushpop_max(heap, item): if heap and item < heap[0]: item, heap[0] = heap[0], item heapq._siftup_max(heap, 0) return item from math import gcd as GCD read=sys.stdin.read readline=sys.stdin.readline readlines=sys.stdin.readlines class Prime: def __init__(self,N): assert N<=10**8 self.smallest_prime_factor=[None]*(N+1) for i in range(2,N+1,2): self.smallest_prime_factor[i]=2 n=int(N**.5)+1 for p in range(3,n,2): if self.smallest_prime_factor[p]==None: self.smallest_prime_factor[p]=p for i in range(p**2,N+1,2*p): if self.smallest_prime_factor[i]==None: self.smallest_prime_factor[i]=p for p in range(n,N+1): if self.smallest_prime_factor[p]==None: self.smallest_prime_factor[p]=p self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]] def Factorize(self,N): assert N>=1 factorize=defaultdict(int) if N<=len(self.smallest_prime_factor)-1: while N!=1: factorize[self.smallest_prime_factor[N]]+=1 N//=self.smallest_prime_factor[N] else: for p in self.primes: while N%p==0: N//=p factorize[p]+=1 if N<p*p: if N!=1: factorize[N]+=1 break if N<=len(self.smallest_prime_factor)-1: while N!=1: factorize[self.smallest_prime_factor[N]]+=1 N//=self.smallest_prime_factor[N] break else: if N!=1: factorize[N]+=1 return factorize def Divisors(self,N): assert N>0 divisors=[1] for p,e in self.Factorize(N).items(): A=[1] for _ in range(e): A.append(A[-1]*p) divisors=[i*j for i in divisors for j in A] return divisors def Is_Prime(self,N): return N==self.smallest_prime_factor[N] def Totient(self,N): for p in self.Factorize(N).keys(): N*=p-1 N//=p return N def Mebius(self,N): fact=self.Factorize(N",np,"['bitmasks', 'combinatorics', 'number theory']",2000
"n=input() L=list(map(int,raw_input().split(' '))) D=[0]*101000 mod=10**9+7 itt=[0]*101000 p=[0]*100010 D[0]=1 for i in range(100010): D[i+1]=(D[i]*2)%mod for i in range(n): itt[L[i]]+=1 for i in range(1,100001): for j in range(i*2,100001,i): itt[i]+=itt[j] p[i]=(D[itt[i]]+mod-1)%mod i=100000 while i>=1: for j in range(i*2,100001,i): p[i]-=p[j] p[i]=(p[i]%mod+mod)%mod i-=1 print(p[1])",np,"['bitmasks', 'combinatorics', 'number theory']",386
"import sys, math, queue MOD = 10**9+7 sys.setrecursionlimit(1000000) def getMul(x): a = 1 for xi in x: a *= xi return a n = int(input()) a = list(map(int, input().split())) d = {} for ai in a: if ai in d: d[ai] += 1 else: d[ai] = 1 f = [[] for i in range(max(a)+10)] for i in range(1, len(f)): for j in range(i, len(f), i): f[j].append(i) seq = [0 for i in range(max(a)+10)] for ai in d: for fi in f[ai]: seq[fi] += d[ai] for i in range(len(seq)): seq[i] = (pow(2, seq[i], MOD) -1 +MOD) % MOD pf = [[] for i in range(max(a)+10)] pf[0] = None pf[1].append(1) for i in range(2, len(f)): if len(pf[i]) == 0: for j in range(i, len(pf), i): pf[j].append(i) for i in range(1, len(pf)): mul = getMul(pf[i]) if mul == i: if len(pf[i])&1 == 1: pf[i] = -1 else: pf[i] = 1 else: pf[i] = 0 pf[1] = 1 ans = 0 for i in range(1, len(seq)): ans += seq[i]*pf[i] ans = (ans + MOD) % MOD print(ans)",np,"['bitmasks', 'combinatorics', 'number theory']",879
"fact=[1] temp=1 MOD=10**9+7 for i in range(1,10**5+5): temp*=i temp%=MOD fact+=[temp] def bino(a,b): up=fact[a] down=pow(fact[b]*fact[a-b],MOD-2,MOD) return (up*down)%MOD def find(A): MOD=10**9+7 dp=[0]*(10**5+2) for x in A: dp[x]+=1 for i in range(2,len(dp)): for j in range(2,len(dp)): if i*j>len(dp)-1: break dp[i]+=dp[i*j] for i in range(2,len(dp)): dp[i]=(pow(2,dp[i],MOD)-1)%MOD for i in range(len(dp)-1,1,-1): for j in range(2,len(dp)): if i*j>=len(dp): break dp[i]-=dp[i*j] dp[i]%=MOD ans=0 for i in range(2,len(dp)): ans+=dp[i] ans%=MOD return (pow(2,len(A),MOD)-ans-1)%MOD input() print(find(list(map(int,input().strip().split(' ')))))",np,"['bitmasks', 'combinatorics', 'number theory']",645
"import math import collections def do(): n = int(input()) nums = map(int, input().split("" "")) count = collections.defaultdict(int) for num in nums: for i in range(1, int(math.sqrt(num))+1): cp = num // i if num % i == 0: count[i] += 1 if cp != i and num % cp == 0: count[cp] += 1 maxk = max(count.keys()) freq = {k: (1 << count[k]) - 1 for k in count} for k in sorted(count.keys(), reverse=True): for kk in range(k << 1, maxk+1, k): freq[k] -= freq[kk] if kk in freq else 0 return freq[1] % (10**9 + 7) print(do())",np,"['bitmasks', 'combinatorics', 'number theory']",514
"N = 10**5+5 MOD = 10**9+7 freq = [0 for i in range(N)] p2 = [0 for i in range(N)] p2[0] = 1 for i in range(1,N): p2[i] = p2[i-1]*2 p2[i]%=MOD def Calculate_Mobius(N): arr = [1 for i in range(N+1)] prime_count = [0 for i in range(N+1)] mobius_value = [0 for i in range(N+1)] for i in range(2,N+1): if prime_count[i]==0: for j in range(i,N+1,i): prime_count[j]+=1 arr[j] = arr[j] * i for i in range(1, N+1): if arr[i] == i: if (prime_count[i] & 1) == 0: mobius_value[i] = 1 else: mobius_value[i] = -1 else: mobius_value[i] = 0 return mobius_value mobius = Calculate_Mobius(N) n = int(input()) b = [int(i) for i in input().split()] for i in b: freq[i]+=1 ans = 0 for i in range(1,N): cnt = 0 for j in range(i,N,i): cnt += freq[j] total_subsequences = p2[cnt] - 1 ans = (ans + (mobius[i] * total_subsequences)%MOD)%MOD ans += MOD print(ans%MOD)",np,"['bitmasks', 'combinatorics', 'number theory']",840
"mod = int(1e9 + 7) n = int(input()) a = [int(_) for _ in input().split()] freq = {i: 0 for i in range(100001)} power = {0: 1} for i in range(1, 100001): power[i] = (2 * power[i - 1]) % mod for v in a: freq[v] += 1 dp = {i: 0 for i in range(100001)} for gcd in range(100000, 0, -1): mult = 2 total = freq[gcd] complement = 0 while mult * gcd <= 100000: total += freq[mult * gcd] complement += dp[mult * gcd] mult += 1 dp[gcd] = (power[total] - 1 - complement + mod) % mod print(dp[1])",np,"['bitmasks', 'combinatorics', 'number theory']",483
"n=int(input()) r=list(map(int,input().split())) dp=[0]*(10**5+1) cnt=[0]*(10**5+1) tmp=[0]*(10**5+1) mod=10**9+7 for i in range(n): cnt[r[i]]+=1 for i in range(1,10**5+1): for j in range(2*i,10**5+1,i): cnt[i]+=cnt[j] tmp[i]=pow(2,cnt[i],mod)-1 for i in range(10**5,0,-1): for j in range(2*i,10**5+1,i): tmp[i]=(tmp[i]-tmp[j])%mod print(tmp[1]%mod)",np,"['bitmasks', 'combinatorics', 'number theory']",348
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import gcd, ceil def prod(a, mod=10**9+7): ans = 1 for each in a: ans = (ans * each) % mod return ans def lcm(a, b): return a * b // gcd(a, b) def binary(x, length=16): y = bin(x)[2:] return y if len(y) >= length else ""0"" * (length - len(y)) + y for _ in range(int(input()) if not True else 1): n = int(input()) a = list(map(int, input().split())) mod = 10**9 + 7 twopow = [1]*(10**5+69) for i in range(1, 10**5+69): twopow[i] = (twopow[i-1] * 2) % mod count = [0]*100069 for i in a: count[i] += 1 multiples = [0]*100069 for i in range(1, 10**5+1): for j in range(i, 10**5+1, i): multiples[i]",np,"['bitmasks', 'combinatorics', 'number theory']",1999
"n=int(input()) s=[c=='1' for c in input()] m=len(s) z=[[0,0]] for c in s: ind = z[-1][c] z[-1][c] = len(z) z.append(z[ind][:]) assert(len(z) == m+1) z[m][0] = z[m][1] = m dp = [0 for _ in range(m+1)] dp[0] = 1 for i in range(n): ndp = [0 for _ in range(m+1)] for i in range(m+1): ndp[z[i][0]] += dp[i] ndp[z[i][1]] += dp[i] dp = ndp res = dp[m] for k in range(1, m): s0 = 0 for c in s[-k:]: s0 = z[s0][c] dp = [0 for _ in range(m+1)] dp[s0] = 1 for i in range(n - k): ndp = [0 for _ in range(m+1)] for i in range(m+1): ndp[z[i][0]] += dp[i] ndp[z[i][1]] += dp[i] dp = ndp for s1 in range(m): v = dp[s1] for c in s[-k:]: if s1 == m: v = 0 s1 = z[s1][c] if s1 == m: res += v print(res)",np,"['dp', 'strings']",683
"import os,sys from io import BytesIO,IOBase def main(): mod = 998244353 n,k = map(int,input().split()) dp = [[[0]*4 for _ in range(k+2)]for _ in range(n)] dp[0][1] = [0,1,1,0] dp[0][0] = [1,0,0,1] for i in range(1,n): for r in range(k): dp[i][r+1][3] = (dp[i][r+1][3]+dp[i-1][r][0])%mod dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][0])%mod dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][0])%mod dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][0])%mod dp[i][r+2][2] = (dp[i][r+2][2]+dp[i-1][r][1])%mod dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][1])%mod dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][1])%mod dp[i][r][1] = (dp[i][r][1]+dp[i-1][r][1])%mod dp[i][r+2][1] = (dp[i][r+2][1]+dp[i-1][r][2])%mod dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][2])%mod dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][2])%mod dp[i][r][2] = (dp[i][r][2]+dp[i-1][r][2])%mod dp[i][r+1][0] = (dp[i][r+1][0]+dp[i-1][r][3])%mod dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][3])%mod dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][3])%mod dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][3])%mod print((dp[-1][k-1][0]+dp[-1][k-1][1]+dp[-1][k-1][2]+dp[-1][k-1][3])%mod) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBa",np,"['bitmasks', 'dp']",1999
"n, K = map(int, input().split()) mod = 998244353 if K == 1: print(2) exit() dp = [[0]*(2**2) for i in range(K+1)] dp[1][0] = 1 dp[2][1] = 1 dp[2][2] = 1 dp[1][3] = 1 for i in range(1, n): nx = [[0]*(2**2) for i in range(K+1)] for k in range(K+1): for j in range(4): if j == 0: nx[k][0] += dp[k][j]%mod if k+1 <= K: nx[k+1][1] += dp[k][j]%mod nx[k+1][2] += dp[k][j]%mod nx[k+1][3] += dp[k][j]%mod elif j == 1: nx[k][0] += dp[k][j]%mod nx[k][1] += dp[k][j]%mod if k+2 <= K: nx[k+2][2] += dp[k][j]%mod nx[k][3] += dp[k][j]%mod elif j == 2: nx[k][0] += dp[k][j]%mod if k+2 <= K: nx[k+2][1] += dp[k][j]%mod nx[k][2] += dp[k][j]%mod nx[k][3] += dp[k][j]%mod else: if k+1 <= K: nx[k+1][0] += dp[k][j]%mod nx[k+1][1] += dp[k][j]%mod nx[k+1][2] += dp[k][j]%mod nx[k][3] += dp[k][j]%mod dp = nx print(sum(dp[K])%mod)",np,"['bitmasks', 'dp']",806
"def main(): n, k = map(int, input().split(' ')) if(k > 2*n): return(0) if(k == 2*n or k==1): return(2) iguales = [0]*(k+1) diferentes = [0]*(k+1) iguales[1] = 2 diferentes[2] = 2 modulo = 998244353 for i in range(1, n): auxigual = [0]*(k+1) auxdiff = [0]*(k+1) for j in range(1, k+1): auxigual[j] = (iguales[j] + iguales[j-1] + 2*diferentes[j]) % modulo for k in range(2, k+1): auxdiff[k] = (diferentes[k] + diferentes[k-2] + 2*iguales[k-1]) % modulo iguales = auxigual diferentes = auxdiff return((iguales[-1] + diferentes[-1]) % modulo) print(main())",np,"['bitmasks', 'dp']",552
"def main(): n, k = map(int, input().split(' ')) if(k > 2*n): return(0) if(k == 2*n or k==1): return(2) iguales = [0]*(k+1) diferentes = [0]*(k+1) iguales[1] = 2 diferentes[2] = 2 modulo = 998244353 for i in range(1, n): auxigual, auxdiff = [0]*(k+1), [0]*(k+1) for j in range(k): auxigual[j+1] = (iguales[j+1] + iguales[j] + 2*diferentes[j+1]) % modulo if(j >= 1): auxdiff[j+1] = (diferentes[j+1] + diferentes[j-1] + 2*iguales[j]) % modulo iguales = auxigual diferentes = auxdiff return((iguales[-1] + diferentes[-1]) % modulo) print(main())",np,"['bitmasks', 'dp']",541
"n,k=map(int,input().split()) same=[0]*(k+1) diff=[0]*(k+1) same[1]=2 if k>1: diff[2]=2 for i in range(n-1): newsame=[0]*(k+1) newdiff=[0]*(k+1) for i in range(1,k+1): newsame[i]=(same[i]+same[i-1]+2*diff[i])%998244353 for i in range(2,k+1): newdiff[i]=(2*same[i-1]+diff[i]+diff[i-2])%998244353 same=newsame diff=newdiff print((same[-1]+diff[-1])%998244353)",np,"['bitmasks', 'dp']",356
"n,k=map(int,input().split()) mod=998244353 dp=[[0,0,0,0] for _ in range(k+1)] dp[1][0]=dp[1][3]=1 if k>1: dp[2][2]=dp[2][1]=1 for x in range(1,n): g=[[0,0,0,0] for _ in range(k+1)] g[1][0]=g[1][3]=1 for i in range(2,k+1): g[i][0]=(dp[i][0]+dp[i][1]+dp[i][2]+dp[i-1][3])%mod g[i][1]=(dp[i-1][0]+dp[i][1]+dp[i-2][2]+dp[i-1][3])%mod g[i][2]=(dp[i-1][0]+dp[i-2][1]+dp[i][2]+dp[i-1][3])%mod g[i][3]=(dp[i-1][0]+dp[i][1]+dp[i][2]+dp[i][3])%mod dp=g print(sum(dp[-1])%mod)",np,"['bitmasks', 'dp']",465
"import sys input = sys.stdin.readline import math import copy import collections from collections import deque import heapq import itertools from collections import defaultdict from collections import Counter n,k = map(int,input().split()) mod = 998244353 dp = [[[0 for z in range(2)] for j in range(k+1)] for i in range(n)] dp[0][1][0] = 1 if k>=2: dp[0][2][1] = 1 for i in range(1,n): for j in range(1,k+1): dp[i][j][0] += dp[i-1][j-1][0]+dp[i-1][j][0]+2*dp[i-1][j][1] dp[i][j][0]%=mod if j-2>=0: dp[i][j][1] += 2*dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i-1][j-2][1] else: dp[i][j][1] += dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i][j-1][0] dp[i][j][1]%=mod ans = 0 for z in range(2): ans+=dp[n-1][k][z] ans*=2 print(ans%mod)",np,"['bitmasks', 'dp']",711
"n,k=map(int,input().split()) mod=998244353 NEXT={(0,1):2,(1,2):2} for i in range(1,n): NOW=NEXT NEXT=dict() for key in NOW: if key[0]==0: if k-(n-i)*2<=key[1]<=k: NEXT[key]=NEXT.get(key,0)+NOW[key] if k-(n-i)*2<key[1]+1<=k: NEXT[(0,key[1]+1)]=NEXT.get((0,key[1]+1),0)+NOW[key] NEXT[(1,key[1]+1)]=NEXT.get((1,key[1]+1),0)+NOW[key]*2%mod else: if k-(n-i)*2<=key[1]<=k: NEXT[key]=NEXT.get(key,0)+NOW[key] NEXT[(0,key[1])]=NEXT.get((0,key[1]),0)+NOW[key]*2%mod if k-(n-i)*2<key[1]+2<=k: NEXT[(1,key[1]+2)]=NEXT.get((1,key[1]+2),0)+NOW[key] ANS=0 for key in NEXT: if key[1]==k: ANS=(ANS+NEXT[key])%mod print(ANS)",np,"['bitmasks', 'dp']",607
"mod = 998244353 N,K = map(int, input().split()) dp = [[[0]*(K+2) for i in range(2)] for i in range(N)] dp[0][0][0] = 1 dp[0][1][1] = 1 for i in range(1,N): for b in range(K): dp[i][0][b] += dp[i-1][0][b] dp[i][0][b] += dp[i-1][1][b] dp[i][0][b] += dp[i-1][1][b] dp[i][0][b+1] += dp[i-1][0][b] dp[i][0][b] %= mod dp[i][1][b+1] += dp[i-1][0][b] dp[i][1][b] += dp[i-1][1][b] dp[i][1][b+2] += dp[i-1][1][b] dp[i][1][b+1] += dp[i-1][0][b] dp[i][1][b] %= mod ans = 0 for x in range(2): ans += dp[N-1][x][K-1] print(ans*2%mod)",np,"['bitmasks', 'dp']",519
"import itertools n, k = [int(i) for i in input().split()] kas = [[0,0,0,0],[1,0,0,1],[0,1,1,0]] mmm = 998244353 def count_k(ka, k, t): if t == 0: return ka[k][0] + ka[k][1] + ka[k][2] + ka[k-1][3] if t == 1: return ka[k-1][0] + ka[k][1] + ka[k-2][2] + ka[k-1][3] if t == 2: return ka[k-1][0] + ka[k-2][1] + ka[k][2] + ka[k-1][3] if t == 3: return ka[k-1][0] + ka[k][1] + ka[k][2] + ka[k][3] for i in range(1, n): if len(kas) < k + 1: kas.append([0,0,0,0]) kas.append([0,0,0,0]) for kk in range(min(len(kas)-1, k), 1, -1): kas[kk] = [count_k(kas, kk, t) % mmm for t in range(4)] print(sum(kas[k]) % mmm if k < len(kas) else 0)",np,"['bitmasks', 'dp']",625
"n,k = map(int,input().split()) mod = 998244353 dp = [[[0,0]for j in range(2*n+1)] for i in range(n)] dp[0][0][0] = dp[0][1][1] = 1 for i in range(1,n): for j in range(2*n-1): dp[i][j][0] += (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][1]) %mod dp[i][j+1][0] += dp[i-1][j][0] % mod dp[i][j+1][1] += (dp[i-1][j][0] + dp[i-1][j][0])%mod dp[i][j][1] += dp[i-1][j][1] %mod dp[i][j+2][1] += dp[i-1][j][1] %mod print(sum(dp[n-1][k-1])*2%mod)",np,"['bitmasks', 'dp']",433
"n, k = map(int, input().split()) same = [0] * (k + 1) diff = [0] * (k + 1) mod = 998244353 same[1] = 2 if k > 1 : diff[2] = 2 for i in range (n - 1) : newsame = [0] * (k + 1) newdiff = [0] * (k + 1) for i in range (1, k + 1) : newsame[i] = (same[i] + same[i - 1] + 2 * diff[i]) % mod for i in range (2, k + 1) : newdiff[i] = (2 * same[i - 1] + diff[i] + diff[i - 2]) % mod same = newsame ; diff = newdiff print((same[-1] + diff[-1]) % mod)",np,"['bitmasks', 'dp']",439
"n, K = map(int, input().split()) dp = [[[0] * 4 for j in range(K + 2)] for i in range(n)] MOD = 998244353 dp[0][1][0] = 1 dp[0][1][1] = 1 dp[0][2][2] = 1 dp[0][2][3] = 1 for i in range(n - 1): for j in range(1, K + 1): if j < K + 1: for k in range(4): dp[i + 1][j][k] += dp[i][j][k] dp[i + 1][j][k] %= MOD for k in range(2): dp[i + 1][j][k] += dp[i][j][2] dp[i + 1][j][k] %= MOD for k in range(2): dp[i + 1][j][k] += dp[i][j][3] dp[i + 1][j][k] %= MOD for j in range(1, K): for k in range(4): if k != 0: dp[i + 1][j + 1][k] += dp[i][j][0] dp[i + 1][j + 1][k] %= MOD for k in range(4): if k != 1: dp[i + 1][j + 1][k] += dp[i][j][1] dp[i + 1][j + 1][k] %= MOD if j + 2 < K + 1: dp[i + 1][j + 2][2] += dp[i][j][3] dp[i + 1][j + 2][2] %= MOD dp[i + 1][j + 2][3] += dp[i][j][2] dp[i + 1][j + 2][3] %= MOD num = 0 for i in range(4): num += dp[n - 1][K][i] num %= MOD print(num)",np,"['bitmasks', 'dp']",871
"n,k = list(map(int,input().split())) limit = 998244353 if k > 2*n: print(0) elif k == 1 or k == 2*n: print(2) else: same = [0] * (k+1) same[1] = 2 diff = [0] * (k+1) diff[2] = 2 for i in range(2, n+1): for j in range(min(k, 2*i), 1, -1): same[j] = same[j] + 2*diff[j] + same[j-1] same[j] %= limit diff[j] = diff[j] + 2*same[j-1] + diff[j-2] diff[j] %= limit print((same[k] + diff[k]) % limit)",np,"['bitmasks', 'dp']",392
"n,k = list(map(int,input().split())) limit = 998244353 if k > 2*n: print(0) elif k == 1 or k == 2*n: print(2) else: same = [0] * (k+1) same[1] = 2 diff = [0] * (k+1) diff[2] = 2 for i in range(2, n+1): for j in range(min(k, 2*i), 1, -1): same[j] = same[j] + 2*diff[j] + same[j-1] same[j] %= limit diff[j] = diff[j] + 2*same[j-1] + diff[j-2] diff[j] %= limit print((same[k] + diff[k]) % limit)",np,"['bitmasks', 'dp']",392
"n,k = [int(x) for x in input().split()] dp = [[[0 for _ in range(4)] for _ in range(k+2)] for _ in range(2)] dp[1][2][0] = 1 dp[1][2][1] = 1 dp[1][1][2] = 1 dp[1][1][3] = 1 for n1 in range(1,n): for k1 in range(1,k+1): dp[0][k1][0] = dp[1][k1][0] dp[0][k1][1] = dp[1][k1][1] dp[0][k1][2] = dp[1][k1][2] dp[0][k1][3] = dp[1][k1][3] dp[1][k1][0] = (dp[0][k1][0] + (dp[0][k1-2][1] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 dp[1][k1][1] = (dp[0][k1][1] + (dp[0][k1-2][0] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 dp[1][k1][2] = (dp[0][k1][2] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][3])% 998244353 dp[1][k1][3] = (dp[0][k1][3] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][2])% 998244353 total = 0 for i in range(4): total += dp[1][k][i] % 998244353 print(total% 998244353 )",np,"['bitmasks', 'dp']",821
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import factorial from collections import Counter, defaultdict from heapq import heapify, heappop, heappush def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') def main(): n, k = RLL() dp = [[0]*4 for _ in range(k+2)] dp",np,"['bitmasks', 'dp']",2000
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import factorial from collections import Counter, defaultdict from heapq import heapify, heappop, heappush def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') def main(): n, k = RLL() dp = [[0]*4 for _ in range(k+2)] dp",np,"['bitmasks', 'dp']",2000
"import sys import math from collections import defaultdict,deque import heapq n,k=map(int,sys.stdin.readline().split()) mod=998244353 dp=[[0,0,0,0] for x in range(k+3)] dp[1][0]=1 dp[1][1]=1 dp[2][2]=1 dp[2][3]=1 newdp=[[0,0,0,0] for x in range(k+3)] for i in range(n-1): for j in range(k+1): newdp[j+1][1]+=dp[j][0] newdp[j+1][3]+=dp[j][0] newdp[j+1][2]+=dp[j][0] newdp[j][0]+=dp[j][0] newdp[j][1]+=dp[j][1] newdp[j+1][3]+=dp[j][1] newdp[j+1][2]+=dp[j][1] newdp[j+1][0]+=dp[j][1] newdp[j][1]+=dp[j][2] newdp[j+2][3]+=dp[j][2] newdp[j][2]+=dp[j][2] newdp[j][0]+=dp[j][2] newdp[j][1]+=dp[j][3] newdp[j][3]+=dp[j][3] newdp[j+2][2]+=dp[j][3] newdp[j][0]+=dp[j][3] for a in range(3): for b in range(4): newdp[a+j][b]%=mod for a in range(k+3): for b in range(4): dp[a][b]=newdp[a][b] newdp[a][b]=0 ans=sum(dp[k]) ans%=mod print(ans)",np,"['bitmasks', 'dp']",827
"import sys import math from collections import defaultdict,deque import heapq n,k=map(int,sys.stdin.readline().split()) mod=998244353 dp=[[0,0,0,0] for x in range(k+3)] dp[1][0]=1 dp[1][1]=1 dp[2][2]=1 dp[2][3]=1 newdp=[[0,0,0,0] for x in range(k+3)] for i in range(n-1): for j in range(k+1): newdp[j+1][1]+=dp[j][0] newdp[j+1][3]+=dp[j][0] newdp[j+1][2]+=dp[j][0] newdp[j][0]+=dp[j][0] newdp[j][1]+=dp[j][1] newdp[j+1][3]+=dp[j][1] newdp[j+1][2]+=dp[j][1] newdp[j+1][0]+=dp[j][1] newdp[j][1]+=dp[j][2] newdp[j+2][3]+=dp[j][2] newdp[j][2]+=dp[j][2] newdp[j][0]+=dp[j][2] newdp[j][1]+=dp[j][3] newdp[j][3]+=dp[j][3] newdp[j+2][2]+=dp[j][3] newdp[j][0]+=dp[j][3] for a in range(3): for b in range(4): newdp[a+j][b]%=mod for a in range(k+3): for b in range(4): dp[a][b]=newdp[a][b] newdp[a][b]=0 ans=sum(dp[k]) ans%=mod print(ans)",np,"['bitmasks', 'dp']",827
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction from collections import defaultdict from itertools import permutations BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") n,k=map(int,sys.stdin.readline().split()) mod=998244353 dp=[[0,0,0,0] for x in range(k+3)] dp[1][0]=1 dp[1][1]=1 dp[2][2]=1 dp[2][3]=1 newdp=[[0,0,0,0] for x in range(k+3)] for i in range(n-1): for j in range(k+1): newdp[j+1][1]+=dp[j][0] newdp[j+1][3]+=dp[j][0] newdp[j+1][2]+=dp[j][0] newdp[j][0]+=dp[j][0] newdp[j][1]+=dp[j][1] newdp[j+1][3]+=dp[j][1] newdp[j+1][2]+=dp[j][1] newdp[j+1][0]+=dp[j][1] newdp[j][1]+=dp[j][2] newdp[j+2][3]+=dp[j][2] newdp[j][2]+=dp[j][2] newdp[j][0]+=dp[j",np,"['bitmasks', 'dp']",1999
"pri=998244353 dp=[[[0 for i in range(2001)] for i in range(1001)] for i in range(2)] n,k=map(int,input().split()) for i in range(1,n+1): if(i==1): dp[0][i][1]=2 dp[1][i][2]=2 continue; for j in range(1,(2*i)+1): dp[0][i][j]=(dp[0][i-1][j])+(dp[0][i-1][j-1])+(2*(dp[1][i-1][j])) dp[0][i][j]%=pri dp[1][i][j]=(2*dp[0][i-1][j-1])+(dp[1][i-1][j])+(dp[1][i-1][j-2]) dp[0][i][j]%=pri dp[1][i][j]%=pri y=dp[0][n][k]+dp[1][n][k] y%=pri print(y)",np,"['bitmasks', 'dp']",436
"from sys import stdin add = lambda a, b: (a % mod + b % mod) % mod mod, bits = 998244353, ['00', '01', '10', '11'] pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]] n, k = map(int, stdin.readline().split()) mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)] for i in range(4): val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1) if val <= k: mem[0][val][i] = 1 for i in range(1, n): for j in range(1, i * 2 + 1): for k1 in range(4): for k2 in range(4): val = j + pat[k1][k2] if val <= k: mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2]) print(sum(mem[-1][k]) % mod)",np,"['bitmasks', 'dp']",618
"from sys import stdin add = lambda a, b: (a + b) % mod mod, bits = 998244353, ['00', '01', '10', '11'] pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]] n, k = map(int, stdin.readline().split()) mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)] for i in range(4): val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1) if val <= k: mem[0][val][i] = 1 for i in range(1, n): for j in range(1, i * 2 + 1): for k1 in range(4): for k2 in range(4): val = j + pat[k1][k2] if val <= k: mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2]) print(sum(mem[-1][k]) % mod)",np,"['bitmasks', 'dp']",606
"from sys import stdin add = lambda a, b: (a + b) % mod mod, bits = 998244353, ['00', '01', '10', '11'] pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]] n, k = map(int, stdin.readline().split()) mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)] for i in range(4): val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1) if val <= k: mem[0][val][i] = 1 for i in range(1, n): for j in range(1, k + 1): for k1 in range(4): for k2 in range(4): val = j + pat[k1][k2] if val <= k: mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2]) print(sum(mem[-1][k]) % mod)",np,"['bitmasks', 'dp']",602
"from sys import stdin add = lambda a, b: (a % mod + b % mod) % mod mod, bits = 998244353, ['00', '01', '10', '11'] pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]] n, k = map(int, stdin.readline().split()) mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)] for i in range(4): val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1) if val <= k: mem[0][val][i] = 1 for i in range(1, n): for j in range(1, k + 1): for k1 in range(4): for k2 in range(4): val = j + pat[k1][k2] if val <= k: mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2]) print(sum(mem[-1][k]) % mod)",np,"['bitmasks', 'dp']",614
"from sys import stdin add = lambda a, b: (a % mod + b % mod) % mod mod, bits = 998244353, ['00', '01', '10', '11'] pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]] n, k = map(int, stdin.readline().split()) mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)] for i in range(4): val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1) if val <= k: mem[0][val][i] = 1 for i in range(1, n): for j in range(1, k + 1): for k1 in range(4): for k2 in range(4): val = j + pat[k1][k2] if val <= k: mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2]) for j in range(1, k + 1): for k1 in range(4): mem[(i - 1) & 1][j][k1] = 0 print(sum(mem[(n - 1) & 1][k]) % mod)",np,"['bitmasks', 'dp']",711
"from sys import stdin add = lambda a, b: (a % mod + b % mod) % mod mod, bits = 998244353, ['00', '01', '10', '11'] pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]] n, k = map(int, stdin.readline().split()) mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)] for i in range(4): val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1) if val <= k: mem[0][val][i] = 1 for i in range(1, n): for j in range(1, i * 2 + 1): for k1 in range(4): for k2 in range(4): val = j + pat[k1][k2] if val <= k: mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2]) for j in range(1, min(i * 2 + 1, k + 1)): for k1 in range(4): mem[(i - 1) & 1][j][k1] = 0 print(sum(mem[(n - 1) & 1][k]) % mod)",np,"['bitmasks', 'dp']",731
"ch_0={0:[0,1,2],2:[2],1:[1],3:[1,2,3]} ch_1={0:[3],3:[0],1:[0,3],2:[0,3]} ch_2={0:[],3:[],2:[1],1:[2]} N=998244353 n,k=map(int,input().strip().split("" "")) dp=[[[0]*4 for j in range(k+5)] for i in range(n+5)] dp[0][1][3]=1 dp[0][1][0]=1 dp[0][2][1]=1 dp[0][2][2]=1 for i in range(1,n): for j in range(1,k+1): for mask in range(4): for t in ch_0[mask]: dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j][t])%N if j>1: for t in ch_1[mask]: dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-1][t])%N if j>2: for t in ch_2[mask]: dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-2][t])%N ans=0 for mask in range(4): ans=(ans+dp[n-1][k][mask])%N print(ans)",np,"['bitmasks', 'dp']",624
"import math,sys,bisect,heapq from collections import defaultdict,Counter,deque from itertools import groupby,accumulate int1 = lambda x: int(x) - 1 input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__ ilele = lambda: map(int,input().split()) alele = lambda: list(map(int, input().split())) ilelec = lambda: map(int1,input().split()) alelec = lambda: list(map(int1, input().split())) def list2d(a, b, c): return [[c] * b for i in range(a)] def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)] def Y(c): print([""NO"",""YES""][c]) def y(c): print([""no"",""yes""][c]) def Yy(c): print([""No"",""Yes""][c]) MOD = 998244353 N,K = ilele() if K == 1 or K == 2*N: print(2) exit(0) dp = list3d(N+1,4,K+1,0) dp[1][0][1] = 1 dp[1][3][1] = 1 dp[1][1][2] = 1 dp[1][2][2] = 1 for n in range(2,N+1): for k in range(1,K+1): dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD if k > 1: dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD else: dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD print(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)",np,"['bitmasks', 'dp']",1444
"import sys from array import array def readline() -> str: return sys.stdin.buffer.readline().decode('utf-8') n, k = map(int, readline().split()) mod = 998244353 dp = [[array('i', [0])*(2*n+3) for _ in range(n)] for _ in range(4)] dp[0][0][1] = dp[3][0][1] = 1 dp[1][0][2] = dp[2][0][2] = 1 for i in range(n-1): for j in range(k+1): for sbit in range(4): for tbit in range(4): add = ( 1 if sbit == 3 and tbit == 0 or sbit == 0 and tbit == 3 else (1 if (sbit & 2) != (tbit & 2) and (tbit == 1 or tbit == 2) else 0) + (1 if (sbit & 1) != (tbit & 1) and (tbit == 1 or tbit == 2) else 0) ) dp[tbit][i+1][j+add] += dp[sbit][i][j] if dp[tbit][i+1][j+add] >= mod: dp[tbit][i+1][j+add] -= mod ans = sum(dp[bit][-1][k] for bit in range(4)) % mod print(ans)",np,"['bitmasks', 'dp']",746
"N = 1010 dp = [[[0] * 4 for j in range(N*2)] for i in range(N)] dp[0][1][0] = dp[0][1][1] = dp[0][2][2] = dp[0][2][3] = 1 m = 998244353 for i in range(N-1): for j in range(1,N*2-5): for me in range(4): for he in range(4): if me <= 1: if he <= 1: dp[i+1][j+(he!=me)][he] = (dp[i+1][j+(he!=me)][he] + dp[i][j][me]) % m else: dp[i+1][j+1][he] = (dp[i+1][j+1][he] + dp[i][j][me]) % m else: if he <= 1: dp[i+1][j][he] = (dp[i+1][j][he] + dp[i][j][me]) % m else: dp[i+1][j + (he != me)*2][he] = (dp[i+1][j+(he!=me)*2][he] + dp[i][j][me]) % m n,k = map(int,input().split()) print(sum(dp[n-1][k])%m)",np,"['bitmasks', 'dp']",591
"import sys def read(): return int(input()) def reads(): return [int(x) for x in input().split()] N,M=reads() table=[reads() for i in range(N)] A=[[0]*N for i in range(N)] B=[[0]*N for i in range(N)] for i in range(N): for j in range(N): res=10**9+7 for k in range(M): res=min(res,abs(table[i][k]-table[j][k])) A[i][j]=res A[j][i]=res res=10**9+7 for k in range(M-1): res=min(res,abs(table[i][k]-table[j][k+1])) B[i][j]=res dp=[[-1]*N for i in range((1<<N) )] def calc(mask,v): if dp[mask][v]!=-1: return dp[mask][v] res =0 for u in range(N): if (mask & 1<<u) and u!=v: res =max(res,min(calc(mask^(1<<v),u),A[u][v])) dp[mask][v]=res return dp[mask][v] ans=0 for i in range(N): dp = [[-1] * N for i in range((1 << N))] for k in range(N): if k==i: dp[1<<k][k]=10**9+7 else: dp[1<<k][k]=0 for j in range(N): ans=max(ans,min(B[j][i],calc((1<<N)-1,j))) print(ans)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'graphs']",857
"import sys import copy input = sys.stdin.readline n,m=map(int,input().split()) MAT=[list(map(int,input().split())) for i in range(n)] if n==1: ANS=10**10 for i in range(1,m): if ANS>abs(MAT[0][i]-MAT[0][i-1]): ANS=abs(MAT[0][i]-MAT[0][i-1]) print(ANS) sys.exit() EDGE0=[[10**10]*n for i in range(n)] EDGE1=[[10**10]*n for i in range(n)] MAX=0 MIN=0 if m!=1: for i in range(n): for j in range(n): EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)]) if EDGE1[i][j]>MAX: MAX=EDGE1[i][j] EDGE0[i][j]=min([abs(MAT[i][k]-MAT[j][k-1]) for k in range(1,m)]) else: for i in range(n): for j in range(n): EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)]) if EDGE1[i][j]>MAX: MAX=EDGE1[i][j] def Hamilton(start,USED,rest,last,weight): if MEMO[last*(1<<n)+USED]!=2: return MEMO[last*(1<<n)+USED] if rest==1: for i in range(n): if USED & (1<<i)==0: final=i break if EDGE0[start][final]>=weight and EDGE1[last][final]>=weight: MEMO[last*(1<<n)+USED]=1 return 1 else: MEMO[last*(1<<n)+USED]=0 return 0 for j in range(n): if USED & (1<<j)==0 and EDGE1[last][j]>=weight: NEXT=USED+(1<<j) if Hamilton(start,NEXT,rest-1,j,weight)==1: MEMO[last*(1<<n)+USED]=1 return 1 else: MEMO[last*(1<<n)+USED]=0 return 0 while MAX!=MIN: aveweight=(MAX+MIN+1)//2 for start in range(n): MEMO=[2]*(n*1<<(n+1)) START=1<<start if Hamilton(start,START,n-1,start,aveweight)==1: MIN=aveweight break else: MAX=aveweight-1 print(MAX)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'graphs']",1436
"import sys def read(): return int(input()) def reads(): return [int(x) for x in input().split()] N,M=reads() table=[reads() for i in range(N)] A=[[0]*N for i in range(N)] B=[[0]*N for i in range(N)] for i in range(N): for j in range(N): res=10**9+7 for k in range(M): res=min(res,abs(table[i][k]-table[j][k])) A[i][j]=res A[j][i]=res res=10**9+7 for k in range(M-1): res=min(res,abs(table[i][k]-table[j][k+1])) B[i][j]=res dp=[[-1]*N for i in range((1<<N) )] def calc(mask,v): if dp[mask][v]!=-1: return dp[mask][v] res =0 for u in range(N): if (mask & 1<<u) and u!=v: res =max(res,min(calc(mask^(1<<v),u),A[u][v])) dp[mask][v]=res return dp[mask][v] ans=0 for i in range(N): dp = [[-1] * N for _ in range((1 << N))] for k in range(N): if k==i: dp[1<<k][k]=10**9+7 else: dp[1<<k][k]=0 for j in range(N): ans=max(ans,min(B[j][i],calc((1<<N)-1,j))) print(ans)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'graphs']",857
"import sys from array import array from typing import List, Tuple, TypeVar, Generic, Sequence, Union def input(): return sys.stdin.buffer.readline().decode('utf-8') def solve(i, n, delta, delta2): inf = 2 * 10**9 dp = [[-1] * n for _ in range(1 << n)] dp[(1 << i)][i] = inf stack = [(1 << i, i)] for t in range(1, n + 1): next_s = [] for bit, v in stack: for dest in range(n): if (1 << dest) & bit: continue if dp[bit | (1 << dest)][dest] == -1: next_s.append((bit | (1 << dest), dest)) dp[bit | (1 << dest)][dest] = max(dp[bit | (1 << dest)][dest], min(dp[bit][v], delta[v][dest])) stack = next_s return max(min(delta2[j][i], dp[-1][j]) for j in range(n) if i != j) def main(): n, m = map(int, input().split()) matrix = [tuple(map(int, input().split())) for _ in range(n)] if n == 1: print(min(abs(x - y) for x, y in zip(matrix[0], matrix[0][1:]))) exit() delta = [[0] * n for _ in range(n)] for i in range(n): for j in range(i + 1, n): delta[i][j] = delta[j][i] = min(abs(x - y) for x, y in zip(matrix[i], matrix[j])) delta2 = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): delta2[i][j] = min((abs(x - y) for x, y in zip(matrix[i], matrix[j][1:])), default=2 * 10**9) print(max(solve(i, n, delta, delta2) for i in range(n))) if __name__ == '__main__': main()",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'graphs']",1279
"import os import string from math import inf from functools import lru_cache if os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \ or os.environ['COMPUTERNAME'] == 'USER145': import pdb import sys pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout) sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') from pprint import pprint from hypothesis import given, settings from hypothesis import strategies as st def ri(): return [int(i) for i in input().split()] def to_bits(l): ans = 0 for i in l: ans |= (1 << i - 1) return ans user_masks = [0 for i in range(1 << 10)] pizzas = [[] for i in range(1 << 10)] @lru_cache() def count_sat_users(mask): ans = 0 cmask = mask while cmask: ans += user_masks[cmask] cmask = (cmask - 1) & mask return ans def main(): n, m = ri() for _ in range(n): k, *a = ri() bits = to_bits(a) user_masks[bits] += 1 ans = (float(-inf), float(inf), -1, -1) for i in range(m): c, k, *a = ri() bits = to_bits(a) pizzas[bits].append((c, i + 1, bits)) pizzas[bits].sort() while len(pizzas[bits]) > 2: pizzas[bits].pop() for mask_F in range(1 << 9): for mask_S in range(1 << 9): if len(pizzas[mask_F]) and len(pizzas[mask_S]) \ and mask_F != mask_S: mask = mask_F | mask_S satisfied_users = count_sat_users(mask) f_pizza = next(iter(pizzas[mask_F])) s_pizza = next(iter(pizzas[mask_S])) summary_cost = 0 summary_cost += f_pizza[0] summary_cost += s_pizza[0] ans = max(ans, (satisfied_users, -summary_cost, s_pizza[1], f_pizza[1])) bmask = mask while bmask: satisfied_users += user_masks[bmask] bmask = (bmask - 1) & mask if len(pizzas[mask_F]) == 2: satisfied_users = count_sat_users(mask_F) it = iter(pizzas[mask_F]) f_pizza = next(it) s_pizza = next(it) summary_cost = 0 summary_cost += f_pizza[0] + s_pizza[0] ans = max(ans, (satisfied_users, -summary_cost, s_pizza[1], f_pizza[1])) if len(pizzas[mask_S]) == 2: satisfied_users = count_sat_users(mask_S) it = iter(pizzas[mask_S]) f_pizza = next(it) s_pizza = next(it) summary_cost = 0 summary_co",np,"['bitmasks', 'brute force']",1999
"n,tnow=map(int,input().split()) left=int("""".join([""1"" for i in range(n)]),2) arr=[] dp={} for i in range(n): a,b=map(int,input().split()) arr.append([a,b]) def recur(tnow,prevgenre,left): key=str(left)+""_""+str(prevgenre) if tnow==0: return 1 elif key in dp: return dp[key] else: ans=0 for i in range(n): if (left&(1<<i))!=0: if arr[i][0]<=tnow and arr[i][1]!=prevgenre: left=left&(~(1<<i)) ans+=recur(tnow-arr[i][0],arr[i][1],left) left=left|(1<<i) dp[key]= ans return ans print(recur(tnow,4,left)%(10**9+7))",np,"['bitmasks', 'combinatorics', 'dp']",508
"import os,sys from io import BytesIO,IOBase def main(): mod = 10**9+7 n,T = map(int,input().split()) y = 1<<n dp = [[0]*3 for _ in range(y)] peo = [list(map(int,input().split())) for _ in range(n)] for ind,i in enumerate(peo): peo[ind][1] -= 1 dp[1<<ind][i[1]] = 1 for i in range(y): for j in range(3): if not dp[i][j]: continue mask = 1 for k in range(n): if i&mask or peo[k][1] == j: mask <<= 1 continue dp[i|mask][peo[k][1]] = (dp[i|mask][peo[k][1]]+dp[i][j])%mod mask <<= 1 ans = 0 for i in range(y): ans1,mask = 0,1 for j in range(n): if i&mask: ans1 += peo[j][0] mask <<= 1 if ans1 == T: ans = (ans+sum(dp[i]))%mod print(ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == '__main",np,"['bitmasks', 'combinatorics', 'dp']",1999
"import sys input=sys.stdin.readline mod=10**9+7 n,t=map(int,input().split()) a=[] for i in range(n): time,genre=map(int,input().split()) genre-=1 a.append((time,genre)) dp=[[0 for j in range(3)] for i in range(1<<n)] for i in range(n): dp[1<<i][a[i][1]]=1 for i in range(1<<n): for j in range(3): if(dp[i][j]==0): continue mask=1 for k in range(n): if(i&mask or a[k][1]==j): mask<<=1 continue dp[i|mask][a[k][1]]=(dp[i|mask][a[k][1]]+dp[i][j])%mod mask<<=1 ans=0 for i in range(1<<n): mask=1 duration=0 for j in range(n): if(i&mask): duration+=a[j][0] mask<<=1 if(duration==t): ans=(ans+sum(dp[i]))%mod print(ans)",np,"['bitmasks', 'combinatorics', 'dp']",613
"from math import factorial def lol(n): if n == 1: yield [0] yield [1] else: for p in lol(n - 1): p.append(0) yield p p[-1] = 1 yield p p.pop() def sp(g1, g2, g3, f): if g1 == 0: if g2 == g3: return 2 elif abs(g2 - g3) == 1: return 1 else: return 0 elif g2 == 0: if g1 == g3: return 2 elif abs(g1 - g3) == 1: return 1 else: return 0 elif g3 == 0: if g2 == g1: return 2 elif abs(g2 - g1) == 1: return 1 else: return 0 else: if f == 1: b = sp(g1, g2 - 1, g3, 2) c = sp(g1, g2, g3 - 1, 3) return b + c elif f == 2: a = sp(g1 - 1, g2, g3, 1) c = sp(g1, g2, g3 - 1, 3) return a + c elif f == 3: a = sp(g1 - 1, g2, g3, 1) b = sp(g1, g2 - 1, g3, 2) return a + b else: a = sp(g1 - 1, g2, g3, 1) b = sp(g1, g2 - 1, g3, 2) c = sp(g1, g2, g3 - 1, 3) return a + b + c n, T = map(int, input().split()) S = [] cnt = 0 M = 10 ** 9 + 7 for i in range(n): S.append(list(map(int, input().split()))) for p in lol(n): d = 0 g1, g2, g3 = 0, 0, 0 for i in range(n): if p[i]: d += S[i][0] if S[i][1] == 1: g1 += 1 elif S[i][1] == 2: g2 += 1 elif S[i][1] == 3: g3 += 1 if d == T: cnt += factorial(g1) * factorial(g2) * factorial(g3) * sp(g1, g2, g3, 0) cnt %= M print(cnt)",np,"['bitmasks', 'combinatorics', 'dp']",1147
"import sys input = sys.stdin.readline n,T=map(int,input().split()) S=[list(map(int,input().split())) for i in range(n)] DP=[[0]*(4) for i in range(T+1)] mod=10**9+7 from functools import lru_cache @lru_cache(maxsize=None) def calc(used,recent,time): ANS=0 for i in range(n): if i in used: continue if time+S[i][0]>T: continue if S[i][1]==recent: continue if time+S[i][0]==T: ANS+=1 if time+S[i][0]<T: used2=list(used)+[i] used2.sort() recent2=S[i][1] time2=time+S[i][0] ANS=(ANS+calc(tuple(used2),recent2,time2))%mod return ANS print(calc(tuple(),-1,0)%mod)",np,"['bitmasks', 'combinatorics', 'dp']",557
"from copy import * n,T=map(int,raw_input().split()) cl=set(()) di={(0,0,0,T):1} for k in range(n): t,g=map(int,raw_input().split()) an=deepcopy(di) for k in an: nc=list(k) nc[3]-=t nc[g-1]+=1 if nc[3]>=0: nc=tuple(nc) if nc in di: di[nc] += an[k] else: di[nc] = an[k] nd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1} mo=10**9+7 def nb(tu): if not(tu in nd): if tu[tu[3]]==0: nd[tu] =0 else: nt=list(tu) nt[tu[3]]-=1 nt[3]=(nt[3]+1)%3 nt2=nt[:] nt2[3]=(nt2[3]+1)%3 nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo return nd[tu] print(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)",np,"['bitmasks', 'combinatorics', 'dp']",613
"from functools import lru_cache P = 10**9+7 N, T = map(int, input().split()) A = [[], [], []] X = [] for _ in range(N): t, g = map(int, input().split()) X.append((t, g)) @lru_cache(maxsize=None) def calc(x, pr, t): if t < 0: return 0 if t == 0: return 1 if x == 0: return 0 ans = 0 for i in range(15): if x & (1<<i): if X[i][1] != pr: y = x ^ (1<<i) ans = (ans + calc(y, X[i][1], t-X[i][0])) % P return ans print(calc(2**N-1, -1, T))",np,"['bitmasks', 'combinatorics', 'dp']",433
"def popcount(i): assert 0 <= i < 0x100000000 i = i - ((i >> 1) & 0x55555555) i = (i & 0x33333333) + ((i >> 2) & 0x33333333) return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24 N, T = map(int, input().split()) TG = [list(map(int, input().split())) for _ in range(N)] mod = 10**9+7 dp = [[0]*(2**N) for _ in range(4)] for i in range(1, 4): dp[i][0] = 1 for S in range(2**N): if popcount(S) == 1: dp[TG[(S&(-S)).bit_length() - 1][1]][S] = 1 for i in range(1, 4): for j in range(N): if S & (2**j) or i == TG[j][1]: continue dp[TG[j][1]][S|(2**j)] = (dp[TG[j][1]][S|(2**j)] + dp[i][S]) % mod table = [0]*(2**N) for S in range(2**N): table[S] = sum(TG[j][0] for j in range(N) if 2**j & S) ans = 0 for S in range(2**N): if table[S] == T: for i in range(1, 4): ans = (ans + dp[i][S]) % mod print(ans)",np,"['bitmasks', 'combinatorics', 'dp']",809
"import os import string from math import inf from functools import lru_cache if os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \ or os.environ['COMPUTERNAME'] == 'RYZEN': import pdb import sys pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout) sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') from pprint import pprint from hypothesis import given, settings from hypothesis import strategies as st def ri(): return [int(i) for i in input().split()] MOD = int(1e9 + 7) def main(): n, t = ri() songs = [] result = 0 for i in range(n): songs.append(ri()) songs[-1][1] -= 1 dp = [[0, 0, 0] for i in range(1 << n)] for ind, it in enumerate(songs): dp[1 << ind][it[1]] = 1 for mask in range(1, 1 << n): for genre in range(3): for nsng, sng in enumerate(songs): if sng[1] != genre and ((mask >> nsng) & 1) == 0: dp[mask | (1 << nsng)][sng[1]] += dp[mask][genre] if (mask | (1 << nsng)) == 4: asdddd = 1 sm = 0 for ind, it in enumerate(reversed(bin(mask)[2:])): if it == '1': sm += songs[ind][0] if sm == t: result += dp[mask][genre] result %= MOD print(result) main()",np,"['bitmasks', 'combinatorics', 'dp']",1103
"from itertools import combinations def out1(a,b,c): if a<0 or b<0 or c<0: return 0 if a==1 and b==0 and c==0: return 1 return a*(out2(a-1,b,c)+out3(a-1,b,c)) def out2(a,b,c): if a<0 or b<0 or c<0: return 0 if a==0 and b==1 and c==0: return 1 return b*(out1(a,b-1,c)+out3(a,b-1,c)) def out3(a,b,c): if a<0 or b<0 or c<0: return 0 if a==0 and b==0 and c==1: return 1 return c*(out2(a,b,c-1)+out1(a,b,c-1)) def column(matrix, i): return [row[i] for row in matrix] N, T = [int(x) for x in input().split()] A = [] s = 0 for i in range(N): A.append([int(x) for x in input().split()]) for i in range(1,N+1): comb = list(combinations(A, i)) for x in comb: if sum(column(x,0))==T: a = column(x,1).count(1) b = column(x,1).count(2) c = column(x,1).count(3) s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c)) print(s%1000000007)",np,"['bitmasks', 'combinatorics', 'dp']",807
"from itertools import* def out1(a,b,c): if a<0 or b<0 or c<0: return 0 if a==1 and b==0 and c==0: return 1 return a*(out2(a-1,b,c)+out3(a-1,b,c)) def out2(a,b,c): if a<0 or b<0 or c<0: return 0 if a==0 and b==1 and c==0: return 1 return b*(out1(a,b-1,c)+out3(a,b-1,c)) def out3(a,b,c): if a<0 or b<0 or c<0: return 0 if a==0 and b==0 and c==1: return 1 return c*(out2(a,b,c-1)+out1(a,b,c-1)) def column(matrix, i): return [row[i] for row in matrix] N, T = [int(x) for x in raw_input().split()] A = [] s = 0 for i in range(N): A.append([int(x) for x in raw_input().split()]) for i in range(1,N+1): comb = list(combinations(A, i)) for x in comb: if sum(column(x,0))==T: a = column(x,1).count(1) b = column(x,1).count(2) c = column(x,1).count(3) s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c)) print(s%1000000007)",np,"['bitmasks', 'combinatorics', 'dp']",803
"from itertools import combinations def findsum(comb): sum = 0 for song in comb: sum += song[0] return sum def finda(a,b,c): if a == 0: return 0 if a == 1 and b == 0 and c == 0: return 1 else: return (a * findb(a-1,b,c)+ a*findc(a-1,b,c)) def findb(a,b,c): if b == 0: return 0 if b == 1 and a == 0 and c == 0: return 1 else: return (b * finda(a,b-1,c)+ b*findc(a,b-1,c)) def findc(a,b,c): if c == 0: return 0 if c == 1 and a == 0 and b == 0: return 1 else: return (c * finda(a,b,c-1)+ c*findb(a,b,c-1)) n, T = map(int,input().split()) songs = [] total_combinations = 0 for i in range(n): t, g = map(int,input().split()) songs.append([t,g]) for i in range(1, n+1): allcomb = list(combinations(songs,i)) for comb in allcomb: sum = findsum(comb) if sum == T: a = 0 b = 0 c = 0 for song in comb: if song[1] == 1: a += 1 elif song[1] == 2: b += 1 else: c += 1 total_combinations += finda(a,b,c)+findb(a,b,c)+findc(a,b,c) total_combinations = total_combinations%1000000007 print(total_combinations)",np,"['bitmasks', 'combinatorics', 'dp']",991
"def main(): t = int(input()) for _ in range(t): n, m = map(int, input().split()) l = []; board = [] for i in range(n): li = list(map(int, input().split())) board.append(li) for j in range(m): l.append((li[j], j)) l.sort(key = lambda x : x[0], reverse = True) idxs = set() z = 0 while len(idxs) < min(n, m): curr = l[z] idxs.add(curr[1]) z += 1 idxs = list(idxs) total = 0 for i in range(n ** n): rotations = []; num = i for j in range(n - 1, -1, -1): nj = n ** j q = num // nj num -= q * nj rotations.append(q) subtotal = 0 for k in range(n): subtotal += max(board[(k + rotations[col]) % n][idxs[col]] for col in range(min(n, m))) total = max(total, subtotal) print(total) main()",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",679
"import os,sys from io import BytesIO, IOBase def main(): inf = -float(""inf"") for _ in range(int(input())): n,m = map(int,input().split()) a = [list(map(int,input().split())) for _ in range(n)] y = 1<<n dp = [[0]+[inf]*(y-1) for _ in range(m+1)] for i in range(1,m+1): for shift in range(n): for mask1 in range(y): for mask2 in range(y): new = mask1^mask2 if new&mask1: continue mm,add = 1,0 for x in range(n): if mm&new: tt = x+shift if tt >= n: tt -= n add += a[tt][i-1] mm <<= 1 dp[i][mask2] = max(dp[i][mask2],dp[i-1][mask1]+add) print(dp[m][y-1]) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",1929
"for _ in range(int(input())): n,m=map(int,input().split()) a=[[int(x) for x in input().split()] for j in range(n)] x=[[a[i][j] for i in range(n)] for j in range(m)] x.sort(key=lambda xx:-max(xx)) dp=[[0 for i in range(1<<n)] for j in range(m+1)] an=0 for i in range(m): for prev in range(1<<n): for pres in range(1<<n): for j in range(n): ma=0 if prev^pres!=prev+pres: continue for st in range(n): if pres&(1<<st): ma+=x[i][(st+j)%n] dp[i+1][pres^prev]=max(dp[i+1][pres^prev],dp[i][prev]+ma) print(dp[m][(1<<n)-1])",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",514
"def naiveSolve(): return def main(): t=int(input()) allans=[] for _ in range(t): n,m=readIntArr() grid=[] for __ in range(n): grid.append(readIntArr()) columns=[] for col in range(m): temp=[grid[i][col] for i in range(n)] columns.append(temp) valCol=[] for i in range(n): for j in range(m): valCol.append((grid[i][j],j)) valCol.sort(reverse=True) topCols=set() for val,col in valCol: topCols.add(col) if len(topCols)==n: break m2=len(topCols) grid2=[[-1 for __ in range(m2)] for ___ in range(n)] topColsList=list(topCols) for j in range(m2): col=topColsList[j] for i in range(n): grid2[i][j]=grid[i][col] ans=-inf for mask in range(n**m2): grid3=[[-1 for __ in range(m2)] for ___ in range(n)] for col in range(m2): shift=mask%n for row in range(n): grid3[row][col]=grid2[(shift+row)%n][col] mask//=n tempAns=0 for row in range(n): maxx=-inf for col in range(m2): maxx=max(maxx,grid3[row][col]) tempAns+=maxx ans=max(ans,tempAns) allans.append(ans) multiLineArrayPrint(allans) return import sys input=sys.stdin.buffer.readline def oneLineArrayPrint(arr): print(' '.join([str(x) for x in arr])) def multiLineArrayPrint(arr): print('\n'.join([str(x) for x in arr])) def multiLineArrayOfArraysPrint(arr): print('\n'.join([' '.join([str(x) for x in y]) for y in arr])) def readIntArr(): return [int(x) for x in input().split()] def makeArr(defaultValFactory,dimensionArr): dv=defaultValFactory;da=dimensionArr if len(da)==1:return [dv() for _ in range(da[0])] else:return [makeArr(dv,da[1:]) for _ in range(da[0])] def queryInteractive(r): print('? {}'.format(r)) sys.stdout.flush() return readIntArr() def answerInteractive(adj,n): print('!') for u in range(1,n+1): for v in adj[u]: if v>u: print('{} {}'.format(u,v)) sys.stdout.flush() inf=float('inf') MOD=10**9+7 from math import gcd,floor,ceil for _abc in range(1): main()",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",1822
"rnd_mod = 1234567890133 rnd_x = 987654321098 def rnd(): global rnd_x rnd_x = rnd_x**2 % rnd_mod return (rnd_x>>5) % (1<<20) def randrange(a): return rnd() % a T = int(input()) for _ in range(T): N, M = map(int, input().split()) X = [] for __ in range(N): X.append([int(a) for a in input().split()]) Y = [[X[i][j] for i in range(N)] for j in range(M)] ma = 0 for t in range(577): for i in range(M): a = randrange(N) Y[i] = [Y[i][j-a] for j in range(N)] ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)])) print(ma)",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",533
"import sys input = sys.stdin.readline t=int(input()) for testcases in range(t): n,m=map(int,input().split()) A=[list(map(int,input().split())) for i in range(n)] B=[] for j in range(m): B.append([A[i][j] for i in range(n)]) B.sort(key=lambda x:max(x),reverse=True) B=B[:n] LEN=len(B) if LEN==1: print(sum(B[0])) elif LEN==2: ANS=0 for i in range(n): A=0 for k in range(n): A+=max(B[0][k],B[1][(i+k)%n]) ANS=max(ANS,A) print(ANS) elif LEN==3: ANS=0 for i in range(n): for j in range(n): A=0 for k in range(n): A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n]) ANS=max(ANS,A) print(ANS) elif LEN==4: ANS=0 for i in range(n): for j in range(n): for l in range(n): A=0 for k in range(n): A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n],B[3][(l+k)%n]) ANS=max(ANS,A) print(ANS)",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",761
"from sys import stdin def f(lst, num): new = lst[num:] + lst[:num] return new t = int(stdin.readline()) for i in range(t): row, col = tuple(int(x) for x in stdin.readline().split()) lst = list([int(x)] for x in stdin.readline().split()) for j in range(row-1): line = tuple(int(x) for x in stdin.readline().split()) for k in range(len(line)): lst[k].append(line[k]) lst.sort(key=lambda x: max(x), reverse = True) ans = float('-inf') for a in range(4): for b in range(4): for c in range(4): for d in range(4): if col >= 1: aa = f(lst[0], a) else: aa = (0,)*row if col >= 2: bb = f(lst[1], b) else: bb = (0,)*row if col >= 3: cc = f(lst[2], c) else: cc = (0,)*row if col >= 4: dd = f(lst[3], d) else: dd = (0,)*row ans = max(ans, sum(max(x[j] for x in (aa, bb, cc, dd)) for j in range(row))) print(ans)",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",799
"from random import randint for _ in range(int(input())): n, m = map(int, input().split()) A = [list(map(int, input().split())) for _ in range(n)] ans = 0 for _ in range(100): for j in range(m): x = randint(0, n - 1) if x: B = [] for i in range(n): B.append(A[i][j]) B = B[x:] + B[:x] for i in range(n): A[i][j] = B[i] c = 0 for i in range(n): c += max(A[i]) ans = max(ans, c) print(ans)",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",386
"t = int(input()) for i in range(t): n, m = [int(item) for item in input().split()] mat = [] col = [[] for _ in range(m)] for j in range(n): line = [int(item) for item in input().split()] for k, item in enumerate(line): col[k].append(item) mat.append(line) colmax = [] for line in col: colmax.append([max(line), line]) colmax.sort(reverse=True) colmax = colmax[:n] ans = 0 for j in range(n ** (n-1)): index = j rot = [0] for k in range(n-1): rot.append(index % n) index //= n ret = 0 for l in range(n): val = 0 for k in range(len(colmax)): val = max(val, colmax[k][1][(l + rot[k]) % n]) ret += val ans = max(ans, ret) print(ans)",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",627
"import random for _ in range(int(input())): N, M = map(int, input().split()) X = [[int(a) for a in input().split()] for _ in range(N)] Y = [[X[i][j] for i in range(N)] for j in range(M)] ma = 0 for t in range(99): for i in range(M): a = random.randrange(N) Y[i] = [Y[i][j-a] for j in range(N)] ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)])) print(ma)",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",375
"q = int(input()) for rquer in range(q): c, r = map(int, input().split()) matt = [list(map(int,input().split())) for i in range(c)] mat = [[matt[i][j] for i in range(c)] for j in range(r)] for i in range(r): mat[i].append(max(mat[i])) mat[i].reverse() mat.sort() mat.reverse() work = mat[:min(4, r)] for t in work: t.pop(0) r = min(4, r) wyn = 0 for num in range(c**r): shif = [(num//(c**i))%c for i in range(r)] new = 0 for i in range(c): kol = [work[j][(i + shif[j])%c] for j in range(r)] new += max(kol) wyn = max(wyn, new) print(wyn)",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",536
"for _ in range(int(input())): N, M = map(int, input().split()) X = [[int(a) for a in input().split()] for _ in range(N)] Y = [[X[i][j] for i in range(N)] for j in range(M)] ma = 0 dp = [[0] * (1<<N) for _ in range(M+1)] for j in range(M): for mask in range(1<<N): maskpre = mask while maskpre >= 0: maskpre &= mask ma = 0 for k in range(N): s = 0 for i in range(N): if (maskpre >> i) & 1 == 0 and (mask >> i) & 1: s += X[i-k][j] ma = max(ma, s) dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma) maskpre -= 1 print(dp[-1][-1])",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",531
"t = int(input()) def maxsa(A): ans = 0 for i in range(n): cur_maxx = 0 for j in range(4): cur_maxx = max(cur_maxx, A[j][i]) ans+= cur_maxx return ans def fu(A): answer = 0 for j in range(n): A[0] = A[0][1:] + A[0][:1] for i in range(n): A[1] = A[1][1:] + A[1][:1] for k in range(n): A[2] = A[2][1:] + A[2][:1] for l in range(n): A[3] = A[3][1:] + A[3][:1] cur_ans = maxsa(A) answer = max(answer, cur_ans) return answer for j in range(t): n,m = map(int,input().split()) A = [0] * n inds = [-1,-1,-1,-1] maxs =[ 0,0,0,0] for j in range(n): A[j] = list(map(int,input().split())) for j in range(m): cur_maxs = 0 for i in range(n): cur_maxs = max(cur_maxs, A[i][j]) maxs.append(cur_maxs) inds.append(j) ind = 4 while ind !=0 and maxs[ind] > maxs[ind-1]: inds[ind], inds[ind-1] = inds[ind-1] , inds[ind] maxs[ind], maxs[ind - 1] = maxs[ind - 1], maxs[ind] ind-=1 maxs.pop() inds.pop() S = [0] * 4 for j in range(4): if inds[j] != -1: S[j] = [s[inds[j]] for s in A] else: S[j] = [0] * n print(fu(S))",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",992
"def solve(matrix, col, N, M): if col == M: ans = 0 for row in matrix: if len(row) == 1: ans += row[0] else: ans += max(*row) return ans if N == 1: return solve(matrix, col + 1, N, M) ans = solve(matrix, col + 1, N, M) for _ in range(N-1): tmp = matrix[0][col] for n in range(1, N): matrix[n-1][col] = matrix[n][col] matrix[N-1][col] = tmp local_ans = solve(matrix, col + 1, N, M) if local_ans > ans: ans = local_ans return ans def main(): T = int(input()) for t in range(T): N, M = list(map(lambda x: int(x), input().split())) matrix = [] for n in range(N): matrix.append( list(map(lambda x: int(x), input().split())) ) elements = [] for n in range(N): for m in range(M): elements.append((matrix[n][m], m)) elements.sort(reverse=True) candidates = [] for t in elements: if t[1] not in candidates: candidates.append(t[1]) if len(candidates) == N: break simplified = [] for n in range(N): row = [] for m in candidates: row.append(matrix[n][m]) simplified.append(row) ans = solve(simplified, 0, N, min(N, M)) print(ans) main()",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",1023
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import factorial from collections import Counter, defaultdict, deque from heapq import heapify, heappop, heappush def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') def main(): for _ in range(N()): n, m = RL() arr = []",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",2000
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import factorial from collections import Counter, defaultdict, deque from heapq import heapify, heappop, heappush def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') def main(): for _ in range(N()): n, m = RL() arr = []",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",2000
"for _ in range(int(input())): N, M = map(int, input().split()) X = [[int(a) for a in input().split()] for _ in range(N)] Y = [[X[i][j] for i in range(N)] for j in range(M)] ma = 0 dp = [[0] * (1<<N) for _ in range(M+1)] for j in range(M): for mask in range(1<<N): maskpre = mask while maskpre >= 0: maskpre &= mask ma = 0 for k in range(N): s = 0 for i in range(N): if (maskpre >> i) & 1 == 0 and (mask >> i) & 1: s += X[i-k][j] ma = max(ma, s) dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma) maskpre -= 1 print(dp[-1][-1])",np,"['bitmasks', 'brute force', 'dp', 'greedy', 'sortings']",531
"import sys sys.setrecursionlimit(10**7) input = sys.stdin.readline INF = 10**9 n, m = [int(item) for item in input().split()] s = input().rstrip() count = [[0] * m for _ in range(m)] ord_a = ord(""a"") for c1, c2 in zip(s, s[1:]): c1 = ord(c1) - ord_a c2 = ord(c2) - ord_a if c1 != c2: count[c1][c2] += 1 sum_of_subset = [[0] * (1 << m) for _ in range(m)] for i in range(m): for j in range(1 << m): if j == 0: continue lsb = j & -j sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1] adj_in_subset = [0] * (1 << m) for i in range(1 << m): for j in range(m): if i & (1 << j): adj_in_subset[i] += sum_of_subset[j][i] total_adj = adj_in_subset[-1] dp = [INF] * (1 << m) dp[0] = 0 for i in range(1 << m): for j in range(m): if i & 1 << j: continue not_i = ((1 << m) - 1) ^ i val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i]) dp[i | (1 << j)] = min(dp[i | (1 << j)], val) print(dp[-1])",np,"['bitmasks', 'dp']",925
"import sys sys.setrecursionlimit(10**7) input = sys.stdin.readline INF = 10**9 n, m = [int(item) for item in input().split()] s = input().rstrip() count = [[0] * m for _ in range(m)] ord_a = ord(""a"") for c1, c2 in zip(s, s[1:]): c1 = ord(c1) - ord_a c2 = ord(c2) - ord_a if c1 != c2: count[c1][c2] += 1 sum_of_subset = [[0] * (1 << m) for _ in range(m)] for i in range(m): for j in range(1 << m): if j == 0: continue lsb = j & -j sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1] adj_in_subset = [0] * (1 << m) for i in range(1 << m): for j in range(m): if i & (1 << j): adj_in_subset[i] += sum_of_subset[j][i] total_adj = adj_in_subset[-1] dp = [INF] * (1 << m) dp[0] = 0 for i in range(1 << m): for j in range(m): if i & 1 << j: continue cost = total_adj - adj_in_subset[i] - adj_in_subset[~i] dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost) print(dp[-1])",np,"['bitmasks', 'dp']",895
"import sys sys.setrecursionlimit(10**7) input = sys.stdin.readline INF = 10**9 n, m = [int(item) for item in input().split()] s = input().rstrip() adj_in_subset = [0] * (1 << m) ord_a = ord(""a"") for c1, c2 in zip(s, s[1:]): c1 = ord(c1) - ord_a c2 = ord(c2) - ord_a if c1 != c2: adj_in_subset[(1 << c1) + (1 << c2)] += 1 for i in range(m): for j in range(1 << m): if j & (1 << i): adj_in_subset[j] += adj_in_subset[j ^ (1 << i)] total_adj = adj_in_subset[-1] dp = [INF] * (1 << m) dp[0] = 0 for i in range(1 << m): for j in range(m): if i & 1 << j: continue cost = total_adj - adj_in_subset[i] - adj_in_subset[~i] dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost) print(dp[-1])",np,"['bitmasks', 'dp']",682
"n, m = map(int, input().split()) a = list(map(str, input().strip())) dp = [10 ** 10] * (1 << 20) cnt = [0] * (1 << 20) def get(x): return 1 << (ord(x) - ord('a')) for i, v in enumerate(a): if i: cnt[get(a[i]) | get(a[i - 1])] += 1 for i in range(m): for j in range(1 << m): if (1 << i) & j: cnt[j] += cnt[j ^ (1 << i)] dp[0] = 0 for i in range(1 << m): for j in range(m): if not i & (1 << j): dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))]) print(dp[(1 << m) - 1])",np,"['bitmasks', 'dp']",529
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') from math import factorial from collections import Counter, defaultdict, deque from heapq import heapify, heappop, heappush def cord(c): return ord(c)-ord('a') def main(): n, m",np,"['bitmasks', 'dp']",1999
"def main(): k = int(input()) n = [] a = [] for i in range(k): line = [int(x) for x in input().split()] ni = line[0] ai = [] n.append(ni) a.append(ai) for j in range(ni): ai.append(line[1 + j]) answer, c, p = solve(k, n, a) if answer: print(""Yes"") for i in range(k): print(c[i], p[i] + 1) else: print(""No"") def solve(k, n, a): asum, sums = calc_sums(k, n, a) if asum % k != 0: return False, None, None tsum = asum / k num_map = build_num_map(k, n, a) masks = [None]*(1 << k) simple = [False]*(1 << k) for i in range(k): for j in range(n[i]): found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict()) if found: simple[mask] = True masks[mask] = path for i in range(1 << k): if not simple[i]: continue mask = i zeroes_count = 0 for u in range(k): if (1 << u) > mask: break if (mask & (1 << u)) == 0: zeroes_count += 1 for mask_mask in range(1 << zeroes_count): mask_child = 0 c = 0 for u in range(k): if (1 << u) > mask: break if (mask & (1 << u)) == 0: if (mask_mask & (1 << c)) != 0: mask_child = mask_child | (1 << u) c += 1 if masks[mask_child] and not masks[mask_child | mask]: masks[mask_child | mask] = {**masks[mask_child], **masks[mask]} if (mask_child | mask) == ((1 << k) - 1): c = [-1] * k p = [-1] * k d = masks[(1 << k) - 1] for key, val in d.items(): c[key] = val[0] p[key] = val[1] return True, c, p if masks[(1 << k) - 1]: c = [-1] * k p = [-1] * k d = masks[(1 << k) - 1] for key, val in d.items(): c[key] = val[0] p[key] = val[1] return True, c, p return False, None, None def build_num_map(k, n, a): result = dict() for i in range(k): for j in range(n[i]): result[a[i][j]] = (i, j) return result def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path): if (mask & (1 << i)) != 0: if i == i_origin and j == j_origin: return True, mask, path else: return False, None, None mask = mask | (1 << i) a_needed = tsum - (sums[i] - a[i][j]) if a_needed not in num_map: return False, None, None i_next, j_next = num_map[a_needed] path[i_nex",np,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",2000
"def main(): k = int(input()) n = [] a = [] for i in range(k): line = [int(x) for x in input().split()] ni = line[0] ai = [] n.append(ni) a.append(ai) for j in range(ni): ai.append(line[1 + j]) answer, c, p = solve(k, n, a) if answer: print(""Yes"") for i in range(k): print(c[i], p[i] + 1) else: print(""No"") def solve(k, n, a): asum, sums = calc_sums(k, n, a) if asum % k != 0: return False, None, None tsum = asum / k num_map = build_num_map(k, n, a) masks = [None]*(1 << k) answer = [False]*(1 << k) left = [0]*(1 << k) right = [0]*(1 << k) for i in range(k): for j in range(n[i]): found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict()) if found: answer[mask] = True masks[mask] = path for mask_right in range(1 << k): if not masks[mask_right]: continue zeroes_count = 0 for u in range(k): if (1 << u) > mask_right: break if (mask_right & (1 << u)) == 0: zeroes_count += 1 for mask_mask in range(1 << zeroes_count): mask_left = 0 c = 0 for u in range(k): if (1 << u) > mask_right: break if (mask_right & (1 << u)) == 0: if (mask_mask & (1 << c)) != 0: mask_left = mask_left | (1 << u) c += 1 joint_mask = mask_left | mask_right if answer[mask_left] and not answer[joint_mask]: answer[joint_mask] = True left[joint_mask] = mask_left right[joint_mask] = mask_right if joint_mask == ((1 << k) - 1): return build_answer(k, masks, left, right) if answer[(1 << k) - 1]: return build_answer(k, masks, left, right) return False, None, None def build_answer(k, masks, left, right): c = [-1] * k p = [-1] * k pos = (1 << k) - 1 while not masks[pos]: for key, val in masks[right[pos]].items(): c[key] = val[0] p[key] = val[1] pos = left[pos] for key, val in masks[pos].items(): c[key] = val[0] p[key] = val[1] return True, c, p def build_num_map(k, n, a): result = dict() for i in range(k): for j in range(n[i]): result[a[i][j]] = (i, j) return result def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path): if (mask & (1 << i)) != 0: if i == i_origin an",np,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",2000
"def main(): k = int(input()) n = [] a = [] for i in range(k): line = [int(x) for x in input().split()] ni = line[0] ai = [] n.append(ni) a.append(ai) for j in range(ni): ai.append(line[1 + j]) answer, c, p = solve(k, n, a) if answer: print(""Yes"") for i in range(k): print(c[i], p[i] + 1) else: print(""No"") def solve(k, n, a): asum, sums = calc_sums(k, n, a) if asum % k != 0: return False, None, None tsum = asum / k num_map = build_num_map(k, n, a) masks = [None]*(1 << k) simple = [False]*(1 << k) answer = [False]*(1 << k) left = [0]*(1 << k) right = [0]*(1 << k) by_last_one = [[] for _ in range(k)] for i in range(k): for j in range(n[i]): found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, []) if found and not answer[mask]: answer[mask] = True masks[mask] = path simple[mask] = True by_last_one[calc_last_one(mask)].append(mask) if answer[(1 << k) - 1]: return build_answer(k, masks, left, right) for mask_right in range(2, 1 << k): if not simple[mask_right]: continue last_one = calc_last_one(mask_right) zeroes_count = 0 alternative_sum = 0 zero_list = [] for u in range(last_one): if (mask_right & (1 << u)) == 0: zeroes_count += 1 alternative_sum += len(by_last_one[u]) zero_list.append(u) if zeroes_count == 0: continue if alternative_sum < (1 << zeroes_count): for fill_last_zero in zero_list: for mask_left in by_last_one[fill_last_zero]: if (mask_left & mask_right) != 0: continue joint_mask = mask_left | mask_right if not answer[joint_mask]: answer[joint_mask] = True left[joint_mask] = mask_left right[joint_mask] = mask_right by_last_one[last_one].append(joint_mask) if joint_mask == ((1 << k) - 1): return build_answer(k, masks, left, right) else: for mask_mask in range(1 << zeroes_count): mask_left = 0 for u in range(zeroes_count): if (mask_mask & (1 << u)) != 0: mask_left = mask_left | (1 << zero_list[u]) joint_mask = mask_left | mask_right if answer[mask_left] and not answer[joint_mask]: answer[joint_mask] = True left[joint_mask] = mask_left righ",np,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",2000
"from itertools import accumulate from sys import stdin, stdout def main(): k = int(stdin.readline()) a = [ tuple(map(int, stdin.readline().split()[1:])) for _ in range(k) ] a2ij = { aij: (i, j) for i, ai in enumerate(a) for j, aij in enumerate(ai) } plena = [0, ] + list(accumulate(map(len, a))) suma = tuple(map(sum, a)) totala = sum(suma) if totala % k != 0: stdout.write(""No\n"") else: needle = totala // k mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma) dp = compute_previous_mask(mask2i2cp) output(dp, mask2i2cp) def compute_mask2i2cp(a, a2ij, needle, plena, suma): used = [False, ] * plena[-1] number_of_masks = 1 << len(a) mask2i2cp = [-1, ] * number_of_masks for i, ai in enumerate(a): for j, aij in enumerate(ai): if not used[plena[i] + j]: mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma) if i2cp != -1: mask2i2cp[mask] = i2cp return mask2i2cp def output(dp, mask2i2cp): mask = len(mask2i2cp) - 1 if dp[mask] == -1: stdout.write(""No\n"") else: answer = [-1, ] * len(mask2i2cp[dp[mask]]) while mask > 0: current_mask = dp[mask] for i, cp in enumerate(mask2i2cp[current_mask]): if 1 == ((current_mask >> i) & 1): c, p = cp answer[i] = (c, p) mask ^= current_mask stdout.write('Yes\n' + '\n'.join('{} {}'.format(c, 1 + p) for c, p in answer)) def compute_mask_i2cp(a2ij, aij, i, j, needle, suma): i2cp = [-1, ] * len(suma) mask = 0 current_a = aij current_i = i try: while True: next_a = needle - (suma[current_i] - current_a) next_i, next_j = a2ij[next_a] if ((mask >> next_i) & 1) == 1: return mask, -1 mask |= 1 << next_i i2cp[next_i] = (next_a, current_i) if next_i == i: if next_j == j: return mask, i2cp return mask, -1 if next_i == current_i: return mask, -1 current_a = next_a current_i = next_i except KeyError: return mask, -1 def compute_previous_mask(mask2cp): number_of_masks = len(mask2cp) dp = [-1, ] * number_of_masks dp[0] = 0 for mask, cp in enumerate(mask2cp): if cp != -1: complement_mask = (number_of_masks - 1) & (~mask) previous_mask = complement_",np,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",2000
"from itertools import accumulate from sys import stdin, stdout def main(): k = int(stdin.readline()) a = [ tuple(map(int, stdin.readline().split()[1:])) for _ in range(k) ] a2ij = { aij: (i, j) for i, ai in enumerate(a) for j, aij in enumerate(ai) } plena = [0, ] + list(accumulate(map(len, a))) suma = tuple(map(sum, a)) totala = sum(suma) if totala % k != 0: stdout.write(""No\n"") else: needle = totala // k mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma) dp = compute_previous_mask(mask2i2cp) output(dp, mask2i2cp) def compute_mask2i2cp(a, a2ij, needle, plena, suma): used = [False, ] * plena[-1] number_of_masks = 1 << len(a) mask2i2cp = [-1, ] * number_of_masks for i, ai in enumerate(a): for j, aij in enumerate(ai): if not used[plena[i] + j]: mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma) if i2cp != -1: mask2i2cp[mask] = i2cp for cp in i2cp: if cp != -1: c, p = cp ii, jj = a2ij[c] used[plena[ii] + jj] = True return mask2i2cp def output(dp, mask2i2cp): mask = len(mask2i2cp) - 1 if dp[mask] == -1: stdout.write(""No\n"") else: answer = [-1, ] * len(mask2i2cp[dp[mask]]) while mask > 0: current_mask = dp[mask] for i, cp in enumerate(mask2i2cp[current_mask]): if 1 == ((current_mask >> i) & 1): c, p = cp answer[i] = (c, p) mask ^= current_mask stdout.write('Yes\n' + '\n'.join('{} {}'.format(c, 1 + p) for c, p in answer)) def compute_mask_i2cp(a2ij, aij, i, j, needle, suma): i2cp = [-1, ] * len(suma) mask = 0 current_a = aij current_i = i try: while True: next_a = needle - (suma[current_i] - current_a) next_i, next_j = a2ij[next_a] if ((mask >> next_i) & 1) == 1: return mask, -1 mask |= 1 << next_i i2cp[next_i] = (next_a, current_i) if next_i == i: if next_j == j: return mask, i2cp return mask, -1 if next_i == current_i: return mask, -1 current_a = next_a current_i = next_i except KeyError: return mask, -1 def compute_previous_mask(mask2cp): number_of_masks = len(mask2cp) dp = [-1, ] * number_of_masks dp[0] = 0 for mask, cp in enumerate(mask2cp): if cp",np,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",1999
"from collections import defaultdict data = defaultdict(list) position = defaultdict() nxt = defaultdict() agg_sum = list() k = int(input()) trace = defaultdict() F = [False for x in range(1 << k)] back = [0 for x in range(1 << k)] total_sum = 0 res = [(0, 0) for x in range(k)] def build_mask(trace_mask): if trace_mask == 0: return if trace.get(trace_mask): for data in trace.get(trace_mask): fr, to, v = data res[fr] = (v, to) return sub_mask = back[trace_mask] build_mask(sub_mask) build_mask(trace_mask - sub_mask) if __name__ == '__main__': for i in range(k): values = list(map(int, input().split(' '))) data[i] = values[1:] agg_sum.append(sum(data[i])) total_sum += agg_sum[i] for cnt, v in enumerate(data[i], 0): position[v] = (i, cnt) if total_sum % k != 0: print(""No"") exit(0) row_sum = total_sum // k for i in range(k): for cnt, value in enumerate(data.get(i), 0): x = i y = cnt mask = (1 << x) could = True circle = list() while True: next_value = row_sum - agg_sum[x] + data.get(x)[y] if position.get(next_value) is None: could = False break last_x = x last_y = y x, y = position.get(next_value) circle.append((x, last_x, next_value)) if x == i and y == cnt: break if mask & (1 << x): could = False break mask |= (1 << x) F[mask] |= could if could: trace[mask] = circle for mask in range(1, 1 << k): sub = mask while sub > 0: if F[sub] and F[mask - sub]: F[mask] = True back[mask] = sub break sub = mask & (sub - 1) if F[(1 << k) - 1]: print('Yes') build_mask((1 << k) - 1) for value in res: print(value[0], value[1] + 1) else: print('No')",np,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",1551
"import sys n = sys.stdin.readline() n = int(n) def get_graph(n): graph = [] for _ in range(n): entries = list(map(lambda x : int(x), sys.stdin.readline().split("" "")[1:])) graph.append(entries) return graph def chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val): mask = 2**bucket_num mem = [] buckets_seen = set({bucket_num}) og_bucket = bucket_num og_val = val for _ in range(len(buckets)): rem = target - sum_bucket[bucket_num] + val if rem not in reverse_bucket: return None, [] new_bucket = reverse_bucket[rem] if new_bucket == og_bucket and rem != og_val: return None, [] elif new_bucket == og_bucket and rem == og_val: mem.append((rem, bucket_num)) return mask | 2**new_bucket, mem elif new_bucket in buckets_seen: return None, [] buckets_seen.add(new_bucket) mask = mask | 2**new_bucket mem.append((rem, bucket_num)) bucket_num = new_bucket val = rem return None, [] def helper(chains, mask, mem): if mask == 0: return [] if mask in mem: return mem[mask] for i, chain in enumerate(chains): if (mask >> i) & 0: continue for key in chain: if key | mask != mask: continue future = helper(chains, ~key & mask, mem) if future is not None: mem[mask] = chain[key] + future return mem[mask] mem[mask] = None return None def solve(n): buckets = get_graph(n) reverse_bucket = {} sum_bucket = [0]* len(buckets) total_sum = 0 for i, bucket in enumerate(buckets): for x in bucket: total_sum += x sum_bucket[i] += x reverse_bucket[x] = i target = total_sum / len(buckets) chains = [] for i, bucket in enumerate(buckets): seto = {} for x in bucket: key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x) if key is not None: seto[key] = val chains.append(seto) return helper(chains, 2 ** len(buckets) - 1, {}), reverse_bucket def result(n): res, reverse_bucket = solve(n) if res is None: sys.stdout.write(""No\n"") else: res = sorted(res, key = lambda x : reverse_bucket[x[0]]) sys.stdout.write(""Yes\n"") for x, y in res: x = int(x) y = int(y) + 1 stuff = "" "".join([str(x), str(y), """,np,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",2000
"import sys n = sys.stdin.readline() n = int(n) def get_graph(n): graph = [] for _ in range(n): entries = list(map(lambda x : int(x), sys.stdin.readline().split("" "")[1:])) graph.append(entries) return graph def chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val): mask = 2**bucket_num mem = [] buckets_seen = set({bucket_num}) og_bucket = bucket_num og_val = val for _ in range(len(buckets)): rem = target - sum_bucket[bucket_num] + val if rem not in reverse_bucket: return None, [] new_bucket = reverse_bucket[rem] if new_bucket == og_bucket and rem != og_val: return None, [] elif new_bucket == og_bucket and rem == og_val: mem.append((rem, bucket_num)) return mask | 2**new_bucket, mem elif new_bucket in buckets_seen: return None, [] buckets_seen.add(new_bucket) mask = mask | 2**new_bucket mem.append((rem, bucket_num)) bucket_num = new_bucket val = rem return None, [] def helper(chains, mask, mem): if mask == 0: return [] if mask in mem: return mem[mask] for i, chain in enumerate(chains): if (mask >> i) & 0: continue for key in chain: if key | mask != mask: continue future = helper(chains, ~key & mask, mem) if future is not None: mem[mask] = chain[key] + future return mem[mask] mem[mask] = None return None def solve(n): buckets = get_graph(n) reverse_bucket = {} sum_bucket = [0]* len(buckets) total_sum = 0 for i, bucket in enumerate(buckets): for x in bucket: total_sum += x sum_bucket[i] += x reverse_bucket[x] = i target = total_sum / len(buckets) chains = [] for i, bucket in enumerate(buckets): seto = {} for x in bucket: key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x) if key is not None: seto[key] = val chains.append(seto) mem = {} for i in range (2**len(buckets)-1): helper(chains, i, mem) return helper(chains, 2 ** len(buckets) - 1, mem), reverse_bucket def result(n): res, reverse_bucket = solve(n) if res is None: sys.stdout.write(""No\n"") else: res = sorted(res, key = lambda x : reverse_bucket[x[0]]) sys.stdout.write(""Yes\n"") for x, y",np,"['bitmasks', 'dfs and similar', 'dp', 'graphs']",1999
"import os,sys from io import BytesIO, IOBase def check(mid,arr,m,n): ls = [[] for _ in range(1<<m)] for i in range(n): ans = 0 for j in range(m): if arr[i][j] >= mid: ans += 1<<j ls[ans].append(i+1) for i in range(len(ls)): for j in range(len(ls)): if len(ls[i]) and len(ls[j]) and i|j == (1<<m)-1: return ls[i][0],ls[j][0] return 0 def main(): n,m = map(int,input().split()) arr = [list(map(int,input().split())) for _ in range(n)] hi,lo,ind1 = 10**9,0,(1,1) while hi >= lo: mid = (hi+lo)//2 ind = check(mid,arr,m,n) if ind: ind1 = ind lo = mid+1 else: hi = mid-1 print(*ind1) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") if __name__ == '__main__': main()",np,"['binary search', 'bitmasks', 'dp']",1956
"import os import sys from collections import * from bisect import * from io import BytesIO, IOBase def vsInput(): sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") ALPHA='abcdefghijklmnopqrstuvwxyz' M=998244353 EPS=1e-6 def Ceil(a,b): return a//b+int(a%b>0) def value():return tuple(map(int,input().split())) def array():return [int(i) for i in input().split()] def Int():return int(input()) def Str():return input() def arrayS():return [i for i in input().split()] def ok(here): have = defaultdict(lambda : -1) for j in range(n): b = a[j] s = '' for i in b: if(i>=here): s+='1' else: s+='0' have[int(s,2)] = j for i in range(300):",np,"['binary search', 'bitmasks', 'dp']",1998
"MAX=10**9 def main(): n,m=readIntArr() arrs=[] for _ in range(n): arrs.append(readIntArr()) def checkPossible(minB): binRepresentations=set() for arr in arrs: binRepresentations.add(convertToBinary(arr,minB)) binList=list(binRepresentations) ii=jj=-1 n=len(binList) for i in range(n): for j in range(i,n): if binList[i]|binList[j]==(1<<m)-1: ii=binList[i] jj=binList[j] if ii!=-1: ansi=ansj=-1 for i in range(len(arrs)): b=convertToBinary(arrs[i],minB) if b==ii: ansi=i if b==jj: ansj=i return (ansi,ansj) else: return None def convertToBinary(arr,minB): b=0 for i in range(m): if arr[i]>=minB: b|=(1<<i) return b minB=-1 i=j=-1 b=MAX while b>0: temp=checkPossible(minB+b) if temp==None: b//=2 else: minB+=b i,j=temp i+=1;j+=1 print('{} {}'.format(i,j)) return import sys input=sys.stdin.buffer.readline def oneLineArrayPrint(arr): print(' '.join([str(x) for x in arr])) def multiLineArrayPrint(arr): print('\n'.join([str(x) for x in arr])) def multiLineArrayOfArraysPrint(arr): print('\n'.join([' '.join([str(x) for x in y]) for y in arr])) def readIntArr(): return [int(x) for x in input().split()] def makeArr(*args): assert len(args) >= 2, ""makeArr args should be (default value, dimension 1, dimension 2,..."" if len(args) == 2: return [args[0] for _ in range(args[1])] else: return [makeArr(args[0],*args[2:]) for _ in range(args[1])] def queryInteractive(x,y): print('? {} {}'.format(x,y)) sys.stdout.flush() return int(input()) def answerInteractive(ans): print('! {}'.format(ans)) sys.stdout.flush() inf=float('inf') MOD=10**9+7 for _abc in range(1): main()",np,"['binary search', 'bitmasks', 'dp']",1565
"import os import sys import math from io import BytesIO, IOBase from fractions import Fraction import collections from itertools import permutations from collections import defaultdict from collections import deque import threading BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class SegmentTree: def __init__(self, data, default=0, func=lambda a, b: a+b): self._default = default self._func = func self._len = len(data) self._size = _size = 1 << (self._len - 1).bit_length() self.data = [default] * (2 * _size) self.data[_size:_size + self._len] = data for i in reversed(range(_size)): self.data[i] = func(self.data[i + i], self.data[i + i + 1]) def __delitem__(self, idx): self[idx] = self._default",np,"['binary search', 'bitmasks', 'dp']",1999
"import sys def find_pair(candidate,data,m): ans = (-1,-1) binary_bit = [False for i in range(1 << m)] for i in data: bit_tmp = 0 for j in range(len(i)): if i[j] >= candidate: bit_tmp |= 1 << j binary_bit[bit_tmp] = True for i in range(1 << m): for j in range(1 << m): if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]: ans = i , j break return ans def backtracking(candidate,ans,data): idx_i = -1 ; idx_j = -1 for i in range(len(data)): bit_tmp = 0 for j in range(len(data[i])): if data[i][j] >= candidate: bit_tmp |= 1 << j if bit_tmp == ans[0]: idx_i = i if bit_tmp == ans[1]: idx_j = i print(str(idx_i + 1) + "" "" + str(idx_j + 1)) def main(): n , m = [int(i) for i in input().split()] data = [[int(i) for i in input().split()] for i in range(n)] a = 0 ; b = 10**9 + 7 ans = (-1,-1) candidate = -1 while a <= b: mid = (a + b)//2 bin_ans = find_pair(mid,data,m) if bin_ans[0] != -1 and bin_ans[1] != -1: ans = bin_ans candidate = mid a = mid + 1 else: b = mid - 1 backtracking(candidate,ans,data) main()",np,"['binary search', 'bitmasks', 'dp']",1019
"import sys input = sys.stdin.buffer.readline n,m=map(lambda x:int(x), input().split()) A = [] for _ in range(n): scores = list(map(lambda x:int(x), input().split())) A.append(scores) def solve(n,m,A): ans = () nstats = 2**m def judge(finalScore): nonlocal ans seen = {} for i,scores in enumerate(A): sta = 0 for e in scores: sta=sta*2+(e>=finalScore) seen[sta]=i for i in range(nstats): for j in range(nstats): if ((i|j) == nstats-1) and i in seen and j in seen: ans = (seen[i], seen[j]) return True return False l=0 r=2**31-1 while l<r: m=l+(r-l)//2 if not judge(m): r=m else: l=m+1 print(ans[0]+1,ans[1]+1) solve(n,m,A)",np,"['binary search', 'bitmasks', 'dp']",621
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline n,m=map(lambda x:int(x), input().split()) A = [] for _ in range(n): scores = list(map(lambda x:int(x), input().split())) A.append(scores) def solve(n,m,A): ans = () nstats = 2**m def judge(finalScore): nonlocal ans seen = {} for i,scores in enumerate(A): sta = 0 for e in scores: sta=sta*2+(e>=finalScore) seen[sta]=i for i in range(nstats): for j in range(nstats): if ((i|j) == nstats-1) and i in seen and j in seen: ans = (seen[i], seen[j]) return True return False l=0 r=2**31-1 while l<r: m=l+(r-l)//2 if not judge(m): r=m else: l=m+1 print(ans[0]+1,ans[1]+1) solve(n,m,A)",np,"['binary search', 'bitmasks', 'dp']",650
"import sys,os,io input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from collections import defaultdict n,m = [int(i) for i in input().split()] a = [] mi = -1 ma = 10**9 for i in range (n): a.append([int(j) for j in input().split()]) ans = [] while(mi<ma): mid = (mi+ma+1)//2 masks = {} for i in range (n): currMask = 0 for j in range (m): if a[i][j] >= mid: currMask += 1<<j masks[currMask] = i req = (1<<m) - 1 possible = 0 for i in masks: for j in masks: if i|j == req: possible = 1 ans = [masks[i]+1,masks[j]+1] break if possible: break if possible: mi = mid else: ma = mid - 1 print(*ans)",np,"['binary search', 'bitmasks', 'dp']",603
"import os import sys from io import BytesIO, IOBase from collections import Counter def check(a,mid,n,m,z): b=Counter() for i in range(n): c=[""0""]*m for j in range(m): if a[i][j]>=mid: c[j]=""1"" zz=int("""".join(c),2) b[zz]=i c=list(b.keys()) lc=len(c) for i in range(lc): for j in range(i,lc): if c[i]|c[j]==z: mi,x,y=10000000000,b[c[i]],b[c[j]] for k in range(m): mi=min(mi,max(a[x][k],a[y][k])) if mi>=mid: return (x,y) def main(): n,m= map(int, input().split()) a=[list(map(int,input().split())) for _ in range(n)] lo,hi,ans,y=0,10**9,[1,1],(1<<m)-1 while lo<=hi: mid=(lo+hi)//2 z=check(a,mid,n,m,y) if z: lo=mid+1 ans=[z[0]+1,z[1]+1] else: hi=mid-1 print(*ans) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip",np,"['binary search', 'bitmasks', 'dp']",1999
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") n,m = map(int,input().split()) A = [None]*n lo,hi = 1<<32,-1<<32 for i in range(n): A[i] = list(map(int,input().split())) lo = min(min(A[i]), lo) hi = max(max(A[i]), hi) best = -1 ans = [-1,-1] def possible(x): global best, ans M = [-1]*(1<<m) for i in range(n): mask = 0 for j in range(m): if A[i][j] >= x: mask += (1<<j) M[mask] = i for m0 in range(1<<m): if M[m0] == -1: continue for m1 in range(1<<m): if M[m1] == -1: continue if m0 | m1 == (1<<m) - 1: if best < x: best = x ans = [M[m0]+1, M[m1]+1] return True return False possible(hi) possible(lo) while lo+1 < hi: mid = (lo+hi)//2 if possible(mi",np,"['binary search', 'bitmasks', 'dp']",2000
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline n,m=map(int,input().split()) a=[list(map(int,input().split())) for i in range(n)] l=-1;r=10**9+1 ans1,ans2=-1,-1 while r-l>1: x=(l+r)//2 idx={} for i in range(n): v=0 for j in range(m): if a[i][j]>=x: v+=1 v<<=1 idx[v>>1]=i ok=False idx1,idx2=0,0 for aa,bb in idx.items(): for cc,dd in idx.items(): for d in range(m): if (aa|cc)==(2**m)-1: ok=True idx1=bb+1 idx2=dd+1 if ok: l=x ans1=idx1 ans2=idx2 else: r=x print(ans1,ans2)",np,"['binary search', 'bitmasks', 'dp']",499
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from collections import defaultdict as dd n,m=map(int,input().split()) l1=[] for i in range(n): l1.append(list(map(int,input().split()))) l=0 h=10**9 c=2**m-1 x,y=1,2 while l<=h: mid=(l+h)//2 d=dd(int) d1=dd(int) for i in range(n): s=[] for j in range(m): if l1[i][j]>=mid: s.append('1') else: s.append('0') s=int(''.join(s),2) d[s]+=1 d1[s]=i+1 f=0 for i in d: for j in d: if i|j==c: f=1 x=d1[i] y=d1[j] break if f: break if f: if l==h: break l=mid+1 else: if l==h: break h=mid print(x,y)",np,"['binary search', 'bitmasks', 'dp']",1886
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import ceil def prod(a, mod=10 ** 9 + 7): ans = 1 for each in a: ans = (ans * each) % mod return ans def gcd(x, y): while y: x, y = y, x % y return x def lcm(a, b): return a * b // gcd(a, b) def binary(x, length=16): y = bin(x)[2:] return y if len(y) >= length else ""0"" * (length - len(y)) + y from math import inf for _ in range(int(input()) if not True else 1): n, m = map(int, input().split()) a = [] for i in range(n): a += [list(map(int, input().split()))] alpha, omega = 0, 10**9 def solve(mid): index = [-1] * (1 << m) for i in range(n): val = 0 for j in range(m): if a[i][j] >= mid: v",np,"['binary search', 'bitmasks', 'dp']",1999
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import ceil def prod(a, mod=10 ** 9 + 7): ans = 1 for each in a: ans = (ans * each) % mod return ans def gcd(x, y): while y: x, y = y, x % y return x def lcm(a, b): return a * b // gcd(a, b) def binary(x, length=16): y = bin(x)[2:] return y if len(y) >= length else ""0"" * (length - len(y)) + y from math import inf for _ in range(int(input()) if not True else 1): n, m = map(int, input().split()) a = [] for i in range(n): a += [list(map(int, input().split()))] alpha, omega = 0, 10**9 def solve(mid): index = [-1] * (1 << m) for i in range(n): val = 0 for j in range(m): if a[i][j] >= mid: v",np,"['binary search', 'bitmasks', 'dp']",1999
"import sys input = sys.stdin.readline n, m = map(int, input().split()) mask = (1 << m) - 1 l = [] for i in range(n): l.append(list(map(int,input().split()))) lo = -1 hi = 10 ** 9 + 1 while hi - lo > 1: test = (hi + lo) // 2 things = dict() for i in range(n): curr = 0 for v in l[i]: curr *= 2 if v >= test: curr += 1 things[curr] = i works = False for v1 in things: for v2 in things: if v1 | v2 == mask: outi = things[v1] outj = things[v2] works = True break if works: break if works: lo = test else: hi = test print(outi + 1, outj + 1)",np,"['binary search', 'bitmasks', 'dp']",536
"def isPoss(n, arrs, nvals): masks = set() midx = {} for pos,arr in enumerate(arrs): mask = 0 for i in range(nvals): if arr[i]>=n: mask += 1<<i midx[mask] = pos+1 masks.add(mask) for m1 in masks: for m2 in masks: if m1|m2 == (1<<nvals)-1: return midx[m1], midx[m2] return -1, -1 narr, nvals = map(int, input().split()) arrs = [] for i in range(narr): arrs.append(list(map(int, input().split()))) mn = -1 mx = 10**9+1 while mn < mx-1: mid = (mn + mx) // 2 a,b = isPoss(mid, arrs, nvals) if a != -1: mn = mid else: mx = mid - 1 for i in range(1,-1,-1): a,b = isPoss(mn+i, arrs, nvals) if a != -1: print(a,b) break",np,"['binary search', 'bitmasks', 'dp']",610
"import sys reader = (s.rstrip() for s in sys.stdin) input = reader.__next__ n,m = map(int, input().split()) a = [] for i in range(n): ai = list(map(int, input().split())) a.append(ai) def check(mid): mask = (1<<m)-1 s = set() d = dict() for i in range(n): state = 0 for j in range(m): if a[i][j] >= mid: state += 1<<j if state in s: continue s.add(state) k = state while k>=0: k &= state d[k] = i k -= 1 need = mask^state if need in d: q1, q2 = d[need], i if q1 > q2: q1, q2 = q2, q1 return True, (q1, q2) return False, (-1, -1) left = 0 right = 10**9+1 i,j = 0, 0 while right-left>1: mid = (right+left)//2 flag, (q1, q2) = check(mid) if flag: left = mid i,j = q1, q2 else: right = mid print(i+1, j+1)",np,"['binary search', 'bitmasks', 'dp']",701
"import sys input = sys.stdin.readline def main(): n,m = map(int,input().split()) a = [] for _ in [0]*n: a.append(list(map(int,input().split()))) ok = 0 ng = 10**9+1 judge = pow(2,m)-1 dg = 1000 while ng-ok > 1: mid = (ng+ok)//2 tank = set() for i in range(n): r = 0 for j in range(m): r *= 2 if a[i][j] >= mid: r += 1 tank.add(r) for p in tank: for q in tank: if p|q == judge: ok = mid break if ok != mid: ng = mid tank = set() res = [] for i in range(n): r = 0 for j in range(m): r *= 2 if a[i][j] >= ok: r += 1 if not r in tank: res.append(i*dg+r) tank.add(r) for p in res: for q in res: if (p%dg)|(q%dg) == judge: print(p//dg+1,q//dg+1) return if __name__ == '__main__': main()",np,"['binary search', 'bitmasks', 'dp']",680
"import sys readline = sys.stdin.readline def popcount(i): assert 0 <= i < 0x100000000 i = i - ((i >> 1) & 0x55555555) i = (i & 0x33333333) + ((i >> 2) & 0x33333333) return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24 N, M = map(int, readline().split()) Ar = [tuple(map(int, readline().split())) for _ in range(N)] pc = [popcount(i) for i in range(1<<(M+1))] inf = 1<<31 maxi = [0]*(1<<M) for i in range(N): a = Ar[i] dp = [0]*(1<<M) for S in range(1, 1<<M): p = pc[S] if p == 1: k = S.bit_length() - 1 dp[S] = a[k] else: dp[S] = min(dp[-S&S], dp[S^(-S&S)]) maxi[S] = max(maxi[S], dp[S]) for i in range(M): for j in range(1<<M): if not j & (1<<i): maxi[j] = max(maxi[j], maxi[j|(1<<i)]) D = (1<<M)-1 ans = maxi[D] aS, bS = D, D for S in range(1<<M): candi = min(maxi[S], maxi[D^S]) if candi > ans: aS, bS = S, D^S ans = candi Ans = [None]*2 pre = False fro = False for i in range(N): a = Ar[i] resa = inf resb = inf for j in range(M): if (1<<j)&aS: resa = min(resa, a[j]) else: resb = min(resb, a[j]) if resa >= ans: pre = True Ans[0] = i+1 if resb >= ans: fro = True Ans[1] = i+1 if pre and fro: break print(*Ans)",np,"['binary search', 'bitmasks', 'dp']",1130
"import sys input = sys.stdin.readline n,m=map(int,input().split()) A=[list(map(int,input().split())) for i in range(n)] SET=set() for a in A: SET|=set(a) compression_dict={a: ind for ind, a in enumerate(sorted(SET))} for i in range(n): A[i]=[compression_dict[a] for a in A[i]] OK=0 NG=len(compression_dict) ANS=[1,1] B=[set()]*n P=[2,3,5,7,11,13,17,19] Q=1 for j in range(m): Q*=P[j] import math def ya(x): xr=math.ceil(math.sqrt(x)) LIST=[] for i in range(1,xr+1): if x%i==0: LIST.append(i) LIST.append(x//i) return LIST while NG>OK+1: mid=(OK+NG)//2 SET=set() for i in range(n): NOW=1 for j in range(m): if A[i][j]>=mid: NOW*=P[j] B[i]=NOW SET.add(NOW) flag=0 for s in SET: for l in ya(s): if Q//l in SET: flag=1 OK=mid break if flag: break else: NG=mid SET=set() for i in range(n): NOW=1 for j in range(m): if A[i][j]>=OK: NOW*=P[j] B[i]=NOW SET.add(NOW) flag=0 for i in range(n): for l in ya(B[i]): if Q//l in SET: ANS1=i flag=1 break if flag: break LIST=ya(B[i]) SET=set(LIST) for i in range(n): if Q//B[i] in SET: ANS2=i print(ANS1+1,ANS2+1)",np,"['binary search', 'bitmasks', 'dp']",1047
"n, m = map(int, input().split()) a = [list(map(int, input().split())) for _ in range(n)] left = 0 right = 10**9+1 ans = (0, 0) while left < right: mid = (left + right) // 2 masks = {} for i in range(n): mask = 0 for j in a[i]: mask <<= 1 if j >= mid: mask += 1 masks[mask] = i ok = False for m1 in masks: for m2 in masks: if m1 | m2 == ((1 << m) - 1): ok = True ans = (masks[m1]+1, masks[m2]+1) break if ok: break if ok: left = mid+1 else: right = mid print(ans[0], ans[1])",np,"['binary search', 'bitmasks', 'dp']",473
"def main(): N, M = map(int, input().split()) L = [tuple(map(int, input().split())) for _ in range(N)] maxi = max(max(t) for t in L)+1 mini, res = max((min(t), i) for i, t in enumerate(L)) res = res, res BITMASK = (1 << M) while True: mid = (maxi+mini)//2 if mid == mini: break masks = [None]*BITMASK for i, t in enumerate(L): tmask = 0 for v in t: tmask *= 2 if v >= mid: tmask += 1 if masks[tmask] is not None: continue masks[tmask] = i for k in range(BITMASK): if masks[k] is not None and k | tmask == BITMASK-1: res = masks[k], i mini = mid = min(max(a, b) for a, b in zip(L[res[0]], L[res[1]])) break else: continue break else: maxi = mid print(res[0]+1, res[1]+1) main()",np,"['binary search', 'bitmasks', 'dp']",675
"import sys from collections import defaultdict reader = (map(int, line.split()) for line in sys.stdin) input = reader.__next__ n, m = input() elems = set() vals = defaultdict(list) for i in range(n): for pos, v in enumerate(input()): elems.add(v) vals[v].append((pos, i)) elems = sorted(elems, reverse=True) masks = [0] * n full = (1<<m) - 1 met = {0:0} for v in elems: for pos, i in vals[v]: curr_mask = masks[i] = masks[i] | (1<<pos) met[curr_mask] = i complement = full ^ curr_mask if complement in met: print(i+1, met[complement]+1) sys.exit()",np,"['binary search', 'bitmasks', 'dp']",547
"import collections import time import os import sys import bisect import heapq from typing import List def check(val, A, M): s = set() for row in A: v = 0 for u in row: v <<= 1 if u >= val: v |= 1 s.add(v) x = 1 << M for u in s: for v in range(x): if v in s and u | v == x - 1: return True return False def getAnswer(val, A, M): vi = {} for i, row in enumerate(A): v = 0 for u in row: v <<= 1 if u >= val: v |= 1 vi[v] = i x = 1 << M for u in vi: for v in range(x): if v in vi and u | v == x - 1: return vi[u], vi[v] return 0, 0 def solve(N, M, A): lo, hi = 0, max([max(row) for row in A]) while lo <= hi: m = (lo + hi) // 2 if check(m, A, M): lo = m + 1 else: hi = m - 1 a, b = getAnswer(hi, A, M) print('{} {}'.format(a + 1, b + 1)) N, M = map(int, input().split()) A = [] for i in range(N): row = [int(x) for x in input().split()] A.append(row) solve(N, M, A)",np,"['binary search', 'bitmasks', 'dp']",862
"import sys input=sys.stdin.readline n,m=map(int,input().split()) a=[] def bs(a,mid,ans): global n,m can=[0 for i in range(1<<m)] for i in range(n): t=0 for j in range(m): t=(t<<1)|(a[i][j]>=mid) can[t]=i+1 for i in range(1<<m): if(not can[i]): continue for j in range(1<<m): if not can[j]: continue if i|j==(1<<m)-1: ans[0]=can[i] ans[1]=can[j] return 1 return 0 for i in range(n): p=[int(x) for x in input().split()] a.append(p) l=0 r=100000000000 ans=[1,1] while l<=r: mid=(l+r)//2 if bs(a,mid,ans): l=mid+1 else: r=mid-1 print(*ans)",np,"['binary search', 'bitmasks', 'dp']",535
"import sys def input(): return sys.stdin.readline().strip() def list2d(a, b, c): return [[c] * b for i in range(a)] def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)] def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)] def ceil(x, y=1): return int(-(-x // y)) def INT(): return int(input()) def MAP(): return map(int, input().split()) def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)] def Yes(): print('Yes') def No(): print('No') def YES(): print('YES') def NO(): print('NO') sys.setrecursionlimit(10 ** 9) INF = 10 ** 18 MOD = 10 ** 9 + 7 def bisearch_max(mn, mx, func): ok = mn ng = mx while ok+1 < ng: mid = (ok+ng) // 2 if func(mid): ok = mid else: ng = mid return ok def check(m): ok = [0] * N S = set() for i in range(N): for j in range(M): if A[i][j] >= m: ok[i] |= 1<<j S.add(ok[i]) full = (1<<M) - 1 for bit1 in range(1<<M): for bit2 in range(bit1, 1<<M): if bit1 in S and bit2 in S: if bit1 | bit2 == full: return True return False N, M = MAP() A = [None] * N for i in range(N): A[i] = LIST() res = bisearch_max(0, 10**9+1, check) ok = [0] * N S = set() D = {} for i in range(N): for j in range(M): if A[i][j] >= res: ok[i] |= 1<<j S.add(ok[i]) D[ok[i]] = i + 1 full = (1<<M) - 1 for bit1 in range(1<<M): for bit2 in range(bit1, 1<<M): if bit1 in S and bit2 in S: if bit1 | bit2 == full: print(D[bit1], D[bit2]) exit()",np,"['binary search', 'bitmasks', 'dp']",1438
"from collections import defaultdict from sys import stdin input = stdin.readline def check(mid, m): d = defaultdict(int) for idx, i in enumerate(a): string = '' for j in i: if j >= mid: string+='1' else: string+='0' d[int(string, 2)] = idx for i in d.keys(): for j in d.keys(): if i|j == 2**m - 1: return [d[i], d[j]] return [] def binarySearch(lo, hi, m): ans = [] while lo < hi: mid = lo + (hi-lo+1)//2 x = check(mid, m) if x: lo = mid ans = [x[0]+1, x[1]+1] else: hi = mid-1 return ans n, m = map(int, input().split()) a = [] for i in range(n): a.append(list(map(int, input().split()))) print(*binarySearch(-1, 10**9+1, m))",np,"['binary search', 'bitmasks', 'dp']",626
"from collections import defaultdict from sys import stdin input = stdin.readline def check(mid, m): d = defaultdict(int) for idx, i in enumerate(a): string = '' for j in i: if j >= mid: string+='1' else: string+='0' d[int(string, 2)] = idx for i in d.keys(): for j in d.keys(): if i|j == 2**m - 1: return [d[i], d[j]] return [] def binarySearch(lo, hi, m): ans = [] while lo < hi: mid = lo + (hi-lo+1)//2 x = check(mid, m) if x: lo = mid ans = [x[0]+1, x[1]+1] else: hi = mid-1 mid = lo + (hi-lo+1)//2 x = check(mid, m) if x: ans = [x[0]+1, x[1]+1] return ans n, m = map(int, input().split()) a = [] for i in range(n): a.append(list(map(int, input().split()))) print(*binarySearch(0, 10**9, m))",np,"['binary search', 'bitmasks', 'dp']",694
"from sys import stdin, stdout import gc gc.disable() input = stdin.readline from collections import defaultdict def check(num): bitmask = set() for i in range(n): b = 0 for j in range(m): if arr[i][j] >= num: b ^= 1 << j bitmask.add(b) target = 2** m - 1 for i in bitmask: for j in bitmask: if i | j == target: return True return False n, m = list(map(int, input().split())) arr = [] for _ in range(n): arr.append(list(map(int, input().split()))) start = 0 end = 10 ** 9 ans = -1 while start <= end: mid = (start + end) // 2 if check(mid): ans = mid start = mid + 1 else: end = mid - 1 bitmask = defaultdict(list) for i in range(n): b = 0 for j in range(m): if arr[i][j] >= ans: b += 1<< j bitmask[b].append(i + 1) target = 2 ** m - 1 for i in bitmask: for j in bitmask: if i | j == target: print(bitmask[i][0], bitmask[j][0]) exit()",np,"['binary search', 'bitmasks', 'dp']",833
"import os, sys, atexit from io import BytesIO, StringIO input = BytesIO(os.read(0, os.fstat(0).st_size)).readline _OUTPUT_BUFFER = StringIO() sys.stdout = _OUTPUT_BUFFER @atexit.register def write(): sys.__stdout__.write(_OUTPUT_BUFFER.getvalue()) n, m = map(int, input().split()) arr = [0] * n for i in range(n): temp = list(map(int, input().split())) arr[i] = temp x = 1 N = 2 ** m - 1 lo = 1 hi = 1000000009 ind = [0, 0] while 1: l = {} freq = [0] * (2 ** m) for i in range(n): an = 0 for j in range(m): if arr[i][j] >= x: an += 2 ** (m - j - 1) if freq[an] == 0: l[i] = an freq[an] = 1 ch = 0 for k1, v1 in l.items(): for k2, v2 in l.items(): if v1 | v2 == N: ch = 1 ind[0] = k1 + 1 ind[1] = k2 + 1 break if ch: break if ch: lo = x x = x * 2 else: hi = x break ans = lo while hi - lo > 1: x = (lo + hi) // 2 l = {} freq = [0] * (2 ** m) for i in range(n): an = 0 for j in range(m): if arr[i][j] >= x: an += 2 ** (m - j - 1) if freq[an] == 0: l[i] = an freq[an] = 1 ch = 0 for k1, v1 in l.items(): for k2, v2 in l.items(): if v1 | v2 == N: ch = 1 ind[0] = k1 + 1 ind[1] = k2 + 1 break if ch: break if ch: lo = x else: hi = x ans = lo if ind[0] == 0: print(""1 1"") else: print(*ind)",np,"['binary search', 'bitmasks', 'dp']",1183
"m,n=[int(ele) for ele in input().split()] a=[] for i in range(m): a.append(list(map(int, input().split()))) ina,mo=0,10**9+1 pos1,pos2=0,0 mask=(1<<n)-1 def check(tang): key=set() dic=dict() for i in range(m): temp=0 for j in range(n): if a[i][j]>=tang: temp+=(1<<j) if temp in key: continue key.add(temp) tempk=temp while tempk>=0: tempk &= temp dic[tempk]=i tempk-=1 tocheck = mask ^ temp if tocheck in dic: return dic[tocheck],i,True return -1,-1,False while ina<mo-1: tang=(ina+mo)//2 temppos1,temppos2,status=check(tang) if status: pos1,pos2=temppos1,temppos2 ina=tang else: mo=tang print(pos1+1,pos2+1)",np,"['binary search', 'bitmasks', 'dp']",608
"import sys reader = (s.rstrip() for s in sys.stdin) input = reader.__next__ n,m = map(int, input().split()) a = [] for i in range(n): ai = list(map(int, input().split())) a.append(ai) def check(mid): mask = (1<<m)-1 s = set() d = dict() for i in range(n): state = 0 for j in range(m): if a[i][j] >= mid: state += 1<<j if state in s: continue s.add(state) k = state while k>=0: k &= state d[k] = i k -= 1 need = mask^state if need in d: q1, q2 = d[need], i if q1 > q2: q1, q2 = q2, q1 return True, (q1, q2) return False, (-1, -1) left = 0 right = 10**9+1 i,j = 0, 0 while right-left>1: mid = (right+left)//2 flag, (q1, q2) = check(mid) if flag: left = mid i,j = q1, q2 else: right = mid print(i+1, j+1)",np,"['binary search', 'bitmasks', 'dp']",701
"import sys reader = (s.rstrip() for s in sys.stdin) input = reader.__next__ m,n=[int(ele) for ele in input().split()] a=[] for i in range(m): a.append(list(map(int, input().split()))) ina,mo=0,10**9+1 pos1,pos2=0,0 mask=(1<<n)-1 def check(tang): key=set() dic=dict() for i in range(m): temp=0 for j in range(n): if a[i][j]>=tang: temp+=(1<<j) if temp in key: continue key.add(temp) tempk=temp while tempk>=0: tempk &= temp dic[tempk]=i tempk-=1 tocheck = mask ^ temp if tocheck in dic: return dic[tocheck],i,True return -1,-1,False while ina<mo-1: tang=(ina+mo)//2 temppos1,temppos2,status=check(tang) if status: pos1,pos2=temppos1,temppos2 ina=tang else: mo=tang print(pos1+1,pos2+1)",np,"['binary search', 'bitmasks', 'dp']",684
"def check(x: int) -> (int, int): vis = {} for i, array in enumerate(a): t = 0 for j, val in enumerate(array): if val >= x: t |= 1 << j vis[t] = i if (1 << m) - 1 in vis: return vis[(1 << m) - 1], vis[(1 << m) - 1] for i in range(1, (1 << m) - 1): for j in range(1, (1 << m) - 1): if i in vis and j in vis and i | j == (1 << m) - 1: return vis[i], vis[j] return -1, -1 if __name__ == '__main__': n, m = map(int, input().split()) a = [] for i in range(n): a.append(list(map(int, input().split()))) l = 0 r = int(1e9) while l <= r: mid = l + r >> 1 if check(mid) != (-1, -1): l = mid + 1 else: r = mid - 1 ans = check(r) print(""%d %d"" % (ans[0] + 1, ans[1] + 1))",np,"['binary search', 'bitmasks', 'dp']",659
"debug = 0 BIG = 10 ** 9 + 1 input = raw_input def prof(f): return f def report(f): def new_f(x): res = f(x) return res return new_f if debug else f def mcheck(a, pairs): m = len(a[0]) allm = 2 ** m - 1 subs = {i: {i} for i in range(allm + 1)} for i in range(allm + 1): for j in range(i): if i | j == i: subs[i].add(j) mx = [max(aa) for aa in a] @prof def check(v): masks = {0: -1} done = [False] * (allm + 1) for i, aa in enumerate(a): if mx[i] < v: continue c = sum(1 << b for b in range(len(aa)) if aa[b] >= v) if not done[c]: for cc in subs[c]: if allm - cc in masks: other = masks[allm - c] pairs[v] = i, other return True masks[cc] = i done[cc] = True return False return check @prof def go(): n, m = map(int, input().split()) a = [] uniq = set() for _ in range(n): aa = tuple(map(int, input().split())) a.append(aa) uniq.update(aa) uniq = sorted(uniq) pairs = {0: (0, 0)} check = mcheck(a, pairs) l = 0 r = len(uniq) - 1 while l != r: if debug: print(l, r) if l + 1 == r: if check(uniq[r]): l = r else: r = l continue c = (l + r) // 2 if check(uniq[c]): l = c else: r = c l = uniq[l] if debug: print(l, pairs[l]) if l not in pairs: check(l) a = pairs[l][0] b = pairs[l][1] if b == -1: b = a print(""%d %d"" % (a + 1, b + 1)) go()",np,"['binary search', 'bitmasks', 'dp']",1233
"import sys reader = (s.rstrip() for s in sys.stdin) inp = reader.__next__ n, m = map(int, inp().split()) arr = tuple(tuple(map(int, inp().split())) for i in range(n)) lower_bound = 0 upper_bound = int(1e9) + 1 mask = (1 << m) - 1 ans = (0, 0) def can_upper(mid): global ans d = dict() for i in range(n): bit = 0 for j in range(m): if arr[i][j] >= mid: bit += 1 << j d[bit] = i keys = tuple(d.keys()) for i in range(len(keys)): a1 = keys[i] for j in range(i, len(keys)): a2 = keys[j] if a1 | a2 == mask: ans = (d[a1], d[a2]) return True return False while upper_bound - lower_bound > 1: middle = (upper_bound + lower_bound) >> 1 if can_upper(middle): lower_bound = middle else: upper_bound = middle print(ans[0] + 1, ans[1] + 1)",np,"['binary search', 'bitmasks', 'dp']",727
"def check(mid,n,m,arr): masks = {} for index in range(n): array = arr[index] x = 0 for i in range(m): if array[i] >= mid: x ^= (1<<i) masks[x] = index+1 ans = False a,b = 1,1 if (1<<m)-1 in masks.keys(): return True,(masks[(1<<m)-1],masks[(1<<m)-1]) for i in masks.keys(): for j in masks.keys(): orAns = i|j if(orAns == ((1<<m)-1)): if i == (1<<m)-1 and (i in masks.keys()): a = masks[i] ans = True break elif j == (1<<m)-1 and (j in masks.keys()): b = masks[j] ans = True break elif (i in masks.keys()) and (j in masks.keys()): ans = True a,b = masks[i],masks[j] break return ans,(a,b) def solve(n,m,arr): mini = 0 maxi = int(1e9)+5 i,j = 1,1 while(mini<=maxi): mid = (mini+maxi)//2 ans,res = check(mid,n,m,arr) if(ans): i,j = res mini =mid +1 else: maxi = mid -1 print(i,j) def main(): n,m = map(int,input().split(' ')) arr = [] for _ in range(n): x = list(map(int,input().split(' '))) arr.append(x) solve(n,m,arr) main()",np,"['binary search', 'bitmasks', 'dp']",923
"import sys input = sys.stdin.buffer.readline def find_pair(candidate,data,m): ans = (-1,-1) binary_bit = [False for i in range(1 << m)] for i in data: bit_tmp = 0 for j in range(len(i)): if i[j] >= candidate: bit_tmp |= 1 << j binary_bit[bit_tmp] = True for i in range(1 << m): for j in range(1 << m): if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]: ans = i , j break return ans def backtracking(candidate,ans,data): idx_i = -1 ; idx_j = -1 for i in range(len(data)): bit_tmp = 0 for j in range(len(data[i])): if data[i][j] >= candidate: bit_tmp |= 1 << j if bit_tmp == ans[0]: idx_i = i if bit_tmp == ans[1]: idx_j = i print(str(idx_i + 1) + "" "" + str(idx_j + 1)) def main(): n , m = [int(i) for i in input().split()] data = [[int(i) for i in input().split()] for i in range(n)] a = 0 ; b = 10**9 + 7 ans = (-1,-1) candidate = -1 while a <= b: mid = (a + b)//2 bin_ans = find_pair(mid,data,m) if bin_ans[0] != -1 and bin_ans[1] != -1: ans = bin_ans candidate = mid a = mid + 1 else: b = mid - 1 backtracking(candidate,ans,data) main()",np,"['binary search', 'bitmasks', 'dp']",1053
"from sys import stdin, stdout idx1 = 0 idx2 = 0 VALD = 0 def getminmax(n, m, a): l = 0 h = 1000000009 while l < h: mid = (l+h+1)//2 exists = existsequalorbig(mid, m, a) if exists: l = mid else: h = mid-1 def existsequalorbig(mid, m, a): global idx1 global idx2 global VALD abw = [] hs = set() for i in range(len(a)): v = 0 for j in range(m): if a[i][j] >= mid: v |= 1 v <<= 1 v >>= 1 if v not in hs: hs.add(v) abw.append([i, v]) for i in range(len(abw)): for j in range(i, len(abw)): if abw[i][1] | abw[j][1] == VALD: idx1 = abw[i][0] idx2 = abw[j][0] return True return False if __name__ == '__main__': nm = list(map(int, stdin.readline().split())) n = nm[0] m = nm[1] VALD = int(pow(2, m) - 1) a = [] for i in range(n): a.append(list(map(int, stdin.readline().split()))) getminmax(n, m, a) stdout.write(str(idx1+1) + ' ' + str(idx2+1))",np,"['binary search', 'bitmasks', 'dp']",837
"import sys from collections import defaultdict reader = (map(int, line.split()) for line in sys.stdin) input = reader.__next__ n, m = input() vals = set() locs = defaultdict(list) for i in range(n): for pos, v in enumerate(input()): vals.add(v) locs[v].append((pos, i)) masks = [0] * n full = (1<<m) - 1 met = {0:0} for v in sorted(vals, reverse=True): for pos, i in locs[v]: curr_mask = masks[i] = masks[i] | (1<<pos) met[curr_mask] = i complement = full ^ curr_mask if complement in met: print(i+1, met[complement]+1) sys.exit()",np,"['binary search', 'bitmasks', 'dp']",530
"import sys input = sys.stdin.readline max_val = 0 n, m = [int(item) for item in input().split()] array = [] for i in range(n): line = [int(item) for item in input().split()] array.append(line) max_val = max(max_val, max(line)) good = (1 << m) - 1 l = 0; r = max_val + 1 a = 0; b = 0 while r - l > 1: mid = (l + r) // 2 bit_array = dict() for k, line in enumerate(array): val = 0 for i, item in enumerate(line): if item >= mid: val |= 1 << i bit_array[val] = k ok = False for key1 in bit_array.keys(): for key2 in bit_array.keys(): if key1 | key2 == good: ok = True i = bit_array[key1] j = bit_array[key2] break if ok: a = i; b = j l = mid else: r = mid print(a+1, b+1)",np,"['binary search', 'bitmasks', 'dp']",668
"n,m=[int(i) for i in input().split("" "")] arrmv=[] for i in range(n): arrmv.append([int(i) for i in input().split("" "")]) x=0 y=int(1e9+1) sucls=[0,0] tols=[] mstr="""" powls=[int(pow(2,i)) for i in range(10)] twodarray=[0 for i in range(257)] while x+1<y: mid = x+(y-x)//2 for idx,ele in enumerate(twodarray):twodarray[idx]=0 tols.clear() for topidx, eletop in enumerate(arrmv): tmp=0 for idx,ele in enumerate(eletop): if ele>=mid:tmp+=powls[idx] if not twodarray[tmp]: twodarray[tmp]=1 tols.append((tmp,topidx)) sz=len(tols) suc=0 no=int(pow(2,m)) for i in range(sz): for j in range(i,sz): if tols[i][0] | tols[j][0] == no-1: sucls[0],sucls[1]=tols[i][1],tols[j][1] suc=1; break; if suc:break if suc:x=mid else:y=mid print(sucls[0]+1,sucls[1]+1)",np,"['binary search', 'bitmasks', 'dp']",743
"import sys from collections import defaultdict input = sys.stdin.readline n, m = map(int, input().split()) vals = set() locs = defaultdict(list) for i in range(n): inp = map(int, input().split()) for pos, v in enumerate(inp): vals.add(v) locs[v].append((pos, i)) masks = [0] * n full = (1<<m) - 1 met = {0:0} for v in sorted(vals, reverse=True): for pos, i in locs[v]: curr_mask = masks[i] = masks[i] | (1<<pos) met[curr_mask] = i complement = full ^ curr_mask if complement in met: print(i+1, met[complement]+1) sys.exit()",np,"['binary search', 'bitmasks', 'dp']",523
"import sys reader = (map(int, line.split()) for line in sys.stdin) input = reader.__next__ n, m = input() arrays = [] for i in range(n): arrays.append(list(input())) full = (1 << m) - 1 L = -1 R = 10 ** 9 + 1 while L + 1 < R: check = (L + R) >> 1 masks = {} for i, arr in enumerate(arrays): curr = 0 for val in arr: curr <<= 1 if val >= check: curr |= 1 masks[curr] = i isValid = False for k1 in masks: for k2 in masks: if k1 | k2 == full: ans0 = masks[k1] ans1 = masks[k2] isValid = True break if isValid: break if isValid: L = check else: R = check print(ans0 + 1, ans1 + 1)",np,"['binary search', 'bitmasks', 'dp']",576
"hell=1000000007 id1=0 id2=0 a = [] def check(n,m,x): global id1,id2 b = [0]*(1<<m) idx = [0]*(1<<m) for i in range(n): mask=0 for j in range(m): if a[i][j]>=x: mask=mask^(1<<j) b[mask]=1 idx[mask]=i+1 for i in range(1<<m): if b[i]: for j in range(1<<m): if b[j]: mask=i|j if mask==((1<<m)-1): id1=idx[i] id2=idx[j] return 1 return 0 def meowmeow321(): n,m = map(int,input().split()) for i in range(n): dog = [int(x) for x in input().split()] a.append(dog) lo=0 hi=hell while hi-lo>0: mid=(hi+lo+1)//2 if check(n,m,mid): lo=mid else: hi=mid-1 check(n,m,lo) print(id1,id2) t=1 for xxx in range(t): meowmeow321()",np,"['binary search', 'bitmasks', 'dp']",609
"import sys input=sys.stdin.readline n,m=map(int,input().split()) l=[] for i in range(n): l.append([int(i) for i in input().split()]) left=0 right=10**9+1 while left<right: mid=(left+right)//2 dicta={} for i in range(n): mask=0 for j in range(m): mask<<=1 if l[i][j]>=mid: mask+=1 dicta[mask]=i ok=False for i in dicta: for j in dicta: if i|j==(2**m-1): ok=True ans=(dicta[i]+1,dicta[j]+1) break if ok ==True: break if ok==True: left=mid+1 else: right=mid print(*ans)",np,"['binary search', 'bitmasks', 'dp']",466
"def get_ans(x, a, n, m): lim = 1<<m match = lim-1 track = [-1 for i in range(lim)] for i in range(n): mask = 0 for j in range(m): if(a[i][j] >= x): mask |= 1 << j track[mask] = i for i in range(lim): for j in range(lim): if(i|j == match and track[i] != -1 and track[j] != -1): return track[i], track[j] return -1, -1 n, m = map(int, input().split()) a = [list(map(int, input().split())) for i in range(n)] lo = 0 hi = 1000000000 while(lo < hi-1): mid = (lo+hi)/2 i, j = get_ans(mid,a,n,m) if(i == -1): hi = mid-1 else: lo = mid i,j = get_ans(hi,a,n,m) if(i != -1): print(""{} {}"".format(i+1,j+1)) else: i,j = get_ans(lo,a,n,m) print(""{} {}"".format(i+1,j+1))",np,"['binary search', 'bitmasks', 'dp']",656
"n, m = map(int, input().split()) a = [list(map(int, input().split())) for i in range(n)] def get_ans(x): lim = 1<<m match = lim-1 track = [-1 for i in range(lim)] for i in range(n): mask = 0 for j in range(m): if(a[i][j] >= x): mask |= 1 << j track[mask] = i for i in range(lim): for j in range(lim): if(i|j == match and track[i] != -1 and track[j] != -1): return track[i], track[j] return -1, -1 lo = 0 hi = 1000000000 while(lo < hi-1): mid = (lo+hi)/2 i, j = get_ans(mid) if(i == -1): hi = mid-1 else: lo = mid i,j = get_ans(hi) if(i != -1): print(""{} {}"".format(i+1,j+1)) else: i,j = get_ans(lo) print(""{} {}"".format(i+1,j+1))",np,"['binary search', 'bitmasks', 'dp']",629
"n, m = map(int, input().split()) a = [list(map(int, input().split())) for i in range(n)] ans = [] def check(mid: int) -> bool: global ans dic = {} for i in range(n): bit = 0 for j in range(m): if a[i][j] >= mid: bit += 1 bit <<= 1 dic[bit >> 1] = i for x, idx in dic.items(): for y, idy in dic.items(): if x | y == 2**m-1: ans = idx + 1, idy + 1 return True return False le = 0 ri = int(1e9) while le <= ri: mid = (le + ri) >> 1 if check(mid): le = mid + 1 else: ri = mid - 1 print(ans[0], ans[1])",np,"['binary search', 'bitmasks', 'dp']",497
"import os import sys from io import BytesIO, IOBase def check(mid: int) -> bool: global ans dic = {} for i in range(n): bit = 0 for j in range(m): if a[i][j] >= mid: bit += 1 bit <<= 1 dic[bit >> 1] = i for x, idx in dic.items(): for y, idy in dic.items(): if x | y == 2**m-1: ans = idx + 1, idy + 1 return True return False n, m = map(int, input().split()) a = [list(map(int, input().split())) for i in range(n)] ans = [] le = 0 ri = int(1e9) while le <= ri: mid = (le + ri) >> 1 if check(mid): le = mid + 1 else: ri = mid - 1 print(ans[0], ans[1]) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def input(): return sys.stdin.readline().rstrip(""\r\n"")",np,"['binary search', 'bitmasks', 'dp']",1898
"import sys input = sys.stdin.readline N, M = map(int, input().split()) state = [list(map(int, input().split())) for _ in range(N)] Ans = {} l = -1 r = 10**9+1 while r-l > 1: m = (l+r)//2 T = {} for j, S in enumerate(state): bit = 0 for i, s in enumerate(S): if s >= m: bit += 1<<i T[bit] = j ok = False for bit1 in range(1<<M): for bit2 in range(1<<M): if bit1|bit2 == (1<<M)-1 and bit1 in T and bit2 in T: ok = True Ans[m] = [T[bit1], T[bit2]] break if ok: break if ok: l = m else: r = m print(Ans[l][0]+1, Ans[l][1]+1)",np,"['binary search', 'bitmasks', 'dp']",520
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def input(): return sys.stdin.readline().rstrip(""\r\n"") def check(mid: int) -> bool: global ans dic = {} for i in range(n): bit = 0 for j in range(m): if a[i][j] >= mid: bit += 1 bit <<= 1 dic[bit >> 1] = i for x, idx in dic.items(): for y, idy in dic.items(): if x | y == 2**m-1: ans = idx + 1, idy + 1 return True return False n, m = map(int, input().split()) a = [list(map(int, input().split())) for i in range(n)] ans = [] le = 0 ri = int(1e9) while le <= ri: mid = (le + ri) >> 1 if check(mid): le = mid + 1 else: ri = mid - 1 print(ans[0], ans[1])",np,"['binary search', 'bitmasks', 'dp']",1898
"import os import sys from io import BytesIO, IOBase def main(): n, m = map(int, input().split()) a = [list(map(int, input().split())) for i in range(n)] ans = [] le = 0 ri = int(1e9) def check(mid: int) -> bool: nonlocal ans dic = {} for i in range(n): bit = 0 for j in range(m): if a[i][j] >= mid: bit += 1 bit <<= 1 dic[bit >> 1] = i for x, idx in dic.items(): for y, idy in dic.items(): if x | y == 2**m-1: ans = idx + 1, idy + 1 return True return False while le <= ri: mid = (le + ri) >> 1 if check(mid): le = mid + 1 else: ri = mid - 1 print(ans[0], ans[1]) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) def input(): return sys.stdin.readline().rstrip(""\r\n"") if __name__ == ""__main__"": main()",np,"['binary search', 'bitmasks', 'dp']",1946
"import sys input = sys.stdin.readline from itertools import combinations from collections import defaultdict n,m = map(int,input().split()) a = [list(map(int,input().split())) for i in range(n)] mx = max(max(a[i]) for i in range(n)) if n == 1: print(1,1) exit() l = 0 r = mx+1 while l+1 < r: flg = 0 x = (l+r)//2 jud = set() dc = defaultdict(int) for i in range(n): jnum = 0 for j in range(m): if a[i][j] >= x: jnum += 1<<j if dc[jnum] == 0: dc[jnum] = i+1 if jnum == (1<<m)-1: flg = 1 if i == 0: ans = (i+1,i+2) else: ans = (1,i+1) jud.add(jnum) for p,q in combinations(jud,2): if p|q == (1<<m)-1: flg = 1 ans = (dc[p],dc[q]) if flg: l = x else: r = x if l == 0: print(1,2) else: print(*ans)",np,"['binary search', 'bitmasks', 'dp']",692
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from math import factorial from collections import Counter, defaultdict from heapq import heapify, heappop, heappush def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0 def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0 def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2) mod = 998244353 INF = float('inf') def main(): n, m = RL() arr = [] for _ in range(n): arr.appe",np,"['binary search', 'bitmasks', 'dp']",2000
"import math as mt import sys input=sys.stdin.readline I=lambda:list(map(int,input().split())) n,m=I() a=[I() for i in range(n)] ans=[] lo=0 hi=10**9 def vanguda(mid: int) -> bool: global ans f={} for i in range(n): bi=0 for j in range(m): if a[i][j]>=mid: bi+=1 bi<<=1 f[bi>>1]=i for aa,bb in f.items(): for cc,dd in f.items(): if aa|cc==(2**m-1): ans =bb+1,dd+1 return True return False while lo<=hi: mid=(lo+hi)//2 if vanguda(mid): lo=mid+1 else: hi=mid-1 print(*ans)",np,"['binary search', 'bitmasks', 'dp']",469
"import io,os input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline from collections import defaultdict as dd I = lambda : list(map(int,input().split())) n,m=I() l=[] an=-1;a=b=0 for _ in range(n): k=I() l.append(k+[_+1]) if an<min(k): a=b=_+1 an=min(k) le=an;r=10**9+1 while le<r: md = (le+r)//2 f=0;a1=a2=-1 s=[0]*n for i in range(n): for j in range(m): if l[i][j]>=md: s[i]|=1<<j po=1<<m d=[0]*po for i in range(n): d[s[i]]=i+1 for i in range(1,po): if d[i]: pp=i while pp: d[pp]=d[i] pp=(pp-1)&i if d[po-1]: f=1 a1=a2=d[po-1] for i in range(1,po): if d[i] and d[(po-1)^i]: f=1 a1 = d[i] a2 = d[(po-1)^i] break if f: le=md+1 if md>an: a,b=a1,a2 an=md else: r=md print(a,b)",np,"['binary search', 'bitmasks', 'dp']",680
"import io import os from collections import Counter, defaultdict, deque DEBUG = False def bisect_f(f, lo, hi): if DEBUG: assert f(lo) and not f(hi) while hi - lo > 1: mid = (lo + hi) // 2 if f(mid): lo = mid else: hi = mid if DEBUG: assert f(lo) and not f(hi) if DEBUG: assert hi - lo == 1 assert f(lo) and not f(hi) return lo def solve(N, M, arrs): def isPossible(target): possible = set() for arr in arrs: mask = 0 for pos, x in enumerate(arr): if x >= target: mask += 1 << pos possible.add(mask) allMask = (1 << M) - 1 for mask1 in possible: for mask2 in possible: if mask1 | mask2 == allMask: return (mask1 << 8) + mask2 return 0 lo = min(arrs[0]) hi = 10 ** 9 + 1 index = bisect_f(isPossible, lo, hi) mask1, mask2 = divmod(isPossible(index), 1 << 8) ans = [-1, -1] for i, arr in enumerate(arrs): mask = 0 for pos, x in enumerate(arr): if x >= index: mask += 1 << pos if mask == mask1: ans[0] = str(i + 1) if mask == mask2: ans[1] = str(i + 1) return "" "".join(ans) if __name__ == ""__main__"": input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline N, M = [int(x) for x in input().split()] arrs = [[int(x) for x in input().split()] for i in range(N)] ans = solve(N, M, arrs) print(ans)",np,"['binary search', 'bitmasks', 'dp']",1193
"import sys, math import io, os from collections import defaultdict as dd, deque, Counter def data(): return sys.stdin.buffer.readline().strip() def mdata(): return list(map(int, data().split())) def outl(var) : sys.stdout.write(' '.join(map(str, var))+'\n') def out(var) : sys.stdout.write(str(var)+'\n') mod = int(1e9)+7 def cal(x): l1=set() d=dd(int) a=[] for i in range(n): k=0 for j in range(m): if A[i][j]>=x: k+=1<<j l1.add(k) d[k]=i+1 l1=list(l1) s=(1<<m)-1 for i in l1: for j in l1: if i|j == s: a=[d[i],d[j]] return a n,m=mdata() A=[mdata() for i in range(n)] l,r=0,10**9 while l<=r: mid=(l+r)//2 if cal(mid): l=mid+1 else: r=mid-1 a=cal(mid) if a: outl(a) else: outl(cal(mid-1))",np,"['binary search', 'bitmasks', 'dp']",688
"from sys import stdin def solve(x: int) -> bool: global ans dp = {} for i in range(n): temp = 0 for j in range(m): if a[i][j] >= x: temp = temp | (1 << j) dp[temp] = i for aa, bb in dp.items(): for cc, dd in dp.items(): if aa | cc == 2 ** m - 1: ans = (bb + 1, dd + 1) return True return False ans = (-1, -1) n, m = map(int, stdin.readline().split()) a = [] for i in range(n): a.append(list(map(int, stdin.readline().split()))) l, r = 0, 10 ** 9 while l <= r: mid = (l + r) // 2 if solve(mid): l = mid + 1 else: r = mid - 1 print(*ans)",np,"['binary search', 'bitmasks', 'dp']",535
"import math import random import heapq, bisect import sys from collections import deque, defaultdict from fractions import Fraction import sys import threading from collections import defaultdict mod = 10 ** 9 + 7 mod1 = 998244353 import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") class TreeNode: def __init__(self, k, v): self.key = k self.value = v self.left = None self.right = None self.parent = None self.height = 1 self.num_left = 1 self.num_total = 1 class AvlTree: def __init__(self): self._tree = None def add(self, k, v): if not self._tree: self._tree = TreeNode(k, v) return node = self._add(k, v) if node: self._rebalance(node) def _add(sel",np,"['binary search', 'bitmasks', 'dp']",1999
"import sys from array import array from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union def input(): return sys.stdin.buffer.readline().decode('utf-8') def main(): n, m = map(int, input().split()) mat = [array('i', map(int, input().split())) for _ in range(n)] bit = [1 << i for i in range(m)] fullbit = (1 << m) - 1 def solve(x: int) -> Tuple[int, int]: dp = {sum(bit[j] for j, y in enumerate(mat[i]) if y >= x): i for i in range(n)} keys = tuple(dp.keys()) for i in range(len(keys)): for j in range(i, len(keys)): if keys[i] | keys[j] == fullbit: return dp[keys[i]], dp[keys[j]] return -1, -1 ok, ng = 0, 10**9 + 1 ans_i, ans_j = 1, 1 while abs(ok - ng) > 1: mid = (ok + ng) >> 1 x, y = solve(mid) if x == -1: ng = mid else: ok = mid ans_i, ans_j = x + 1, y + 1 print(ans_i, ans_j) if __name__ == '__main__': main()",np,"['binary search', 'bitmasks', 'dp']",836
"import sys from array import array from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union def input(): return sys.stdin.buffer.readline().decode('utf-8') def main(): n, m = map(int, input().split()) mat = [array('i', map(int, input().split())) for _ in range(n)] bit = [1 << i for i in range(m)] max_bit = 1 << m fullbit = max_bit - 1 def solve(x: int) -> Tuple[int, int]: dp = array('i', [-1]) * max_bit for i in range(n): dp[sum(bit[j] for j, y in enumerate(mat[i]) if y >= x)] = i for i in range(max_bit): if dp[i] == -1: continue for j in range(i, max_bit): if dp[j] != -1 and i | j == fullbit: return dp[i], dp[j] return -1, -1 ok, ng = 0, 10**9 + 1 ans_i, ans_j = 1, 1 while abs(ok - ng) > 1: mid = (ok + ng) >> 1 x, y = solve(mid) if x == -1: ng = mid else: ok = mid ans_i, ans_j = x + 1, y + 1 print(ans_i, ans_j) if __name__ == '__main__': main()",np,"['binary search', 'bitmasks', 'dp']",872
"import sys from array import array from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union def input(): return sys.stdin.buffer.readline().decode('utf-8') def main(): n, m = map(int, input().split()) mat = [array('i', map(int, input().split())) for _ in range(n)] bit = array('h', [1 << i for i in range(m)]) max_bit = 1 << m fullbit = max_bit - 1 def solve(x: int) -> Tuple[int, int]: dp = array('i', [-1]) * max_bit for i in range(n): dp[sum(bit[j] for j in range(m) if mat[i][j] >= x)] = i for i in range(max_bit): if dp[i] == -1: continue for j in range(i, max_bit): if dp[j] != -1 and i | j == fullbit: return dp[i], dp[j] return -1, -1 ok, ng = 0, 10**9 + 1 ans_i, ans_j = 1, 1 while abs(ok - ng) > 1: mid = (ok + ng) >> 1 x, y = solve(mid) if x == -1: ng = mid else: ok = mid ans_i, ans_j = x + 1, y + 1 print(ans_i, ans_j) if __name__ == '__main__': main()",np,"['binary search', 'bitmasks', 'dp']",880
"from heapq import heappush, heappop class MinCostFlow: INF = 10**18 def __init__(self, N): self.N = N self.G = [[] for i in range(N)] def add_edge(self, fr, to, cap, cost): forward = [to, cap, cost, None] backward = forward[3] = [fr, 0, -cost, forward] self.G[fr].append(forward) self.G[to].append(backward) def flow(self, s, t, f): N = self.N; G = self.G INF = MinCostFlow.INF res = 0 H = [0]*N prv_v = [0]*N prv_e = [None]*N d0 = [INF]*N dist = [INF]*N while f: dist[:] = d0 dist[s] = 0 que = [(0, s)] while que: c, v = heappop(que) if dist[v] < c: continue r0 = dist[v] + H[v] for e in G[v]: w, cap, cost, _ = e if cap > 0 and r0 + cost - H[w] < dist[w]: dist[w] = r = r0 + cost - H[w] prv_v[w] = v; prv_e[w] = e heappush(que, (r, w)) if dist[t] == INF: return None for i in range(N): H[i] += dist[i] d = f; v = t while v != s: d = min(d, prv_e[v][1]) v = prv_v[v] f -= d res += d * H[t] v = t while v != s: e = prv_e[v] e[1] -= d e[3][1] += d v = prv_v[v] return res class UnionFindVerSize(): def __init__(self, N): self._parent = [n for n in range(0, N)] self._size = [1] * N self.group = N def find_root(self, x): if self._parent[x] == x: return x self._parent[x] = self.find_root(self._parent[x]) stack = [x] while self._parent[stack[-1]]!=stack[-1]: stack.append(self._parent[stack[-1]]) for v in stack: self._parent[v] = stack[-1] return self._parent[x] def unite(self, x, y): gx = self.find_root(x) gy = self.find_root(y) if gx == gy: return self.group -= 1 if self._size[gx] < self._size[gy]: self._parent[gx] = gy self._size[gy] += self._size[gx] else: self._parent[gy] = gx self._size[gx] += self._size[gy] def get_size(self, x): return self._size[self.find_root(x)] def is_same_group(self, x, y): return self.find_root(x) == self.find_root(y) n,m = map(int,input().split()) G = MinCostFlow(n+2) coef = [0 for i in range(n)] edge = [] for _ in range(m): x,y,b = map(int,input().split()) G.add_edge(y,x,10**18,-1) coef[x-1] += b coef[y-1] -= b edge.append((x,y)) s = 0 for i in range(n):",np,"['bitmasks', 'dfs and similar', 'dp', 'flows', 'graphs', 'math']",1999
"from math import * n,x,y=map(int,input().split());g=gcd(x,y);n,x,y,r,h=n//g,x//g,(x+y)//g,n%g,lambda n:max(f(n,0),f(n,1)) def f(n,s): d=[-n,-n];d[s]=0 for i in range(y):d=[max(d[0],d[1]),d[0]+n//y+(i*x%y<n%y)] return d[s] print(h(n+1)*r+h(n)*(g-r))",np,"['bitmasks', 'dp', 'math']",248
"def f(n,s): d=[-n,-n];d[s]=0 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",237
"def f(n,s): d=[-n,-n];d[s]=0 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",237
"from math import gcd n, x, y = map(int, input().split()) def solve(n, x, y): g = gcd(x, y) if gcd(x, y) != 1: return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g) ans = 0 for s in [0, 1]: dp = [-n, -n] dp[s] = 0 for i in range(x + y): dp = [max(dp[0], dp[1]), dp[0] + (n // (x + y)) + (i * x % (x + y) < n % (x + y))] ans = max(ans, dp[s]) return ans print(solve(n, x, y))",np,"['bitmasks', 'dp', 'math']",416
"from sys import stdin, gettrace if gettrace(): def inputi(): return input() else: def input(): return next(stdin)[:-1] def inputi(): return stdin.buffer.readline() def bitcount(m): return bin(m).count('1') def main(): n,x,y = map(int, input().split()) if x > y: x,y = y, x assert x <= y mm1 = range(1, 1 << y, 2) vbases = [((~(m1 >> (y - x)) & ~m1 & ((1 << x) - 1)) << y) | m1 for m1 in mm1 if m1 & m1 >> x == 0] def btail(m): return bitcount(m & ((1 << n % (x + y)) - 1)) res = max(bitcount(m)*(n//(x+y)) + btail(m) for m in vbases) print(res) if __name__ == ""__main__"": main()",np,"['bitmasks', 'dp', 'math']",578
"import math def solve(n, x, y): g = math.gcd(x, y) if g != 1: return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g) p = x + y weights = [n // p] * p for i in range(p): if (i * x) % p < n % p: weights[i] += 1 ans = -n for i in range(2): dp = [-n, -n] dp[i] = 0 for w in weights: dp = [max(dp[0], dp[1]), dp[0] + w] ans = max(ans, dp[i]) return ans def main(): n, x, y = [int(x) for x in input().split()] print(solve(n, x, y)) main()",np,"['bitmasks', 'dp', 'math']",474
"import json import os def convert_files_to_json(): answer = dict() for file in os.listdir(""bad/""): if '_' in file: answer[file] = [list(map(int, line.split())) for line in open(""bad/"" + file).read().split('\n')[:2]] return json.dumps(answer) def extract_list(compressed_list, start_val=1): answer = [] for num in compressed_list: answer += [start_val] * num start_val += 1 return answer answer = json.loads('{""1_12"": [[], [2, 2, 2, 2, 2, 3]], ""6_11"": [[1, 1, 1, 1, 1, 7], [2, 3, 1, 2, 2, 2, 2, 3]], ' '""3_10"": [[], [1, 1, 4, 1, 1, 5]], ""3_17"": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], ""6_9"": [[], [1, 1, ' '1, 1, 1, 10]], ""9_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 19]], ""18_21"": [[], [1, 1, 1, 1, 1, 1, 1, ' '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], ""10_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], ""15_18"": [[' '], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], ""1_10"": [[], [2, 2, 2, 2, 3]], ""6_19"": [[], ' '[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 8]], ""3_13"": [[1, 1, 4, 1, 1, 4], [2]], ""2_22"": [[], [1, 3]], ' '""3_6"": [[], [1, 1, 7]], ""10_14"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 1, 1, 1, 1, 7], ' '[1, 3]], ""9_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], ""6_15"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 7]], ' '""7_22"": [[], [1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 9]], ""1_15"": [[], [2]], ""10_15"": [[], [1, ' '1, 1, 1, 1, 1, 1, 1, 1, 16]], ""3_15"": [[], [1, 1, 4]], ""11_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ' '12], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4]], ""15_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ' '1, 1, 1, 16, 1, 1, 4, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], ""18_19"": [[], [1, 1, 1, ' '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], ""11_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], ' '[2]], ""2_2"": [[], [1, 3]], ""16_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 1, 2, ' '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, ' '3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, ' '3, 3, 3, 3, 1, 2",np,"['bitmasks', 'dp', 'math']",2000
"def f(n,s): d=[-n,-n]; d[s]=0; for i in range(y//g): d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]; return d[s]; import math; n,x,y=map(int,input().split()); g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1)); y=y+x; print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",247
"import math; def f(n,s): d=[-n,-n]; d[s]=0 for i in range(y//g): d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] n,x,y=map(int,input().split()); g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1)); y+=x; print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",243
"import math def f(n,s): d=[-n,-n];d[s]=0 for i in range(y//g): d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] n,x,y=map(int,input().split()); g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1)); y+=x; print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",241
"import math def f(n,s): d=[-n,-n];d[s]=0 for i in range(y//g): d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] n,x,y=map(int,input().split()); g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1)); y+=x; print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",241
"import math def f(n,s): d=[-n,-n];d[s]=0 for i in range(y//g): d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] n,x,y=map(int,input().split()) g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1)) y+=x print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",238
"import math def f(n,s): d=[-n,-n];d[s]=0 for i in range(y//g): d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] n,x,y=map(int,input().split()) g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1)) y+=x print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",238
"import math def f(n,s): d=[-n,-n];d[s]=0 for i in range(y//g): d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] n,x,y=map(int,input().split()) g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1)) y+=x print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",238
"def f(n,s): d=[-n,-n];d[s]=0 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)] return d[s] import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"['bitmasks', 'dp', 'math']",237
"from math import gcd def t_prime(n): if n == 1: return False for p in [2,3,5,7,11,13,17,19,23]: if p < n and pow(p,n-1,n) != 1: return False return True primes = [i for i in range(2,10**5) if t_prime(i)] pset = set(primes) n, k = map(int, input().split()) l = list(map(int, input().split())) if k == 1: print(0) exit() for i in range(n): for j in range(i): u, v = l[i], l[j] poss = gcd(u,v) poss2 = max(u,v)//poss smol = min(poss,poss2) if t_prime(smol) and smol not in pset: primes.append(smol) pset.add(smol) powers = set() count = 0 outLs = [] pgood = [] for p in primes: curr = [] fp = [v for v in l if v % p == 0] for v in fp: v2 = v while v2 % p == 0: v2 //= p if v2 == 1: curr.append(v) powers.add(v) if len(curr) > 1: count += len(curr) outLs.append(curr) pgood.append(p) order = [(len(lis), lis) for lis in outLs] order.sort(key = lambda x: x[0]) if len(order) == 0: print(0) exit() if order[-1][0] == 2 and k % 2 and count > k: extra = -1 need = -1 last = [] for v in l: if v in powers: continue v2 = v primesn = [] for p in pgood: add = 1 while v2 % p == 0: v2 //= p if add: primesn.append(p) add = 0 if v2 == 1 and (need == -1 or need > len(primesn)): extra = v last = primesn need = len(last) assert need >= 2 if need == -1 or 2 * need + 1 > k: print(0) exit() other = [] out = [extra] for a,b in outLs: works = False for p in last: if a % p == 0: works = True break if works: out.append(a) out.append(b) else: other.append(a) other.append(b) assert len(out) == 2 * need + 1 assert (k - 2 * need - 1) % 2 == 0 ret = out + other[:(k - 2*need - 1)] assert len(ret) == k print(' '.join(map(str,ret))) exit() out = [] need = k for i in range(len(order)): assert need != 1 lis = order[i][1] if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis need -= len(lis) elif len(lis) == need - 1: if len(lis) > 2: out += lis[:-1] need -= (len(lis) - 1) assert need == 2 else: out += lis[:need] need = 0 assert need + len(out) == k assert need >= 0 a",np,"['binary search', 'greedy', 'math', 'number theory']",2000
"from math import gcd def t_prime(n): if n == 1: return False for p in [2,3,5,7,11,13,17,19,23]: if p < n and pow(p,n-1,n) != 1: return False return True primes = [i for i in range(2,10**5) if t_prime(i)] pset = set(primes) n, k = map(int, input().split()) l = list(map(int, input().split())) if k == 1: print(0) exit() for i in range(n): for j in range(i): u, v = l[i], l[j] poss = gcd(u,v) poss2 = max(u,v)//poss smol = min(poss,poss2) if t_prime(smol) and smol not in pset: primes.append(smol) pset.add(smol) powers = set() count = 0 outLs = [] pgood = [] for p in primes: curr = [] fp = [v for v in l if v % p == 0] for v in fp: v2 = v while v2 % p == 0: v2 //= p if v2 == 1: curr.append(v) powers.add(v) if len(curr) > 1: count += len(curr) outLs.append(curr) pgood.append(p) order = [(len(lis), lis) for lis in outLs] order.sort(key = lambda x: x[0]) if len(order) == 0: print(0) exit() if order[-1][0] == 2 and k % 2 and count > k: extra = -1 need = -1 last = [] for v in l: if v in powers: continue v2 = v primesn = [] for p in pgood: add = 1 while v2 % p == 0: v2 //= p if add: primesn.append(p) add = 0 if v2 == 1 and (need == -1 or need > len(primesn)): extra = v last = primesn need = len(last) assert need >= 2 if need == -1 or 2 * need + 1 > k: print(0) exit() other = [] out = [extra] for a,b in outLs: works = False for p in last: if a % p == 0: works = True break if works: out.append(a) out.append(b) else: other.append(a) other.append(b) assert len(out) == 2 * need + 1 assert (k - 2 * need - 1) % 2 == 0 ret = out + other[:(k - 2*need - 1)] assert len(ret) == k print(' '.join(map(str,ret))) exit() out = [] need = k for i in range(len(order)): assert need != 1 lis = order[i][1] if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis need -= len(lis) elif len(lis) == need - 1: if len(lis) > 2: out += lis[:-1] need -= (len(lis) - 1) assert need == 2 else: out += lis[:need] need = 0 assert need + len(out) == k assert need >= 0 a",np,"['binary search', 'greedy', 'math', 'number theory']",2000
"from math import gcd def t_prime(n): if n == 1: return False for p in [2,3,5,7,11,13,17,19,23]: if p < n and pow(p,n-1,n) != 1: return False return True primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split())) if k == 1: print(0);exit() for i in range(n): for j in range(i): u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2) if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol) powers = set();count = 0;outLs = [];pgood = [] for p in primes: curr = []; fp = [v for v in l if v % p == 0] for v in fp: v2 = v while v2 % p == 0: v2 //= p if v2 == 1: curr.append(v); powers.add(v) if len(curr) > 1: count += len(curr); outLs.append(curr); pgood.append(p) order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0]) if len(order) == 0: print(0); exit() if order[-1][0] == 2 and k % 2 and count > k: extra = -1 need = -1 last = [] for v in l: if v in powers: continue v2 = v primesn = [] for p in pgood: add = 1 while v2 % p == 0: v2 //= p if add: primesn.append(p) add = 0 if v2 == 1 and (need == -1 or need > len(primesn)): extra = v last = primesn need = len(last) assert need >= 2 if need == -1 or 2 * need + 1 > k: print(0) exit() other = [] out = [extra] for a,b in outLs: works = False for p in last: if a % p == 0: works = True break if works: out.append(a) out.append(b) else: other.append(a) other.append(b) assert len(out) == 2 * need + 1 assert (k - 2 * need - 1) % 2 == 0 ret = out + other[:(k - 2*need - 1)] assert len(ret) == k print(' '.join(map(str,ret))) exit() out = [] need = k for i in range(len(order)): assert need != 1 lis = order[i][1] if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis need -= len(lis) elif len(lis) == need - 1: if len(lis) > 2: out += lis[:-1] need -= (len(lis) - 1) assert need == 2 else: out += lis[:need] need = 0 assert need + len(out) == k assert need >=",np,"['binary search', 'greedy', 'math', 'number theory']",2000
"from math import gcd def t_prime(n): if n == 1: return False for p in [2,3,5,7,11,13,17,19,23]: if p < n and pow(p,n-1,n) != 1: return False return True primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split())) if k == 1: print(0);exit() for i in range(n): for j in range(i): u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2) if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol) powers = set();count = 0;outLs = [];pgood = [] for p in primes: curr = []; fp = [v for v in l if v % p == 0] for v in fp: v2 = v while v2 % p == 0: v2 //= p if v2 == 1: curr.append(v); powers.add(v) if len(curr) > 1: count += len(curr); outLs.append(curr); pgood.append(p) order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0]) if len(order) == 0: print(0); exit() if order[-1][0] == 2 and k % 2 and count > k: extra = -1; need = -1; last = [] for v in l: if v in powers: continue v2 = v; primesn = [] for p in pgood: add = 1 while v2 % p == 0: v2 //= p if add: primesn.append(p) add = 0 if v2 == 1 and (need == -1 or need > len(primesn)): extra = v; last = primesn; need = len(last); assert need >= 2 if need == -1 or 2 * need + 1 > k: print(0); exit() other = []; out = [extra] for a,b in outLs: works = False for p in last: if a % p == 0: works = True; break if works: out.append(a); out.append(b) else: other.append(a); other.append(b) assert len(out) == 2 * need + 1; assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)]; assert len(ret) == k; print(' '.join(map(str,ret))); exit() out = [];need = k for i in range(len(order)): assert need != 1 lis = order[i][1] if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis need -= len(lis) elif len(lis) == need - 1: if len(lis) > 2: out += lis[:-1] need -= (len(lis) - 1) assert need == 2 else: out += lis[:need] need = 0 assert need + len(out) ==",np,"['binary search', 'greedy', 'math', 'number theory']",1999
"from math import gcd def t_prime(n): if n == 1: return False for p in [2,3,5,7,11,13,17,19,23]: if p < n and pow(p,n-1,n) != 1: return False return True primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split())) if k == 1: print(0);exit() for i in range(n): for j in range(i): u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2) if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol) powers = set();count = 0;outLs = [];pgood = [] for p in primes: curr = []; fp = [v for v in l if v % p == 0] for v in fp: v2 = v while v2 % p == 0: v2 //= p if v2 == 1: curr.append(v); powers.add(v) if len(curr) > 1: count += len(curr); outLs.append(curr); pgood.append(p) order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0]) if len(order) == 0: print(0); exit() if order[-1][0] == 2 and k % 2 and count > k: extra = -1; need = -1; last = [] for v in l: if v in powers: continue v2 = v; primesn = [] for p in pgood: add = 1 while v2 % p == 0: v2 //= p if add: primesn.append(p) add = 0 if v2 == 1 and (need == -1 or need > len(primesn)): extra = v; last = primesn; need = len(last); assert need >= 2 if need == -1 or 2 * need + 1 > k: print(0); exit() other = []; out = [extra] for a,b in outLs: works = False for p in last: if a % p == 0: works = True; break if works: out.append(a); out.append(b) else: other.append(a); other.append(b) assert len(out) == 2 * need + 1; assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)]; assert len(ret) == k; print(' '.join(map(str,ret))); exit() out = [];need = k for i in range(len(order)): assert need != 1;lis = order[i][1] if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis; need -= len(lis) elif len(lis) == need - 1: if len(lis) > 2: out += lis[:-1]; need -= (len(lis) - 1); assert need == 2 else: out += lis[:need]; need = 0 assert need + len(out)",np,"['binary search', 'greedy', 'math', 'number theory']",2000
"import sys input = sys.stdin.readline def topological_sorted(digraph): n = len(digraph) indegree = [0] * n for v in range(n): for nxt_v in digraph[v]: indegree[nxt_v] += 1 tp_order = [i for i in range(n) if indegree[i] == 0] stack = tp_order[:] while stack: v = stack.pop() for nxt_v in digraph[v]: indegree[nxt_v] -= 1 if indegree[nxt_v] == 0: stack.append(nxt_v) tp_order.append(nxt_v) return len(tp_order) == n, tp_order n, m, k = map(int, input().split()) p = [input()[:-1] for i in range(n)] s = [list(input().split()) for i in range(m)] memo = {} for idx, ptn in enumerate(p): val = 0 for i in range(k): if ptn[i] == ""_"": continue val += (ord(ptn[i]) - 96) * (27 ** i) memo[val] = idx for i, (string, idx) in enumerate(s): s[i] = tuple(map(ord, string)), int(idx) graph = [[] for i in range(n)] for string, idx in s: idxs = [] idx -= 1 for bit_state in range(1 << k): val = 0 for i in range(k): if (bit_state >> i) & 1: continue val += (string[i] - 96) * (27 ** i) if val in memo: idxs.append(memo[val]) if idx not in idxs: print(""NO"") exit() for idx_to in idxs: if idx == idx_to: continue graph[idx].append(idx_to) flag, res = topological_sorted(graph) if flag: print(""YES"") print(*[i + 1 for i in res]) else: print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1228
"import sys input = sys.stdin.readline from collections import deque n,m,k = map(int,input().split()) p = [input().rstrip() for i in range(n)] idx = {s:i for i,s in enumerate(p)} def match(s): res = [] for i in range(2**k): tmp = [] for j in range(k): if i>>j & 1: tmp.append(s[j]) else: tmp.append(""_"") res.append("""".join(tmp)) return set(res) edge = [[] for i in range(n)] deg = [0]*n for i in range(m): s,mt = input().rstrip().split() mt = int(mt)-1 t = p[mt] M = match(s) if t in M: for nv in M: if nv!=t and nv in idx: nv = idx[nv] edge[mt].append(nv) deg[nv] += 1 else: exit(print(""NO"")) deq = deque([v for v in range(n) if deg[v]==0]) res = [] while deq: v = deq.popleft() res.append(v+1) for nv in edge[v]: deg[nv] -= 1 if deg[nv]==0: deq.append(nv) if len(res)!=n: exit(print(""NO"")) print(""YES"") print(*res)",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",815
"from bisect import * from collections import * from math import gcd,ceil,sqrt,floor,inf from heapq import * from itertools import * from operator import add,mul,sub,xor,truediv,floordiv from functools import * import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") def RL(): return map(int, sys.stdin.readline().rstrip().split()) def RLL(): return list(map(int, sys.stdin.readline().rstrip().split())) def N(): return int(input()) from types import GeneratorType def bootstrap(f, stack=[]): def wrappedfunc(*args, **kwargs): if stack: return f(*args, **kwargs) else: to = f(*args, **kwargs) while True: if type(to) is GeneratorType: stack.append(to) to = nex",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",2000
"import io import os from collections import Counter, defaultdict, deque from pprint import pprint def toposort(graph): res = [] found = [0] * len(graph) stack = list(range(len(graph))) while stack: node = stack.pop() if node < 0: res.append(~node) elif not found[node]: found[node] = 1 stack.append(~node) stack += graph[node] for node in res: if any(found[nei] for nei in graph[node]): return None found[node] = 0 return res[::-1] def solve(N, M, K, P, S, MT): graph = [[] for i in range(N)] def isMatch(s, pattern): for a, b in zip(s, pattern): if b != ""_"" and a != b: return False return True ordA = ord(""a"") - 1 def hashStr(s): hsh = 0 for i, c in enumerate(s): val = 27 if c == ""_"" else ord(c) - ordA hsh = 32 * hsh + val return hsh patternToId = {} for i, p in enumerate(P): patternToId[hashStr(p)] = i for s, mt in zip(S, MT): if not isMatch(s, P[mt]): return ""NO"" vals = [ord(c) - ordA for c in s] hsh = 0 for mask in range(1 << K): hsh = 0 for pos in range(K): val = 27 if (1 << pos) & mask else vals[pos] hsh = 32 * hsh + val if hsh in patternToId: mt2 = patternToId[hsh] if mt2 != mt: graph[mt].append(mt2) ans = toposort(graph) if ans is None: return ""NO"" return ""YES\n"" + "" "".join(str(i + 1) for i in ans) if __name__ == ""__main__"": input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline TC = 1 for tc in range(1, TC + 1): N, M, K = [int(x) for x in input().split()] P = [input().decode().rstrip() for i in range(N)] S = [] MT = [] for i in range(M): s, mt = input().split() s = s.decode() mt = int(mt) - 1 S.append(s) MT.append(mt) ans = solve(N, M, K, P, S, MT) print(ans)",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1593
"import sys from enum import Enum class flag(Enum): UNVISITED = -1 EXPLORED = -2 VISITED = -3 def match(p, s): for i in range(len(p)): if p[i] != ""_"" and p[i] != s[i]: return False return True def cycleCheck(u): global AL global dfs_num global dfs_parent global sol dfs_num[u] = flag.EXPLORED.value for v in AL[u]: if dfs_num[v] == flag.UNVISITED.value: dfs_parent[v] = u cycleCheck(v) elif dfs_num[v] == flag.EXPLORED.value: sol = False dfs_num[u] = flag.VISITED.value def toposort(u): global AL global dfs_num global ts dfs_num[u] = flag.VISITED.value for v in AL[u]: if dfs_num[v] == flag.UNVISITED.value: toposort(v) ts.append(u) sol = True n, m, k = map(int, sys.stdin.readline().strip().split()) pd = {} ps = set() pa = [] for i in range(n): p = sys.stdin.readline().strip() pd[p] = i + 1 ps.add(p) pa.append(p) AL = [[] for _ in range(n)] for _ in range(m): s, fn = sys.stdin.readline().strip().split() fn = int(fn) if not match(pa[fn-1], s): sol = False mm = [""""] for i in s: mm = list(map(lambda x: x + ""_"", mm)) + list(map(lambda x: x + i, mm)) for i in mm: if i in ps: if pd[i] != fn: AL[fn-1].append(pd[i]-1) try: if not sol: print(""NO"") else: dfs_num = [flag.UNVISITED.value] * n dfs_parent = [-1] * n for u in range(n): if dfs_num[u] == flag.UNVISITED.value: cycleCheck(u) if not sol: print(""NO"") else: dfs_num = [flag.UNVISITED.value] * n ts = [] for u in range(n): if dfs_num[u] == flag.UNVISITED.value: toposort(u) ts = ts[::-1] print(""YES"") print(' '.join(map(lambda x: str(x+1), ts))) except: print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1522
"def main(): import sys import collections input = sys.stdin.readline n, m, K = map(int, input().split()) A = [input().rstrip() for i in range(n)] B = [list(input().rstrip().split()) for i in range(m)] alpha = 'abcｄ' D = dict() for i, x in enumerate(A): D[x] = i G = [set() for i in range(n)] X = [set() for i in range(n)] for i in range(m): a, b = B[i] b = int(b) flag = False for j in range(2**K): x = [] for k in range(K): if (j >> k) % 2 == 1: x.append('_') else: x.append(a[k]) x = ''.join(x) if x in D: if D[x] == b-1: flag = True continue else: G[b-1].add(D[x]) X[D[x]].add(b-1) if flag: continue else: print(""NO"") exit(0) X = [len(X[i]) for i in range(n)] ANS = [] s = set() q = collections.deque() for i in range(n): if X[i] == 0: q.append(i) s.add(i) while(q): if len(ANS) == n: print(""NO"") exit(0) x = q.popleft() ANS.append(x+1) for y in G[x]: if X[y] == 0: continue else: X[y] -= 1 if X[y] == 0: q.append(y) if len(ANS) == n: print(""YES"") print(*ANS) else: print(""NO"") main()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",987
"import sys;input = sys.stdin.readline def topological_sorted(digraph): n = len(digraph) indegree = [0] * n for v in range(n): for nxt_v in digraph[v]: indegree[nxt_v] += 1 tp_order = [i for i in range(n) if indegree[i] == 0] stack = tp_order[:] while stack: v = stack.pop() for nxt_v in digraph[v]: indegree[nxt_v] -= 1 if indegree[nxt_v] == 0: stack.append(nxt_v) tp_order.append(nxt_v) return len(tp_order) == n, tp_order n, m, k = map(int, input().split()) p = [input()[:-1] for i in range(n)] s = [list(input().split()) for i in range(m)] memo = {} for idx, ptn in enumerate(p): val = 0 for i in range(k): if ptn[i] == ""_"": continue val += (ord(ptn[i]) - 96) * (27 ** i) memo[val] = idx for i, (string, idx) in enumerate(s): s[i] = tuple(map(ord, string)), int(idx) graph = [[] for i in range(n)] for string, idx in s: idxs = [] idx -= 1 for bit_state in range(1 << k): val = 0 for i in range(k): if (bit_state >> i) & 1: continue val += (string[i] - 96) * (27 ** i) if val in memo: idxs.append(memo[val]) if idx not in idxs: print(""NO"") exit() for idx_to in idxs: if idx == idx_to: continue graph[idx].append(idx_to) flag, res = topological_sorted(graph) if flag:print(""YES"");print(*[i + 1 for i in res]) else:print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1226
"import sys;input = sys.stdin.readline def topological_sorted(digraph): n = len(digraph);indegree = [0] * n for v in range(n): for nxt_v in digraph[v]:indegree[nxt_v] += 1 tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:] while stack: v = stack.pop() for nxt_v in digraph[v]: indegree[nxt_v] -= 1 if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v) return len(tp_order) == n, tp_order n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {} for idx, ptn in enumerate(p): val = 0 for i in range(k): if ptn[i] != ""_"":val += (ord(ptn[i]) - 96) * (27 ** i) memo[val] = idx for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx) graph = [[] for i in range(n)] for string, idx in s: idxs = [] idx -= 1 for bit_state in range(1 << k): val = 0 for i in range(k): if (bit_state >> i) & 1: continue val += (string[i] - 96) * (27 ** i) if val in memo: idxs.append(memo[val]) if idx not in idxs: print(""NO"") exit() for idx_to in idxs: if idx == idx_to: continue graph[idx].append(idx_to) flag, res = topological_sorted(graph) if flag:print(""YES"");print(*[i + 1 for i in res]) else:print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1213
"import sys;input = sys.stdin.readline def topological_sorted(digraph): n = len(digraph);indegree = [0] * n for v in range(n): for nxt_v in digraph[v]:indegree[nxt_v] += 1 tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:] while stack: v = stack.pop() for nxt_v in digraph[v]: indegree[nxt_v] -= 1 if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v) return len(tp_order) == n, tp_order n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)] for idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != ""_""]);memo[val] = idx for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx) for string, idx in s: idxs = [] idx -= 1 for bit_state in range(1 << k): val = 0 for i in range(k): if (bit_state >> i) & 1: continue val += (string[i] - 96) * (27 ** i) if val in memo: idxs.append(memo[val]) if idx not in idxs:print(""NO"");exit() for idx_to in idxs: if idx == idx_to: continue graph[idx].append(idx_to) flag, res = topological_sorted(graph) if flag:print(""YES"");print(*[i + 1 for i in res]) else:print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1208
"import sys;input = sys.stdin.readline def topological_sorted(digraph): n = len(digraph);indegree = [0] * n for v in range(n): for nxt_v in digraph[v]:indegree[nxt_v] += 1 tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:] while stack: v = stack.pop() for nxt_v in digraph[v]: indegree[nxt_v] -= 1 if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v) return len(tp_order) == n, tp_order n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)] for idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != ""_""]);memo[val] = idx for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx) for string, idx in s: idxs = [] idx -= 1 for bit_state in range(1 << k): val = 0 for i in range(k): if (bit_state >> i) & 1: continue val += (string[i] - 96) * (27 ** i) if val in memo: idxs.append(memo[val]) if idx not in idxs:print(""NO"");exit() graph[idx] += [idx_to for idx_to in idxs if idx != idx_to] flag, res = topological_sorted(graph) if flag:print(""YES"");print(*[i + 1 for i in res]) else:print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1194
"from sys import stdin, stdout from collections import defaultdict import sys input = stdin.readline def gen(temp,i): global s,k,outs if i==k: j='' for o in range(k): if temp[o]==1: j+=s[o] else: j+='_' outs.add(j) return temp[i]=1 gen(temp,i+1) temp[i]=-1 gen(temp,i+1) class Graph: def __init__(self, vertices): self.graph = defaultdict(list) self.V = vertices def addEdge(self, u, v): self.graph[u].append(v) def isCyclicUtil(self, v, visited, recStack): visited[v] = True recStack[v] = True for neighbour in self.graph[v]: if visited[neighbour] == False: if self.isCyclicUtil(neighbour, visited, recStack) == True: return True elif recStack[neighbour] == True: return True recStack[v] = False return False def isCyclic(self): visited = [False] * self.V recStack = [False] * self.V for node in range(self.V): if visited[node] == False: if self.isCyclicUtil(node, visited, recStack) == True: return True return False def topologicalSortUtil(self, v, visited, stack): visited[v] = True for i in self.graph[v]: if visited[i] == False: self.topologicalSortUtil(i, visited, stack) stack.append(v) def topologicalSort(self): visited = [False] * self.V stack = [] for i in range(self.V): if visited[i] == False: self.topologicalSortUtil(i, visited, stack) stack=stack[::-1] print(""yes"") for i in stack: stdout.write(str(i+1)+"" "") n,m,k=map(int,input().split()) patterns={} all=[] for i in range(n): s=input()[:-1] patterns[s]=i all.append(s) strs=[] dg=Graph(n) for i in range(m): s,mt=input().split() mt=int(mt)-1 outs=set() temp=[0 for o in range(k)] gen(temp,0) if all[mt] not in outs: print(""no"") sys.exit() for i in outs: if i!=all[mt] and i in patterns: dg.addEdge(mt,patterns[i]) if dg.isCyclic(): print(""no"") else: dg.topologicalSort()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1738
"import sys input = sys.stdin.readline from collections import defaultdict, Counter, deque n, m, k = map(int, input().split()) P = [input()[:-1] for _ in range(n)] S = [list(input().split()) for _ in range(m)] idx = {p: i for i, p in enumerate(P, 1)} G = defaultdict(list) deg = Counter() for s, i in S: i = int(i) cand = set() for mask in range(1 << k): cur = ['_'] * k for j in range(k): if mask >> j & 1: cur[j] = s[j] cur = """".join(cur) if cur in idx: cand.add(idx[cur]) if i not in cand: print(""NO"") break for c in cand: if c == i: continue G[i].append(c) deg[c] += 1 else: ans = [] q = deque([i for i in range(1, n + 1) if not deg[i]]) while q: i = q.popleft() ans.append(i) for j in G[i]: deg[j] -= 1 if not deg[j]: q.append(j) if len(ans) < n: print(""NO"") else: print(""YES"") print(*ans)",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",793
"import sys input = sys.stdin.readline n,m,k=map(int,input().split()) P=[input().strip() for i in range(n)] S=[input().split() for i in range(m)] for i in range(m): S[i][1]=int(S[i][1])-1 PDICT=dict() for i in range(n): PDICT[P[i]]=i E=[] for i in range(m): x=S[i][0] LIST=[] for j in range(1<<k): t="""" for l in range(k): if (1<<l) & j != 0: t+=""_"" else: t+=x[l] if t in PDICT: LIST.append(PDICT[t]) if not (S[i][1] in LIST): print(""NO"") exit() else: s=S[i][1] for l in LIST: if l==s: continue else: E.append((s,l)) EDGEIN=[0]*n EDGEOUTLIST=[[] for i in range(n)] for x,y in E: EDGEIN[y]+=1 EDGEOUTLIST[x].append(y) from collections import deque QUE = deque() for i in range(n): if EDGEIN[i]==0: QUE.append(i) TOP_SORT=[] while QUE: x=QUE.pop() TOP_SORT.append(x) for to in EDGEOUTLIST[x]: EDGEIN[to]-=1 if EDGEIN[to]==0: QUE.appendleft(to) if len(TOP_SORT)==n: print(""YES"") print(*[i+1 for i in TOP_SORT]) else: print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",923
"import sys input = lambda: sys.stdin.readline().rstrip('\r\n') N, M, K = map(int, input().split()) P = [] D_P = {} for i in range(N): S = input() P.append(S) D_P[S] = i adj = [[] for _ in range(N)] indeg = [0] * N for _ in range(M): S, mt = input().split() mt = int(mt)-1 fp = P[mt] if any(fp[i] not in (S[i], '_') for i in range(K)): print('NO') raise SystemExit for bs in range(1<<K): pat = ''.join(S[i] if bs & (1<<i) == 0 else '_' for i in range(K)) if pat == fp: continue if pat in D_P: j = D_P[pat] indeg[j] += 1 adj[mt].append(j) Q = [i for i in range(N) if indeg[i] == 0] for i in Q: for j in adj[i]: indeg[j] -= 1 if indeg[j] == 0: Q.append(j) if len(Q) == N: print('YES') print(' '.join(str(v+1) for v in Q)) else: print('NO')",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",736
"import sys input = lambda: sys.stdin.readline().rstrip() from collections import defaultdict as ddc def main(): n, m, k = map(int,input().split()) def edges(s): Ans = set() for i in range(2**k): ans = '' for j in range(k): if i>>j&1: ans = ''.join([ans, s[j]]) else: ans = ''.join([ans, '_']) Ans.add(ans) return Ans D = ddc(lambda : -1) for i in range(n): D[input()] = i flag = 1 In, Out = [set() for _ in range(n)], [set() for _ in range(n)] for _ in range(m): S, t = input().split() t = int(t) for e in edges(S): if D[e]+1: Out[t-1].add(D[e]) In[D[e]].add(t-1) if t-1 not in Out[t-1]: flag = 0 break else: Out[t-1].remove(t-1) In[t-1].remove(t-1) from collections import deque def topological_sort(In, Out): dq = deque() L = [] for i, I in enumerate(In): if not I: dq.append(i) while dq: v = dq.popleft() L.append(v) for w in Out[v]: In[w].remove(v) if not In[w]: dq.append(w) if len(L) < len(In): return False return L T = topological_sort(In, Out) if flag == 0 or not T: print('NO') else: print('YES') print(*[t+1 for t in T], sep = ' ') main()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1049
"import sys input = lambda: sys.stdin.readline().rstrip() from collections import deque, defaultdict def topological_sort(In, Out): dq, L = deque(), [] for i, I in enumerate(In): if not I: dq.append(i) while dq: v = dq.popleft() L.append(v) for w in Out[v]: In[w].remove(v) if not In[w]: dq.append(w) if len(L) < len(In): return False return L def main(): n, m, k = map(int,input().split()) def edges(s): Ans = set() for i in range(2**k): ans = '' for j in range(k): if i>>j&1: ans = ''.join([ans, s[j]]) else: ans = ''.join([ans, '_']) Ans.add(ans) return Ans D = defaultdict(lambda : -1) for i in range(n): D[input()] = i flag = 1 In, Out = [set() for _ in range(n)], [set() for _ in range(n)] for _ in range(m): S, t = input().split() t = int(t) for e in edges(S): if D[e]+1: Out[t-1].add(D[e]) In[D[e]].add(t-1) if t-1 not in Out[t-1]: flag = 0 break else: Out[t-1].remove(t-1) In[t-1].remove(t-1) T = topological_sort(In, Out) if flag == 0 or not T: print('NO') else: print('YES') print(*[t+1 for t in T], sep = ' ') main()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1027
"import sys from collections import deque, defaultdict input = lambda: sys.stdin.readline().rstrip() def topological_sort(In, Out): dq, L = deque(), [] for i, I in enumerate(In): if not I: dq.append(i) while dq: v = dq.popleft() L.append(v) for w in Out[v]: In[w].remove(v) if not In[w]: dq.append(w) if len(L) < len(In): return False return L def main(): n, m, k = map(int,input().split()) def edges(s): Ans = set() for i in range(2**k): ans = [s[j] if i>>j&1 else '_' for j in range(k)] Ans.add(''.join(ans)) return Ans D = defaultdict(lambda : -1) for i in range(n): D[input()] = i flag = 1 In, Out = [set() for _ in range(n)], [set() for _ in range(n)] for _ in range(m): S, t = input().split() t = int(t) for e in edges(S): if D[e]+1: Out[t-1].add(D[e]) In[D[e]].add(t-1) if t-1 not in Out[t-1]: flag = 0 break else: Out[t-1].remove(t-1) In[t-1].remove(t-1) T = topological_sort(In, Out) if flag == 0 or not T: print('NO') else: print('YES') print(*[t+1 for t in T], sep = ' ') main()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",988
"import sys from collections import deque, defaultdict input = lambda: sys.stdin.readline().rstrip() def topological_sort(In, Out): dq, L = deque(), [] for i, I in enumerate(In): if not I: dq.append(i) while dq: v = dq.popleft() L.append(v) for w in Out[v]: In[w].remove(v) if not In[w]: dq.append(w) if len(L) < len(In): return False return L def main(): n, m, k = map(int,input().split()) def edges(s): Ans = set() for i in range(2**k): ans = [s[j] if i>>j&1 else '_' for j in range(k)] Ans.add(''.join(ans)) return Ans D = defaultdict(lambda : -1) for i in range(n): D[input()] = i flag = 1 In, Out = [set() for _ in range(n)], [set() for _ in range(n)] for _ in range(m): S, t = input().split() t = int(t) for e in edges(S): if D[e]+1: Out[t-1].add(D[e]) In[D[e]].add(t-1) if t-1 not in Out[t-1]: flag = 0 break else: Out[t-1].remove(t-1) In[t-1].remove(t-1) T = topological_sort(In, Out) if flag and T: print('YES') print(*[t+1 for t in T], sep = ' ') else: print('NO') main()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",980
"import sys from collections import deque, defaultdict input = lambda: sys.stdin.readline().rstrip() def topological_sort(In, Out): dq, L = deque(), [] for i, I in enumerate(In): if not I: dq.append(i) while dq: v = dq.popleft() L.append(v) for w in Out[v]: In[w].remove(v) if not In[w]: dq.append(w) if len(L) < len(In): return False return L def main(): n, m, k = map(int,input().split()) def edges(s): Ans = set() for i in range(2**k): ans = [s[j] if i>>j&1 else '_' for j in range(k)] Ans.add(''.join(ans)) return Ans D = defaultdict(lambda : -1) for i in range(n): D[input()] = i flag = True In, Out = [set() for _ in range(n)], [set() for _ in range(n)] for _ in range(m): S, t = input().split() t = int(t) for e in edges(S): if D[e]+1: Out[t-1].add(D[e]) In[D[e]].add(t-1) if t-1 not in Out[t-1]: flag = False break else: Out[t-1].remove(t-1) In[t-1].remove(t-1) T = topological_sort(In, Out) if flag and T: print('YES') print(*[t+1 for t in T]) else: print('NO') main()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",976
"import sys sys.setrecursionlimit(10**5) int1 = lambda x: int(x)-1 p2D = lambda x: print(*x, sep=""\n"") def II(): return int(sys.stdin.buffer.readline()) def MI(): return map(int, sys.stdin.buffer.readline().split()) def LI(): return list(map(int, sys.stdin.buffer.readline().split())) def LLI(rows_number): return [LI() for _ in range(rows_number)] def BI(): return sys.stdin.buffer.readline().rstrip() def SI(): return sys.stdin.buffer.readline().rstrip().decode() inf = 10**16 md = 10**9+7 trie = [{}] def push(s, val): now = 0 for c in s: if c not in trie[now]: trie[now][c] = len(trie) trie.append({}) now = trie[now][c] trie[now][""end""] = val def match(s): res = [] stack = [(0, 0)] while stack: u, i = stack.pop() if i == k: res.append(trie[u][""end""]) continue if s[i] in trie[u]: stack.append((trie[u][s[i]], i+1)) if ""_"" in trie[u]: stack.append((trie[u][""_""], i+1)) return res n, m, k = MI() for i in range(n): push(SI(), i) to = [[] for _ in range(n)] for _ in range(m): s, u = SI().split() u = int(u)-1 vv = match(s) notmatch = True for v in vv: if u == v: notmatch = False else: to[u].append(v) if notmatch: print(""NO"") exit() vis=[-1]*n topo=[] for u in range(n): if vis[u]==1:continue stack=[u] while stack: u=stack.pop() if vis[u]==-1: vis[u]=0 stack.append(u) for v in to[u]: if vis[v]==0: print(""NO"") exit() if vis[v]==-1: stack.append(v) elif vis[u]==0: topo.append(u+1) vis[u]=1 print(""YES"") print(*topo[::-1])",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1428
"import sys I=sys.stdin.readlines() N,M,K=map(int,I[0].split()) S=[I[i+1][:-1] for i in range(N)] D=dict() for i in range(N): D[S[i]]=i T=[I[i+N+1].split() for i in range(M)] for i in range(M): T[i][1]=int(T[i][1])-1 G=[[] for i in range(N)] C=[0]*N for i in range(M): for j in range(K): if S[T[i][1]][j]!='_' and S[T[i][1]][j]!=T[i][0][j]: print('NO') exit() for j in range(1<<K): t=''.join(['_' if j&(1<<k) else T[i][0][k] for k in range(K)]) x=D.get(t,-1) if x!=-1 and x!=T[i][1]: G[T[i][1]].append(x) C[x]+=1 P=[] Q=[] F=[1]*N for i in range(N): if C[i]==0 and F[i]: Q.append(i) while len(Q): v=Q.pop() F[v]=0 P.append(v+1) for i in range(len(G[v])): C[G[v][i]]-=1 if C[G[v][i]]==0: Q.append(G[v][i]) if len(P)==N: print('YES') print(*P) else: print('NO')",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",758
"from sys import stdin, gettrace if gettrace(): def inputi(): return input() else: def input(): return next(stdin)[:-1] def inputi(): return stdin.buffer.readline() def patterns(s): if len(s) == 1: return [s, '_'] else: tp = patterns(s[1:]) return [s[0] + t for t in tp] + ['_' + t for t in tp] def main(): n,m,k = map(int, input().split()) pp = (input() for _ in range(n)) ppm = {} for i, p in enumerate(pp): ppm[p] = i pre = [0]*n suc = [[] for _ in range(n)] for _ in range(m): s, ml = input().split() ml = int(ml) - 1 ps = patterns(s) found = False for p in ps: if p in ppm: if ppm[p] == ml: found = True else: pre[ppm[p]] += 1 suc[ml].append(ppm[p]) if not found: print(""NO"") return znodes = [i for i in range(n) if pre[i]==0] res = [] while znodes: i = znodes.pop() res.append(i+1) for j in suc[i]: pre[j] -= 1 if pre[j] == 0: znodes.append(j) if len(res) == n: print(""YES"") print(' '.join(map(str, res))) else: print(""NO"") if __name__ == ""__main__"": main()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",962
"import collections,sys,functools,heapq,bisect,math def binary(s): ans = set() for i in range(2**len(s)): x = [] for j in range(len(s)): if (i>>j) & 1: x.append(s[j]) else: x.append('_') ans.add(''.join(x)) return ans seen = set() visited = set() ans = [] def dfs(i): visited.add(i) seen.add(i) for j in graph[i]: if j in visited: return True if j in seen: continue if dfs(j): return True ans.append(str(i)) visited.remove(i) return False def topo(graph): seen.clear() for i in range(1,n+1): if i in seen: continue if dfs(i): return False return True input = sys.stdin.readline mod = 10**9 + 7 for _ in range(1): n,m,k = map(int,input().strip().split()) d = {} dop = {} for i in range(1,n+1): d[i] = input().strip() dop[d[i]] = i graph = collections.defaultdict(list) for i in range(m): s = input().strip().split() ind = int(s[1]) sset = binary(s[0]) if d[ind] not in sset: print('NO') break for i in sset: if i in dop and dop[i] != ind : graph[dop[i]].append(ind) else: if topo(graph): print('YES') print(' '.join(ans)) else: print('NO')",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1037
"import sys input = lambda: sys.stdin.readline().rstrip('\r\n') from collections import defaultdict as dft n,m,k=map(int,input().split()) dct={} global case case=0 iput=[] for i in range(n): word=input() dct[word]=i+1 iput.append(word) d=[[] for i in range(n+1)] size=[0]*(n+1) for _ in range(m): word,idx=input().split() idx=int(idx) temp=1 w=iput[idx-1] for x in range(k): if w[x]!='_' and w[x]!=word[x]: temp=0 print(""NO"") exit() break res=[] for i in range(1<<k): s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)]) if s in dct: j=dct[s] if j!=idx: d[idx].append(j) size[j]+=1 st=[nd for nd in range(1,n+1) if size[nd]==0] for i in st: for j in d[i]: size[j]-=1 if size[j]==0: st.append(j) if len(st)==n: print(""YES"") print(*st) else: print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",763
"import os,sys from io import BytesIO, IOBase from collections import deque, Counter,defaultdict as dft from heapq import heappop ,heappush from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor from bisect import bisect,bisect_left,bisect_right from decimal import * import sys,threading from itertools import permutations, combinations from copy import deepcopy input = sys.stdin.readline ii = lambda: int(input()) si = lambda: input().rstrip() mp = lambda: map(int, input().split()) ms= lambda: map(str,input().strip().split("" "")) ml = lambda: list(mp()) mf = lambda: map(float, input().split()) alphs = ""abcdefghijklmnopqrstuvwxyz"" def solve(): n,m,k=map(int,input().split()) dct={} global case case=0 iput=[] for i in range(n): word=input() dct[word]=i+1 iput.append(word) d=[[] for i in range(n+1)] size=[0]*(n+1) for _ in range(m): word,idx=input().split() idx=int(idx) temp=1 w=iput[idx-1] for x in range(k): if w[x]!='_' and w[x]!=word[x]: temp=0 print(""NO"") exit() break res=[] for i in range(1<<k): s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)]) if s in dct: j=dct[s] if j!=idx: d[idx].append(j) size[j]+=1 st=[nd for nd in range(1,n+1) if size[nd]==0] for i in st: for j in d[i]: size[j]-=1 if size[j]==0: st.append(j) if len(st)==n: print(""YES"") print(*st) else: print(""NO"") BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",2000
"import os,sys from io import BytesIO, IOBase from collections import deque, Counter,defaultdict as dft from heapq import heappop ,heappush from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor from bisect import bisect,bisect_left,bisect_right from decimal import * import sys,threading from itertools import permutations, combinations from copy import deepcopy input = sys.stdin.readline ii = lambda: int(input()) si = lambda: input().rstrip() mp = lambda: map(int, input().split()) ms= lambda: map(str,input().strip().split("" "")) ml = lambda: list(mp()) mf = lambda: map(float, input().split()) alphs = ""abcdefghijklmnopqrstuvwxyz"" def solve(): def seq(nd,i): case=0 vis[nd]=1 for lnk in d[nd]: if not vis[lnk]: i,case=seq(lnk,i) if case:return i,case else: if lnk not in seen: case=1 break order[i]=nd seen.add(nd) return i-1,case def chk(word,dct,i): if i==k: res.append(dct[' else: if word[i] in dct: chk(word,dct[word[i]],i+1) if '_' in dct: chk(word,dct['_'],i+1) n,m,k=map(int,input().split()) trie={} global case case=0 for i in range(n): word=input() dct=trie for w in word: if w not in dct: dct[w]={} dct=dct[w] dct[' d=dft(list) for i in range(m): word,idx=input().split() idx=int(idx) res=[] chk(word,trie,0) temp=0 for num in res: if num!=idx: d[idx].append(num) else: temp=1 if not temp: case=1 order=[0]*(n+1) vis=[0]*(n+1) seen=set() idx=n for i in range(1,n+1): if not vis[i]: idx,tp=seq(i,idx) if tp: case=1 break if case: print(""NO"") else: print(""YES"") print(*order[1:]) BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def re",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",2000
"import math,sys,bisect,heapq,os from collections import defaultdict,Counter,deque from itertools import groupby,accumulate from functools import lru_cache int1 = lambda x: int(x) - 1 def input(): return sys.stdin.readline().rstrip('\r\n') aj = lambda: list(map(int, input().split())) def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)] def Y(c): print([""NO"",""YES""][c]) def y(c): print([""no"",""yes""][c]) def Yy(c): print([""No"",""Yes""][c]) def solve(): G = defaultdict(list) def addEdge(a,b): G[a].append(b) def Kahn(N): in_degree = [0]*(N+1) for i in G.keys(): for j in G[i]: in_degree[j] += 1 queue = deque() for i in range(1,N+1): if in_degree[i] == 0: queue.append(i) cnt =0 top_order = [] while queue: u = queue.popleft() top_order.append(u) for i in G.get(u,[]): in_degree[i] -= 1 if in_degree[i] == 0: queue.append(i) cnt += 1 if cnt != N: Y(0);exit(0) else: Y(1);print(*top_order) n,m,k = aj() mark= {} for i in range(n): s = input() mark[s] = i+1 B = [] for i in range(2**k): f = bin(i)[2:] f = '0'*(k - len(f)) + f B.append(f) for i in range(m): s,mt = input().split("" "") mt = int(mt) st = set() for j in B: ss = ['']*k for l in range(k): if j[l] == '1': ss[l] = s[l] else: ss[l] = '_' ss = """".join(ss) if ss in mark: st.add(mark[ss]) if mt not in st: Y(0);exit(0) st.discard(mt) for j in st: addEdge(mt,j) Kahn(n) try: sys.stdin = open('input.txt', 'r') sys.stdout = open('output.txt', 'w') except: pass solve()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1445
"mod = 1000000007 eps = 10**-9 def main(): import sys input = sys.stdin.readline N, M, K = map(int, input().split()) P = [""""] for i in range(N): p = input().rstrip(""\n"") P.append(p) p2i = {p: i for i, p in enumerate(P)} adj = [set() for _ in range(N+1)] for i in range(M): s, mt = input().split() mt = int(mt) ok = 0 for k in range(1 << K): s_new = [""_""] * K for j in range(K): if k >> j & 1: s_new[j] = s[j] s_new = """".join(s_new) if s_new != P[mt]: if s_new in p2i: adj[mt].add(p2i[s_new]) else: ok = 1 if not ok: print(""NO"") exit() in_num = [0] * (N+1) for v in range(1, N+1): for u in adj[v]: in_num[u] += 1 st = [] for v in range(1, N+1): if in_num[v] == 0: st.append(v) ans = [] while st: v = st.pop() ans.append(v) for u in adj[v]: in_num[u] -= 1 if in_num[u] == 0: st.append(u) if len(ans) == N: print(""YES"") print(*ans) else: print(""NO"") if __name__ == '__main__': main()",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",879
"import sys, os from collections import defaultdict if os.environ['USERNAME']=='kissz': inp=open('in.txt','r').readline def debug(*args): print(*args,file=sys.stderr) else: inp=input def debug(*args): pass def get_hash(s): r=0 for c in s: r*=30 if c!='_': r+=ord(c)-96 return r def matches(s): R=[] for i in range(2**k): r=0 for j in range(k): if i&(1<<j): r+=(ord(s[j])-96)*(30**(k-j-1)) if pattern_pos[r]>=0: R.append(pattern_pos[r]) return R n,m,k=map(int,inp().split()) pattern_pos=[-1]*(30**k) for i in range(n): p=get_hash(inp().strip()) pattern_pos[p]=i+1 parents=[0]*(n+1) edges=defaultdict(list) failed=False for i in range(m): s,l=inp().split() l=int(l) M=matches(s) if l in M: for m in M: if l==m: continue edges[l].append(m) parents[m]+=1 else: failed=True break if failed: print('NO') else: Q=[] for i in range(1,n+1): if parents[i]==0: Q.append(i) ans=[] while Q: i=Q.pop() ans.append(i) for child in edges[i]: parents[child]-=1 if parents[child]==0: Q.append(child) if len(ans)==n: print('YES') print(*ans) else: print('NO')",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1038
"import sys input = sys.stdin.readline from collections import deque class Graph: def __init__(self, N, M=-1): self.V = N if M>=0: self.E = M self.edge = [[] for _ in range(self.V)] self.edge_rev = [[] for _ in range(self.V)] self.order = [] self.to = [0]*self.V self.visited = [False]*self.V self.dp = [0]*self.V def add_edge(self, a, b, dist=-1, bi=False, rev=False): if dist>=0: self.edge[a].append((dist, b)) if rev: self.edge_rev[b].append((dist, a)) if bi: self.edge[b].append((dist, a)) else: self.edge[a].append(b) self.to[b] += 1 if rev: self.edge_rev[b].append(a) if bi: self.edge[b].append(a) def topo_sort(self): updated = [0]*self.V for start in range(self.V): if self.to[start] or updated[start]: continue stack = deque([start]) while stack: v = stack.popleft() self.order.append(v+1) updated[v] = 1 for u in self.edge[v]: self.to[u] -= 1 if self.to[u]: continue stack.append(u) N, M, K = map(int, input().split()) from collections import defaultdict dic = defaultdict(lambda: -1) for i in range(N): S = input()[:-1] dic[S] = i G = Graph(N) for _ in range(M): t, mt = input().split() mt = int(mt)-1 lis = [] for S in range(1<<K): s = '' for i in range(K): if (S>>i)%2: s += '_' else: s += t[i] if dic[s]>=0: lis.append(dic[s]) if mt not in lis: print('NO') exit() for l in lis: if l!=mt: G.add_edge(mt, l, bi=False, rev=False) G.topo_sort() if len(G.order)==N: print('YES') print(*G.order) else: print('NO')",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1420
"import sys input=sys.stdin.readline from collections import defaultdict def toposort(graph): res = [] found = [0] * len(graph) stack = list(range(len(graph))) while stack: node = stack.pop() if node < 0: res.append(1+(~node)) elif not found[node]: found[node] = 1 stack.append(~node) stack.extend(graph[node]) for node in res: node-=1 if any(found[nei] for nei in graph[node]): print(""NO"") return found[node] = 0 print(""YES"") print(*res[::-1]) n,m,k=map(int,input().split()) patterns=set() pos=dict() for i in range(n): p=input().rstrip() patterns.add(p) pos[p]=i matches=[[] for _ in range(n)] chk=True for i in range(m): s,mt=input().rstrip().split() mt=int(mt)-1 if(chk): chk=False for i in range(1<<k): tmp=[] for j in range(k): if(i&(1<<j)): tmp.append('_') else: tmp.append(s[j]) tmp=''.join(tmp) if(tmp in patterns): if(mt==pos[tmp]): chk=True else: matches[mt].append(pos[tmp]) if(not chk): print(""NO"") else: toposort(matches)",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",934
"import os import sys from io import BytesIO, IOBase BUFSIZE = 8192 class FastIO(IOBase): newlines = 0 def __init__(self, file): self._fd = file.fileno() self.buffer = BytesIO() self.writable = ""x"" in file.mode or ""r"" not in file.mode self.write = self.buffer.write if self.writable else None def read(self): while True: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) if not b: break ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines = 0 return self.buffer.read() def readline(self): while self.newlines == 0: b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE)) self.newlines = b.count(b""\n"") + (not b) ptr = self.buffer.tell() self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr) self.newlines -= 1 return self.buffer.readline() def flush(self): if self.writable: os.write(self._fd, self.buffer.getvalue()) self.buffer.truncate(0), self.buffer.seek(0) class IOWrapper(IOBase): def __init__(self, file): self.buffer = FastIO(file) self.flush = self.buffer.flush self.writable = self.buffer.writable self.write = lambda s: self.buffer.write(s.encode(""ascii"")) self.read = lambda: self.buffer.read().decode(""ascii"") self.readline = lambda: self.buffer.readline().decode(""ascii"") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip(""\r\n"") from collections import defaultdict def toposort(graph): res = [] found = [0] * len(graph) stack = list(range(len(graph))) while stack: node = stack.pop() if node < 0: res.append(1+(~node)) elif not found[node]: found[node] = 1 stack.append(~node) stack.extend(graph[node]) for node in res: node-=1 if any(found[nei] for nei in graph[node]): print(""NO"") return found[node] = 0 print(""YES"") print(*res[::-1]) n,m,k=map(int,input().split()) patterns=set() pos=dict() for i in range(n): p=input().rstrip() patterns.add(p) pos[p]=i matches=[[] for _ in range(n)] chk=True for i in range(m): s,mt=input().rst",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",2000
"from collections import defaultdict from itertools import accumulate import sys input = sys.stdin.readline inf = 100000000000000000 mod = 998244353 n, m ,k= map(int, input().split()) M=[] S=[] F=[] for i in range(n): M.append(input().strip()) for i in range(m): tmp1, tmp2 = input().split() S.append(tmp1) F.append(int(tmp2)-1) TRAN_dict=defaultdict(int) TRAN_dict['_']=0 for i in range(97,97+26): TRAN_dict[chr(i)]=i-96; def cal(X): base=1 number=0 for x in X: number=number*base+TRAN_dict[x] base*=27 return number STONE=defaultdict(int) for i in range(n): STONE[cal(list(M[i]))]=i def check(X,result): number=cal(X) if number in STONE.keys(): result.append(STONE[number]) bian=[[] for i in range(n)] du=[0]*n for i in range(m): gain=[] for digit in range(1<<k): now=list(S[i]) tmp=bin(digit) tmp=tmp[2:] tmp='0'*(k-len(tmp))+tmp for j in range(k): if tmp[j]=='1': now[j]='_' check(now,gain) if F[i] not in gain: print(""NO"") sys.exit(0) for x in gain: if x!=F[i]: bian[F[i]].append(x) du[x]+=1 from collections import deque QUE=deque() for i in range(n): if du[i]==0: QUE.append(i) TOP_SORT=[] while QUE: now=QUE.pop() TOP_SORT.append(now) for to in bian[now]: du[to]-=1 if du[to]==0: QUE.append(to) if len(TOP_SORT)==n: print(""YES"") print(*[i+1 for i in TOP_SORT]) else: print(""NO"")",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1285
"def parse(): s, i = input().split() i = int(i) - 1 return s, i def match(p, s): for a, b in zip(p, s): if a != '_' and a != b: return False return True def main(): from itertools import product n, m, k = [int(t) for t in input().split()] P = [input() for _ in range(n)] S = [parse() for _ in range(m)] index_of = dict() for i, p in enumerate(P): index_of[p] = i G = [[] for _ in range(n)] for s, i in S: if not match(P[i], s): print(""NO"") return for mask in product(range(2), repeat=k): sp = ['_' if bit else c for bit, c in zip(mask, s)] sp = ''.join(sp) try: j = index_of[sp] if i != j: G[i].append(j) except: pass tp = toposort(G) if tp is None: print(""NO"") else: print(""YES"") print(*[x+1 for x in tp]) def toposort(graph): res, found = [], [0] * len(graph) stack = list(range(len(graph))) while stack: node = stack.pop() if node < 0: res.append(~node) elif not found[node]: found[node] = 1 stack.append(~node) stack += graph[node] for node in res: if any(found[nei] for nei in graph[node]): return None found[node] = 0 return res[::-1] import sys, os, io input = lambda: sys.stdin.readline().rstrip('\r\n') stdout = io.BytesIO() sys.stdout.write = lambda s: stdout.write(s.encode(""ascii"")) main() os.write(1, stdout.getvalue())",np,"['bitmasks', 'data structures', 'dfs and similar', 'graphs', 'hashing', 'sortings', 'strings']",1231
"def divisors(M): d=[] i=1 while M>=i**2: if M%i==0: d.append(i) if i**2!=M: d.append(M//i) i=i+1 return d def popcount(x): x = x - ((x >> 1) & 0x55555555) x = (x & 0x33333333) + ((x >> 2) & 0x33333333) x = (x + (x >> 4)) & 0x0f0f0f0f x = x + (x >> 8) x = x + (x >> 16) return x & 0x0000007f def eratosthenes(n): res=[0 for i in range(n+1)] prime=set([]) for i in range(2,n+1): if not res[i]: prime.add(i) for j in range(1,n//i+1): res[i*j]=1 return prime def factorization(n): res=[] for p in prime: if n%p==0: while n%p==0: n//=p res.append(p) if n!=1: res.append(n) return res def euler_phi(n): res = n for x in range(2,n+1): if x ** 2 > n: break if n%x==0: res = res//x * (x-1) while n%x==0: n //= x if n!=1: res = res//n * (n-1) return res def ind(b,n): res=0 while n%b==0: res+=1 n//=b return res def isPrimeMR(n): d = n - 1 d = d // (d & -d) L = [2, 3, 5, 7, 11, 13, 17] for a in L: t = d y = pow(a, t, n) if y == 1: continue while y != n - 1: y = (y * y) % n if y == 1 or t == n - 1: return 0 t <<= 1 return 1 def findFactorRho(n): from math import gcd m = 1 << n.bit_length() // 8 for c in range(1, 99): f = lambda x: (x * x + c) % n y, r, q, g = 2, 1, 1, 1 while g == 1: x = y for i in range(r): y = f(y) k = 0 while k < r and g == 1: ys = y for i in range(min(m, r - k)): y = f(y) q = q * abs(x - y) % n g = gcd(q, n) k += m r <<= 1 if g == n: g = 1 while g == 1: ys = f(ys) g = gcd(abs(x - ys), n) if g < n: if isPrimeMR(g): return g elif isPrimeMR(n // g): return n // g return findFactorRho(g) def primeFactor(n): i = 2 ret = {} rhoFlg = 0 while i*i <= n: k = 0 while n % i == 0: n //= i k += 1 if k: ret[i] = k i += 1 + i % 2 if i == 101 and n >= 2 ** 20: while n > 1: if isPrimeMR(n): ret[n], n = 1, 1 else: rhoFlg = 1 j = findFactorRho(n) k = 0 while n % j == 0: n //= j k += 1 ret[j] = k if n > 1: ret[n] = 1 if rhoFlg: ret = {x: ret[x] for x in sorted(ret)} return ret def divisors(n): res = [1] prime = primeFactor(n) for p in prime: newres = [] for d in res: for j in range(prime[",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",2000
"import sys input = lambda: sys.stdin.readline().rstrip() N, K = map(int, input().split()) S = [-1 if a == ""?"" else ord(a) - 97 for a in input()] II = {1 << i: i for i in range(20)} def calc(mmm): inf = 300000 X = [[0] * N for _ in range(K)] for k in range(K): Xk = X[k] mi = inf r = 0 for i in range(N)[::-1]: if S[i] < 0 or S[i] == k: r += 1 else: r = 0 if r >= mmm: mi = min(mi, i + mmm) Xk[i] = mi Y = [0] * (1 << K) for i in range(1, 1 << K): mi = inf for j in range(K): if i >> j & 1: ii = i ^ (1 << j) if Y[ii] < N: mi = min(mi, X[j][Y[ii]]) Y[i] = mi return 1 if Y[-1] < inf else 0 l, r = 0, N // K + 1 while r - l > 1: m = l + r >> 1 if calc(m): l = m else: r = m print(l)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",680
"import sys input = sys.stdin.readline n, k = map(int, input().split()) s = input()[:-1] left, right = 0, n while left < right: mid = right - (right - left) // 2 A = [[0] * (n + 2) for _ in range(k)] for c in range(k): A[c][n] = A[c][n + 1] = n + 1 L = 0 for i in range(n - 1, -1, -1): if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1 else: L = 0 A[c][i] = i + mid if L >= mid else A[c][i + 1] dp = [n + 1] * (1 << k) dp[0] = 0 for mask in range(1 << k): for i in range(k): if mask >> k & 1: continue t = mask | 1 << i dp[t] = min(dp[t], A[i][dp[mask]]) if dp[-1] <= n: left = mid else: right = mid - 1 print(left)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",616
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from collections import deque n, k = map(int,input().split()) s = input() maxconseq = [[0 for j in range(k)] for i in range(n+1)] for i in range(n): if s[i]==ord('?'): for j in range(k): maxconseq[i][j] = maxconseq[i-1][j] + 1 else: j = s[i]-97 maxconseq[i][j] = maxconseq[i-1][j] + 1 def judge(needed): inf = 2147483647 minstate = [inf]*(1<<k) minstate[0] = 0 effect = [[inf]*(n+1) for j in range(k)] for j in range(k): for i in range(n)[::-1]: if maxconseq[i][j]>=needed: effect[j][i-needed+1] = i+1 effect[j][i] = min(effect[j][i], effect[j][i+1]) for state in range(1,1<<k): minimum = minstate[state] for j in range(k): if (1<<j) & state==0: continue index = minstate[state^(1<<j)] if index<n: minimum = min(minimum, effect[j][index]) minstate[state] = minimum if minstate[-1]<=n: return True return False front = 0 rear = n//k+1 while front < rear: mid = (front+rear)//2 flag = judge(mid) if flag: front = mid + 1 else: rear = mid print(front-1)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",1024
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from collections import deque n, k = map(int,input().split()) s = input() def judge(needed): inf = 2147483647 minstate = [inf]*(1<<k) minstate[0] = 0 effect = [[inf]*(n+1) for j in range(k)] for j in range(k): accu = 0 index = inf for i in range(n)[::-1]: if s[i]==ord('?') or s[i]==97+j: accu += 1 else: accu = 0 if accu>=needed: index = i + needed effect[j][i] = index for state in range(1,1<<k): minimum = minstate[state] for j in range(k): if (1<<j) & state==0: continue index = minstate[state^(1<<j)] if index<n: minimum = min(minimum, effect[j][index]) minstate[state] = minimum if minstate[-1]<=n: return True return False front = 0 rear = n//k+1 while front < rear: mid = (front+rear)//2 flag = judge(mid) if flag: front = mid + 1 else: rear = mid print(front-1)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",844
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from collections import deque n, k = map(int,input().split()) s = input() def judge(needed): inf = 2147483647 minstate = [inf]*(1<<k) minstate[0] = 0 effect = [[inf]*(n+1) for j in range(k)] for j in range(k): accu = 0 index = inf for i in range(n)[::-1]: if s[i]==ord('?') or s[i]==97+j: accu += 1 else: accu = 0 if accu>=needed: index = i + needed effect[j][i] = index effect[j][i] = effect[j][i+4-4] for state in range(1,1<<k): minimum = minstate[state] for j in range(k): if (1<<j) & state==0: continue index = minstate[state^(1<<j)] if index<n: minimum = min(minimum, effect[j][index]) minstate[state] = minimum if minstate[-1]<=n: return True return False front = 0 rear = n//k+1 while front < rear: mid = (front+rear)//2 flag = judge(mid) if flag: front = mid + 1 else: rear = mid print(front-1)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",876
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from collections import deque n, k = map(int,input().split()) s = input() def judge(needed): inf = 2147483647 minstate = [inf]*(1<<k) minstate[0] = 0 effect = [[inf]*(n+1) for j in range(k)] for j in range(k): accu = 0 index = inf for i in range(n)[::-1]: if s[i]==ord('?') or s[i]==97+j: accu += 1 else: accu = 0 if accu>=needed: index = i + needed effect[j][i] = index effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf) for state in range(1,1<<k): minimum = minstate[state] for j in range(k): if (1<<j) & state==0: continue index = minstate[state^(1<<j)] if index<n: minimum = min(minimum, effect[j][index]) minstate[state] = minimum if minstate[-1]<=n: return True return False front = 0 rear = n//k+1 while front < rear: mid = (front+rear)//2 flag = judge(mid) if flag: front = mid + 1 else: rear = mid print(front-1)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",902
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from collections import deque n, k = map(int,input().split()) s = input() def judge(needed): inf = 2147483647 minstate = [inf]*(1<<k) minstate[0] = 0 effect = [[inf]*(n+1) for j in range(k)] for j in range(k): accu = 0 index = inf for i in range(n)[::-1]: if s[i]==ord('?') or s[i]==97+j: accu += 1 else: accu = 0 if accu>=needed: index = i + needed effect[j][i] = index effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf*inf) for state in range(1,1<<k): minimum = minstate[state] for j in range(k): if (1<<j) & state==0: continue index = minstate[state^(1<<j)] if index<n: minimum = min(minimum, effect[j][index]) minstate[state] = minimum if minstate[-1]<=n: return True return False front = 0 rear = n//k+1 while front < rear: mid = (front+rear)//2 flag = judge(mid) if flag: front = mid + 1 else: rear = mid print(front-1)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",906
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from collections import deque n, k = map(int,input().split()) s = input() def judge(needed): inf = 2147483647 minstate = [inf]*(1<<k) minstate[0] = 0 effect = [[inf]*(n+1) for j in range(k)] for j in range(k): accu = 0 index = inf for i in range(n)[::-1]: if s[i]==ord('?') or s[i]==97+j: accu += 1 else: accu = 0 if accu>=needed: index = i + needed effect[j][i] = index effect[j][i] = min(effect[j][i],inf) for state in range(1,1<<k): minimum = minstate[state] for j in range(k): if (1<<j) & state==0: continue index = minstate[state^(1<<j)] if index<n: minimum = min(minimum, effect[j][index]) minstate[state] = minimum if minstate[-1]<=n: return True return False front = 0 rear = n//k+1 while front < rear: mid = (front+rear)//2 flag = judge(mid) if flag: front = mid + 1 else: rear = mid print(front-1)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",881
"import io,os input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline from collections import deque n, k = map(int,input().split()) s = input() def judge(needed): inf = 2147483647 minstate = [inf]*(1<<k) minstate[0] = 0 effect = [[inf]*(n+1) for j in range(k)] for j in range(k): accu = 0 index = inf for i in range(n)[::-1]: if s[i]==ord('?') or s[i]==97+j: accu += 1 else: accu = 0 if accu>=needed: index = i + needed effect[j][i] = index for state in range(1,1<<k): minimum = minstate[state] for j in range(k): if (1<<j) & state==0: continue index = minstate[state^(1<<j)] if index<n: minimum = min(minimum, effect[j][index]) minstate[state] = minimum if minstate[-1]<=n: return True return False front = 0 rear = n//k+1 while front < rear: mid = (front+rear)//2 flag = judge(mid) if flag: front = mid + 1 else: rear = mid print(front-1)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",844
"import sys;input = sys.stdin.readline;n, k = map(int, input().split());s = input()[:-1];left, right = 0, n while left < right: mid = right - (right - left) // 2;A = [[0] * (n + 2) for _ in range(k)] for c in range(k): A[c][n] = A[c][n + 1] = n + 1;L = 0 for i in range(n - 1, -1, -1):L = (L + 1 if s[i] == '?' or ord(s[i]) - ord('a') == c else 0);A[c][i] = i + mid if L >= mid else A[c][i + 1] dp = [n + 1] * (1 << k);dp[0] = 0 for mask in range(1 << k): for i in range(k): if mask >> k & 1: continue t = mask | 1 << i;dp[t] = min(dp[t], A[i][dp[mask]]) if dp[-1] <= n: left = mid else: right = mid - 1 print(left)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",614
"import sys int1 = lambda x: int(x)-1 p2D = lambda x: print(*x, sep=""\n"") def II(): return int(sys.stdin.readline()) def LI(): return list(map(int, sys.stdin.readline().split())) def LLI(rows_number): return [LI() for _ in range(rows_number)] def LI1(): return list(map(int1, sys.stdin.readline().split())) def LLI1(rows_number): return [LI1() for _ in range(rows_number)] def SI(): return sys.stdin.readline().rstrip() inf = 10**16 md = 10**9+7 n, k = LI() s = [-1 if c == ""?"" else ord(c)-97 for c in SI()] def ok(m): nxt = [[n]*(n+1) for _ in range(k)] for j in range(k): cnt = 0 ni = n nxtj = nxt[j] for i in range(n)[::-1]: if s[i] == -1 or s[i] == j: cnt += 1 else: cnt = 0 if cnt >= m: ni = i nxtj[i] = ni dp = [n+1]*(1 << k) dp[0] = 0 for bit in range(1 << k): l = dp[bit] if l+m > n: continue for j in range(k): if bit >> j & 1: continue i = nxt[j][l] if i+m <= n: nbit = bit | 1 << j dp[nbit] = min(dp[nbit], i+m) return dp[-1] <= n l, r = 0, n//k+1 while l+1 < r: m = (l+r)//2 if ok(m): l = m else: r = m print(l)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",1022
"N, K = list(map(int, input().split())) S = input().strip() S = [-1 if _ == '?' else ord(_) - ord('a') for _ in S] def check(x): p = [[N for i in range(N+1)] for k in range(K)] for k in range(K): keep = 0 for i in range(N-1, -1, -1): keep += 1 if S[i] != -1 and S[i] != k: keep = 0 p[k][i] = p[k][i+1] if keep >= x: p[k][i] = i + x - 1 d = [N for s in range(1<<K)] d [0] = -1 for s in range(1, 1<<K): for k in range(K): if (s&(1<<k)) and (d[s^(1<<k)]<N): d[s] = min(d[s], p[k][d[s^(1<<k)]+1]) return d[(1<<K)-1] < N l, r = 0, N//K while l < r: mid = (l + r + 1) // 2 if check(mid): l = mid else: r = mid - 1 print(l)",np,"['binary search', 'bitmasks', 'brute force', 'dp', 'strings', 'two pointers']",615
