code,complexity,tags,code_length
"from math import sqrt

a, v = map(int, input().split())
l, d, w = map(int, input().split())

def findt(u, v, a, dist):
	front = (v*v-u*u)/(2*a)
	if front > dist:
		return (sqrt(u*u+2*a*dist)-u)/a
	return (v-u)/a + (dist-front)/v

def solve(a, v, l, d, w):
	if v <= w or 2*a*d <= w*w:
		return findt(0, v, a, l)
	after = findt(w, v, a, l-d)
	peak = sqrt(a*d + w*w/2)
	if peak > v:
		travel = (v*v-w*w/2)/a
		before = (2*v-w)/a + (d-travel)/v
	else:
		before = (2*peak-w)/a
	return before + after

print(f'{solve(a, v, l, d, w):.8f}')",constant,"implementation,math",532
"from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)
",constant,"implementation,math",703
"""""""
#If FastIO not needed, use this and don't forget to strip
#import sys, math
#input = sys.stdin.readline
""""""

import os
import sys
from io import BytesIO, IOBase
import heapq as h 
from bisect import bisect_left, bisect_right
import time

from types import GeneratorType
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq, Counter as dc
import string
from math import sqrt

#start_time = time.time()

def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

def getMat(n):
    return [getInts() for _ in range(n)]

def isInt(s):
    return '0' <= s[0] <= '9'

MOD = 10**9 + 7 

""""""
S = U T + 0.5 A T^2
V^2 = U^2 + 2 A S
V = U + A T
S = V T - 0.5 A T^2

If V < W:
    linearly accelerate to V, then cruise to the end

If V >= W:
    If we can get to speed W in distance <= D:
        cruise to W, then reach the max speed such that we can still decelerate to W. Then post camera, accelerate to V and then cruise
    Else:
        linearly accelerate all the way to speed V, then cruise to the end

2*W*T + A * T^2 - 2*rem_dist = 0
""""""

def t_from_s_a_u(s,a,u):
    return (-2*u + sqrt(4*u*u + 8*s*a))/(2*a)
    

def solve():
    A, V = getInts()
    L, D, W = getInts()
    if V <= W or W**2 >= 2*A*D: # this renders W irrelevant
        #can we get to speed V before distance L?
        if V**2 >= 2*A*L:
            return sqrt(2*L/A)
        else:
            dist_1 = (V**2)/(2*A)
            T1 = 2*dist_1/V
            dist_2 = L - dist_1
            T2 = dist_2/V
            return T1+T2
    else:
        #V > W, and we reach W in time
        dist_1 = (W**2)/(2*A)
        T1 = sqrt(2*dist_1/A)
        rem_dist = D - dist_1
        dist_A = (V**2 - W**2)/(2*A)
        if 2*dist_A >= rem_dist:
            #accelerate then decelerate the whole time. Accelerate for rem_dist/2, decelerate for rem_dist/2
            TA = 2*t_from_s_a_u(rem_dist/2,A,W)
        else:
            TA1 = 2*(V-W)/A
            SA1 = (V+W)*(V-W)/A
            SA2 = rem_dist - SA1
            TA2 = SA2/V
            TA = TA1 + TA2
        T1 += TA
        #now we are at speed W again, so we accelerate to V and then cruise
        if V**2 - W**2 >= 2*A*(L-D):
            #accelerate linearly from W to V
            #print(T1,t_from_s_a_u(L-D,A,W))
            return T1 + t_from_s_a_u(L-D,A,W)
        else:
            dist_2 = (V**2 - W**2)/(2*A)
            T2 = 2*dist_2/(V+W)
            dist_3 = L - D - dist_2
            T3 = dist_3/V
            #print(T1,T2,T3)
            return T1+T2+T3
    return
    
#for _ in range(getInt()):
print(solve())
#solve()


#print(time.time()-start_time)",constant,"implementation,math",4495
"from math import *
a, vm = map(int, input().split())
l, d, vd = map(int, input().split())
if vm <= vd or sqrt(2 * a * d) <= vd:
    if vm ** 2 / (2 * a) >= l:
        ans = sqrt(2 * l / a)
    else:
        ans = vm / a + (l - vm ** 2 / (2 * a)) / vm
else:
    s1 = (vm ** 2 - vd ** 2) / (2 * a)
    if s1 >= (l - d):
        ans = (sqrt(4 * (vd ** 2) + 8 * a * (l - d)) - 2 * vd) / (2 * a)
    else:
        ans = (vm - vd) / a + (l - d - s1) / vm
    v1 = sqrt((2 * a * d + vd ** 2) / 2)
    if v1 <= vm:
        ans = ans + v1 / a + (v1 - vd) / a
    else:
        s1 = d - (vm ** 2 - vd ** 2) / (2 * a) - (vm ** 2) / (2 * a)
        ans = ans + vm / a + (vm - vd) / a + s1 / vm
print('%.12f' % ans)",constant,"implementation,math",702
"from math import *
a,v=list(map(int,input().split()))
l,d,w=list(map(int,input().split()))
if v>w:
    s1=w**2/2/a
    if d<=s1:
        s=min(v**2/2/a,l)
        t=sqrt(2*s/a)+(l-s)/v
    else:
        t=sqrt(2*s1/a)
        s2=min((d-s1)/2,(v**2-w**2)/(2*a))
        if s2==(d-s1)/2:
            t+=2*(sqrt(2*(s1+s2)/a)-sqrt(2*s1/a))
        else:
            t+=2*(v-w)/a+(d-s1-2*s2)/v
        s3=min((v**2-w**2)/2/a,l-d)
        t+=sqrt(2*(s3+s1)/a)-sqrt(2*s1/a)+(l-d-s3)/v
else:
    s=min(v**2/2/a,l)
    t=sqrt(2*s/a)+(l-s)/v
print(t)",constant,"implementation,math",540
"'''
Jana Goodman

5d follow traffic rules

accel formulas:
    t = (v1 - v0) / a
    d = (v1 - v0)t / 2
    v = sqr (2ad)

no accel: d = vt -- t = d / v -- v = d / t

'''
import math

SPACE = ' '


def get_data(file_name):
    result = list()
    state = 0
    data = list()
    # [a, v, l, d, w, answer]
    try:
        for line in open(file_name, 'r').readlines():
            line = line.strip()
            if state == 0:
                if line == 'Input':
                    data = list()
                    state = 1
                elif line == 'Answer':
                    state = 2
            elif state == 1:
                data += list(map(int, line.split(SPACE)))
                state = 11
            elif state == 11:
                data += list(map(int, line.split(SPACE)))
                state = 0
            elif state == 2:
                data.append(float(line))
                result.append(data)
                state = 0
    except FileNotFoundError:
        print(f'File {file_name} not found.')
    return result


# no accel: d = vt -- t = d / v -- v = d / t

def time(d=None, v=None, v0=0, steady=False):
    if steady:
        return d / v

    if d is None:
        # time to accelerate v0 to v
        return (v - v0) / ACCEL

    # time to go distance d while accelerating from v0
    if v is None:
        v = vel(d=d, v0=v0)
    return (2 * d) / (v + v0)


def dist(t=None, v=None, v0=0, steady=False):
    if steady:
        return v * t

    if t is None:
        # distance to accelerate v0 to v
        return (pow(v, 2) - pow(v0, 2)) / (2 * ACCEL)

    # distance to accelerate for time t
    return (1 / 2) * (v + v0) * t


def vel(d=None, t=None, v0=0, steady=False):
    if steady:
        return d / t

    if d is None:
        # velocity after accelerating from v0 for time t
        return t * ACCEL - v0

    # velocity after going distance d accelerating from v0
    return pow(2 * d * ACCEL + v0 ** 2, 1 / 2)

def can_ignore_sign(v, w, d):
    return v <= w or d <= dist(v=w)


def ignore_sign(v, w, l):
    dmax = dist(v=v)
    if l <= dmax:
        return time(d=l)
    return time(v=v) + time(d=l - dmax, v=v, steady=True)


def get_time(a, v, l, d, w):
    global ACCEL
    ACCEL = a

    if can_ignore_sign(v, w, d):
        return ignore_sign(v, w, l)

    # go to the sign
    tmax, dmax = time(v=v), dist(v=v)
    tlim_max, dlim_max = time(v=v, v0=w), dist(v=v, v0=w)
    if dmax + dlim_max <= d:
        #  0 <<< lim <<< max === sign <<< dlim_max
        #  0 <<<dlim === dmax=== sign <<< dlim_max
        res = tmax + time(d=d - dmax - dlim_max, v=v, steady=True) + tlim_max
    else:
        #  0 <<<dlim ... dmax=== sign <<< dlim_max
        res = time(v=w) + time(v=vel(d=(d - dist(v=w)) / 2, v0=w), v0=w) * 2

    # go from sign to end of the road
    x = d + dist(v=v) - dist(v=w)
    if x >= l:
        # reach end of the road before getting to top speed
        res += time(d=l - d, v0=w)
        return res
    return res + time(v=v, v0=w) + time(d=l - x, v=v, steady=True)


if __name__ == '__main__':
    a, v = map(int, input().split())
    l, d, w = map(int, input().split())
    print(get_time(a, v, l, d, w))

# --------- testing
    # cases = get_data('testdata.txt')
    # for i, [a, v, l, d, w, ans] in enumerate(cases, 1):
    #     if a == 6 and v == 80:
    #         debug = 1
    #     my_ans = get_time(a, v, l, d, w)
    #     if abs(my_ans - ans) >= pow(10, -6):
    #         print(f'Case {i} My answer: {my_ans} -- Right answer: {ans}')
    #     else:
    #         print(f'Case {i} OK')
",constant,"implementation,math",3586
"import math
def getdt():
    return map(int, input().split())
def calc(v0, v, a, x):
    t = (v - v0) / a
    x0 = v0 * t + 0.5 * a * t * t
    if x0 >= x:
        return (x, (math.sqrt(v0 * v0 + 2 * a * x) - v0) / a)
    return (x0, t)
def go(v0, v, a, x):
    x0, t = calc(v0, v, a, x)
    return t + (x - x0) / v
a, v = getdt()
l, d, w = getdt()
if w > v:
    w = v
x, t = calc(0, w, a, d)
if x == d:
    print(go(0, v, a, l))
else:
    print(t + go(w, v, a, (d - x) * 0.5) * 2 + go(w, v, a, l - d))
",constant,"implementation,math",503
"import math
def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v
a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))
",constant,"implementation,math",438
"a, v = list(map(int, input().split("" "")))
l, d, w = list(map(int, input().split("" "")))
 
if(v <= w or w * w > 2 * a * d):
    if(v * v > 2 * a * l):
        print((2 * l / a) ** 0.5)
    else:
        print(l / v + v / 2 / a)
else:
    u = (w * w / 2 + a * d) ** 0.5
    if(u > v):
        m =  v / a + (v - w) / a + (d - (v * v / 2 / a) - (v * v - w * w) / 2 / a) / v
    else:
        m = (2 * u - w) / a
        
    if(v * v > 2 * a * (l - d + w * w / 2 / a)):
        print(m - w / a + (2 * (l - d + (w * w / 2 / a)) / a) ** 0.5)
    else:
        print(m - w / a + (l - d + w * w / 2 / a) / v + v / 2 / a)",constant,"implementation,math",611
"import decimal
decimal.getcontext().prec = 100

a, v = map(decimal.Decimal, input().split())
l, d, w = map(decimal.Decimal, input().split())

def DecimalPow(a, b):
    return decimal.Decimal(a) ** decimal.Decimal(b)

def getLastT(v1, dist):
    t1 = (v - v1) / a
    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)
    if d1 >= dist:
        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a
    t2 = (dist - d1) / v
    return t1 + t2

if w >= v:
    t1 = v / a
    if decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2)) <= l:
        t2 = (l - decimal.Decimal(0.5) * a * (t1 ** decimal.Decimal(2))) / v
    else:
        t1 = (decimal.Decimal(2) * l / a) ** decimal.Decimal(0.5)
        t2 = 0
    t = t1 + t2
    print('{t:.5f}'.format(t = t))

elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)
    t1 = w / a + t2
    t3 = getLastT(w, l - d)
    t = t1 + t2 + t3
    print('{t:.5f}'.format(t = t))

else:
    t1 = v / a
    t3 = (v - w) / a
    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v
    t4 = getLastT(w, l - d)
    t = t1 + t2 + t3 + t4
    print('{t:.5f}'.format(t = t))",constant,"implementation,math",1558
"import decimal
decimal.getcontext().prec = 100

a, v = map(decimal.Decimal, input().split())
l, d, w = map(decimal.Decimal, input().split())

def DecimalPow(a, b):
    return decimal.Decimal(a) ** decimal.Decimal(b)

def getLastT(v1, dist):
    t1 = (v - v1) / a
    d1 = v1 * t1 + decimal.Decimal(0.5) * a * DecimalPow(t1, 2)
    if d1 >= dist:
        return (-v1 + (v1 ** decimal.Decimal(2) + 2 * a * dist) ** decimal.Decimal(0.5)) / a
    t2 = (dist - d1) / v
    return t1 + t2

if w >= v:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))


elif (w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t = getLastT(0, l)
    print('{t:.5f}'.format(t = t))

elif (v ** decimal.Decimal(2) - 0) / (2 * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a) >= d:
    t2 = -w / a + ((w ** decimal.Decimal(2)) / (2 * (a ** decimal.Decimal(2))) + d / a) ** decimal.Decimal(0.5)
    t1 = w / a + t2
    t3 = getLastT(w, l - d)
    t = t1 + t2 + t3
    print('{t:.5f}'.format(t = t))

else:
    t1 = v / a
    t3 = (v - w) / a
    t2 = (d - ((v ** decimal.Decimal(2) - 0) / (decimal.Decimal(2) * a) + (v ** decimal.Decimal(2) - w ** decimal.Decimal(2)) / (decimal.Decimal(2) * a))) / v
    t4 = getLastT(w, l - d)
    t = t1 + t2 + t3 + t4
    print('{t:.5f}'.format(t = t))",constant,"implementation,math",1316
"""""""
Codeforces
5D - Follow Traffic Rules
http://codeforces.com/contest/5/problem/D

Héctor González Belver
../07/2018
""""""
import sys

def time_distance(v0, a, d):
  #quadratic equation. Time is positive ==> root with (+discriminant) in quadratic formula
  #d = v0*t + (a/2)*t^2
  return (-v0 + (v0**2 + 2*a*d)**0.5)/a

def time_accelerating(v0, v1, a):
  return (v1 - v0)/a

def time_speed(v, d):
  return d/v

def distance_travelled(v0, t, a):
  return v0*t + (a/2)*t**2
  
def main():
  a, v = map(int,sys.stdin.readline().strip().split())
  l, d, w = map(int,sys.stdin.readline().strip().split())

  time = 0

  time_to_d = time_distance(0, a, d)
  time_to_v = time_accelerating(0, v, a)

  if (v if time_to_v <= time_to_d else time_to_d * a) <= w:
    #Accelerating 0-v
    acceleration_time = time_to_v
    acceleration_distance = distance_travelled(0, acceleration_time, a)

    if acceleration_distance >= l:
      #Accelerating 0-?
      time = time_distance(0, a, l)
    else:
      #Accelerating 0-v
      time = acceleration_time
      #Max speed v
      time += time_speed(v, l - acceleration_distance)

  else:      
    if time_to_v <= time_to_d:
      #Accelerating 0-v
      acceleration_time = time_to_v
      acceleration_distance = distance_travelled(0, acceleration_time, a)

      #Decelerating v-w
      deceleration_time = time_accelerating(v, w, -a)
      deceleration_distance = distance_travelled(v, deceleration_time, -a)
    
    if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:
      #Accelerating 0-w
      acceleration_time = time_accelerating(0, w, a)
      acceleration_distance = distance_travelled(0, acceleration_time, a)
      
      remaining_distance = d - acceleration_distance
      #Remaining distance --> Acceleration = -Deceleration ==> half remaining distance each action 
      delta_time = time_distance(w, a, remaining_distance/2)
      #Accelerating 0-? and Decelerating ?-w
      time = acceleration_time + 2*delta_time
    else:
      #Accelerating 0-v
      time = time_to_v
      #Max speed v
      time += time_speed(v, d - deceleration_distance - acceleration_distance)
      #Decelerating v-w
      time += deceleration_time
      
    #Accelerating w-v
    acceleration_time = time_accelerating(w, v, a)
    acceleration_distance = distance_travelled(w, acceleration_time, a)
    if acceleration_distance >= l - d:
      #Accelerating w-?
      time += time_distance(w, a, l - d)
    else:
      #Accelerating w-v
      time += acceleration_time
      #Max speed v
      time += time_speed(v, l - (d + acceleration_distance))
  
  sys.stdout.write('{0:.5f}'.format(time) + '\n')

if __name__ == '__main__': 
  main()",constant,"implementation,math",2703
"a,v=map(int,input().split())

l,d,w=map(int,input().split())

t=0

def gett(a,b,c):

    delta=b**2-4*a*c

    t1=(-b+delta**(1/2))/(2*a)

    t2=(-b-delta**(1/2))/(2*a)

    if min(t1,t2)>0:

        return min(t1,t2)

    else:

        return max(t1,t2)

if 2*a*d<=w*w or v<=w:

    if 2*a*l<=v*v:

        t=(2*l/a)**(1/2)

    else:

        t=l/v+v/a/2

else:

    tmp=d-1/2*v*v/a+1/2*(v-w)**2/a-v*(v-w)/a

    if tmp<=0:

        tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a)

        if tmp2>=0:

            t=tmp2/v+(v-w)/a+2*gett(a,2*w,w*w/(2*a)-d)+w/a

        else:

            t=gett(a/2,w,d-l)+2*gett(a,2*w,w*w/(2*a)-d)+w/a

    else:

        tmp2=l-d-(1/2*(v-w)**2/a+w*(v-w)/a)

        if tmp2>=0:

            t=tmp2/v+(v-w)/a+(2*v-w)/a+tmp/v

        else:

            t=gett(a/2,w,d-l)+(2*v-w)/a+tmp/v

print(""%.12f"" %(t))



# Made By Mostafa_Khaled",constant,"implementation,math",863
"import math

def getdt():
    return map(int,input().split())
def calc(v0,v,a,x):
    t = (v - v0)/a
    x0 = v0 * t + 0.5*a*t*t
    if x0>=x:
        return (x,(math.sqrt(v0*v0 + 2*a*x)-v0)/a)
    return (x0,t)
def go(v0,v,a,x):
    x0,t = calc(v0,v,a,x)
    return t + (x-x0)/v

a,v = getdt()
l,d,w = getdt()
if w>v:
    w = v
x,t = calc(0,w,a,d)
if x==d:
    print(go(0,v,a,l))
else:
    print(t+go(w,v,a,(d-x)*0.5) * 2 + go(w,v,a,l-d))",constant,"implementation,math",439
"
def func(u,v,a,l):
    if (v**2-u**2)>=2*a*l:
        return ((u**2+2*a*l)**(1/2)-u)/a
    else:
        t1=(v-u)/a
        t2=(l-(u*t1+a*t1*t1/2))/v
        return t1+t2
def efficient(v,a,w,d):
    if 2*v*v-w*w<=2*a*d:
        t1=v/a
        t2=(v-w)/a
        t3=(d-0.5*a*t1*t1-v*t2+0.5*a*t2*t2)/v
        return t1+t2+t3
    else:
        bound=((2*a*d+w*w)/2)**0.5
        t1=bound/a
        t2=(bound-w)/a
        t3=func(0,w,a,d)
        return t1+t2
        return min(t1+t2,t3)
def main():
    string1=input()
    string2=input()
    arr1=string1.split("" "")
    arr2=string2.split("" "")
    a=int(arr1[0])
    v=int(arr1[1])
    l=int(arr2[0])
    d=int(arr2[1])
    w=int(arr2[2])
    if 2*a*d<=w**2 or v<=w:
        t1=func(0,v,a,l)
        print(""%.8f""%(t1))
    else:
        t1=efficient(v,a,w,d)
        t2=func(w,v,a,l-d)
        print(""%.8f""%(t1+t2))
main()
",constant,"implementation,math",874
"from math import sqrt

a, v = map(int, input().split())
l, d, w = map(int, input().split())
w = min(v, w)
lowtime = (v - w) / a
lowdist = v * lowtime - a * lowtime**2 / 2
startdist = v**2 / (2 * a)
if startdist + lowdist <= d:
    ans = v / a + (d - startdist - lowdist) / v + lowtime
elif w**2 <= 2 * d * a:
    u = sqrt(a * d + w**2 / 2)
    ans = (2 * u - w) / a
else:
    ans = sqrt(2 * d / a)
    w = ans * a
hightime = (v - w) / a
highdist = w * hightime + a * hightime**2 / 2
if highdist <= l - d:
    ans += hightime + (l - d - highdist) / v
else:
    disc = sqrt(w**2 + 2 * a * (l - d))
    ans += (disc - w) / a
print('%.7f' % ans)
",constant,"implementation,math",642
"from math import sqrt


def dist(speed, time):
	"""""" 
	Calculates the distance will be covered in specified time, 
	if car's current speed is speed. 
	This function will not take car's speed limit into account. 
	Also it assumes, that car is always driven with maximum acceleration a
	""""""
	return speed * time + a * time**2 / 2


def travelTime(distance, speed):
	""""""
	Calculates the time, required to travel specified distance, 
	if car have starting speed equal to speed. 
	This function will also take care about car's speed limit.
	""""""
	tAll = (- speed + sqrt(speed**2 + 2 * distance * a)) / a

	tMax = (v - speed) / a

	if tMax >= tAll:
		return tAll
	else:
		return tMax + (distance - dist(speed, tMax)) / v


a, v = map(int, input().split())
l, d, w = map(int, input().split())

if v <= w:
	print(travelTime(l, 0))
else:
	tw = w / a  # time to gain speed w

	dw = dist(0, tw)

	if dw >= d:
		print(travelTime(l, 0))
	else:
		print(tw + 2 * travelTime((d - dw) / 2, w) + travelTime(l - d, w))
",constant,"implementation,math",998
"
def f(n):
    return n + n//2
        
        
n = int(input())
print(f(n))
",constant,"math,number theory",78
"n = int(input())
print(3*(n//2))",constant,"math,number theory",32
"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split()) 
def get_list(): return list(map(int, sys.stdin.readline().strip().split())) 


n=iinput()
print(3*n//2)",constant,"math,number theory",274
"x= int(input(""""))
print(int((x/2)*3))",constant,"math,number theory",37
"a = int(input())
print((a // 2) * 3)",constant,"math,number theory",36
"n = int(input())
print(3*n//2)",constant,"math,number theory",30
"n = int(input())
print(n//2+n)",constant,"math,number theory",30
"n=int(input())
g=n//2
print(g+n)",constant,"math,number theory",32
"n=int(input())
print(n+(n//2))",constant,"math,number theory",30
"# Codeforces A. Toy Army
# Created by Abdulrahman Elsayed on 15/01/2021

n = int(input())
print(int(3 * n / 2))",constant,"math,number theory",111
"n = int(input())
print(int(3 * n / 2))",constant,"math,number theory",38
"n=int(input())
a=(n//2)*3
print(a)",constant,"math,number theory",34
"if __name__ == '__main__':
	n = int(input())
	num = n + n//2
	print(num)",constant,"math,number theory",72
"n = int(input())
print(n + n // 2)",constant,"math,number theory",34
"n = int(input())
print((n*3)//2)",constant,"math,number theory",32
"n = int(input())
n = n + n//2

print(n)",constant,"math,number theory",39
print(int(input())//2*3),constant,"math,number theory",24
"i = int(input())
print(int(i/2) * 3)",constant,"math,number theory",36
"def luck(n):
    if n % 4 == 0 or n % 7 == 0:
        return True
    while n > 0:
        tmp = n % 10
        n = int(n / 10)
        if tmp != 4 and tmp != 7:
            return False

    return True


def lucky(n):
    if luck(n):
        return ""YES""

    for x in range(1, n + 1):
        if n % x == 0 and luck(x):
            return ""YES""

    return ""NO""


n = int(input())

print(lucky(n))",constant,"brute force,number theory",400
"# -*- coding: utf-8 -*-

n = int(input())

lucky = [""1"",""2"",""3"",""5"",""6"",""8"",""9"",""0""]


ye = False
for i in range(1,n+1):
    luck=True
    for char in str(i):
        if char in lucky:
            luck = False
            break
            
    if luck == True and n % i == 0:
        print(""YES"")
        ye = True
        break
    else:
        continue
if ye != True:
    print(""NO"")",constant,"brute force,number theory",387
"n = int(input())
m = ''.join(set(list(str(n))))
if m == '47' or m == '74' or m == '4' or m == '7':
  print('YES')
else:
  if n %4 == 0 or n %7== 0 or n %74== 0 or n %47== 0:
    print('YES')
  else:
    print(""NO"")",constant,"brute force,number theory",214
"def check(num):
    l = list(str(num))
    l = list(dict.fromkeys(l))
    if l==['4', '7'] or l==['7', '4'] or l==['4'] or l==['7']: return True
    else: return False

lucky = False
n = int(input())
for i in range(3, n+1):
    if n%i==0 and check(i): lucky=True
print(""YES"" if lucky else ""NO"")",constant,"brute force,number theory",294
"details=[4,7,44,77,444,777,47,74,447,774,474,747,477]
n=int(input())
f=0
for i in details:
    if n%i==0:
        f=1 
        break 
if f:
    print(""YES"")
else:
    print(""NO"")",constant,"brute force,number theory",178
"n = int(input())
print([""YES"", ""NO""][all(n % i for i in [4, 7, 47, 744, 477])])",constant,"brute force,number theory",79
"n=int(input())
l=[4,7,47,74,44,77,447,444,474,777,747,744,477]
c=0
for i in range(len(l)):
    if n%l[i]==0:
        c=1
        break
if c==1:
    print(""YES"")
else:
    print(""NO"")
",constant,"brute force,number theory",183
"n = int(input())
l = [4,7,47,74,444,447,474,477,747,744,774,777]

for i in l:
    if n % i == 0:
        print('YES')
        break
    else:
        pass
else:
    print('NO')
    
        



            
",constant,"brute force,number theory",207
"import math
def islucky(x):
    digits = set(list(str(x)))
    return (len(digits) == 2 and (""4"" in digits and ""7"" in digits)) or (len(digits) == 1 and (""4"" in digits or ""7"" in digits))
a = int(input())
lucky = islucky(a)
for i in range(2, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        #print(i, a / i)
        if islucky(i) or islucky(a // i):
            lucky = True
            break

print(""YES"" if lucky else ""NO"")",constant,"brute force,number theory",429
"a=int(input())
b=str(a)
c=[]
for i in range(2,a+1):
    if(a%i==0):
        c.append(i)

l=0
for j in c:
    r=str(j)
    t=len(r)
    o=0
    for p in r:
        if(p==""4"" or p==""7""):
            o=o+1
    if(o==t):
        l=l+1
if(l>0):
    print(""YES"")
else:
    print(""NO"")

            
    
",constant,"brute force,number theory",298
"n = int(input())
k = set(""47"")
p = False
for i in range(1, n+1):
    if n%i == 0:
        if set(str(i)) <= k:
            p = bool(set(str(i)))
            break       
if p == True:
    print(""YES"")
else:
    print(""NO"") ",constant,"brute force,number theory",223
"n=int(input())
s=[4,7,44,77,47,74,444,777,477,447,744,474,747,774]
t=0
for i in s:
    if n%i==0:
        print(""YES"")
        t=1
        break
if t==0:
    print(""NO"")
    
    ",constant,"brute force,number theory",179
"import math
def lucky(x):
    return (list(set(list(str(x)))) in [[""4""],[""7""],[""4"",""7""],[""7"",""4""]])
a = int(input())
true = False
for i in range(1, math.ceil(math.sqrt(a))+1):
    if a % i == 0:
        if lucky(i) or lucky(a//i):
            true = True
            break
print(""YES"" if true else ""NO"")",constant,"brute force,number theory",303
"n=int(input())
c=0
lst=[4,7,47,74,447,474,744,477,747,774]
if n in lst:
    print(""YES"")
else:
    for i in lst:
        if n%i==0:
            print(""YES"")
            c=c+1
            break
        else:
            continue
    if c==0:
        print(""NO"")
    
",constant,"brute force,number theory",266
"import itertools

def q121a_v2():
	good_num_arr = generate_47_arr()
	num = int(input())
	for element in good_num_arr:
		if(num % element == 0):
			print(""YES"")
			return
	print(""NO"")


def generate_47_arr():
	arr = []
	for digits in range(1, 4):
		arr += itertools.product(""47"", repeat=digits)
	for i in range(len(arr)):
		arr[i] = int("""".join(list(arr[i])))
	arr.append(4444444444)
	return arr

q121a_v2()",constant,"brute force,number theory",406
"def luckynumber(n):
    a=[]
    for i in range(4,n+1):
        r=i
        c=0
        while(r>0):
            x=r%10
            if x!=4 and x!=7:
                c=1
                break
            r=r//10
        if c==0:
            a.append(i)
    return a
n=int(input())
a=luckynumber(n)
for i in a:
    if n==i or n%i==0:
        print(""YES"")
        break
else:
    print(""NO"")

",constant,"brute force,number theory",390
"s=int(input())
t=len(str(s))
L=['4','7']
import copy
for i in range(t):
    L1=copy.deepcopy(L)
    for m in L:
        L1.append(m+'4')
        L1.append(m+'7')
    L=L1
L0=list(map(int,L))
sum=0
for i in range(len(L0)):
    if s%L0[i]==0:
        sum=sum+1
if sum>0:
    print('YES')
else:
    print('NO')",constant,"brute force,number theory",307
"n=int(input())
li=[]
for i in range(1,n+1):
    if n%i==0:
        li.append(i)
p=0
for t in li:
    l=[m for m in str(t)]
    if set(l)=={'4'} or set(l)=={'7'} or set(l)=={'4','7'}:
        p+=1
if p>0:
    print('YES')
else:
    print('NO')",constant,"brute force,number theory",242
"s=int(input())
u=True
for i in [4,7,47,74,447,474,477,747,774]:
    if s%i==0:
        u=False
        print(""YES"")
        break
if u:
    print(""NO"")


        
        
            
    

    
    
",constant,"brute force,number theory",201
"n = int(input())

print('0','0',n)
",constant,"brute force,constructive algorithms,implementation,number theory",35
"n = int(input())
f0= 0
f1 = 1
li = [0,1]
for i in range(45):
	t = f1
	f1 += f0
	f0 = t
	li.append(f1)
x = []
for i in range(3):
	for i in range(len(li)-1, -1, -1):
		if li[i] <= n:
			n -= li[i]
			x.append(li[i])
			break
if n == 0:
	print(*x, sep = "" "")
else:
	print(""I'm too stupid to solve this problem"")
",constant,"brute force,constructive algorithms,implementation,number theory",309
"# def fibonacci(n):
#     flist = []
#     a = 0
#     b = 1
#     flist.append(a)
#     flist.append(b)
#
#     for i in range(2,n):
#         c = a + b
#         a = b
#         b = c
#         if b<n:
#             flist.append(b)
#         else:
#             flist.append(b)
#             break
#     return flist
#
# def twopinter(li,i,x):
#     z = 0
#     while i<=len(li):
#         if li[i]+li[len(li)-z]==x:
#             print(li[i], li[len(li)-z])
#             return li[i]+li[len(li)-z]
#         elif li[i]+li[len(li)-z] < x:
#             i+=1
#         elif li[i]+li[len(li)-z] > x:
#             z+=1
#         else:
#             return 0
#
#
# def threepointer(li,n):
#     st = 0
#     s = li[st]
#     while st<=len(li):
#         x = (n-s[st])
#         if s[st]+twopinter(li,st,x) == n:
#             print(s[st])
#             print(""Done"")
#         elif s[st]+twopinter(li,st,x) < n:
#             st+=1
#         else:
#             return False
#
#
#
#
#
#
#
# n = int(input())
# li = fibonacci(n)
# print(li)
#
# if threepointer(li,n) ==  False:
#     print(""I'm too stupid to solve this problem"")
# else:
#     print("""")
#
#
#

n = int(input())
print(0, 0, n)",constant,"brute force,constructive algorithms,implementation,number theory",1191
"# def fibo(n):
#     if n==0:
#         return 0
#     elif n==1:
#         return 1
#     else:
#         return fibo(n-1)+fibo(n-2)
#
# n = int(input())
#
# if n>3:
#     print(fibo(n-1),fibo(n-3),fibo(n-4))

a = [0,1]
n = int(input())
i=2
r=0
while r<n:
     r = a[i-1]+a[i-2]
     a.append(r)
     i+=1
l = len(a)-1
if n>3:
    print(a[l-4],a[l-3],a[l-1])
elif n==3:
    print(1,1,1)
elif n==2:
    print(0,1,1)
elif n==1:
    print(0,0,1)
elif n==0:
    print(0,0,0)",constant,"brute force,constructive algorithms,implementation,number theory",471
"import sys,os,io,time,copy
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

import math

def main():
    # start=time.time()
    n=int(input())
    print(0,0,n)

    # end=time.time()
main()",constant,"brute force,constructive algorithms,implementation,number theory",254
"x = int(input())
print(0,0,x)",constant,"brute force,constructive algorithms,implementation,number theory",29
"n = int(input())
print(""0 0 {}"".format(n))
",constant,"brute force,constructive algorithms,implementation,number theory",43
"n = int(input())

print(0, 0, n)
",constant,"brute force,constructive algorithms,implementation,number theory",33
"print(0, 0, input())
",constant,"brute force,constructive algorithms,implementation,number theory",21
"fib = [0]*100
fib[1] = 1
for i in range(2, 100):
    fib[i] = fib[i-1] + fib[i-2]
# ans = [fib[0], fib[1], fib[2]]
# i = 3
# j = 0
n = int(input())
# print(fib)
# ok = False
if (n in fib):
    if (n == 0):
        print(0, 0, 0)
    elif (n == 1):
        print(0, 0, 1)
    else:
        print(0, fib[fib.index(n)-2], fib[fib.index(n)-1])
else:
    print(""I'm too stupid to solve this problem"")
# while True:
#     if (sum(ans) == n):
#         ok = True
#         break
#     else:
#         if (j == 1):
#             j = 0
#         ans[j] = fib[i]
#         print(i)
#         j += 1
#         i += 1
# if (ok):
#     print(*ans)
# else:
#     print(""I'm too stupid to solve this problem"")",constant,"brute force,constructive algorithms,implementation,number theory",694
"n = int(input())
if n==0:
    print(*[0,0,0])
elif n==1:
    print(*[0,0,1])
else:
    prev2 = 0
    prev1 = 1
    prev = 1
    while prev!=n:
        curr = prev+prev1
        prev2 = prev1
        prev1 = prev
        prev = curr
    print(*[0,prev2,prev1])
",constant,"brute force,constructive algorithms,implementation,number theory",260
"
n = int(input())
fib = [0,1]

for x in range(1,200):


    z = fib[x] + fib[x-1]
    if z <= n:

        fib.append(z)
    else:
        break

fib = fib[::-1]
lis = []
for y in range(len(fib)):

    if fib[y] <= n:
        if (sum(lis) + fib[y]) <= n:
            if len(lis) < 3:
                lis.append(fib[y])
if sum(lis) == n:
    if len(lis) == 1:
        lis.append(0)
        lis.append(0)
        print(*lis)
    elif len(lis) == 2:
        lis.append(0)
        print(*lis)
    else:
        print(*lis)
else:
    print(""I'm too stupid to solve this problem"")


",constant,"brute force,constructive algorithms,implementation,number theory",576
"n=int(input())
print(""0"",""0"",n)",constant,"brute force,constructive algorithms,implementation,number theory",31
"import sys,math
from collections import deque,defaultdict
import operator as op
from functools import reduce

#sys.setrecursionlimit(10**6) 

I=sys.stdin.readline

 #s=""abcdefghijklmnopqrstuvwxyz""

""""""
x_move=[-1,0,1,0,-1,1,1,-1]
y_move=[0,1,0,-1,1,1,-1,-1]
""""""
def ii():
	return int(I().strip())
def li():
	return list(map(int,I().strip().split()))
def mi():
	return map(int,I().strip().split())

""""""def ncr(n, r):
    r = min(r, n-r)
    numer = (reduce(op.mul, range(n, n-r, -1), 1))%(10**9+7)
    denom = (reduce(op.mul, range(1, r+1), 1))%(10**9+7)
    return (numer // denom)%(10**9+7)""""""
def ncr(n, r, p):
    # initialize numerator
    # and denominator
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, 
            p - 2, p)) % p
 

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def valid(row,col,rows,cols,rcross,lcross):
 	return rows[row]==0 and cols[col]==0 and rcross[col+row]==0 and lcross[col-row]==0


def div(n):
	tmp=[]
	for i in range(2,int(n**.5)+1):
		if n%i==0:
			cnt=0
			while(n%i==0):
				n=n//i 
				cnt+=1
			tmp.append((i,cnt))
	if n>1:
		tmp.append((n,1))
	return tmp

def isPrime(n):
	if n<=1:
		return False
	elif n<=2:
		return True
	else:
		flag=True
		for i in range(2,int(n**.5)+1):
			if n%i==0:
				flag=False
				break
		return flag

def s(b):
	ans=[]
	while b>0:
		tmp=b%10
		ans.append(tmp)
		b=b//10
	return ans


def main():
	n=ii()
	print(n,0,0)









	



	
		




	










	


	

	

		



		

		
		


	
	

		
	

		




		




			












			
		
			



		


	
			
						
			








	





			
		



	
			





	

























	
	
	





if __name__ == '__main__':
	main()",constant,"brute force,constructive algorithms,implementation,number theory",1746
"n = int(input())
if n == 0:
    print(0, 0, 0)
else:
    a, b = 0, 1
    while a + b != n:
        a, b = b, a + b
    print(0, a, b)",constant,"brute force,constructive algorithms,implementation,number theory",133
"ser = [0, 1]
def fib(n):
    i = 1
    while i < n:
        ser.append(i)
        i = ser[-1] + ser[-2]
    if i != n:
        return -1
    else:
        return len(ser)

n = int(input())
a, b, c = 0, 0, 0
ans = 1
if n == 0:
    ans = 1
elif n == 1:
    a = 1
elif n == 2:
    a = 1
    b = 1
elif n == 3:
    a = 1
    b = 1
    c = 1
else:
    ans = fib(n)
    if ans != -1:
        a = ser[ans-2]
        b = ser[ans-2]
        c = ser[ans-3]
if ans != -1:
    print(a, b, c)
else:
    print(""I'm too stupid to solve this problem"")
    ",constant,"brute force,constructive algorithms,implementation,number theory",540
"n = int(input())
print(n, 0, 0)",constant,"brute force,constructive algorithms,implementation,number theory",31
"n=int(input())

if n<=2:
    print(n)
else:
    if n%2!=0:
        print(n*(n-1)*(n-2))
    elif n%3==0:
        print((n-1)*(n-2)*(n-3))
    else:
        print(n*(n-1)*(n-3))",constant,number theory,176
"n = int(input())
print(n if n < 3 else ((n - 1) * (n * (n - 2) if n & 1 else (n - 3) * (n if n % 3 else n - 2))))",constant,number theory,113
"n=int(input())
if(n<3):
    print(n)
else:

    if(n%2!=0):
        print(n*(n-1)*(n-2))
    elif(n%3==0):
        print((n-1)*(n-2)*(n-3))
    else:
        print(n*(n-1)*(n-3))",constant,number theory,178
"def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)

if __name__ == ""__main__"":
    n = int(input())
    ans = 0
    if n==1:
        ans = 1
    elif n==2:
        ans = 2
    else:
        if n%2!=0:
            ans = n*(n-1)*(n-2)
        else:
            if gcd(n,(n-3)) ==1:
                ans = n*(n-1)*(n-3)
            else:
                ans = (n-1)*(n-2)*(n-3)
    print(ans)",constant,number theory,417
"n=int(input())
if n<3:
    print(n)
else:
    if n%2!=0:
        print(n*(n-1)*(n-2))
    else:
        if n==6:
            print(60)
        elif n%3==0:
            print((n-1)*(n-2)*(n-3))
        else:
            print(n*(n-1)*(n-3))
",constant,number theory,240
"# -*- coding: utf-8 -*-
""""""
Created on Tue Dec 15 23:11:30 2020

LCM Challenge

@author --> yashodeep
@Link --> https://codeforces.com/problemset/problem/235/A
@status --> Accepted in first attempt
""""""
n = int(input())
ans = 1
if n == 1:
    ans = 1
elif n == 2:
    ans = 2
elif n == 3:
    ans = 6
elif n%2 == 0:
    if n%3 == 0:
        ans = (n-1)*(n-2)*(n-3)
    else:
        ans = n*(n-1)*(n-3)
else:
    ans = n*(n-1)*(n-2)

print(ans)",constant,number theory,443
"def Solve(n):
    if n <=2:
        return n
    elif n % 6== 0:
        return (n -1)*(n -2)*(n - 3)
    elif n % 2 == 0:
        return n * (n - 1) * (n - 3)
    else:
        return n * (n - 1) * (n - 2)

n = int(input())
print(Solve(n))",constant,number theory,240
"n=int(input())
if n==1 or n==2 :
    print(n)
elif n%2!=0 :
    m=n*(n-1)*(n-2)
    print(m)
elif n%3!=0 :
    m=n*(n-1)*(n-3)
    print(m)
else :
    m=(n-1)*(n-2)*(n-3)
    print(m)",constant,number theory,183
"import math
n=int(input())
if(n==4): print(12)
elif(n<=2): print(n)
else:
    if(n%2==0):
        a=n*(n-1)*(n-3)
        if(n%3==0): a=a//3
        b=n*(n-1)*(n-2)
        b=b//2
        print(max(a,b,(n-1)*(n-2)*(n-3)))
    else: print(n*(n-1)*(n-2))",constant,number theory,252
"n = int(input())
ans = 0
if n==1:
    print(1)
    exit()
if n==2:
    print(2)
    exit()
if n==3:
    print(6)
    exit()
if n%2==0:
    if n%3==0:
        ans=(n-1)*(n-2)*(n-3)
    else:
        ans=n*(n-1)*(n-3)
else:
    ans=n*(n-1)*(n-2)

print(ans)",constant,number theory,255
"def NOD(a, b):
    while b != 0:
        a %= b
        y = a
        a = b
        b = y
    return(a)
    
def NOK(a, b):
    i = (a*b) // NOD(a, b)
    return(i)
 
 
n = int(input())
maxnok = 0
x = 40
for i in range(max(1, n-x), n+1):
    for j in range(max(1, i-x), i+1):
        for f in range(max(1, j-x), j+1):
            nokk = NOK(NOK(i,j), f)
            if maxnok < nokk:
                maxnok = nokk
                delit = []
                delit.append(i)
                delit.append(j)
                delit.append(f)
print(maxnok)",constant,number theory,550
"import math
n = int(input())
m = 0
for i in range(min(100,n)):
	for ii in range(min(100,n)):
		for iii in range(min(100,n)):
			i1 = n-i
			ii1 = n-ii
			iii1 = n-iii
			r1 = (i1*ii1)//math.gcd(i1,ii1)
			r2 = (r1*iii1)//math.gcd(iii1,r1)
			m = max(m,r2)
print(m)",constant,number theory,264
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,4)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")
# def seive():
#     prime=[1 for i in range(10**6+1)]
#     prime[0]=0
#     prime[1]=0
#     for i in range(10**6+1):
#         if(prime[i]):
#             for j in range(2*i,10**6+1,i):
#                 prime[j]=0
#     return prime




x=L()[0]
if x<=2:
    print(x)
    exit()
if x%2:
    n=x
    lcm=n*(n-1)//gcd(n,n-1)
    lcm=lcm*(n-2)//gcd(lcm,n-2)
    print(lcm)
else:
    ans=1
    for n1 in range(max(1,x-50),x+1):
        for n2 in range(max(1,x-50),x+1):
            for n3 in range(max(1,x-50),x+1):
                lcm=(n1*n2)//(gcd(n1,n2))
                lcm=(lcm*n3)//gcd(lcm,n3)
                ans=max(ans,lcm)
    print(ans)





endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")
",constant,number theory,1789
"n=int(input())
if(n<3):
	print(n)
	exit(0)
if n%2==1:
	print(n*(n-1)*(n-2))
else:
	g=0;
	if n%3==0:
		g=n-2
	else:g=n;
	print((n-1)*(n-3)*(g))
",constant,number theory,143
"n = int(input("""")) 
if n==1 or n==2: 
    print(n) 
elif n&1: 
    print((n)*(n-1)*(n-2))
else:
    if n%3==0:
        print((n-2)*(n-1)*(n-3))
    else :
         print(max(n*(n-1)*(n-3), (n-1)*(n-2)*(n-3),(n*(n-1)*(n-2))/2))",constant,number theory,226
"'''''
arr= [1,3,4,3]
i=0
for k in range(8):
    if i!=arr[i]-1:
        if arr[i]!=arr[arr[i]-1]:
            print(arr[i],arr[arr[i]-1],arr,i)
            arr[i],arr[arr[i]-1]=arr[arr[i]-1],arr[i]
        else:
            i+=1
    else:
        i+=1
print(arr)
'''''

'''
def AllParenthesis(n):

    def backtrack(ans,curr,openp,closep,maxp):
        if len(curr)==2*maxp:
            ans.append(curr)
            return
        if openp<maxp:
            backtrack(ans,curr+""("",openp+1,closep,maxp)
        if closep<openp:
            backtrack(ans,curr+"")"",openp,closep+1,maxp)


    ans = []
    openp, closep = 0, 0
    curr = ''
    backtrack(ans, curr, openp, closep, n)
    return ans
print(AllParenthesis(3))
'''

#mat = [[1,2,3],[4,5,6],[7,8,9]]

'''temp=[[0 for x in range(len(mat[0]))]for x in range(len(mat))]
for i in range(len(mat)):
    temp[i][0]=mat[i][0]
    for j in range(1,len(mat[0])):
        temp[i][j]=temp[i][j-1]+mat[i][j]
for i in range(1,len(mat)):
    for j in range(len(mat[0])):
        temp[i][j]=temp[i-1][j]+temp[i][j]

k=3
lr=0
lc=0
rr=0
rc=0
ans=[[0 for x in range(len(mat[0]))]for x in range(len(mat))]
for i in range(len(mat)):
    for j in range(len(mat[0])):
        area1 = 0
        area2 = 0
        area3 = 0

        lr=i
        lc=j
        if i-k>=0:
            lr=i-k
        else:
            lr=0
        if j-k>=0:
            lc=j-k
        else:
            lc=0
        rr=i
        rc=j
        if i+k<len(mat):
            rr=i+k
        else:
            rr=len(mat)-1
        if j+k<len(mat[0]):
            rc=j+k
        else:
            rc=len(mat[0])-1
        if lc-1>=0:
            area1=temp[rr][lc-1]

        if lr-1>=0:
            area2=temp[lr-1][rc]
        if lr-1>=0 and lc-1>=0:
            area3=temp[lr-1][lc-1]
        ans[i][j]=temp[rr][rc]-area1-area2+area3'''


'''print(ans)'''
'''
nums = [-1,0,1,2,-1,-4]   #-1,0,1,2,-1,-4,-2,-3,3,0,4
nums.sort()
print(nums)
seen = set()
length=len(nums)
ans=[]
i=0
while i<length-2:
    l=i+1
    r=length-1
    target=nums[i]
    while l<r:
        if nums[l]+nums[r]==-target:
            seen.add((target,nums[l],nums[r]))

            while l < r and nums[l + 1] == nums[l]:
                l += 1
            while l < r and nums[r - 1] == nums[r]:
                r -= 1

            l+=1
            r-=1
        elif nums[l]+nums[r]>-target:
            r-=1
        else:
            l+=1
    i+=1
print(seen)
'''
import math
def check(n):
    '''   check = [1] * (n + 1)
    check[0] = 0
    check[1] = 0

    for i in range(2, int(math.sqrt(n)) + 1):
        if check[i] == 1:
            for j in range(i * i, n + 1, i):
                if check[j] == 1:
                    check[j] = 0

    def lcm(num1, num2):
        gcd1 = math.gcd(num1, num2)
        lcmf = (num1 * num2) // gcd1
        return lcmf'''

    if n==1:
        return 1
    if n==2:
        return 2
    if n==3:
        return 6
#    ans = 0
    if n&1:
        return ((n-1)*(n-2)*(n))
    if math.gcd(n,n-3)==1:
        return (n*(n-1)*(n-3))
    else:
        return ((n-1)*(n-2)*(n-3))
'''    k = j - 1
    for k in range(n-2, n-10, -1):
        lcm2 = lcm((n*(n-1)), k)
        if check[k]:
            return(lcm1*k)
'''
n =int(input())
print(check(n))
",constant,number theory,3268
"for _ in range(int(input())):
	a, b = map(int, input().split())
	result = 0
	while min(a, b)!=0:
		x = max(a, b)
		y = min(a, b)
		a = x
		b = y
		result+=a//b
		a%=b
	print(result)",constant,"math,number theory",181
"for _ in range(int(input())):
    a,b = map(int, input().split())
    c = 0
    while (a!=0 and b!=0):
        if (a>b) : 
            c+= a//b
            a = a%b
        elif (b>a):
            c+= b//a
            b = b%a
        else :
            c+=1
            break
    print(c)",constant,"math,number theory",287
"def f(a, b):
    global ans
    maks = max(a, b)
    mins = min(a, b)
    ans += (maks//mins)
#     print(ans)
    if (mins == 1):
        return ans
    else:
        if (maks % mins == 0):
            return ans 
        else:
            return f(maks%mins, mins)
for i in range(int(input())):
    a, b = list(map(int, input().split()))
    ans = 0
    print(f(a, b))",constant,"math,number theory",370
"for _ in range(int(input())):
    n,m = sorted(map(int,input().split()))
    count = 0
    while n> 0:
        count+= m//n
        m = m%n
        n,m = sorted([n,m])
    print(count)
",constant,"math,number theory",185
"def solve(a, b):
    m = max(a, b)
    n = min(a, b)
    if n == 0:
        return 0
    if m == n:
        return 1
    elif m % n == 0:
        return m // n
    k = m // n
    return k + solve(n, m - n * k)


for _ in range(int(input())):
    a, b = map(int, input().split())
    print(solve(a, b))",constant,"math,number theory",301
"for x in range(int(input())):
	a,b = map(int,input().split())
	if a > b or a == b:c,d = a,b
	else:c,d = b,a
	e = [0]
	def fun(c,d):
		e[0] += c // d 
		f = d
		d = c % d
		c = f
		if f > 0 and d > 0:
			fun(c,d)
	fun(c,d)
	print(e[0])",constant,"math,number theory",234
"from sys import stdin

def read_lines(sep=' ', input_type=None):
    #list of rows
    _lines = stdin.readlines()
    cast = input_type is not None
    lines = []
    for line in _lines:
        line = line[:-1].split(sep)
        if cast:
            line = [input_type(x) for x in line]
        lines.append(line)
    return lines

import collections

def numz(a,b):
    if a and b:
        if b > a:
            a,b=b,a
        d,m = divmod(a,b)
        return d + numz(b,m)
    else:
        return 0
    
if __name__ == '__main__':

    lines = read_lines(input_type=int)
    
    lines = lines[1:]
    for line in lines:
        print(numz(*line))
        
        
        ",constant,"math,number theory",680
"t = int(input())
ans = ''
for j in range(t):
    ab = input().split()
    a = int(ab[0])
    b = int(ab[1])
    k = 0
    while a > 0 and b > 0:
        if a >= b:
            k += a // b
            a %= b
        else:
            k += (b // a)
            b %= a
    ans += str(k) + '\n'
print(ans)
",constant,"math,number theory",302
"import math


n=int(input())

for _ in range(n):
    a,b=map(int,input().split())
    ans=0
    while a>0 and b>0:
        if a>=b:
            ans+=a//b
            a=a%b
        else:
            ans+=b//a
            b=b%a
    print(ans)
        ",constant,"math,number theory",249
"for _ in range(int(input())):
    a,b=map(int,input().split())
    ans=int(0)
    while a and b:
        a,b=min(a,b),max(a,b)
        ans,b=ans+b//a,b%a
    print(ans)
",constant,"math,number theory",169
"def max1(a,b):
    if a>=b:
        return a,b
    else:
        return  b,a
def minus(a,b):
    p=a//b
    cnt=p
    return b,(a-(b*cnt)),cnt
n=int(input())
for _ in range(n):
    a,b=input().split()
    a=int(a)
    b=int(b)
    cnt=0

    while a>0 and b>0:
        a,b=max1(a,b)
        a,b,p=minus(a,b)
        cnt+=p

    print(cnt)
",constant,"math,number theory",339
"n=input()
n1=int(n)
c=[]
for i in range(0,n1):
    z4=0
    p,q=input().split()
    a=int(p)
    b=int(q)
    while a!=0 and b!=0:
        z1=z3=0
        if a<=b:
          z=(b/a)
          z1=int(z)
          b=b-(z1*a) 
        if b<=a and b!=0:
          z2=a/b
          z3=int(z2)
          a=a-(z3*b) 
        z4=z4+z1+z3    
    c.append(z4)
l=len(c)
for j in range(0,l):
    print(c[j])
    ",constant,"math,number theory",401
"def substraction(a,b):
    if a==0 or b==0:
        return 0
    else:
        if a>b:
            count=a//b
            return substraction(a%b,b)+count
        else:
            count = b//a
            return substraction(a,b%a)+count

t=int(input())
lst=[]
res=[]
for i in range(0,t):
    lst=[int(i) for i in input().split()]
    ele=substraction(lst[0],lst[1])
    res.append(ele)

for i in range(0,t):
    print(res[i])",constant,"math,number theory",427
"import sys
if __name__=='__main__':
    # read input
    numCases = int(sys.stdin.readline())
    for i in range(numCases):
        a, b = sys.stdin.readline().split()
        a = int(a)
        b = int(b)
        total = 0
        largerNum = max(a,b)
        smallerNum = min(a,b)
        while True:
            div = int(largerNum/smallerNum)
            total += div
            rem = int(largerNum%(smallerNum*div))
            if rem == 0:
                break
            else:
                largerNum = smallerNum
                smallerNum = rem
                
        print(total)
        
    ",constant,"math,number theory",610
"def operations(a, b):
    less = min(a, b)
    more = max(a, b)
    ops = 0
    while less > 0 and more > 0:
        ops += more // less
        more -= less * (more // less)
        less, more = more, less
    return ops

n = int(input())
for i in range(n):
    a, b = map(int, input().split())
    print(operations(a, b))
",constant,"math,number theory",324
"import sys

def num_ops(low, high):
    if high % low == 0:
        return high // low
    else:
        return (high // low) + num_ops(high % low, low)

def main():
    n = int(sys.stdin.readline().strip())
    for _ in range(n):
        low, high = [int(i) for i in sys.stdin.readline().strip().split()]
        print(num_ops(low, high))




if __name__ == '__main__':
    main()",constant,"math,number theory",381
"n=int(input())
for i in range(n):
	a,b = map( int, input().split() )
	if a>b: 
	    a,b=b,a
	ans=0
	while a>0:
		ans+=b//a
		b%=a
		a,b=b,a
	print(ans)",constant,"math,number theory",151
"cases = int(input())
while cases:
    cases -= 1
    a, b = map(int, input().split())

    ans = 0
    while a > 0 and b > 0:
        if a < b:
            a, b = b, a
        ans += a//b
        a = a % b

    print(ans)
",constant,"math,number theory",222
"from collections import Counter
import copy

def solve():
    a,b=list(map(int,input().split()))
    count=0
    if a==b:
        return 1
    while a!=0 and b!=0:
        if a<b:
            count+=(b//a)
            b-=a*(b//a)
        else:
            count+=a//b
            a-=b*(a//b)
    return count


for i in range(int(input())):
        print(solve())

",constant,"math,number theory",365
"# https://codeforces.com/problemset/problem/313/A

n = int(input())

if n > 0:
    print(n)
else:
    n = n * -1
    x = n % 10
    y = (n // 10) % 10

    if x > y:
        print(-(n // 10))
    else:
        print(-((n // 100)* 10 + x))
",constant,"implementation,number theory",239
"from collections import defaultdict
import bisect
from itertools import accumulate, count
import os
import sys
import math
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input(): return sys.stdin.readline().rstrip(""\r\n"")



# ------------------- fast io --------------------
s=input()
neg=0
if int(s)<0:
    neg=1
ans1 = """"
s=int(s)
s=abs(s)
s=str(s)
ans2 = """"
for i in range(0, len(s)):
    if i == len(s)-2:
        ans1 += s[i]
    elif i == len(s)-1:
        ans2 += s[i]
    else:
        ans1 += s[i]
        ans2 += s[i]
if neg==0:
    print(s)
else:
    if str(min(int(ans1), int(ans2)))==""0"":
        print(0)
    else:
        print(""-""+str(min(int(ans1), int(ans2))))
",constant,"implementation,number theory",2270
"n=input();print(max(map(int,(n,n[:-1],n[:-2]+n[-1]))))",constant,"implementation,number theory",54
"n=int(input())
if n>-1:
    print(n)
else:
    n=str(n)
    x=int(n[:len(n)-1])
    y=int(n[:len(n)-2]+n[-1])
    print(max(x,y))",constant,"implementation,number theory",129
"import math
n = int(input())

if n>0:
    print(n)
else:
    l = list(str(n))
    
    last = l[0:len(l)-1]
    second = l[0:len(l)-2]
    second+=l[-1]
    lR = """".join(last)
    sR = """".join(second)
    
    
    
    print(max(eval(lR),eval(sR)))

        
    
    




    
    
            


   ",constant,"implementation,number theory",302
"n=int(input())
if n >= 0:
 
    print(n)
 
else:
 
    a = int(n / 10)
    b=int(n/100)*10 - abs(n)%10
    
    print(max(a,b))",constant,"implementation,number theory",127
"n = int(input())

if(n>=0):
    print(n)
    exit()
else:
    n=str(abs(n))
    n1=int(n[:len(n)-1])

    temp=n[len(n)-1]

    n2=n[:len(n)-2]

    n2=int(n2+temp)
    #print(n2)

if(n1<=n2):
    if(n1!=0):
        print('-'+str(n1))
    else:
        print(0)
else:
    if(n2!=0):
        print('-'+str(n2))
    else:
        print(0)",constant,"implementation,number theory",336
"s=input()
n=len(s)
if(s[0]=='-'):
    if(s[n-1]<s[n-2]):
        s=s[::-1]
        s=s.replace(s[1],"""",1)
        s=s[::-1]
    else:
        s=s[::-1]
        s=s.replace(s[0],"""",1)
        s=s[::-1]
    if(s==""-0""):
        print(""0"")
    else:
        print(s)
else:
    print(s)",constant,"implementation,number theory",282
"n=int(input())
l=list(str(n))
if n>=0:
	print(n)
else:
	if int(l[-1])>int(l[-2]):
		l.pop(-1)
	else:
		l.pop(-2)
	print(int(''.join(l)))
",constant,"implementation,number theory",137
"n=int(input())
a=str(n)
m=len(a)
b=int(a[0:m-1])
c=int(a[0:m-2]+a[-1])
d=max(n,b,c)
print(d)
",constant,"implementation,number theory",93
"r=input()
t1=int(r)
t2=int(r[:len(r)-1])
t3=int(r[:len(r)-2]+r[-1])
print(max(t1,t2,t3))
",constant,"implementation,number theory",89
"n=int(input())
if n>=0:
    print(n)
else:
    a=str(n)
    a=a[1::]
    if len(a)>2:
        a=a[::-1][1::][::-1]
        num1=int(a)
        a=str(n)
        a=a[1::]
        b=a[::-1]
        p1=b[0]
        p2=b[2::]
        p=p1+p2
        p=p[::-1]
        num2=int(p)
        small=min(num1,num2)
        print(-1*small)
        
    elif len(a)==2:
        m=a[0]
        n=a[1]
        small=min(int(m),int(n))
        print(-1*small)
    ",constant,"implementation,number theory",448
"n=int(input())
if(n>=0):
    print(n)
else:
    n=abs(n)
    rem=n%10
    n1=n//10
    n2=n1//10
    n2=n2*10+rem
    k=min(n1,n2)
    print(-1*k)
    
    
    
    
    
    
    
",constant,"implementation,number theory",182
"n=int(input())
m=str(n)
print(max(int(m),int(m[:-2]+m[-1:]),int(m[:-1])))
",constant,"implementation,number theory",74
"s = input()
if int(s) < 0:
    k = int(s)/10
    m = s[:len(s)-2]+s[-1]
    print(max(int(k),int(m)))

else:
    print(s)",constant,"implementation,number theory",121
"money=input()
initi=money
# if money>0:pass
    
if int(money)<0:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-2]
    else:money=money[:-2]+money[-1]
    print(int(money))
else:
    lst_dig=money[-1]
    lsec_dig=money[-2]
    if int(lst_dig)>int(lsec_dig):money=money[:-2]+money[-1]
    else:money=money[:-2]+money[-2]
    if int(initi)>=int(money):
        print(initi)
    else:
        print(money)
    ",constant,"implementation,number theory",465
"n=input()
if int(n)>0:
	print(n)
elif -9<=int(n)<=0:
	print(0)
else:
	a=(-int(n))//10
	b=((-int(n))//100)*10+int(n[-1])
	print(max(-a,-b))",constant,"implementation,number theory",138
"n=int(input())
if(n>=0):
    print(n)
else:
    if((n*-1)//10==0):
        print(0)
    else:
        n*=-1
        y=n//10
        z=n%10
        x=y//10
        x*=10;
        x+=z;
        x*=-1
        y*=-1
        if(x>=y):
            print(x)
        else:
            print(y)",constant,"implementation,number theory",285
"a=int(input())
if a>0:
    print(a)
else:
    a=a-2*a
    k=a//10
    b=a%10
    c=(a//100)*10+b
    if k<c:
        if k!=0:
            print('-%d' %k)
        else:
            print(k)
    else:
        if c!=0:
            print('-%d' %c)
        else:
            print(c)",constant,"implementation,number theory",278
"n,m=map(int,input().split())
a=0
while m:a+=n//m;n,m=m,n%m
print(a)",constant,"math,number theory",67
"def resistors(a,b):
    ans=0
    while b:
        ans+=a//b
        a,b=b,a%b
    return ans
a,b=map(int,input().strip().split())
print(resistors(a,b))",constant,"math,number theory",152
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353
# from sys import stdin
# input = stdin.readline
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,7)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")
def seive():
    prime=[1 for i in range(10**6+1)]
    prime[0]=0
    prime[1]=0
    for i in range(10**6+1):
        if(prime[i]):
            for j in range(2*i,10**6+1,i):
                prime[j]=0
    return prime



a,b=L()
def rec(a,b):
    if b==1:
        return a
    if a>b:
        return a//b+rec(b,a%b)
    else:
        return rec(b,a)
print(rec(a,b))



















endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")",constant,"math,number theory",1569
"a,b = map(int,input().split())
ans = 0
if(a > b):
    ans += int(a//b)
    a = a%b
while(b!=0):
    ans += int(a//b)
    a,b = b,a%b
print(ans)",constant,"math,number theory",143
"a,b=map(int,input().split())
ans=0
while a and b:
  ans+=a//b
  a,b=b,a%b
print(ans)",constant,"math,number theory",84
"n, m = map(int, input().split())
s = 0
while m:
    s += n // m
    n, m = m, n % m
print(s)",constant,"math,number theory",92
"import math
a, b = map(int, input().split())
if a % b == 0:
    print(int(a/b))
else:
    c = 0
    while b:
        c += a//b
        temp = a
        a = b
        b = temp % b
    print(c)
",constant,"math,number theory",192
"a, b = map(int, input().split(' '))
res = 0
temp = 0

if a%b == 0:
    print(int(a/b))
else:
    while b!=0:
        res += a//b
        a%=b
        temp = a
        a = b
        b = temp
    print(res)
			     			  				 				 			  		",constant,"math,number theory",235
"n, m = map(int, input().split())
a = 0
while m:
    a += n//m
    n, m = m, n % m
print(a)
",constant,"math,number theory",91
"
from sys import stdin,stdout,setrecursionlimit
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor	
from bisect import bisect_right as br,bisect_left as bl
import heapq

def solve(a,b):
	if a == 0:
		return 0
	return b//a + solve(b%a,a)
print(solve(*mp()))

",constant,"math,number theory",447
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
# sys.setrecursionlimit(111111) 
INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True
 
    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False
 
    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1
 
    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x
 
    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k
 
    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1
 
        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True
 
    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi
 
        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True
 
    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)
 
    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))
 
    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value
 
    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx
 
    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx
 
    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)
 
    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len
 
    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]
 
    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)
 
    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False
 
    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)
 
    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))
 
    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))
    
class SegTree:
    
    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)
    
    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1
    
    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):
    """"""Returns all primes not greater than limit.""""""
    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    ###CODE
    

            
    tc = 1
    for _ in range(tc):
        a,b=ria()
        op=0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
        while True:
            if b:
                op+=a//b
                a%=b
                a,b=b,a
            else:
                break
        wi(op)
            
            
            
            
        
                        
                
        
        
        
        
        
        

                    
                
                
                
        
        
        
            
        
                        
            
 
            


                

        
        
        
        
        
       
        
       

        
        

            
            
            
                
            

            
            
        
        
           
        
        
                 
                
        
        

        
        

        
        
        
            
        
        
            
                

            
            
                
            
            
            
            
        
        
       
         
        

        
        
                    
                        

                    
           
                     
            
        
                
        
        
            
        
        
        
        
        

    
        
        
        
                
                
        
        
        
    

        
        
        

        
                             
        
        
        
            
        
        
                     
        
        
                    
        
                     
                    
                    
                
                
                    
                
        
        
            
                   
        
                    

        
        
                
            
            
    
            
                        
        
    

        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",constant,"math,number theory",18657
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
# sys.setrecursionlimit(111111) 
INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True
 
    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False
 
    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1
 
    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x
 
    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k
 
    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1
 
        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True
 
    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi
 
        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True
 
    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)
 
    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))
 
    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value
 
    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx
 
    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx
 
    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)
 
    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len
 
    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]
 
    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)
 
    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False
 
    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)
 
    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))
 
    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))
    
class SegTree:
    
    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)
    
    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1
    
    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):
    """"""Returns all primes not greater than limit.""""""
    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    ###CODE
    

            
    tc = 1
    for _ in range(tc):
        a,b=ria()
        op=0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
        while min(a,b):
            if a>b:
                op+=a//b
                a%=b
            else:
                op+=b//a
                b%=a
        
        wi(op)
            
            
            
            
        
                        
                
        
        
        
        
        
        

                    
                
                
                
        
        
        
            
        
                        
            
 
            


                

        
        
        
        
        
       
        
       

        
        

            
            
            
                
            

            
            
        
        
           
        
        
                 
                
        
        

        
        

        
        
        
            
        
        
            
                

            
            
                
            
            
            
            
        
        
       
         
        

        
        
                    
                        

                    
           
                     
            
        
                
        
        
            
        
        
        
        
        

    
        
        
        
                
                
        
        
        
    

        
        
        

        
                             
        
        
        
            
        
        
                     
        
        
                    
        
                     
                    
                    
                
                
                    
                
        
        
            
                   
        
                    

        
        
                
            
            
    
            
                        
        
    

        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",constant,"math,number theory",18672
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
# sys.setrecursionlimit(111111) 
INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""
class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True
 
    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False
 
    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1
 
    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x
 
    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k
 
    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1
 
        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True
 
    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi
 
        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True
 
    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)
 
    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))
 
    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value
 
    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx
 
    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx
 
    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)
 
    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len
 
    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]
 
    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)
 
    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False
 
    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)
 
    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))
 
    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))
    
class SegTree:
    
    def __init__(self, n):
        self.N = 1 << n.bit_length()
        self.tree = [0] * (self.N<<1)
    
    def update(self, i, j, v):
        i += self.N
        j += self.N
        while i <= j:
            if i%2==1: self.tree[i] += v
            if j%2==0: self.tree[j] += v
            i, j = (i+1) >> 1, (j-1) >> 1
    
    def query(self, i):
        v = 0
        i += self.N
        while i > 0:
            v += self.tree[i]
            i >>= 1
        return v

def SieveOfEratosthenes(limit):
    """"""Returns all primes not greater than limit.""""""
    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def main():

    mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    ###CODE
    

            
    tc = 1
    for _ in range(tc):
        a,b=ria()
        # LOGIC-
        # actually the quesn can easily understood as
        # we have 1 ohm resistor
        # we have 2 options now 
        # we can add 1 ohm resistor in series to this 
        # or we can add 1 ohm resistor in parallel to this
        # let say we get to a/b ohm circuit system using k resistors
        # now we add 1 resistor in series and parallel and see what happens
        # a/b becomes (a+b)/b in series and a/(a+b) in parallel using k+1 resistors
        # so if we have resistance as a/b it becomes (a+b)/b or a/(a+b) using 1 resistor
        # in other words :
        # so if we had resistance a/b it would have been 
        # (a-b)/a without 1 ohm resistor in series 
        # a/(b-a) without 1 ohm resistor in parallel
        # func(a,b)=func(a-b,b) or func(a,b-a)
        # does it ring a bell?
        # Adding 1 ohm resistor to a circuit is just reverse of euclidean algo for finding gcd
        # That means that the answer is equal to the number of steps in standard Euclidean algorithm.
        # but basic gcd(a,b)=gcd(b-a,a) wont work we have to use mod to calculate faster
        # like gcd(a,b)=gcd(b,a%b)
              
        op=0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
        while min(a,b):
            if a>b:
                op+=a//b
                a%=b
            else:
                op+=b//a
                b%=a
        
        wi(op)
            
            
            
            
        
                        
                
        
        
        
        
        
        

                    
                
                
                
        
        
        
            
        
                        
            
 
            


                

        
        
        
        
        
       
        
       

        
        

            
            
            
                
            

            
            
        
        
           
        
        
                 
                
        
        

        
        

        
        
        
            
        
        
            
                

            
            
                
            
            
            
            
        
        
       
         
        

        
        
                    
                        

                    
           
                     
            
        
                
        
        
            
        
        
        
        
        

    
        
        
        
                
                
        
        
        
    

        
        
        

        
                             
        
        
        
            
        
        
                     
        
        
                    
        
                     
                    
                    
                
                
                    
                
        
        
            
                   
        
                    

        
        
                
            
            
    
            
                        
        
    

        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",constant,"math,number theory",19845
"import os
import sys
from io import BytesIO, IOBase
# region fastio
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def input(): return sys.stdin.readline().rstrip(""\r\n"")
def getint(): return int(input())
def getints(): return list(map(int, input().split()))
def getint1(): return list(map(lambda x: int(x) - 1, input().split()))

def main():
    a,b = getints()
    print(result(a,b))

def result(a,b):
    if a==0 or b==0:
        return 0
    if a>b:
        return a//b+result(a%b,b)
    else:
        return b//a+result(b%a,a)

if __name__ == ""__main__"":
    main()",constant,"math,number theory",2121
"def prime(n):
    if n < 2:
        return False
    elif n % 2 == 0 and n != 2:
        return False
    for j in range(3, int(pow(n, 0.5) + 1), 2):
        if n % j == 0:
            return False
    return True
n = int(input())
for j in range(2, int(n / 2) + 1):
    if prime(j) == False and prime(n - j) == False:
        print(j, n - j)
        break
",constant,"math,number theory",356
"  
def primecheck(x):
	cnt=0
	for i in range(2,x//2 +1):
		if x%i == 0:
			cnt+=1
			break
	if cnt :
		return 1
	else:
		return 0


n = int(input())
for i in range(4,n):
	if primecheck(i) == 1 and primecheck(n-i) == 1:
		print(str(i) + "" ""+ str(n-i))
		break",constant,"math,number theory",258
"import sys

def is_prime(x):
    return all(x%i for i in range(2, int(x**.5)+1))

t = int(sys.stdin.read().strip())
for i in range(4, t//2+1):
    if not is_prime(i) and not is_prime(t-i):
        print(i, t-i, sep=' ')
        break
",constant,"math,number theory",234
"import bisect
import collections
import copy
import functools
import heapq
import itertools
import math
import random
import re
import sys
import time
import string
from time import time_ns
from typing import List
sys.setrecursionlimit(99999)

def II():return int(sys.stdin.readline().strip())
def IIs():return list(map(int,sys.stdin.readline().strip().split()))
def SI():return sys.stdin.readline().strip()

n=II()
if n&1:
    print(9,n-9)
else:
    print(8,n-8)",constant,"math,number theory",463
"n=int(input())
print('4 %s'%(n-4) if n%2==0 else '9 %s'%(n-9))",constant,"math,number theory",62
"# n = int(input())
# digits = list([])
# new_digits= set({})
# for i in range(n):
#     n = int(input())
#     if n in range(1,10):
#         print(1)
#         print(n)
#     else:
#         while n > 0 :
#             digit = n % 10
#             digits.append(digit)
#             n = int(n /10)
#         i = 0
#         for d in digits:
#             new_digits.add(d * 10**i)
#             i += 1
#         if 0 in new_digits:
#              new_digits.remove(0)
#         print(len(new_digits))
#         for d in new_digits:
#             print(d,end="" "")
#         print('')
#         new_digits.clear()
#         digits.clear()

# we need to find the index of these values in the given array
# n = int(input())
# a = list(map(int,input().split(' ')))
# b = list([])
# for i in range(1,n+1):
#     b.append(i)
# results = []
# for l in b:
#     results.append(a.index(l) + 1)
#
# for r in results:
#     print(r,end="" "")


# k = int(input())
# l = int(input())
# m = int(input())
# n = int(input())
# d = int(input())
# nums = list([])
# for i in range(1,d+1):
#     nums.append(i)
# results = set({})
# for num in nums:
#     if num % k == 0 :
#         results.add(num)
#     elif num % l == 0 :
#         results.add(num)
#     elif num % m == 0 :
#         results.add(num)
#     elif num % n == 0 :
#         results.add(num)
# print(len(results))

# function problem
# n = int(input())
# result = 0
#
# if n %2 == 0:
#     result = int(n /2)
# else:
#     result = -1 * (int(n / 2) + 1)
# print(result)




# General arrival
# n = int(input())
# a = list(map(int,input().split(' ')))
# b = list(dict.fromkeys(a))
# finding the max number and index
# max_index = 0
# i = 0
# maxi = a[0]
# while i < len(b):
#     if b[i] >= maxi:
#         maxi = b[i]
#         max_index = i
#     i += 1

# finding the min number and index
# min_index = 0
# i = 0
# mini = max(b)
# while i < len(b):
#     if b[i] <= mini:
#         mini = b[i]
#         min_index = i
#     i += 1
# if len(a) == 2:
#     print(len(a) - 1)
# else:
#     print( (max_index - 0) + ((len(b) - 1) - min_index) )
# print(b)



def is_prime(num):
    if num > 1:
        for i in range(2, num):
            if (num % i) == 0:
               return  False
        else:
            return True
    else:
        return False

n = int(input())
temp = 0
first = 0
second = 0
if n % 2 == 0:
    temp = int(n/2)
    first = temp
    second = n - temp
    while is_prime(first) or is_prime(second):
        first -= 1
        second += 1
        if first + second == n and (not is_prime(first) and not is_prime(second)):
            break
else:
    temp = int(n / 2)
    first = temp
    second = n - first
    while is_prime(first) or is_prime(second):
        first -= 1
        second += 1
        if first + second == n and (not is_prime(first) and not is_prime(second)):
            break
print(first,end="" "")
print(second)",constant,"math,number theory",2899
"i=int(input())
d=i%2+8;print(d,i-d)",constant,"math,number theory",35
"n=int(input());
if n % 2 == 0:
    
    print((n-4),"" 4"")
else:
    
    print((n-9),"" 9"")
		
		
		",constant,"math,number theory",99
"def isPrime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
n=int(input());d=0
if n%2==0:
    print('4 '+str(n-4))
else:
    i=4
    while i<=int(n//2)+1:
        k=n-i
        if isPrime(k)==False:
            print(str(i)+' '+str(k))
            break
        i+=2

            
        
            
",constant,"math,number theory",340
"n=int(input());print('4 '+str(n-4) if n%2==0 else '9 '+str(n-9))

            
        
            
",constant,"math,number theory",101
"n=int(input())
if n%2==0:
    print(4,n-4)
else:
    print(9,n-9)
    ",constant,"math,number theory",70
"n = int(input())

if n % 2 == 0 :
    print(4 , n - 4)
else:
    print(9 , n - 9)




",constant,"math,number theory",86
"n = int(input())
if n%2==0:
    a = n - 8
    print(a,8)
else:
    a = n-9
    print(a,9)
",constant,"math,number theory",90
"from math import *
n = int(input())
if n%2==0:
    print(n-8,n-(n-8))
else:
    print((n-9),n-(n-9))
",constant,"math,number theory",101
"def Is_prime(n):
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True


n = int(input())
for i in range(2, 100):
    if not Is_prime(i) and not Is_prime(n - i):
        print(i, n - i)
        break
# print(Is_prime(n))
",constant,"math,number theory",273
"def iscomposite(value):
    for i in range(2,value):
        if(value%i==0):
            return '1'
    else:
        return '0'



n=int(input())
for i in range(4,n):
    a=i
    b=n-i
    if(iscomposite(a)=='1' and iscomposite(b)=='1'):
        print(a,b)
        break
    else:
        continue
",constant,"math,number theory",299
"k = 1000001
a = [True] * k
a[0] = a[1] = False

for i in range(k):
    if a[i]:
        j = 2 * i
        while j < k:
            a[j] = False
            j += i

n = int(input())
for i in range(4, n):
    if not a[i] and not a[n-i]:
        print(i, n-i)
        exit()",constant,"math,number theory",271
"k = 1000001
a = [True] * k
a[0] = a[1] = False

for i in range(k):
    if a[i]:
        for j in range(2*i, k, i):
            a[j] = False

n = int(input())
for i in range(4, n):
    if not a[i] and not a[n-i]:
        print(i, n-i)
        exit()",constant,"math,number theory",248
"def resheto(a):
    numbers = list(range(0, a + 1))
    primes = set()
    for k in range(2, a + 1):
        if numbers[k] != 0:
            primes.add(k)
            for j in range(2 * k, a + 1, k):
                numbers[j] = 0
    return primes


all_primes = resheto(10**6)
n = int(input())
for i in range(2, n):
    if i not in all_primes and (n - i) not in all_primes:
        print(i, n - i)
        break",constant,"math,number theory",413
"l,r=map(int,input().split())
j=r-l+1

if j==3:
	if l%2==0:
		print(l,l+1,l+2)
	else:
		print(-1)
elif j>3:
	if l%2==0:print(l,l+1,l+2)
	else:print(l+1,l+2,l+3)
else:print(-1)",constant,"brute force,implementation,math,number theory",174
"l,r=map(int,input().split())
j=r-l+1

# basically two even numbers can never be coprime so we will check can we have three numbers 
# such that we can have 2 even and 1 odd 

# if gap consists number less than 3 then output would be -1
# if gap is of 3 it must start with even like 2-4 we have 2 3 4
# if it starts with 5-7 we can write 5 6 7 
if j==3:
	if l%2==0:
		print(l,l+1,l+2)
	else:
		print(-1)
elif j>3:
	if l%2==0:print(l,l+1,l+2)
	else:print(l+1,l+2,l+3)
else:print(-1)",constant,"brute force,implementation,math,number theory",480
"
l,r = list(map(int,input().split()))
f = 0
def gcd(a,b):
    if b == 0:
        return a
    return gcd(b,a%b)
for a in range(l,r+1):
    for b in range(a+1,r+1):
        for c in range(b+1,r+1):
        
           if (gcd(a,b) == 1) and (gcd(b,c) == 1) and (gcd(a,c)!=1):
                print(a,b,c)
                f = 1
                break
        if f == 1:
            break
    if f == 1:
        break
else:
    print(-1)

        
    
    
",constant,"brute force,implementation,math,number theory",454
"import sys
input = sys.stdin.readline
x,y = map(int, input().split())
if y-x<2:
	print(-1)
elif x%2 != 0 and y-x==2:
	print(-1)
elif x%2==0:
	print(x, x+1, x+2)
else:
	print(x+1, x+2, x+3)",constant,"brute force,implementation,math,number theory",188
"x,y=map(int,input().strip().split())
if(abs(x-y)<2):
    print(-1)
else:
    k=[]
    for i in range(x,y+1):
        if(i%2==0):
            k.append(i)
            if(i+1<y):
                k.append(i+1)
                k.append(i+2)
                break
    if(len(k)==3):
        print("" "".join(str(t) for t in k))
    else:
        print(-1)",constant,"brute force,implementation,math,number theory",347
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""""""
Created on Mon Dec 14 13:18:46 2020

@author: yash
""""""
""""""
 __  __ _                   
|  \/  (_)_ __ ___  _ __    
| |\/| | | '__/ _ \| '_ \  
| |  | | | | | (_) | | | | 
|_|  |_|_|_|  \___/|_| |_|  
""""""
""""""
 
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░████████░░░░░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████████░░░░░░░░░░░░░░░░░▌░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░◐◐◐█████████▀▀▀▀▀▀🔥░░░░░░░░███
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████████░░░░░░░░░░░░░░░░░░░░▌░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████████░░░░░░░░░░░░░░░░░░░░█▌░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▄▄▀█████████████████████████████████████████████████
░░░░░░░░░░░░░░░░░░░░░░░░░░▄▄▄████▄████████ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ██ ████
░░░░░░░░░░░░░░░░░░░░░░░░░░░▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█████████▀▀▀▀▀▀▀▀▀
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████████░░░░░░░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░◐◐◐█████████▀▀▀▀▀▀🔥░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████████░░░░░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████████░░░░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░████████░░░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░███████░░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██████░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█████░░░░░░░░░░░░░░░
""""""
""""""
 
 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@#@@#@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@M@M # #@@@M@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@@ @@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@### #@@B@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@B@@#@@@@@#M@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@##@@M@#@@##@##@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#M@@@@@##@M@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##@@@@@@#@##@#@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#  @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@  #
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@@#@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @# @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @# @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@@#@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@  #
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#  @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ @@#@@#@@@@@@@@@@@@@@@@@#@@#@#@@@@@@@@@@@@@@@@@@@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@
 @ #@@@@@@@@@@@@@@@@@@@@#@@@@@@#@@@@@@@@@@@@@@@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ @@#@#@@@@@@@@@@@@@@@@@@#@####@@@@@@@@@@@@@@@@@M@#@@#@#@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@#@#M@@@M@@@@@@@@@@@@@@@@@@@M@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@M@#@#@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@M@@M@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@#@@#@@@@@@@@@@@@@@@@@@@@M@M@#@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@
@@#@@#@@@@@@@@@@@@@@@@@@@@@@@M@                   @M@@#@@@@@@@@@@@@@@@@@@@@@@@@@
@#@@@@@#@@@@@@@@@@@@@@@@@@@#@@                     @@@@M@@@@@@@@@@@@@@@@@@@@@@@@
@@@#@@@##@@@#@@@@@#@@@@@##@@@@                     #@#@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@####@@####@@@@#@@@@M@@@#@@#                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@#@          @#@@#@@@       #@             @       #@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                            @#           @@#@@     #@@#@@@@@@@@@@@@@@@@@@@@@@@@@
                     ##@#@@ #M           @# @@     @@M  @@@@@@@@@@@@@@@@@@@@@@@@
                     @#@@@M #@           #@   #    @@   @@@@@@@@@@@@@@@@@@@@@@@@
                      @@ @@#@@           ##    @##@@    @@@@@@@@@@@@@@@@@@@@@@@@
                      @#  @@M@           @@             @@@@@@@@@@@@@@@@@@@@@@@@
    @@@##@@@          @@@@ @@@          @@               #@#@@#@@@@@@@@@@@@@@@@@
@@@@###@@###@@@@#@#@@@@#@@@ M@          #@    @       B  @@@#@@@@@@@@@@@@@@@@@@@
@M@@@@@MM@@@@@M@@#@##@@@#@@M@B          @#   M@   @# #@  #@@#@@@@@@@@@@@@@@@@@@@
@#@#@@M@@M@@#@#@#@#@@#@#@#@@@@          @#   @@   #  @M  @#@@@@@@@@@@@@@@@@@@@@@
@@@          @@@@#@##@     #@#          @M    #  @   @   @@@@@#@@@@@@@@@@@@@@@@@
                            @@          @@   @#@@#@@#M   #@@@@#@@@@@@@@@@@@@@@@@
                           M@#           #@   @@@@##@@ @M@#M@@@#@@@@@@@@@@@@@@@@
                           @@@@           @@          @@@#@@@#@#@@@@@@@@@@@@@@@@
                          @#  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
                          @@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   @M@H@@  @#        @#@@@@#@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@#@#@##@M@@@M@ @M#@@@@@#@@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#M@@@##@@@@@@@@M@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@#@@@@@M@#@M@@B#M@@M@###@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
###@@@@@@@@@# @#@@@@@@@#@@@#@##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@#@@M@@@#@@#@#@@@@@@#@@@#@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@M@#@# 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@@@#
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@M@@##
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#@M
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@###@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#  #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 
 
""""""
""""""
                          / \  //\
            |\___/|      /   \//  \\
            /0  0  \__  /    //  | \ \    
           /     /  \/_/    //   |  \  \  
           @_^_@'/   \/_   //    |   \   \ 
           //_^_/     \/_ //     |    \    \
        ( //) |        \///      |     \     \
      ( / /) _|_ /   )  //       |      \     _\
    ( // /) '/,_ _ _/  ( ; -.    |    _ _\.-~        .-~~~^-.
  (( / / )) ,-{        _      `-.|.-~-.           .~         `.
 (( // / ))  '/\      /                 ~-. _ .-~      .-~^-.  \
 (( /// ))      `.   {            }                   /      \  \
  (( / ))     .----~-.\        \-'                 .~         \  `. \^-.
             ///.----..>        \             _ -~             `.  ^-`  ^-_
               ///-._ _ _ _ _ _ _}^ - - - - ~                     ~-- ,.-~
                                                                  /.-~
 
""""""
""""""
  ____          _      _____                       
 / ___|___   __| | ___|  ___|__  _ __ ___ ___  ___ 
| |   / _ \ / _` |/ _ \ |_ / _ \| '__/ __/ _ \/ __|
| |__| (_) | (_| |  __/  _| (_) | | | (_|  __/\__ \
 \____\___/ \__,_|\___|_|  \___/|_|  \___\___||___/
""""""
""""""
░░██▄░░░░░░░░░░░▄██
░▄▀░█▄░░░░░░░░▄█░░█░
░█░▄░█▄░░░░░░▄█░▄░█░
░█░██████████████▄█░
░█████▀▀████▀▀█████░
▄█▀█▀░░░████░░░▀▀███
██░░▀████▀▀████▀░░██
██░░░░█▀░░░░▀█░░░░██
███▄░░░░░░░░░░░░▄███
░▀███▄░░████░░▄███▀░
░░░▀██▄░▀██▀░▄██▀░░░
░░░░░░▀██████▀░░░░░░
░░░░░░░░░░░░░░░░░░░░
""""""
""""""░░██▄░░░░░░░░░░░▄██
░▄▀░█▄░░░░░░░░▄█░░█░
░█░▄░█▄░░░░░░▄█░▄░█░
░█░██████████████▄█░
░█████▀▀████▀▀█████░
▄█▀█▀░░░████░░░▀▀███
██░░▀████▀▀████▀░░██
██░░░░█▀░░░░▀█░░░░██
███▄░░░░░░░░░░░░▄███
░▀███▄░░████░░▄███▀░
░░░▀██▄░▀██▀░▄██▀░░░
░░░░░░▀██████▀░░░░░░
░░░░░░░░░░░░░░░░░░░░
""""""
""""""
# Codeforces Round #186 (Div. 2), problem: (A) Ilya and Bank Account

    n = int(input())
    if n > 0:
        print(n)
    else:
        s = str(n)
        if s[len(s)-1] < s[len(s)-2] and s[len(s)-2] != '0':
            print(int(s[:len(s)-2] + s[len(s)-1:]))
        elif s[len(s)-1] > s[len(s)-2] and s[len(s)-1] != '0':
            print(int(s[:len(s)-1]))
        else:
            print(int(s[:len(s)-1]))
""""""


""""""
# Codeforces Round #261 (Div. 2), problem: (A) Pashmak and Garden,

x1, y1, x2, y2=map(int,input().split())
l=abs(x1-x2)
m=abs(y1-y2)
if x1==x2:
    print(x1+m,y1,x2+m,y2)
elif y1==y2:
    print(x1,y1+l,x2,y2+l)
elif l!=m: 
    print(-1)
else: 
    print(x1,y2,x2,y1)
""""""


""""""
# Codeforces Round #142 (Div. 2), problem: (A) Dragons

def solve():
    s, n = map(int, input().split())
    sets = []
    for _ in range(n):
        ith, bonus = map(int, input().split())
        sets.append([ith, bonus])
    sets.sort(key=lambda x: x[0])
    for i in sets:  
        if i[0] < s:
                s += i[1]
        else:
            return ""NO""
    return ""YES""
print(solve())
""""""
""""""
# Codeforces Round #690 (Div. 3)

# (A) Favorite Sequence-

    for _ in range(int(input())):
        n = int(input())
        l = list(map(int, input().split()))
        ans = []
        k = n//2
        start = 0
        end = len(l)-1
        while start <= end:
            if start != end:
                ans.append(l[start])
                ans.append(l[end])
            else:
                ans.append(l[end])
            start += 1
            end -= 1
        for i in ans:
            print(i, end="" "")
        print()

# B) Last Year's Substring-

    for _ in range(int(input())):
        n = int(input())
        s = input()
        if s[0]+s[1] == '20' and s[-2]+s[-1] == '20':
            print(""YES"")
        elif s[0] == '2' and s[-3]+s[-2]+s[-1] == '020':
            print(""YES"")
        elif s[0]+s[1]+s[2] == '202' and s[-1] == '0':
            print(""YES"")
        elif s[0]+s[1]+s[2]+s[3] == '2020':
            print(""YES"")
        elif s[-4]+s[-3]+s[-2]+s[-1] == '2020':
            print(""YES"")
        else:
            print(""NO"")
""""""
""""""
# Codeforces Round #251 (Div. 2)
   
    n, d = map(int, input().split())
    l = list(map(int, input().split()))
    if (sum(l) + (n-1)*10) > d:
        print(-1)
    else:
        print((d-sum(l))//5)
""""""
""""""
# Codeforces Round #290 (Div. 2)

n,m=map(int,input().split())
for i in range(n):
    if i % 4 == 0:
        print('#'*m)
    elif i % 4 == 1:
        print('.'*(m-1)+'#')
    elif i % 4 == 2:
        print('#'*m)
    else:
        print('#'+'.'*(m-1))
        
        
n,m=map(int,input().split())
for i in range(n):
    print(['#'*m,'.'*(m-1)+'#','#'*m,'#'+'.'*(m-1)][i%4])

""""""     
""""""
# Educational Codeforces Round 100 (Rated for Div. 2)


# problem: (A) Dungeon
    def solve(a, b, c):
        s = a+b+c
        k = s//9
        if s % 9 == 0 and a >= k and b >=k and c >= k:
            return ""YES""
        else:
            return ""NO""
            
    for _ in range(int(input())):
        a, b, c = map(int, input().split())
        print(solve(a, b, c)) 


# problem: (B) Find The Array

    for _ in range(int(input())):
        n = int(input())
        l = list(map(int, input().split()))
        even = 0
        odd = 0
        for i in range(len(l)):
            if i % 2 == 0:
                even += l[i]
            else:
                odd += l[i]
        
        if even < odd:
            for i in range(len(l)):
                if i % 2 == 0:
                    l[i] = 1
                    print(l[i], end="" "")
                else:
                    print(l[i], end="" "")
        else:
             for i in range(len(l)):
                if i % 2 == 0:
                    print(l[i], end="" "")
                else:
                    l[i] = 1
                    print(l[i], end="" "")

""""""



""""""
# Codeforces Beta Round #25 (Div. 2 Only), problem: (A) IQ test
    n = int(input())
    nums = list(map(int, input().split()))
    even = 0
    odd = 0
    counter1 = 0
    counter2 = 0
    for i in range(len(nums)):
        if nums[i]%2 == 0:
            counter1+=1
            even = i+1
        else:
            counter2+=1
            odd = i+1
        
    if counter1 == 1:
        print(even)
    else:
        print(odd)
""""""

""""""
# Codeforces Round #246 (Div. 2), problem: (A) Choosing Teams

    n, k = map(int, input().split())
    l = list(map(int, input().split()))
    counter = 0
    for i in range(len(l)):
        if (5-l[i]) >= k:
            counter += 1
    print(counter//3)
""""""

""""""
 # Codeforces Round #192 (Div. 2), problem: (A)   
    r, c = map(int, input().split())
    a = set()
    b = set()
    for i in range(r):
        d = input()
        for j in range(len(d)):
            if d[j] == 'S':
                a.add(j)
                b.add(i)
    
    print(r*c - len(a)*len(b))
""""""


# n, m = map(int, input().split())
# b = []
# for i in range(n):
#     if min(list(map(int, input().split()))[1:]) < m:
#         b.append(i + 1)
# print(len(b), '\n', *b)
        
""""""
 # Codeforces Round #691 (Div. 2), problem: (A) Red-Blue Shuffle,
    for i in range(int(input())):
        n = int(input())
        a = input()
        b = input()
        counter_a = 0
        counter_b = 0
        for j in range(len(a)):
            if a[j] > b[j]:
                counter_a += 1
            elif a[j] < b[j]:
                counter_b += 1
        
        if counter_a > counter_b:
            print(""RED"")
        elif counter_a < counter_b:
            print(""BLUE"")
        else:
            print(""EQUAL"")
    
""""""
""""""
# Codeforces Round #263 (Div. 2), problem: (A) Appleman and Easy Task
    x = ''
    for _ in range(int(input())):
        x += input()
        
    if x == x[::-1]:
        print(""YES"")
    else:
        print(""NO"")
""""""
""""""
 # Codeforces Round #226 (Div. 2), problem: (A) Bear and Raspberry
    n, c = map(int, input().split())
    l = list(map(int, input().split()))
    ans = l[0] - l[1]
    for i in range(1, len(l)-1):
        ans = max(ans, l[i] - l[i+1])
    if ans - c < 0:
        print(0)
    else:
        print(ans-c)
""""""

# n, k = map(int, input().split())
# joy = float(""-inf"")
# for _ in range(n):
#     f, t = map(int, input().split())
#     if t >= k:
#         joy = max(joy, f - (t - k))
#     else:
#         joy =  max(joy, f)
# print(joy)


""""""
# Codeforces Round #260 (Div. 2), problem: (A) Laptops,   
    for _ in range(int(input())):
        a,b=input().split()
        if a!=b:
            print('Happy Alex')
            exit()
    print('Poor Alex')
""""""
""""""
# Technocup 2021 - Elimination Round 3:
    
    problem: (A) In-game Chat
        for _ in range(int(input())):
            n = int(input())
            s = input()
            j = len(s)-1
            count = 0
            while j >= 0:
                if s[j] != ')':
                    break
                count += 1
                j -= 1
        
            if count > len(s)-count:
                print(""YES"")
            else:
                print(""NO"")
""""""


# def solve(x):
#     for i in str(x):
#         if i != '0' and x % int(i) != 0:
#             return False
#     return True
     
# t = int(input())
# for _ in range(t):
#     n = int(input())
#     while not solve(n):
#         n += 1
#     print(n)
    
""""""
 # Codeforces Round #222 (Div. 2), problem: (A) Playing with Dice
    a, b = map(int, input().split())
    a_w = 0
    b_w = 0
    draw = 0
    for i in range(1, 7):
        if abs(i-a) < abs(i-b):
            a_w += 1
        elif  abs(i-a) > abs(i-b):
            b_w += 1
        else:
            draw += 1
    print(a_w, draw, b_w)
""""""
""""""
# Codeforces Round #283 (Div. 2), problem: (A) Minimum Difficulty
    n=int(input())
    l=list(map(int,input().split()))
    x=max([l[i+1]-l[i] for i in range(n-1)])
    y=min([l[i+2]-l[i] for i in range(n-2)])
    print(max(x,y))
""""""
""""""
 # Codeforces Round #156 (Div. 2), problem: (A) Greg's Workout
        n = int(input())
        arr = list(map(int, input().split()))
        chest_count = 0
        biceps_count = 0
        back_count = 0
        for i in range(len(arr)):
            if i%3 == 0:
                chest_count += arr[i]
            elif i%3 == 1:
                biceps_count += arr[i]
            elif i%3 == 2:
                back_count += arr[i]
            
        ans = max(chest_count, biceps_count, back_count)
        
        if chest_count == ans:
            print(""chest"")
        elif biceps_count == ans:
            print(""biceps"")
        else:
            print(""back"")
            
               OR

        input()
        arr = [int(i) for i in input().split()]
        b = [sum(arr[::3]), sum(arr[1::3]), sum(arr[2::3])]
        c = ['chest', 'biceps', 'back']
        print(c[b.index(max(b))])
    
""""""

l, r = map(int, input().split())
if r - l + 1 < 3:
    print(-1)
    exit()
if l % 2 == 0:
    print(l, l+1, l+2)
    exit()
if r - l + 1 > 3:
    print(l+1, l+2, l+3)
    exit()
print(-1)

    














            

        
    
            
    
    
    

















 ",constant,"brute force,implementation,math,number theory",19004
"import sys, collections, math, itertools, random, bisect
INF = sys.maxsize
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_array(): return list(map(int, sys.stdin.readline().strip().split()))
def input(): return sys.stdin.readline().strip()
mod = 1000000007

l,r = get_ints()
if r-l < 2:
    print(-1)
elif l%2 == 0:
    print(l, l+1, l+2)
elif r-l > 2:
    print(l+1, l+2, l+3)
else:
    print(-1)",constant,"brute force,implementation,math,number theory",428
"# pylint: disable=unused-variable
# pylint: enable=too-many-lines
# * Just believe in yourself


# @ Author @CAP
# import numpy
import os
import sys
from io import BytesIO, IOBase
import math as M
import itertools as ITR
from collections import defaultdict as D
from collections import Counter as C
from collections import deque as Q
import threading
from functools import lru_cache, reduce
from functools import cmp_to_key as CMP
from bisect import bisect_left as BL
from bisect import bisect_right as BR
import random as R
import string
import cmath, time

enum = enumerate
start_time = time.time()

# * Variables

MOD = 1_00_00_00_007
MA = float(""inf"")
MI = float(""-inf"")

# * Graph 8 direction
di8 = ((1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1))

# * Graph 4 direction
di4 = ((1, 0), (0, 1), (-1, 0), (0, -1))

# * Stack increment


def increase_stack():
    sys.setrecursionlimit(2 ** 32 // 2 - 1)
    threading.stack_size(1 << 27)
    # sys.setrecursionlimit(10**6)
    # threading.stack_size(10**8)
    # t = threading.Thread(target=main)
    # t.start()
    # t.join()


# * Region Funtions


def binary(n):
    return bin(n)[2:]


def decimal(s):
    return int(s, 2)


def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return p


def maxfactor(n):
    q = []
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            q.append(i)
    if q:
        return q[-1]


def factors(n):
    q = []
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            q.append(i)
            q.append(n // i)
    return list(sorted(list(set(q))))


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(M.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    l.sort()
    return l


def isPrime(n):
    if n == 1:
        return False
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if n % i == 0:
                return False
        return True


def seive(n):
    a = []
    prime = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:
        if prime[p] == True:
            for i in range(p ** 2, n + 1, p):
                prime[i] = False
        p = p + 1
    for p in range(2, n + 1):
        if prime[p]:
            a.append(p)
    prime[0] = prime[1] = False
    return a, prime


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(M.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countchar(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if s[i] == ch:
            c += 1
        else:
            break
    return c


def str_counter(a):
    q = [0] * 26
    for i in range(len(a)):
        q[ord(a[i]) - 97] = q[ord(a[i]) - 97] + 1
    return q


def lis(arr):
    n = len(arr)
    lis = [1] * n
    maximum = 0

    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
                maximum = max(maximum, lis[i])
    return maximum


def lcm(arr):
    a = arr[0]
    val = arr[0]

    for i in range(1, len(arr)):

        gcd = gcd(a, arr[i])
        a = arr[i]
        val *= arr[i]

    return val // gcd


def ncr(n, r):
    return M.factorial(n) // (M.factorial(n - r) * M.factorial(r))


def npr(n, r):
    return M.factorial(n) // M.factorial(n - r)


# * Make work easy funtions


def IF(c, t, f):
    return t if c else f


def YES(c):
    print(IF(c, ""YES"", ""NO""))


def Yes(c):
    print(IF(c, ""Yes"", ""No""))


def yes(c):
    print(IF(c, ""yes"", ""no""))


def JA(a, sep="" ""):
    print(sep.join(map(str, a)))


def JAA(a, s=""\n"", t="" ""):
    return s.join(t.join(map(str, b)) for b in a)


def PS(a, s="" ""):
    print(str(a), end=s)


# * Region Taking Input


def I():
    return int(inp())


def F():
    return float(inp())


def LI():
    return list(map(int, inp().split()))


def LF():
    return list(map(float, inp().split()))


def MATI(n):
    return [LI() for i in range(n)]


def MATS(n):
    return [list(inp()) for i in range(n)]


def IV():
    return map(int, inp().split())


def FV():
    return map(float, inp().split())


def LS():
    return list(inp())


def S():
    return inp()


# * Region Fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
inp = lambda: sys.stdin.readline().rstrip(""\r\n"")


# <==================================== Write The Useful Code Here ============================

# < Make it one if there is some test cases
TestCases = 0  # <=====================
# < =======================================
""""""
> Sometimes later becomes never. Do it now.
! Be Better than yesterday.
* Your limitation—it’s only your imagination.
> Push yourself, because no one else is going to do it for you.
? The harder you work for something, the greater you’ll feel when you achieve it.
! Great things never come from comfort zones.
* Don’t stop when you’re tired. Stop when you’re done.
> Do something today that your future self will thank you for.
? It’s going to be hard, but hard does not mean impossible.
! Sometimes we’re tested not to show our weaknesses, but to discover our strengths.
""""""
# @  Goal is to get Candidate Master


def solve():
    a, b = IV()

    if b - a + 1 < 3:
        print(""-1"")

    elif a % 2 == 0:
        print(a, a + 1, a + 2)

    elif b - a + 1 > 3:
        print(a + 1, a + 2, a + 3)
    else:
        print(-1)


# * This is the Main Function


def main():
    flag = 1
    #! Checking we are offline or not
    try:
        sys.stdin = open(
            ""c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/input.txt"",
            ""r"",
        )
        sys.stdout = open(
            ""c:/Users/Manoj Chowdary/Documents/python/CodeForces/contest-div-2/output.txt"",
            ""w"",
        )
    except:
        flag = 0

    t = 1
    if TestCases:
        t = I()
    for _ in range(1, t + 1):
        solve()

    if flag:
        print(""Time: %.4f sec"" % (time.time() - start_time))
        localtime = time.asctime(time.localtime(time.time()))
        print(localtime)
        sys.stdout.close()


# * End Region


if __name__ == ""__main__"":

    # ? Incresing Stack Limit
    # increase_stack()

    #! Calling Main Function
    main()",constant,"brute force,implementation,math,number theory",8087
"l,r = map(int,input().split())
if l%2:
    l+=1
if r-l<2:
    print(-1)
else:
    print(l,l+1,l+2)
",constant,"brute force,implementation,math,number theory",99
"l,r=map(int,input().split(' '))

def gcd(a ,b):
    if(b==0):return a
    return gcd(b,a%b)

for a in range(l,r+1):
    for b in range(a+1,r+1):
        for c in range(b+1,r+1):
            if(gcd(a,b)==1 and gcd(b,c)==1 and gcd(a,c)!=1):
                print(a,b,c)
                exit()

print(-1)
",constant,"brute force,implementation,math,number theory",302
"l,r=map(int,input().split())
if(l%2==0 and r-l>1):
    print(l,l+1,l+2,end="" "")
elif(l%2!=0 and r-l>2):
    print(l+1,l+2,l+3,end="" "")
else:
    print(""-1"")",constant,"brute force,implementation,math,number theory",156
"l,r=input().split("" "")
l,r=int(l),int(r)
if (l % 2 != 0):
    l+=1
if (l + 2 > r):
    print(-1);
else:
    print(l,l+1,l+2)
            
                
                
",constant,"brute force,implementation,math,number theory",172
"l,r=input().split("" "")
l,r=int(l),int(r)

a,b,c=l,l+1,l+2

if (l % 2 != 0):
    a,b,c=a+1,b+1,c+1
    
if (c > r):
    print(-1)
    
else:
    print(a,b,c)",constant,"brute force,implementation,math,number theory",156
"from math import gcd
# region fastio
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion


def func(l,r):
    if l==1:
        l+=1
    if r-l<2:
        return -1

    if l&1:
        if r-l>2:
            l+=1
            return '{} {} {}'.format(l,l+1,l+2)
        else:
            if gcd(l,l+2)!=1:
                return '{} {} {}'.format(l,l+1,l+2)
            return -1
    return '{} {} {}'.format(l, l + 1, l + 2)



def main():
    l,r=map(int,input().split())
    print(func(l,r))
    return


if __name__ == '__main__':
    main()
",constant,"brute force,implementation,math,number theory",2209
"from math import gcd
# region fastio
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""right"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\right\n"")


# endregion


def func(left:int, right:int):
    if left == 1:
        left += 1
    if right - left < 2:
        return -1

    if left & 1:
        if right - left > 2:
            left += 1
            return '{} {} {}'.format(left, left + 1, left + 2)
        else:
            if gcd(left, left + 2) != 1:
                return '{} {} {}'.format(left, left + 1, left + 2)
            return -1
    return '{} {} {}'.format(left, left + 1, left + 2)


def main():
    left, right = map(int, input().split())
    print(func(left, right))
    return


if __name__ == '__main__':
    main()
",constant,"brute force,implementation,math,number theory",2344
"import math

l, r = (map(int, input().split()))
a = l
if a % 2:
    a += 1

if a + 2 > r:
    print(-1)
else:
    print(a, a + 1, a + 2)",constant,"brute force,implementation,math,number theory",136
"a,b=map(int,input().split())
if max(a,b)-min(a,b) +1<=2:
    print(-1)
elif max(a,b)-min(a,b) +1==3:
    if a % 2==1 and b %2==1:
        print(-1)
    else:
        print(min(a,b),min(a,b)+1,min(a,b)+2)
else:
    ans=0
    for i in range(a,b+1):
        if i%2==0:
            ans=i
            break
    print(ans,ans+1,ans+2)",constant,"brute force,implementation,math,number theory",328
"l,r = [int(x) for x in input().split()]
if l==r or l+1==r:
    print(-1)
elif l%2==0:
    print(l,l+1,l+2)
elif l%2!=0 and r-l+1>3:
    print(l+1,l+2,l+3)
else:
    print(-1)",constant,"brute force,implementation,math,number theory",174
"l, r = map(int, input().split())
if r == l + 1 or r == l:
    print(-1)
elif l%2 == 0:
    print(l, l+1, l+2)
elif abs(r - l) >= 3:
    print(l+1, l+2, l+3)
else:
    print(-1)",constant,"brute force,implementation,math,number theory",176
"n = int(input())
if n == 1:
    print(5)
else:
    print(25)
	 	    	 		 	    		 	 			     	",constant,number theory,92
print('25'),constant,number theory,11
print(25),constant,number theory,9
"n = int(input())
print(25)",constant,number theory,26
"input()
print(25)",constant,number theory,17
"a = int(input())
print(25)",constant,number theory,26
"n=int(input())
print('25') ",constant,number theory,27
"n = int(input())
if n==1:
    print(5)
else:
    print(25)
",constant,number theory,59
"n = int(input())

if n>=2:
    print(25)
",constant,number theory,41
"n = int(input())
print(25)
",constant,number theory,27
"l = list(sorted(list(map(int,input().split()))))
if min(l) == 1 or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==4 and l[2]==4) or(l[0]==2 and l[1] == 2):
    print(""Yes"")
else:
    print(""No"")",constant,"brute force,constructive algorithms",203
"def solve():
    k = [int(x) for x in input().split(' ')]
    k.sort()
    if min(k) == 1:
        return ""YES""
    elif k.count(2) >= 2:
        return ""YES""
    elif k.count(3) == 3:
        return ""YES""
    elif k == [2, 4, 4]:
        return ""YES""
    return ""NO""


print(solve())",constant,"brute force,constructive algorithms",284
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
k1, k2, k3  = sorted(map(int, input().split()))
'''
we have 1       - obvious
2 twos          - they can cover everything
3 threes        - they can cover everything
2 3 3           - also possible. need to cover all odd numbers with 2 threes:
                2*x+1 + 3*k
                2*x+3 + 3*k
at least 1 > 3  - 
x3 + k3*i, where k3 > 3
we can choose x3, so it's >= max(x1, x2, x3)
=> need to cover:
x3+1, x3+2, x3+3, ...
we can cover x3+1 and x3+3 using 2.
?

lcm(k1, k2, k3)
xmax = max(x1, x2, x3)
xmin = min(x1, x2, x3)
one of xi can be taken as zero (just substract xmin from all)
also, it doesn't make sense to take any of xi > 0 greater than lcm
therefore, we can check interval [lcm, 2*lcm] to be covered

1 2 3 4 5 6 7 8 9 10
  x   x   x   x   x
3 3 3
x x x x x x x x x x
2 3 3 - doesn't seems to work
x x   x   x x x   x
x   x x   x x   x x

(k1 == 2 and k3 % k2 == 0) - passed 5th test
k1 == 2, k2 >= 3
2 4 4
1 2 3 4 5 6 7 8 9 10
x x x x x x x x x x
'''
# def gcd(a, b):
#     if b == 0:
#         return a
#     return gcd(b, a % b)

# gcdk = gcd(gcd(k1, k2), k3)
#lcmk = k1*k2*k3 // gcdk

if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \
    or (k1 == 2 and k2 == 4 and k3 == 4):
    print(""YES"")
else:
    print(""NO"")",constant,"brute force,constructive algorithms",1309
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
k1, k2, k3  = sorted(map(int, input().split()))
'''
k1 == 1         - obvious
2 twos          - they can cover everything
3 threes        - they can cover everything

lcm := lcm(k1, k2, k3)
xmax := max(x1, x2, x3)
xmin := min(x1, x2, x3)
one of xi can be taken as zero (just substract xmin from all)
also, it doesn't make sense to take any of xi > 0 greater than lcm
therefore, we can check interval [lcm, 2*lcm] to be covered

2 3 3           - doesn't seems to work
1 2 3 4 5 6 7 8 9 10
x x   x   x x x   x  
x   x x   x x   x x

2 4 4
1 2 3 4 5 6 7 8 9 10
x x x x x x x x x x

2 ? ?
1 2 3 4 5 6 7 8 9 10
x   x   x   x   x  
to cover 2 and 4 with one ki => ki == 2
to cover 2 and 6 with one ki => ki == 4
'''
if 1 == k1 or (2 == k1 and 2 == k2) or (3 == k1 and 3 == k2 and 3 == k3) \
    or (k1 == 2 and k2 == 4 and k3 == 4):
    print(""YES"")
else:
    print(""NO"")",constant,"brute force,constructive algorithms",913
"import sys
readline = sys.stdin.readline

k = list(map(int, readline().split()))


ans = 'NO'
if min(k) == 1 or k.count(2) >= 2 or k.count(3) >= 3 or (k.count(4) == 2 and k.count(2) == 1):
    ans = 'YES'

print(ans)",constant,"brute force,constructive algorithms",216
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

k = inpl(); k.sort()
if k.count(1) >= 1 or k.count(2) >= 2 or k.count(3) >= 3 or k == [2,4,4]:
    print('YES')
else:
    print('NO')",constant,"brute force,constructive algorithms",677
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=None):
        self.BIT=[0]*(n+1)
        self.num=n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        self.mod = mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

k = li()
k.sort()
k = tuple(k)

ans = [(2,4,4),(3,3,3)]
if k.count(1)>=1:
    print(""YES"")
elif k.count(2)>=2:
    print(""YES"")
elif k.count(3)>=3:
    print(""YES"")
elif k in ans:
    print(""YES"")
else:
    print(""NO"")
",constant,"brute force,constructive algorithms",19493
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache
#sys.setrecursionlimit(200000000)
int1 = lambda x: int(x) - 1
#def input(): return sys.stdin.readline().strip()m
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
#MOD = 1000000000 + 7
def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

def fun(A):
    for i in range(len(A)):
        if A[i] == 0:
            return i
    return 1
    
    
dp = [0]*10
A = aj();A.sort()
k1,k2,k3 = A
for i in range(0,10,k1):
    dp[i] = 1
for i in range(fun(dp),10,k2):
    dp[i] = 1
for i in range(fun(dp),10,k3):
    dp[i] = 1
Y(0 not in dp)
    
    ",constant,"brute force,constructive algorithms",886
"import sys,os,io
import math,bisect,operator
inf,mod = float('inf'),10**9+7
# sys.setrecursionlimit(10 ** 6)
from itertools import groupby,accumulate
from heapq import heapify,heappop,heappush
from collections import deque,Counter,defaultdict
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
Neo = lambda : list(map(int,input().split()))
# test, = Neo()
A = sorted(Neo())
B = [0]*100
for i in A:
    j = 0
    for c in range(100):
        if B[c] == 0:
            j = c
            break
            
    while j < 100:
        B[j] = 1
        j += i  
if B.count(0) == 0:
    print('YES')
else:
    print('NO')
",constant,"brute force,constructive algorithms",634
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)
#
dp=[0]*5001;dp[0]=1
i=0
while i<=5000:
 if dp[i]==0 and i+a[0]<=5000:
   while i+a[0]<=5000:
     dp[i]=1
     i=i+a[0]
 else:i+=1
#print(dp)
#
i=0
while i<=5000:
 if dp[i]==0 and i+a[1]<=5000:
   while i+a[1]<=5000:
     dp[i]=1
     i=i+a[1]
 else:i+=1
#print(dp)
#
i=0
while i<=5000:
 if dp[i]==0 and i+a[2]<=5000:
   while i+a[2]<=5000:
     dp[i]=1
     i=i+a[2]
 else:i+=1
#
dp=dp[:2002]
if dp.count(0)==0:print(""YES"")
else:print(""NO"")
",constant,"brute force,constructive algorithms",503
"k1,k2,k3=map(int,input().split())
a=[k1,k2,k3];a=sorted(a)
if a[0]==1 or a.count(2)>=2 or a.count(3)==3:print(""YES"")
elif a.count(4)==2 and a.count(2)==1:print(""YES"")
else:print(""NO"")
",constant,"brute force,constructive algorithms",184
"k1,k2,k3=map(int,input().split())
fl=0
for i1 in range(5):
    for i2 in range(5):
        for i3 in range(5):
            flak=1
            for i in range(8):
                if (i-i1)%k1==0 or (i-i2)%k2==0 or (i-i3)%k3==0:
                    continue
                else:
                    flak=0
            if flak==1:
                fl=1
if fl==1:
    print(""YES"")
else:
    print(""NO"")",constant,"brute force,constructive algorithms",397
"import sys
input = sys.stdin.buffer.readline
from itertools import permutations

k = list(map(int,input().split()))

worked = 0
for k1,k2,k3 in permutations(k):
    worked2 = 1
    for t in range(10000):
        if not (t % k1 == 0 or t % k2 == 1 or t % k3 == 2):
            worked2 = 0

    if worked2:
        worked = 1
        break

if worked:
    print(""YES"")
else:
    print(""NO"")
",constant,"brute force,constructive algorithms",389
"a = list(map(int,input().split()))
if a.count(1)>=1 or a.count(2)>=2 or a.count(3)==3 or (a.count(2)==1 and a.count(4)==2):
    print(""YES"")
else:
    print(""NO"")",constant,"brute force,constructive algorithms",162
"k1,k2,k3 = map(int, input().strip().split(' '))
l=[k1,k2,k3]
if min(k1,k2,k3)==1:
    print('yes')
elif l.count(2)>=2:
    print('yes')
elif l.count(3)==3:
    print('yes')
elif l.count(4)==2 and l.count(2)==1:
    print('yes')
else:
    print('no')",constant,"brute force,constructive algorithms",249
"l=list(map(int,input().split()))
l.sort()
x1=l[0]
x2=l[1]
x3=l[2]
if l[0]==1 or (l[0]==2 and l[1]==4 and l[2]==4) or (l[0]==3 and l[1]==3 and l[2]==3) or (l[0]==2 and l[1]==2):
    print(""YES"")
else:
    print(""NO"")",constant,"brute force,constructive algorithms",215
"import sys
import math
import collections
import heapq
input=sys.stdin.readline
k1,k2,k3=(int(i) for i in input().split())
l=[k1,k2,k3]
if(1 in l):
    print(""YES"")
elif(l.count(2)>=2):
    print(""YES"")
elif(l.count(3)==3):
    print(""YES"")
elif(sorted(l)==[2,4,4]):
    print(""YES"")
else:
    print(""NO"")",constant,"brute force,constructive algorithms",305
"l=list(map(int,input().split()))
s1,s2,s3,s4=0,0,0,0
for i in l:
	if i==1:
		s1+=1
	if i==2:
		s2+=1
	if i==3:
		s3+=1
	if i==4:
		s4+=1
# print(s1,s2,s3)
if s3>2 or s2>1 or s1>0 or (s4==2 and s2==1):
	print(""YES"")
else:
	print(""NO"")",constant,"brute force,constructive algorithms",233
"# import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""ot.out"",""w"")

A,B=map(int,input().split())
x,y,z=map(int,input().split())
summ=0
y1=0
b1=0
y1=(x*2)+y

b1=y+(3*z)

summ=0
if y1>A:
	summ+=y1-A
if b1>B:
	summ+=b1-B
print(summ)",constant,implementation,240
"a , b = list(map(int, input().split()))
x, y, z = list(map(int, input().split()))
ans = 0
p = a - ((x*2) + y)
q = b - ((z*3) + y)
# print(p, q)
if (p < 0 and q < 0):
    print(abs(p) + abs(q))
elif (p < 0):
    print(abs(p))
elif (q < 0):
    print(abs(q))
else:
    print(0)",constant,implementation,275
"A,B = map(int, input().split())
x,y,z = map(int, input().split())
A1 = 2*x + y - A
B1 = 3*z + y - B
final = 0
if A1 > 0:
    final = final + A1
if B1 > 0:
    final = final + B1
print(final)",constant,implementation,190
"a,b=map(int,input().split())
x,y,z=map(int,input().split())
if a < x*2+y:
    ry=x*2+y-a
else:
    ry=0
if b < y+z*3:
    rb=y+z*3-b
else:
    rb=0
print(ry+rb)",constant,implementation,160
"yellow,blue = map(int,input().split())
x,y,z = map(int,input().split())
ry = x*2+y
rb =z*3+y
r1,r2 = 0,0
if ry-yellow < 0:
    r1 = 0
else:
    r1 = ry-yellow
if rb - blue < 0:
    r2 = 0
else:
    r2 = rb-blue
print(r1+r2)
",constant,implementation,224
"h,b = map(int,input().split())
x,y,z = map(int,input().split())
print(max(0,2*x+y-h)+max(0,3*z+y-b))",constant,implementation,100
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
print(max((0,2*x+y-a))+max((0,3*z+y-b)))",constant,implementation,109
"yellow, blue = map(int, input().split())
y, g, b = map(int, input().split())

count = 0

yt = y * 2 + g
bt = g + b * 3

yc = yellow - yt
if yc < 0:
    count += abs(yc)

bc = blue - bt
if bc < 0:
    count += abs(bc)

print(count)





# while True:
#     if yellow > 0:
#         y = ny * 2
#         yellow -= y
#         yellow = yellow - g
#         break
#     else:
#         yellow += 1
#         count += 1
#         break
#
# while True:
#     if blue > 0:
#         blue = blue - g
#         nb = nb * 3
#         blue = blue - nb
#         break
#     else:
#         blue += 1
#         count += 1
#         break
#
# print(count)
",constant,implementation,643
"
# import os
 
a,b = map(int,input().split())
 
x,y,z=map(int,input().split())
 
r = 0

yellow = 2*x
blue = 3*z
green = y

if a > yellow:
    a -= yellow
else:
    r += abs(a-yellow)
    a=0

if b > blue:
    b -= blue
else:
    r += abs(b-blue)
    b=0

if a > green:
    a-= green
else:
    r += abs(a-green)

if b > green:
    b-=green
else:
    r += abs(b-green)

print(r)",constant,implementation,376
"a,d=map(int,input().split())
y,g,b=map(int,input().split())
m=y*2+g
n=b*3+g
c=0
if(m>a):
    c+=m-a
if(n>d):
    c+=n-d
print(c)
",constant,implementation,129
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7
# md = 998244353

a,b=MI()
x,y,z=MI()
yel=x*2+y
bul=y+z*3
print(max(0,yel-a)+max(0,bul-b))
",constant,implementation,583
"a,b = map(int, input().split())
x, y, z = map(int, input().split())

ans = max(0, 2*x+y-a)+max(0, 3*z+y-b)
print(ans)
",constant,implementation,118
"A, B = map(int, input().split())
x, y, z = map(int, input().split())
nA = 2*x+y
nB = 3*z+y
r = 0
if nA > A:
    r += nA-A
if nB > B:
    r += nB-B
print(r)
",constant,implementation,156
"a, b = map(int, input().split())
x, y, z = map(int, input().split())
needa = 2 * x + y
needb = y + 3 * z
print(max(0, needa - a) + max(0, needb - b))",constant,implementation,149
"R=lambda:map(int,input().split())
a,b=R()
x,y,z=R()
print(max(0,2*x+y-a)+max(0,y+3*z-b))",constant,implementation,88
"# cook your dish here

def main():
    A,B = list(map(int, input().strip().split()))
    yellow,green,blue = list(map(int, input().strip().split()))
    
    yelreq = 0
    blureq = 0
    
    # for yellow balls
    yelreq = 2*yellow
    
    # green balls 
    yelreq += green
    blureq += green
    
    # blue balls 
    blureq += 3*blue
    
    reqs = 0
    if A<yelreq:
        reqs += yelreq - A
    if B<blureq:
        reqs += blureq - B

    print(reqs)
    
main()
",constant,implementation,477
"def req_num(a, b, x, y, z):
    req_a = (x * 2) + y
    req_b = (z * 3) + y
    if (req_a - a) <= 0:
        ans_a = 0
    else:
        ans_a = req_a - a
    if (req_b - b) <= 0:
        ans_b = 0
    else:
        ans_b = req_b - b
    return ans_a + ans_b

a, b = list(map(int, input().strip().split()))
x, y, z = list(map(int, input().strip().split()))
print(req_num(a, b, x, y, z))
",constant,implementation,387
"yellow, blue = map(int, input().split())
x, y, z = map(int, input().split())
answer1 = x*2+y-yellow
answer2 = z*3+y - blue
if answer1 > 0:
    if answer2 > 0:
        print(answer1+answer2)
    else:
        print(answer1)
else:
    if answer2 > 0:
        print(answer2)
    else:
        print(0)
",constant,implementation,299
"a,b=map(int,input().split())
x,y,z=map(int,input().split())

yell=2*x+y
blue=y+3*z
res=max(0,yell-a)+max(0,blue-b)

print(res)",constant,implementation,126
"n, m = int(input()), int(input())
value = False
for j in range(n + 1):
    if pow(2, j) > m:
        value = True
        break
if value:
    print(m)
else:
    print(m % pow(2, n))
",constant,"implementation,math",182
"n=int(input())
m=int(input())
print(m%(1<<n))",constant,"implementation,math",45
"n, m = int(input()), int(input())
value = False
for j in range(n + 1):
    if pow(2, j) > m:
        value = True
        break
if value:
    print(m)
else:
    print(m % pow(2, n))",constant,"implementation,math",181
"n = int(input())
m = int(input())
if(n<=26):
    print(m%(2**n))
else:
    print(m)
    ",constant,"implementation,math",88
"def Fast_power(x , y):
    res = 1
    while y > 0 :
        if (y % 2 != 0):
            res = res * x

        y = y // 2
        x = x * x

    return res

n = int(input())
m = int(input())

if n <= 40 :
    print(m % Fast_power(2 , n))
else:
    print(m)


",constant,"implementation,math",261
"

def power(x , y):
    res = 1
    while y > 0 :
        if y % 2 != 0 :
            res = res * x
        y //= 2
        x *= x

    return res

n = int(input())
m = int(input())

if n <= 40 :
    print(m % power(2 , n))

else:
    print(m)

",constant,"implementation,math",245
"
n=int(input())
m=int(input())
# x=(2**n)
if n>(m+1)/2:
	print(m)
else:
	print(int(m%(2**n)))
# print(x)",constant,"implementation,math",104
"n = int(input())
m = int(input())
print(m % (2**n ))",constant,"implementation,math",52
"n = int(input())
m = int(input())
r = 1
for power in range(n):
    r *= 2
    if r > m:
        print(m)
        break
else:
    if r == m:
        print(0)
    else:
        print(m % r)
",constant,"implementation,math",188
"n=int(input())
m=int(input())
print(m%(pow(2,n)))",constant,"implementation,math",49
"n = int(input())
m = int(input())

print(m % pow(2, n))
",constant,"implementation,math",56
"n, m = int(input()), int(input())
print(m % (2 ** n) if n < 30 else m)",constant,"implementation,math",70
"n,m = int(input()),int(input())
if n < 27:
    print(m%2**n)
else:
    print(m)",constant,"implementation,math",79
"n=int(input())
m=int(input())
print(m%2**n)
",constant,"implementation,math",44
"import math
t=1
while t:
        t-=1
        n=int(input())
        m=int(input()) 
        if(n>=27):
                print(m)
        else:
                print(m%(pow(2,n)))
",constant,"implementation,math",179
"n = int(input())
m = int(input())
print(m%2**n)",constant,"implementation,math",47
"from sys import stdin, stdout
n = int(stdin.readline())
m = int(stdin.readline())
stdout.write(str(m%(1<<n)))",constant,"implementation,math",109
"from sys import stdin
 
def read_lines(sep=' ', input_type=None):
    #list of rows
    _lines = stdin.readlines()
    cast = input_type is not None
    lines = []
    for line in _lines:
        line = line[:-1].split(sep)
        if cast:
            line = [input_type(x) for x in line]
        lines.append(line)
    return lines

import math
        
if __name__ == '__main__':
 
    lines = read_lines(input_type=int)
    
    #t = lines[0]
    #lines = lines[1:]
    
    n,m = lines[0][0], lines[1][0]
    
    if n <= math.log2(m):
        print(m % (2**n))
    else:
        print(m)
        ",constant,"implementation,math",602
"n, pos, l, r=map(int, input().split())
if l==1 and r==n:
	print(0)
elif l==1 and r!=n:
	print(abs(pos-r)+1)
elif l!=1 and r==n:
	print(abs(pos-l)+1)
else:
	print(r-l+2+min(abs(pos-l), abs(pos-r)))",constant,implementation,196
"n, pos, l, r = map(int, input().split())
result = abs(pos - l) + r - l + 2
if (l == 1):
    if (abs(pos - r) + 1 < result):
        result = abs(pos - r) + 1
if (r == n):
    if (abs(pos - l) + 1 < result):
        result = abs(pos - l) + 1
if (l == 1 and r == n):
    result = 0
if (abs(pos - r) + r - l + 2 < result):
    result = abs(pos - r) + r - l + 2
print(result)",constant,implementation,371
"n,pos,l,r=map(int,input().split())
if l==1 and r==n:
    print(0)
elif l==1:
    print(abs(pos-r)+1)
elif r==n:
    print(abs(pos-l)+1)
else:
    print(min(abs(pos-l),abs(pos-r))+abs(l-r)+2)",constant,implementation,190
"import math
n,pos,l,r = map(int, input().strip().split(' '))
#n=int(input())
#lst = list(map(str, input().strip().split(' ')))
if l==1 and r==n:
    print(0)
elif l==1:
    if pos==r:
        print(1)
    elif pos>r:
        print(pos-r+1)
    elif pos<r:
        print(r-pos+1)
elif r==n:
    if pos==l:
        print(1)
    elif pos<l:
        print(l-pos+1)
    else:
        print(pos-l+1)
else:
    if pos>=l and pos<=r:
        if pos-l<r-pos:
            print(2+pos-l+r-l)
        else:
            print(2+r-l+r-pos)
    else:
        if pos>r:
            print(pos-r+2+r-l)
        else:
            print(l-pos+2+r-l)",constant,implementation,629
"import sys
import math
input = sys.stdin.readline
for _ in range(1):
    n,pos,l,r = map(int,input().split())
    if l == 1 and r == n:
        print(0)
        continue

    if l != 1 and r != n:
        ans = min(abs(l-pos),abs(r-pos))+2+abs(r-l)

    else:
        if l == 1:
            ans = abs(pos-r)+1

        else:
            ans = abs(pos-l)+1

    print(ans)",constant,implementation,371
"n,pos,l,r = map(int, input().split())
dl,dr = abs(pos-l) + 1, abs(pos-r) + 1
print(dr*(r<n) if l==1 else dl if r==n else min(dl,dr)+r-l+1)",constant,implementation,138
"n,p,l,r = map(int,input().split())
if l == 1 and r == n:
    print(0)
elif l==1:
    print(abs(p-r)+1)
elif r == n:
    print(abs(p - l) + 1)
else:
    print(min(abs(p-r),abs(p - l))+r-l+2)",constant,implementation,189
"def main():
	n, pos, l, r=tuple(map(int,input().split()))
	time=0
	if l!=1 and r!=n:
		if abs(pos-l)<abs(pos-r):
			time+=abs(pos-l)+abs(l-r)+2
		else:
			time+=abs(pos-r)+abs(l-r)+2
	elif l==1 and r!=n:
		time+=abs(pos-r)+1
	elif r==n and l!=1:
		time+=abs(pos-l)+1
	else:
		time+=0
	print(time)
if __name__=='__main__':
	main()",constant,implementation,329
"n, p, l, r = map(int, input().split())
if l == 1 and r == n:
    print(0)
elif l == 1:
    print(abs(p-r) + 1)
elif r == n:
    print(abs(p-l) + 1)
else:
    print(min(abs(p-l), abs(p-r)) + r - l + 2)",constant,implementation,200
"#Mamma don't raises quitter.................................................
from collections import deque as de
import math
from sys import stdin, stdout
import re
from collections import Counter as cnt
from functools import  reduce

from itertools import groupby as gb
#from fractions import Fraction as fr
from bisect import bisect_left as bl, bisect_right as br

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
    
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack() 

#decimal to binary   
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")
#binary to decimal
def binarytodecimal(n):
    return int(n,2)

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

 
# Function to get product of digits
def getProduct(n):
 
    product = 1
 
    while (n != 0):
        product = product * (n % 10)
        n = n // 10
 
    return product


#function to find LCM of two numbers
def lcm(x,y):
   lcm = (x*y)//math.gcd(x,y)
   return lcm

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 
#to check whether the given sorted sequnce is forming an AP or not....
def checkisap(list):
    d=list[1]-list[0]
    for i in range(2,len(list)):
        temp=list[i]-list[i-1]
        if temp !=d:
            return False
    return True
        
    

#ceil  function gives wrong answer after 10^17 so i have to create my own :)
# because i don't want to doubt on my solution of 900-1000 problem set.
def ceildiv(x,y): 
    return (x+y-1)//y 
  
def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(int, input()))
def indict():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(index)+1] = int(value)
    return dic
def frqdict():
    # by default it is for integer input. :)
    dic={}
    for index, value in enumerate(input().split()):
        if int(value) not in dic:
            dic[int(value)] =1
        else:
            dic[int(value)] +=1
    return dic

#inp = open(""input.txt"",""r"")
#out = open(""output.txt"",""w"")
#Here we go......................
#practice like your never won
#perform like you never lost
n,pos, l, r=di()
if l==1 and r==n:
    print(0)
else:
    if pos < l:
        ans=l-pos+1
        if r <n:
            ans+=(r-l)
            ans+=1
        print(ans)
    elif l<=pos<=r:
        if l >1 and r<n:
            ans=(r-l)
            ans+=min(pos-l,r-pos)
            ans+=2
        elif l>1 and r==n:
            ans=pos-l
            ans+=1
        else:
            ans=r-pos
            ans+=1
        print(ans)
            
            
    else:
        ans=pos-r+1
        if l>1:
            ans+=(r-l)
            ans+=1
        print(ans)


        
        
        

        

    
            
        
        
    
        
        
        


                
                

    


        
        
    
    
    
        
    
        
    




    

                
    
        


        
    

            
        
    

                
                
                
        
        
        

            

        





                    
                
            
        

            
    
        
    
    

    
        
    
 

    
        


    
        

",constant,implementation,4572
"n, pos, a, b = map(int,input().split())

lf, rf = a - 1, n - b
if lf == rf == 0:
	print(""0"")
elif lf == 0:
	print(abs(pos-b)+1)
elif rf == 0:
	print(abs(pos-a)+1)
else:
	cl = abs(a-pos) + 1
	cr = abs(b-pos) + 1
	xn = abs(a-b) + 1
	if cl < cr:
		print(cl+xn)
	else:
		print(cr+xn)",constant,implementation,279
"n, pos, l, r = map(int,input().split())
step, dif = 0, lambda a, b : abs(a - b)

if dif(pos, l) < dif(pos, r):
	if l != 1:
		step += dif(pos, l) + 1
		pos = l
	if r != n:
		step += dif(pos, r) + 1
else:
	if r != n:
		step += dif(pos, r) + 1
		pos = r
	if l != 1:
		step += dif(pos, l) + 1
print(step)
",constant,implementation,301
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
for _ in range(1):#nmbr()):
    n, cur, l, r=lst()
    if l==1 and r==n:
        print(0)
    elif l==1 and r!=n:
        print(abs(r-cur)+1)
    elif r==n and l!=1:
        print(abs(cur-l)+1)
    else:
        disa=abs(l-cur)
        disb=abs(r-cur)
        ans=min(disa, disb) + (r-l) +2
        print(ans)

",constant,implementation,415
"x=list(map(int,input().split()))
pos=x[1]
n=x[0]
l=x[2]
r=x[3]
step=0
if pos<l :
    step=l-pos+1
    
    if r< n :
        step+=r-l+1
elif pos>r:
    step=pos-r+1
    
    if l> 1 :
        step+=r-l+1
else:
    if l>1 and n>r:
        step+=min(pos-l,r-pos)+r-l+2
    elif l==1 and n>r:
        step=r-pos+1
    elif l>1 and n==r:
        step+=pos-l+1
    else:
        step=0



print(step)
",constant,implementation,397
"x=list(map(int,input().split()))
pos=x[1]
n=x[0]
l=x[2]
r=x[3]
step=0
if pos<l :
    step=l-pos+1
    
    if r< n :
        step+=r-l+1
elif pos>r:
    step=pos-r+1
    
    if l> 1 :
        step+=r-l+1
else:
    if l>1 and n>r:
        step+=min(pos-l,r-pos)+r-l+2
    elif l==1 and n>r:
        step=r-pos+1
    elif l>1 and n==r:
        step+=pos-l+1
    else:
        step=0



print(step)",constant,implementation,396
"n,pos,l,r = map(int,input().split())
if(r-l+1 == n):
    print(0)
    exit(0)
if(pos>l and pos<r):
    if(n>r and l>1):
        x = pos-l+1+r-l+1
        y = r-pos+1+r-l+1
        ans = min(x,y)
    else:
        if(n==r):
            ans = pos-l+1
        elif(l==1):
            ans = r-pos+1
elif(pos>=r):
    if(n>r):
        ans = pos-r+1
    else:
        ans = 0
    if(l>1):
        ans+=r-l+1
elif(pos<=l):
    if(l>1):
        ans = l-pos+1
    else:
        ans = 0
    if(n>r):
        ans+=r-l+1
print(ans)
    ",constant,implementation,524
"n=int(input())
print((n//2)+1)",constant,math,30
"n=int(input())
print(int(n/2+1))",constant,math,32
"import math
num=int(input())
k=math.ceil(num/2)
if num%2==0:
    print(k+1)
else:
    print(k)",constant,math,94
"n=int(input())
print(int(n/2)+1)",constant,math,32
"# A. Splits

n = int(input())

# Editorial - https://codeforces.com/blog/entry/58991
print(n//2 + 1)
",constant,math,101
"# cook your dish here
n=int(input())
print(int(n/2)+1)",constant,math,54
"n = int(input())
print(n//2+1)",constant,math,30
print(int(input()) // 2 + 1),constant,math,28
print((int(input()))//2+1),constant,math,26
"'''     Design by Dinh Viet Anh(JOKER)
//_____________________________________$$$$$__
//___________________________________$$$$$$$$$
//___________________________________$$$___$
//___________________________$$$____$$$$
//_________________________$$$$$$$__$$$$$$$$$$$
//_______________________$$$$$$$$$___$$$$$$$$$$$
//_______________________$$$___$______$$$$$$$$$$
//________________$$$$__$$$$_________________$$$
//_____________$__$$$$__$$$$$$$$$$$_____$____$$$
//__________$$$___$$$$___$$$$$$$$$$$__$$$$__$$$$
//_________$$$$___$$$$$___$$$$$$$$$$__$$$$$$$$$
//____$____$$$_____$$$$__________$$$___$$$$$$$
//__$$$$__$$$$_____$$$$_____$____$$$_____$
//__$$$$__$$$_______$$$$__$$$$$$$$$$
//___$$$$$$$$$______$$$$__$$$$$$$$$
//___$$$$$$$$$$_____$$$$___$$$$$$
//___$$$$$$$$$$$_____$$$
//____$$$$$$$$$$$____$$$$
//____$$$$$__$$$$$___$$$
//____$$$$$___$$$$$$
//____$$$$$____$$$
//_____$$$$
//_____$$$$
//_____$$$$
'''
from math import *
from cmath import *
from itertools import *
from decimal import *  # su dung voi so thuc
from fractions import *  # su dung voi phan so
from sys import *
from types import CodeType, new_class
#from numpy import *

'''getcontext().prec = x # lay x-1 chu so sau giay phay (thuoc decimal)
Decimal('12.3') la 12.3 nhung Decimal(12.3) la 12.30000000012
Fraction(a) # tra ra phan so bang a (Fraction('1.23') la 123/100 Fraction(1.23) la so khac (thuoc Fraction)
a = complex(c, d) a = c + d(i) (c = a.real, d = a.imag)
a.capitalize() bien ki tu dau cua a(string) thanh chu hoa, a.lower() bien a thanh chu thuong, tuong tu voi a.upper()
a.swapcase() doi nguoc hoa thuong, a.title() bien chu hoa sau dau cach, a.replace('a', 'b', slg)
chr(i) ki tu ma i ord(c) ma ki tu c
a.join['a', 'b', 'c'] = 'a'a'b'a'c, a.strip('a') bo dau va cuoi ki tu 'a'(rstrip, lstrip)
a.split('a', slg = -1) cat theo ki tu 'a' slg lan(rsplit(), lsplit()), a.count('aa', dau = 0, cuoi= len(a)) dem slg
a.startswith('a', dau = 0, cuoi = len(a)) co bat dau bang 'a' ko(tuong tu endswith())
a.index(""aa"") vi tri dau tien xuat hien (rfind())
input = open("".inp"", mode='r')  a = input.readline()
out = open("".out"", mode='w') a.index(val) '''
#inn = open("".inp"", ""r"")

n = int(input())
print(n//2+1)",constant,math,2191
"n = int(input())
print(n // 2 + 1)",constant,math,34
"n=int(input())
print(n//2+1)",constant,math,28
"n = int(input())
ans = 1+n//2
print(ans)
",constant,math,41
"n=int(input())
print((n//2)+1)
",constant,math,31
"n = int(input())
print((n//2)+1)",constant,math,32
"print(int(input())//2 + 1)
",constant,math,27
"x=int(input())
d=x//2
print(d+1)
",constant,math,33
"n=int(input())
print((n+2)//2)",constant,math,30
"k, n, s, p = map(int, input().split())
L = (n - 1) // s + 1
L *= k
print((L - 1) // p + 1)",constant,math,90
"k,n,s,p = map(int,input().split())
print(int((int((n+s-1)/s)*k+p-1)/p))",constant,math,71
"import math

k,n,s,p = input().split()
k = int(k)      #no of person
n = int(n)      #no of planes each will make
s = int(s)      #no of planes that can be made in one sheet
p = int(p)      #no of sheet in one pack

sheet_for_each_person = math.ceil(n/s)
# print(sheet_for_each_person)
total_sheets_required = k*sheet_for_each_person
# print(total_sheets_required)
no_of_packs = math.ceil( total_sheets_required/p )
print(no_of_packs)",constant,math,434
"from math import *
k,n,s,p = map(int,input().split())
sheetsforone = ceil(n/s)
sheetsfork = sheetsforone*k
packs = ceil(sheetsfork/p)
print(int(packs))",constant,math,151
"# A. Paper Airplanes

k, n, s, p = map(int, input().split())

sheets = (n + s - 1) // s

print((sheets * k + p - 1) // p)

",constant,math,123
"from sys import stdin,stdout
from math import ceil
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):#nmbr()):
    k,n,s,p=lst()
    spp=ceil(n/s)
    tots=spp*k
    print(ceil(tots/p))
									 	 	 	  	   	    		 		",constant,math,277
"from math import ceil
def paper(a,b,c,d):
    return ceil((a*(ceil(b/c)))/d)

a,b,c,d=map(int,input().strip().split())
print(paper(a,b,c,d))",constant,math,140
"from math import ceil

k, n, s, p = map(int, input().split())
n_sheets = ceil(n / s)* k
n_p = ceil(n_sheets / p)
print(n_p)",constant,math,123
"'''     Design by Dinh Viet Anh(JOKER)
//_____________________________________$$$$$__
//___________________________________$$$$$$$$$
//___________________________________$$$___$
//___________________________$$$____$$$$
//_________________________$$$$$$$__$$$$$$$$$$$
//_______________________$$$$$$$$$___$$$$$$$$$$$
//_______________________$$$___$______$$$$$$$$$$
//________________$$$$__$$$$_________________$$$
//_____________$__$$$$__$$$$$$$$$$$_____$____$$$
//__________$$$___$$$$___$$$$$$$$$$$__$$$$__$$$$
//_________$$$$___$$$$$___$$$$$$$$$$__$$$$$$$$$
//____$____$$$_____$$$$__________$$$___$$$$$$$
//__$$$$__$$$$_____$$$$_____$____$$$_____$
//__$$$$__$$$_______$$$$__$$$$$$$$$$
//___$$$$$$$$$______$$$$__$$$$$$$$$
//___$$$$$$$$$$_____$$$$___$$$$$$
//___$$$$$$$$$$$_____$$$
//____$$$$$$$$$$$____$$$$
//____$$$$$__$$$$$___$$$
//____$$$$$___$$$$$$
//____$$$$$____$$$
//_____$$$$
//_____$$$$
//_____$$$$
'''
from math import *
from cmath import *
from itertools import *
from decimal import *  # su dung voi so thuc
from fractions import *  # su dung voi phan so
from sys import *
from types import CodeType, new_class
#from numpy import *

'''getcontext().prec = x # lay x-1 chu so sau giay phay (thuoc decimal)
Decimal('12.3') la 12.3 nhung Decimal(12.3) la 12.30000000012
Fraction(a) # tra ra phan so bang a (Fraction('1.23') la 123/100 Fraction(1.23) la so khac (thuoc Fraction)
a = complex(c, d) a = c + d(i) (c = a.real, d = a.imag)
a.capitalize() bien ki tu dau cua a(string) thanh chu hoa, a.lower() bien a thanh chu thuong, tuong tu voi a.upper()
a.swapcase() doi nguoc hoa thuong, a.title() bien chu hoa sau dau cach, a.replace('a', 'b', slg)
chr(i) ki tu ma i ord(c) ma ki tu c
a.join['a', 'b', 'c'] = 'a'a'b'a'c, a.strip('a') bo dau va cuoi ki tu 'a'(rstrip, lstrip)
a.split('a', slg = -1) cat theo ki tu 'a' slg lan(rsplit(), lsplit()), a.count('aa', dau = 0, cuoi= len(a)) dem slg
a.startswith('a', dau = 0, cuoi = len(a)) co bat dau bang 'a' ko(tuong tu endswith())
a.index(""aa"") vi tri dau tien xuat hien (rfind())
input = open("".inp"", mode='r')  a = input.readline()
out = open("".out"", mode='w') a.index(val) '''
#inn = open("".inp"", ""r"")

k, n, s, p = map(int, input().split())
print((k*(n//s + (n%s != 0))) // p + ((k*(n//s + (n%s != 0))) % p != 0))",constant,math,2272
"k, n, s, p = map(int, input().split())
print(((n + s - 1) // s * k + p - 1) // p)",constant,math,81
"k,n,s,p=map(int,input().split())
a=n//s
if(n%s!=0):
    a+=1
q=k*a
m=q//p
if(q%p!=0):
    m+=1
print(m)
    

",constant,math,110
"k,n,s,p = map(int, input().split())
q = (n+s-1)//s
ans = (q*k+p-1)//p
print(ans)
",constant,math,81
"import math
def solve():
    words = input().split()
    people = int(words[0])
    planes_each = int(words[1])
    per = int(words[2])
    sheets = int(words[3])
    sheets_per_person = math.ceil(planes_each/per)
    needed = sheets_per_person*people
    packs = math.ceil(needed/sheets)
    print(packs)

    

# for _ in range(int(input())):
solve()",constant,math,352
"k,n,s,p=map(int,input().split())
c=(n//s) if n%s==0 else (n//s)+1
print((c*k)//p if (c*k)%p==0 else ((c*k)//p)+1)

",constant,math,115
"k,n,s,p = map(int,input().split())
x = (n+s-1)//s
x *= k
print((x+p-1)//p)


",constant,math,77
"k,n,s,p=map(int,input().split(' '))
if (1*n)%s==0:
    need=(1*n)//s
    if need==0 and k%p==0:
        print(k//p)
    elif (k*need)%p==0:
        print((k*need)//p)
    else:
        print(((k*need)//p)+1)    
else:
    need=((1*n)//s)+1
    if need==0 and k%p==0:
        print(k//p)
    elif (k*need)%p==0:
        print((k*need)//p)
    else:
        print(((k*need)//p)+1)    ",constant,math,382
"k, n, s, p = map(int, input().split())

paper_person = (n + s -1)//s

total_needed = paper_person * k

ans = (total_needed+p-1)//p

print(ans)


",constant,math,145
"import math
k, n, s, p = map(int, input().split())
sheets = math.ceil(n/s) * k
print(math.ceil(sheets/p))
 	  										  	 		 				",constant,math,131
"import math
k,n,s,p=[int(x) for x in input().split()]
x=math.ceil(n/s)
y=math.ceil(x*k/p)
print(y)",constant,math,98
"from sys import stdin,stdout
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
def fn(p):
    turns=b[p]//14
    a=b.copy();sm=0
    a[p]=0
    for i in range(1,15):
        a[(p+i)%14]+=turns
    rem=b[p]%14
    for i in range(p+1,p+rem+1,1):
        a[(i%14)]+=1
    for i in range(14):
        if a[i]&1==0:
            sm+=a[i]
    # print(a)
    return sm
for _ in range(1):#nmbr()):
    b=lst()
    ans=0
    for i in range(14):
        if b[i]!=0:ans=max(ans,fn(i))
    print(ans)
",constant,"brute force,implementation",530
"if __name__ == '__main__':
    a = [int(i) for i in input().split()]

    mx = -1

    for i in range(14):
        b = a.copy()
        if a[i]:
            b[i], d, ans = 0, i + 1, 0
            r = (a[i] + d) // 14
            l = (a[i] + d) % 14

            if d + a[i] < 14:
                ans = sum([j + 1 for j in a[d:d + a[i]] if not (j + 1) % 2])
            else:
                for j in range(14):
                    b[j] += r
                if d > l:
                    for j in range(l, d):
                        b[j] -= 1
                else:
                    for j in range(d, d + abs(d - l)):
                        b[j] += 1
                ans = sum([p for p in b if not p % 2])
            mx = max(mx, ans)

    print(mx)
",constant,"brute force,implementation",754
"A = list(map(int, input().split()))

ans = 0
for i in range(14):
    if A[i] == 0:
        continue
    B = A+A
    B[i+14] = 0
    q, r = divmod(B[i], 14)
    for j in range(1, 15):
        if j <= r:
            B[i+j] += (q+1)
        else:
            B[i+j] += q
    #print(A[i], B)
    temp = 0
    for j in range(i+1, i+15):
        if B[j]%2 == 0:
            temp += B[j]
    ans = max(ans, temp)
print(ans)
",constant,"brute force,implementation",417
"a = list(map(int, input().split()))
n = len(a)
k = [i for i in a]
lst = []
for i in range(n):
    p = k[i]%n
    ans = 0
    a = k[i+1:] + k[:i+1]
    a[-1] = 0
    for j in range(n):
        if (a[j] + 1 + int(k[i]//n))%2 == 0 and j < p:
            ans += a[j] + 1 + int(k[i]//n)
        elif (a[j] + int(k[i]//n))%2 == 0 and j >= p:
            ans += a[j] + int(k[i]//n)
    lst.append(ans)

print(max(lst))
",constant,"brute force,implementation",412
"# Fast IO Region
import os
import sys
from io import BytesIO ,IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# Get out of main functoin
def main():
    pass
# decimal to binary
def binary(n):
    return (bin(n).replace(""0b"", """"))
# binary to decimal
def decimal(s):
    return (int(s, 2))
# power of a number base 2
def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
# if  number is prime in √n time
def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
# list to string ,no spaces
def lts(l):
    s = ''.join(map(str, l))
    return s
# String to list
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# Sieve for prime numbers in a range
def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1
            # print(p)
    return (cnt)
# for positive integerse only
def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)
# 1000000007
mod = int(1e9) + 7
def ssinp(): return input()
# s=input()
def iinp(): return int(input())
# n=int(input())
def nninp(): return map(int ,input().split())
# a,b,c=map(int,input().split())
def llinp(): return list(map(int ,input().split()))
# a=list(map(int,input().split()))
def p(xyz): print(xyz)
def p2(a ,b): print(a ,b)
import math

# import random
# sys.setrecursionlimit(300000)
# from fractions import Fraction
from collections import OrderedDict
# from collections import deque
########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################
########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################
########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################
########################                         from collections import deque                              ########################
########################                         ASCII of A-Z= 65-90                                        ########################
########################                         ASCII of a-z= 97-122                                       ########################
########################                         d1.setdefault(key, []).append(value)                       ########################
#for __ in range(iinp()):
a=llinp()
ans=0
for i in range(14):
    temp=a.copy()
    nos=temp[i]
    temp[i]=0
    for j in range(i+1,14):
        temp[j]+=1
        nos-=1
    for j in range(0,14):
        temp[j]+=nos//14
    nos=nos%14
    j=0
    while(nos!=0):
        temp[j]+=1
        nos-=1
        j+=1
    ans1=0
    for c in temp:
        if(c%2==0):
            ans1+=c
    ans=max(ans,ans1)
p(ans)



























",constant,"brute force,implementation",5264
"from copy import copy

a = list(map(int, input().split()))

ans = 0
for i in range(14):
    b = copy(a)
    b[i] = 0

    for j in range(1, 14 + 1):
        b[(i + j) % 14] += (a[i] - 1) // 14 + ((a[i] - 1) % 14 + 1 > j - 1)

    ans = max(ans, sum(el * (el % 2 == 0) for el in b))

print(ans)
",constant,"brute force,implementation",294
"
stones = list(map(int,input().split())) 
initial_sum = 0

def even_sum(arr):
    temp_sum = 0
    for each in arr:
        if(each%2 == 0):
            temp_sum += each 
        
    return temp_sum   
    
initial_sum = even_sum(stones)            
dup_sum = initial_sum 

for i in range(14):
    duplicate = list(stones)
    temp = stones[i]
    duplicate[i] = 0
    j = i
    
    for each in range(14):
        duplicate[each] += temp//14
    temp = temp%14 
    while temp > 0 :
        if( j == 13):
            j = -1 
        j += 1 
        duplicate[j] += 1
        temp -= 1 
    
    ts = even_sum(duplicate)
    if(ts > initial_sum ):
        initial_sum = ts
        
print(initial_sum)
",constant,"brute force,implementation",702
"l = list(map(int,input().split()))
n = 0
m=-1
while(n<14):
    c=0
    g = l.copy()
    div = l[n]//14
    h = l[n]%14
    i = n+1
    sum = div*14
    g[n]=0
    while(sum):
        if i==14:
            i=0
        g[i]+=div
        sum-=div
        i+=1
    i = n+1
    while(h):
        if i==14:
            i=0
        g[i]+=1
        h-=1
        i+=1
    for j in g:
        if j%2==0:
            c+=j

    m = max(c,m)
    n+=1
print(m)

",constant,"brute force,implementation",448
"a=list(map(int,input().split()))
mr=0
for t in range(14):
    b=list(a)
    m=b[t]
    k=t
    i=1
    b[k]=0
    while(m>0):
        if(m//14==0):
            b[(k+i)%14]+=1
            m-=1
            i+=1
        else:
            q=m//14
            for c in range(14):
                b[c]+=q
            m-=14*q
    p=sum([ x  for x in b if x%2==0 ])
    mr=max(p,mr)
print(mr)
        
        
",constant,"brute force,implementation",403
"l=list(map(int,input().split()))
ans=0
for i in range(14):
	a=[]
	m=0
	a.extend(l)
	c=a[i]//14
	d=a[i]%14
	a[i]=0
	j=1
	while(j<=d):
		k=(i+j)%14
		a[k]+=1
		j+=1
	for j in range(14):
		a[j]+=c
		if a[j]%2==0:
			m+=a[j]
	ans=max(ans, m)
print(ans)",constant,"brute force,implementation",248
"import os
import sys
from io import BytesIO, IOBase
from collections import *
from itertools import *
from functools import *
from math import *
# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion
# Start Here

A = [int(n) for n in input().split()]
N = len(A)
dp = [0] * N
for i in range(N):
    B = A.copy()
    each = B[i] // N
    curr = B[i]
    B[i] = 0
    for j in range(N):
        B[j] += each
    for j in range(1, (curr - each * N) + 1):
        B[(i + j) % N] += 1
    for M in B:
        if M % 2 == 0:
            dp[i] += M
print(max(dp))",constant,"brute force,implementation",2182
"grid = list(map(int,input().split()))
max_res = 0
for i in range(14):
    g_c = grid.copy()
    Amount = g_c[i]//14
    Amount_r = g_c[i]%14
    if(Amount > 0):    
        for j in range(14):
            if i != (i+j+1)%14:
                g_c[(i+j+1)%14]+=Amount
                g_c[i]-=Amount    
    if Amount_r > 0:
        for j in range(14):
            if Amount_r > 0:
                if i != (i+j+1)%14:
                    g_c[(i+j+1)%14]+=1
                    Amount_r-=1
                    g_c[i]-=1
            else:
                break
    
    res = 0
    for i in range(14):
        if g_c[i] % 2 ==0:    
            res+=g_c[i]
      
    max_res = max(max_res,res)

print(max_res)  
    ",constant,"brute force,implementation",711
"a=list(map(int, input().split()))
h=0
for i in range(14):
    b=a[:]
    if i==13:
        j=0
    else:
        j=i+1
    if a[i]>0:
        c=0
        t=b[i]%14
        x=b[i]//14
        b[i]=0
        # print(b)
        for i in range(14):
            b[i]+=x
        # print(b)
        while t>0:
            b[j]+=1
            j+=1
            if j==14:
                j=0
            t-=1
        for i in range(14):
            if b[i]%2==0:
                c+=b[i]
        # print(b)
        if c>h:
            h=c
print(h)






",constant,"brute force,implementation",543
"import math

v = [int(x) for x in input().split()]
n = len(v)
val = 0
for i in range(n):
    a = v[i] // n
    arr = v.copy()
    arr[i] = 0
    for j in range(n):
        arr[j] += a
    b = v[i] % n
    k = i + 1
    l = 0
    while l < b:
        if k > n - 1:
            k = 0
        arr[k] += 1
        k += 1
        l += 1

    count = 0
    for j in range(n):
        if arr[j] % 2 == 0:
            count += arr[j]
    val = max(val, count)
print(val)





",constant,"brute force,implementation",468
"def f(a, ind):
    if a[ind] == 0:
        return -1
    k = a[ind] // 14
    x = a[ind] % 14
    b = a[:]
    b[ind] = 0
    for j in range(14):
        b[j] += k
    for j in range(ind + 1, ind + x + 1):
        j1 = j % 14
        b[j1] += 1
    res = 0
    for j in range(14):
        if b[j] % 2 == 0:
            res += b[j]
    return res
a = list(map(int, input().split()))
ans = 0
for i in range(14):
    cur = f(a, i)
    ans = max(ans, cur)
print(ans)",constant,"brute force,implementation",462
"def score(l):
    return sum(x*(x%2 == 0) for x in l)

res = 0
ns = list(map(int, input().split()))
for i in range(14):
    l = list(ns)
    for j in range(13):
        l[(i+1+j) % 14] += l[i]//14 + (1 if (j+1) <= l[i]%14 else 0)
    l[i] = l[i]//14
    res = max(res, score(l))

print(res)
",constant,"brute force,implementation",291
"xs = [int(x) for x in input().split()]

res = 0
for i in range(14):
    newxs = xs[:]
    newxs[i] = 0
    for j in range(14):
        newxs[j] += xs[i] // 14
    
    for j in range(xs[i] % 14):
        newxs[(i + 1 + j) % 14] += 1
    
    res = max(res, sum(val for val in newxs if val % 2 == 0))

print(res)
",constant,"brute force,implementation",312
"b = list(map(int, input().split()))
n = 14
ans = 0
for i in range(n):
    a = b.copy()
    if a[i] == 0: 
        continue
    x = a[i]
    a[i] = 0
    full = x // n
    xex = x % n
    for j in range(n):
        a[j] += full
    for j in range(xex):
        a[(i + j + 1) % n] += 1
    pot = 0
    for j in a:
        if j % 2 == 0:
            pot += j
    ans = max(ans, pot)
print(ans)


",constant,"brute force,implementation",393
"a = list(map(int, input().split()))

ans = 0
for i in range(len(a)):
    x = a[i]
    b = [j for j in a]
    b[i] = 0
    for j in range(len(a)):
        b[j] += x // 14
    
    for j in range(1, x % 14 + 1):
        b[(i + j) % 14] += 1
        
    ans_now = 0
    for j in b:
        if j % 2 == 0:
            ans_now += j
    ans = max(ans_now, ans)
print(ans)",constant,"brute force,implementation",366
"import sys
n=int(input())
if n==0:
	print(0)
	sys.exit()
if (n+1)%2==0:
	print((n+1)//2)
else:
	print(n+1)",constant,math,106
"import os
import sys
from math import *
from collections import *

# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase


def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6


def Ceil(a, b):
    return a // b + int(a % b > 0)


def value():
    return tuple(map(int, input().split()))


def array():
    return [int(i) for i in input().split()]


def Int():
    return int(input())


def Str():
    return input()


def arrayS():
    return [i for i in input().split()]


# -------------------------code---------------------------#

n = int(input())
if n == 0:
    print(0)
else:
    print(n // 2 + 1 if n % 2 != 0 else n + 1)
",constant,math,2434
"a=input()
b=int(a)+1
if b==1 :
    print(""0"")
elif b%2==0 :
    print(b//2)
elif b%2!=0 : 
    print(b)",constant,math,103
"n = int(input())
if n == 0:
    print(0)
else:
    if n % 2 == 0:
        print(n+1) 
    else:
        print((n+1)//2)

 	 		  	  	 					     				 	 		",constant,math,152
"n = int(input()) + 1
if n == 1:
    print(0)
    exit()
print(n if n % 2 else n // 2)
",constant,math,86
"n = int(input())+1
print(0 if not (n-1) else n//2 if not n&1 else n)",constant,math,68
"n=int(input())
if(n==0):
    print(0)
elif(n%2!=0):
    print((n+1)//2)
else:
    print(n+1)
",constant,math,93
"n = int(input())
n+=1
if n==1:
	print(0)
elif n%2==0:
	print(n//2)
elif n%2!=0 and n!=1:
	print(n)",constant,math,98
"n=int(input())
n+=1
if(n==1):print(0)
elif n%2==0:print(n//2)
else :print(n)",constant,math,76
"n=int(input())+1
if n<2:
    print(0)
elif n%2==0:
    print(n//2)
else:
    print(n)",constant,math,85
"n = int(input())
if n == 0:
    print(0)
else:
    if n % 2 == 0:
        print(n+1) 
    else:
        print((n+1)//2)",constant,math,119
"n=int(input())+1
if n==1:
    print(0)
elif n%2:
    print(n)
else:
    print(n//2)",constant,math,83
"n = int(input()) + 1

if n == 1:
    print(0)
else:
    if n % 2:
        print(n)
    else:
        print(n // 2)",constant,math,114
"n = int(input())
if n==0:
    print(0)
elif n%2==1:
    print((n+1)//2)
else:
    print(n+1)",constant,math,92
"n = int(input())
if n % 2 == 1:
    print((n + 2) // 2)
elif n > 0:
    print(n + 1)
else:
    print(0)
    ",constant,math,108
"from sys import stdin
n = int(stdin.readline()) + 1
if n == 1:
    print(0)
else:
    print(n//2 if n%2 == 0 else n)",constant,math,116
"n=int(input())
n+=1

if n%2==0 or n==1:
	print(n//2)
else:
	print(n)",constant,math,68
"#Winners never quit, Quitters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 
def ceildiv(x,y): return (x+y-1)//y #ceil  function gives wrong answer after 10^17 so i have to create my own :)
# because i don't want to doubt on my solution of 900-1000 problem set.  

#here we go......................
#Winners never quit, Quitters never win
n=int(input())
if n==0:
    print(0)
else:
    if (n+1)%2:
        print(n+1)
    else:
        print((n+1)//2)
        


    
        
        
",constant,math,2328
"lst = []
ans = {'purple' : 'Power', 'green' : 'Time', 'blue': 'Space', ""orange"" : ""Soul"", ""red"" : ""Reality"", ""yellow"" : ""Mind""}
for i in range(int(input())):
    lst.append(input())
a = []
for i in ans.keys():
    if i not in lst:
        a.append(ans[i])
print(len(a))
for i in a:
    print(i)",constant,implementation,294
"dic = {'purple':'Power', 'green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}
n = int(input())
a = []
for i in range(n):
    a.append(input())
print(6-len(a))
for i in dic:
    if i not in a:
        print(dic[i])",constant,implementation,239
"
d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"",""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}

i = int(input())
l = []
for x in range(i):
    d.pop(input())

print(len(d))
for i in d.values() : print(i)",constant,implementation,213
"n=int(input())
d={""purple"":""Power"",""green"":""Time"",""blue"":""Space"",""orange"":""Soul"",""red"":""Reality"",""yellow"":""Mind""}
l=[]
for i in range(n):
    s=input()
    l.append(s)
print(6-n)
for i in d:
    if i not in l:
        print(d[i])",constant,implementation,229
"n=int(input())
s=['Power','Time','Space','Soul','Reality','Mind']
for _ in range(n):
    i=input()
    if(i=='purple'):
        s.remove('Power')
    elif(i=='green'):
        s.remove('Time')
    elif(i=='blue'):
        s.remove('Space')
    elif(i=='orange'):
        s.remove('Soul')
    elif(i=='red'):
        s.remove('Reality')
    elif(i=='yellow'):
        s.remove('Mind')
print(len(s))
for i in range(len(s)):
    print(s[i])
    ",constant,implementation,442
"my_list = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""yellow"":""Mind"", ""red"":""Reality""}

n = int(input())
for i in range(n):
    my_list.pop(input())

print(len(my_list))
for i in my_list:
    print(my_list[i])",constant,implementation,234
"kol = int(input())

dic = {'purple': 'Power',
       'green': 'Time',
       'blue': 'Space',
       'orange': 'Soul',
       'red': 'Reality',
       'yellow': 'Mind'}

r = []
g = []
missing = 6 - kol

for k in range(kol):
    rocks = input()
    r.append(rocks)

for key in dic:
    if r.count(key) == 0:
        g.append(dic[key])

print(missing)

for stone in g:
    print(stone)",constant,implementation,383
"# import os

n = int(input())

gems = {'purple':'Power', 'green':'Time', 'blue': 'Space',
    'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}

gems_in = []
for _ in range(n):
    gems_in.append(input())

print(6-len(gems_in))
r = list(set(gems) - set(gems_in))
for gem in r:
    print(gems[gem])
",constant,implementation,302
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"", ""yellow"":""Mind""}
s = set()
n = int(input())
for _ in range(n):
	w = input()
	s.add(w)
print(6 - n)
for (key, value) in d.items():
	if key not in s:
		print(value)",constant,implementation,251
"n = int(input())
d = {'red':'Reality', 'purple': 'Power', 'yellow':'Mind', 'orange':'Soul','blue':'Space','green':'Time'}
stones = ['Reality', 'Power', 'Mind', 'Soul', 'Space', 'Time']
st=[]
for _ in range(n):
    st.append(d[input()])
b=[]
for a in stones:
    if a not in st:
        b.append(a)
print(len(b))
for k in b:
    print(k)",constant,implementation,336
"# sys.setrecursionlimit(300000)
import sys
def main():
    pass
def binary(n):
    # decimal to binary
    return (bin(n).replace(""0b"", """"))
def decimal(s):
    # binary to decimal
    return (int(s, 2))
def pow2(n):
    # power of a number base 2
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
def isPrime(n):
    # if  number is prime in √n time
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
def lts(l):
    # list to string ,no spaces
    s = ''.join(map(str, l))
    return s
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# 1000000007
mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()
#s=input()
def iinp(): return int(input())
#n=int(input())
def nninp(): return map(int, sys.stdin.readline().strip().split())
#n, m, a=[int(x) for x in input().split()]
def llinp(): return list(map(int, sys.stdin.readline().strip().split()))
#a=list(map(int,input().split()))
def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
from collections import OrderedDict
#for _ in range(iinp()):
n=iinp()
l=[]
s={""purple"",""green"",""blue"",""orange"",""red"",""yellow""}
for i in range(n):
    inp=ssinp()
    s.remove(inp)
print(6-n)
for i in s:
    if(i==""purple""):
        print(""Power"")
    elif(i==""green""):
        print(""Time"")
    elif(i==""blue""):
        print(""Space"")
    elif (i == ""orange""):
        print(""Soul"")
    elif (i == ""red""):
        print(""Reality"")
    else:
        print(""Mind"")

",constant,implementation,2048
"d = {
    ""purple"": ""Power"",
    ""green"": ""Time"",
    ""blue"": ""Space"",
    ""orange"": ""Soul"",
    ""red"": ""Reality"",
    ""yellow"": ""Mind"",
}

all_colors = list(d.keys())

n = int(input())
colors = [input() for i in range(n)]

print(len(d) - len(colors))
for color in all_colors:
    if color not in colors:
        print(d[color])
",constant,implementation,329
"dict={""Power"":""purple"",
      ""Time"":""green"",
      ""Space"":""blue"",
      ""Soul"":""orange"",
      ""Reality"":""red"",
      ""Mind"":""yellow""}
dict1={}
n=(int(input()))
while n:
    str=input()
    if str==""purple"":
        dict1[""Power""]=str
    elif str==""green"":
        dict1[""Time""]=str
    elif str==""blue"":
        dict1[""Space""]=str
    elif str==""orange"":
        dict1[""Soul""]=str
    elif str==""red"":
        dict1[""Reality""]=str
    elif str==""yellow"":
        dict1[""Mind""]=str
    n-=1

val=list(dict.keys())
val_list=list(dict1.keys())
l=[key for key in val if key not in val_list]
print(len(l))
for i in range(len(l)):
    print(l[i])",constant,implementation,644
"n=int(input())
l=[]
for i in range(n):
    s=str(input())
    l.append(s)
print(6-n)  
if ""purple"" not in l:
    print(""Power"")
if ""green"" not in l:
    print(""Time"")
if ""red"" not in l:
    print(""Reality"")
if ""blue"" not in l:
    print(""Space"")
if ""orange"" not in l:
    print(""Soul"")
if ""yellow"" not in l:
    print(""Mind"")
",constant,implementation,326
"import sys
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, sys.stdin.readline().strip().split()) 
def listinput(): return list(map(int, sys.stdin.readline().strip().split())) 
n=iinput()
color=['purple','green','blue','orange','red','yellow']
gem=['Power','Time','Space','Soul','Reality','Mind']
for _ in range(n):
    s=input()
    indexofcolor=color.index(s)
    color.remove(s)
    gem.pop(indexofcolor)
print(len(gem))
for i in gem:
    print(i)",constant,implementation,521
"n = int(input())
li1 = []
s=""""
li2 = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"",""yellow"":""Mind""}
for i in range(n):
    s = input()
    li1.append(s)
print(6-n)
for key in li2:
    if key in li1:
        continue
    else:
        li1.append(key)
        print(li2[key])",constant,implementation,311
"allcolor=['purple','green','blue','orange','red','yellow']
op=['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind']
n=int(input())
ipcolor=[]
for i in range(0,n):
    color=input()
    ipcolor.append(color)
diff=list(set(allcolor) - set(ipcolor))
print(len(diff))
for i in range(0,len(diff)):
    print(op[allcolor.index(diff[i])])",constant,implementation,331
"d={'purple':'Power','green':'Time','blue':'Space','orange':'Soul','red':'Reality','yellow':'Mind'}
for _ in[0]*int(input()):d.pop(input())
print(len(d),*d.values(),sep='\n')",constant,implementation,173
"d = {""purple"":""Power"", ""green"":""Time"", ""blue"":""Space"", ""orange"":""Soul"", ""red"":""Reality"", ""yellow"":""Mind""}
s = set()
n = int(input())
for _ in range(n):
	w = input()
	s.add(w)
print(6 - n)
for (key, value) in d.items():
	if key not in s:
		print(value)
 ",constant,implementation,253
"a, b, c, n = [int(j) for j in input().split()]
a -= c
b -= c
if n - a - b - c >= 1 and a >= 0 and b >= 0:
    print(n - a - b - c)
else:
    print(-1)
",constant,implementation,151
"a,b,c,n=map(int,input().split())
if(c>b or c>a or c>n):
    print(-1)
else:
    k=c+(a-c)+(b-c)
    k=n-k
    if(k>0):
        print(k)
    else:
        print(-1)

",constant,implementation,165
"import math
import os
import random
import re
import sys
import functools
from operator import itemgetter, attrgetter
from collections import Counter

if __name__ == '__main__':
    Y = lambda: list(map(int, input().split()))
    P = lambda: map(int, input().split())
    N = lambda: int(input())

    a, b, c, n = P()

    if a < c or b < c:
        r = -1
    else:
        r = n - (a + b - c)
    print(-1 if r <= 0 else r)",constant,implementation,426
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def main():
    a,b,c,n = map(int,input().split())
    if a+b-c > n-1 or min(a,b) < c:
        print(-1)
    else:
        print(n-(a+b-c))

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",constant,implementation,1944
"lis = list(map(int,input().split()))
if lis[2] <= lis[0] and lis[2] <= lis[1]:
	if ((lis[0]+lis[1]) - lis[2]) < lis[3]:
		print(lis[3] - ((lis[0]+lis[1]) - lis[2]))
	elif sum(lis) == 0:
		print(-1)
	elif lis[0] == 0 and lis[1] == 0 and lis[2] == 0 :
		print(lis[3])
	else:
		print(-1)
else:
	print(-1)





		



",constant,implementation,313
"A, B, C, N = map(int, input().strip().split())
D = N - (A + B - C)
if D <= 0 or C > A or C > B:
    print('-1')
    exit(0)
print(D)
",constant,implementation,133
"a,b,c,n=map(int, input().split())
p=n-(a+b-c)
if c>a or c>b or p<=0:
    print(-1)
    exit()
if p<1:
    print(-1)
else:
    print(p)",constant,implementation,134
"a,b,c,n= [int(c) for c in input().split()]
u=a+b-c
if a<c or b<c:
	print(-1)
else:
	if n-u>=1:
		print(n-u)
	else:
		print(-1)
",constant,implementation,127
"a,b,c,n=map(int,input().split())
if n-a-b+c>=1:
    if a<c or b<c:
        print(-1)
    else:
        print(n-a-b+c)
else:
    print(-1)",constant,implementation,137
"mecces, burgerKing, both, groupSize = map(int,input().strip().split(' '))
mecces -= both
burgerKing -= both
notPassed = groupSize - sum((mecces,burgerKing,both))
if notPassed > 0 and burgerKing >= 0 and mecces >= 0:
    print(notPassed)
else:
    print(-1)",constant,implementation,256
"a, b, c, n = map(int, input().split())
t = a + b - c
if a >= n or b >= n or c > a or c > b or t >= n:
    print(-1)
else:
    print(n - t)
",constant,implementation,139
"a,b,c,n=list(map(int,input().split()))
p=(a+b-c)
f=n-p
if p>=n or c>a or c>b:
	print(""-1"")
else:
	print(f)",constant,implementation,106
"a, b, c, n = map(int, input().split())
result = n - a - b + c
print(result if result > 0 and c <= a and c <= b else -1)",constant,implementation,119
"a, b, c, n = map(int, input().split())
t = a+b-c
if c > a or c > b:
    print(-1)
    exit()
if n-t >= 1:
    print(n-t)
else:
    print(-1)
",constant,implementation,141
"a,b,c,n = map(int,input().split())
a-=c
b-=c
if a>=0 and b>=0:
    if (a+b+c)<n:
        n-=(a+b+c)
        print(n)
    else:
        print(-1)
else:
    print(-1)",constant,implementation,164
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

#?############################################################


def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

#?############################################################


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


#?############################################################

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))


#?############################################################

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

#?############################################################


def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime


#?############################################################

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

#?############################################################


def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

#?############################################################


def mapin():
    return map(int, input().split())

#?############################################################


# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
# python3 15.py<in>op
a, b, c, n = mapin()
d = a+b-c

if(d > n-1 or c > a or c > b):
    print(-1)
else:
    print(n-d)",constant,implementation,2197
"a,b,c,n = map(int,input().split())
if c > a or c > b or (a+b) - c >=n:
    print(-1)
else:
    print(n -((a+b)-c))",constant,implementation,114
"a, b, c, n= map(int, input().split())
p = a + b - c
if p <= n-1 and a - c >= 0 and b - c >= 0:
    print(n - p)
else :
    print(-1)
",constant,implementation,133
"from sys import stdin
a, b, c, n = map(int, stdin.readline().split())
if c > a or c > b:
    print(-1)
else:
    val = n - ((a - c) + (b - c)) - c
    print(val if val <= n and val > 0 else -1)",constant,implementation,193
"def f(ch):
    if ch=='0':
        return 0
    else:
        return 1

U=[ [f(i) for i in list(input())],
    [f(i) for i in list(input())]]
i=0
size=len(U[0])
ans=0
while i+1<size:
    if U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]>1:
        i+=1
        continue
    elif U[0][i]+U[0][i+1]+U[1][i]+U[1][i+1]==1:
        U[0][i]=1
        U[0][i+1]=1
        U[1][i]=1
        U[1][i+1]=1
        ans+=1
    else:
        U[0][i]=1
        U[0][i+1]=1
        U[1][i]=1
        ans+=1
    ###
    ###
    ###
    i+=1

print(ans)
",constant,"dp,greedy",525
"from math import inf

a=[0,0]
a[0]=[str(c)for c in list(input().strip()) ]
a[1]=[str(X) for X in list(input().strip())]

an = [-inf,-inf,-inf]
if a[0][0]==a[1][0]=='0':
    an[0]=0
elif  a[0][0]!=a[1][0]:
    an[1]=0
x=0
for i in range(1,len(a[0])) :
  #  print(a[0][i],a[1][i],an,x)
    if an[0]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1

            an=[-inf,0 ,-inf]
        elif a[0][i]!=a[1][i]:
            x+=1
            an=[-inf]*3
        else:
            an = [-inf, -inf, -inf]
    elif an[1]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1
            an=[-inf,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            pass
        else:
            an=[-inf,-inf ,-inf]
    else:
        if a[0][i]==a[1][i]=='0':

            an=[0,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            an=[-inf,0,-inf]
        else:
            an=[-inf,-inf ,-inf]


print(x)",constant,"dp,greedy",895
"from math import inf

a=[0,0]
a[0]=[str(c)for c in list(input().strip()) ]
a[1]=[str(X) for X in list(input().strip())]

an = [-inf,-inf,-inf]
if a[0][0]==a[1][0]=='0':
    an[0]=0
elif  a[0][0]!=a[1][0]:
    an[1]=0
x=0
for i in range(1,len(a[0])) :
  #  print(a[0][i],a[1][i],an,x)
    if an[0]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1

            an=[-inf,0 ,-inf]
        elif a[0][i]!=a[1][i]:
            x+=1
            an=[-inf]*3
        else:
            an = [-inf, -inf, -inf]
    elif an[1]==0:
        if a[0][i]==a[1][i]=='0':
            x+=1
            an=[-inf,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            pass
        else:
            an=[-inf,-inf ,-inf]
    else:
        if a[0][i]==a[1][i]=='0':

            an=[0,-inf ,-inf]
        elif a[0][i]!=a[1][i]:
            an=[-inf,0,-inf]
        else:
            an=[-inf,-inf ,-inf]

print(x)",constant,"dp,greedy",894
"input_1 = input()
input_2 = input()

line_1 = [i for i in str(input_1)]
line_2 = [i for i in str(input_2)]

no = 0
for i in range(len(line_1) - 1):
    if line_1[i] != 'X' and line_2[i] != 'X':
        if line_1[i + 1] != 'X':
            no += 1
            line_1[i] = 'X'
            line_2[i] = 'X'
            line_1[i + 1] = 'X'

        elif line_2[i + 1] != 'X':
            no += 1
            line_1[i] = 'X'
            line_2[i] = 'X'
            line_2[i + 1] = 'X'

    elif line_1[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X':
        no += 1
        line_1[i] = 'X'
        line_1[i + 1] = 'X'
        line_2[i + 1] = 'X'

    elif line_2[i] != 'X' and line_1[i + 1] != 'X' and line_2[i + 1] != 'X':
        no += 1
        line_2[i] = 'X'
        line_1[i + 1] = 'X'
        line_2[i + 1] = 'X'

print(no)

            

            
        ",constant,"dp,greedy",874
"S = [str(input()) for i in range(2)]
S[0] = S[0].replace('X','1')
S[1] = S[1].replace('X','1')

n = len(S[0])
if n == 1:
    print(0)
    exit()

INF = 10**18
from collections import defaultdict
dp = defaultdict(lambda: -INF)
for i in range(0, 2):
    for j in range(0, 2):
        dp[(i, j)] = -INF
dp[(int(S[0][0]), int(S[1][0]))] = 0

for i in range(1, n):
    nx = defaultdict(lambda: -INF)
    for j in range(0, 2):
        for k in range(0, 2):
            nx[(int(S[0][i]), int(S[1][i]))] = max(nx[(int(S[0][i]), int(S[1][i]))], dp[(j, k)])
    for j in range(0, 2):
        for k in range(0, 2):
            if dp[(j, k)] == -INF:
                continue
            if j == 0 and k == 0:
                if S[0][i] == '1' and S[1][i] != '1':
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
                if S[0][i] != '1' and S[1][i] == '1':
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
                if S[0][i] != '1' and S[1][i] != '1':
                    nx[(1, 0)] = max(nx[(1, 0)], dp[(j, k)]+1)
                    nx[(0, 1)] = max(nx[(0, 1)], dp[(j, k)]+1)
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
            if j == 0 and k == 1:
                if S[0][i] != '1' and S[1][i] != '1':
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
            if j == 1 and k == 0:
                if S[0][i] != '1' and S[1][i] != '1':
                    nx[(1, 1)] = max(nx[(1, 1)], dp[(j, k)]+1)
    dp = nx
ans = -INF
for k, v in dp.items():
    ans = max(ans, v)
print(ans)
",constant,"dp,greedy",1557
"s = [list(input()), list(input())]
ans = 0
l = len(s[0])
i = 0
while i < l - 1:
    a = (s[0][i], s[0][i + 1], s[1][i], s[1][i + 1])
    if a.count(""0"") == 4:
        ans += 1
        s[0][i + 1] = ""X""
        i+=1
    elif a.count(""0"") == 3:
        ans += 1
        i += 2
    else:
        i += 1
print(ans)
",constant,"dp,greedy",311
"import itertools
import bisect
import math
from collections import *
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())


def main():
    a = li()
    b = li()
    n = len(a)
    ans = 0
    for i in range(n):
        if a[i] == ""0"":
            ans += 1
            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:
                a[i] = b[i] = b[i - 1] = ""X""
            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:
                a[i] = b[i] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == b[i + 1]:
                a[i] = b[i] = b[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:
                a[i] = b[i + 1] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == a[i + 1]:
                a[i] = b[i] = a[i + 1] = ""X""
            else:
                ans -= 1
    print(ans)
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",constant,"dp,greedy",2725
"import itertools
import bisect
import math
from collections import *
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())


def main():
    a = li()
    b = li()
    n = len(a)
    ans = 0
    for i in range(n):
        if a[i] == ""0"":
            ans += 1
            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:
                a[i] = b[i] = b[i - 1] = ""X""
            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:
                a[i] = b[i] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == b[i + 1]:
                a[i] = b[i] = b[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:
                a[i] = b[i + 1] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == a[i + 1]:
                a[i] = b[i] = a[i + 1] = ""X""
            else:
                ans -= 1
    print(ans)
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

# 3b5d858938ed5adabba546577a06a820e2ffb0defd893320d00e9740333b19c5

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",constant,"dp,greedy",2792
"import itertools
import bisect
import math
from collections import *
import os
import sys
from io import BytesIO, IOBase

ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())


def main():
    a = li()
    b = li()
    n = len(a)
    ans = 0
    for i in range(n):
        if a[i] == ""0"":
            ans += 1
            if i - 1 >= 0 and a[i] == b[i] == b[i - 1]:
                a[i] = b[i] = b[i - 1] = ""X""
            elif i + 1 < n and b[i] == b[i + 1] == a[i + 1] == a[i]:
                a[i] = b[i] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == b[i + 1]:
                a[i] = b[i] = b[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i + 1] == a[i + 1]:
                a[i] = b[i + 1] = a[i + 1] = ""X""
            elif i + 1 < n and a[i] == b[i] == a[i + 1]:
                a[i] = b[i] = a[i + 1] = ""X""
            else:
                ans -= 1
    print(ans)
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

# a03e7a21f6788bc81f27641a9c1f55f66ef836ddc748e5f5a882374bb22a897d


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",constant,"dp,greedy",2793
"b = [list(input()) for _ in range(2)]

n = len(b[0])
ans = 0
a = []
for i in range(n):
    ai = 0
    if b[0][i] == '0':
        ai += 1
    if b[1][i] == '0':
        ai += 1
    a.append(ai)
prv = 0
for i in range(n):
    if a[i] == 0:
        prv = 0
    elif a[i] == 1:
        if prv == 2:
            ans += 1
            prv = 0
        else:
            prv = 1
    elif a[i] == 2:
        if prv == 2:
            ans += 1
            prv = 1
        elif prv == 1:
            ans += 1
            prv = 0
        else:
            prv = 2
print(ans)",constant,"dp,greedy",560
"s=[list(input()) for i in range(2)]
n=len(s[0])
cnt=0
for i in range(n-1):
  if s[0][i]==s[1][i]==s[0][i+1]==""0"":
    cnt+=1
    s[0][i]=s[1][i]=s[0][i+1]=""X""
  elif s[0][i]==s[1][i]==s[1][i+1]==""0"":
    cnt+=1
    s[0][i]=s[1][i]=s[1][i+1]=""X""
  elif s[0][i]==s[1][i+1]==s[0][i+1]==""0"":
    cnt+=1
    s[0][i]=s[1][i+1]=s[0][i+1]=""X""
  elif s[0][i+1]==s[1][i]==s[1][i+1]==""0"":
    cnt+=1
    s[0][i+1]=s[1][i]=s[1][i+1]=""X""
print(cnt)",constant,"dp,greedy",435
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
########################################################################

figures=[
  ((0,0),(0,1),(1,0)),
  ((0,0),(0,1),(1,1)),
  ((0,1),(1,0),(1,1)),
  ((0,0),(1,0),(1,1)),
]

board=[]
for _ in range(2):
  s=rl()
  board.append(list(s))

n=len(board[0])

ans=0
for j in range(n-1):
  for fig in figures:
    ok=1
    for fi,fj in fig:
      if board[fi][j+fj]=='X':
        ok=0
        break
    if not ok:
      continue
    ans+=1
    for fi,fj in fig:
      board[fi][j+fj]='X'

print(ans)
",constant,"dp,greedy",1077
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
########################################################################

figures=[
  [(0,0),(0,1),(1,0)],
  [(0,0),(0,1),(1,1)],
  [(0,1),(1,0),(1,1)],
  [(0,0),(1,0),(1,1)],
]

board=[]
for _ in range(2):
  s=rl()
  board.append(list(s))

n=len(board[0])

ans=0
for j in range(n-1):
  for fig in figures:
    ok=1
    for fi,fj in fig:
      if board[fi][j+fj]=='X':
        ok=0
        break
    if not ok:
      continue
    ans+=1
    for fi,fj in fig:
      board[fi][j+fj]='X'
    break

print(ans)
",constant,"dp,greedy",1087
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase

def get(a,x):
    return (a[0][x] == ""0"") + (a[1][x] == ""0"")

def main():
    a=[input().rstrip() for _ in range(2)]
    n=len(a[0])
    if n==1:
        print(0)
    else:
        dp=[[-1,-1,-1] for _ in range(n)]
        z=get(a,0)
        dp[0][z]=0
        for i in range(1,n):
            z=get(a,i)
            if z==0:
                dp[i][0]=max(dp[i-1])
            elif z==1:
                dp[i][0]=dp[i-1][2]+1
                dp[i][1]=max(dp[i-1])
            elif z==2:
                dp[i][0]=max(dp[i-1][1]+1,dp[i-1][2]+(i!=1))
                dp[i][1]=dp[i-1][2]+1
                dp[i][2]=max(dp[i-1])
        print(max(dp[-1]))


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",constant,"dp,greedy",2474
"arr1=str(input())
arr2=str(input())
arr1=arr1.encode()
arr2=arr2.encode()
arr1=bytearray(arr1)
arr2=bytearray(arr2)
n, tot=len(arr1), 0
for i in range(n-1):
	if arr1[i]==48 and arr1[i+1]==48 and arr2[i]==48:
		tot+=1
		arr1[i]=49
		arr1[i+1]=49
		arr2[i]=49
	elif arr1[i]==48 and arr2[i]==48 and arr2[i+1]==48:
		tot+=1
		arr1[i]=49
		arr2[i]=49
		arr2[i+1]=49
	elif arr2[i]==48 and arr2[i+1]==48 and arr1[i+1]==48:
		tot+=1
		arr2[i]=49
		arr2[i+1]=49
		arr1[i+1]=49
	elif arr1[i]==48 and arr1[i+1]==48 and arr2[i+1]==48:
		tot+=1
		arr1[i]=49
		arr1[i+1]=49
		arr2[i+1]=49
print(tot)",constant,"dp,greedy",585
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq
# sys.setrecursionlimit(100000)
# ^^^TAKE CARE FOR MEMORY LIMIT^^^
import random


def main():
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def binary(n):
    return (bin(n).replace(""0b"", """"))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum


def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m


def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)


def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c


def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p


def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))


def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s
def chk1(i):
    '''
    .
    ..
    '''
    if(i!=n-1 and l1[i]==l2[i]==l2[i+1]==""0""):
        l1[i] = l2[i] = l2[i + 1] = ""X""
        return True
    return False
def chk2(i):
    '''
    ..
    .
    '''
    if(i!=n-1 and l1[i]==l1[i+1]==l2[i]==""0""):
        l1[i] = l1[i + 1] = l2[i] = ""X""
        return True
    return False
def chk3(i):
    if (i != n - 1 and l1[i] == l1[i + 1] == l2[i+1] == ""0""):
        l1[i] = l1[i + 1] = l2[i+1] = ""X""
        return True
    return False
def chk4(i):
    if (i != n - 1 and l2[i+1] == l1[i + 1] == l2[i] == ""0""):
        l1[i] = l1[i + 1] = l2[i] = ""X""
        return True
    return False


def check1(i):
    if (i <= n - 3 and l1[i:i + 3] == l2[i:i + 3] == [""0"",""0"",""0""]):
        for j in range(i,i+3):
            l1[j]=l2[j]=""X""
        return True


def check2(i):
    if(chk1(i) or chk2(i) or chk3(i) or chk4(i)):
        return True
    return False


l1=list(input())
l2=list(input())
#print(l1,l2)
n=len(l1)
i=0
ans=0
while(i<n):
    if(check1(i)):
        #print(i)
        ans+=2
        i+=3
    else:
        if(check2(i)):
            ans+=1
            i+=2
        else:
            i+=1
print(ans)
#print(l1)
#print(l2)",constant,"dp,greedy",6092
"def ch_x(stri, n):
    res = ''
    for i in range(len(stri)):
        if i != n:
            res += stri[i]
        else:
            res += 'x'
    return res


a = input()
b = input()
n = 0
for i in range(0, len(a)):
    if a[i] == '0' and b[i] == '0':
        c = [i-1, i+1]
        for e in c:
            if 0 <= e < len(a):
                if a[e] == '0':
                    n += 1
                    a = ch_x(a, e)
                    break
                if b[e] == '0':
                    n += 1
                    b = ch_x(b, e)
                    break
        a = ch_x(a, i)
        b = ch_x(b, i)
print(n)",constant,"dp,greedy",625
"
s = [input(), input()]
n = len(s[0])

dp = [[0,0,0] for _ in range(n+1)]

for i in range(n-2,-1,-1):
    dp[i] = [dp[i+1][0]]*3
    vals = [0,0,0,0]
    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i] == '0':
        vals[0] = dp[i+1][2] + 1
    if s[0][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':
        vals[1] = dp[i+2][0] + 1
    if s[1][i] == '0' and s[0][i+1] == '0' and s[1][i+1] == '0':
        vals[2] = dp[i+2][0] + 1
    if s[0][i] == '0' and s[1][i] == '0' and s[1][i+1] == '0':
        vals[3] = dp[i+1][1] + 1
    dp[i][1] = max(dp[i+1][0], vals[1])
    dp[i][2] = max(dp[i+1][0], vals[2])
    dp[i][0] = max(dp[i][1], dp[i][2], *vals)

result = max(dp[0])
print(result)
",constant,"dp,greedy",699
"l, r = [{'0': 1, 'X': 0}[c] for cc in zip(input(), input()) for c in cc], 0
for i in range(0, len(l) - 3, 2):
    s = 7 - sum(l[i:i + 4])
    if s < 5:
        r += 1
        l[i:i + s] = [0] * s
print(r)",constant,"dp,greedy",204
"a = list(map(int, input().split()))
b = list(map(int, input().split()))
a1 = min(a[::2])
b1 = max(a[::2])
c1 = min(a[1::2])
d1 = max(a[1::2])
g  = sum(b[::2]) / 4
h  = sum(b[1::2]) / 4
r  = abs(b[0] - g) + abs(b[1] - h)
for i in range(a1, b1+1) :
    for j in range(c1, d1+1) :
        if abs(i-g) + abs(j-h) <= r:
            print(""YES"")
            exit()
print(""NO"")
",constant,brute force,371
"x1, y1, x2, y2, x3, y3, x4, y4 = map(int, input().split())
X1, Y1, X2, Y2, X3, Y3, X4, Y4 = map(int, input().split())

x = [x1, x2, x3, x4]
y = [y1, y2, y3, y4]
x = list(set(x))
y = list(set(y))
x.sort()
y.sort()
xl, xr = x
yl, yr = y

if xl <= X1 <= xr and yl  <= Y1 <= yr:
    print('YES')
    exit()
if xl <= X2 <= xr and yl  <= Y2 <= yr:
    print('YES')
    exit()
if xl <= X3 <= xr and yl  <= Y3 <= yr:
    print('YES')
    exit()
if xl <= X4 <= xr and yl  <= Y4 <= yr:
    print('YES')
    exit()

CX, CY = (X1+X2+X3+X4)//4,  (Y1+Y2+Y3+Y4)//4
X1, X2, X3, X4 = X1-CX, X2-CX, X3-CX, X4-CX
Y1, Y2, Y3, Y4 = Y1-CY, Y2-CY, Y3-CY, Y4-CY

if xl <= CX <= xr and yl  <= CY <= yr:
    print('YES')
    exit()

A = 0
for X in (X1, X2, X3, X4):
    A = max(A, abs(X))
if abs(x1-CX)+abs(y1-CY) <= A:
    print('YES')
    exit()
if abs(x2-CX)+abs(y2-CY) <= A:
    print('YES')
    exit()
if abs(x3-CX)+abs(y3-CY) <= A:
    print('YES')
    exit()
if abs(x4-CX)+abs(y4-CY) <= A:
    print('YES')
    exit()
print('NO')
",constant,brute force,1011
"def inn1(s1):
    t=False
    for i in s1:
        if i[0]>=xmi1 and i[0]<=xma1 and i[1]>=ymi1 and i[1]<=yma1:
            t=True
            break
    if c2[0]>=xmi1 and c2[0]<=xma1 and c2[1]>=ymi1 and c2[1]<=yma1:
            t=True
    return t
def inn2(s):
    t=False
    for i in s:
        if i[0]>=xmi2 and i[0]<=xma2 and i[1]>=ymi2 and i[1]<=yma2:
            t=True
            break
    if c1[0]>=xmi2 and c1[0]<=xma2 and c1[1]>=ymi2 and c1[1]<=yma2:
            t=True
    return t
def conv(s):
    for i in range(4):
        x=s[i][0]
        y=s[i][1]
        s[i][0]=x+y
        s[i][1]=x-y
    return s
aux=list(map(int,input().split()))
s=[]
for i in range(0,8,2):
    s.append([aux[i],aux[i+1]])
aux=list(map(int,input().split()))
s1=[]
for i in range(0,8,2):
    s1.append([aux[i],aux[i+1]])
st=set()
for i in s:
    st.add(i[1])
xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
for i in range(4):
    xma1=max(xma1,s[i][0])
    xma2=max(xma2,s1[i][0])
    xmi1=min(xmi1,s[i][0])
    xmi2=min(xmi2,s1[i][0])
    yma1=max(yma1,s[i][1])
    yma2=max(yma2,s1[i][1])
    ymi1=min(ymi1,s[i][1])
    ymi2=min(ymi2,s1[i][1])
c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
t=False
if len(st)==2:
    t=True
if t:
    t1=inn1(s1)
    s=conv(s)
    s1=conv(s1)
    xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
    for i in range(4):
        xma1=max(xma1,s[i][0])
        xma2=max(xma2,s1[i][0])
        xmi1=min(xmi1,s[i][0])
        xmi2=min(xmi2,s1[i][0])
        yma1=max(yma1,s[i][1])
        yma2=max(yma2,s1[i][1])
        ymi1=min(ymi1,s[i][1])
        ymi2=min(ymi2,s1[i][1])
    c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
    c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
    t2=inn2(s)
else:
    t1=inn2(s)
    s=conv(s)
    s1=conv(s1)
    xma1=s[0][0];xma2=s1[0][0];xmi1=s[0][0];xmi2=s1[0][0];yma1=s[0][1];yma2=s1[0][1];ymi1=s[0][1];ymi2=s1[0][1]
    for i in range(4):
        xma1=max(xma1,s[i][0])
        xma2=max(xma2,s1[i][0])
        xmi1=min(xmi1,s[i][0])
        xmi2=min(xmi2,s1[i][0])
        yma1=max(yma1,s[i][1])
        yma2=max(yma2,s1[i][1])
        ymi1=min(ymi1,s[i][1])
        ymi2=min(ymi2,s1[i][1])
    c1=[(xma1+xmi1)/2,(yma1+ymi1)/2]
    c2=[(xma2+xmi2)/2,(yma2+ymi2)/2]
    t2=inn1(s1)
    
if t1 or t2:
    print(""YES"")
else:
    print(""NO"")
    
",constant,brute force,2414
"def onseg(p,q,r):
    return min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and \
           min(p[1], r[1]) <= q[1] <= max(p[1], r[1])

def orientation(p,q,r):
    val = (q[1] - p[1]) * (r[0] - q[0]) - \
          (q[0] - p[0]) * (r[1] - q[1])
 
    if (val == 0): return 0  # colinear
    return 1 if val > 0 else 2 # clock or counterclock wise

def doint(p1, q1, p2, q2):
    o1 = orientation(p1, q1, p2)
    o2 = orientation(p1, q1, q2)
    o3 = orientation(p2, q2, p1)
    o4 = orientation(p2, q2, q1)
 
    if o1 != o2 and o3 != o4:
        return True
 
    if o1 == 0 and onseg(p1, p2, q1): return True
    if o2 == 0 and onseg(p1, q2, q1): return True
    if o3 == 0 and onseg(p2, p1, q2): return True
    if o4 == 0 and onseg(p2, q1, q2): return True
 
    return False

x0,y0,x1,y1,x2,y2,x3,y3 = map(int,input().split())
x4,y4,x5,y5,x6,y6,x7,y7 = map(int,input().split())

A = x0,y0
B = x1,y1
C = x2,y2
D = x3,y3
a = x4,y4
b = x5,y5
c = x6,y6
d = x7,y7

if doint(A,B,a,b) or doint(A,C,a,b) or doint(A,D,a,b) or doint(B,C,a,b) or doint(B,D,a,b) or doint(C,D,a,b) or \
   doint(A,B,a,c) or doint(A,C,a,c) or doint(A,D,a,c) or doint(B,C,a,c) or doint(B,D,a,c) or doint(C,D,a,c) or \
   doint(A,B,a,d) or doint(A,C,a,d) or doint(A,D,a,d) or doint(B,C,a,d) or doint(B,D,a,d) or doint(C,D,a,d) or \
   doint(A,B,b,c) or doint(A,C,b,c) or doint(A,D,b,c) or doint(B,C,b,c) or doint(B,D,b,c) or doint(C,D,b,c) or \
   doint(A,B,b,d) or doint(A,C,b,d) or doint(A,D,b,d) or doint(B,C,b,d) or doint(B,D,b,d) or doint(C,D,b,d) or \
   doint(A,B,c,d) or doint(A,C,c,d) or doint(A,D,c,d) or doint(B,C,c,d) or doint(B,D,c,d) or doint(C,D,c,d):
    print('YES')
else:
    print('NO')

",constant,brute force,1675
"
a, b, c, d, e, f, g, h = map(int, input().split(' '))
i, j, k, l, m, n, o, p = map(int, input().split(' '))

s1 = [[a, b], [c, d], [e, f], [g, h]]
s1.sort()
bleft = s1[0]
tr = s1[3]
u, v, w, x = bleft[0], bleft[1], tr[0], tr[1]


def check(xd, dx, u, v, w, x):
	return (u <= xd and xd <= w and v <= dx and dx <= x)

god = [(i+k+m+o)/4, (j+l+n+p)/4]
nani = 0
for moo in [[i, j], [k, l], [m, n], [o, p]]:
	if check(moo[0], moo[1], u, v, w, x):
		print(""Yes"")
		quit()

	
if check(god[0], god[1], u, v, w, x):
	nani += 1


i, j = i+j, i-j
k, l = k+l, k-l
m, n = m+n, m-n
o, p = o+p, o-p

a, b = a+b, a-b
c, d = c+d, c-d
e, f = e+f, e-f
g, h = g+h, g-h

a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p = i, j, k, l, m, n, o, p, a, b, c, d, e, f, g, h

s1 = [[a, b], [c, d], [e, f], [g, h]]
s1.sort()
bleft = s1[0]
tr = s1[3]
u, v, w, x = bleft[0], bleft[1], tr[0], tr[1]


def check(xd, dx, u, v, w, x):
	return (u <= xd and xd <= w and v <= dx and dx <= x)

god = [(i+k+m+o)/4, (j+l+n+p)/4]


for moo in [[i, j], [k, l], [m, n], [o, p]]:
	if check(moo[0], moo[1], u, v, w, x):
		print(""Yes"")
		quit()

if check(god[0], god[1], u, v, w, x):
	nani += 1
if nani == 2:
	print(""Yes"")
	quit()

print(""No"")",constant,brute force,1196
"import sys

def sol(a,b):
	for square in [a,b]:
		for i1 in range(4):
			i2 = (i1 + 1)%4
			p1,p2 = square[i1],square[i2]
			
			norm = (p2[1]-p1[1],p1[0]-p2[0])

			minA = maxA = minB = maxB = None
			for p in a:
				proj = norm[0] * p[0] + norm[1] * p[1]
				if minA == None or proj < minA:
					minA = proj
				if maxA == None or proj > maxA:
					maxA = proj
			for p in b:
				proj = norm[0] * p[0] + norm[1] * p[1]
				if minB == None or proj < minB:
					minB = proj
				if maxB == None or proj > maxB:
					maxB = proj

			if maxA < minB or maxB < minA:
				return False
	return True

x11,y11,x12,y12,x13,y13,x14,y14 = list(map(int,sys.stdin.readline().strip().split(' ')))
x21,y21,x22,y22,x23,y23,x24,y24 = list(map(int,sys.stdin.readline().strip().split(' ')))

a = [(x11,y11), (x12,y12), (x13,y13), (x14,y14)]
b = [(x21,y21), (x22,y22), (x23,y23), (x24,y24)]

print([""NO"",""YES""][sol(a,b)])",constant,brute force,900
"p = [int(x) + 100 for x in input().strip().split()]
d = [int(x) + 100 for x in input().strip().split()]

minx = min(p[::2])
maxx = max(p[::2])
miny = min(p[1::2])
maxy = max(p[1::2])

grid = [[False] * 201 for _ in range(201)]
for x in range(minx, maxx+1):
    for y in range(miny, maxy+1):
        grid[x][y] = True

minx = min(d[::2])
maxx = max(d[::2])
avgx = sum(d[::2]) // 4
avgy = sum(d[1::2]) // 4
span = (maxx - minx) // 2

for x in range(minx, maxx+1):
    height = span - abs(x - avgx)
    for y in range(avgy - height, avgy + height + 1):
        if grid[x][y]:
            print('YES')
            exit()

print('NO')
",constant,brute force,630
"from collections import namedtuple

Point = namedtuple(""Point"", ""x y"")
Square = namedtuple(""Square"", ""left right top bottom"")
Triangle = namedtuple(""Triangle"", ""left top"")

a = [int(v) for v in input().split()]
b = [int(v) for v in input().split()]

a = [Point(a[i], a[i + 1]) for i in range(0, 8, 2)]
b = [Point(b[i], b[i + 1]) for i in range(0, 8, 2)]

bc = Point(sum(p.x for p in b) // 4, sum(p.y for p in b) // 4)
bb = [None] * 4
for p in b:
    if p.x < bc.x:
        bb[0] = p
    elif p.y > bc.y:
        bb[1] = p
    elif p.x > bc.x:
        bb[2] = p
    elif p.y < bc.y:
        bb[3] = p
    else:
        assert False

def in_sqr(sqr, pt):
    return sqr.left <= pt.x <= sqr.right and sqr.bottom <= pt.y <= sqr.top

def in_tri(tri, pt):
    return (
        tri.left.x <= pt.x <= tri.top.x and
        tri.left.y <= pt.y <= tri.top.y and
        pt.y - tri.left.y <= pt.x - tri.left.x
    )

def solve_sqr_tri(sqr, tri):
    return (
        in_sqr(sqr, tri.left) or
        in_sqr(sqr, tri.top) or
        in_sqr(sqr, Point(tri.top.x, tri.left.y)) or
        in_tri(tri, Point(sqr.left, sqr.top)) or
        in_tri(tri, Point(sqr.right, sqr.top)) or
        in_tri(tri, Point(sqr.right, sqr.bottom)) or
        in_tri(tri, Point(sqr.left, sqr.bottom))
    )

def rotate90(pt):
    return Point(-pt.y, pt.x)

def iterate_rot(pt, times):
    for _ in range(times):
        pt = rotate90(pt)
    return pt

def solve_sqr_sqr45(sqr_pts, sqr45):
    for i in range(4):
        tri_pts = sqr45[i], sqr45[(i + 1) % 4]
        left, top = [iterate_rot(pt, i) for pt in tri_pts]

        assert left.x < top.x
        assert left.y < top.y

        tri = Triangle(left=left, top=top)

        sqr = Square(
            left=min(p.x for p in sqr_pts),
            right=max(p.x for p in sqr_pts),
            top=max(p.y for p in sqr_pts),
            bottom=min(p.y for p in sqr_pts),
        )

        if solve_sqr_tri(sqr, tri):
            return True

        sqr_pts = [rotate90(pt) for pt in sqr_pts]

    return False


print([""NO"", ""YES""][solve_sqr_sqr45(a, bb)])
",constant,brute force,2078
"one = list(map(int, input().split()))
two = list(map(int, input().split()))

one_ = sorted([(one[i], one[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))
two_ = sorted([(two[i], two[i + 1]) for i in range(0, 8, 2)], key=lambda x: (x[1], x[0]))

ones = [one_[0], one_[2], one_[3], one_[1]]
twos = [two_[1], two_[3], two_[2], two_[0]]

L, D, U, R = ones[0][0], ones[0][1], ones[2][1], ones[2][0]


def in_one(point):
    x, y = point

    return L <= x <= R and D <= y <= U


def in_two(point):
    x_0, y_0 = twos[0]

    def U_p(x_):
        return x_ + y_0 - x_0

    def D_m(x_):
        return -x_ + y_0 + x_0

    x_1, y_1 = twos[2]

    def U_m(x_):
        return -x_ + y_1 + x_1

    def D_p(x_):
        return x_ + y_1 - x_1

    x, y = point
    
    return D_m(x) <= y <= U_p(x) and D_p(x) <= y <= U_m(x)


c_one = ((L + R) / 2, (U + D) / 2)
c_two = ((twos[0][0] + twos[2][0]) / 2, (twos[1][1] + twos[3][1]) / 2)

ones.append(c_one)
twos.append(c_two)

for p in ones:
    if in_two(p):
        print('YES')
        exit()

for p in twos:
    if in_one(p):
        print('YES')
        exit()

print('NO')
",constant,brute force,1129
"import math
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def print(self):
        print(self.x, self.y)


class Line:
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2

    def on(self, p):
        return distance(self.p1, p) + distance(self.p2, p) == distance(self.p1, self.p2)

    def print(self):
        self.p1.print()
        self.p2.print()


class Square:
    def __init__(self, points):
        self.points = points

    def area(self):
        return distance(self.points[0], self.points[1]) ** 2

    def lines(self):
        l = []
        for i in range(3):
            l.append(Line(self.points[i], self.points[i + 1]))
        l.append(Line(self.points[3], self.points[0]))
        return l

    def midpoint(self):
        return Point(self.points[0].x / 2 + self.points[2].x / 2, self.points[0].y / 2 + self.points[2].y / 2)

    def print(self):
        for point in self.points:
            point.print()


def distance(p1, p2):
    return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** .5


def tri_area(p1, p2, p3):
    a = distance(p1, p2)
    b = distance(p2, p3)
    c = distance(p3, p1)
    s = a + b + c
    s /= 2
    return (s * (s - a) * (s - b) * (s - c)) ** .5


def inter(p, s):
    a = s.area()
    area_sum = tri_area(s.points[0], s.points[1], p) + tri_area(s.points[1], s.points[2], p)
    area_sum += tri_area(s.points[2], s.points[3], p) + tri_area(s.points[3], s.points[0], p)
    if abs(a - area_sum) < 0.000001:
        return True
    return False


c1 = input().split("" "")
c2 = input().split("" "")
for i in range(8):
    c1[i] = int(c1[i])
    c2[i] = int(c2[i])
c1p = []
c2p = []
for i in range(0, 8, 2):
    c1p.append(Point(c1[i], c1[i + 1]))
    c2p.append(Point(c2[i], c2[i + 1]))
s1 = Square(c1p)
s2 = Square(c2p)
yes = False
for point in s1.points:
    if inter(point, s2):
        if not yes:
            print(""YES"")
            yes = True
for point in s2.points:
    if inter(point, s1):
        if not yes:
            print(""YES"")
            yes = True
if inter(s1.midpoint(), s2):
    if not yes:
        print(""YES"")
        yes = True
if inter(s2.midpoint(), s1):
    if not yes:
        print(""YES"")
if not yes:
    print(""NO"")",constant,brute force,2249
"from collections import deque
from sys import stdin, stderr
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def signum(n):
    return 1 if n > 0 else 0 if n == 0 else -1

def range_includes(i, j):
    s = signum(j - i)
    return range(i, j + s, s)

def main():
    # lines will now contain all of the input's lines in a list
    first = ints()
    aCoords = tuple(first[i:i+2] for i in range(0, 8, 2))
    minX = min(aCoord[0] for aCoord in aCoords)
    minY = min(aCoord[1] for aCoord in aCoords)
    maxX = max(aCoord[0] for aCoord in aCoords)
    maxY = max(aCoord[1] for aCoord in aCoords)
    def inFirst(x, y):
        return x >= minX and x <= maxX and y >= minY and y <= maxY

    second = ints()
    bCoords = tuple(second[i:i+2] for i in range(0, 8, 2))
    minSum = min(sum(bCoord) for bCoord in bCoords)
    maxSum = max(sum(bCoord) for bCoord in bCoords)
    minDiff = min(bCoord[0] - bCoord[1] for bCoord in bCoords)
    maxDiff = max(bCoord[0] - bCoord[1] for bCoord in bCoords)
    def inSecond(x, y):
        return x + y >= minSum and x + y <= maxSum and x - y >= minDiff and x - y <= maxDiff

    for aCoord in aCoords:
        if inSecond(*aCoord):
            return True
    for i in range(-1, 3):
        c1 = bCoords[i]
        c2 = bCoords[i + 1]
        for x, y in zip(range_includes(c1[0], c2[0]), range_includes(c1[1], c2[1])):
            if inFirst(x, y):
                return True
    return False

if __name__ == '__main__':
    print(""YES"" if main() else ""NO"")
",constant,brute force,1783
"class vec():
    def __init__(self, x, y=None):
        if y is None:
            x, y = x
        self.x = x
        self.y = y  
    def __mod__(self, other):
        return self.x*other.y - self.y*other.x
    def __sub__(self, other):
        return vec(self.x - other.x, self.y - other.y)
    def __repr__(self):
        return 'vec({}, {})'.format(self.x, self.y)

def lines_cross(a, b, c, d):
    ab, ac, ad = b - a, c - a, d - a
    cd, ca, cb = d - c, a - c, b - c
    return (ab % ac) * (ab % ad) <= 0 and (cd % ca) * (cd % cb) <= 0

def rot(a):
    return vec(a.x-a.y, a.x+a.y)

ax, ay, bx, by, cx, cy, dx, dy = map(int, input().split())
kx, ky, lx, ly, mx, my, nx, ny = map(int, input().split())
c, b, d, a = map(vec, sorted([(ax, ay), (bx, by), (cx, cy), (dx, dy)]))
m, n, l, k = map(vec, sorted([(kx, ky), (lx, ly), (mx, my), (nx, ny)]))
res = False
s1 = [a, b, c, d]
s2 = [k, l, m, n]
for i in range(4):
    for j in range(4):
        if lines_cross(s1[i], s1[(i+1)%4], s2[j], s2[(j+1)%4]):
            res = True
            break
    if res:
        break
if all([b.x <= p.x <= a.x and c.y <= p.y <= b.y for p in [k, l, m ,n]]):
    res = True
if all([rot(l).x <= rot(p).x <= rot(k).x and rot(m).y <= rot(p).y <= rot(l).y for p in [a, b, c ,d]]):
    res = True
print('YES' if res else 'NO')",constant,brute force,1307
"x1, y1, x2, y2, x3, y3, x4, y4 = [int(s) for s in input().split()]
x11, y11, x22, y22, x33, y33, x44, y44 = [int(s) for s in input().split()]

min_x1 = min(x1, x2, x3, x4)
min_y1 = min(y1, y2, y3, y4)
max_x1 = max(x1, x2, x3, x4)
max_y1 = max(y1, y2, y3, y4)

min_x11 = min(x11, x22, x33, x44)
min_y11 = min(y11, y22, y33, y44)
max_x11 = max(x11, x22, x33, x44)
max_y11 = max(y11, y22, y33, y44)

a = (max_x11 + min_x11) / 2
b = (max_y11 + min_y11) / 2
d2 = (max_x11 - min_x11) / 2

for x in range(min_x1, max_x1 + 1):
    for y in range(min_y1, max_y1 + 1):
        if abs(x - a) + abs(y - b) <= d2:
            print(""yes"")
            exit(0)
print(""no"")
",constant,brute force,658
"a,b=list(map(int,input().split()))
c,d=(((b+1)//2)-1,(b-a-1))
print(c if d<0 else c-d if c>d else 0)
",constant,math,101
"a = input()
lst = []
a_1 = """"
for i in range(len(a)):
    if a[i] != "" "":
        a_1 = a_1 + a[i]
    else:
        lst.append(int(a_1))
        a_1 = """"
lst.append(int(a_1))
if lst[1] > 2 * lst[0] - 1:
    print(0)
else:
    countr = 0
    if lst[1] % 2 == 1:
        countr = (lst[1] - 1) // 2
    else:
        countr = (lst[1] - 2) // 2
    if lst[1] > lst[0] + 1:
        countr = countr - lst[1] + lst[0] + 1
    print(countr)",constant,math,433
"n,k=map(int,input().split())
if 2*n-1<k :
	print(0)
elif k<=n+1 :
	if k%2:
		print(k//2)
	else:
		print(k//2-1)
else:
	t1=k-n
	if k%2==0:
		print(k//2-t1)
	else:
		print(k//2-t1+1)
",constant,math,181
"n,k=map(int,input().split())
if k>n+(n-1):
    print(0)
else:
    if k<=n:
        print((k-1)//2)
    else:
        x=n-(k-n)
        print((x+1)//2)
",constant,math,151
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################
import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 


alphabets = list('abcdefghijklmnopqrstuvwxyz')


def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):
    """"""
    L is a list.
    The function returns the power set, but as a list of lists.
    """"""
    cardinality=len(L)
    n=2 ** cardinality
    powerset = []
    
    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
        
    #the function could stop here closing with
    #return powerset

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)
        
    return powerset_orderred
def fastPlrintNextLines(a):
    # 12
    # 3
    # 1
    #like this
    #a is list of strings
    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1
# t = int(input())
for _ in range(t):
    n,k = li()
    if k<=n:
        print((k-1)//2)
    else:
        print(max((2*n-k+1)//2,0))
    
    
",constant,math,3742
"import sys
# Get out of main functoin
def main():
    pass
# decimal to binary
def binary(n):
    return (bin(n).replace(""0b"", """"))
# binary to decimal
def decimal(s):
    return (int(s, 2))
# power of a number base 2
def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
# if  number is prime in √n time
def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
# list to string ,no spaces
def lts(l):
    s = ''.join(map(str, l))
    return s
# String to list
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# Sieve for prime numbers in a range
def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1
            # print(p)
    return (cnt)
# for positive integerse only
def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)
# 1000000007
mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()
# s=input()
def iinp(): return int(input())
# n=int(input())
def nninp(): return map(int, sys.stdin.readline().strip().split())
# n, m, a=[int(x) for x in input().split()]
def llinp(): return list(map(int, sys.stdin.readline().strip().split()))
# a=list(map(int,input().split()))
def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
#import random
#sys.setrecursionlimit(300000)
#from fractions import Fraction
#from collections import OrderedDict
#from collections import deque
########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################
########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################
########################                         from collections import deque                              ########################
########################                         ASCII of A-Z= 65-90                                        ########################
########################                         ASCII of a-z= 97-122                                       ########################
########################                         d1.setdefault(key, []).append(value)                       ########################
#for __ in range(iinp()):
n,k=nninp()
if(k>=2*n):
    p(0)
elif(k<=n):
    if(k%2==1):
        p(k//2)
    else:
        p(k//2-1)
else:
    if(k%2==1):
       print(k//2-(k-n)+1)
    else:
        print(k//2 - (k - n))









",constant,math,3284
"n,m = map(int,input().split())

if m<=n:
    print((m-1)//2)
elif m>n:
    if (m-n) in range(1,n+1):
        if(n-(m-n))%2==0:
            print((n-(m-n))//2)
        else:
            print((n-(m-n))//2+1)
    else:
        print(0)",constant,math,233
"n,k = map(int,input().split())
if k>n+n-1:
    print(0)
    exit(0)
if k-1<=n:
    ml = 1
    mr = k-1
    print((mr-ml+1)//2)
else:
    mr = n
    ml = k-n
    print((mr-ml+1)//2)",constant,math,180
"n,k=map(int,input().split())
if n>=k:
    print((k-1)//2)
elif n*2>k:
    print(n-k//2)
else: print(0)
",constant,math,103
"n,k=map(int,input().split())
if n>=k: 
    print((k-1)//2)
elif n*2>k: 
    print(n-k//2)
    
else: 
    print(0)",constant,math,114
"n,k = map(int,input().split())
if(k - n >= n) :
    print(0)
    exit()
if(k <= n):
    if(k%2):
         print(k//2)
    else :
        print(k//2-1)
else:
    print(n-k//2)",constant,math,174
"n, k = (int(x) for x in input().split())
 
if k > n * 2 or k < 3:
    print(0)
elif n >= k-1:
    print(k - k//2 - 1)
else:
    print(n - k//2)",constant,math,143
"import sys
import math
from collections import OrderedDict
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, input().split()) 
def listinput(): return list(map(int, input().split()))
n,k=minput()
if n==k:print(math.ceil(n/2)-1)
elif k>2*n:print(0)
else:print(min(n,k-1)-k//2)",constant,math,345
"n,k=map(int,input().split())
print(max(min(n,k-1)-k//2,0))",constant,math,58
"#B. Pair of Toys
n,k=map(int,input().split())
if n>=k: 
    print((k-1)//2)
elif n*2>k: 
    print(n-k//2)
else: 
    print(0)",constant,math,126
"import math
n, k = map(int, input().split())
if k % 2 == 1:
  mink = (k + 1) // 2
else:
  mink = k // 2 + 1
print(max(0, min(k - 1, n) - mink + 1))
",constant,math,148
"import math

types_of_toy , toy_pair = map(int,input().split())

if(toy_pair <= types_of_toy ):
    print(math.floor( ( toy_pair - 1 ) /2))
elif( toy_pair <= 2*types_of_toy - 1):
    print(math.floor( ( types_of_toy +1 -(toy_pair - types_of_toy) )/ 2)) 
else:
    print(0)


",constant,math,275
"import sys, string

n, m = map(int, sys.stdin.readline().split())
print('4' * 2229)
print('5' * 2228 + '6')",constant,"constructive algorithms,math",107
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def main():
    n,m = map(int,input().split())
    x = ((n-5)//4+((n-5)%4!=0))
    if n <= 5:
        a,b = '5','5'
    else:
        a = '5'*(x+1)
        b = '4'*x+'5'
    print(a,b)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",constant,"constructive algorithms,math",1989
"n, m = map(int, input().split())
a = []
b = []
check = True
while n >= 0:
    if check == True:
        a.append(5)
        n -= 5
        b.append(4)
        check = False
    else:
         check = True
         a.append(4)
         n -= 4
         b.append(5)


if m != 1:
    a.append(5)
    b.append(6)
else:
    a.append(5)
    b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",constant,"constructive algorithms,math",387
"n, m = map(int, input().split())
a = []
b = []
check = True
while n >= 0:
    if check == True:
        a.append(5)
        n -= 5
        b.append(4)
        check = False
    else:
         check = True
         a.append(4)
         n -= 4
         b.append(5)

a.append(5)
b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",constant,"constructive algorithms,math",329
"n, m = map(int, input().split())
a = []
b = []
while n >= 0:
    a.append(4)
    n -= 4
    b.append(5)

a.append(5)
b.append(5)

print(*a, sep = """")
print(*b, sep = """")
",constant,"constructive algorithms,math",170
"n, m = map(int, input().split())

a = []
b = []

if n <= 8:
    a = [4]
    b = [5]
    
while n > 8:
    a += [4,5]
    b += [5,4]
    n -= 8
    
print(*a + [5], sep="""")
print(*b + [5], sep="""")",constant,"constructive algorithms,math",195
"n,m = map(int,input().split())
 
print(n*""8"")
print((n-1)*""1""+""2"")",constant,"constructive algorithms,math",66
"n,m = map(int,input().split())
print(n*""8"")
print((n-1)*""1""+""2"")",constant,"constructive algorithms,math",64
"def f(l):
    n,m = l #1129
    return ['5'*282,'4'*281+'5']

l = list(map(int,input().split()))
[print(r) for r in f(l)]
",constant,"constructive algorithms,math",122
"a, b = map(int, input().split())
print(""1""*a)
print(int(""1"" + (""0"" * a)) - int(""1"" * a))",constant,"constructive algorithms,math",88
"a='4'*(300)+'5'
b='5'*(301)
print(a);print(b)
",constant,"constructive algorithms,math",46
"n,m=[int(x) for x in input().split()]
ans1=""1""*1500
ans2=""8""*1499+""9""
print(ans1)
print(ans2)
",constant,"constructive algorithms,math",94
"n,m=[int(x) for x in input().split(' ')]
print((n-1)*'4'+'5')
print(n*'5')
#
#sum a+b less than m .. so sum a+b will be of form 1000000....000

#so it will be 1, that condition is always satisfied
#condition of mn will always be satisfied because it is 5times n
#always greater than n",constant,"constructive algorithms,math",284
"n, m = map(int, input().split())
a = 1
for i in range(n - 1):
  a *= 10
  a += 1
b = 10 ** n - a
print(a)
print(b)",constant,"constructive algorithms,math",114
"for i in range (1000) :
    print(5,end="""")
print()
for i in range (999) :
    print(4,end="""")
print(5)",constant,"constructive algorithms,math",103
print('4'*1131+'\n'+'5'*1130+'6'),constant,"constructive algorithms,math",33
"#!/usr/bin/env python
# coding: utf-8

# In[46]:


a=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
b=9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
print(a)
print(b)

",constant,"constructive algorithms,math",456
"n,m = map(int, input().strip().split(' '))
a='8'*1129 + '9'
b='1'*1130
print(a)
print(b)",constant,"constructive algorithms,math",88
"n = int(input())
ax, ay = list(map(int, input().split(' ')))
bx, by = list(map(int, input().split(' ')))
cx, cy = list(map(int, input().split(' ')))

if ((cx < ax) == (bx < ax)) and ((cy < ay) == (by < ay)):
    print('YES')
else:
    print('NO')",constant,"dfs and similar,graphs,implementation",246
"n = int(input())

ax, ay = list(map(int, input().split()))
bx, by = list(map(int, input().split()))
cx, cy = list(map(int, input().split()))

x = [ax, bx, cx]
y = [ay, by, cy]

x.sort()
y.sort()

if (x[1] != ax) and (y[1] != ay):
        print('YES')
else:
        print('NO')
",constant,"dfs and similar,graphs,implementation",277
"n = int(input())
x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())
if (x2 < x1 and x3 < x1 or x2 > x1 and x3 > x1) and (y2 < y1 and y3 < y1 or y2 > y1 and y3 > y1):
    print(""YES"")
else:
    print(""NO"")
",constant,"dfs and similar,graphs,implementation",259
"n=int(input())
a,b=map(int,input().split())
b1,b2=map(int,input().split())
c1,c2=map(int,input().split())
b1-=a
b2-=b
c1-=a
c2-=b
if b1==0 or b2==0 or c1==0 or c2==0:print('NO')
else:
    if b1*c1<0 or b2*c2<=0:print('NO')
    else:print('YES')",constant,"dfs and similar,graphs,implementation",244
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal


def ria():
    return [int(i) for i in input().split()]


if getpass.getuser() != 'frohenk':
    filename = 'half'
    # sys.stdin = open('input.txt')
    # sys.stdout = open('output.txt', 'w')
else:
    sys.stdin = open('input.txt')
    # sys.stdin.close()
# sys.stdout = open('input.txt','w')

n = ria()[0]
x, y = ria()
bx, by = ria()
cx, cy = ria()

x1, y1 = x - bx, y - by
x2, y2 = x - cx, y - cy

if abs(x2) == abs(y2):
    print('NO')
    exit(0)
if math.copysign(x2, x1) != x2:
    print('NO')
    exit(0)
if math.copysign(y2, y1) != y2:
    print('NO')
    exit(0)
print('YES')",constant,"dfs and similar,graphs,implementation",688
"import sys

if __name__ == '__main__':
    cin = sys.stdin

    n = int(next(cin))
    ax, ay = map(int, next(cin).split())
    bx, by = map(int, next(cin).split())
    cx, cy = map(int, next(cin).split())

#   if cx == ax or cy == ay or cx-cy==ax-ay or cx+cy==ax+ay:
#       print('YES')
#       sys.exit(0)
    if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:
        print('YES')
    else:
        print('NO')
",constant,"dfs and similar,graphs,implementation",412
"# make sure the king never crosses the row or column the queen is in

n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if bx < ax < cx or bx > ax > cx or by < ay < cy or cy < ay < by:
    print('NO')
else:
    print('YES')
",constant,"dfs and similar,graphs,implementation",297
"size = int(input())
x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())

if (y2 - y1) * (y3 - y1) > 0 and (x2 - x1) * (x3 - x1) > 0 and x1 + y1 != x3 + y3:
    print('YES')
else:
    print('NO')",constant,"dfs and similar,graphs,implementation",247
"n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if bx < ax < cx:
    print(""NO"")
elif cx < ax < bx:
    print(""NO"")
elif by < ay < cy:
    print(""NO"")
elif cy < ay < by:
    print(""NO"")
else:
    print(""YES"")",constant,"dfs and similar,graphs,implementation",283
"n = int(input())
ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())

if (bx > ax, by > ay) != (cx > ax, cy > ay):
    print(""NO"")
    exit(0)

print(""YES"")
",constant,"dfs and similar,graphs,implementation",210
"n = int(input())
(ax, ay) = [int(x) for x in input().split()]
(bx, by) = [int(x) for x in input().split()]
(cx, cy) = [int(x) for x in input().split()]


if (bx < ax < cx) or (bx > ax > cx) or (by < ay < cy) or (by > ay > cy):
    print(""NO"")
else:
    print(""YES"")",constant,"dfs and similar,graphs,implementation",265
"n=int(input())

ax, ay = map(int,input().split())
bx, by = map(int,input().split())

cx, cy = map(int,input().split())

if ((bx<ax and cx<ax) or (bx>ax and cx>ax)) and ((by<ay and cy<ay) or (by>ay and cy>ay)):
	print('YES')

else:
	print('NO')",constant,"dfs and similar,graphs,implementation",243
"n = int(input())
bx, by = map(int, input().split())
ax, ay = map(int, input().split())
cx, cy = map(int, input().split())
num1 = ax > bx
num3 = cx > bx
num2 = ay > by
num4 = cy > by
if num1 == num3 and num2 == num4:
    print(""YES"")
else:
    print(""NO"")
",constant,"dfs and similar,graphs,implementation",255
"def x(a,b):
    if(a>b):
        return(1)
    else:
        return(0)
n=int(input())
a1,a2=map(int,input().split())
b1,b2=map(int,input().split())
c1,c2=map(int,input().split())
if((a1-a2)==(b1-b2)):
    print(""NO"")
elif((a1+a2)==(b1+b2)):
    print(""NO"")
elif(a1==b1):
    print(""NO"")
elif(a2==b2):
    print(""NO"")
elif((a1-a2)==(c1-c2)):
    print(""NO"")
elif((a1+a2)==(c1+c2)):
    print(""NO"")
elif(a1==c1):
    print(""NO"")
elif(a2==c2):
    print(""NO"")
else:
    if((x(a1,b1)==x(a1,c1)) and (x(a2,b2)==x(a2,c2))):
        print(""YES"")
    else:
        print(""NO"")",constant,"dfs and similar,graphs,implementation",568
"n = int(input())
queen = list(map(int,input().split("" "")))
king = list(map(int,input().split("" "")))
target = list(map(int,input().split("" "")))

def done():
	print(""NO"")
	exit()

def complete():
	print(""YES"")
	exit()

# king is left of queen
if king[0] < queen[0]:
	if target[0] > queen[0]:
		done()
	# king is higher than queen
	if king[1] > queen[1]:
		if target[1] < queen[1]:
			done()
		complete()
	else:
		if target[1] > queen[1]:
			done()
		complete()
else:
	if target[0] < queen[0]:
		done()
	if king[1] > queen[1]:
		if target[1] < queen[1]:
			done()
		complete()
	else:
		if target[1] > queen[1]:
			done()
		complete()
	
",constant,"dfs and similar,graphs,implementation",633
"n = int(input())
ax,ay = list(map(int,input().split()))
bx,by = list(map(int,input().split()))
cx,cy = list(map(int,input().split()))

if (ax-bx)*(ax-cx) > 0 and (ay-by)*(ay-cy) > 0:
    print(""YES"")
else:
    print(""NO"")
",constant,"dfs and similar,graphs,implementation",222
"import sys

next(sys.stdin)

q_x, q_y = map(int, next(sys.stdin).rstrip().split())
k_x, k_y = map(int, next(sys.stdin).rstrip().split())
dest_x, dest_y = map(int, next(sys.stdin).rstrip().split())

def sign(x):
    return 1 if x >= 0 else -1

def which_square(x, y):
    return sign(x - q_x), sign(y - q_y)

if which_square(k_x, k_y) == which_square(dest_x, dest_y):
    print(""YES"")
else:
    print(""NO"")

",constant,"dfs and similar,graphs,implementation",407
"def quadrant(x, y, rx, ry):
	if x>rx and y>ry:
		return 1
	elif x<rx and y>ry:
		return 2
	elif x<rx and y<ry:
		return 3
	else:
		return 4

n = int(input())

qx, qy = map(int, input().split())
kx, ky = map(int, input().split())
cx, cy = map(int, input().split())

if quadrant(kx, ky, qx, qy) == quadrant(cx, cy, qx, qy):
	print(""YES"")
else:
	print(""NO"")
",constant,"dfs and similar,graphs,implementation",355
"n = int(input()) 
ax,ay = [int(s) for s in input().split()]
bx,by = [int(s) for s in input().split()]
cx,cy = [int(s) for s in input().split()]
if ((bx-ax < 0 and cx-ax < 0 or
    bx-ax > 0 and cx-ax > 0) and
    (by-ay < 0 and cy-ay < 0 or
    by-ay > 0 and cy-ay > 0)):
        print(""YES"")
else:
    print(""NO"")",constant,"dfs and similar,graphs,implementation",314
"N, K = map(int, input().split())

print((K+N-1)//N)
",constant,math,52
"n, k = map(int, input().split())

print((k + n - 1) // n)
",constant,math,58
"n, k = map(int, input().split())
h = k // n
if h * n < k:
    h += 1
print(h)
",constant,math,78
"a,b=map(int,input().split(' '))
print((b+a-1)//a)",constant,math,49
"n, k = map(int, input().split())
print((k + n - 1) // n)",constant,math,56
"n,k=map(int,input().split())
print(-(-k//n))",constant,math,44
"USE_STDIO = False

if not USE_STDIO:
    try: import mypc
    except: pass

def main():
    n, k = map(int, input().split(' '))
    ans = (k + n - 1) // n
    print(ans)

if __name__ == '__main__':
    main()



",constant,math,212
"n, k = map(int, input().split())
p = (k - 1) // n + 1
print(p)
",constant,math,63
"n,k=map(int,input().split())

ans=k//n
if(k%n):
    ans+=1
print(ans)",constant,math,69
"n, k = map(int , input().split())
s = k // n
if k % n != 0:
    s += 1
print(s)
",constant,math,80
"n, m = map(int, input().split())
print(m // n + (1 if m % n else 0))
",constant,math,69
"n,k = map(int,input().split())
print(-(-k//n))
",constant,math,47
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, K = getIntList()

r=  K//N
if K%N!=0: r+=1

print(r)






",constant,math,769
"a, b = map(int, input().split())
print((b+a-1)//a)
",constant,math,51
"n, k = map(int, input().split())
print(k // n + (k % n != 0))
",constant,math,62
"[n, k]=[int(i) for i in input().split()]
print((k+n-1)//n)",constant,math,58
"a,b = (map(int,input().split()))
print((b+a-1)//a)
",constant,math,51
"n, k = map(int, input().split())
q = 2 * n + 1
p = k // n
if k % n:
    print(p + 1)
else:
    print(p)",constant,math,103
"q=int(input())

for e in range(q):
    x,y,k=map(int,input().split())
    x,y=abs(x),abs(y)
    x,y=max(x,y),min(x,y)
    
    if(x%2!=k%2):
        k-=1
        y-=1
    
    
    if(x>k):
        print(-1)
        continue
    if((x-y)%2):
        k-=1
        x-=1
    print(k)
    
    
    
    ",constant,math,300
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
Q, = getIntList()
for _ in range(Q):
    N, M, K  = getIntList()
    if max(N,M) >K:
        print(-1)
        continue
    r = K
    if N%2!= K%2:
        r-=1
    if M%2!= K%2:
        r-=1
    print(r)






",constant,math,918
"q = int(input())
for i in range(q):
    x, y, k = map(int, input().split())
    if x > y: x, y = y, x
    m = y
    d = y
    if (y - x) % 2 == 1:
        d -= 1
    if k < m:
        print(-1)
        continue
    r = k - m
    if r % 2 != 0:
        r -= 1
        if d != m:
            d += 1
        else:
            d -= 1
    d += r
    print(d)
",constant,math,354
"q = int(input())
otvet = []
for i in range(q):
    g = input().split()
    n = int(g[0])
    m = int(g[1])
    k = int(g[2])
    if n < 0:
        n = -n
    if m < 0:
        m = -m
    if m > k or n > k:
        otvet.append(-1)
    elif m % 2 == k % 2 and n % 2 == k % 2:
        otvet.append(k)
    elif m % 2 == k % 2 or n % 2 == k % 2:
        otvet.append(k - 1)
    else:
        otvet.append(k - 2)
for i in otvet:
    print(i)
    ",constant,math,441
"q = int(input())
for i in range(q):
    a, b, k = map(int, input().split())
    if a < b:
        a, b, = b, a
    if a > k:
        print(-1)
    elif a % 2 == b % 2 != k % 2:
        print(k - 2)
    elif (a + b) % 2 != 0:
        print(k - 1)
    else:
        print(k)
    ",constant,math,277
"q = int(input())
for i in range(q):
    n, m, k = map(int, input().split())
    m, n = abs(m), abs(n)
    mx = max(m, n)
    remaining = k - mx
    if remaining < 0:
        print(-1)
    elif m == n == 0:
        if k == 1:
            print(-1)
        elif k % 2:
            print(k - 1)
        else:
            print(k)
    elif abs(m - n) % 2 == 0:
        if remaining % 2 == 0:
            print(k)
        else:
            print(k - 2)
    else:
        if not remaining:
            print(k - 1)
        elif remaining % 2 == 0:
            print(k - 1)
        else:
            print(k - 1)
",constant,math,606
"from collections import deque
from sys import stdin
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def main():
    # lines will now contain all of the input's lines in a list
    T = int(nextline())
    for testCase in range(1, T + 1):
        n, m, k = ints()
        min_k = max(n, m)
        if min_k > k:
            print(-1)
            continue
        if (n - m) % 2 == 0:
            if k % 2 == n % 2:
                print(k)
                continue
            print(k - 2)
            continue
        print(k - 1)

if __name__ == '__main__':
    main()
",constant,math,854
"

q = int(input())

for _ in range(q):
    n, m, k = map(int, input().split())
    if max([n, m]) > k:
        print(-1)
    else:
        if (n + m) % 2 == 0:
            if max([n, m]) % 2 != k % 2:
                print(k - 2)
            else:
                print(k)
        else:
            print(k - 1);
",constant,math,313
"import math

q = int(input())

for i in range(q):
    x, y, k = map(int, input().split())
    if x > k or y > k:
        print(-1)
    else:
        if (x+y)%2 == 0:
            if (k-max(x,y)) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        else:
            if (k-max(x,y)) % 2 == 0:
                print(k-1)
            else:
                print(k-1)",constant,math,399
"q = int(input())

for _ in range(q):
    n, m, k = map(int, input().split())
    if k == 0:
        if n == 0 and m == 0:
            print(0)
        else:
            print(-1)
    elif k == 1:
        if max(abs(n), abs(m)) != 1:
            print(-1)
        elif abs(n) == abs(m) == 1:
            print(1)
        else:
            print(0)
    else:
        if max(abs(n), abs(m)) > k:
            print(-1)
        elif abs(n) == abs(m):
            if (k - abs(n)) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        elif (max(abs(n), abs(m)) - min(abs(n), abs(m))) % 2 == 0:
            if (k - max(abs(n), abs(m))) % 2 == 0:
                print(k)
            else:
                print(k - 2)
        else:
            print(k - 1)



",constant,math,788
"
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline

for _ in range(int(input())):
    n,m,k=map(int,input().split())
    n=abs(n)
    m=abs(m)
    if max(n,m)>k:
        print(""-1"")
    else:
        # you can't 0 0 1 me :D
        bad1=((n+k)%2==1)
        bad2=((m+k)%2==1)
        print(k-bad1-bad2)
",constant,math,317
"USE_STDIO = False

if not USE_STDIO:
    try: import mypc
    except: pass

def main():
    q,  = map(int, input().split(' '))
    for _ in range(q):
        n, m, k = map(int, input().split(' '))
        if n > k or m > k:
            print(-1)
        elif (n - m) % 2:
            print(k - 1)
        elif (n - k) % 2:
            print(k - 2)
        else:
            print(k)

if __name__ == '__main__':
    main()



",constant,math,425
"q=int(input())

Q=[list(map(int,input().split())) for i in range(q)]

for n,m,k in Q:
    if n>k or m>k:
        print(-1)
        continue

    x=max(n,m)-min(n,m)
    y=k-max(n,m)

    if x%2==0 and y%2==0:
        print(k)
    elif x%2==0 and y%2==1:
        print(k-2)
    elif x%2==1 and y%2==0:
        print(k-1)
    elif x%2==1 and y%2==1:
        print(k-1)
",constant,math,367
"n = int(input())
for i in range(n):
    a, b, c = [int(el) for el in input().split()]
    if ( a > c or b > c):
        print(-1)
    else:
        if (a% 2 + b % 2 == 1):
            print(c - 1)
        elif (a%2 == b%2 == c%2):
            print(c)
        else:
            print(c - 2)
",constant,math,291
"Q = int(input())
src = [tuple(map(int,input().split())) for i in range(Q)]
ans = []
for x,y,k in src:
    d = max(x,y)
    if (x+y)%2:
        ans.append(-1 if d > k else k-1)
    else:
        if d > k:
            ans.append(-1)
        else:
            ans.append(k-2 if (d+k)%2 else k)

print(*ans,sep='\n')
",constant,math,313
"def m():
	[x, y, k] = [int(i) for i in input().split()]
	d=min(x, y)
	x-=d
	y-=d
	k-=d
	
	if k-x-y<0:
		print(-1)
	else:
		x+=y
		if x%2 > 0 and k%2>0:
			print(d+k-1)
		elif x%2 >0:
			print(d+k-1)
		elif k%2>0:
			print(d+k-2)
		else:
			print(d+k)
			
		
			
	
n=int(input())
for i in range(n):
	m()",constant,math,302
"q = int(input())

for i in range(q):
    (x, y, k) = map(int, input().split())

    if max(x, y) > k:
        print(-1)
    elif x == y and k == x + 1:
        print(k - 2)
        continue
    elif x % 2 == 1 and y % 2 == 1 and k % 2 == 0:
        print(k - 2)
        continue
    elif x % 2 == 0 and y % 2 == 0 and k % 2 == 1:
        print(k - 2)
        continue
    elif (x + y) % 2 == 0:
        print(k)
    else:
        print(k - 1)
",constant,math,443
"n = int(input())
for q in range(n):
    x, y, k = map(int, input().split())
    if max(x, y) > k:
        print(-1)
    else:
        if 0 == (x + y) % 2:
            if k % 2 == max(x, y) % 2:
                print(k)
            else:
                print(k - 2)
        else:
            print(k - 1)
",constant,math,305
"def go():
    n = int(input())
    for i in range(n):
        a, b, d = [int(i) for i in input().split(' ')]
        if a > d or b > d:
            print(-1)
        elif a % 2 == b % 2:
            if a % 2 == d % 2:
                print(d)
            else:
                print(d - 2)
        else:
            if a % 2 == b % 2:
                if d % 2 == a % 2:
                    print(d)
                else:
                    print(d - 2)
            else:
                print(d - 1)
go()
",constant,math,506
"x, y, z, t1, t2, t3 = map(int, input().split())
ladder = abs(x - y) * t1
elevator = abs(x - z) * t2 + 3 * t3 + abs(x - y) * t2
if elevator > ladder:
	print(""NO"")
else:
	print(""YES"")",constant,implementation,181
"x, y, z, t1, t2, t3 = list(map(int, input().split()))
print(""YES"" if 3 * t3 + abs(x - z) * t2 + abs(x - y) * t2 <= abs(x - y) * t1 else ""NO"")",constant,implementation,141
"from sys import stdin, stdout
from math import sin, tan, cos

x, y, z, t1, t2, t3 = map(int, stdin.readline().split())

if abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3 <= abs(x - y) * t1:
    stdout.write('YES')
else:
    stdout.write('NO')",constant,implementation,238
"x, y, z, t1, t2, t3 = map(int, input().split())
a = abs(x - y) * t1
b = abs(x - z) * t2 + abs(x - y) * t2 + t3 * 3
if a < b:
    print('NO')
else:
    print('YES')",constant,implementation,163
"x, y, z, t1, t2, t3 = map(int, input().split())
stair = t1 * abs(x - y)
lift = t2 * (abs(z - x) + abs(x - y)) + t3 * 3
print(""YES"" if lift <= stair else ""NO"")
",constant,implementation,159
"x, y, z, t1, t2, t3 = [int(i) for i in input().split()]
if abs(z-x)*t2 + 3 * t3 + abs(x-y)*t2 <= abs(x-y)*t1:
    print(""YES"")
else:
    print(""NO"")
",constant,implementation,149
"x, y, z, t1, t2, t3 = map(int, input().split())
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
stairs = t1 * abs(x - y)
if lift <= stairs:
    print(""YES"")
else:
    print(""NO"")
",constant,implementation,187
"x, y, z, t1, t2, t3 = map(int, input().split())
d1 = abs(x - y) * t1
d2 = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3
if d2 <= d1:
    print('YES')
else:
    print('NO')
",constant,implementation,169
"x, y, z, t1, t2, t3 = map(int, input().split())
a=abs(x-y)*t1
b=abs(x-z)*t2+abs(x-y)*t2+3*t3
if b<=a:print(""YES"")
else:print(""NO"")",constant,implementation,130
"x, y, z, t1, t2, t3 = map(int, input().split())
dp = abs(x - y) * t1;
dl = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3;
if dp < dl:
    print(""NO"")
else:
    print(""YES"")
",constant,implementation,170
"x, y, z, t1, t2, t3 = map(int, input().split())

tp = abs(x - y) * t1
pt = (abs(x - y) + abs(x - z)) * t2 + t3 + t3 + t3
if tp >= pt:
    print(""YES"")
else:
    print(""NO"")
",constant,implementation,173
"x,y,z,t1,t2,t3 = map(int, input().split())
stairs = abs(x - y) * t1
lift = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3
print('YES' if lift <= stairs else 'NO')",constant,implementation,164
"

if __name__ == '__main__':

    x, y, z, t1, t2, t3 = [int(i) for i in input().split(' ')]

    lift_time = (abs(z-x) + abs(y-x))*t2 + 3*t3

    stairs_time = abs(y-x)*t1

    if lift_time <= stairs_time:
        print('YES')
    else:
        print('NO')",constant,implementation,257
"x, y, z, t1, t2, t3 = map(int, raw_input().split())
elev = t3*3 + t2*(abs(z-x) + abs(x-y))
stairs = t1*abs(x - y)
if elev <= stairs:
    print('YES')
else:
    print('NO')
",constant,implementation,172
"x,y,z,t1,t2,t3=map(int,input().split())
if abs(x-y)*t1>=abs(x-z)*t2+t3*3+abs(x-y)*t2:
    print('YES')
else:
    print('NO')",constant,implementation,124
"x, y, z, t1, t2, t3 = map( int, input().split() )
elevator = t2 * ( abs( x - y ) + abs( z - x ) ) + 3 * t3
stairs = t1 * abs( x - y )
if elevator > stairs:
    print( 'NO' )
else:
    print( 'YES' )
",constant,implementation,199
"x,y,z,t1,t2,t3 = map(int, input().split())
time1 = abs(x-y)*t1
time2 = (abs(x-y)+abs(z-x))*t2+3*t3
if time2 <= time1:
    print(""YES"")
else: print(""NO"")",constant,implementation,152
"x, y, z, t1, t2, t3, = map(int, input().split())
if abs(x-z)*t2 + abs((x-y))*t2 + t3*3 <= t1*abs((x-y)):
    print(""YES"")
else:
    print(""NO"")",constant,implementation,143
"(x, y, z, t1, t2, t3) = map(int, input().split())


if 3 * t3 + t2 * (abs(z - x) + abs(x - y)) <= t1 * abs(x - y):
    print(""YES"")
else:
    print(""NO"")

",constant,implementation,155
"n,t=int(input()),1
while n>0:
        if n!=3:  
            k=n//2+n%2
            print((str(t)+' ')*k,end= '')
            n-=k
            t*=2
        else:
            print(t,t,t*3)
            n=0
",constant,"constructive algorithms,math",205
"n, m =map(int, input().split())
if m % n != 0:
	print( m // n + 1)
else:
	print(m // n)
",constant,"greedy,implementation,math",88
"#n, m = map(int, input().split())
#x = int(input())
n, m = map(int, input().split())
ans = m // n + min(1, m % n)
print(ans)",constant,"greedy,implementation,math",124
"n, s = map(int, input().split())
print((s + n - 1) // n)",constant,"greedy,implementation,math",56
"m, a = map(int, input().split())
if (a % m == 0):
    print(a // m)
else:
    print(a//m + 1)",constant,"greedy,implementation,math",93
"n, s = map(int, input().split())
if s % n == 0:
    print(s // n)
else:
    print(s // n + 1)
",constant,"greedy,implementation,math",94
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

n, s = map(int, stdin.readline().split())
stdout.write(str((s + n - 1) // n))",constant,"greedy,implementation,math",179
"n, S = map(int, input().split())
print((S + n - 1) // n);
",constant,"greedy,implementation,math",58
"n, s = map(int, input().split())
ans = s // n
s %= n
if s != 0:
    ans += 1
print(ans)
",constant,"greedy,implementation,math",88
"n,s=map(int,input().split())
x=s//n
if x*n<s:
    x+=1
print(x)",constant,"greedy,implementation,math",63
"from __future__ import division
from sys import stdin, stdout


def write(x):
    stdout.write(str(x) + ""\n"")


n, s = map(int, stdin.readline().split())

if s % n == 0:
    write(s // n)
else:
    write(s // n + 1)
",constant,"greedy,implementation,math",216
"n, s = list(map(int, input().split()))
num_1 = s // n
if s % n == 0:
    print(num_1)
else:
    print(num_1 + 1)",constant,"greedy,implementation,math",112
"n,s=map(int,input().split())
count=0
for i in range(n):
    count+=(s//(n-i))
    s-=(s//(n-i))*(n-i)
print(count)
",constant,"greedy,implementation,math",115
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations


def li():
	return list(map(int , input().split()))


def num():
	return map(int , input().split())


def nu():
	return int(input())


n,s=num()
cc=0
for i in range(n,0,-1):
	cc+=s//i
	s=s%i
print(cc)",constant,"greedy,implementation,math",321
"n, s = map(int, input().split())

print((s + n - 1) // n)",constant,"greedy,implementation,math",57
"n, s = map(int, input().split())

big = s // n
r = s - big * n
if r > 0:
    print(big + 1)
else:
    print(big)
",constant,"greedy,implementation,math",113
"#a = [int(i) for i in input().split()]
#n = input()
n,s = map(int,input().split())

if s%n==0:
	print(s//n)
else:
	print(s//n+1)",constant,"greedy,implementation,math",128
"n, s = map(int, input().split(' '))

if(s <= n):
  sol = 1
else:
  sol = s // n
  if(s % n):
    sol += 1

print(sol)

",constant,"greedy,implementation,math",119
"from math import *
k,n=map(int,input().split())
print(ceil(n/k))",constant,"greedy,implementation,math",64
"n, s = map(int, input().split())
print((s + n - 1) // n)
",constant,"greedy,implementation,math",57
"#!/bin/python3
from itertools import*

moves =[(x*mx,y*my) for mx,my,(x,y) in product( (-1,1),(-1,1), ( (1,2),(2,1) ) )]

def ac(l,x):
	if l==0: return 0
	return l[x] if 0<=x<len(l) else 0

def work():
	x=1
	while x:
		x=0
		for r in range(len(a)):
			for c in range(len(a[0])):
				if not a[r][c] and sum(ac(ac(a,r+dr),c+dc) for dr,dc in moves)>=4:
					a[r][c]=1
					x=1

for n in [int(input())]:
	#print(' ===== n=',n)
	cand=set()

	#for x in (0,1):
	#	for y in range(-1000,1000):
	#		if y%3!=0: cand.add((x,y))
	#
	#for y in [0]:
	#	for x in range(-1000,1000):
	#		cand.add((x,y))

	for i in range(1000):
		for x,y in ( (0,i),(i,0),(i,1),(-i,0),(-i,1),(0,-i) ):
			if x==0 or x%3!=1:
				if n==len(cand): break
				cand.add((x,y))

	assert len(cand)==n

	#NN=25
	#a=[[0]*(NN*2) for x in range(NN*2)]
	#for x,y in sorted(cand,key=lambda a:abs(a[0])+abs(a[1]))[:n]:
	#	a[x+NN][y+NN]=1

	#for r in a: print(''.join('-#'[x] for x in r))
	#print('===')
	#nn=sum(sum(r) for r in a)
	#print(nn)

	#work()

	#for r in a: print(''.join('-#'[x] for x in r))
	#print('===')

	#have=sum(sum(r) for r in a)
	#print(have)
	#need=nn**2//10
	#print('need',need)

	#assert have>=need, n

	for x,y in cand: print(x,y)
",constant,constructive algorithms,1205
"n, m, k, l = map(int, input().split())
cnt = (k + l + m - 1) // m
if cnt * m > n:
    print(-1)
else:
    print(cnt)",constant,math,116
"n, m, k, l = map(int, input().split())
need = k + l
if need % m == 0 and need <= n:
    print(need // m)
else:
    x = need // m + 1
    if x * m > n:
        print(-1)
    else:
        print(x)",constant,math,195
"n, m, k, l = map(int, input().split())
if (k+l+m-1)//m*m > n:
    print(-1)
else:
    print((k+l+m-1)//m)
",constant,math,106
"n, m, k, l = map(int, input().split())
if k + l > n:
    print(-1)
else:
    x = (k + l) // m + (1 if (k + l) % m != 0 else 0)
    if x * m > n:
        print(-1)
    else:
        print(x)
",constant,math,190
"n,m,k,l=map(int,input().split())
c=(k+l)//m
if (k+l)%m!=0:
    c+=1
if n>=m*c:
    print(c)
else :
    print(-1)",constant,math,112
"n, m, k, l = map(int, input().split())
k += l
x = (k + m - 1) // (m);
if m * x > n:
    print(-1)
else:
    print(x)",constant,math,116
"n, m, k, l = list(map(int, input().split()))
if (l > n - k):
    print(-1)
else:
    am = ((l + k) // m + bool((l + k) % m))
    if am * m > n:
        print(-1)
    else:
        print(am)",constant,math,189
"N, M, K, L = map(int, input().split())
if N < M or K + L > N:
    print(-1)
else:
    print((L + K - 1) // M + 1 if ((L + K - 1) // M + 1) * M <= N else -1)",constant,math,156
"n, m, k, l = map(int, input().split())
required = k + l
per_friend = (required + m - 1) // m
if (m * per_friend > n):
    print(-1)
else:
    print(per_friend)   
",constant,math,163
"import math

if __name__ == '__main__':
    n, m, k, l = map(int, input().split())
    one_friend = (k + l) // m + int((k + l) % m != 0)
    if one_friend * m > n:
        print(-1)
    else:
        print(one_friend)
",constant,math,218
"import math

def main():
    n,m,k,l = map(int, input().strip().split())

    t = int(k + l + m - 1) // m

    if k + l > n:
        print(-1)
        return
    
    if m * t > n:
        print(-1)
        return
    
    print(t)

if __name__ == '__main__':
    main()",constant,math,270
"n, m, k, l = [int(x) for x in input().split()]
if (l + k) % m == 0:
    c = (l + k)//m
else:
    c = (l + k)//m + 1
if m * c > n:
    print(-1)
else:
    print(c)",constant,math,162
"n, m, k, l = map(int, input().split())
if m > n:
    print(-1)
elif l + k > n:
    print(-1)
else:
    s = (l + k) // m + bool((l + k) % m)
    if s * m > n:
        print(-1)
    else:
        print(s)
",constant,math,203
"n, m, k, l = map(int, input().split())
if m > n or (l + k + m - 1) // m * m > n:
    print(-1)
else:
    x = (l + k + m - 1) // m
    print(x)",constant,math,142
"import math, sys

def mp():
    return list(map(int, input().split()))

def main():
    n, m, k, l = mp()
    ost = n - k
    need = (l + k)
    if ost < l or need > n:
        print(-1)
        return
    ans = (l + k - 1) // m + 1
    if ans * m - k >= l and ans * m <= n:
        print(ans)
    else:
        print(-1)
    
    
    

deb = 0
if deb:
    file = open(""input.txt"", ""r"")
    input = file.readline
else:
    input = sys.stdin.readline

main()

if deb:
    file.close()
",constant,math,485
"import math

n, m, k, l = map(int, input().split())

x = (l + k) // m
if x * m < l + k:
    x += 1
assert x * m >= l + k

if m * x > n:
    print(-1)
else:
    print(x)",constant,math,168
"#!/usr/bin/env python3
n,m,k,l=map(int,input().split())
q=(l+k-1)//m+1
if q*m>n:print(-1)
else:print(q)
",constant,math,104
"def main():
    n, m, k, l = map(int, input().split())
    d = (l + k) // m
    if (l + k) % m:
        d += 1
    if m * d > n or n - k < l:
        print(-1)
    else:
        print(d)


main()",constant,math,195
"N, M, K, L = list(map(int, input().split()))

each = (K + L) // M

if (K + L) % M != 0:
    each += 1

if each * M > N:
    print(-1)
else:
    print(each)
",constant,math,156
"n = int(input())
x, y = map(int, input().split())
white = max(x - 1, y - 1)
black = max(n - x, n - y)
print(""White"" if white <= black else ""Black"")",constant,"implementation,math",147
"n=int(input())
a,b=map(int,input().split())
white=abs(a-1)+abs(b-1)
black=abs(n-a)+abs(n-b)
if white<=black:
    print(""White"")
else:
    print(""Black"")",constant,"implementation,math",152
"n = int(input())
x, y = list(map(int,input().split()))
if x-1+y-1 <= n-x+n-y:
    print('White')
else:
    print('Black')",constant,"implementation,math",121
"n = int(input())
x,y = map(int,input().split())
if max(x-1,y-1) > max(n-x,n-y):
    print(""Black"")
else:
    print(""White"")
",constant,"implementation,math",124
"n = int(input())
x, y = map(int, input().split())
na = abs(x - 1) + abs(y - 1)
nb = abs(n - x) + abs(n - y)
if na <= nb:
    print(""white"")
else:
    print(""black"")
",constant,"implementation,math",165
"def solve(x, y, n):
    return ""White"" if (x-1 + y-1) <= (n-x + n-y) else ""Black""


def main():
    n = int(input())
    x, y = [int(i) for i in input().split()]
    print(solve(x, y, n))


main()
",constant,"implementation,math",197
"n = int(input())
x,y = map(int,input().split())
num = x - 1 + y - 1
num2 = n - x + n - y
ans = num <= num2
if ans:
    print(""White"")
else:
    print(""Black"")
",constant,"implementation,math",159
"n = int(input())
x, y = list(map(int, input().split()))
d0 = max(x - 1, y - 1)
d1 = max(n - x, n - y)
print('White' if d0 <= d1 else 'Black')
",constant,"implementation,math",142
"n = int(input())
x, y = [int(i) for i in input().split()]

d1 = abs(x - 1) + abs(y - 1)
d2 = abs(n - x) + abs(n - y)

print(""White"" if d1 <= d2 else ""Black"")
",constant,"implementation,math",158
"n = int(input())

x, y = map(int, input().split())

ans = (x - 1) + (y - 1) <= (n - x) + (n - y)
print('White' if ans else 'Black')
",constant,"implementation,math",132
"n = int(input())
x, y = map(int, input().split())

if abs(x - 1) + abs(y - 1) <= abs(x - n) + abs(y - n):
    print('White')
else:
    print('Black')
",constant,"implementation,math",150
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal
import pprint


def ria():
    return [int(i) for i in input().split()]


if getpass.getuser() != 'frohenk':
    filename = 'half'
    # sys.stdin = open('input.txt')
    # sys.stdout = open('output.txt', 'w')
else:
    sys.stdin = open('input.txt')
    # sys.stdin.close()
# sys.stdout = open('output.txt', 'w')


n = ria()[0]
x, y = ria()
d1 = abs(1 - x) + abs(1 - y)
d2 = abs(n - x) + abs(n - y)
if d1<=d2:
    print('White')
else:
    print('Black')",constant,"implementation,math",554
"from bisect import bisect_right as br
from bisect import bisect_left as bl
from math import *

def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2: 
        return True    
    if not n & 1: 
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False

    return True

def mhd(a,b,x,y):

    return abs(a-x)+abs(b-y)


n = int(input())
a,b = map(int,input().split())
if(mhd(a,b,1,1)<=mhd(a,b,n,n)):
    print('White')
else:
    print('Black')",constant,"implementation,math",528
"n = int(input())
x, y = map(int, input().split())

def d(a, b):
    return a + b

if d(x-1, y-1) <= d(n-x, n-y):
    print(""White"")
else:
    print(""Black"")",constant,"implementation,math",156
"n=int(input())
x,y=map(int,input().split())
val1=max(x,y)-1
val2=n-min(x,y)
if(val1<=val2):
    print('White')
else:
    print('Black')",constant,"implementation,math",135
"def go():
    n = int(input())
    x, y = [int(i) for i in input().split(' ')]
    a = 1 + 1
    b = n + n
    c = x + y
    distance_w = c - a
    distance_b = b - c
    if distance_w == distance_b:
        return 'White'
    if distance_w < distance_b:
        return 'White'
    return 'Black'

print(go())
",constant,"implementation,math",310
"n = int(input())
x, y = list(map(int, input().strip().split()))

if n-x + n-y >= x-1 + y-1:
	print(""White"")
else:
	print(""Black"")",constant,"implementation,math",129
"q = int(input())
a,s = map(int,input().split())
if ((a+s-2)<=(q+q-a-s)):
    print(""White"")
else:
    print('Black')
",constant,"implementation,math",117
"n=int(input())
x,y=map(int,input().split())
d1=max(x-1,y-1)
d2=max(n-x,n-y)
if d1<=d2:
    print(""White"")
else:
    print(""Black"")",constant,"implementation,math",130
"from math import ceil

n, k = map(int, input().split())

print(ceil((8 * n) / k) + ceil((5 * n) / k) + ceil((2 * n) / k))
",constant,math,122
"n,k=map(int,input().split())
ans=0
ans+=(2*n)//k + bool((2*n)%k!=0)
ans+=(5*n)//k + bool((5*n)%k!=0)
ans+=(8*n)//k + bool((8*n)%k!=0)
print(ans)",constant,math,144
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial

n, k = map(int, stdin.readline().split())
stdout.write(str((n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k))",constant,math,229
"n, k = map(int, input().split())
a, b, c = 2 * n, 5 * n, 8 * n
ceil = lambda x, y: (x + y - 1) // y
print(ceil(a, k) + ceil(b, k) + ceil(c, k))
",constant,math,144
"n, k = map(int, input().split())
r_n = n * 2
g_n = n * 5
b_n = n * 8
t = 0
t += r_n // k
if r_n % k != 0:
    t += 1
t += g_n // k
if g_n % k != 0:
    t += 1

t += b_n // k
if b_n % k != 0:
    t += 1
print(t)
",constant,math,211
"N, K= map(int, input().split())
Rcnt = N * 2
Gcnt = N * 5
Bcnt = N * 8

res = (Rcnt + K - 1) // K + (Gcnt + K - 1) //K + (Bcnt + K -1 ) // K
print(res)
",constant,math,152
"import sys
from math import floor, ceil

input = sys.stdin.readline

n, k = map(int, input().split())

print(ceil((n*2)/k) + ceil((n*5)/k) + ceil((n*8)/k))",constant,math,155
"from math import ceil
n, k = map(int, input().split())
print(ceil(n*2/k) + ceil(n*5/k) + ceil(n*8/k))",constant,math,101
"from __future__ import division
from sys import stdin, stdout
from math import ceil

def write(x):
    stdout.write(str(x) + ""\n"")


n, k = map(int, stdin.readline().split())

red = 2 * n

green = 5 * n

blue = 8 * n


need = int(ceil(red / k)) + int(ceil(green / k)) + int(ceil(blue / k))

write(need)
",constant,math,303
"import sys, math

def mp():
    return list(map(int, input().split()))

def main():
    n, k = mp()
    a = [2, 5, 8]
    s = 0
    for i in a:
        s += (n * i - 1) // k + 1
    print(s)
    
debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()",constant,math,309
"n,k = map(int, input().split())
a = 2*n
b = 5*n
c = 8*n
print((a+k-1)//k + (b+k-1)//k + (c + k -1) // k)",constant,math,104
"n,k = map(int,input().split())
print((2*n + k - 1) // k + (5*n+k-1) // k + (8*n+k-1)//k)
",constant,math,89
"from math import ceil
n, k = map(int, input().split())
cou = 0
cou += ceil(n*2/k)
cou += ceil(n*5/k)
cou += ceil(n*8/k)
print(cou)",constant,math,130
"from math import ceil
n,k = map(int,input().split())
print(ceil(n*2/k)+ceil(n*5/k)+ceil(n*8/k))
",constant,math,96
"from math import ceil

n, k = list(map(int, input().strip().split()))
r = 2*n
g = 5*n
b = 8*n

print(ceil(r/k)+ceil(g/k)+ceil(b/k))",constant,math,131
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n, k = mi()
ans = (n * 2 + k - 1) // k + (n * 5 + k - 1) // k + (n * 8 + k - 1) // k
print(ans)
",constant,math,210
"n, k = map(int, input().split())
print((n*2)//k + bool((n*2)%k) + (n*5)//k + bool((n*5)%k) + (n*8)//k + bool((n*8)%k))",constant,math,118
"n, k = map(int, input().split())
print((8 * n + k - 1) // k + (5 * n + k - 1) // k + (2 * n + k - 1) // k)",constant,math,106
"n,k=map(int,input().split())
print((-(-n*2//k))+(-(-n*5//k))+(-(-n*8//k)))
#2,5,8
",constant,math,82
"def s(k):
	if k % 2 == 0:
		return k // 2
	else:
		return - (k + 1) // 2


for i in range(int(input())):
	l, r = map(int, input().split())
	print(s(r) - s(l - 1))
",constant,math,163
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

for _ in range(ii()):
    l, r = mi()
    l -= 1
    sr = r // 2 + (r % 2) * -r
    sl = l // 2 + (l % 2) * -l
    print(sr - sl)",constant,math,243
"def main():
    def calc(x):
        if x & 1:
            return -x + calc(x - 1)
        return x // 2
    n = int(input())
    for i in range(n):
        a, b = map(int, input().split())
        print(calc(b) - calc(a - 1))    

main()
",constant,math,239
"input = raw_input

def f(n):
    t = (n + 1) // 2
    return t if n % 2 == 0 else -t

for i in range(int(input())):
    le, rg = map(int, input().split())

    print(f(rg) - f(le - 1))
",constant,math,185
"from sys import stdin, stdout
from math import sin, tan, cos, pi, atan2, sqrt, acos, atan, factorial


def get(l, r):
    if l > r:
        return 0
    
    if l & 1:
        return (-l - r) * (r - l + 2) // 4
    else:
        return (l + r) * (r - l + 2) // 4


def solution(l, r):
    l1, l2, r1, r2 = l, l, r, r
    
    if l & 1:
        l2 += 1
    else:
        l1 += 1
    
    if r & 1:
        r2 -= 1
    else:
        r1 -= 1
    
    return get(l1, r1) + get(l2, r2)


q = int(stdin.readline())
for i in range(q):
    l, r = map(int, stdin.readline().split())
    stdout.write(str(solution(l, r)) + '\n')",constant,math,618
"n = int(input())
for i in range(n):
    a,b = map(int, input().split())
    a1 = a
    if a % 2 == 0:
        a1 += 1
    b1 = b
    if b % 2 == 0:
        b1 -= 1
    n = 0
    if a1 <= b1:
        num = (b1 - a1) // 2 + 1
        n = num * (b1 + a1) // 2
        n *= -1
    b2 = b
    a2 = a
    if a % 2 == 1:
        a2 += 1
    if b % 2 == 1:
        b2 -= 1
    n2 = 0
    if a2 <= b2:
        num = (b2 - a2) // 2 + 1
        n2 = num * (b2 + a2) // 2
    print(n + n2)

",constant,math,479
"import math
n  = int(input())

for i in range(n):
    l,r = [*map(int, input().split())]
    l-=1
    war1 = math.ceil(l/2)
    if(l%2 == 1):
        war1 = -1*war1
    
    war2 = math.ceil(r/2)
    if(r%2 == 1):
        war2 = -1*war2

    print(war2-war1)",constant,math,258
"import sys, math

def mp():
    return list(map(int, input().split()))

def ss(x):
    return x * (x + 1) // 2

def sol(x):
    if x == 0:
        return 0
    res = ss(x // 2) * 2
    res1 = ss(x) - res
    return res - res1

def main():
    q = int(input())
    for i in range(q):
        l, r = mp()
        print(sol(r) - sol(l - 1))
        
    
debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()
",constant,math,466
"q = int(input())
for i in range(q):
    l, r = map(int, input().split())
    if l % 2 == 0:
        count = -((r - l + 1) // 2)
    else:
        count = ((r - l + 1) // 2)
    if (r - l + 1) % 2 == 0:
        print(count)
    else:
        if r % 2 == 0:
            print(count + r)
        else:
            print(count - r)",constant,math,327
"n = int(input())
for _ in range(n):
    l, r = map(int, input().split())
    if (l - r) % 2 == 1:
        if l % 2:
            print((r-l+1)//2)
        else:
            print(-((r-l+1)//2))
    else:
        ans = 0
        if l % 2:
            ans = ans + (r-l)//2
        else:
            ans = ans + -(r-l)//2
        if r % 2:
            ans = ans - r
        else:
            ans = ans + r
        print(ans)",constant,math,420
"import sys
input = sys.stdin.readline

Q=int(input())
LR=[list(map(int,input().split())) for i in range(Q)]

#正:N//2個の和
#負:(N+1)//2個の和

def SUM(i):
    plus=i//2
    minus=(i+1)//2

    P=(2+2*plus)*plus//2
    M=(1+2*minus-1)*minus//2
    return P-M

for l,r in LR:
    print(SUM(r)-SUM(l-1))
",constant,math,294
"# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import itertools
import sys

""""""
created by shhuan at 2018/11/24 15:28

""""""

Q = int(input())
ans = []

for i in range(Q):
    l, r = map(int, input().split())
    if l % 2 == 0 and r % 2 == 0:
        ans.append((r-l)//2 + l)
    elif l % 2 == 1 and r % 2 == 0:
        ans.append((r-l+1)//2)
    elif l % 2 == 1 and r % 2 == 1:
        ans.append(0-(r-l)//2-l)
    else:
        ans.append(0-(r-l+1)//2)

print('\n'.join(map(str, ans)))",constant,math,533
"cs = int(input())

for c in range(cs):
    l, r = map(int, input().split())
    #odd     => -
    #even    => +
    
    if l%2 == 0 and r%2 == 0:
        print((r - l) // 2 + l)
    if l%2 == 1 and r%2 == 0:
        print((r - l + 1) // 2)
    if l%2 == 0 and r%2 == 1:
        print(-(r - l + 1) // 2)
    if l%2 == 1 and r%2 == 1:
        print(-(r - l) // 2 - l)",constant,math,366
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()
#print(N)

for _ in range(N):
    l,r = getIntList()
    n = (r-l+1)
    z = n//2
    if l%2==0:
        z*=-1
    if n%2==1:
        if r%2==0:
            z += r
        else:
            z-=r
    print(z)

    




",constant,math,1020
"Q = int(input())

def getsum(N):
    A = (N+1)//2
    r1 = -A + A*(A+1)
    B = N // 2
    r2 = B*(B+1)
    return -r1 + r2

while Q != 0:
    L, R = map(int, input().split())
    print(getsum(R) - getsum(L-1))
    Q -= 1
    
",constant,math,227
"def getsum(a, b):
    if a % 2 == 0:
        return (a + b) * ((b - a) // 2 + 1) // 2
    else:
        return -(a + b) * ((b - a) // 2 + 1) // 2

q = int(input())
for i in range(q):
    l, r = map(int, input().split())
    if l == r:
        print(l if l % 2 == 0 else -l)
    else:
        print(
            getsum(l if l % 2 == 1 else l + 1, r if r % 2 == 1 else r - 1) + 
            getsum(l if l % 2 == 0 else l + 1, r if r % 2 == 0 else r - 1)
        )",constant,math,461
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)


def main():
    n = I()
    aa = [LI() for _ in range(n)]
    r = []
    for a,b in aa:
        al = a + (1-a%2)
        ar = b - (1-b%2)
        sa = (ar-al) // 2 + 1
        tr = -(al+ar) * sa // 2

        bl = a + (a%2)
        br = b - (b%2)
        sb = (br-bl) // 2 + 1
        tr += (bl+br) * sb // 2
        r.append(tr)

    return ""\n"".join(map(str,r))


print(main())
",constant,math,1050
"# from math import ceil
# n, k = map(int, input().split())
# print(ceil(n*2/k) + ceil(n*5/k) + ceil(n*8/k))

for _ in range(int(input())):
    i, j = map(int, input().split())
    i -= 1
    print((j//2 * (j//2 + 1) - i//2 * (i//2 + 1)) - 
          (((j - j//2) * (j - j//2)) - ((i - i//2) * (i - i//2)))) ",constant,math,307
"q = int(input())
for _ in range(q):
	l, r = map(int, input().split())
	sign = -1 if l % 2 else 1
	if (r-l) % 2:
		print(-sign*(r-l+1)//2)
	else:
		print(sign*(l+(r-l)//2))

",constant,math,173
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

def pre(x, y):
    w = x * (y // 2) + (y % 2) * (x + 1) // 2
    b = x * (y // 2) + (y % 2) * x // 2
    assert w + b == x * y
    return w

def count(x1, y1, x2, y2):
    w = pre(x2, y2) + pre(x1 - 1, y1 - 1) - pre(x2, y1 - 1) - pre(x1 - 1, y2)
    b = (x2 - x1 + 1) * (y2 - y1 + 1) - w
    return w, b

for t in range(ii()):
    n, m = mi()
    x1, y1, x2, y2 = mi()
    x3, y3, x4, y4 = mi()
    w = pre(m, n)
    b = m * n - w
    # white spill
    wc, bc = count(x1, y1, x2, y2)
    w -= wc
    b -= bc
    w += (x2 - x1 + 1) * (y2 - y1 + 1)
    # black spill
    if max(x1, x3) <= min(x2, x4) and max(y1, y3) <= min(y2, y4):
        x5 = max(x1, x3)
        y5 = max(y1, y3)
        x6 = min(x2, x4)
        y6 = min(y2, y4)
        w -= (x6 - x5 + 1) * (y6 - y5 + 1)
        wc, bc = count(x5, y5, x6, y6)
        w += wc
        b += bc
    wc, bc = count(x3, y3, x4, y4)
    w -= wc
    b -= bc
    b += (x4 - x3 + 1) * (y4 - y3 + 1)
    print(w, b)",constant,implementation,1072
"def main():
    def calc(x1, y1, x2, y2):
        if x1 > x2 or y1 > y2:
            return 0
        if (x2 - x1 + 1) * (y2 - y1 + 1) % 2 == 0:
            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
        if (x1 + y1) % 2 == 1:
            return (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + 1
        return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
    T = int(input())
    for t in range(T):
        n, m = map(int, input().split())
        a, b, c, d = map(int, input().split())
        e, f, g, h = map(int, input().split())
        j, k, l, q = max(a, e), max(b, f), min(c, g), min(d, h)
        black = calc(1, 1, n, m) - calc(a, b, c, d) - calc(e, f, g, h) + (h - f + 1) * (g - e + 1) + calc(j,k,l,q)
        print(n * m - black, black)

main()
",constant,implementation,740
"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**13
mod = 10**9+7
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)


def main():
    q = I()
    rr = []

    def f(a,b,c,d):
        if a > c or b > d:
            return (0,0)
        sa = c-a + 1
        sb = d-b + 1
        g = h = (sa * sb) // 2
        if (sa*sb) % 2 == 1:
            g += 1

        if (a+b) % 2 == 0:
            return (g,h)
        return (h,g)

    def fa(a):
        return f(a[0],a[1],a[2],a[3])

    for _ in range(q):
        n,m = LI()
        wa = LI()
        ba = LI()
        wc,bc = f(1,1,n,m)
        w1,b1 = fa(wa)
        w2,b2 = fa(ba)
        w3,b3 = f(max(wa[0],ba[0]),max(wa[1],ba[1]),min(wa[2],ba[2]),min(wa[3],ba[3]))

        wc += b1
        bc -= b1
        wc -= w2
        bc += w2
        wc -= b3
        bc += b3
        rr.append('{} {}'.format(wc,bc))


    return ""\n"".join(map(str,rr))


print(main())
",constant,implementation,1463
"def color(x, y):
	# print(f'color(x = {x}, y = {y}) called')
	return 'white' if (x + y) % 2 == 0 else 'black'


def white(x1, y1, x2, y2):
	"""""" x1 <= x2, y1 <= y2 """"""
	# print(f'white(x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}) called')
	if x1 > x2 or y1 > y2:
		return 0

	if color(x1, y1) != color(x2, y2):
		return (x2 - x1 + 1) * (y2 - y1 + 1) // 2
	else:
		if color(x1, y1) == color(x1, y2) == color(x2, y1) == 'white':
			return ((x2 - x1 + 1) * (y2 - y1 + 1) + 1) // 2
		elif color(x1, y1) == color(x1, y2) == color(x2, y1) == 'black':
			return ((x2 - x1 + 1) * (y2 - y1 + 1) - 1) // 2
		else:
			return (x2 - x1 + 1) * (y2 - y1 + 1) // 2	


def black(x1, y1, x2, y2):
	"""""" x1 <= x2, y1 <= y2 """"""
	if x1 > x2 or y1 > y2:
		return 0

	return (x2 - x1 + 1) * (y2 - y1 + 1) - white(x1, y1, x2, y2)


def intersect_1D(x1, x2, x3, x4):
	"""""" x1 <= x2, x3 <= x4 """"""
	return max(x1, x3), min(x2, x4)


def intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4):
	"""""" x1 <= x2, x3 <= x4, y1 <= y2, y3 <= y4 """"""
	xl, xr = intersect_1D(x1, x2, x3, x4)
	yl, yr = intersect_1D(y1, y2, y3, y4)
	return xl, yl, xr, yr


for i in range(int(input())):
	n, m = map(int, input().split())
	# print(f'n = {n}, m = {m}')
	x1, y1, x2, y2 = map(int, input().split())
	# print(f'x1 = {x1}, y1 = {y1}, x2 = {x2}, y2 = {y2}')
	x3, y3, x4, y4 = map(int, input().split())
	# print(f'x3 = {x3}, y3 = {y3}, x4 = {x4}, y4 = {y4}')

	w0, b0 = white(1, 1, m, n), black(1, 1, m, n)
	# print(f'w0 = {w0}, b0 = {b0}')

	_b0 = black(x1, y1, x2, y2)
	# print(f'_b0 = {_b0}')
	w1, b1 = w0 + _b0, b0 - _b0

	_w1 = white(x3, y3, x4, y4)
	# print(f'_w1 = {_w1}')
	w2, b2 = w1 - _w1, b1 + _w1

	xl, yl, xr, yr = intersect_2D(x1, y1, x2, y2, x3, y3, x4, y4)
	# print(f'xl = {xl}, yl = {yl}, xr = {xr}, yr = {yr}')
	_b2 = black(xl, yl, xr, yr)
	# print(f'_b2 = {_b2}')
	w3, b3 = w2 - _b2, b2 + _b2

	print(w3, b3)
",constant,implementation,1866
"t = int(input())

def getcol(x1, y1, x2, y2):
    dx = max((x2-x1+1), 0)
    dy = max((y2-y1+1), 0)
    b = w = dx*dy//2
    if dx % 2 and dy % 2:
        if (x1+y1) % 2:
            b = b + 1
        else:
            w = w + 1
    return w, b

for _ in range(t):
    n, m = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())
    w, b = getcol(1,1,n,m)
    w1, b1 = getcol(x1,y1,x2,y2)
    w2, b2 = getcol(x3,y3,x4,y4)
    w3, b3 = getcol(max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))
    woff = w-w1-w2+w3
    boff = b-b1-b2+b3
    print(woff+w1-w3+b1-b3, boff+w3+b3+b2-b3+w2-w3)
",constant,implementation,650
"import sys, math

def mp():
    return list(map(int, input().split()))

def quer(x1, y1, x2, y2):
    if x1 > x2 or y1 > y2:
        return [0, 0]
    s = (x2 - (x1 - 1)) * (y2 - (y1 - 1))
    if s % 2 == 0:
        return [s // 2, s // 2]
    if (x1 + y1) & 1:
        return [s // 2 + 1, s // 2]
    return [s // 2, s // 2 + 1]
        

def main():
    q = int(input())
    for i in range(q):
        n, m = mp()
        x1, y1, x2, y2 = mp()
        s = quer(1, 1, n, m)
        s1 = quer(x1, y1, x2, y2)
        s[0] -= s1[0]
        s[1] += s1[0]
        
        # print(s[::-1])
        x3, y3, x4, y4 = mp()
        xmn = max(x1, x3)
        xmx = min(x2, x4)
        ymn = max(y1, y3)
        ymx = min(y2, y4)
        s1 = quer(x3, y3, x4, y4)
        s[0] += s1[1]
        s[1] -= s1[1]
        s1 = quer(xmn, ymn, xmx, ymx)
        s[0] += s1[0]
        s[1] -= s1[0]
        print(*s[::-1])
        
debug = 0
if debug:
    file = open(""input.txt"", ""r"")
    input = file.readline
main()
if debug:
    file.close()",constant,implementation,1027
"def area(rect):
    if rect is None:
        return 0
    x1, y1, x2, y2 = rect
    return (x2-x1+1) * (y2-y1+1)


def get_w(rect):
    if rect is None:
        return 0#, 0

    x1, y1, x2, y2 = rect

    ra = area(rect)
    more, less = (ra + 1) // 2, ra // 2

    if (x1 + y1) % 2 == 0:
        return more #, less
    else:
        return less #, more


def intersect_rects(r1, r2):
    out = []
    for i, a, b in zip(range(4), r1, r2):
        out.append(max(a,b) if i < 2 else min(a,b))

    if out[0] > out[2] or out[1] > out[3]:
        return None
    return out


def main():
    n, m = list(map(int, input().split()))
    rect1 = list(map(int, input().split()))
    rect2 = list(map(int, input().split()))
    rect12 = intersect_rects(rect1, rect2)

    w_start = get_w([1,1,n,m])
    w1 = get_w(rect1)
    w2 = get_w(rect2)
    w12 = get_w(rect12)

    w = w_start - w1 - w2 + w12 + area(rect1) - area(rect12)
    print(w, n*m-w)


q = int(input())
for i in range(q):
    main()
",constant,implementation,992
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
T, = getIntList()
#print(N)
def isin( x,y, M):
    if M[0] <= x <= M[2] and M[1] <= y <= M[3]:
        return True
    return False

for _ in range(T):
    N, M = getIntList()
    m1 = getIntList()
    m2 = getIntList()
    zx = [0, M]
    zx += [m1[0]-1, m1[2]]
    zx += [m2[0]-1, m2[2]]
    zx.sort()
    zy = [0, N]
    zy += [m1[1]-1, m1[3]]
    zy += [m2[1]-1, m2[3]]
    zy.sort()
    totB = 0
    for i0 in range(5):
        if zx[i0] == zx[i0+1]: continue
        for i1 in range(5):
            if zy[i1] == zy[i1+1]: continue
            
            x0 = zx[i0]+1
            y0 = zy[i1]+1
            dprint('x0,y0', x0,y0)
            size = (zx[i0+1] - zx[i0] ) *( zy[i1+1] - zy[i1]) 
            if isin(x0,y0, m2):
                dprint('black')
                totB += size
            elif isin(x0,y0, m1):
                dprint('white')
                pass
            else:
                totB+= size//2
                if size%2==1:
                    if (x0+y0)%2==1:
                        dprint('extra black')
                        totB+=1
    print(N*M - totB, totB)
                    

",constant,implementation,1908
"def num_sq(x,y,x2,y2):
    # b, w
    a = (abs(x2-x)+1)
    b = (abs(y2-y)+1)
    if a % 2 == 0 or b % 2 == 0:
        return (a*b // 2, a*b // 2)
    if (x+y) % 2 == 0:
        num_b = a * b // 2
        return (num_b, a * b - num_b)
    num_w = a * b // 2
    return (a * b - num_w, num_w)
def pt_in(p1, r1, r2):
    return r1[0] <= p1[0] <= r2[0] and r1[1] <= p1[1] <= r2[1]
def intc(p1, p2, p3, p4):
    x1 = max(p1[0], p3[0])
    x2 = min(p2[0], p4[0])
    y1 = max(p1[1], p3[1])
    y2 = min(p2[1], p4[1])
    if x1 <= x2 and y1 <= y2:
        return ((x1, y1), (x2, y2))
    return None

num_ = int(input())
for _ in range(num_):
    n, m = map(int, input().split())
    x1,y1,x2,y2 = map(int,input().split())
    x3,y3,x4,y4 = map(int,input().split())
    p1 = (x1,y1)
    p2 = (x2,y2)
    p3 = (x3,y3)
    p4 = (x4,y4)
    all_b, all_w = num_sq(1, 1, n, m)
    tmp = intc(p1, p2, p3, p4)
    if tmp:
        intc_1, intc_2 = tmp
        t_b, t_w = num_sq(intc_1[0], intc_1[1], intc_2[0], intc_2[1])
    b,w = num_sq(x1,y1,x2,y2)
    if tmp:
        b -= t_b
        w -= t_w
    b2,w2 = num_sq(x3,y3,x4,y4)
    if tmp:
        b2 -= t_b
        w2 -= t_w
    w_tot, b_tot = (all_w + b - w2, all_b - b + w2)
    if tmp:
        w_tot -= t_w
        b_tot += t_w
    print(w_tot, b_tot)

",constant,implementation,1295
"def get_colors(x1, y1, x2, y2):
    w = x2 - x1 + 1
    h = y2 - y1 + 1
    if w % 2 == 0 or h % 2 == 0:
        black = w * h // 2
        white = w * h // 2
    else:
        oddx = w // 2
        if x1 % 2 == 1 and x2 % 2 == 1:
            oddx += 1
        oddy = h // 2
        if y1 % 2 == 1 and y2 % 2 == 1:
            oddy += 1
        evenx = w // 2
        if x1 % 2 == 0 and x2 % 2 == 0:
            evenx += 1
        eveny = h // 2
        if y1 % 2 == 0 and y2 % 2 == 0:
            eveny += 1
        white = oddx * oddy + evenx * eveny
        black = w * h - white
    return white, black

def get_intersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
    if ax1 > bx2:
        return None, None, None, None
    if bx1 > ax2:
        return None, None, None, None
    if ay1 > by2:
        return None, None, None, None
    if by1 > ay2:
        return None, None, None, None
    return max(ax1, bx1), max(ay1, by1), min(ax2, bx2), min(ay2, by2)

t = int(input())
for i in range(t):
    n, m = map(int, input().split())
    white, black = get_colors(1, 1, m, n)
    wx1, wy1, wx2, wy2 = map(int, input().split())
    w, b = get_colors(wx1, wy1, wx2, wy2)
    white += b
    black -= b
    bx1, by1, bx2, by2 = map(int, input().split())
    ix1, iy1, ix2, iy2 = get_intersection(wx1, wy1, wx2, wy2, bx1, by1, bx2, by2)
    if ix1 is not None:
        w, b = get_colors(ix1, iy1, ix2, iy2)
        white -= b
        black += b
    w, b = get_colors(bx1, by1, bx2, by2)
    white -= w
    black += w
    print(white, black)",constant,implementation,1539
"t = int(input())
for i in range(t):
    n, m = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())
    count_w = n * m // 2 + n * m % 2
    count_g = n * m // 2
    if (x1 + y1) % 2 == 0:
        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2
        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2
    else:
        count_g -= (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2
        count_w += (x2 - x1 + 1) * (y2 - y1 + 1) // 2 + (x2 - x1 + 1) * (y2 - y1 + 1) % 2
    x5 = max(x1, x3)
    x6 = min(x4, x2)
    y5 = max(y1, y3)
    y6 = min(y4, y2)
    if (x3 + y3) % 2 == 1:
        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2
        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2
    else:
        count_g += (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2
        count_w -= (x4 - x3 + 1) * (y4 - y3 + 1) // 2 + (x4 - x3 + 1) * (y4 - y3 + 1) % 2
    if (x5 + y5) % 2 == 0 and x5 <= x6 and y5 <= y6:
        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2
        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2
    elif x5 <= x6 and y5 <= y6:
        count_g += (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2
        count_w -= (x6 - x5 + 1) * (y6 - y5 + 1) // 2 + (x6 - x5 + 1) * (y6 - y5 + 1) % 2
    print(count_w, count_g)",constant,implementation,1363
"def getBW(x1, y1, x2, y2):
    if (x2 - x1) % 2 == 1 or (y2 - y1) % 2 == 1:
        return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2] 
    else:
        if (x1 % 2 == 0 and y1 % 2 == 0) or (x1 % 2 == 1 and y1 % 2 == 1):
            return [(y2 + 1 - y1) * (x2 + 1 - x1) // 2, 1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2]
        else:
            return [1 + (y2 + 1 - y1) * (x2 + 1 - x1) // 2, (y2 + 1 - y1) * (x2 + 1 - x1) // 2]

cs = int(input())



for c in range(cs):
    m, n = map(int, input().split())
    BW = getBW(1, 1, n, m)
    x1, y1, x2, y2 = map(int, input().split())
    
    x3, y3, x4, y4 = map(int, input().split())
    
    BW1 = getBW(x1, y1, x2, y2)
    BW2 = getBW(x3, y3, x4, y4)
    BWO =[0, 0]
    #if x1 > x3: (x1, y1, x2, y2), (x3, y3, x4, y4) = (x3, y3, x4, y4), (x1, y1, x2, y2)
    #xO1, xO2 = x1, min(x2, x4)
    xo1 = max(x1, x3)
    xo2 = min(x2, x4)
    yo1 = max(y1, y3)
    yo2 = min(y2, y4)
    if (xo2 >= xo1 and yo2 >= yo1):
        BWO = getBW(xo1, yo1, xo2, yo2)
        '''
    print(BW1)
    print(BW2)
    print(BWO)
    print(BW)'''
    B = BW[0] - BW1[0] + BW2[1] + BWO[0]
    W = BW[1] + BW1[0] - BW2[1] - BWO[0]
    
    print(W, end = "" "")
    print(B)",constant,implementation,1228
"from collections import defaultdict
# from fractions import Fraction
def read_line():
    return [int(x) for x in input().split()]


def solve2(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4):
    def inside(x, y):
        return 1 <= x <= m and 1 <= y <= n

    def col(a, b):
        assert inside(a, b)
        return 'WB'[(a+b)%2]

    d = {}
    for i in range(1, m+1):
        for j in range(1, n+1):
            d[(i, j)] = col(i, j)
    for i in range(x1, x2+1):
        for j in range(y1, y2+1):
            d[(i, j)] = 'W'
    for i in range(x3, x4+1):
        for j in range(y3, y4+1):
            d[(i, j)] = 'B'
    return len([P for P in d if d[P] == 'W']), len([P for P in d if d[P] == 'B'])

def rnd_test():
    from random import randint
    n = randint(1, 50)
    m = randint(1, 50)
    x1, x2, x3, x4 = [randint(1, m) for _ in range(4)]
    y1, y2, y3, y4 = [randint(1, n) for _ in range(4)]
    x1, x2 = min(x1, x2), max(x1, x2)
    y1, y2 = min(y1, y2), max(y1, y2)
    x3, x4 = min(x3, x4), max(x3, x4)
    y3, y4 = min(y3, y4), max(y3, y4)
    assert solve(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4) == solve2(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4)


            
def solve(n, m, x1, y1, x2, y2,
                x3, y3, x4, y4):

    def inside(x, y):
        return 1 <= x <= m and 1 <= y <= n

    def col(a, b):
        assert inside(a, b)
        return 'WB'[(a+b)%2]

    def cols(x1, y1, x2, y2):
        assert inside(x1, y1) and inside(x2, y2)
        assert x1 <= x2 and y1 <= y2
        w, h = x2+1-x1, y2+1-y1
        if w % 2 == 0 or h % 2 == 0:
            return w*h // 2, w*h // 2
        else:
            WH, BL = w*h // 2, w*h // 2
            if col(x1, y1) == 'W':
                WH += 1
            else: BL += 1
            return WH, BL

    def overlap():
        X1 = max(x1, x3)
        X2 = min(x2, x4)
        Y1 = max(y1, y3)
        Y2 = min(y2, y4)
        if X1 > X2 or Y1 > Y2: return None
        return X1, Y1, X2, Y2

    tot_wh, tot_bl = cols(1, 1, m, n)
    # print(""Starting cols: {} wh, {} bl"".format(tot_wh, tot_bl))
    A_wh, A_bl = cols(x1, y1, x2, y2)
    ovrlp = overlap()
    if ovrlp is not None:
        O_wh, O_bl = cols(*ovrlp)
        assert A_wh >= O_wh and A_bl >= O_bl
        A_wh -= O_wh
        A_bl -= O_bl
        #print(""Overlap cols: {} wh, {} bl"".format(O_wh, O_bl))
    # print(""White rect cols: {} wh, {} bl"".format(A_wh, A_bl))
    B_wh, B_bl = cols(x3, y3, x4, y4)
    #print(""Black rect cols: {} wh, {} bl"".format(B_wh, B_bl))

    # Paint A white:
    tot_wh += A_bl
    tot_bl -= A_bl

    # Paint B black:
    tot_wh -= B_wh
    tot_bl += B_wh
    return(tot_wh, tot_bl)

# for _ in range(2000):
#     rnd_test()
# print(""tested"")
t = int(input())

for _ in range(t):
    n, m = read_line()
    x1, y1, x2, y2 = read_line()
    x3, y3, x4, y4 = read_line()
    print(*solve(n, m, x1, y1, x2, y2, x3, y3, x4, y4))
",constant,implementation,2939
"def wb(n,m,flip=False):
    w = b = n*m // 2
    if n%2 == 1 and m %2 == 1:
        w += 1
    if flip:
        return b,w
    else:
        return w,b

t = int(input())
for tt in range(t):
    n,m = map(int, input().split())
    x1,y1,x2,y2 = map(int, input().split())
    x3,y3,x4,y4 = map(int, input().split())
    x5 = max(x1,x3)
    x6 = min(x2,x4)
    y5 = max(y1,y3)
    y6 = min(y2,y4)
    ov = False
    if x6-x5 >= 0 and y6-y5 >= 0:
        ov = True
    w,b = wb(n,m)
    wm,bm = wb(x2-x1+1, y2-y1+1, (x1+y1)%2==1)
    wd,bd = wb(x4-x3+1, y4-y3+1, (x3+y3)%2==1)
    if ov:
        wo,bo = wb(x6-x5+1, y6-y5+1, (x5+y5)%2==1)
    else:
        wo,bo = 0,0
    # print('w, b', w, b)
    # print('wm, bm', wm, bm)
    # print('wd, bd', wd, bd)
    # print('wo, bo', wo, bo)
    w = w+bm-wd-bo
    b = b-bm+wd+bo
    print(w,b)",constant,implementation,833
"# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import itertools
import sys

""""""
created by shhuan at 2018/11/24 15:29

""""""

T = int(input())


def interact(rect1, rect2):
    x1, y1, x2, y2 = rect1
    x3, y3, x4, y4 = rect2

    ans = (-1, -1, -1, -1)
    if x2 < x3 or x4 < x1:
        return 0, ans
    if y2 < y3 or y4 < y1:
        return 0, ans

    ans = (max(x1, x3), max(y1, y3), min(x2, x4), min(y2, y4))

    return area(ans), ans


def area(rect):
    return (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1)


def winrect(rect):
    a = area(rect)
    if a % 2 == 0:
        return a // 2

    x1, y1, x2, y2 = rect
    e1, e2 = x1 % 2 == 0, y1 % 2 == 0
    ow = (e1 and e2) or (not e1 and not e2)
    return a // 2 + 1 if ow else a // 2

ans = []
for ti in range(T):
    N, M = map(int, input().split())
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, x4, y4 = map(int, input().split())

    w = winrect((1, 1, N, M))
    a, b = (x1, y1, x2, y2), (x3, y3, x4, y4)
    s, c = interact(a, b)
    if s == 0:
        w -= winrect(a) + winrect(b)
        w += area(a)
    elif s == area(a):
        w -= winrect(b)
    elif s == area(b):
        w -= winrect(b)
        w += area(a) - area(b) - (winrect(a) - winrect(b))
    else:
        w += area(a) - winrect(a)
        w -= winrect(b)
        w -= area(c) - winrect(c)

    ans.append((w, N*M-w))

print('\n'.join(['{} {}'.format(a, b) for a, b in ans]))",constant,implementation,1476
"def black_count(x, y):
	total = x * y
	return total // 2


def black_count2(a, b, c, d):
	return black_count(c, d) - black_count(a-1, d) - black_count(c, b-1) + black_count(a-1, b-1)

def white_count2(a, b, c, d):
	total = (c - a + 1) * (d - b + 1)
	return total - black_count2(a, b, c, d)


def intersection(a, b, c, d, x, y):
	if x < a or y < b:
		return None
	x = min(x, c)
	y = min(y, d)
	return (a, b, x, y)

def intersection2(a1, b1, c1, d1, a2, b2, c2, d2):
	if b1 > d2 or a1 > c2:
		return None
	if b2 > d1 or a2 > c1:
		return None

	a = max(a1, a2)
	b = max(b1, b2)
	c = min(c1, c2)
	d = min(d1, d2)
	return (a, b, c, d)


def solve(n, m, W, B):
	total = n * m
	whites = total - black_count(n, m)
	whites += black_count2(*W)
	whites -= white_count2(*B)
	I = intersection2(*W, *B)
	if I:
		whites -= black_count2(*I)
	blacks = n * m - whites
	return whites, blacks

def main():
	t = int(input())
	for _ in range(t):
		n, m = map(int, input().split())
		W = list(int(i) for i in input().split())
		B = list(int(i) for i in input().split())
		w, b = solve(n, m, W, B)
		print(w, b)


if __name__ == '__main__':
	main()
",constant,implementation,1126
"import sys
input = sys.stdin.readline

testcase=int(input())
T=[list(map(int,input().split())) for i in range(testcase*3)]
#n,m=map(int,input().split())
#WHITE=list(map(int,input().split()))
#BLACK=list(map(int,input().split()))

def COMMON(WHITE,BLACK):
    x1,y1,x2,y2=WHITE
    x3,y3,x4,y4=BLACK
    return (max(x1,x3),max(y1,y3),min(x2,x4),min(y2,y4))

def BtoW(WHITE):
    x1,y1,x2,y2=WHITE
    if (x1+y1)%2==0:
        return (x2-x1+1)*(y2-y1+1)//2
    else:
        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2
        
def WtoB(BLACK):
    x1,y1,x2,y2=BLACK
    if (x1+y1)%2==1:
        return (x2-x1+1)*(y2-y1+1)//2
    else:
        return (x2-x1+1)*(y2-y1+1)-(x2-x1+1)*(y2-y1+1)//2
        
for test in range(testcase):
    n,m=T[test*3]
    WHITE=T[test*3+1]
    BLACK=T[test*3+2]

    ANSB=n*m//2
    ANSW=n*m-ANSB

    #print(ANSB,ANSW,end=""!"")

    WHITE2=COMMON(WHITE,BLACK)

    k=BtoW(WHITE)
    ANSB-=k
    ANSW+=k

    #print(ANSB,ANSW,end=""!"")
    
    #print(x5,y5,x6,y6)
    if WHITE2[0]>WHITE2[2] or WHITE2[1]>WHITE2[3]:#共通部なし
        True
    else:
        l=BtoW(WHITE2)
        ANSB+=l
        ANSW-=l

    #print(ANSB,ANSW,end=""!"")

    m=WtoB(BLACK)

    ANSB+=m
    ANSW-=m

    print(ANSW,ANSB)

    
        
    
",constant,implementation,1251
"def whb(a,b,c,d):
    dim = (c-a+1)*(d-b+1)
    col1 = dim//2
    col2 = dim-col1
    if (a+b)%2==0:
        return [col2, col1]
    else:
        return [col1, col2]

def insegment(a, b, a1, b1):
    li = [[a,1], [b,1], [a1,2], [b1,2]]
    li.sort()
    if li[0][1] == li[1][1]:
        if li[1][0] == li[2][0]:
            return [li[1][0], li[2][0]]
        else:
            return -1
    else:
        return [li[1][0], li[2][0]]

def inrect(a,b,c,d,a1,b1,c1,d1):
    xra = insegment(a,c,a1,c1)
    yra = insegment(b,d,b1,d1)
    if xra==-1 or yra==-1:
        return -1
    else:
        return [xra[0], yra[0], xra[1], yra[1]]

q = int(input())
for quer in range(q):
    [n, m] = [int(i) for i in input().split()]
    [x1, y1, x2, y2] = [int(i) for i in input().split()]
    [x3, y3, x4, y4] = [int(i) for i in input().split()]
    [white, black] = whb(1,1,n,m)
    [w1, b1] = whb(x1, y1, x2, y2)
    [w2, b2] = whb(x3, y3, x4, y4)
    black+= w2-b1
    white+= b1-w2
    inter = inrect(x1, y1, x2, y2, x3, y3, x4, y4)
    if type(inter)==list:
        [w3, b3] = whb(inter[0], inter[1],inter[2], inter[3])
        black += b3
        white -= b3
    print(white, black)",constant,implementation,1177
"def fis(sq):
    if sq[2] < sq[0] or sq[3] < sq[1]:
        return [0, 0]
    sc = (sq[0] + sq[1]) % 2
    fc = (sq[2] + sq[3]) % 2
    sxl = sq[2] - sq[0] + 1
    syl = sq[3] - sq[1] + 1
    hf = (sxl * syl) // 2
    cp = -1
    if sc == fc and (sxl+syl) % 2 == 0 and sxl % 2 == 1:
        cp = sc
    return([hf + (1 if cp == 0 else 0), hf + (1 if cp == 1 else 0)])

t = int(input())
for i in range(t):
    n, m = [int(x) for x in input().split()]
    wco = [int(x) for x in input().split()]
    bco = [int(x) for x in input().split()]
    wf, bf = fis([1, 1, m, n])
    btw = fis(wco)[1]
    wtb = fis(bco)[0]
    bnac = [max(wco[0], bco[0]), max(wco[1], bco[1]), min(wco[2], bco[2]), min(wco[3], bco[3])]
    bna = fis(bnac)[1]
    print(wf+btw-wtb-bna, bf+wtb-btw+bna)
",constant,implementation,774
"pw = [1, 4]
for i in range(2, 32):
    pw.append(pw[i - 1] * 4)
t = int(input())
for cas in range(t):
    n, k = map(int, input().split())
    last = 1
    path = 1
    ans = n
    i = 0
    while True:
        if((pw[i + 1] - 1) // 3 > k):
            ans -= i
            last = k - (pw[i] - 1) // 3
            break
        i = i + 1
        path *= 2
    sp = path * 2 - 1
    if((ans < 0) or ((ans == 0) and (last > 0))):
        print(""No"")
        continue
    sq = path * path - sp
    if (ans == 1) and (last > sq) and (last < sp):
        print(""No"")
        continue
    elif (ans == 1) and (last >= sp):
        ans = ans - 1
    print(""Yes"", ans)
",constant,"constructive algorithms,implementation,math",661
"import math

t = int(input())


def eval_(n, k):
    level = 0.5*math.log2(3*k+1)
    if n > 30:
        cond = (level - n) > 0
    else:
        cond = (3*k+1) > 4**n
    if cond:
        return ""NO""
    elif n == 2 and k == 3:
        return ""NO""
    else:
        level = math.floor(level)
        # print(level)
        if n > 5:
            # return ""YES "" +  str(n - level)
            temp = 1 + 0.5*math.log2(3*(k-1) + 1)
            if n > temp:
                return ""YES "" + str(n - 1)
            else:
                return ""YES  0""
        else:
            delta = 2**(n-level)*(2**level-1)*(4**(n-level)-1)//3
            start = (4**(level)-1)//3
            if k <=(start+delta):
                return ""YES "" + str(n - level)
            else:
                return ""YES "" + str(n - level-1)



for i in range(t):
    (n, k) = [int(i) for i in input().split()]
    print(eval_(n, k))",constant,"constructive algorithms,implementation,math",905
"f = [0 for _ in range(40)]

for i in range(1, 32):
    f[i] = 1 + 4 * f[i - 1]
t = int(input())
for _ in range(t):
    n, k = map(int, input().split())
    if n >= 32:
        print(""YES %d"" % (n - 1))
        continue

    if f[n] < k:
        print(""NO"")
        continue

    k -= 1
    extra = 1
    way = 3
    size = n - 1
    done = False
    total = f[size]
    ans = True
    while k > total and size > 0:
        if k < way:
            ans = False
            break
        k -= way
        size -= 1
        extra = way * 2 - 1
        way = way * 2 + 1
        total += extra * f[size]

    if ans:
        print(""YES %d"" % size)
    else:
        print(""NO"")
",constant,"constructive algorithms,implementation,math",673
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase
from collections import defaultdict,Counter
from copy import deepcopy

def main():
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    nums = defaultdict(lambda :[0])
    freq,minus = Counter(),0
    for i in a:
        if i == c:
            minus += 1
        else:
            freq[i] += 1
            nums[i].append(freq[i]-minus)
    tot = minus
    suff = deepcopy(nums)
    for i in nums:
        for j in range(len(nums[i])-2,0,-1):
            suff[i][j] = max(suff[i][j],suff[i][j+1])
    freq,ans = Counter(),tot
    for i in a:
        if i == c:
            continue
        freq[i] += 1
        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)
    print(ans)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",constant,"binary search,dp,greedy",2485
"a = list(map(int,input().split()))
b = list(map(int,input().split()))
c = list(map(int,input().split()))
a,b,c= sorted([a,b,c])

path = []
for i in range(min(a[1],b[1],c[1]) , max(a[1],b[1],c[1]) + 1):
    path.append((b[0],i))
for i in range(a[0],b[0]+1):
    path.append((i,a[1]))
for i in range(b[0],c[0]+1):
    path.append((i,c[1]))

print(len(set(path)))
for i in set(path):
    print(*i)
",constant,"greedy,implementation",395
"def get_path_hv(A, B):
	x, y = A

	path = [(x, y)]

	while x < B[0]:
		x += 1
		path.append((x, y))

	while x > B[0]:
		x -= 1
		path.append((x, y))

	while y < B[1]:
		y += 1
		path.append((x, y))

	while y > B[1]:
		y -= 1
		path.append((x, y))

	return path

def get_path_vh(A, B):
	x, y = A

	path = [(x, y)]

	while y < B[1]:
		y += 1
		path.append((x, y))

	while y > B[1]:
		y -= 1
		path.append((x, y))

	while x < B[0]:
		x += 1
		path.append((x, y))

	while x > B[0]:
		x -= 1
		path.append((x, y))

	return path

A = tuple(map(int, input().split()))
B = tuple(map(int, input().split()))
C = tuple(map(int, input().split()))

paths = []
paths.append([get_path_vh(A, B), get_path_hv(A, B)])
paths.append([get_path_vh(C, B), get_path_hv(C, B)])
paths.append([get_path_vh(A, C), get_path_hv(A, C)])

ans = 10 ** 8
ans_path = []

for i in range(3):
	for j in range(3):
		if i != j:
			for a in paths[i]:
				for b in paths[j]:
					X = list(set([*a, *b]))

					if len(X) < ans:
						ans = len(X)
						ans_path = X

print(ans)
for p in ans_path:
	print(*p)
",constant,"greedy,implementation",1065
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
p0 = getIntList()
p1 = getIntList()
p2 = getIntList()
#print(N)

zp = [p0, p1, p2]



def getpath( p0, p1):
    if p0[0] < p1[0]:
        sp = 1
    elif p0[0] > p1[0]:
        sp = -1
    else:
        sp =0
    zz = [tuple(p0), tuple(p1)]
    if sp!=0:
        for x in range(p0[0], p1[0]+ sp, sp):
            tp = (x, p0[1])
            zz.append(tp)
    if p0[1] < p1[1]:
        sp = 1
    elif p0[1] > p1[1]:
        sp = -1
    else:
        sp = 0
    if sp!=0:
        for y in range(p0[1], p1[1] + sp, sp):
            tp = (p1[0], y)
            zz.append(tp)
    return zz

nr = 1000000;
zr = set()
for i in range(3):
    for j in range(3):
        cx = zp[i][0]
        cy = zp[j][1]
        cp = (cx, cy)
        z1 = getpath(cp, zp[0])
        z2 =getpath(cp, zp[1])
        z3 =getpath(cp, zp[2])
        
        z0 = z1+z2+z3
        s1 = set(z0)
        dprint(cp,s1)
        if len(s1) < nr:
            nr = len(s1)
            zr = s1
        
print(len(zr))
for x in zr:
    print(x[0], x[1])



",constant,"greedy,implementation",1804
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

# A. Connect Three

a = [tuple(mi()) for i in range(3)]
a.sort()

up1 = a[1][1] >= a[0][1]
up2 = a[2][1] >= a[0][1]
ans = {a[0]}
x, y = a[0]
if up1 and up2:
    while y < min(a[1][1], a[2][1]):
        y += 1
        ans.add((x, y))
    while x < a[2][0]:
        x += 1
        ans.add((x, y))
    hx, hy = a[2] if a[2][1] > a[1][1] else a[1]
    while hy > y:
        ans.add((hx, hy))
        hy -= 1
else:
    dn1 = a[1][1] <= a[0][1]
    dn2 = a[2][1] <= a[0][1]
    ans = {a[0]}
    x, y = a[0]
    if dn1 and dn2:
        while y > max(a[1][1], a[2][1]):
            y -= 1
            ans.add((x, y))
        while x < a[2][0]:
            x += 1
            ans.add((x, y))
        lx, ly = a[2] if a[2][1] < a[1][1] else a[1]
        while ly < y:
            ans.add((lx, ly))
            ly += 1
    else:
        x, y = a[0]
        ans = {a[0]}
        while x < a[2][0]:
            x += 1
            ans.add((x, y))
        dy = 1 if a[1][1] <= a[0][1] else -1
        xx, yy = a[1]
        while yy != a[0][1]:
            ans.add((xx, yy))
            yy += dy
        dy = 1 if a[2][1] <= a[0][1] else -1
        xx, yy = a[2]
        while yy != a[0][1]:
            ans.add((xx, yy))
            yy += dy

ans = sorted(ans)
print(len(ans))
print('\n'.join('%d %d' % (x, y) for x, y in ans))",constant,"greedy,implementation",1426
"xa, ya = map(int, input().split())
xb, yb = map(int, input().split())
xc, yc = map(int, input().split())
if (xb, yb) < (xa, ya):
    xa, ya, xb, yb = xb, yb, xa, ya
if (xc, yc) < (xa, ya):
    xa, ya, xc, yc = xc, yc, xa, ya
if xb > xc:
    xb, yb, xc, yc = xc, yc, xb, yb
d = 1 if ya <= yc else -1
if ya <= yb <= yc or ya >= yb >= yc:
    print(xc - xa + abs(yc - ya) + 1)
    for x in range(xa, xb):
        print(x, ya)
    for y in range(ya, yc, d):
        print(xb, y)
    for x in range(xb, xc + 1):
        print(x, yc)
elif yb < min(ya, yc):
    print(xc - xa + max(ya, yc) - yb + 1)
    for x in range(xa, xc + 1):
        print(x, min(ya, yc))
    for y in range(yb, min(ya, yc)):
        print(xb, y)
    if ya < yc:
        for y in range(ya + 1, yc + 1):
            print(xc, y)
    else:
        for y in range(yc + 1, ya + 1):
            print(xa, y)
else:
    print(xc - xa + yb - min(ya, yc) + 1)
    for x in range(xa, xc + 1):
        print(x, max(ya, yc))
    for y in range(max(ya, yc) + 1, yb + 1):
        print(xb, y)
    if ya < yc:
        for y in range(ya, yc):
            print(xa, y)
    else:
        for y in range(yc, ya):
            print(xc, y)
",constant,"greedy,implementation",1185
"def path(x1,y1,x2,y2,hor):
    out=[]
    if hor:
        for i in range(x2-x1):
            out.append((x1+i,y1))
        if y2>y1:
            for i in range(y2-y1):
                out.append((x2,y1+i))
        else:
            for i in range(y1-y2):
                out.append((x2,y1-i))
    else:
        for i in range(x2-x1):
            out.append((x2-i,y2))
        if y2>y1:
            for i in range(y2-y1):
                out.append((x1,y2-i))
        else:
            for i in range(y1-y2):
                out.append((x1,y2+i))
    return out[1:]
a,b=map(int,input().split())
c,d=map(int,input().split())
e,f=map(int,input().split())
if a>c:
    a,b,c,d=c,d,a,b
if c>e:
    c,d,e,f=e,f,c,d
if a>c:
    a,b,c,d=c,d,a,b
if c==e and abs(f-b)<abs(d-b):
    c,d,e,f=e,f,c,d
g1=path(a,b,c,d,True)
if d>b:
    if f<b:
        g2=path(c,b,e,f,True)
    elif f<d:
        g2=path(c,f,e,f,True)
    else:
        g2=path(c,d,e,f,True)
else:
    if f<d:
        g2=path(c,d,e,f,True)
    elif f<b:
        g2=path(c,f,e,f,True)
    else:
        g2=path(c,b,e,f,True)
print(len(g1)+len(g2)+3)
print(a,b)
print(c,d)
print(e,f)
for x,y in g1:
    print(x,y)
for x,y in g2:
    print(x,y)",constant,"greedy,implementation",1192
"import sys
from math import floor, ceil
#sys.stdin = open('input.txt', 'r')
r = lambda: sys.stdin.readline().strip()

a = [[0] * 2 for i in range(3)]


def abs(x):
    if x < 0:
        x = -x
    return x


def calcLen(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2) + 1


def main():
    a[0][0], a[0][1] = map(int, r().split())
    a[1][0], a[1][1] = map(int, r().split())
    a[2][0], a[2][1] = map(int, r().split())
    xMax = max(a[0][0], a[1][0], a[2][0])
    xMin = min(a[0][0], a[1][0], a[2][0])
    yMax = max(a[0][1], a[1][1], a[2][1])
    yMin = min(a[0][1], a[1][1], a[2][1])

    pathLen = xMax - xMin + yMax - yMin + 1
    for i in range(3):
        for j in range(3):
            px = a[i][0]
            py = a[j][1]
            sum = 0
            for k in range(3):
                sum += (calcLen(a[k][0], a[k][1], px, py))
            sum -= 2
            if sum == pathLen:
                break
        if sum == pathLen:
            break
    sq = [[0]*(yMax+1) for i in range(xMax+1)]
    for i in range(3):
        if px == a[i][0]:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py, c):
                sq[px][j]=1
        elif py== a[i][1]:
            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
        else:
            c = -1
            if py > a[i][1]:
                c = 1
            for j in range(a[i][1], py + c, c):
                sq[a[i][0]][j] = 1
                
            c = -1
            if px > a[i][0]:
                c= 1
            for j in range(a[i][0], px, c):
                sq[j][py] = 1
    sq[px][py] = 1
    ans = []
    for i in range(xMax + 1):
        for j in range(yMax + 1):
            if sq[i][j] == 1:
                ans.append((i, j))
    print(len(ans))
    for i in ans:
        print(i[0], i[1])

main()
",constant,"greedy,implementation",1939
"l = []
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
a, b = map(int, input().split())
l.append((a,b))
l.sort()
path = []
path.append(l[0])
x = l[0][0]
while(x<l[1][0]):
	path.append((x, l[0][1]))
	x = x + 1
up = False
if(l[0][1]<l[1][1]):
	#print(""why"")
	up = True
if(up):
	y = l[0][1]
	while(y<=l[1][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[0][1]
	while(y>=l[1][1]):
		path.append((l[1][0], y))
		y = y-1
up = False
if(l[1][1]<l[2][1]):
	up = True
if(up):
	y = l[1][1]
	while(y<=l[2][1]):
		path.append((l[1][0], y))
		y = y+1
else:
	y = l[1][1]
	while(y>=l[2][1]):
		path.append((l[1][0], y))
		y = y-1
x = l[1][0]
while(x<l[2][0]):
	path.append((x, l[2][1]))
	x = x + 1
path.append(l[2])
path = list(set(path))
print(len(path))
for i in range(len(path)):
	print(str(path[i][0])+"" ""+str(path[i][1]))

",constant,"greedy,implementation",870
"ax, ay = map(int, input().split())
bx, by = map(int, input().split())
cx, cy = map(int, input().split())
if ax > bx:
    ax, bx = bx, ax
    ay, by = by, ay
if ax > cx:
    ax, cx = cx, ax
    ay, cy = cy, ay
if bx > cx:
    bx, cx = cx, bx
    by, cy = cy, by
ans = []
for i in range(min(ay, by, cy), max(ay, by, cy) + 1):
    ans.append([bx, i])
for i in range(ax, bx):
    ans.append([i, ay])
for i in range(bx + 1, cx + 1):
    ans.append([i, cy])
print(len(ans))
for x in ans:
    print(x[0], x[1])

	 	 		    		 	    	 					 	",constant,"greedy,implementation",532
"
import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log2, ceil
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from bisect import insort
from collections import Counter
from collections import deque
from heapq import heappush,heappop,heapify
from itertools import permutations,combinations
from itertools import accumulate as ac
mod = int(1e9)+7
#mod = 998244353
 
ip = lambda : int(stdin.readline())
inp = lambda: map(int,stdin.readline().split())
ips = lambda: stdin.readline().rstrip()
out = lambda x : stdout.write(str(x)+""\n"")

t = 1
for _ in range(t):
    q = ""? {} {}"".format(0,0)
    print(q,flush = True)
    cond = ip()
    cur_a = 0
    cur_b = 0
    for i in range(29,-1,-1):
        xor = (1<<i)
        query_a = cur_a^xor
        query_b = cur_b^xor
        q = ""? {} {}"".format(query_a,query_b)
        print(q,flush = True)
        val = ip()
        if val != cond:
            if cond == -1 and val == 1:
                cur_b ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
            else:
                cur_a ^= xor
                query_a = cur_a
                query_b = cur_b
                q = ""? {} {}"".format(query_a,query_b)
                print(q,flush = True)
                val = ip()
                cond = val
        else:
            cond = val
            query_a = cur_a^xor
            query_b = cur_b
            q = ""? {} {}"".format(query_a,query_b)
            print(q,flush = True)
            val = ip()
            if val == -1:
                cur_a ^= xor
                cur_b ^= xor
            else:
                pass
    ans = ""! {} {}"".format(cur_a,cur_b)
    print(ans,flush = True)
    
        
        
        
        
        
        
        
        
        
    



    
                    
                
                
            
                
            
            
        
                
                
        
    
    
    
        
    
        
            
        
        
        
        
            
        
        
    
        
            
        
                
        
        
        
        
        
            
            
            
            
            
        
    
            
    
            
            
            
            
            
            
            
                
                
                


    
        
",constant,"bitmasks,constructive algorithms,implementation,interactive",2650
"import sys


def ask(c, d):
    print(""? {} {}"".format(c, d))
    return int(input())


c = d = 0


def solve(mi, base):
    def solve_same():
        global c, d
        print(""# solve_same"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d)
            res2 = ask(c, d ^ bit)
            if res1 == -1 and res2 == 1:
                c |= bit
                d |= bit

    def solve1():
        global c, d
        print(""# solve1"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == -1:
                # a[i] == 1, b[i] == 0
                c |= bit
                return solve(i - 1, ask(c, d))
            else:
                # a[i] == b[i]
                res2 = ask(c ^ bit, d)
                if res2 == -1:
                    # a[i] == b[i] == 1
                    c |= bit
                    d |= bit

    def solve2():
        global c, d
        print(""# solve2"", file=sys.stderr)
        for i in range(mi, -1, -1):
            print(f"">> {i=} {c=} {d=}"", file=sys.stderr)
            bit = 1 << i
            res1 = ask(c ^ bit, d ^ bit)
            if res1 == 1:
                # a[i] == 0, b[i] == 1
                d |= bit
                return solve(i - 1, ask(c, d))
            else:
                # a[i] == b[i]
                res2 = ask(c, d ^ bit)
                if res2 == 1:
                    # a[i] == b[i] == 1
                    c |= bit
                    d |= bit

    if base == 0:
        solve_same()
    elif base == 1:
        solve1()
    else:
        solve2()


solve(29, ask(0, 0))
print(""! {} {}"".format(c, d))
",constant,"bitmasks,constructive algorithms,implementation,interactive",1836
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right
from math import cos, sin

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

mod = 10 ** 9 + 7


def ask(x, y):
    print('?', x, y, flush=True)
    return int(input())


a = b = 0
cond = ask(a, b)
for i in range(29, -1, -1):
    if cond:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, y)
        if cond == n_cond:
            if cond == 1:
                n_cond1 = ask(x, b)
            else:
                n_cond1 = ask(a, y)

            if cond != n_cond1:
                a = x
                b = y

        else:
            if cond == 1:
                a = x
            else:
                b = y
            cond = ask(a, b)
    else:
        x = a + (1 << i)
        y = b + (1 << i)
        n_cond = ask(x, b)
        if n_cond == -1:
            a = x
            b = y
print('!', a, b, flush=True)
",constant,"bitmasks,constructive algorithms,implementation,interactive",2627
"print(""?"",0,0)
e=int(input())
astr=""000000000000000000000000000000""
bstr=""000000000000000000000000000000""
abig=e
for i in range(30):
    if abig==0:
        print(""?"",int(astr,2)+2**(29-i),int(bstr,2))
        e=int(input())
        if e==1:
            continue
        else:
            if i<29:
                astr=astr[:i]+""1""+astr[i+1:]
                bstr=bstr[:i]+""1""+bstr[i+1:]
            else:
                astr=astr[:i]+""1""
                bstr=bstr[:i]+""1""
    else:
        print(""?"",int(astr,2)+2**(29-i),int(bstr,2)+2**(29-i))
        e=int(input())
        if e==-abig:
            if abig==1:
                if i<29:
                    astr=astr[:i]+""1""+astr[i+1:]
                else:
                    astr=astr[:i]+""1""
            else:
                if i<29:
                    bstr=bstr[:i]+""1""+bstr[i+1:]
                else:
                    bstr=bstr[:i]+""1""
            print(""?"",int(astr,2),int(bstr,2))
            abig=int(input())
        else:
            print(""?"",int(astr,2)+2**(29-i),int(bstr,2))
            e=int(input())
            if e==-1:
                if i<29:
                    astr=astr[:i]+""1""+astr[i+1:]
                    bstr=bstr[:i]+""1""+bstr[i+1:]
                else:
                    astr=astr[:i]+""1""
                    bstr=bstr[:i]+""1""
print(""!"",int(astr,2),int(bstr,2))",constant,"bitmasks,constructive algorithms,implementation,interactive",1353
"
a0 = (1 << 30) - 1

a0 = 3
b0 = 1

def mock_query(c, d):
    res = (a0 ^ c) - (b0 ^ d)
    if res > 0:
        return 1
    elif res < 0:
        return -1
    else:
        return 0

def query2(c, d):
    ans = mock_query(c, d)
    print('? {:08b} {:08b} --> {}'.format(c, d, ans))
    return ans

def query(c, d):
    print('?', c, d)
    return int(input())

# query = query2

def solve():
    a = 0
    b = 0
    last_ans = query(0, 0)

    pos = 29
    while pos >= 0:
        bit = 1 << pos

        ans = query(a + bit, b + bit)
        if (last_ans, ans) == (1, -1):
            a += bit
            last_ans = query(a, b)
        elif (last_ans, ans) == (-1, 1):
            b += bit
            last_ans = query(a, b)
        # elif ans == 0:
            # pass
        else:
            last_ans = ans
            ans = query(a + bit, b)
            if ans == -1:
                a += bit
                b += bit

        pos -= 1

    print('!', a, b)

solve()
",constant,"bitmasks,constructive algorithms,implementation,interactive",975
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
	print(""?"", xr + cb, cb)
	ans11 = input()
	print(""?"", xr, cb)
	if ans11 == ans00:
		ans01 = input()
		if ans01 == '1':
			a += cb
			b += cb
	else:
		ans00 = input()
		if ans11 == '1':
			b += cb
		else:
			a += cb
		xr += cb
	cb //= 2
print(""!"", a, b)
",constant,"bitmasks,constructive algorithms,implementation,interactive",326
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    

import random
import time
random.seed( int(time.time()) )

bb = random.randint(0, 2**30-1)

hat1 = 0
hat2 = 0
lastresult = None
for i in range(29, -1, -1):
    g1 = hat1 + (1<<i)
    g2 = hat2 + (1<<i)
    
    if lastresult is None:
        print('?',hat1^ bb,hat2)
        t1 = int(input())
    else:
        t1 = lastresult
    if t1!=0:
        print('?',g1^ bb,g2)
        t2 = int(input())
        if t1!=t2:
            if t1==1:
                hat1+= (1<<i)
            else:
                hat2+= (1<<i)
            lastresult = None
            continue
    lastresult = t1
    print('?',g1^ bb,hat2)
    t3 = int(input())
    if t3==1:
        pass
    else:
        hat1+= (1<<i)
        hat2+= (1<<i)
    
print('!', hat1^bb% (2**30), hat2)



",constant,"bitmasks,constructive algorithms,implementation,interactive",1544
"print(""? 0 0"")
t = int(input())
A=[]
B=[]
a=0
b=0
for i in range(30):
    A.append(-1)
    B.append(-1)
i = 29
d = 2**i
while i>=0:
    a+=d
    b+=d
    print(""?"", end=' ')
    print(a, end=' ')
    print(b)
    s=int(input())
    if s == -t:
        if s==1:
            A[i]=0
            B[i]=1
            b-=d
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
        elif s==-1:
            A[i]=1
            a-=d
            B[i]=0
            print(""?"", end=' ')
            print(a, end=' ')
            print(b)
            t=int(input())
    i-=1
    d//=2
d=1
for j in range(30):
    if A[j]==-1:
        a = a^d
        print(""?"", end=' ')
        print(a, end=' ')
        print(b)
        s = int(input())
        if s==1:
            A[j]=1
            B[j]=1
        else:
            A[j]=0
            B[j]=0
        a = a^d
    d*=2
d=1
a=0
b=0
for i in range(30):
    a+=d*A[i]
    b+=d*B[i]
    d*=2
print(""!"", end=' ')
print(a, end=' ')
print(b)
",constant,"bitmasks,constructive algorithms,implementation,interactive",1031
"import sys
keta=29
print(""?"",0,0,flush=True)


A00=int(input())
if A00==0:
    ANS=0
    for k in range(keta,-1,-1):
        print(""?"",2**k,0,flush=True)
        if int(input())==-1:
            ANS+=2**k
    print(""!"",ANS,ANS,flush=True)
    sys.exit()


A=0
B=0
for k in range(keta,-1,-1):
    LIST=[]
    print(""?"",2**k+A,B,flush=True)
    LIST.append(int(input()))
    print(""?"",A,2**k+B,flush=True)
    LIST.append(int(input()))

    if LIST[0]!=LIST[1]:
        if LIST[0]==-1:
            A+=2**k
            B+=2**k

    else:
        if A00==1:
            A+=2**k
        else:
            B+=2**k
        A00=LIST[0]
print(""!"",A,B,flush=True)
        
        
",constant,"bitmasks,constructive algorithms,implementation,interactive",672
"
from sys import stdout
a, b = 0, 0


mp = 29

c, d = 0,0

powers = [1]
for i in range(32):
    powers.append(powers[-1]*2)

qqq = 0

def get_ans(c, d):
    global qqq
    qqq += 1
    a, b = 1073741823, 1073741821
    a, b = 3, 1

    print(c, d)

    if (a^c) > (b^d): 
        print(1)
        return -1
    elif (a^c) < (b^d):
        print(-1)
        return 1
    print(0)
    return 0

def get_ans(c, d):
    print('? {} {}'.format(c, d))
    stdout.flush()
    return -int(input())

q = get_ans(0, 0)

for i in range(mp+1):
    cp = mp - i
    c += powers[cp]
    d += powers[cp]
    #print('cp, q', cp, q)
    if q == 0:
        continue
    t = get_ans(c, d)
    #print('t', t)

    if t != q:
    #    print('t != q')
    #    print(a, b,c,d)
        if t == 1:
            a += powers[cp]
            c -= powers[cp]
        elif t == -1:
            b += powers[cp]
            d -= powers[cp]
        q = get_ans(c, d)

    #print(a, b, c, d)

#print('qwe', a, b, c, d)


for i in range(mp+1):
    cp = mp - i
    #print(c, powers[cp], d)
    if c & powers[cp] > 0 and d & powers[cp] > 0:
        c -= powers[cp]
        t = get_ans(c, d)

        if t < 0:
            a += powers[cp]
            b += powers[cp]

        c += powers[cp]

print('!', a, b)


",constant,"bitmasks,constructive algorithms,implementation,interactive",1273
"def ask(a, b):
    print(""?"", a, b, flush=True)
    return int(input()) <= 0


def solve(M):
    a, b = 0, 0
    less = ask(0, 0)

    for i in range(M - 1, -1, -1):
        bit = 1 << i
        
        if less:
            if not ask(a | bit, b | bit):
                b |= bit
                less = ask(a, b)
            elif ask(a | bit, b):
                a |= bit
                b |= bit
        else:
            if ask(a | bit, b | bit):
                a |= bit
                less = ask(a, b)
            elif ask(a | bit, b):
                a |= bit
                b |= bit

    print(""!"", a, b, flush=True)

if __name__ == '__main__':
    solve(30)
",constant,"bitmasks,constructive algorithms,implementation,interactive",667
"from sys import stdin,stdout
stdout.flush()
def qu(a,b):
    print(""?"",a,b)
    return int(input())
a=0
b=0
big=qu(a,b)
for i in range(29,-1,-1):
    x=2**i
    f=qu(a+x,b)
    l=qu(a,b+x)
    if l==f:
        if big==1:
            a+=x
        else:
            b+=x
        big=f
    elif f==-1:
        a+=x
        b+=x   
print(""!"",a,b)

",constant,"bitmasks,constructive algorithms,implementation,interactive",344
"import sys
def ask(x,y,rev):
	if (rev==0):
		print(""? %d %d""%(x,y))
	else:
		print(""? %d %d""%(y,x))
	sys.stdout.flush()
	if (rev==1):
		return -int(input())
	else:
		return int(input())

comp=ask(0,0,0)
nowa=0
nowb=0
rev=0
for i in range(29,-1,-1):
	if (comp<0):
		rev^=1
		nowa,nowb=nowb,nowa
		comp=-comp
	if comp>=0:
		comp=ask(nowa|(1<<i),nowb|(1<<i),rev)
		if (comp<0):
			nowa|=1<<i
			comp=ask(nowa,nowb,rev)
		else:
			tmp=ask(nowa|(1<<i),nowb,rev)
			if (tmp<0):
				nowa|=1<<i
				nowb|=1<<i
if (rev==1):
	nowa,nowb=nowb,nowa
print(""! %d %d""%(nowa,nowb))
			
		",constant,"bitmasks,constructive algorithms,implementation,interactive",571
"#a, b = map(int, input().split())
def interact(c, d): return max(min((a ^ c) - (b ^ d), 1), -1)

def main():
	def ask(c, d):
		#return interact(c, d)
		print(""?"", c, d, flush = True)
		return int(input())

	relative = ask(0, 0)
	curA = 0
	curB = 0

	for i in range(29, -1, -1):
		q1 = ask(curA ^ 2 ** i, curB)
		q2 = ask(curA, curB ^ 2 ** i)
	
		if q1 == q2:
			if relative == 1:
				curA ^= 2 ** i
			else:
				curB ^= 2 ** i
			relative = q1
		elif q2 == 1:
			curA ^= 2 ** i
			curB ^= 2 ** i
	return curA, curB
print(""!"", *main())",constant,"bitmasks,constructive algorithms,implementation,interactive",534
"print(""? 0 0"")
ans00 = input()
xr = 0
a = 0
b = 0
cb = 2 ** 29
while cb:
    print(""?"", xr + cb, cb)
    ans11 = input()
    print(""?"", xr, cb)
    if ans11 == ans00:
        ans01 = input()
        if ans01 == '1':
            a += cb
            b += cb
    else:
        ans00 = input()
        if ans11 == '1':
            b += cb
        else:
            a += cb
        xr += cb
    cb //= 2
print(""!"", a, b)",constant,"bitmasks,constructive algorithms,implementation,interactive",415
"from sys import stdout
m = 30
a, b = 0, 0
fle = 1
for i in range(m):
    if fle:
        print('? {} {}'.format(a, b))
        stdout.flush()
        resp1 = int(raw_input())
        fle = 0
    print('? {} {}'.format(a + 2**(m-1-i),b + 2**(m-1-i)))
    stdout.flush()
    resp2 = int(raw_input())
    #print(resp1,resp2,a,b)
    if resp1 == -1 and resp2 == 1:
        b += 2**(m-1-i)
        fle = 1
    elif resp1 == 1 and resp2 == -1:
        a += 2**(m-1-i)
        fle = 1
    else:
        fle = 0
        print('? {} {}'.format(a + 2**(m-1-i), b))
        stdout.flush()
        resp3 = int(raw_input())
        if resp3 == -1:
            b += 2**(m-1-i)
            a += 2**(m-1-i)
        #print(resp1,resp2,resp3,a,b)
print('! {} {}'.format(a,b))
stdout.flush()",constant,"bitmasks,constructive algorithms,implementation,interactive",772
"print('?', 0, 0, flush=True)
t = int(input())
s = [0]*31
if t == 1:
    s[30] = 1
else:
    s[30] = -1

a = 0
b = 0
for i in range(30, 0, -1):
    c = (1 << (i-1)) + a
    d = b
    print('?', c, d, flush=True)
    ans1 = int(input())
    c = a
    d = (1 << (i-1)) + b
    print('?', c, d, flush=True)
    ans2 = int(input())
    if ans1 == -1 and ans2 == 1:
        a += 1 << (i-1)
        b += 1 << (i-1)
        s[i-1] = s[i]
    elif ans1 == 1 and ans2 == -1:
        a += 0 << (i-1)
        b += 0 << (i-1)
        s[i-1] = s[i]
    else:
        s[i-1] = ans1
        if s[i] == 1:
            a += 1 << (i-1)
            b += 0 << (i-1)
        else:
            a += 0 << (i-1)
            b += 1 << (i-1)
print('!', a, b)

",constant,"bitmasks,constructive algorithms,implementation,interactive",733
"print(""? 0 0"", flush=True)
res = input()
i = 1
a = 0
b = 0
for i in range(29,-1,-1):
	print(""?"",(a^(1<<i)), b, flush=True)
	res1 = input()
	print(""?"",a, (b^(1<<i)), flush=True)
	res2 = input()
	if res1 == res2:
		if res == '1':
			a ^= (1<<i)
		else:
			b ^= (1<<i)
		res = res1
	elif res1 == '-1':
		a ^= (1<<i)
		b ^= (1<<i)
print(""!"", a, b, flush=True)",constant,"bitmasks,constructive algorithms,implementation,interactive",355
"
import sys


def query(c, d):
    print('? %d %d' % (c, d))
    sys.stdout.flush()
    res = int(input())
    return res

a = 0
b = 0
big = query(0, 0)

for i in range(29, -1, -1):
    p = query(a ^ (1 << i), b)
    q = query(a, b ^ (1 << i))
    if p == q:
        if big == 1:
            a ^= 1 << i
        else:
            b ^= 1 << i
        big = p
    elif p == -1:
        a ^= 1 << i
        b ^= 1 << i

print('! %d %d' % (a, b))
sys.stdout.flush()
",constant,"bitmasks,constructive algorithms,implementation,interactive",462
"from math import sin
pi = 3.141592653589793238462643383279502884197
n, r = map(int,input().split())
theta = 2*pi / n
R = r / (1-sin(theta/2))
print(R-r)",constant,"binary search,geometry,math",152
"import math
n, r = list(map(int, input().split(' ')))
l = 2 * r * math.sin(math.pi/n)
R = l * r / (-l + 2*r)
print(R)",constant,"binary search,geometry,math",117
"import math

n, r = map(float, input().split())
a = math.pi / n
s = math.sin(a)
R = (r * s) / (1 - s)
print(R)
",constant,"binary search,geometry,math",111
"import math

n, r = map(int, input().split())
angle = math.pi / n
s = math.sin(angle)
#rad = 1 / math.sin(angle) - 1
#print('%.8f' % (r / rad))
print('%.8f' % (r * s / (1 - s)))
",constant,"binary search,geometry,math",178
"import math

n,r = [int(x) for x in input().split()]

x = math.sin(math.pi/n)

y = (x*r)/(1-x)

print(y)",constant,"binary search,geometry,math",104
"import math
n,r = list(map(int,input().split()))
angle = math.pi/(n)
c = math.sin(angle)
k = c/(1-c)
R = k*r
R = float(format(R,'.7f'))
print(R)",constant,"binary search,geometry,math",144
"def solve(a, b, c):
    D = b * b - 4 * a * c
    k = D**0.5
    x1 = (-b+k)/(2*a)
    x2 = (-b-k)/(2*a)
    return max(x1,x2)

from math import *
n, r = map(int, input().split())
a = (1/tan(pi/n))**2
b = -2 * r
c = -(r*r)
ans = solve(a,b,c)
print(""%.10f"" % ans)",constant,"binary search,geometry,math",262
"from math import sin, pi

n, r = map(int, input().split())

print(r * sin(pi / n) / (1 - sin(pi / n)))
",constant,"binary search,geometry,math",103
"from math import sin, pi
n, r = map(int, input().split())

def p(n, r):
    return 2 * n * r * sin(pi / n)

le = 0; ri = r * 1000
while ri - le > 1e-9:
    m = (ri + le) / 2
    if p(n, r + m) < n * m * 2:
        ri = m
    else:
        le = m
print(m)",constant,"binary search,geometry,math",254
"import math

n, r = (int(x) for x in input().split())

#print(n, r)

s = math.sin(math.pi/n)
ans = (r*s)/(1-s)

print(""%.7f"" % ans)",constant,"binary search,geometry,math",131
"import math


n, r = map(int, input().split())

a = math.pi/n
sin = math.sin(a)
R = r*sin/(1-sin)

print(R)",constant,"binary search,geometry,math",107
"import math

n, r = map(int, input().split())
s = math.sin(math.pi / n)
print('%.7lf' % (r * s / (1 - s)))",constant,"binary search,geometry,math",106
"from math import pi, sin
from decimal import Decimal

n, r = map(int, input().split())
alpha = Decimal(pi)/Decimal(n)
a = Decimal(sin(alpha))
R = Decimal((r * a) / (1 - a))
print(R)",constant,"binary search,geometry,math",181
"from math import sin
n,r=[int(i) for i in input().split()]
pi=3.14159265359
print(r/((2*sin(pi*(1/2-1/n)))/(sin(2*pi/n))-1))",constant,"binary search,geometry,math",124
"from math import sin, pi
n, r = map(int, input().split())
R = r*sin(pi/n)/(1-sin(pi/n))
print(R)
",constant,"binary search,geometry,math",97
"import math
n,r=map(int,input().split())
print(r/( 1/math.cos(math.pi*(n-2)/2/n)-1))",constant,"binary search,geometry,math",84
"import math
n, r = [int(i) for i in input().split()]

t = math.sin(math.pi/n)
res = r*t/(1-t)
print(res)",constant,"binary search,geometry,math",104
"from math import pi, sin

n, r = map(float, input().split())
ang = pi / n
k = sin(ang)
print(k * r /  (1 - k))
",constant,"binary search,geometry,math",111
"import math

N,r=map(int,input().split())

#sin(360/N)=R/(r+R)

print(r*math.sin(math.pi/N)/(1-math.sin(math.pi/N)))
#print(math.sin(math.pi/N))
",constant,"binary search,geometry,math",145
"n,k=map(int,input().split())
if k>=n-1:
    print(n-1)
else:
    print(k+ ((n-k)*(n-k+1))//2 - 1)",constant,"dp,greedy,math",97
"n, v = map(int, input().split())

result = v-1 + (n-v)*(n-v+1)//2 if n-1 > v else n-1
print(result)",constant,"dp,greedy,math",99
"if __name__ == '__main__':    
    nums = input().split()
    n = int(nums[0])
    v = int(nums[1])

    if n < v+2:
        print(n - 1)
    else:
        print(int(v-1 + (n-v)*(n-v+1)/2))",constant,"dp,greedy,math",189
"citys,cap=map(int,input().split())
if citys-1<=cap:
	print(citys-1)
else:
	n=citys-cap
	print(n*(n+1)//2+cap-1)",constant,"dp,greedy,math",111
"s = map(int, raw_input().rstrip().split())
n = s[0]
v = s[1]

primo = min(n -1, v)
if primo == n-1:
    print(primo)
else:
    rimane = n - primo
    print(primo - 1 + (rimane)*(rimane + 1) / 2)",constant,"dp,greedy,math",194
"#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#

""""""
""""""

from operator import itemgetter

n, v = map(int, input().split())

if v >= n-1:
    ans = n-1
else:
    ans = v + ((2+(2+n-v-2))*(n-v-1))//2
print(ans)
",constant,"dp,greedy,math",228
"# import math
# import sys

n,v = [int(x) for x in input().strip().split("" "")]
if v>=(n-1):
	print(n-1)
else:
	print(n-1+((n-1-v)*(n-v)//2))
		",constant,"dp,greedy,math",143
"list_int_input = lambda inp: list(map(int, inp.split()))
int_input = lambda inp: int(inp)
string_to_list_input = lambda inp: list(inp)

n,v=map(int,input().split())
val=v-1+int(((n-v)*(n-v+1))/2)
if n>v:
    print(val)
else:
    print(n-1)",constant,"dp,greedy,math",239
"n, v = map(int, input().split())
if n - 1 > v:
    print(v + (n - v + 2) * (n - v - 1) // 2)
else:
    print(n - 1)",constant,"dp,greedy,math",115
"n,v=[int(x) for x in input().split()]
if v>=(n-1):
    print(n-1)
else:
    print(int((((n-v)*(n-v+1))/2)-1+v))
    
    ",constant,"dp,greedy,math",121
"n,v = map(int,input().split())

if n <= v + 1:
    print( n - 1 )
else:
    b = n - v
    print( v - 1 + ((b*(b+1))//2))
",constant,"dp,greedy,math",121
"n, v = list(map(int, input().split()))
f = lambda x: x*(x+1)//2
print(min(n-1, v)+f(n-min(n-1, v))-1)",constant,"dp,greedy,math",101
"n, k = [int(x) for x in input().split()]
if k == 1:
    print(""1"" + ""0""*(n-1))
elif 3*k <= n:
    # print(""2"")
    print((""0"" * ((n-k)//2)) + ""1"" + (""0""*(k-2)) + ""1"" + ""0"" * ((n-k)//2))
else:
    tmp = ""0"" * ((n-k)//2) + ""1""
    s = tmp
    s = tmp * (n // len(tmp) + 1)
    s = s[:n]
    print(s)",constant,"brute force,greedy,constructive algorithms,math,strings",297
"n, k = [int(x) for x in input().split()]
if k == 1:
    print(""1"" + ""0""*(n-1))
else:
    tmp = ""0"" * ((n-k)//2) + ""1""
    s = tmp
    s = tmp * (n // len(tmp) + 1)
    s = s[:n]
    print(s)",constant,"brute force,greedy,constructive algorithms,math,strings",190
"#saved
n, k = map(int, input().split())
if n == k:
    print('1' * n)
elif k == 1:
    print('0' + '1' * (n - 1))
else:
    x = (n - k) // 2
    a = '0' * x + '1'
    print(a * (n // (x + 1)) + '0' * (n % (x + 1)))",constant,"brute force,greedy,constructive algorithms,math,strings",214
"from math import *
from fractions import *
def li():
  return list(map(int, input().split("" "")))
n,k = li()
if k == 1:
  print(""1"" + ""0""*(n-1))
else:
  a = (n-k)//2
  p = ""1"" + ""0""*a
  ans = p * (n//(a+1)) + p[:(n%(a+1))]
  print(ans)",constant,"brute force,greedy,constructive algorithms,math,strings",234
"k = int(input())

if k<=9:
    print(k)
else:
    num_arr = [9*(i+1)* 10**i for i in range(11)]

    index = 0

    while True:
        if k<=num_arr[index]:
            break
        else:
            k -= num_arr[index]
            index += 1

    digit = index+1
    k += digit-1


    num = k//digit
    offset = k%digit

    string_num = str(10**(digit-1)+ num-1)

    print(string_num[offset])

",constant,"binary search,divide and conquer,implementation",401
"import math
n=int(input())
# 99-9
# 999-99
a=[9]
for i in range(2,20):
    a.append(10**i   - 10**(i-1) )
b=[0]
for i in range(1,20):
    b.append(b[-1]+ i*a[i-1])
for i in range(20):
    if n<=b[i]:
        break
p=b[i-1]
k=n-p
# print(p,k)
ans=10**(i-1) - 1 + math.ceil(k/(i))
# print(k,p,i)
# print(ans,i,k)
if k%i==0:
    print(('0'+str(ans))[i])
else:
    print(('0'+str(ans))[k%i])",constant,"binary search,divide and conquer,implementation",387
"k = int(input())
ch = 0
i = 0
r = 1
while k > r - 1:
    r += 9 * (i + 1) * 10 ** i
    i += 1
r -= 9 * i * 10 ** (i - 1)
#print(r, i)
print(str((k - r) // i + 10 ** (i - 1))[(k - r) % i]  )
",constant,"binary search,divide and conquer,implementation",191
"k=int(input())
i=0
r=1
while(k>=r):
    r+=9*(i+1)*10**i
    i+=1
r=r-(9*i*10**(i-1))
ans=str(((k-r)//i)+10**(i-1))[(k-r)%i]
print(ans)",constant,"binary search,divide and conquer,implementation",135
"k = int(input())
prev=0
nextt=0
NumofDigits=0
#i = 0
#while(summ<(2^12)):
while(True):
    prev = nextt
    nextt = nextt+(9*(10**(NumofDigits-1))*NumofDigits)
    if(k>= prev and k<=nextt):
        break
    NumofDigits=NumofDigits+1
if(NumofDigits==1):
    print(k)
else:
    result = (10**(NumofDigits-1))+int((k-(prev+1))/NumofDigits)
    i=0
    while(True):
        if (k-int(prev+1))%NumofDigits == i:
            break
        i=i+1
    result = str(result)
    print(result[i])",constant,"binary search,divide and conquer,implementation",486
"a = int(input())
c = [1] * 30
for i in range (1,20):
	c[i] = 9 * i * pow(10,i-1)
for i in range (1,15):
	if (a > c[i]):
		a -= c[i]
	else:
		d = int((a-1) / i + pow(10,i-1) - 1)
		e = (a-1) % i + 1
		f = str(d+1)
		print(f[e-1])
		exit()",constant,"binary search,divide and conquer,implementation",237
"n=input()
i=0
while(True):
    if (n-9*10**i*(i+1))<=0:
        break
    n-=9*10**i*(i+1)
    i+=1

a=n/(i+1)
b=n%(i+1)
if(b!=0):
    print(str(10**i+a)[b-1])
else:
    print(str(10**i+a-1)[-1])
",constant,"binary search,divide and conquer,implementation",196
"k = int(input()) - 1

l = 1
c = 9
while k >= c*l:
    k -= c * l
    l += 1
    c *= 10

c = 10**(l-1) + k // l
print(str(c)[k % l])
",constant,"binary search,divide and conquer,implementation",133
"def mp():
    return map(int, input().split())

def f(i):
    return (10 ** i - 10 ** (i - 1)) * i

n = int(input())

i = 1
sum = 0
while n - f(i) >= 0:
    n -= f(i)
    sum += f(i) // i
    i += 1

print(str(sum + (n + i - 1) // i)[n % i - 1])",constant,"binary search,divide and conquer,implementation",245
"#!/usr/bin/env python3
from sys import stdin


def solve(tc):
    k = int(stdin.readline().strip())
    cmp = 9
    ndigit = 1

    while k>(cmp*ndigit):
        k -= cmp*ndigit
        cmp *= 10
        ndigit += 1
    
    num = (10**(ndigit-1)) + ((k-1) // ndigit)
    pos = (k-1) % ndigit

    print(str(num)[pos])
    pass


LOCAL_TEST = not __debug__
if LOCAL_TEST:
    infile = __file__.split('.')[0] + ""-test.in""
    stdin = open(infile, 'r')

tcs = (int(stdin.readline().strip()) if LOCAL_TEST else 1)
tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1",constant,"binary search,divide and conquer,implementation",560
"import sys
k=int(input())
if type(k)!=int or k<=0 or k>pow(10,12) :
        print(""wrong input. try again"")
        sys.exit()
lim_init=lim=decimal=9
c=0
while True:
        c+=1
        if k<=lim:
                diff=lim-k #189-21
                pos=diff%c
                diff=int(diff/c) #168/2=84
                diff=decimal-diff #99-84
                print(''.join(list(reversed(str(diff))))[pos])
                break
        else:
                decimal = int(str(lim_init)*(c+1))
                lim+=int(str(lim_init)+'0'*c)*(c+1)
",constant,"binary search,divide and conquer,implementation",546
"

n=int(input())

x=1

while n>(10**(len(str(x))-1)*9*len(str(x))):
    n-=10**(len(str(x))-1)*9*len(str(x))

    x*=10
    
t=len(str(x))
nadighe=False
while nadighe==False:
    qw=1
    nadighe=True
    while n>(10**(len(str(qw))-1)*9*t):
        n-=10**(len(str(qw))-1)*9*t
        nadighe=False
        qw*=10
    x+=qw-1
   
    
while n>len(str(x)):
    n-=len(str(x))
    x+=1
for i in range(len(str(x))):
    if n!=0:
        s=str(x)[i]
        n-=1
print(s)
    
",constant,"binary search,divide and conquer,implementation",473
"n = int(input())
limit_int = limit = decimal = 9
count = 0
while True:
    count += 1
    if n <= limit:
        difference = limit - n
        position = difference % count
        difference = difference // count
        difference = decimal - difference
        print(''.join(list(reversed(str(difference))))[position])
        break
    else:
        decimal = int(str(limit_int) * (count + 1))
        limit += int(str(limit_int) + '0' * count) * (count + 1)
",constant,"binary search,divide and conquer,implementation",464
"""""""
Strategy: Split sequence into subsequences
according to number of digits. Then find corresponding
number and digit in that number.
""""""

# Standard input.
k=int(input())

# Initilize sequence
num_digits=1
num_numbers=9

k-=1
while k>num_digits*num_numbers:
    # Move sequence starting point. 
    k -= num_numbers*num_digits
    num_digits += 1
    num_numbers *= 10

# Generate number.
number = 10**(num_digits - 1) + k // num_digits
# Find index in that number
index = k % num_digits
answer = str(number)[index]
print(answer)",constant,"binary search,divide and conquer,implementation",531
"L = [(i+1)*9*10**i for i in range(12)]
number = int(input())

exponent=0
while number >= 0:
    number-=L[exponent]
    exponent+=1
exponent-=1
number%=L[exponent]
start = 10**exponent
numDigits = exponent+1
final = start+(number//numDigits-1)
remainder = number%numDigits
if remainder == 0:
    final = str(final)
    print(final[-1])
else:
    final = str(final+1)
    print(final[remainder-1])
'''print(number, exponent, numDigits, start, final, remainder)'''
",constant,"binary search,divide and conquer,implementation",463
"T = (0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889, 98888888889, 1088888888889)
k = int(input())
a = 0
for i in T:
    if i - k > 0:
        a = T.index(i)
        break
temp = T[a] - k
x = temp % a
res = (10 ** a) - 1 - int(temp / a)
ans = int((res % (10 ** (x+1))) / (10 ** x))
print(ans)
",constant,"binary search,divide and conquer,implementation",318
"k=int(input())
x=0
c=0
while(x<k):
    x+=9*(10**c)*(c+1)
    c+=1
p=(x-k)%c
k=((10**c)-int(((x-k)/c))-1)
k=str(k)
print(k[len(k)-(p)-1])",constant,"binary search,divide and conquer,implementation",137
"k=int(input())
a=[]
for i in range(0,12):
    s=9*pow(10,i)*(i+1)
    if k<=s:
        break
    else:
        k-=s
pos=i+1
num=(pow(10,pos-1)+(k//pos)-1)
if k%pos==0:
    print(str(num)[-1])
else:
    print(str(num+(0 if pos==1 else 1))[(k%pos)-1])
 
",constant,"binary search,divide and conquer,implementation",252
"index = int(input())

total = 9
n = 1

while index > total:
    total += (n + 1) * (10**n) * 9
    n += 1
last = 10**(n - 1)
total -= n * 9 * last
index = index - total


r = index % (n)
k = index // n

number = last + k


if r == 0:
    print(str(number - 1)[n-1])
else:
    print(str(number)[r - 1])
",constant,"binary search,divide and conquer,implementation",302
"n = int(input())
a = n * (n + 1) // 2
print(4 * a - 4 * n + 1)",constant,"dp,implementation,math",62
"n=int(input())
print(int(n**2+(n-1)**2))",constant,"dp,implementation,math",40
"#l=list(map(int,raw_input().split()))
n=int(input())
print(2*(n*(n-1))+1)
",constant,"dp,implementation,math",74
"a = int(input())
print(a * (a - 1) * 2 + 1)",constant,"dp,implementation,math",43
"a = int(input())

print(a**2+(a-1)**2)
",constant,"dp,implementation,math",39
"n=int(input())-1
print(2*n*(n+1)+1)
",constant,"dp,implementation,math",36
"n = int(input())
print(n**2 + (n-1)**2)
",constant,"dp,implementation,math",40
"n = int(input())
print(n**2+((n-1)**2))
",constant,"dp,implementation,math",40
"n=int(input())
print(n**2+(n-1)**2)",constant,"dp,implementation,math",35
"# coding: utf-8
import sys
sys.setrecursionlimit(int(1e7))

def main():
    n = int(input().strip())
    print(2*(n*(n-1))+1)
    return

while 1:
    try: main()
    except EOFError: break",constant,"dp,implementation,math",189
"n=int(input())
print(2*n*n-2*n+1)",constant,"dp,implementation,math",33
"def main():
    n = int(input())
    ans = n * n + (n - 1) * (n - 1)
    print(ans)


if __name__ == ""__main__"":
    main()
",constant,"dp,implementation,math",124
"n = int(input())
ans = (2 * (n - 1) ** 2) + 2 * n - 1
print(ans)
",constant,"dp,implementation,math",65
"n = int(input())
print(1+2*((n-1)*n))
",constant,"dp,implementation,math",38
"n = int(input().strip())
print(n**2+(n-1)**2)",constant,"dp,implementation,math",45
"n = int(input())
print(n * n + (n - 1) **2)
",constant,"dp,implementation,math",44
"n = int(input())
print(2*(n**2)-2*n+1)",constant,"dp,implementation,math",38
"n=int(input())
print(2*n**2-2*n+1)",constant,"dp,implementation,math",34
"t1, t2, t3 = input().split()
ans = 2
if t1 == t2 or t2 == t3 or t3 == t1:
    if t1 == t2 == t3:
        ans = 0
    else:
        ans = 1
aaa = []
for i in range(10):
    for j in range(10):
        for k in range(10):
            if k - j == j - i == 1:
                aaa.append({i, j, k})
if t1[1] == t2[1] == t3[1] and {int(t1[0]), int(t2[0]), int(t3[0])} in aaa:
    ans = 0
elif (t1[1] == t2[1] and (abs(int(t1[0]) - int(t2[0])) == 1 or abs(int(t1[0]) - int(t2[0])) == 2)) or (t1[1] == t3[1] and (abs(int(t1[0]) - int(t3[0])) == 1 or abs(int(t1[0]) - int(t3[0])) == 2)) or (t3[1] == t2[1] and (abs(int(t3[0]) - int(t2[0])) == 1 or abs(int(t3[0]) - int(t2[0])) == 2)):
    ans = min(1, ans)
print(ans)",constant,"brute force,implementation",708
"from math import sqrt as sqrt
n, k = map(int, input().split())
t = int(sqrt(8 * n + 8 * k + 9) + 0.0001)
m = (t - 3) // 2
print(n - m)",constant,"binary search,brute force,math",134
"n, k = map(int, input().split())
c = n + k
p = int(0.5 * ((8 * c + 9) ** 0.5 - 3))
print(n - p)
",constant,"binary search,brute force,math",96
"from math import *
n,k=map(int,input().split())
val=int(sqrt(9+(8*(n+k))))
ans=(-3+val)//2
print(n-ans)
",constant,"binary search,brute force,math",104
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time


(n, k) = (int(i) for i in input().split())


start = time.time()

print((2*n+3-int((9+8*(n+k))**0.5))//2)
finish = time.time()
#print(finish - start)
",constant,"binary search,brute force,math",212
"import sys
import math

n, k = list(map(int, sys.stdin.readline().strip().split()))
a = (2 * n + 3 - math.sqrt((2*n+3)**2 - 4 * (n**2 + n - 2 * k))) // 2
print(int(a))",constant,"binary search,brute force,math",167
"n,k=map(int,input().split())
for i in range(10**5):
  if (i*(i+1))//2-(n-i)==k:
    print(n-i)",constant,"binary search,brute force,math",94
"import math
n,k = [int(x) for x in input().split(' ')]
ans = ((2*n + 3) - int(math.sqrt(8*n + 8*k + 9)))//2
print(ans);",constant,"binary search,brute force,math",119
"n, k = map(int, input().split())
d = int((9 + 8 * (n + k)) ** 0.5)
x = (d - 3) // 2
print(n - x)",constant,"binary search,brute force,math",96
"from math import sqrt
n, k = map(int, input().split())
print(int(n - 0.5 * (sqrt(8 * (k + n) + 9) - 3)))
",constant,"binary search,brute force,math",105
"import math
n, k = map(int, input().split())

q = int(-3 + math.sqrt(9 + 8*(n+k)))//2

r = n-q

print(r)",constant,"binary search,brute force,math",104
"n,k=[int(i) for i in input().split()]
a = pow(1+2*k+2*n,0.5) - 1
print(n-int(a))
",constant,"binary search,brute force,math",81
"from sys import stdin, stdout, exit
import math

n, k = map(int, stdin.readline().split())



ans = round((-3 + math.sqrt(9 + 8*(k+n))) / 2)
stdout.write(str(n-ans) + ""\n"")
",constant,"binary search,brute force,math",173
"n,k=map(int,input().split())
b=(9+8*(n+k))**0.5
a=int(b)
print(n-(a-3)//2)",constant,"binary search,brute force,math",74
"def find(n,k):
    x=9+8*(n+k)
    a=(-3+int(x**0.5))//2
    b=n-a
    return b
n,k=list(map(int,input().strip().split(' ')))
print(find(n,k))",constant,"binary search,brute force,math",142
"n, k = map(int, input().split())

a = 1
b = -(2*n+3)
c = (n*n+n-2*k)

d = int((b*b - 4*a*c) ** 0.5)

s1 = (-b + d) // (2 * a)
s2 = (-b - d) // (2 * a)
if s1 >= 0 and s1 <= n:
    print(s1)
else:
    print(s2)
",constant,"binary search,brute force,math",209
"def MI():
    return map(int,input().split())
def I():
    return int(input())
def LI():
    return [int(i) for i in input().split()]

n,k=MI()

b=-(2*n+3)
c=n*n+n-2*k
x=(-b-((b*b-4*c)**0.5))//2
y=(-b+((b*b-4*c)**0.5))//2
x,y=int(x),int(y)
for i in [x-1,x,x+1,y-1,y,y+1]:
    if i**2+b*i+c==0 and 0<=i<=n-1:
        print(i)
        break",constant,"binary search,brute force,math",338
"from math import sqrt

n, k = map(int, input().split())

answer = int(-1.5 + sqrt(9/4 + 2*(n+k)))

print(n - answer)
",constant,"binary search,brute force,math",117
"t=int(input())
for i in range(t):
    n=int(input())
    g=list(map(int,input().split()))
    m1=max(g)
    g.remove(m1)
    m2=max(g)
    dl=len(g)-1
    print(min(dl,m2-1))",constant,"greedy,math,sortings",174
"read = lambda: map(int, input().split())
def sq(x):
    return int(x ** 0.5) ** 2 == x
t = int(input())
for _ in range(t):
    n = int(input())
    if (n % 2 == 0 and sq(n // 2)) or (n % 4 == 0 and sq(n // 4)):
        print('YES')
    else:
        print('NO')",constant,"brute force,geometry,math,number theory",261
"def solve():
    n = int(input())
    for d in [2,4]:
        if n % d != 0:
            continue
        temp = int((n//d) ** (0.5))
        temp -= 1
        while temp*temp < n//d:
            temp += 1
        if temp*temp == n//d:
            print(""YES"")
            return
    print(""NO"")
for _ in range(int(input())):
    solve()
",constant,"brute force,geometry,math,number theory",338
"from math import sqrt
for _ in ' '*int(input()):
    n = int(input())
    if int(sqrt(n/2)) == sqrt(n/2) or int(sqrt(n/4)) == sqrt(n/4):
        print(""YES"")
    else: print(""NO"")",constant,"brute force,geometry,math,number theory",179
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    if n==1:
        return 0
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matridigit[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matridigit[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matridigit[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matridigit[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matridigit[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

square = set([i**2 for i in range(10**5)])

for _ in range(int(input())):
    n = int(input())
    if n%2:
        print(""NO"")
    else:
        k = n//2
        if k in square:
            print(""YES"")
        elif k%2:
            print(""NO"")
        else:
            k = k//2
            if k in square:
                print(""YES"")
            else:
                print(""NO"")
",constant,"brute force,geometry,math,number theory",17797
"def chk(n):
    return int(n**0.5+0.1)**2 == n
for _ in range(int(input())):
    n = int(input())
    if n % 2 == 0 and chk(n//2) or n % 4 == 0 and chk(n//4):
        print(""YES"")
    else:
        print(""NO"")
",constant,"brute force,geometry,math,number theory",210
"import sys
input = sys.stdin.readline

ok = set()
for i in range(114514):
    x = i * i
    ok.add(2 * x)
    ok.add(4 * x)

t = int(input())
for _ in range(t):
    n = int(input())
    ans = ""YES"" if n in ok else ""NO""
    print(ans)",constant,"brute force,geometry,math,number theory",233
"import io
import os


def solve(N,):

    if N % 2 != 0:
        return ""NO""
    N //= 2
    if int(N ** 0.5) ** 2 == N:
        return ""YES""
    if N % 2 != 0:
        return ""NO""
    N //= 2
    if int(N ** 0.5) ** 2 == N:
        return ""YES""
    return ""NO""


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    TC = int(input())
    for tc in range(1, TC + 1):
        (N,) = [int(x) for x in input().split()]
        ans = solve(N,)
        print(ans)
",constant,"brute force,geometry,math,number theory",503
"#!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase


def main():
    from math import sqrt
    for _ in range(int(input())):
        n = int(input())
        if (round(sqrt(n)) ** 2 == n and n % 2 == 0) or round(sqrt(n * 2)) ** 2 == 2 * n:
            print(""YES"")
        else:
            print(""NO"")


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()",constant,"brute force,geometry,math,number theory",2047
"t=int(input())
k=set()
for i in range(1,10**5):
  k.add(4*i*i)
  k.add(2*i*i)
for _ in range(t):
  n=int(input())
  if n in k:
    print('YES')
  else:
    print('NO')",constant,"brute force,geometry,math,number theory",167
"import sys
input=sys.stdin.readline
hashi=dict()
for i in range(1,10**5):
    hashi[i*i]=1
    hashi[(2*i*i)]=1
t=int(input())
for you in range(t):
    n=int(input())
    if(n%2):
        print(""NO"")
        continue
    z=n//2
    if(z in hashi):
        print(""YES"")
    else:
        print(""NO"")
",constant,"brute force,geometry,math,number theory",299
"import sys,math
input = sys.stdin.readline

out = []

t = int(input())
for _ in range(t):
    n = int(input())

    o1 = math.isqrt(n//2)
    o2 = math.isqrt(n//4)

    if 2 * o1 * o1 == n or 4 * o2 * o2 == n:
        out.append('YES')
    else:
        out.append('NO')
print('\n'.join(out))
",constant,"brute force,geometry,math,number theory",293
"def checksq(n):
    m = int(n**0.5)
    if m * m == n:
        return m
    m += 1
    if m * m == n:
        return m
    return -1

def main():
    # n, m = map(int, input().split())
    n = int(input())
    # arr = list(map(int, input().split()))
    # s = input()
    if n % 2 == 1:
        print(""NO"")
        return
    if checksq(n // 2) != -1:
        print('YES')
        return
    n //= 2
    if n % 2 == 1:
        print('NO')
        return
    if checksq(n // 2) != -1:
        print('YES')
    else:
        print('NO')




# for i in range(1):
for i in range(int(input())):
    main()",constant,"brute force,geometry,math,number theory",600
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    if n % 2 == 1:
        print(""NO"")
        return
    n //= 2
    if n == int(n ** 0.5) ** 2:
        print(""YES"")
        return
    if n % 2 == 1:
        print(""NO"")
        return
    n //= 2
    if n == int(n ** 0.5) ** 2:
        print(""YES"")
        return
    print(""NO"")
        

        
for _ in range(int(input())):
    main()",constant,"brute force,geometry,math,number theory",415
"from sys import stdin
t = int(stdin.readline())
for _ in range(t):
    n = int(stdin.readline())
    a = round((n / 2) ** 0.5)
    b = round((n / 4) ** 0.5)
    if 2*a**2 == n or 4*b**2 == n:
        print(""YES"")
    else:
        print(""NO"")
",constant,"brute force,geometry,math,number theory",243
"from math import sqrt

def inpl():
	return list(map(int, input().split()))

def inpi():
	return int(input())

def issq(p):
	x = int(sqrt(p))
	return x*x == p

def g(n):
	return (issq(n//2) and n%2==0) or (issq(n//4) and n%4==0)

def f():
	n = inpi()

	print(""YES"" if g(n) else ""NO"")

t = int(input())
for _ in range(t):
	f()
",constant,"brute force,geometry,math,number theory",325
"import math

def solve(n) :
    if not n%2 and math.sqrt(n//2) == int(math.sqrt(n//2)) :
        print('YES')
        return
    if not n%4 and math.sqrt(n//4) == int(math.sqrt(n//4)) :
        print('YES')
        return
    print('NO')

t = int(input())
for i in range(t) :
    n = int(input())
    solve(n)",constant,"brute force,geometry,math,number theory",309
"import math
for _ in range (int(input())):
    n=int(input())
    s=1
    ch=0
    for i in range (1,31):
        s*=2
        d=math.sqrt(n//s)
        if n%s==0 and d==int(d):
            ch=1
            break
    if ch:
        print(""YES"")
    else:
        print(""NO"")",constant,"brute force,geometry,math,number theory",274
"#   Author: yumtam
#   Created at: 2021-05-02 23:39

def is_square(x):
    sq = int(x**0.5)
    return sq * sq == x

for _ in range(int(input())):
    n = int(input())

    if ((n % 2 == 0 and is_square(n//2))
            or (n % 4 == 0 and is_square(n//4))):
        print(""YES"")
    else:
        print(""NO"")
",constant,"brute force,geometry,math,number theory",311
"T = int(input())
for _ in range(T):
    N = int(input())

    if N%2 == 1:
        print(""NO"")
    else:
        N //= 2
        if N**(1/2) == int(N**(1/2)):
            print(""YES"")
        else:
            if N%2 == 1:
                print(""NO"")
            else:
                N //= 2
                if N**(1/2) == int(N**(1/2)):
                    print(""YES"")
                else:
                    print(""NO"")",constant,"brute force,geometry,math,number theory",425
"import re

inputs = int(input())

for x in range(inputs):
    coordinates = input()
    match = re.match(""R(\d+)C(\d+)"", coordinates)
    if match:
        rows = int(match.group(1))
        columns = int(match.group(2))

        output = """"
        i = 0
        while columns > 0:
            alpha_index = (columns // (26 ** i) - 1) % 26
            output = chr(65 + alpha_index) + output
            # print(columns, alpha_index)
            columns -= (alpha_index + 1) * (26 ** i)
            i += 1
        output += str(rows)
        print(output)
    else:
        match = re.match(""(\D+)(\d+)"", coordinates)
        letters = match.group(1)
        rows = match.group(2)
        columns = 0
        for i in range(len(letters), 0, -1):
            columns += (ord(letters[i - 1]) - 64) * (26 ** (len(letters) - i))
        output = f""R{rows}C{columns}""
        print(output)
",linear,"implementation,math",886
"from math import floor
import re

z = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""

# numbers to row
# def convert_num(x):
#     output = """"
#     row, col = [int(x) for x in re.split(""(\d+)"", x) if x.isnumeric()]
#     while col > 0:
#         if col % 26 == 0:
#             col = floor(col / 26)
#             output += ""Z""
#         else:
#             y = col % 26
#             output += z[y - 1]
#             col = floor(col / 26)
#     return f""{output[::-1]}{row}""
def convert_num(x):
    output = """"
    row, col = [int(x) for x in re.split(""(\d+)"", x) if x.isnumeric()]
    while col > 0:
        y = (col - 1) % 26
        output += z[y]
        col = floor((col - 1) / 26)
    return f""{output[::-1]}{row}""


# letters to alpha
def convert_alpha(x):
    output = 0
    word = ("""".join([i for i in x if i.isalpha()]))[::-1]
    for i in range(0, len(word)):
        output += (z.index(word[i]) + 1) * 26 ** i
    ending = x[len(word) :]

    return f""R{ending}C{output}""


# print(convert_alpha(""BC23""))
# print(convert_num(""R23C55""))

i = int(input())
output = """"
for x in range(i):
    hehexd = input()
    if hehexd.startswith(""R"") and hehexd[1].isnumeric() and ""C"" in hehexd:
        output += f""{convert_num(hehexd)}\n""
    else:
        output += f""{convert_alpha(hehexd)}\n""
print(output)",linear,"implementation,math",1292
"def decimal_to_26(num):
    num = int(num)
    res = ''
    while num:
        mod = num % 26
        if mod == 0:
            res = 'Z' + res
            num = num // 26 - 1
        else:
            num //= 26
            res = chr(mod+64) + res
    return res

def RXCY_to_Excel(c,r):
    new_row = decimal_to_26(r)
    return new_row + str(c)
# print(RXCY_to_Excel(55,23))

n = int(input())
li = []
for i in range(n):
    li.append(input())
for i in li:
    di_index = []
    al_index = []
    temp = i
    for j in range(len(i)):
        if i[j].isalpha():
            al_index.append(j)
            i = i.replace(i[j],' ')
            # print(i)
        elif i[j].isdigit():
            di_index.append(j)
            i = i.replace(i[j],' ')
            # print(i)
    i = temp
    if min(di_index) < max(al_index): # RxxCxx
        # print(i)
        row = int(i[1:i.index('C')])
        col = int(i[i.index('C')+1:])
        # print(row,col,sep=' ')
        print(RXCY_to_Excel(row,col))
    else: # COL + ROW
        row_num = 0
        for k in range(len(i)):
            if i[k].isdigit():
                num_start = k
                break
        # print(i)
        # print(k)
        length = len(i[0:k])
        # print(length)
        for m in range(num_start):
            row_num += 26 ** (length-1) * (ord(i[m])-64) or (ord(i[m])-64)
            # print(row_num)
            length -= 1
        print('R'+i[num_start:]+'C'+str(row_num))








",linear,"implementation,math",1465
"def numtostr(a):
    var=[]
    while a>0:
 
       if a%26==0:
          var.append(""Z"")
          a=a//26-1
       else:
          var.append(chr(a%26-1+ord(""A"")))
          a=a//26
    var.reverse()
    return """".join(var)
 
def strtonum(b):
    par=len(b)
    result=0
    for i in range(1,par):
        result+=(26**i)
    par=len(b)-1
    for elem in b:
        if par!=0:
             result+=((ord(elem)-ord(""A""))*((26)**par))
        else:
            result += ((ord(elem) - ord(""A""))+1)
 
        if par==0:
            break
        par -= 1
    return result
 
def method1(par1):
    C=par1.index(""C"")
    result=numtostr(int(par1[C+1:]))+str(par1[1:C])
    return result
 
def method2(par2):
    c=0
    for elem in par2:
        try:
            if int(elem):
                break
        except:
            c+=1
    return ""R""+par2[c:]+""C""+str(strtonum(par2[:c]))
 
i=input()
inp=[]
for j in range(int(i)):
     x=input()
     inp.append(x)
for key in range(len(inp)):
    if ""R"" in inp[key] and ""C"" in inp[key]:
        try:
            if int(inp[key][1:inp[key].index(""C"")]) and int(inp[key][inp[key].index(""C"")+1:]):
                print(method1(inp[key]))
        except:
            print(method2(inp[key]))
    else:
        print(method2(inp[key]))",linear,"implementation,math",1275
"for _ in range(int(input())):
    s = input()
    ro=co=0
    for c in s:
        if '0'<= c <= '9': ro = 10*ro+int(c)
        elif ro:
            ro, co = s[1:].split('C'); co=int(co)
            v = ''
            while co:
                co-=1
                r = co%26
                co = co//26
                v += chr(65+r)
            print(v[::-1]+ro)
            break
        else: co = co*26 + ord(c) - 64
    else:
        print(""R{}C{}"".format(ro, co))
    
",linear,"implementation,math",475
"import re
import string
import math

letter_number_pattern = ""[a-zA-Z]*[0-9]*""

alpha = dict(zip(range(1,28), string.ascii_uppercase))
decimals = dict(zip(string.ascii_uppercase, range(1,27)))


alpha_len = len(alpha)

def letter_to_decimal(n):
    exponents = []
    pow_i = 0
    while True:
        if n // (26**pow_i) > 26:
            exponents.append(1)
            n = n - (26**pow_i)
            pow_i += 1
        else:
            exponents.append(n // (26**pow_i))
            n = n - ((n // (26**pow_i)) * (26**pow_i))
            break
    pow_i = pow_i - 1
    while n != 0:
        t = n // (26**pow_i)
        n = n - (t * (26 ** pow_i))
        exponents[pow_i] = exponents[pow_i] + t
        pow_i = pow_i - 1
    result = ''.join(list(map(lambda x: alpha[x], reversed(exponents))))
    return result


def letters_to_deci(letters):
    total_sum = 0
    pows = list(reversed(range(len(letters))))
    for i in range(len(letters)):
        total_sum += decimals[letters[i]] * (26**pows[i])
    return total_sum

input_cells = []

n_lines = input()
for i in range(int(n_lines)):
    input_cells.append(input())

for cell in input_cells:
    all_matches = re.findall(letter_number_pattern, cell)[:-1]
    if len(all_matches) == 2:
        rows = int(re.search(""[0-9]*$"", all_matches[0]).group())
        cols = int(re.search(""[0-9]*$"", all_matches[1]).group())
        converted_cols = letter_to_decimal(cols)
        print(""%s%s"" % (converted_cols, rows))
    elif len(all_matches) == 1:
        rows = re.match(""[A-Z]*"", all_matches[0]).group()
        cols = re.search(""[0-9]*$"", all_matches[0]).group()
        converted_rows = letters_to_deci(rows)
        print(""R%sC%s"" % (cols, converted_rows))
    else:
        pass",linear,"implementation,math",1741
"def parse(line):
	i = 0
	while line[i].isalpha():
		i += 1
	i1 = i
	while i < len(line) and line[i].isdigit():
		i += 1
	return line[:i1], int(line[i1:i]), line[i:]

for _ in range(int(input())):
	a1, n1, rest = parse(input())
	if rest:
		_, n2, _ = parse(rest)
		a2 = ''
		while n2:
			r = (n2 - 1) % 26
			a2 = chr(r + ord('A')) + a2
			n2 = (n2 - r - 1) // 26
		print(a2 + str(n1))
	else:
		n2 = 0
		for c in a1:
			n2 = 26 * n2 + (ord(c) - ord('A') + 1)
		print(f'R{n1}C{n2}')
		

",linear,"implementation,math",485
"def solution():
    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        # R23C55 -> BC23
        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v = list()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                p += 1

            sr = s[:p]
            sc = s[p:]

            c = 0
            for x in sr:
                c = c * 26 + (ord(x) - ord('A') + 1)

            print(""R%sC%d"" % (sc, c))


if __name__ == ""__main__"":
    solution()
",linear,"implementation,math",950
"def solution():
    v = list()

    n = int(input())
    for _ in range(n):
        s = input()
        p = s.find('C')

        # R23C55 -> BC23
        if s[0] == 'R' and s[1].isdigit() and p > 1:
            r = int(s[1:p])
            c = int(s[(p + 1):])

            v.clear()
            while c > 0:
                if c % 26 == 0:
                    v.append('Z')
                    c = (c - 1) // 26
                else:
                    v.append(chr(ord('A') + (c % 26 - 1)))
                    c //= 26

            v.reverse()
            print(""%s%d"" % ("""".join(v), r))

        else:
            c = 0
            p = 0
            while p < len(s):
                if s[p].isdigit():
                    break
                c = c * 26 + (ord(s[p]) - ord('A') + 1)
                p += 1

            print(""R%sC%d"" % (s[p:], c))


if __name__ == ""__main__"":
    solution()
",linear,"implementation,math",898
"a,k=map(int,input().split())
p=[]
for n in range(2,a+1):
	for i in range(2,int(n**0.5)+1):
		if n%i==0:
			break
	else:
		p.append(n)
c=0
for i in range(0,len(p)-1):
	n=p[i]+p[i+1]+1
	for i in range(2,int(n**0.5)+1):
		if n%i==0:
			break
	else:
		if n<=a:
			c+=1
if c>=k:
	print(""YES"")
else:
	print(""NO"")
",linear,"brute force,math,number theory",307
"n,k = map(int,input().split())
B = [1]*(n+1)
B[0] = B[1] = 0
for i in range(2,n+1):
    if B[i] == 1:
        m = 2
        while m*i <= n:
            B[m*i] = 0
            m += 1
C = []
D = []
for i in range(len(B)):
    if B[i] != 0:
        D.append(i)
for i in range(1,len(D)):
    c = D[i] + D[i-1] + 1
    if c <= n:
        C.append(c)
x = 0
for i in range(len(C)):
    if B[C[i]] == 1:
        x += 1
if x >= k:
    print('YES')
else:
    print('NO')",linear,"brute force,math,number theory",460
"def prime(n):
    j = 3
    while j * j <= n:
        if n % j == 0:
            return False
        j += 2
    return True
ref = [2]
for j in range(3, 1000, 2):
    if prime(j) == True:
        ref.append(j)
def check(n):
    for j in range(1, len(ref) - 1):
        v = n - ref[j] - 1
        if ref[j - 1] == v or ref[j + 1] == v:
            return True
        if j > n:
            break
    return False
arr = []
for j in range(3, 1001, 2):
    if prime(j) == True and check(j) == True:
        arr.append(j)
n, k = [int(j) for j in input().split()]
count = 0
for j in range(2, n + 1):
    if j in arr:
        count += 1
if count >= k:
    print(""YES"")
else:
    print(""NO"")
",linear,"brute force,math,number theory",684
"n,k=map(int,input().strip().split())
v = []
for i in range(2,n+1):
	if all(i%j!=0 for j in v):
		v.append(i)
c = 0
for i in range(len(v)-1):
	if 1+v[i]+v[i+1] in v:
		c += 1
if c >= k:
	print(""YES"")
else:
	print(""NO"")",linear,"brute force,math,number theory",217
"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
n,k=map(int,input().split())
c=0
for i in range(len(l)-1):
    if(l[i]+l[i+1]+1 in l and l[i]+l[i+1]+1<=n):
        c+=1
if(c>=k):
    print('YES')
else:
    print('NO')
        ",linear,"brute force,math,number theory",983
"import math



n,k = map(int,input().split())
l=[]
c=0
for j in range(2,n):
    p=0

    for i in range(2,int(math.sqrt(j))+1):

        if j%i==0:

            p=1
            break
        else:
            pass

    if p==0:
        l.append(j)

l+=[n]

for i in range(len(l)-1):

    if (l[i]+l[i+1]+1) in l:

        c+=1
if c>=k:
    print(""YES"")
else:
    print(""NO"")
",linear,"brute force,math,number theory",375
"def f(n):
    k=2
    while k*k<=n:
        if n%k==0:
            return False
        k+=1
    return True
n,k=map(int,input().split())
a=[]
x=0
for i in range(2,n+1):
    if f(i):
        a.append(i)
for i in range(len(a)-2):
    if a[i]+a[i+1]+1 in a:
        x+=1
if x>=k:
    print('YES')
else:
    print('NO')
",linear,"brute force,math,number theory",317
"import sys
import math
import bisect
from sys import stdin, stdout
from math import gcd, floor, sqrt, log
from collections import defaultdict as dd
from bisect import bisect_left as bl, bisect_right as br
from collections import Counter
from collections import defaultdict as dd

# sys.setrecursionlimit(100000000)

flush = lambda: stdout.flush()
stdstr = lambda: stdin.readline()
stdint = lambda: int(stdin.readline())
stdpr = lambda x: stdout.write(str(x))
stdmap = lambda: map(int, stdstr().split())
stdarr = lambda: list(map(int, stdstr().split()))

mod = 1000000007

def sieve(n):

    prime = [True for _ in range(n+1)]
    p = 2

    while(p*p <= n):
        if(prime[p] == True):

            for i in range(p*p, n+1, p):
                prime[i] = False

        p += 1

    return prime


# for _ in range(stdint()):
n,k = stdmap()

all = sieve(n)

# print(all)

primes = []

for i in range(1, len(all)):
    if(all[i] == True):
        primes.append(i)

s = Counter(primes)

res = 0

for i in range(len(primes)-1):
    toCheck = primes[i]+primes[i+1]+1

    if(toCheck in s):
        res += 1

if(res >= k):
    print(""YES"")
else:
    print(""NO"")
",linear,"brute force,math,number theory",1158
"y = [2]
h = []
j = 0
for i in range(3,1000):
    z = 0
    for x in range(2, int(i**0.5)+1):
        if i%x == 0:
            z+=1
    if z == 0:
        y.append(i)
for i in range(0,len(y)-1):
    x = y[i]+y[i+1]
    h.append(x)

k = list(input().split())
a = int(k[0])
b = int(k[1])

for i in range(0,len(h)):
    h[i] = h[i] + 1

g = []

for i in h:
    z = 0
    for x in range(2, int(i**0.5)+1):
        if i%x == 0:
            z+=1
            
    if z == 0:
        g.append(i)
#print(g)

for i in g:
    if i>=2 and i<=a:
        j+=1
if j >= b:
    print(""YES"")
else:
    print(""NO"")

",linear,"brute force,math,number theory",596
"''' 25A - IQ test '''
try:
    odd, even, oddIndex, evenIndex = 0, 0, 0, 0
    n = int(input())
    s = list(map(int, input().split()))
    counter = 0
    for i in s:
        if i % 2 == 0:
            even += 1
            evenIndex = counter
        else:
            odd += 1
            oddIndex = counter
        counter += 1
    ans = evenIndex + 1 if even == 1 else oddIndex + 1
    print(ans)
except EOFError as e:
    pass",linear,brute force,432
"n = int(input())
arr = list(map(int, input().split()))
codd = 0
ceven = 0
ptodd = -1
pteven = -1
for i in range(n):
    if arr[i]%2 == 0:
        ceven += 1
        pteven = i
    else:
        codd += 1
        ptodd = i

if ceven == 1:
    print(pteven+1)
else:
    print(ptodd+1)",linear,brute force,282
"n=int(input())
def judge(x):
    if x%2==0:
        return 0
    else:
        return 1
ls=[int(x) for x in input().split()]
if judge(ls[0])==judge(ls[1]):
    for x in ls[2:]:
        if judge(x)!=judge(ls[0]):
            print(ls.index(x)+1)
            break
else:
    if judge(ls[2])==judge(ls[0]):
        print(2)
    elif judge(ls[2])==judge(ls[1]):
        print(1)",linear,brute force,374
"a = int(input())
b = list(map(int, input().split()))
c = [int(i % 2 == 0) for i in b]
if(c.count(1) == 1):
	print(c.index(1) + 1)
else:
	print(c.index(0) + 1)
	
		  	 		 	  	 	   		 			 	   		",linear,brute force,192
"input()
l=[int(x)%2 for x in input().split()]
print(l.index(sum(l)==1)+1)",linear,brute force,73
"n = int(input())

lst = list(map(int, input().split()))

evens = []
odds = []

for e, x in enumerate(lst):
    if x % 2 == 0:
        evens.append(e + 1)
    else:
        odds.append(e + 1)

if len(evens) < len(odds):
    print(evens[0])
else:
    print(odds[0])
",linear,brute force,264
"n=int(input())
li=list(map(int,input().split()))
lis=[x%2 for x in li]
if lis.count(0)>lis.count(1):
    print(lis.index(1)+1)
else:
    print(lis.index(0)+1)",linear,brute force,158
"n = int(input())
a = list(map(int, input().split()))
chet = 0
ne_chet = 0
chet1 = []
ne_chet1 = []
for i in range(len(a)):
    if a[i] % 2 == 0:
        chet += 1
        chet1.append(a[i])
    else:
        ne_chet += 1
        ne_chet1.append(a[i])
    if chet >= 1 and ne_chet >= 1 and (chet > 1 or ne_chet > 1):
        break
if chet == 1:
    print(a.index(chet1[0]) + 1)
elif ne_chet == 1:
    print(a.index(ne_chet1[0]) + 1)
",linear,brute force,432
"n = int(input())
l = list(map(int,input().split()))
c1 = 0
c2 = 0
for i in l:
    if i % 2 == 0:
        c1+=1
    else:
        c2+=1
            
for i in range(len(l)-1,-1,-1):
    if l[i] % 2 == 0:
        lasteven = i
        break
for i in range(len(l)-1,-1,-1):
    if l[i] % 2 != 0:
        lastodd = i
        break
if c1 == 1:
    print(lasteven + 1)
else:
    print(lastodd + 1)
",linear,brute force,390
"n, s = int(input()), input() * 2
h = s.count('H') // 2
print(h - max(s[i:i + h].count('H') for i in range(n)))",linear,two pointers,110
"n=int(input())
a=input()
b=a.count('T')
c=-1
for i in range(n):
    d=0
    for j in range(b):
        d+=int(a[(i+j)%n]=='H')
    if c==-1 or d<c:
        c=d
print(c)",linear,two pointers,168
"a = int(input())
s = input()
d = s.count('H')
p = []
for i in range(len(s)):
	if i+d > len(s):
		n = d+i - len(s)
		m = d - n
		h = s[:m] + s[-n:]
		k = h.count(""T"")
		p.append(k)
	else:
		h = s[i:d+i]
		k = h.count(""T"")
		p.append(k)
mi = a
for i in range(len(p)):
	if p[i] < mi:
		mi = p[i]
if s.count(""H"") == 1 or s.count(""T"") == 0:
	print(0)
else:
	print(mi)

",linear,two pointers,364
"# your code goes here
import sys
n=int(input())
s=input()
s+=s
h=0
for i in range(n):
	if s[i]=='H':
		h+=1
ans=h
for i in range(n):
	c=0
	for j in range(i,i+h):
		if s[j]=='T':
			c+=1
	ans=min(ans,c)
print(ans)
	

	
	
	

 		 	 	  			 	 	  		 		  	  		",linear,two pointers,253
"def process(S):
    n = len(S)
    h_count = 0
    answer = float('inf')
    for c in S:
        if c=='H':
            h_count+=1
    current = 0
    for i in range(h_count):
        if S[i]=='H':
            current+=1
    answer = min(answer, h_count-current)
    for i in range(h_count, n+h_count):
        if i > n-1:
            i1 = i-n
        else:
            i1 = i 
        i2 = i-h_count
        if S[i1]=='H':
            current+=1
        if S[i2]=='H':
            current-=1
        answer = min(answer, h_count-current)
    return answer

n = int(input())
S = input()
print(process(S))",linear,two pointers,604
"R = lambda : map(int, input().split())
n = int(input())
s = input()
hc, tc = s.count('H'), s.count('T')
hr = min([s[i:i + hc].count('T') for i in range(n - hc)])
tr = min([s[i:i + tc].count('H') for i in range(n - tc)])
print(min(hr, tr))",linear,two pointers,238
"n=int(input())
s=input()

h=s.count('H')
s=s+s
print(min(s[i:i+h].count('T') for i in range(n)))
",linear,two pointers,97
"n, s = int(input()), input() * 2

h = s.count('H') // 2

print(h - max(s[i:i + h].count('H') for i in range(n)))



# Made By Mostafa_Khaled",linear,two pointers,140
"# -*- coding:utf-8 -*-

""""""

created by shuangquan.huang at 11/2/18

""""""



def steps(start, target):
    
    ans = 0
    for i, v in enumerate(start):
        u = target[i]
        if v != u:
            for j in range(i+1, len(start)):
                a, b = start[j], target[j]
                if a != b and a == u:
                    start[i], start[j] = start[j], start[i]
                    break
            ans += 1
    
    return ans


def solve(seq):
    hc = seq.count('H')
    tc = len(seq) - hc
    ans = float('inf')
    for i in range(tc+1):
        s = ['T'] * i + ['H'] * hc + ['T'] * (tc-i)
        ans = min(steps(seq.copy(), s), ans)
    for i in range(hc+1):
        s = ['H'] * i + ['T'] * tc + ['H'] * (hc-i)
        ans = min(steps(seq.copy(), s), ans)
    return ans
    
    
N = int(input())
line = list(input())
print(solve(line))",linear,two pointers,862
"n, k = map(int,input().split())
arr = list(map(int, input().split()))

def find_segment(arr, n, k):
  f = [0]*100001
  L = count = 0
  R = -1
  while R < n-1:
    R += 1
    if f[arr[R]] == 0:
      count += 1
    f[arr[R]] += 1
    while count == k:
      f[arr[L]] -= 1
      if f[arr[L]] == 0:
        print(L+1, R+1)
        return
      L += 1
  print(-1,-1)
find_segment(arr, n, k)",linear,"bitmasks,implementation,two pointers",387
"n,k = map(int,input().split())
a = list(map(int,input().split()))

count = 0
b = {}
for i in range(n):
    if a[i] in b:
        b[a[i]] += 1
    else:
        b[a[i]] =1
    if b[a[i]] == 1:
        count += 1
    if count == k:
        break
#print(""i="", i)
#print(b)


for j in range(n):
  if a[j] in b:
    b[a[j]] -= 1
#    print(""j="", j)
#    print(b)
  if b[a[j]] == 0:
    break 
#  print(""j="",j)
        
if count != k:
    print(""-1 -1"")
else:
  if n == 1:
    print(1,1)
  elif n == 2 and count == 2:
    print(1,2)
  else:
    print(j+1,i+1)  ",linear,"bitmasks,implementation,two pointers",555
"n,k=map(int, input().split())
a=list(map(int, input().split()))
i=0
d=0
x=-1
y=-1
s=[0]*(10**5+1)
for j in range (len(a)):
    s[a[j]]+=1
    i+=1
    if s[a[j]]==1:
        d+=1
    if i==1:
        x=j+1
    if d==k:
        y=j+1
        break
while k!=1 and s[a[x-1]]-1!=0:
    s[a[x-1]]-=1
    x+=1
if x==-1 or y==-1:
    x=-1
    y=-1
print(x,y)",linear,"bitmasks,implementation,two pointers",351
"# minimal by inclusion means that any subset cannot satisfy the same requirements (essentially no duplicates at either end)

n, k = map(int, input().split())
values, single, l, r = [int(i) for i in input().split()], set(), -1, -1
for i in range(n):
    single.add(values[i])
    if len(single) == k:
        l, r = 1, i + 1
        break
single = set()
for i in range(r - 1, max(-1, l - 2), -1):
    single.add(values[i])
    if len(single) == k:
        l = i + 1
        break
        
if len(single) < k:
    print(-1, -1)
else:
    print(l, r)
",linear,"bitmasks,implementation,two pointers",548
"from sys import stdin,stdout
from collections import Counter
nmbr=lambda:int(stdin.readline())
lst = lambda: list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n,k=lst()
    a=lst()
    d={};r=l=-2
    for i in range(n):
        d[a[i]]=d.get(a[i],0)+1
        if len(d)==k:
            r=i
            break
    for i in range(r+1):
        if d[a[i]]==1:
            l=i
            break
        d[a[i]]-=1
    print(l+1,r+1)",linear,"bitmasks,implementation,two pointers",449
"n, k= map(int, input().split())
A = list(map(int, input().split()))
C = [0] * 100001

l = 0
r = 0
p = 0

while r<n and p < k:
    C[A[r]] += 1
    if C[A[r]] == 1:
        p += 1
    r += 1
if p != k:
    print('-1', '-1')
else:
    while p == k:
        C[A[l]] -= 1
        if C[A[l]] == 0:
            p -= 1
        l +=1
        
    l -= 1
    
    print(l+1,r)",linear,"bitmasks,implementation,two pointers",367
"n, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

count = [0]*(int(1e5+1))

for i in arr:
    count[i] += 1

s = sum([1 if i>0 else 0 for i in count])
if s < k:
    print('-1 -1')
    exit()

r = n-1
while True:
    if count[arr[r]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[r]] -= 1
    r -= 1

l=0
while True:
    if count[arr[l]] == 1:
        s -= 1
        if s < k:
            s += 1
            break
    count[arr[l]] -= 1
    l += 1

print(l+1, r+1)

",linear,"bitmasks,implementation,two pointers",537
"n,k=map(int,input().split())
a=list(map(int,input().split()))
q={0}
e=0
l=[]
for i in range(n):
    if a[i] not in q:
        e+=1
        q.add(a[i])
    if e==k:
        e=0
        q={0}
        l+=[i]
w=10**5
t=0
for i in l:
    e=0
    q={0}
    for j in range(i,-1,-1):
        if a[j] not in q:
            e+=1
            q.add(a[j])
        if e==k:
            if w>len(q):
                w=j+1
                t=i+1
            break
if len(set(a))>=k:print(w,t)
else:print(-1,-1)
",linear,"bitmasks,implementation,two pointers",494
"n, m = map(int, input().split())
arr = list(map(int, input().split()))
d = {}
i = 1
for x in arr:
	if len(d) == m:
		break
	d[x] = i
	i += 1
if len(d) == m:
	print(min(d.values()), max(d.values()))
else:
	print(-1,-1)
",linear,"bitmasks,implementation,two pointers",218
"def process(X, a, b):
    X1 = set(X)
    Other = set([])
    A = set([])
    B = set([])
    Both = set([])
    for x in X:
        if a-x in X1 and b-x  not in X1:
            A.add(x)
            A.add(a-x)
        elif a-x not in X1 and b-x in X1:
            B.add(x)
            B.add(b-x)
        elif a-x not in X1 and b-x not in X1:
            return 'NO'
        else:
            Both.add(x)
    start = A.copy()
    while len(start) > 0:
        next_s = set([])
        for x in start:
            if b-x in Both:
                Both.remove(b-x)
                next_s.add(b-x)
                if a-b+x in Both:
                    Both.remove(a-b+x)
                    A.add(a-b+x)
                    next_s.add(a-b+x)
                A.add(b-x)
            if a-x in Both:
                Both.remove(a-x)
                next_s.add(a-x)
                A.add(a-x)
            elif a-x in B or a-x not in A:
                return 'NO'
        start = next_s
    start = B.copy()
    while len(start) > 0:
        next_s = set([])
        for x in start:
            if a-x in Both:
                Both.remove(a-x)
                next_s.add(a-x)
                if b-a+x in Both:
                    Both.remove(b-a+x)
                    B.add(b-a+x)
                    next_s.add(b-a+x)
                B.add(a-x)
            if b-x in Both:
                Both.remove(b-x)
                next_s.add(b-x)
                B.add(b-x)
            elif b-x in A or b-x not in B:
                return 'NO'
        start = next_s
    answer = []
    for x in X:
        if x in A:
            answer.append(0)
        else:
            answer.append(1)
    return answer

n, a, b = [int(x) for x in input().split()]
X = [int(x) for x in input().split()]
answer = process(X, a, b)
if answer=='NO':
    print('NO')
else:
    print('YES')
    print(' '.join(map(str, answer)))
        
                
    
            ",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",1939
"parent = [i for i in range(int(1e5 + 10))]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    if findSet(n) == findSet(n + 1):
        print('NO')
    else:
        print('YES')
        tmp = findSet(n + 1)
        lst = [0 if findSet(i) == tmp else 1 for i in range(n)]
        print(*lst)",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",830
"class DisjointSet:
    def __init__(self, n):
        self._fa = list(range(n))

    def union(self, x, y):
        x = self.get_father(x)
        y = self.get_father(y)
        self._fa[x] = y
        return y

    def get_father(self, x):
        y = self._fa[x]
        if self._fa[y] == y:
            return y
        else:
            z = self._fa[y] = self.get_father(y)
            return z

    def __repr__(self):
        return repr([self.get_father(i) for i in range(len(self._fa))])

def solve(n, a, b, xs):
    h = {x: i for i, x in enumerate(xs)}
    if a == b:
        if all(a - x in h for x in xs):
            return [0] * n
        return False
    g1 = n
    g2 = n + 1
    ds = DisjointSet(n + 2)

    for i, x in enumerate(xs):
        for t in (a, b):
            if t - x in h:
                ds.union(i, h[t - x])

    for i, x in enumerate(xs):
        b1 = (a - x) in h
        b2 = (b - x) in h
        if b1 + b2 == 0:
            return False
        if b1 + b2 == 1:
            if b1:
                ds.union(i, g1)
            else:
                ds.union(i, g2)
            if ds.get_father(g1) == ds.get_father(g2):
                return False
    group = [None] * n
    for i, x in enumerate(xs):
        f = ds.get_father(i)
        if f < n:
            return False
        group[i] = f - n
    return group

n, a, b = map(int, input().split())
xs = list(map(int, input().split()))
group = solve(n, a, b, xs)
if isinstance(group, list):
    print('YES')
    print(' '.join(map(str, group)))
else:
    print('NO')",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",1557
"parent = [i for i in range(int(1e5 + 2))]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    pa = findSet(n)
    pb = findSet(n + 1)
    if pa == pb:
        print('NO')
    else:
        print('YES')
        lst = [0 if findSet(i) == pb else 1 for i in range(n)]
        print(*lst)",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",823
"def findSet(u, parent):
    if parent[u] != u:
        parent[u] = findSet(parent[u], parent)
    return parent[u]

def unionSet(u, v, parent):
    up = findSet(u, parent)
    vp = findSet(v, parent)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    parent = [i for i in range(n + 2)]
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]], parent)
        else:
            unionSet(i, n, parent)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]], parent)
        else:
            unionSet(i, n + 1, parent)

    pa = findSet(n, parent)
    pb = findSet(n + 1, parent)
    if pa == pb:
        print('NO')
    else:
        print('YES')
        lst = [0 if findSet(i, parent) == pb else 1 for i in range(n)]
        print(*lst)",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",916
"parent = [i for i in range(100002)]
def findSet(u):
    if parent[u] != u:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

if __name__ == '__main__':
    n, a, b = map(int, input().split())
    lst = list(map(int, input().split()))
    temp = {lst[i]: i for i in range(n)}
    for i in range(n):
        if a - lst[i] in temp:
            unionSet(i, temp[a - lst[i]])
        else:
            unionSet(i, n)
        if b - lst[i] in temp:
            unionSet(i, temp[b - lst[i]])
        else:
            unionSet(i, n + 1)

    pa = findSet(n)
    pb = findSet(n + 1)
    if pa == pb:
        print('NO')
    else:
        print('YES')
        lst = [0 if findSet(i) == pb else 1 for i in range(n)]
        print(*lst)",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",817
"def find(u):
    global par
    if u != par[u]:
        par[u] = find(par[u])
    return par[u]

def union(u, v):
    u = find(u)
    v = find(v)
    par[u] = v

n, a, b = map(int, input().split())
p = list(map(int, input().split()))
mp = dict()
for i in range(n):
    mp[p[i]] = i + 1
par = [i for i in range(n + 2)]

for i in range(n):
    union(i + 1, mp.get(a - p[i], n + 1))
    union(i + 1, mp.get(b - p[i], 0))

A = find(0)
B = find(n + 1)

if A != B:
    print('YES')
    print(' '.join(['1' if find(i) == B else '0' for i in range(1, n + 1)]))
else:
    print('NO')",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",574
"def findSet(u):
  if parents[u] != u:
    parents[u] = findSet(parents[u])
  return parents[u]


def unionSet(u, v):
  up = findSet(u)
  vp = findSet(v)
  if up == vp:
    return
  
  if ranks[up] > ranks[vp]:
    parents[vp] = up
  elif ranks[up] < ranks[vp]:
    parents[up] = vp
  else:
    parents[up] = vp
    ranks[vp] += 1
    
n, a, b = map(int, input().split())
ps = list(map(int, input().split())) 

mapping = set(ps)

parents = {x: x for x in ps}
parents['A'] = 'A'
parents['B'] = 'B'
ranks = {x: 0 for x in ps}
ranks['A'] = 0
ranks['B'] = 0
# print(parents)
result = True
for x in ps:
  if a - x in mapping:
    unionSet(x, a - x)
  else:
    unionSet(x, 'B')
    
  if b - x in mapping:
    unionSet(x, b - x)
  else:
    unionSet(x, 'A')
  # print(parents)

# print(parents)
if findSet('A') == findSet('B'):
  print(""NO"")
  
else:
  print(""YES"")
  for i in ps:
    if findSet(i) == findSet('A'):
      print(""0"", end = ' ')
    else:
      print(""1"", end = ' ')
",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",976
"MAX = 100001
parent = []

def makeSet():
    global parent
    parent = [i for i in range(MAX + 1)]

def findSet(u):
    global parent
    if u != parent[u]:
        parent[u] = findSet(parent[u])
    return parent[u]

def unionSet(u, v):
    up = findSet(u)
    vp = findSet(v)
    parent[up] = vp

makeSet()
n, a, b = map(int, input().split())
p = list(map(int, input().split()))
pos = dict()
for i in range(n):
    pos[p[i]] = i + 1

for i in range(n):
    unionSet(i + 1, pos.get(a - p[i], n + 1))
    unionSet(i + 1, pos.get(b - p[i], 0))

A = findSet(0)
B = findSet(n + 1)

if A != B:
    print('YES')
    for i in range(1, n + 1):
        if findSet(i) == B:
            print('1', end = "" "")
        else:
            print('0', end = "" "")
else:
    print('NO')
",linear,"2-sat,dfs and similar,dsu,graph matchings,greedy",770
"
import string

n, s, t = int(input()), input(), input()
x, i, j = 0, -1, -1
sc_dict = {c: set() for c in string.ascii_lowercase}
tc_dict = {c: set() for c in string.ascii_lowercase}
sti_dict, tsi_dict = dict(), dict()

for ci, sc, tc in zip(range(n), s, t):
    if sc == tc:
        continue
    sc_dict[sc].add(tc)
    tc_dict[tc].add(sc)
    sti_dict[sc + tc] = ci
    tsi_dict[tc + sc] = ci
    x += 1

for c in string.ascii_lowercase:
    cs = sc_dict[c] & tc_dict[c]
    if not cs:
        continue
    c2 = cs.pop()
    x -= 2
    i = sti_dict[c + c2] + 1
    j = tsi_dict[c + c2] + 1
    break
else:
    for c in string.ascii_lowercase:
        if not sc_dict[c] or not tc_dict[c]:
            continue
        x -= 1
        i = sti_dict[c + sc_dict[c].pop()] + 1
        j = tsi_dict[c + tc_dict[c].pop()] + 1
        break

print(x)
print(i, j)",linear,greedy,855
"num=int(input())

a=input()

b=input()

dic={}

lis=[]

ham=0

swap1=-1

swap2=-1

p=False

q=False

for i in range(num):

    if a[i]!=b[i]:

        ham+=1

        lis.append(i)

        dic[b[i]]=i

for i in lis:

    if a[i] in dic:

        p=True

        swap1=i+1

        f=dic[a[i]]

        swap2=f+1

        if a[f]==b[i]:

            q=True

            break

print(ham-(2 if q else 1 if p else 0))

print(swap1,swap2)



# Made By Mostafa_Khaled",linear,greedy,463
"n = int(input())
s = input()
t = input()
dic, diff = {}, []
res, res1, res2 = 0, -1, -1
for i in range(n) :
    if s[i] != t[i] :
        res += 1
        diff.append(i)
        dic[t[i]] = i
swap1, swap2 = False, False
for i in diff :
    if s[i] in dic:
        swap1 = True
        res1 = i+1
        j = dic[s[i]]
        res2 = j+1
        if s[j] == t[i] :
            swap2 = True
            break
print(res - (2 if swap2 else 1 if swap1 else 0))
print(res1, res2)
",linear,greedy,473
"__author__ = 'ruckus'

n = int(input())
s = input()
t = input()
dif = {}
hem = 0
for i in range(n):
    if s[i] != t[i]:
        dif[i] = [s[i], t[i]]
        hem += 1

change = []
probed = []
k = 0
for i in dif.keys():
    if dif[i] in probed:
        continue
    probed.append(dif[i])
    k += 1
    for j in list(dif.keys())[k:]:
        if dif[i] == dif[j][::-1]:
            print(hem - 2)
            print(i + 1, j + 1)
            quit()
        if not change and (dif[i][0] == dif[j][1] or dif[j][0] == dif[i][1]):
            change = [i, j]

if change:
    print(hem - 1)
    print(change[0] + 1, change[1] + 1)
else:
    print(hem)
    print('-1 -1')",linear,greedy,663
"n = int(input())
s = input()
t = input()
p = [-1, -1]
a = [[-1] * 26 for i in range(26)]
k = 0
for i in range(n):
    if t[i] != s[i]:
        k += 1
for i in range(n):
    if t[i] != s[i]:
        if a[ord(t[i]) - 97][ord(s[i]) - 97] != -1:
            print(k - 2)
            print(a[ord(t[i]) - 97][ord(s[i]) - 97] + 1, i + 1)
            exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
for i in range(n):
    if t[i] != s[i]:
        for j in range(26):
            if a[j][ord(s[i]) - 97] != -1:
                print(k - 1)
                print(a[j][ord(s[i]) - 97] + 1, i + 1)
                exit()
        a[ord(s[i]) - 97][ord(t[i]) - 97] = i
print(k)
print(-1, -1)
",linear,greedy,683
"
n=int(input())
s=list(input())
t=list(input())
d={}
ans=0
x,y=-1,-1
for i in range(n):
	if s[i]!=t[i]:
		d[(s[i],t[i])]=i
		ans+=1
l=[chr(i+97) for i in range(26)]
for i in l:
	for j in l:
		if (i,j) in d and (j,i) in d:
			ans-=2
			x=d[(i,j)]+1
			y=d[(j,i)]+1
			break
	if x!=-1:
		break
if x==y==-1:
	for i in l:
		for j in l:
			for k in l:
				if (i,j) in d and (j,k) in d:
					ans-=1
					x=d[(i,j)]+1
					y=d[(j,k)]+1
					break
		if x!=-1:
			break
print(ans)
print(x,y)",linear,greedy,482
"from sys import stdin,stdout
from collections import Counter
def ai(): return list(map(int, stdin.readline().split()))
def ei(): return map(int, stdin.readline().split())
def ip(): return  int(stdin.readline().strip())
def op(ans): return stdout.write(str(ans) + '\n') 

n = ip()
s = input()
t = input()
value = {}
li = []
res1 = 0
res2 =res3 = -1
for i in range(n):
	if s[i] != t[i]:
		value[t[i]] = i
		res1 += 1
		li.append(i)
p = sq = False
for i in li:
	if s[i] in value:
		p = True
		res2 = i+1
		f = value[s[i]]
		res3 = f+1
		if s[f] == t[i]:
			sq = True
			break
print(res1-(2 if sq else 1 if p else 0))
print(res2,res3)",linear,greedy,630
"n = int(input())
s = input()
t = input()
pair2ind = {}
letters_s = [0] * 26
letters_t = [0] * 26
non_common = set()
cnt = 0
for i in range(n):
    if s[i] != t[i]:
        pair2ind[(s[i], t[i])] = i + 1
        letters_s[ord(s[i]) - ord('a')] = i + 1
        letters_t[ord(t[i]) - ord('a')] = i + 1
        non_common.add(i + 1)
        cnt += 1

sim = -1
for i in range(26):
    if letters_s[i] != 0 and letters_t[i] != 0:
        sim = letters_s[i]
        break
else:
    print(cnt)
    print(-1, -1)
    exit()

for i in range(n):
    if s[i] != t[i]:
        if (t[i], s[i]) in pair2ind:
            print(cnt - 2)
            print(pair2ind[(s[i], t[i])], pair2ind[(t[i], s[i])])
            exit()

non_common.remove(sim)
print(cnt - 1)
print(sim, letters_t[ord(s[sim-1]) - ord('a')])
exit()
",linear,greedy,799
"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split()) 
def get_list(): return list(map(int, sys.stdin.readline().strip().split())) 


n,s=rinput()
maxi=s
for i in range(n):
    f,t=rinput()
    maxi=max(maxi,f+t)

print(maxi)",linear,"implementation,math",341
"def solve(n, p, s):
    p.append((0, 0))
    p.sort()
    t = 0
    while p:
        x = p.pop()
        s, t = x[0], max(x[1], t + abs(s - x[0]))
    return t


n, s = [int(x) for x in input().split(' ')]
p = [tuple([int(x) for x in input().split(' ')]) for r in range(n)]

print(solve(n, p, s))",linear,"implementation,math",296
"n, s = map(int, input().split())
ans = s
f = []
t = []
for i in range(n):
    f, t = map(int, input().split())
    if(t>(s-f)):
        ans +=  t - (s-f)
        s += t - (s-f)

print(ans)",linear,"implementation,math",188
"n, s = map(int, input().split())
ans = s
for i in range(n):
    f, t = map(int, input().split())
    ans = max(ans, t+f)
print(ans)",linear,"implementation,math",131
"n, s = map(int, input().split())
ans = s
for i in range(n):
    f, t = map(int, input().split())
    if(t>(s-f)):
        ans +=  t - (s-f)
        s += t - (s-f)

print(ans)",linear,"implementation,math",174
"n , s = map(int , input().split())
lst = []
for i in range(n):
    lst.append(list(map(int , input().split())))
lst = sorted(lst , key =lambda x : x[0] , reverse = True)
prev , ans = s , 0
for i in range(n):
    ans += prev -lst[i][0]
    if ans < lst[i][1]:
        ans += (lst[i][1]- ans)
    
    prev = lst[i][0]
print(ans+prev)",linear,"implementation,math",332
"import sys
from math import sqrt, log, log2, ceil, log10, gcd, floor, pow, sin, cos, tan, pi, inf, factorial
from copy import copy, deepcopy
from sys import exit, stdin, stdout
from collections import Counter, defaultdict, deque
from itertools import permutations
import heapq
from bisect import bisect_left 
from bisect import bisect_right
# sys.setrecursionlimit(100000000)
mod = 1000000007
iinp = lambda: int(sys.stdin.readline())
inp = lambda: sys.stdin.readline().strip()
strl = lambda: list(inp().strip().split("" ""))
intl = lambda: list(map(int, inp().split("" "")))
mint = lambda: map(int, inp().split())
flol = lambda: list(map(float, inp().split("" "")))
flush = lambda: stdout.flush()
# ========================================================Functions====================================================
def solve():
 
    n,s=mint()
    cm=0
    for i in range(n):
        fi,ti=mint()
        if i==0:
            cm=fi+ti
        if i!=0:
            if fi+ti>cm:
                cm=fi+ti
    if cm>s:
        print(cm)
    else:
        print(s)
 
 
# ========================================================Main Code=====================================================
# t=iinp()
t=1
for _ in range(t):
        solve()",linear,"implementation,math",1231
"n,s=map(int,input().split())
arr=[]
for i in range(n):
    arr.append([])
    arr[i]=[int(i) for i in input().split()]
arr=sorted(arr,reverse=True,key=lambda x:x[0])
ans,c=0,0
for i in range(n):
    if i!=0:
       c=arr[i-1][0]
    if i==0:
       ans=ans+s-arr[i][0]
    else:
       ans=ans+c-arr[i][0]
    if arr[i][1]>=ans:
        ans=ans+(arr[i][1]-ans)
ans=ans+arr[n-1][0]
print(ans)
    ",linear,"implementation,math",396
"n,s=map(int,input().split())
mins=s
my_dict={}
mylist=[]
while(n):
	person,floor=map(int,input().split())
	mylist.append(person+floor)
	n-=1
val=max(mylist)
if(val<mins):
	print(mins)
else:
	print(val)",linear,"implementation,math",201
"a , b = input(), input()
ans = 0
 
ones = [0 for i in range(len(b)+1)]
zeros = [0 for i in range(len(b)+1)]
 
for i in range(len(b)):
    ones[i] = ones[i-1] + int(b[i])
    zeros[i] = i + 1 - ones[i]
    
for i in range(len(a)):
    if a[i] == '1':
        ans += zeros[len(b)-len(a)+i] - zeros[i-1]
 
    else:
        ans += ones[len(b)-len(a)+i] - ones[i-1]
 
print(ans)
  	 	   	     	 				 	     			",linear,"combinatorics,strings",405
"
if __name__ == '__main__':
    a = [int(c) for c in str(input())]
    b = [int(c) for c in str(input())]
    b_len = len(b)
    a_len = len(a)
    carCountPrefix = [[ 0 for c in range(2)] for _ in range(b_len+1)]
    b_zero_count = 0
    b_one_count = 0
    for b_i in range(b_len):
        if b[b_i] == 0:
            b_zero_count += 1
        elif b[b_i] == 1:
            b_one_count += 1
        carCountPrefix[b_i+1][1] = b_one_count
        carCountPrefix[b_i+1][0] = b_zero_count
    res = 0
    for cur in range(0, a_len):
        for dig in range(2):
            res += (carCountPrefix[b_len - a_len + cur + 1][dig] - carCountPrefix[cur][dig]) * abs(a[cur] -dig)
    print(res)

 	 		 					  	 	 	  		 		    	",linear,"combinatorics,strings",719
"def solve(a, b):
    m = len(a)
    n = len(b)
    p_b = [0]
    for x in b[:]:
        p_b.append(p_b[-1] + int(x))
    s = 0
    for i in range(m):
        if a[i] == '0':
            s += p_b[n - m + 1 + i] - p_b[i]
        else:
            s += (n - m + 1) - (p_b[n - m + 1 + i] - p_b[i])
    return s


a = input()
b = input()
print(solve(a, b))
",linear,"combinatorics,strings",352
"a = input()
b = input()
o = []
z = []
c0 = 0
c1 = 0
for i in b:
    if i == ""0"":
        c0 += 1

    else:
        c1 += 1

    o.append(c1)
    z.append(c0)

n = len(b)-1
m = len(a)-1
ans = 0
for i in range(len(a)):
    x = a[i]
    if x == ""1"":
        ans += z[(n-(m-i))]-z[i]
        if b[i] == ""0"":
            ans += 1

    else:
        ans += o[(n - (m - i))] - o[i]
        if b[i] == ""1"":
            ans += 1

print(ans)",linear,"combinatorics,strings",432
"from sys import stdin,stdout
# input=stdin.readline
mod=10**9+7
t=1
for _ in range(t):
    a=input()
    b=input()
    n=len(a)
    m=len(b)
    dp=[[0 for i in range(2)] for j in range(m+1)]
    dp[1][0]=int(b[0])^1
    dp[1][1]=int(b[0])
    for i in range(2,m+1):
        dp[i][0]=dp[i-1][0]+(int(b[i-1])^1)
        dp[i][1]=dp[i-1][1]+int(b[i-1])
    ans=0
    for i in range(n):
        count0=dp[m-n+i+1][0]-dp[i][0]
        count1=dp[m-n+i+1][1]-dp[i][1]
        ans+=count0*int(a[i])+count1*(int(a[i])^1)
    print(ans)",linear,"combinatorics,strings",527
"""""""
https://codeforces.com/contest/608/problem/B
01
00111 should output 3

0011
0110 should output 2
""""""
first = [int(i) for i in input()]
second = [int(i) for i in input()]

pref_dists = [
    [0] + [int(0 != c) for c in second],
    [0] + [int(1 != c) for c in second]
]
for i in range(1, len(second) + 1):
    pref_dists[0][i] += pref_dists[0][i - 1]
    pref_dists[1][i] += pref_dists[1][i - 1]

total = 0
for i, c in enumerate(first):
    end = len(second) - (len(first) - i)
    total += pref_dists[c][end + 1] - pref_dists[c][i]
print(total)
",linear,"combinatorics,strings",549
"a=str(input())
b=str(input())
count=0
al=len(a)
bl=len(b)
s=b[:bl-al+1].count('1')
for i in range(al-1):
    if a[i]=='0':
        count+=s
    else:
        count+=bl-al+1-s
    s+=int(b[bl-al+i+1])-int(b[i])
 
if a[-1]=='0':
    count+=s
else:
    count+=bl-al+1-s
print(count)",linear,"combinatorics,strings",279
"# Author : nitish420 --------------------------------------------------------------------
import os
import sys
from io import BytesIO, IOBase



def main():
    a=list(map(int,input()))
    b=list(map(int,input()))
    dff=len(b)-len(a)
    if dff<0:
        print(0)
        exit()
    lb=len(b)
    c=[0]*(lb+1)
    for i in range(lb):
        c[i+1]=c[i]+b[i]
    ans=0
    for i in range(len(a)):
        item=a[i]
        if item:
            ans+=(dff+1-(c[dff+i+1]-c[i]))
        else:
            ans+=(c[dff+i+1]-c[i])

    print(ans)


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')





# endregion

if __name__ == '__main__':
    main()",linear,"combinatorics,strings",2269
"a = list(input())
a = [int(x) for x in a]

b = list(input())
b = [int(x) for x in b]

n = len(a)
m = len(b)

ans = 0
for i in range(n):
    ans+=a[i]^b[i]
ones = [0 for i in range(m)]
zeros = [0 for i in range(m)]
# print(b)
for i in range(m):
    if b[i]:
        ones[i]=1
    else:
        zeros[i]=1
# print(ones,zeros)
for i in range(1,m):
    ones[i]+=ones[i-1]
    zeros[i]+=zeros[i-1]
    
for i in range(n):
    if a[i]==1:
        ans+=zeros[m-n+i]-zeros[i]
    else:
        ans+=ones[m-n+i]-ones[i]
print(ans)
",linear,"combinatorics,strings",522
"from sys import stdin
from bisect import *

rints = lambda: [int(x) for x in stdin.readline().split()]
rints_2d = lambda n: [rints() for _ in range(n)]
n, mem, pos, power = int(input()), [1], [], []
a = sorted(rints_2d(n))

for x, y in a:
    pos.append(x)
    power.append(y)

for i in range(1, n):
    ix = bisect_left(pos, pos[i] - power[i]) - 1
    if ix == -1:
        mem.append(1)
    else:
        mem.append(mem[ix] + 1)

print(n - max(mem))
",linear,dp,451
"import sys

def chain_reaction(n, beacons):
    table = [0] * n
    # table[i] represents the number of beacons destroyed if the first i beacons are used
    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0
        # use binary search to find the beacon that will be activated after the current one
        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1
        # beacons destroyed by next activated one
        destroyed += table[hi]
        # beacons destroyed by currently activated one
        destroyed += (i - (hi + 1))
        table[i] = destroyed

    # find first index of max # of beacons destroyed
    cost = n
    ind = 0
    while ind < len(table):
        cost = min(cost, n - ind - 1 + table[ind])
        ind += 1

    # options: add a beacon that doesn't destroy any or add a beacon that destroys the beacon at index ind
    return cost
 
n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",linear,dp,1370
"import sys

def chain_reaction(n, beacons):
    table = [0] * n
    # table[i] represents the number of beacons destroyed if the first i beacons are used
    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0
        # use binary search to find the beacon that will be activated after the current one
        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1
        # beacons destroyed by next activated one
        destroyed += table[hi]
        # beacons destroyed by currently activated one
        destroyed += (i - (hi + 1))
        table[i] = destroyed

    # print(table)

    # find first index of max # of beacons destroyed
    max_val = max(table)
    ind = 0
    while ind < len(table):
        if table[ind] == max_val:
            break
        ind += 1
    cost = (len(table) - ind) + table[ind - 1]

    options = []
    for i in range(n):
        cost = (n - i) + table[i - 1]
        options.append(cost)
    min_cost = min(options)

    # options: add a beacon that doesn't destroy any or add a beacon that destroys the beacon at index ind
    # return min(table[n - 1], cost)
    return min(table[n - 1], min_cost)
 
n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",linear,dp,1646
"import sys

def chain_reaction(n, beacons):
    table = [0] * n
    # table[i] represents the number of beacons destroyed if the first i beacons are used
    for i in range(n):
        position = beacons[i][0]
        power = beacons[i][1]
        destroyed = 0
        r = position - power
        b = 0
        # use binary search to find the beacon that will be activated after the current one
        lo = 0
        hi = len(beacons) - 1
        while lo <= hi:
            mid = int(lo + (hi - lo) / 2)
            pos = beacons[mid][0]
            if beacons[mid][0] < r:
                lo = mid + 1
            else:
                hi = mid - 1
        # beacons destroyed by next activated one
        destroyed += table[hi]
        # beacons destroyed by currently activated one
        destroyed += (i - (hi + 1))
        table[i] = destroyed

    # print(table)

    # calculate cost of placing a beacon that activates each beacon in the table
    options = []
    for i in range(n):
        cost = (n - i) + table[i - 1]
        options.append(cost)
    min_cost = min(options)

    # options: add a beacon that doesn't destroy any or add a beacon that destroys the beacon with minimum cost
    return min(table[n - 1], min_cost)
 
n = int(sys.stdin.readline().strip())
beacons = []
for i in range(n):
    a, b = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    beacons.append((a, b))
beacons.sort()
print(chain_reaction(n, beacons))",linear,dp,1460
"import math

n = int(input())

# Assumption = they give it to me sorted by A

beacons = {}
sortedKeys = [0]*n

for i in range(n):
    a, b = map(int, input().split(' '))
    sortedKeys[i] = a
    beacons[a] = b

sortedKeys.sort()
maxA = sortedKeys[-1]

sumBeacons = [0]*(maxA+1)
count = 0
for a in range(maxA+1):
    sumBeacons[a] = count
    # Exclusive on the end value
    if a in beacons:
        count += 1

f = [0]*(n+1)
minF = math.inf
for i in range(1, n+1):
    a = sortedKeys[i-1]
    b = beacons[a]
    end = max(0, a-b)
    numDestroyed = sumBeacons[a] - sumBeacons[end]
    f[i] = numDestroyed
    if i-numDestroyed > 0:
        f[i] += f[(i-1)-numDestroyed]
    # Our answer is the minF of this value + all the ones before it we would have to destroy
    minF = min(minF, f[i]+n-i)

print(minF)",linear,dp,808
"n = int(input())

dp = [0] * 1000007

majak = [0] * 1000007



q = 1000007

p = 0

for i in range(n):

    a, b = map(int, input().split())

    q = min(q, a)

    majak[a] = b



dp[q] = 1

ma = 1

for i in range(q + 1, 1000003, 1):

    if(majak[i] == 0):

        dp[i] = dp[i - 1]

    else:

        dp[i] = dp[i - majak[i] - 1] + 1

        ma = max(ma, dp[i])



print(n - ma)



# Made By Mostafa_Khaled",linear,dp,411
"import sys

maxN = 10**6 + 5
dp = [0] * maxN
b = [0] * maxN

N = int(sys.stdin.readline())
for _ in range(N):
    beacon = [int(x) for x in sys.stdin.readline().split()]
    b[beacon[0]] = beacon[1]

if b[0] > 0:
    dp[0] = 1

for i in range(1, maxN):
    if b[i] == 0:
        dp[i] = dp[i-1]
    else:
        if b[i] >= i:
            dp[i] = 1
        else:
            dp[i] = dp[i-b[i]-1]+1
print(N-max(dp))

",linear,dp,416
"n = int(input())
p = [(-(10**6), 0)] + sorted([tuple(map(int, input().split())) for i in range(n)])
dp = [0] * (n + 1)
for i in range(1, n + 1):
    l, r = 0, i
    while r - l > 1:
        mid = (l + r) >> 1
        if p[i][0] - p[i][1] <= p[mid][0]: r = mid
        else: l = mid
    dp[i] = i - r + dp[r - 1]
ans = min(dp[i] + (n - i) for i in range(1, n + 1))
print(ans)",linear,dp,374
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n = mint()
a = [0]*n
dp = [0]*n
for i in range(n):
	a[i] = tuple(mints())
a.sort()
for i in range(n):
	x, p = a[i]
	l = -1
	r = n
	v = x-p
	while r-l > 1:
		c = (l + r)//2
		if a[c][0] >= v:
			r = c
		else:
			l = c
		if l == -1:
			dp[i] = i-l-1
		else:
			dp[i] = i-l-1+dp[l]
#print(dp)
z = 1e9
for i in range(n):
	z = min(z,dp[i]+n-i-1)
print(z)",linear,dp,510
"import sys
LI=lambda:list(map(int, sys.stdin.readline().split()))
MI=lambda:map(int, sys.stdin.readline().split())
SI=lambda:sys.stdin.readline().strip('\n')
II=lambda:int(sys.stdin.readline())
# sys.stdin=open('input.txt')
# sys.stdout=open('output.txt', 'w')
# for _ in range(II()):
n=II()
s=SI()
c=set(s)
ln=[0]*n
for d in c:
	last=-1
	# print(d, end=' ')
	for i, v in enumerate(s):
		if v==d:
			last=i
		if last==-1:
			ln[i]=int(1e9)
		else:
			ln[i]=max(ln[i], i-last+1)
	# print(ln)
print(min(ln))",linear,"binary search,strings,two pointers",505
"# https://codeforces.com/problemset/problem/701/C
# two pointers method


def main():
    n = int(input())
    s = input()

    u_set = set()
    for i in s:
        u_set.add(i)
    u_cnt = len(u_set)

    d = {}
    j = 0
    ans = 10**9
    for i in range(n):
        while len(d.keys()) < u_cnt and j < n:
            d[s[j]] = d.get(s[j], 0) + 1
            j += 1

        if len(d.keys()) == u_cnt:
            if j - i < ans:
                ans = j - i
        elif j == n:
            break

        d[s[i]] -= 1
        if d[s[i]] == 0:
            del d[s[i]]

    print(ans)


if __name__ == '__main__':
    main()
",linear,"binary search,strings,two pointers",628
"
n = int(input())
pokemons = input()

last = {}
start_of_all = 0
for i in range(n):
    ty = pokemons[i]
    if ty not in last:
        start_of_all = i
    last[ty] = 0

minlen = 100001
for i in range(n):
    ty = pokemons[i]
    last[ty] = i
    length = i + 1 - min(last.values())
    if i >= start_of_all and length < minlen:
        minlen = length

print(minlen)

	  	  				   	 			   		   	  	",linear,"binary search,strings,two pointers",400
"import sys
import math

prime=[True for _ in range(1000001)]

# # Remove these 2 lines while submitting your code online
# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')
def solve():
    n,e,h,a,b,c=map(int,input().split())
    ans=1e9
    for i in range(1,1000001):
        su=0
        ntmp=n
        tmp1=e
        tmp2=h
        tmp1-=i
        tmp2-=i
        if (tmp1<0 or tmp2<0 or i>ntmp):
            break
        ntmp-=i
        su+=(c*i)
        if (ntmp==0):
            ans=min(ans,su)
            continue
        if (a<=b):
            if ((tmp1//2)>=ntmp):
                su+=int(a*ntmp)
                ntmp-=ntmp
            else:
                su+=int(a*(tmp1//2))
                ntmp-=(tmp1//2)
                if (ntmp<=(tmp2//3)):
                    su+=int(b*ntmp)
                    ntmp-=ntmp
                else:
                    su+=int(b*(tmp2//3))
                    ntmp-=(tmp2//3)
        else:
            if ((tmp2//3)>=ntmp):
                su+=int(b*ntmp)
                ntmp-=ntmp
            else:
                su+=int(b*(tmp2//3))
                ntmp-=(tmp2//3)
                if (ntmp<=(tmp1//2)):
                    su+=int(a*ntmp)
                    ntmp-=ntmp
                else:
                    su+=int(a*(tmp1//2))
                    ntmp-=(tmp1//2)
        if (ntmp==0):
            ans=min(ans,su)
    # print(ans)
    if (ans==1e9):
        print(""-1"")
    else:
        print(ans)

def main():
    n=int(input())
    s=input()
    m={}
    have={}
    cc=0
    for c in s:
        if (c not in m):
            m[c]=1
        else:
            m[c]+=1
    ct=len(m)
    l=0
    ans=1e9
    for i in range(0,n):
        if (s[i] not in have):
            have[s[i]]=0
            cc+=1
        have[s[i]]+=1
        while(l<=i and have[s[l]]>1):
            have[s[l]]-=1
            l+=1
        if (cc==ct):
            ans=min(ans,i-l+1)
    print(ans)

if __name__ == ""__main__"":
    main()",linear,"binary search,strings,two pointers",1995
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
sys.setrecursionlimit(111111) 
INF=99999999999999999999999999999999
class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True
 
    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False
 
    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1
 
    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x
 
    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k
 
    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1
 
        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True
 
    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi
 
        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True
 
    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)
 
    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))
 
    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value
 
    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx
 
    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx
 
    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)
 
    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len
 
    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]
 
    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)
 
    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False
 
    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)
 
    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))
 
    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))
def main():

    mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    ###CODE
    tc = 1
    for _ in range(tc):
        n=ri()
        s=rs()
        
        d={}
        for i in range(n):
            # print(i,s[i])
            d[s[i]]=1
        l=0
        r=0
        td={}
        ans=INF
        while l<=r and r<n:
            while len(td)!=len(d):
                if r==n:
                    print(ans)
                    exit()
                if s[r] in td:
                    td[s[r]]+=1
                else:
                    td[s[r]]=1
                r+=1
                
            if len(td)==len(d):
                r-=1
                ans=min(ans,r-l+1)
            while l<=r:
                # g=(s[l],l)
                td[s[l]]-=1
                if td[s[l]]==0:
                    del td[s[l]]
                    ans=min(ans,r-l+1)
                    l+=1
                    break
                l+=1
            r+=1
        wi(ans)
        
                
        
        
            
        
        
                     
        
        
                    
        
                     
                    
                    
                
                
                    
                
        
        
            
                   
        
                    

        
        
                
            
            
    
            
                        
        
    

        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    
",linear,"binary search,strings,two pointers",11963
"
M = {}

N = int(input())
S = input().strip()

s = set()
for c in S:
    s.add(c)
    M[c] = 0

i = 0; j = -1; aux = 0; ans = 1e10
while j < N - 1:
    j += 1

    M[S[j]] += 1
    if M[S[j]] == 1:
        aux += 1
    while M[S[i]] > 1:
        M[S[i]] -= 1
        i += 1

    if aux == len(s):
        ans = min(ans, j - i + 1)

print(ans)
",linear,"binary search,strings,two pointers",343
"n,s=int(input()),input()
p,q,r=len(set(s)),{},10**6
for i in range(n):
    q[s[i]]=i
    if len(q)==p:r=min(r,max(q.values())-min(q.values()))
print(r+1)",linear,"binary search,strings,two pointers",153
"def bs(l, h):
    while l < h:
        m = (l + h) // 2
        if gf(m):
            h = m
        else:
            l = m + 1
    return l

def gf(x):
    d = {}
    for i in range(x):
        if s[i] in d:
            d[s[i]] += 1
        else:
            d[s[i]] = 1
    if len(d) == len(u):
        return 1
    for i in range(x, n):
        if s[i] in d:
            d[s[i]] += 1
        else:
            d[s[i]] = 1
        d[s[i - x]] -= 1
        if not d[s[i - x]]:
            del d[s[i - x]]
        if len(d) == len(u):
            return 1
    return 0

n = int(input())
s = input()
u = set([*s])
print(bs(1, n))",linear,"binary search,strings,two pointers",628
"n = int(input())
s = input()
want = len(set(s))
d = {}
j = 0
count = 0
ans = float(""inf"")
for i in range(n):
    if s[i] not in d:
        d[s[i]] = 0
        count+=1
    d[s[i]]+=1
    if count==want:
        while d[s[j]]>1:
            d[s[j]]-=1
            j+=1
        ans = min(ans,i-j+1)
print(ans)",linear,"binary search,strings,two pointers",307
"import sys

n = int(sys.stdin.buffer.readline().decode('utf-8'))
cost = [0] + \
    list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))
a = [line.decode('utf-8').rstrip() for line in sys.stdin.buffer]

mask = [0, 1, 51, 1911]
inf, bs_size, full_bit = 10**9, 1 << 12, (1 << 12) - 1
dp = [[inf]*bs_size for _ in range(4*n+1)]
dp[0][0] = 0

for i in range(4*n):
    y, x = i & 3, i >> 2
    is_dot = 1 if a[y][x] == '.' else 0

    for bitset in range(bs_size):
        if y == 0:
            '''
              01234    01234
            0 s****    .t..*
            1 ***** -> ....*
            2 ***** -> ....*
            3 *****    ....*
            '''
            if dp[i+4][full_bit] > dp[i][bitset] + cost[4]:
                dp[i+4][full_bit] = dp[i][bitset] + cost[4]

        if (is_dot | bitset & 1) and\
                dp[i+1][bitset >> 1] > dp[i][bitset]:
            dp[i+1][bitset >> 1] = dp[i][bitset]

        for k in range(1, min(4-y, 3)+1):
            if dp[i][bitset | mask[k]] > dp[i][bitset] + cost[k]:
                dp[i][bitset | mask[k]] = dp[i][bitset] + cost[k]

print(min(dp[4*n]))
",linear,"bitmasks,dp",1129
"s1, s2 = [str(j) for j in input().split()]
output = s1 + s2
for j in range(len(s1)):
    s = s1[:j + 1]
    for k in range(len(s2)):
        s += s2[k]
        if sorted([s, output])[0] == s:
            output = s
print(output)
",linear,"brute force,greedy,sortings",229
"a, b = input().split()
li = []
for i in range(len(a)):
    li.append(a[:i + 1] + b[0])
li.sort()
print(li[0])
",linear,"brute force,greedy,sortings",110
"import sys
import bisect
#input=sys.stdin.readline
l=input().split()
a=l[0]
b=l[1]
p=[]
for i in range(len(a)):
    for j in range(len(b)):
        ok=a[:i+1]+b[:j+1]
        p.append(ok)
print(min(p))
",linear,"brute force,greedy,sortings",202
"s1, s2 = input().split()
ans = 'z' * 21
for i in range(1, len(s1) + 1):
    for j in range(1, len(s2) + 1):
        ans = min(ans, s1[:i] + s2[:j])
print(ans)",linear,"brute force,greedy,sortings",158
"s1, s2 = input().split()
ans = s1[0]
for i in range(1, len(s1)):
    if s1[i] < s2[0]:
        ans += s1[i]
        if i == len(s1) - 1:ans += s2[0]
    else:
        ans += s2[0]
        break
if len(s1) == 1:print(s1[0] + s2[0])
else:print(ans)",linear,"brute force,greedy,sortings",246
"s1, s2 = input().split()
ans = s1[0]
for i in range(1, len(s1)):
    if s1[i] < s2[0]:ans += s1[i]
    else:break
print(ans + s2[0])",linear,"brute force,greedy,sortings",132
"str1,str2=map(str,input("""").split())
lst=[]
lst_ans=[]
l_count=0
count=0
for i in str2:
    if(count<1):
        lst.append(i)
    else:
        break
for i in str1:
    if(count==0):
        lst_ans.append(i)
        count+=1
    elif(ord(i)<ord(lst[0])):
        lst_ans.append(i)
    else:
        lst_ans.append(lst[0])
        break
else:
    lst_ans.append(lst[0])
print(''.join(lst_ans))  ",linear,"brute force,greedy,sortings",396
"s = input().split(' ')
s1 = s[0]
s2 = s[1]
res = s1[0]
flag = 0
for i in range(1, len(s1)):
    if(s1[i]>=s2[0]):
        res+=s2[0]
        flag = 1
        break
    else:
        res+=s1[i]
if(flag == 0):
    res+=s2[0]
print(res)
",linear,"brute force,greedy,sortings",234
"first,last=input().split()
username=first[0]
first=first[1:]
while first!="""" and first[0]<last[0]:
    username=username+first[0]
    first=first[1:]
print(username+last[0])",linear,"brute force,greedy,sortings",173
"n=int(input());print(sum(i for i in range(1+n%2!=1,n+1,2)))",linear,"constructive algorithms,math",59
"print(sum(i for i in range(int(input()),-1,-2)))",linear,"constructive algorithms,math",48
"n = int(input())
import math
print(math.ceil(n/2) * (math.floor(n/2)+1))",linear,"constructive algorithms,math",72
"n = int(input())
dp = [0]*101
dp[1] = 1
dp[2] = 2
for i in range(3, 101):
    dp[i] = dp[i-2]+i
print(dp[n])
",linear,"constructive algorithms,math",109
"from math import ceil
N = int(input())
S = (N * (N + 1)) / 2
F = int(ceil(N /2.0))
ans = int((S + F) / 2)
print(ans)",linear,"constructive algorithms,math",116
"# cook your dish here
import math
n=int(input())
if(n%2==0):
   x=math.floor(n/2+1)*(math.floor(n/2))
if(n%2!=0):
   x=(math.ceil(n/2)*(math.ceil(n/2)))
print(x)",linear,"constructive algorithms,math",161
"import math
n=int(input())
print((math.floor(n/2)+1)*math.ceil(n/2))",linear,"constructive algorithms,math",68
"n=int(input())
a=[]
for i in range(n+1):
    a.append(((n+1)-i)*i)
print(max(a))",linear,"constructive algorithms,math",80
"n=int(input())
print((n+n%2)*((n+2)//2)//2)",linear,"constructive algorithms,math",43
"# https://codeforces.com/problemset/problem/909/D
def process(a):
    assert len(a) >= 2
    
    n    = len(a)
    min_ = float('inf')

    for i, [cnt, c] in enumerate(a):
        if i == 0 or i == n-1:
            min_ = min(min_, cnt)
        else:
            min_ = min(min_, (cnt+1) //2) 
    
    b    = []
    for i, [cnt, c] in enumerate(a):
        if i == 0 or i == n-1:
            remain = cnt - min_
        else:
            remain = cnt - min_ * 2
        
        if remain <= 0:
            continue
        
        if len(b) == 0 or c != b[-1][1]:
            b.append([remain, c])
        else:
            pre_cnt, pre_c  = b.pop()
            b.append([pre_cnt+remain, c])
    
    return b, min_        

S   = input() + ' '
cur = []

cnt = 0
pre = ''
for x in S:
    if cnt == 0:
        cnt+= 1
        pre = x
    elif x!=pre:
        cur.append([cnt, pre])
        cnt = 1
        pre = x
    else:
        cnt+=1

cnt = 0
while len(cur) not in [0, 1]: 
    cur, min_ = process(cur)
    cnt+=min_
    
print(cnt)    ",linear,"data structures,greedy,implementation",1045
"n=int(input())
g={}
for i in range(1,n):
    p=int(input())
    if g.get(p):g[p].append(i+1)
    else:g[p]=[i+1]
ams='YES'
for i in g:
    c=0
    for j in g[i]:
        if j not in g:c+=1 
    if c<3:ams='NO'
print(ams)",linear,"implementation,trees",220
"n= int(input())
t=[[] for _ in range(n+1)]
for i in range(n-1):
    v = int(input())
    t[v].append(i+2)
#print(t)
flag=True
for l in t:
    if l!=[]:
        cnt=0
        for ele in l:
            if t[ele]==[]:
                cnt+=1
        if cnt<3:
            flag=False
            break
if flag:
    print(""YES"")
else:
    print(""NO"")",linear,"implementation,trees",344
"n = int(input())
a = [0] * (n+1) ; b = [0] * (n+1) ; c = [0] * (n+1)
for i in range(2, n+1):
    a[i] = int(input())
    b[a[i]] += 1
for i in range(1, n+1):
    if b[i] == 0:
        c[a[i]] += 1
for i in range(1, n+1):
    if b[i] != 0 and c[i] < 3:
        print(""NO"")
        exit()
print(""YES"")",linear,"implementation,trees",299
"# -*- coding: utf-8 -*-
""""""
Created on Fri Dec 18 13:12:13 2020

@author: lenovo
""""""

from collections import defaultdict
from collections import deque

class graph:
    def __init__(self):
        self.g=defaultdict(list)
    def addedge(self,u,v):
        self.g[u].append(v)
def router(values):
    gr=graph()
    for i in range(len(values)):
        gr.addedge(values[i], i+2)
    return gr.g

def isleaf(node,gr):
    if len(gr[node])==0:
        return True
    return False

def christmas(gr,start,visited):
    q=deque()
    q.append(start)
    visited[start]=True
    count=0
    while q:
        count=0
        value=q.popleft()
        for val in gr[value]:
            if not isleaf(val,gr):
                q.append(val)
                visited[val]=True
            else:
                visited[val]=True
                count=count+1
        if count<3:
            return 'No'
    if count<3:
        return 'No'
    return 'Yes'
n=int(input())
values=[]
for i in range(n-1):
    value=int(input())
    values.append(value)
gr=router(values)
visited=[False]*(n+1)
print(christmas(gr, 1, visited))
    ",linear,"implementation,trees",1119
"n=int(input())
d,l,m,a=[0]*(n+1),[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
for i in range(1,n+1):
    if m[i]==0:
        d[l[i]]+=1
for i in range(1,n+1):
    if m[i]>0 and d[i]<3:
        print(""No"")
        break
else:
    print(""Yes"")",linear,"implementation,trees",282
"def if_Spruce(n,l,m):
    d=[0]*(n+1)
    for i in range(1, n + 1):
        if m[i] == 0:
            d[l[i]] += 1
    for i in range(1, n + 1):
        if m[i] > 0 and d[i] < 3:
            return ""No""
    return ""Yes""


n=int(input())
l,m,a=[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
print(if_Spruce(n,l,m))
",linear,"implementation,trees",353
"def if_spruce(n,l,m):
    d=[0]*(n+1)
    for i in range(1,n+1):
        if m[i]==0:
            d[l[i]]+=1
    for i in range(1,n+1):
        if m[i]>0 and d[i]<3:
            return ""No""
    return ""Yes""

n=int(input())
l,m,a=[0]*2,[0]*(n+1),0
for _ in range(n-1):
    a=int(input())
    l.append(a)
    m[a]+=1
print(if_spruce(n,l,m))",linear,"implementation,trees",337
"def if_spruce(n,l,s):
    d=[0]*(n+1)
    for i in range(1,n+1):
        if i not in s:
            d[l[i]]+=1
    for i in range(1,n+1):
        if i in s and d[i]<3:
            return ""No""
    return ""Yes""

n=int(input())
l,a=[0]*2,0
for _ in range(n-1):
    a=int(input())
    l.append(a)
s=set(l)
print(if_spruce(n,l,s))",linear,"implementation,trees",325
"def if_spruce(n,l,s):
    d=[0]*(n+1)
    for i in range(1,n+1):
        if i not in s:
            d[l[i]]+=1
    for i in range(1,n+1):
        if i in s and d[i]<3:
            return ""No""
    return ""Yes""
 
n=int(input())
l,a=[0]*2,0
for _ in range(n-1):
    a=int(input())
    l.append(a)
s=set(l)
print(if_spruce(n,l,s))",linear,"implementation,trees",326
"class Combi():

    def __init__(self, N, mod=10**9 + 7):
        self.power = [1 for _ in range(N+1)]
        self.rev = [1 for _ in range(N+1)]
        self.mod = mod
        for i in range(2, N+1):
            self.power[i] = (self.power[i-1]*i) % self.mod
        self.rev[N] = pow(self.power[N], self.mod-2, self.mod)
        for j in range(N, 0, -1):
            self.rev[j-1] = (self.rev[j]*j) % self.mod

    def com(self, K, R):
        if not (0 <= R <= K):
            return 0
        else:
            return ((self.power[K])*(self.rev[K-R])*(self.rev[R])) % self.mod

    def perm(self, K, R):
        if not (0 <= R <= K):
            return 0
        else:
            return (self.power[K])*(self.rev[K-R]) % self.mod


def bitcnt(X):
    res = 0
    v = X
    while v:
        res += v & 1
        v >>= 1
    return res


c = Combi(10000)
NL = list(map(int, list(input())))[::-1]
N = len(NL)
K = int(input())
MOD = 10**9 + 7

dp = [[0]*(1020) for i in range(1020)]

dp[0][0] = 1
for pos, bit in enumerate(NL):
    if bit == 1:
        for bit in range(1010):
            dp[pos + 1][bit] = (dp[pos][bit - 1] + c.com(pos, bit)) % MOD
        continue
    else:
        for bit in range(1010):
            dp[pos + 1][bit] = dp[pos][bit]
        continue

INF = 1 << 60
cnt = [INF]*(1010)

cnt[1] = 0
MOD = 10**9 + 7

for i in range(2, 1010):
    cnt[i] = 1 + cnt[bitcnt(i)]

if K == 0:
    print(dp[N][0])
    exit()
else:
    ans = 0
    for bitcnt in range(1010):
        if cnt[bitcnt] == K - 1:
            ans += dp[N][bitcnt]
    if K == 1:
        ans -= 1
    print(ans % MOD)
    exit()
",linear,"brute force,combinatorics,dp",1614
"N = 1030
MOD = int(1e9+7)
c = [[0] * N for i in range(N)]
for i in range(N):
    c[i][0] = 1
for i in range(1, N):
    for j in range(1, N):
        c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD

arr = list(map(int, list(input())))
cnt = int(input())
if cnt == 0:
    print(1)
    exit()

dp = [0] * N
for i in range(2, N):
    dp[i] = dp[bin(i).count('1')] + 1
res = 0
for i in range(1, N):
    if dp[i] != cnt - 1:
        continue
    n, k = len(arr)-1, i
    for pos in range(len(arr)):
        if arr[pos] == 1:
            res = (res + c[n][k]) % MOD
            k -= 1
        n -= 1
    if n == -1 and k == 0:
        res += 1
if cnt == 1: 
    res -= 1
print(res)",linear,"brute force,combinatorics,dp",668
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 1000000007;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if n < 0 or r < 0 or r > n: return 0;
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    C();

def D():
    [n,m,k] = ti();
    w = [[] for i in range(n)];
    for i in range(n):
        w[i] = ts();

    mn = [[0 for j in range(k+1)] for i in range(n+1)];
    for i in range(1,n+1):
        for j in range(k+1):
            c = 0;
            st,en = -1,-1;
            for x in range(m):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;
            st,en = -1,-1;
            c = 0;
            for x in range(m-1,-1,-1):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            if st != -1 and en != -1 >= 0:
                mn[i][j] = min(mn[i][j], st-en+1);

    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];
    for i in range(k+1):
        dp[0][i] = 0;
    for i in range(1,n+1):
        for j in range(k+1):
            for x in range(k+1):
                if j-x >= 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);

    print(dp[n][k]);

def getCount(n):
    x = 1;
    count = 0;
    while n > 0:
        if n & 1 == 1:
            count += 1;
        n = n >> 1;
    return count;

def C():
    try:
        n = ts();
        k = pi();
        if k == 0:
            print(1);
            return;
        dp = [0 for i in range(1010)];
        for i in range(1010):
            if i == 0 or i == 1:
                continue;
            dp[i] = dp[getCount(i)]+1;
        fact(1010,mod);

        ans = 0;    
        s = n;
        count = 0;
        for i in range(len(s)):
            if s[i] == '0': continue;
            for j in range(max(count,1),1010):
                if dp[j] == k-1:
                    ans = (ans+ncr(len(s)-i-1,j-count,mod))%mod;
                    if i == 0 and k == 1: ans = (ans+mod-1)%mod;
            count += 1;
        count = 0;
        for i in range(len(s)):
            if s[i] == '1': count += 1;
        if dp[count] == k-1: ans = (ans+1)%mod;

        print(ans);
    except: print(sys.exc_info()[0]);


main();",linear,"brute force,combinatorics,dp",3084
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)",linear,"brute force,combinatorics,dp",1187
"s0=input()
k=int(input())
s1=s0[::-1]
lens1=len(s1)
maxnum=1005
mod=1000000007
dp=[[0]*maxnum for tmpi in range(maxnum)]
f=[0]*maxnum
c=[[0]*maxnum for tmpi in range(maxnum)]

def cntone(num):
    tmps=bin(num)[2:]
    cnt=0
    for i in range(len(tmps)):
        if(tmps[i]=='1'):
            cnt+=1
    return cnt

for i in range(1,maxnum):
    if(i==1):
        f[i]=0
    else:
        f[i]=f[cntone(i)]+1

for i in range(maxnum):
    if(i==0):
        c[i][0]=1
        continue
    for j in range(i+1):
        if(j==0):
            c[i][j]=1
        else:
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod

for i in range(lens1):
    if(i==0):
        dp[i][0] = 1
        if(s1[i]=='1'):
            dp[i][1]=1
        else:
            dp[i][1]=0
        continue
    else:
        for j in range(0,i+2):
            if(j==0):
                dp[i][j]=1
                continue
            if(s1[i]=='1'):
                dp[i][j]=(dp[i-1][j-1]+c[i][j])%mod
            else:
                dp[i][j]=dp[i-1][j]%mod

ans=0

for i in range(1,lens1+1):
    if(f[i]==k-1):
        ans=(ans+dp[lens1-1][i])%mod

if(k==0):
    ans=1
elif(k==1):
    ans-=1
else:
    ans=ans
print(ans)
  	 	   	 	 			 	 	  	 	 	 	 		",linear,"brute force,combinatorics,dp",1219
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def bit_count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k==0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10**9+7
    dp = [0]*(x+1)
    dp[1] = 1
    for i in range(2,x+1):
        dp[i] = dp[bit_count(i)]+1
    dp1 = [[0]*(x+1) for _ in range(x+1)]
    # length ; set bits
    for i in range(x+1):
        dp1[i][0] = 1
    for i in range(1,x+1):
        for j in range(1,i+1):
            dp1[i][j] = (dp1[i-1][j-1]+dp1[i-1][j])%mod
    ans = 0
    cou = n.count('1')
    for i in range(1,x+1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans+dp1[x-1-j][se]-(se==1 and k==1))%mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans+1)%mod
    print(ans)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",linear,"brute force,combinatorics,dp",2804
"import os, sys
from io import BytesIO, IOBase


def bit_count(x):
    ans = 0
    while x:
        x &= x - 1
        ans += 1
    return ans


def main():
    n = input().strip()
    x = len(n)
    k = int(input())
    if n == '1':
        print(int(k == 0))
        exit()
    if not k:
        print(1)
        exit()
    mod = 10 ** 9 + 7
    dp = [0] * (x + 1)
    dp[1] = 1
    for i in range(2, x + 1):
        dp[i] = dp[bit_count(i)] + 1
    dp1 = [[0] * (x + 1) for _ in range(x + 1)]
    # length ; set bits
    for i in range(x + 1):
        dp1[i][0] = 1
    for i in range(1, x + 1):
        for j in range(1, i + 1):
            dp1[i][j] = (dp1[i - 1][j - 1] + dp1[i - 1][j]) % mod
    ans = 0
    cou = n.count('1')
    for i in range(1, x + 1):
        if dp[i] != k:
            continue
        se = i
        for j in range(x):
            if n[j] == '0':
                continue
            ans = (ans + dp1[x - 1 - j][se] - (se == 1 and k == 1)) % mod
            se -= 1
            if se < 0:
                break
        if cou == i:
            ans = (ans + 1) % mod
    print(ans)
main()",linear,"brute force,combinatorics,dp",1117
"'''
jitne bhi binary mai 2 ki power ones hai unhe lagega 2 ;
now i fill a dp table
'''
global fact,inv_fact
def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
	global fact, inv_fact


	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod


make_nCr_mod()
def comb(n, r):
	mod=10**9+7
	global fact,inv_fact
	res = 1
	while n or r:
		a, b = n % mod, r % mod
		if a < b:
			return 0
		res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
		n //= mod
		r //= mod
	return res
def f():
	dp=[0]*(1000+100)
	dp[1]=1

	for i in range(2,len(dp)):
		o=bin(i).count(""1"")
		if o==1:
			dp[i]=2
		else:
			dp[i]+=dp[o]+1
	return dp

def bit(s,k):
	dp=f()
	l=[]
	ans=0
	ll=len(s)
	ans=0
	ones=0
	if k==0:
		return 1
	for i  in range(ll):
		if s[i]==""0"":
			continue
		else:
			for j in range(max(ones,1),1000):
				if dp[j]==k:
					ans=(ans+comb(ll-i-1,j-ones))%(10**9+7)
					if i==0 and k==1:
						ans-=1
		ones+=1
	if dp[ones]==k:
		ans+=1
	return (ans)%(10**9+7)



s=input().strip()
k=int(input())
print(bit(s,k))",linear,"brute force,combinatorics,dp",1256
"'''
jitne bhi binary mai 2 ki power ones hai unhe lagega 2 ;
now i fill a dp table
'''


def make_nCr_mod(max_n=2 * 10 ** 5, mod=10 ** 9 + 7):
	max_n = min(max_n, mod - 1)

	fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
	fact[0] = 1
	for i in range(max_n):
		fact[i + 1] = fact[i] * (i + 1) % mod

	inv_fact[-1] = pow(fact[-1], mod - 2, mod)
	for i in reversed(range(max_n)):
		inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

	def nCr_mod(n, r):
		res = 1
		while n or r:
			a, b = n % mod, r % mod
			if a < b:
				return 0
			res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
			n //= mod
			r //= mod
		return res

	return nCr_mod


def f():
	dp = [0] * (1000 + 100)
	dp[1] = 1

	for i in range(2, len(dp)):
		o = bin(i).count(""1"")
		if o == 1:
			dp[i] = 2
		else:
			dp[i] += dp[o] + 1
	return dp


def bit(s, k):
	dp = f()
	l = []
	comb=make_nCr_mod()
	ans = 0
	ll = len(s)
	ans = 0
	ones = 0
	if k == 0:
		return 1
	for i in range(ll):
		if s[i] == ""0"":
			continue
		else:
			for j in range(max(ones, 1), 1000):
				if dp[j] == k:
					ans = (ans + comb(ll - i - 1, j - ones)) % (10 ** 9 + 7)
					if i == 0 and k == 1:
						ans -= 1
		ones += 1
	if dp[ones] == k:
		ans += 1
	return (ans) % (10 ** 9 + 7)


s = input().strip()
k = int(input())
print(bit(s, k))
",linear,"brute force,combinatorics,dp",1298
"n=int(input())
a=list(map(int,input().split()))
b=[]
maxi=0
for i in range(n):
    maxi=max(maxi,a[i]+1)
    b.append(maxi)
c=[]
count=b[-1]
for i in range(n-1,-1,-1):
    if count-1>=b[i]:
        count-=1
        c.append(count)
    else:
        c.append(count)
c=c[::-1]
ans=0
for i in range(n):
    ans+=(c[i]-a[i]-1)
print(ans)",linear,"data structures,dp,greedy",333
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
##########################################################
from collections import Counter, defaultdict
import bisect
import math

for _ in range(1):
    n = int(input())
    #n,k=map(int, input().split())
    arr = list(map(int, input().split()))
    t=[0]*n
    cur=0
    for i in range(n-1,-1,-1):
        cur=max(cur-1,0,arr[i]+1)
        t[i]=cur
    ans=0
    for i in range(n):
        cur=max(cur,t[i])
        ans+=cur
    for i in range(n):
        ans-=(arr[i]+1)
    print(ans)



















",linear,"data structures,dp,greedy",2213
"'''
mark-up-1 :hmmge:
'''


def f(ar):
	mx = ar.index(max(ar))
	cmark = 0
	ans = 0
	big = [0] * (len(ar))
	for i in range(len(ar) - 1, -1, -1):
		# big man nearest chote ko bharo
		cmark = max(cmark - 1, ar[i] + 1, 0)
		big[i] = cmark
	cmark = 0
	t=[0]*(len(ar))
	for i in range(len(ar)):
		cmark = max(cmark, big[i]) 
		t[i]=cmark  # total marks at that index
	ans=0
	for i in range(len(ar)):
		t[i]=t[i]-ar[i]-1 #answer calc
	return (sum(t))


a = input()
print(f([*map(int, input().strip().split())]))
",linear,"data structures,dp,greedy",505
"n = int(input())
m = input().split()
t = []
for i in range(n):
    m[i] = int(m[i])
    if i == 0:
        t.append(m[i]+1)
    else:
        t.append(max(t[i-1], m[i]+1))
s = t[n-1] - m[n-1] - 1
for i in range(n-2, -1, -1):
    if t[i] < t[i+1]-1:
        t[i] = t[i+1]-1
    s += t[i] - m[i] - 1
print(s)",linear,"data structures,dp,greedy",306
"n = int(input())
m = input().split(' ')
j = 0
mark = [1]
for i in range(1,len(m)) :
    tmp = max(mark[i-1],int(m[i])+1)
    mark.append(tmp)

j+=mark[len(m)-1]-int(m[len(m)-1])-1
for i in range(len(m)-2,-1,-1):
    if mark[i]<mark[i+1]-1:
        mark[i] = mark[i+1]-1
    j+=mark[i]-int(m[i])-1
print(j)
",linear,"data structures,dp,greedy",306
"n=int(input())
a=input().split(' ')
for i in range(len(a)):
    a[i]=int(a[i])
khat=n*[0]
ted=0
assl=0
khat[0]=1
lol=[0,0]
for i in range(1,len(khat)):
    khat[i]=max([khat[i-1],a[i]+1])
for i in range(len(khat)-2,-1,-1):
    if khat[i]<khat[i+1]-1:
        khat[i]=khat[i+1]-1
    ted=ted+(khat[i]-(a[i]+1))
ted=ted+(khat[n-1]-(a[n-1]+1))
print(ted)
",linear,"data structures,dp,greedy",352
"n = int(input())
Ab = input().split()
Un = []
Al = [0]
r = 0
for i in range(n):
    Ab[i] = int(Ab[i])
    Al.append(max(Ab[i]+1,Al[i]))
for i in range(n,-1,-1):
    if Al[i-1] < Al[i] - 1:
        Al[i-1] = Al[i] - 1
for i in range(n):
    Un.append(Al[i+1]-Ab[i]-1)
    r += Un[-1]
print(r)
",linear,"data structures,dp,greedy",293
"n,p = map(int,input().split())
a  = list(map(int,input().split()))
forward = [a[0]]
for i in range(1,n):
    forward.append(forward[-1] + a[i])
sm = sum(a)
mx = -float('inf')
for i in range(n-1):
    mx = max(mx,(forward[i]%p) + ((sm -forward[i] )%p))
print(mx)",linear,brute force,261
"n,k = map(int, input().strip().split(' '))
lst = list(map(int, input().strip().split(' ')))
s=sum(lst)
s2=0
m=0
for i in range(n-1):
    s2+=lst[i]
    s-=lst[i]
    if (s2%k)+(s%k)>m:
        m=(s2%k)+(s%k)
print(m)
    
    
        
",linear,brute force,236
"n, p = map(int, input().split())
a = list(map(int, input().split()))
t = 0
k = 0
for i in range(n):
    k += a[i]
s = 0
for i in range(0, n-1):
    s += a[i]
    t = max(t, s%p + (k - s)%p)
print(t)
",linear,brute force,199
"n, p = map(int, input().split())

arr = [int(b) for b in input().split()]

res = []

prefsums = [arr[0]]

for i in range(1, n):
    prefsums.append(prefsums[i - 1] + arr[i])

allsum = sum(arr)

if len(arr) == 2:
    print(arr[0] % p + arr[1] % p)
    exit()

for i in range(1, n - 1):
    res.append((prefsums[i] % p) + ((allsum - prefsums[i]) % p))


print(max(res))

",linear,brute force,369
"n, p = map(int, input().split())
a = list(map(int, input().split()))
a = [c % p for c in a]
s = sum(a)
sp = s % p
if sp == s or sp + 1 == p:
    print(sp)
else:
    print(sp + p)",linear,brute force,178
"#Mamma don't raises quitter.................................................
from collections import deque as de
import math
import re
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr
from bisect import bisect_left as bl, bisect_right as br

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
    
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack() 

#decimal to binary   
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")
#binary to decimal
def binarytodecimal(n):
    return int(n,2)

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))
    return prime_factors

def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

 
# Function to get product of digits
def getProduct(n):
 
    product = 1
 
    while (n != 0):
        product = product * (n % 10)
        n = n // 10
 
    return product

# function to count consecutive duplicate element in an array
def dupconscount(nums):
    element = []
    freque = []
    if not nums:
        return element
    running_count = 1
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]:
            running_count += 1
        else:
            freque.append(running_count)
            element.append(nums[i])
            running_count = 1
    freque.append(running_count)
    element.append(nums[i+1])
    return element,freque
        

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

#ceil  function gives wrong answer after 10^17 so i have to create my own :)
# because i don't want to doubt on my solution of 900-1000 problem set.
def ceildiv(x,y): 
    return (x+y-1)//y 
  
def di():return map(int, input().split())
def ii():return int(input())
def li():return list(map(int, input().split()))
def si():return list(map(str, input()))
def indic():
    dic = {}
    for index, value in enumerate(input().split()):
        dic[int(index)+1] = int(value)
    return dic

#Here we go......................
#concentration and mental toughness are margins of victory
n,p=di()
a=li()
fir=a[0]
sec=sum(a)-fir
ans=(fir%p)+(sec%p)
for i in range(1,n):
    fir+=a[i]
    sec-=a[i]
    temp=(fir%p)+(sec%p)
    if temp >ans:
        ans=temp
print(ans)

                    
                    
            
            
    
    

   
        





    
            
        
        
    
    

    
    
    
        


        
    




    





    





    
    
    
    
    

          
            
    

    
    
    
    
    
    
        
        
            
            
            
    
        
        
        

                

        
    



        
            

        

        
    
        
         





                
        
            
        
            

        
        

    

    
    
            
        
    

             
        


    
        

            

        
    
    

    
        
    
    

            
            
            

        
    
        
    
    
    
    

    
            
        
        
    
        
        
        


                
                

    


        
        
    
    
    
        
    
        
    




    

                
    
        


        
    

            
        
    

                
                
                
        
        
        

            

        





                    
                
            
        

            
    
        
    
    

    
        
    
 

    
        


    
        

",linear,brute force,4787
"n, p=map(int, input().split())
arr=list(map(int, input().split()))
su=0
for i in range(n):
	su+=arr[i]
maxi, f=0, 0
for i in range(n-1):
	f+=arr[i]
	maxi=max(maxi, f%p+(su-f)%p)
print(maxi)",linear,brute force,189
"n, p = map(int, input().split())
list1 = list(map(int, input().split()))
mx = 0
curr = 0
nxt = sum(list1)
for i in range(n - 1):
    curr += list1[i]
    nxt -= list1[i]
    mx = max(mx, curr % p + nxt % p)
print(mx)",linear,brute force,216
"arr = []
d = {}
for _ in range(int(input())):
    s = input()
    a,b,c = tuple(map(int, s.replace(""("","""").replace("")"","""").replace(""/"",""."").replace(""+"",""."").split(""."")))
    x = (a+b)/c
    arr.append(x)
    if x not in d:
        d[x] = 0
    d[x] += 1

for i in arr:
    print(d[i], end = "" "")",linear,"expression parsing,math",295
"from math import gcd
import sys
input=sys.stdin.readline
from collections import defaultdict as dd
m=int(input())
d=dd(int)
l=[]
for i in range(m):
    s=input().split()[0]
    a=0
    b=0
    c=0
    n=len(s)
    ind=0
    for i in range(1,n):
        if(s[i]=='+'):
            ind=i+1
            break
        a=a*10+int(s[i])
    for i in range(ind,n):
        if(s[i]==')'):
            ind1=i+2
            break
        b=b*10+int(s[i])
    for i in range(ind1,n):
        c=c*10+int(s[i])
    a=a+b
    g=gcd(a,c)
    a=a//g
    c=c//g
    d[(a,c)]+=1
    l.append((a,c))
for i in l:
    print(d[i],end="" "")
",linear,"expression parsing,math",617
"from collections import defaultdict
from sys import stdin

input = stdin.readline

dct = defaultdict(int)
n = int(input())
lst = [0] * n
for i in range(n):
    t = input().strip()
    a, b, c = map(int, (t[1:t.index('+')], t[t.index('+') + 1:t.index(')')], t[t.index('/') + 1:]))
    x = (a + b) / c
    lst[i] = x
    dct[x] += 1
for i in lst:
    print(dct[i], end=' ')
",linear,"expression parsing,math",372
"
def val(s):
  ans = ((int(s.split('+')[0][1:]) + int(s.split('+')[1].split(')')[0])) / int(s.split('/')[1]))
  return ans 

n = int(input())
s = []
f = {}
for i in range(n):
  ss = input()
  s.append(val(ss))
  if(s[i] not in f):
    f[s[i]] = 1 
  else:
    f[s[i]] += 1

for i in range(len(s)):
  print(f[s[i]], end= "" "")
print()

",linear,"expression parsing,math",334
"f=input
D,E=dict(),[eval(f())for i in range(int(f()))]
for e in E:D[e]=D.get(e,0)+1
for e in E:print(D[e])",linear,"expression parsing,math",106
"f=input
D,E={},[eval(f())for _ in range(int(f()))]
for e in E:D[e]=D.get(e,0)+1
for e in E:print(D[e])",linear,"expression parsing,math",102
"from math import gcd

n = int(input())
d = dict()
qs = []
for i in range(n):
    s = input()
    a = int(s[1:s.index('+')])
    b = int(s[s.index('+') + 1: s.index(')')])
    c = int(s[s.index(')') + 2:])
    a = a + b
    gc = gcd(a, c)
    res = (a // gc, c // gc)
    qs.append(res)
    if res in d:
        d[res] += 1
    else:
        d[res] = 1
for q in qs:
    print(d[q], end=' ')
",linear,"expression parsing,math",390
"from math import gcd
from collections import defaultdict as dd
m=int(input())
d=dd(int)
l=[]
ans=[]
for i in range(m):
    s=input().split()[0]
    a=0
    b=0
    c=0
    n=len(s)
    ind=0
    for i in range(1,n):
        if(s[i]=='+'):
            ind=i+1
            break
        a=a*10+int(s[i])
    for i in range(ind,n):
        if(s[i]==')'):
            ind1=i+2
            break
        b=b*10+int(s[i])
    for i in range(ind1,n):
        c=c*10+int(s[i])
    a=a+b
    g=gcd(a,c)
    a=a//g
    c=c//g
    d[(a,c)]+=1
    l.append((a,c))
for i in l:
    ans.append(d[i])
print(*ans)",linear,"expression parsing,math",596
"n=int(input())
dict1={}
dict2={}
for i in range(n):
    s=input()
    s=s.split('/')
    c=int(s[1])
    s=s[0].strip('(').strip(')').split('+')
    a=int(s[0])
    b=int(s[1])
    ans=(a+b)/c
    try:
        dict2[ans] += 1
    except:
        dict2[ans] = 1
    dict1[i] = ans
for i in range(n):
    print(dict2[dict1[i]],end=' ')
",linear,"expression parsing,math",334
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353
# from sys import stdin
# input = stdin.readline
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass

n=L()[0]
if n<6:
    print(-1)
else:
    print(1,2)
    print(1,3)
    print(1,4)
    for i in range(5,n+1):
        print(2,i)
for i in range(1,n):
    print(i,i+1)




endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")",linear,"constructive algorithms,trees",1294
"import os
import sys
from io import BytesIO, IOBase
from collections import Counter

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)


def lcm(a, b):
    return (a * b) / gcd(a, b)


def main():
    n=int(input())
    if n<6:
        print(-1)
    else:
        for i in range(2, n-2+1):
            print(1, i)
        print(2, n-1)
        print(2, n)
    for i in range(1,n):
        print(i, i+1)

    return


if __name__ == ""__main__"":
    main()",linear,"constructive algorithms,trees",2077
"import sys
input = sys.stdin.readline
n = int(input())
if n < 6:
    print(-1)

else:
    l = []
    o = []
    x = (3+n)//2
    for i in range(3,x+1):
        l.append((1,i))

    for i in range(x+1,n+1):
        o.append((2,i))

    sys.stdout.write(""1""+"" ""+""2""+""\n"")
    for x in l:
        sys.stdout.write(str(x[0]) + "" "" + str(x[1]) + ""\n"")

    for x in o:
        sys.stdout.write(str(x[0]) + "" "" + str(x[1]) + ""\n"")

sys.stdout.write(""1""+"" ""+""2""+""\n"")
p = 2
for i in range(3,n+1):
    sys.stdout.write(str(p) + "" "" + str(i) + ""\n"")
    p = i

",linear,"constructive algorithms,trees",552
"n = int(input())
 
if n<6:
	print(-1)
else:
	print(""1 2\n1 3\n1 4"")
	for i in range(5,n+1):
		print('2 '+str(i))
for i in range(2, n+1):
	print('1 '+str(i))",linear,"constructive algorithms,trees",156
"n=int(input())
if(n<6):
    print(-1)
else:
    print(1,2)
    print(1,3)
    print(1,4)
    for i in range(4,n):
        print(2,i+1)
 
for i in range(n-1):
    print(1,i+1+1)",linear,"constructive algorithms,trees",176
"n = int(input())
if n <= 5:
    print(-1)
    for i in range(2, n+1):
        print(1, i)
    exit()

print(1, 2)
print(2, 3)
print(2, 4)
for i in range(5, n+1):
    print(3, i)

for i in range(2, n+1):
    print(1, i)
",linear,"constructive algorithms,trees",219
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
else:
    input = sys.stdin.readline

############## Code starts here ##########################

n = int(input())

if(n == 2 or n == 3 or n == 4 or n == 5):
    print(-1)
else:
    print(1,2)
    print(2,3)
    print(2,4)
    for i in range(5,n + 1):
        print(4,i)

for i in range(2,n + 1):
    print(1,i)

############## Code ends here ############################
",linear,"constructive algorithms,trees",565
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n=int(input())
if n<=5:
    print(-1)
else:
    for i in range(2,5):
        print(1,i)
    for i in range(5,n+1):
        print(2,i)
for i in range(2,n+1):
    print(1,i)",linear,"constructive algorithms,trees",453
"n=int(input())
if n>=6:
	for i in range(2, n-1):
		print(1, i)
	for i in range(n-1, n+1):
		print(2, i)
else:
	print(-1)
for i in range(2, n+1):
	print(1, i)",linear,"constructive algorithms,trees",157
"n, k = map(int, input().split())
a = list(map(int, input().split()))
t = list(map(int, input().split()))
p = [0] * (n + 1)
now = 0
for i in range(0, n):
    if (t[i] == 1):
        now += a[i]
    p[i + 1] = p[i]
    if (t[i] == 0):
        p[i + 1] += a[i]
s = 0
for i in range(n - k + 1):
    s = max(s, p[i + k] - p[i])
print(now + s)
    ",linear,"data structures,dp,implementation,two pointers",342
"n,k = list(map(int, input().split()))
a = list(map(int, input().split()))
t = list(map(int, input().split()))
x = 0
summ = 0
maxx = 0
for i in range(n):
  summ += a[i]*t[i]
for i in range(k):
  if not t[i]:
    x+=a[i]
maxx = max(maxx,x)
for i in range(n-k):
  x+=a[i+k]*(1-t[i+k])
  x-=a[i]*(1-t[i])
  if x>maxx:
    maxx=x
  #maxx = max(x, maxx)
print(summ+maxx)",linear,"data structures,dp,implementation,two pointers",364
"import sys
input=sys.stdin.readline
n,k=map(int,input().split())
theorems=list(map(int,input().split()))
sleep=list(map(int,input().split()))
tsum=[]
ts=0
sleepsum=[]
slsum=0
for i in range(n):
    ts+=theorems[i]
    tsum.append(ts)
    if(sleep[i]==1):
        slsum+=theorems[i]
    sleepsum.append(slsum)
#print(""tsum="",tsum)
#print(""sleepsum="",sleepsum)
maxdiff=0
#print(""slsum="",slsum)
maxdiff=tsum[k-1]-sleepsum[k-1]
for i in range(1,n-k+1):
    diff=(tsum[i+k-1]-tsum[i-1])-(sleepsum[i+k-1]-sleepsum[i-1])
    #print(""i="",i,""diff="",diff)
    maxdiff=max(maxdiff,diff)
#print(""maxdiff="",maxdiff)
print(slsum+maxdiff)",linear,"data structures,dp,implementation,two pointers",623
"n,k=map(int,input().split())
a=list(map(int,input().split()))
t=list(map(int,input().split()))
ans=0
m=0
for i in range(n):
    if t[i]:
        ans+=a[i]
        a[i]=0
cf=[0]*(n+1)
for i in range(1,n+1):
    cf[i]=cf[i-1]+a[i-1]
for i in range(n-k+1):
    m=max(m,cf[i+k]-cf[i])
print(ans+m)",linear,"data structures,dp,implementation,two pointers",293
"def ints():
 return list(map(int,input().split()))
n,k=ints()
a,t=ints(),ints()
ans=sum(a[ii] for ii in range(n) if t[ii])
bb=[a[ii] if t[ii]==0 else 0 for ii in range(n)]
ll=0
rr=k
tmp=sws=sum(bb[:k])
while rr<n:
 sws-=bb[ll]
 sws+=bb[rr]
 ll+=1
 rr+=1
 tmp=max(tmp,sws)
ans+=tmp
print(ans)
 			 	  		 		 	   	 	 	  	 			",linear,"data structures,dp,implementation,two pointers",322
"fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
z,zz=input,lambda:list(map(int,z().split()))
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from re import *
from sys import *
from math import *
from heapq import *
from queue import *
from bisect import *
from string import *
from itertools import *
from collections import *
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from collections import Counter as cc
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
    return 1
def dfs(u,visit,graph):
    visit[u]=1
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)
def output(answer):
    stdout.write(str(answer))
###########################---Test-Case---#################################
""""""

  If you Know me , Then you probably don't know me !


""""""
###########################---START-CODING---##############################

 
 
n,k=zzz()

arr1=zzz()
arr2=zzz()
ans=0

new_arr=[0]*n

for i in range(n):
    if arr2[i]==0:
        new_arr[i]=arr1[i]
    else:
        ans+=arr1[i]

total=sum(new_arr[:k])
mx=total

j=0
for i in range(k,n):
    total-=new_arr[j]
    total+=new_arr[i]
    mx=max(mx,total)
    j+=1
        
    
print(mx+ans)
    










    








        
        
       
",linear,"data structures,dp,implementation,two pointers",1495
"n,k=list(map(int,input().split()))

arr1=list(map(int,input().split()))
arr2=list(map(int,input().split()))
ans=0

new_arr=[0]*n

for i in range(n):
    if arr2[i]==0:
        new_arr[i]=arr1[i]
    else:
        ans+=arr1[i]

total=sum(new_arr[:k])
mx=total

j=0
for i in range(k,n):
    total-=new_arr[j]
    total+=new_arr[i]
    mx=max(mx,total)
    j+=1
        
    
print(mx+ans)
    ",linear,"data structures,dp,implementation,two pointers",391
"from sys import stdin, stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):#nmbr()):
    n,k=lst()
    a=lst()
    b=lst()
    ps=list(accumulate(a))
    dp=[[0 for _ in range(2)] for _ in range(1+n)]
    for i in range(1,n+1):
        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]
        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])
    # print(dp)
    print(max(max(v) for v in dp))",linear,"data structures,dp,implementation,two pointers",522
"from sys import stdin, stdout
from itertools import accumulate
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):#nmbr()):
    n,k=lst()
    a=lst()
    b=lst()
    ps=list(accumulate(a))
    dp=[[0 for _ in range(2)] for _ in range(1+n)]
    for i in range(1,n+1):
        dp[i][0]=dp[i-1][0]+a[i-1]*b[i-1]
        dp[i][1]=max(dp[i-1][1]+a[i-1]*b[i-1],ps[i-1]-(ps[i-k-1] if i-k-1>=0 else 0)+dp[max(i-k,0)][0])
    # print(dp)
    print(max(dp[n]))",linear,"data structures,dp,implementation,two pointers",509
"



n = int(input())

t = list(map(int,input().split()))


p = sum(t)
import math

a = math.ceil(p/2)

u=0
for j in range(n):
    u+=t[j]
    if u>=a:
        print(j+1)
        break
    
",linear,implementation,189
"
def get_answer(arr):
    current_sum = 0
    total = sum(arr)
    for index, val in enumerate(arr):
        current_sum += val
        if current_sum >= total / 2:
            return index + 1

nonsense = input()
input_values = input()
values = [int(v) for v in input_values.split()]

print(get_answer(values))
",linear,implementation,312
"n=int(input())
a=list(map(int,input().split()))
s=sum(a)
new=0
i=0
while 2*(new+a[i])<s:
    new+=a[i]
    i+=1
print(i+1)
",linear,implementation,123
"n = int(input())

number_sequence = [int(x) for x in input().split("" "")]
number_total = sum(number_sequence)

current_total = 0
current_position = 0

for number in number_sequence:
    current_total = current_total + number
    current_position = current_position + 1
    if(current_total >= number_total/2):
        print(current_position)
        break
",linear,implementation,355
"import math

input()
all_days_problems = list(map(int, input().split()))
sum_count = sum(all_days_problems)
half_problems = math.ceil(sum_count/2)
current_sum = 0
answer = 0
for num in all_days_problems:
    answer += 1
    current_sum +=num
    if current_sum >=half_problems:
        break

print(answer)
 	   	 	 	 								 	  		 	   	",linear,implementation,338
"import bisect

def solve():
    n = int(input())
    a = [int(x) for x in input().split(' ')]
    p = [0]
    for x in a:
        p.append(p[-1] + x)
    return bisect.bisect_left(p, p[-1] / 2)

print(solve())",linear,implementation,209
"# Input.
n = int(input())
A = [int(a) for a in input().split()]

# Prefix sum array.
prefix = [0] * n
prefix[0] = A[0]
for i in range(1, n):
    prefix[i] = prefix[i - 1] + A[i]

# Binary Search.
target = (sum(A) + 1) // 2

for i in range(n):
    if prefix[i] < target:
        continue
    else:
        print(i + 1)
        break",linear,implementation,331
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################
import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 


alphabets = list('abcdefghijklmnopqrstuvwxyz')


def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def fastPrintNextLines(a):
    # 12
    # 3
    # 1
    #like this
    #a is list of strings
    print('\n'.join(map(str,a)))

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1
# t = int(input())
for _ in range(t):
    n = ii()
    a = li()
    s = sum(a)
    cur = 0
    for i in range(n):
        cur+=a[i]
        if cur>=s/2:
            print(i+1)
            break
",linear,implementation,3017
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
n, A, B, C, T = rints()
a, ans = rints(), 0
for i in range(n):
    su, cur = A, A
    for j in range(a[i], T):
        cur -= B
        su = max(su, (j - a[i] + 1) * C + cur)

    ans += su
print(ans)
",linear,math,283
"n, a, b, c, t = map(int, input().split())
l = list(map(int, input().split()))
f = [0] * 1001
for i in l: f[i] -= -1
tmp = 0
tmp2 = 0
for i in range(1, t):
    tmp += (t - i) * f[i]
tmp = n * a + tmp * c - tmp * b
print(max(n * a, tmp))",linear,math,235
"n, a, b, c, T = map(int, input().split())
ts = list(map(int, input().split()))
ts.sort()
ans = 0
for t in ts:
    temp = -10**18
    for u in range(t, T+1):
        temp = max(temp, c*(u-t)+a-b*(u-t))
        #print(temp)
    ans += temp
print(ans)
",linear,math,249
"n,a,b,c,t=map(int,input().split())
l=list(map(int,input().split()))
if c>b:
    r=0
    for i in l:
        k=t-i
        k*=(c-b)
        r+=k
    print(a*n+r)
else:
    print(a*n)
",linear,math,182
"n,a,b,c,T=map(int,input().split())
arr=list(map(int,input().split()))
Tcnt=arr.count(T);l=n-Tcnt;ans=0;a1=0
for i in range(1,T):
  for j in range(n):
    if arr[j]<=i:a1+=1
 # print(a1)
  ans+=a1*c;a1=0  
b1=0
#print(ans)
#print(ans)
for i in range(n):
  b1=a-((T-arr[i])*b)#;print(b1)
  if b1<=0:ans+=b1;
  else:ans+=b1
ans1=n*a
print(max(ans,ans1))

",linear,math,352
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################
import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
from bisect import bisect_left , bisect_right
import math 




alphabets = list('abcdefghijklmnopqrstuvwxyz')



#for deep recursion__________________________________________-
from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,p - 2, p)) % p

def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    c = dict(Counter(l))
    return list(set(l))
    # return c

def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 

#____________________GetPrimeFactors in log(n)________________________________________
def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i): 
                if (spf[j] == j):
                    spf[j] = i
    return spf
def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]  
    return ret
#____________________________________________________________



def SieveOfEratosthenes(n): 
    #time complexity = nlog(log(n))
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def si():
    return input()
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


def solve():
    n,a,b,c,t = li()
    ti = li()
    if b>c:
        print(n*a)
    else:
        ans = 0
        ti.sort()
        for i in ti:
            ans+=(t-i)*(c-b)+a 
        print(ans)


t = 1
# t = ii()
for _ in range(t):
    solve()
",linear,math,3860
"n,A,B,C,T=map(int,input().split())
t=list(map(int,input().split()))
if(B>C):
    print(n*A)
else:
    c=0
    t.sort()
    for i in t:
        c+=(T-i)*(C-B)+A 
    print(c)",linear,math,173
"n, s = map(int, input().split())
times = []
result = 0 
need = True 
for i in range (n):
    h, m = map(int, input().split())
    times.append(60*h + m)

if n == 1:
    if 0 + s + 1 <= times[0]:
        need = False
for i in range(n-1):
    if 0 + s + 1 <= times[0]:
        need = False
        break
    if times[i+1] - times[i] >= 2 + 2*s:
        result = times[i] + 1 + s
        break 
if result == 0 and need:
    result = times[n-1] + 1 + s

hour = result // 60
minute = result % 60

print(hour, minute)",linear,implementation,511
"if __name__ == '__main__':
    n, s = map(int, input().split())
    a = []
    for _ in range(n):
        h, m = map(int, input().split())
        a.append(h * 60 + m)
    if a[0] != 0 and a[0] > s:
        print(0, 0)
    else:
        a.append(a[n - 1] + 2 * s + 3)
        for i in range(1, n + 1):
            if a[i] - (a[i - 1] + 2 + s) >= s:
                print((a[i - 1] + s + 1)//60, (a[i - 1] + s + 1)%60)
                break
",linear,implementation,440
"n, m = map(int,input().split())
b = []
d = []
for x in range(n):
	if x == 0:
		a,c = map(int,input().split())
		if (a * 60) + c > m:b.append(""0 0"")
		d.append((a * 60) + c)
	else:
		a ,c = map(int,input().split())
		if ((a * 60) + c) - d[-1] > (m * 2) + 1:
			f = d[-1] + m + 1
			b.append(str(f // 60) + "" "" + str((f % 60)))
		d.append((a * 60) + c)
if len(b) == 0:
	f = d[-1] + m + 1
	b.append(str(f // 60) + "" "" + str((f % 60)))
print(b[0])",linear,implementation,443
"n,k = map(int,input().split())
r = 0
for _ in range(n):
    h,m = map(int,input().split())
    t = 60*h+m
    if(t>r+k): 
        break
    r = t+k+1
print(r//60,r%60)",linear,implementation,167
"n,s=map(int,input().split())
h=list()
m=list()
l=list()
l.append(0)
for _ in range(n):
    x,y=map(int,input().split())
    h.append(x)
    m.append(y)
    l.append((x*60)+y)
if(l[1]!=0 and (l[1]-l[0])>=s+1):
    print(0,0)
else:
    k=2*s+2
    r=0
    for i in range(n):
        if(l[i+1]-l[i]>=k):
            r=l[i]+s+1
            break
        else:
            continue
    if(r==0):
        r=l[n]+s+1    
    print(r//60,r%60)
    ",linear,implementation,440
"


n,s = map(int,input().split())
t=[[0,0]]
for j in range(n):

    a,b = map(int,input().split())


    total = a*60+b


    last = t[-1][0]*60+t[-1][1]+1

    t.append([a,b])

    if j==0:
        if total>= s+1:
            print(0,0)
            break
    if total-last > 2*s:
        u = last+s
        print(u//60, u%60)
        break

    if j==n-1:
        x = t[-1][0]*60+t[-1][1]
        print((x+s+1)//60 ,(x+s+1)%60 )
        break


    
    
",linear,implementation,456
"from __future__ import division
from sys import stdin, stdout
from collections import *

rstr = lambda: stdin.readline().strip()
rstrs = lambda: [str(x) for x in stdin.readline().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(stdin.readline())
rints = lambda: [int(x) for x in stdin.readline().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
pr = lambda args, sep: stdout.write(sep.join(map(str, args)) + '\n')
ceil1, out = lambda a, b: (a + b - 1) // b, []

n, s = rints()
a, ans = rints_2d(n), -1

for i in range(26):
    for j in range(60):
        tem = i * 60 + j
        ans = (i, j)
        for h, m in a:
            tem2 = h * 60 + m
            if tem <= tem2:
                if tem2 - (tem + 1) < s:
                    ans = -1
                    break
            else:
                if tem - (tem2 + 1) < s:
                    ans = -1
                    break

        if ans != -1:
            print('%d %d' % (ans[0], ans[1]))
            exit()
",linear,implementation,1054
"from itertools import *
n, s = map(int, input().split())
times = []
for i in range(n):
    h, m = map(int, input().split())
    times.append((h * 60 + m))

times.sort()
for t in count():
    if all(abs(u - t) > s for u in times):
        print(*divmod(t, 60))
        break
",linear,implementation,274
"I=lambda:map(int,input().split())
n,s=I()
l=[0]
for i in range(n):
    q,w=I()
    q=q*60+w
    l+=[q]
if l[1]-l[0]>s:exit(print(0, 0))
for i in range(n):
    if l[i+1]-l[i]>2*s+1:
        l[i]+=s+1
        exit(print(l[i]//60,l[i]%60))
l[-1]+=s+1
print(l[-1]//60,l[-1]%60)",linear,implementation,273
"# ---------------------------iye ha aam zindegi---------------------------------------------
import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
#import threading
from collections import defaultdict
#threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
#sys.setrecursionlimit(300000)

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------game starts now----------------------------------------------------import math
class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1


class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):
        """"""
        Side effect!!! Changes node. Node should have exactly one child
        """"""
        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n


# -----------------------------------------------binary seacrh tree---------------------------------------
class SegmentTree1:
    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------game starts now----------------------------------------------------import math
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


# --------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m


# --------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z


# --------------------------------------------------product----------------------------------------
def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por


# --------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] <=key):
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count


# --------------------------------------------------binary----------------------------------------
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)


# --------------------------------------------------binary------------------------------------
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord
#-----------------------------------------trie---------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None  # left node for 0
        self.right = None  # right node for 1
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data
#-------------------------bin trie-------------------------------------------
n,a1,b=map(int,input().split())
l=[]
ans=0
d=defaultdict(int)
e=defaultdict(list)
e1=defaultdict(int)
for i in range(n):
    a,b,c=map(int,input().split())
    d[(b,c)]+=1
for i in d:
    b,c=i
    e[c-a1*b].append(d[i])
    e1[c-a1*b]+=d[i]
for i in e:
    for j in e[i]:
        ans+=j*(e1[i]-j)
print(ans)",linear,"geometry,math",19401
"import sys
import io, os
input = sys.stdin.buffer.readline
#input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

from collections import defaultdict

n, a, b = map(int, input().split())
XV = []
for i in range(n):
    x, vx, vy = map(int, input().split())
    XV.append((x, vx, vy))
if a != 0:
    ans = 0
    d = defaultdict(lambda:0)
    dvx = defaultdict(lambda:0)
    for x, vx, vy in XV:
        k = -a*vx+vy
        ans += max(0, d[k]-dvx[(k, vx)])
        d[k] += 1
        dvx[(k, vx)] += 1
    print(ans*2)
else:
    ans = 0
    d = defaultdict(lambda:defaultdict(lambda:0))
    ds = defaultdict(lambda:0)
    for x, vx, vy in XV:
        ans += max(0, ds[vy]-d[vy][vx])
        d[vy][vx] += 1
        ds[vy] += 1
    print(ans*2)
",linear,"geometry,math",747
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

from collections import defaultdict

n, a, b = map(int, input().split())
XV = []
for i in range(n):
    x, vx, vy = map(int, input().split())
    XV.append((x, vx, vy))
if a != 0:
    ans = 0
    d = defaultdict(lambda:0)
    dvx = defaultdict(lambda:0)
    dvy = defaultdict(lambda:0)
    dvxy = defaultdict(lambda:0)
    for x, vx, vy in XV:
        k = -a*vx+vy
        ans += max(0, d[k]-(dvx[(k, vx)]+dvy[(k, vy)]-dvxy[(k, vx, vy)]))
        d[k] += 1
        dvx[(k, vx)] += 1
        dvy[(k, vy)] += 1
        dvxy[(k, vx, vy)] += 1
    print(ans*2)
else:
    ans = 0
    d = defaultdict(lambda:defaultdict(lambda:0))
    ds = defaultdict(lambda:0)
    for x, vx, vy in XV:
        ans += max(0, ds[vy]-d[vy][vx])
        d[vy][vx] += 1
        ds[vy] += 1
    print(ans*2)
",linear,"geometry,math",867
"n, A, C = list(map(int, input().split()))

def Ro(x, y):
    return A * x - y + C
 
huh = []
 
for i in range(n):
    z, x, y = list(map(int, input().split()))
    huh.append((Ro(x + z, z * A + y), x))
huh = sorted(huh)
anss = 0
c1 = 0
c2 = 0
prev = (-9999999999999, -999999999999999)
g = []

huh.append((-9999999999999, -999999999999999))
#print(huh)
for huhh in huh:
    if huhh[0] != prev[0]:
        g.append(c1)
        #print(g)
        for j in g:
            anss += (c2 - j) * j
        g = []
        c1 = 1
        c2 = 1
        prev = (huhh[0], huhh[1])
        continue
    c2 += 1
    if huhh[1] != prev[1]:
        g.append(c1)
        c1 = 0
        prev = (huhh[0], huhh[1])
    c1 += 1
print(anss)
    ",linear,"geometry,math",721
"import atexit
import io
import sys

# Buffering IO
_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
    

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a*x+b + vy
        dd = a*nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx,vy) not in dc[dd]:
            dc[dd][(vx,vy)] = 0
        dc[dd][(vx,vy)] += 1
    
    tot = 0
    for v,k in dc.items():
        tt = 0
        pp =0
        for _,cc in k.items():
            tt -= cc * (cc+1) // 2
            pp += cc
        tt += pp * (pp+1) // 2
        tot += tt*2
    print(tot)
        

    
if __name__ == '__main__':
    main()
        ",linear,"geometry,math",931
"n, a, b = map(int, input().split())
ghosts = [(vx, vy) for x, vx, vy in (map(int, input().split()) for i in range(n))]
speeds = {}
for vx, vy in ghosts:
    vl = a * vx - vy
    k = vx + a * vy
    ss = speeds.setdefault(vl, {})
    ss[k] = ss.get(k, 0) + 1

result = 0
for vl, ss in speeds.items():
    group_size = sum(ss.values())
    for sss in ss.values():
        result += sss * (group_size - sss)
print(result)",linear,"geometry,math",418
"import atexit
import io
import sys

# Buffering IO
_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER


@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())


def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a * x + b + vy
        dd = a * nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx, vy) not in dc[dd]:
            dc[dd][(vx, vy)] = 0
        dc[dd][(vx, vy)] += 1

    tot = 0
    for v, k in dc.items():
        tt = 0
        pp = 0
        for _, cc in k.items():
            tt -= cc * (cc + 1) // 2
            pp += cc
        tt += pp * (pp + 1) // 2
        tot += tt * 2
    print(tot)


if __name__ == '__main__':
    main()",linear,"geometry,math",920
"import atexit
import io
import sys

# Buffering IO
_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__

def main():
    n, a, b = [int(x) for x in input().split()]
    dc = {}
    for i in range(n):
        x, vx, vy = [int(x) for x in input().split()]
        nx = x + vx
        ny = a * x + b + vy
        dd = a * nx - ny + b
        if dd not in dc:
            dc[dd] = {}
        if (vx, vy) not in dc[dd]:
            dc[dd][(vx, vy)] = 0
        dc[dd][(vx, vy)] += 1

    tot = 0
    for v, k in dc.items():
        tt = 0
        pp = 0
        for _, cc in k.items():
            tt -= cc * (cc + 1) // 2
            pp += cc
        tt += pp * (pp + 1) // 2
        tot += tt * 2
    print(tot)


if __name__ == '__main__':
    main()",linear,"geometry,math",776
"import sys
if locals()['__file__'][-2:] == 'py':
    sys.stdin = open('in.txt', 'r')
from sys import stdin
rl = lambda l: tuple(map(int, l.split()))
n, a, b = rl(input())
l = list(map(rl, stdin.readlines()))
c, d = {}, {}
r = 0
for _, x, y in l:
    i, j = a * x - y, (x, y)
    r += c.get(i, 0) - d.get(j, 0)
    c[i] = c.get(i, 0) + 1
    d[j] = d.get(j, 0) + 1
print(2 * r)
",linear,"geometry,math",377
"num=int(input())

b=input()

if b=='0' or b=='1':
    print(b)

else:
    s=len(list(filter(lambda x:x=='0',b)))

    print('1'+'0'*s)",linear,implementation,134
"n = int(input())
a = input()
zero = 0
for i in range(len(a)):
    if (a[i] == ""0""):
        zero += 1
if (""1"" in a):
    print(""1"", end="""")
    print(""0""*zero)
else:
    print(""0""*zero)",linear,implementation,185
"n = int(input())
s = input()
x = s.count('0')
if s == '0':
    print('0')
else:
    print('1' + '0'*x)",linear,implementation,102
"# A. Minimum Binary Number

n = int(input())
s = input()

if n == 1:
    print(s)
else:
    zeros = s.count('0')
    print('1' + zeros * '0')
",linear,implementation,142
"n = int(input())

m = input()

s = list(m)

if n==1:
    ans = s[0]
else:
    count = 0
    for i in range(0,n):
        if s[i]=='0':
            count = count + 1
    ans = '1'
    for i in range(0,count):
        ans = ans + '0'

print(ans)",linear,implementation,243
"n=int(input())
s=input()
if ""0"" in s:
    if ""1"" in s:
        print(""1""+""0""*s.count(""0""))
    else:
        print(""0"")
else:
    print(""1"")",linear,implementation,140
"n, = map(int,input().split())

s = input()
if s=='0':
    print(0)
else:
    print(""1""+""0""*s.count('0'))",linear,implementation,104
"_ = int(input())
binary_number = input()

if binary_number == '0':
    print('0')
else:
    count_0 = sum(1 for b in binary_number if b == '0')
    count_1 = sum(1 for b in binary_number if b == '1')
    print('1' + '0' * count_0)
",linear,implementation,231
"n = input()
s = input()
n = int(n)
print('1'*min(s.count('1'), 1)+'0'*s.count('0'))",linear,implementation,83
"#time - O(n)
# space- O(1)

x=int(input())
s=input()

def substring(x,s):
    count=0
    ans=0
    
    for i in range(x):
        if s[i]==""x"":
            count+=1
        else:
            if count>=3:
                ans+=count-2
            count=0
    if count>=3:
        ans+=count-2
    
    return ans
print(substring(x,s))",linear,"greedy,strings",334
"# Time - O(n)
# Space - O(1)

n = int(input())
s = input()
count = 0
temp_count = 0
for c in s:
    if c == 'x':
        temp_count += 1
    else:
        temp_count = 0
    if temp_count == 3:
        count += 1
        temp_count -= 1

print(count)
",linear,"greedy,strings",251
"# TC - O(n)
#SC - O(n)
size = int(input())
s = input()


ct = 0
F = 0
for i in range(size-2):
    if s[i]==s[i+1] and s[i+1]==s[i+2] and s[i] == 'x':
        ct += 1
        F = 1

if F == 0:
    print(0)
else:
    print(ct)",linear,"greedy,strings",224
"a = int(input())
b = input()
s = 0
for i in range(a-2):
    if b[i:i+3] == 'xxx':
        s = s + 1
print(s)",linear,"greedy,strings",108
"import os
import sys
from math import *
from collections import *

# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase


def vsInput():
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA = ""abcdefghijklmnopqrstuvwxyz/""
M = 1000000007
EPS = 1e-6


def Ceil(a, b):
    return a // b + int(a % b > 0)


def value():
    return tuple(map(int, input().split()))


def array():
    return [int(i) for i in input().split()]


def Int():
    return int(input())


def Str():
    return input()


def arrayS():
    return [i for i in input().split()]


# -------------------------code---------------------------#

n = int(input())
s = input()
ans = 0
cnt = 0
for x in s:
    if x == ""x"":
        cnt += 1
        if cnt >= 3:
            ans += 1
    else:
        cnt = 0
print(ans)
",linear,"greedy,strings",2510
"#""xxx""が連続部分文字列としていくつ含まれるか
#文字ごとでグループに分ければキーがxのグループのみに注目することができる
#xがキーのグループの長さをlとするならmax(0,l-3+1)がそのグループに含まれる""xxx""の個数
from itertools import groupby
n=int(input())
s=input()
x=[len(list(group)) for key,group in groupby(s) if key==""x""]
ans=sum(max(0,l-3+1) for l in x)
print(ans)",linear,"greedy,strings",276
"'''Author- Akshit Monga'''
from sys import stdin,stdout
input=stdin.readline
t=1
for _ in range(t):
    n=int(input())
    x=input()
    c=0
    ans=0
    for i in x:
        if i=='x':
            c+=1
        else:
            ans+=max(0,c-2)
            c = 0
    ans+=max(0,c-2)
    print(ans)",linear,"greedy,strings",297
"n = int(input())

string = input()
i = 0
j = 0
total = 0

while j < len(string):
    bool = False
    count = 0
    while j < len(string) and string[i] == 'x' and string[j] == 'x':
        count += 1
        bool = True
        j += 1

    if count >= 3:
        total += (count-3)+1
    if bool:
        i = j
    else:
        i += 1
        j += 1



print(total)
",linear,"greedy,strings",367
"import re
input()
print(sum(len(f)-2 for f in re.findall('x{3,}',input())))",linear,"greedy,strings",75
"n = int(input())
black = list(input())
white = list(input())
katie = list(input())

ALPHABET = [chr(i) for i in range(65, 65+26)] + [chr(i)
                                                 for i in range(97, 97+26)]


def optimal_score(LIST):
    d = {char: 0 for char in ALPHABET}
    for v in LIST:
        d[v] += 1
    max_freq = max(d.values())
    L = len(LIST)
    res = 0
    for freq in d.values():
        if L - freq >= n:
            res = max(res, freq + n)
        else:
            if not (L -freq < n and n == 1):
                res = L
            else:
                res = max(res, L - 1)
    return res


score_black = optimal_score(black)
score_white = optimal_score(white)
score_katie = optimal_score(katie)

M = max(score_black, score_katie, score_white)
MAXCNT = 0

winner = ""NOBODY""


if M == score_black:
    winner = ""Kuro""
    MAXCNT += 1
if M == score_white:
    winner = ""Shiro""
    MAXCNT += 1
if M == score_katie:
    winner = ""Katie""
    MAXCNT += 1

if MAXCNT == 1:
    print(winner)

else:
    print(""Draw"")
",linear,greedy,1045
"import sys
input=sys.stdin.readline
al=list(""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"")
n=int(input())
s=[input().rstrip() for i in range(3)]
l=len(s[0])
ans=[0]*3
for c in al:
    for i in range(3):
        cnt_c=s[i].count(c)
        if cnt_c+n<=l:
            ans[i]=max(ans[i],cnt_c+n)
        else:
            if n==1 and l==cnt_c:
                ans[i]=max(ans[i],l-1)
            else:
                ans[i]=l
if (ans[0]==ans[1] and max(ans)==ans[0]) or (ans[1]==ans[2] and max(ans)==ans[1]) or (ans[0]==ans[2] and max(ans)==ans[2]):
    print(""Draw"")
elif max(ans)==ans[0]:
    print(""Kuro"")
elif max(ans)==ans[1]:
    print(""Shiro"")
else:
    print(""Katie"")",linear,greedy,681
"n=int(input())
st_a=input()
st_b=input()
st_c=input()
a=[0 for i in range(125)]
b=[0 for i in range(125)]
c=[0 for i in range(125)]
l=len(st_c)
for i in range(l):
    a[ord(st_a[i])] +=1
    b[ord(st_b[i])] +=1
    c[ord(st_c[i])] +=1
maxi_a=0
maxi_b=0
maxi_c=0
if n==1:
    maxi_a =max(a) +1
    maxi_b=max(b) +1
    maxi_c=max(c) +1
    if maxi_a >l:
        maxi_a-=2
    if maxi_b >l:
        maxi_b -=2
    if maxi_c >l:
        maxi_c-=2
else:
    for i in range(123):
        if (i>=65 and i <=90) or (i>=97 and i<=122):
            if a[i] +n >=l:
                    maxi_a=max(maxi_a,l)
            else:
                maxi_a =max(maxi_a ,a[i] +n)
            if b[i] +n >=l:
                    maxi_b=max(maxi_b,l)
            else:
                maxi_b =max(maxi_b ,b[i] +n)
            if c[i] +n >=l:
                    maxi_c=max(maxi_c,l)
            else:
                maxi_c =max(maxi_c ,c[i] +n)
s=[maxi_a,maxi_b,maxi_c]
s.sort()
if s[1] ==s[2]:
    print(""Draw"")
if maxi_a >max(maxi_b,maxi_c):
    print(""Kuro"")
if maxi_b >max(maxi_c,maxi_a):
    print(""Shiro"")
if maxi_c >max(maxi_b,maxi_a):
    print(""Katie"")
",linear,greedy,1141
"from collections import Counter

def f(x):
    return max(list(Counter(x).values()))

n=int(input())
z=input()
l=len(z)
a=f(z)
b=f(input())
c=f(input())

def v(x):
    if x==l:
        return x-1
    else:
        return x+1

if n==1:
    a, b, c=v(a), v(b), v(c)
    if a>b and a>c:
        print(""Kuro"")
    elif b>a and b>c:
        print(""Shiro"")
    elif c>a and c>b:
        print(""Katie"")
    else:
        print(""Draw"")
elif (l-a<=n)+(l-b<=n)+(l-c<=n)>=2:
    print(""Draw"")
elif a>b and a>c:
    print(""Kuro"")
elif b>a and b>c:
    print(""Shiro"")
elif c>a and c>b:
    print(""Katie"")
else:
    print(""Draw"")
#print((l-a<=n)+(l-b<=n)+(l-c<=n))
#print(a, b, c)",linear,greedy,666
"turns = int(input())
s0 = input()
s1 = input()
s2 = input()

d0 = dict()
d1 = dict()
d2 = dict()

alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
for char in alphabet:
	d0[char] = 0
	d1[char] = 0
	d2[char] = 0

for char in s0:
	d0[char] += 1
for char in s1:
	d1[char] += 1
for char in s2:
	d2[char] += 1	

m0 = max([d0[char] for char in alphabet])
m1 = max([d1[char] for char in alphabet])
m2 = max([d2[char] for char in alphabet])

l0 = len(s0)
l1 = len(s1)
l2 = len(s2)

if turns == 1 and m0 == l0:
	score0 = m0 - 1
else:
	score0 = min(l0,m0+turns)

if turns == 1 and m1 == l1:
	score1 = m1 - 1
else:
	score1 = min(l1,m1+turns)

if turns == 1 and m2 == l2:
	score2 = m2 - 1
else:
	score2 = min(l2,m2+turns)
	
scores = [score0,score1,score2]
bestscore = max(scores)

winnerlist = [i for i in range(3) if scores[i] == bestscore]
if len(winnerlist) > 1:
	print('Draw')
else:
	print(['Kuro','Shiro','Katie'][winnerlist[0]])",linear,greedy,939
"from collections import Counter;

n = int(input())

a = input()
b = input()
c = input()

fa = Counter(a);
fb = Counter(b);
fc = Counter(c);

la = min(fa.most_common(1)[0][1] + n, len(a))
lb = min(fb.most_common(1)[0][1] + n, len(a))
lc = min(fc.most_common(1)[0][1] + n, len(a))

if fa.most_common(1)[0][1] == len(a) and n == 1:
    la = len(a)-1

if fb.most_common(1)[0][1] == len(b) and n == 1:
    lb = len(b)-1

if fc.most_common(1)[0][1] == len(c) and n == 1:
    lc = len(c)-1



if la > max(lb, lc):
    print(""Kuro"")
elif lb > max(la, lc):
    print(""Shiro"")
elif lc > max(la, lb):
    print(""Katie"")
else:
    print(""Draw"")

",linear,greedy,634
"N = int(input())
S = [input() for i in range(3)]
bu = []
for s in S:
    cnt = {}
    mx = 0
    for c in s:
        if c not in cnt:
            cnt[c] = 0
        cnt[c] += 1
        mx = max(mx, cnt[c])
    if mx == len(s) and N == 1:
        bu.append(mx - 1)
    else:
        bu.append(min(len(s), mx + N))

ans = -1
ansmx = -1
for i in range(3):
    if bu[i] > ansmx:
        ans = i
        ansmx = bu[i]
    elif bu[i] == ansmx:
        ans = -1

if ans == -1:
    print('Draw')
elif ans == 0:
    print('Kuro')
elif ans == 1:
    print('Shiro')
else:
    print('Katie')
",linear,greedy,580
"def ct(s):
    a=[0]*26*2
    for i in s:
        if ord(i)<97:
            a[ord(i)-65]+=1
        else:
            a[ord(i)-97+26]+=1
    return max(a)
n=int(input())
s1=input()
ln=len(s1)
s1=ct(s1)
s2=ct(input())
s3=ct(input())
s=[s1,s2,s3]
for i in range(len(s)):
    if s[i]==ln and n==1: s[i]=ln-1
    else:s[i]=s[i]+n
    if s[i]>ln: s[i]=ln
s1=s[0]
s2=s[1]
s3=s[2]
#print(s)
s.sort()
if s[2]==s[1]:
    print('Draw')
elif s[-1]==s1:
    print('Kuro')
elif s[-1]==s2:
    print('Shiro')
elif s[-1]==s3:
    print('Katie')


    


##////////////////      //////        ///////      //             ///////     //  //   //
##////          //    ///   ///     ///    ///     //            ///  ///     ////     //
##////    ////       ///     ///   ///      ///    //           /////////     ////     ///////
##////     /////    ///       /// ///        ///   //          ///    ///     ////     //   //
##//////////////     ///////////   ///////////     //////     ///     ///     //  //   //   //



",linear,greedy,1007
"from collections import Counter

def solve(n, ribbons):
	L = len(ribbons[0])
	a = [Counter(r).most_common(1)[0][1] for r in ribbons]

	r = sorted([(x, i) for i, x in enumerate(a)], reverse=True)

	if n == 1:
		c = Counter(a)
		if c[L - 1] == 1:
			for i in range(3):
				if a[i] == L - 1: return i
		if c[L - 1] > 1:
			return 3
		if c[L] + c[L - 2] == 1:
			for i in range(3):
				if a[i] == L or a[i] == L-2:
					return i
		if c[L] + c[L - 2] > 1:
			return 3

	if r[1][0] == r[0][0]:
		return 3
	if r[1][0] + n >= L:
		return 3
	return r[0][1]

	print(a)

def main():
	n = int(input())
	cats = ('Kuro', 'Shiro', 'Katie', 'Draw')

	ribbons = [input().strip() for _ in range(3)]

	# print(ribbons)
	k = solve(n, ribbons)
	print(cats[k])

if __name__ == '__main__':
	main()",linear,greedy,774
"n,k=list(map(int,input().split()))

if k%2==0:
    s="".""
    s=s+""#""*(k//2)
    s=s+"".""*(n-len(s))
    print(""YES"")
    print("".""*n)
    print(s)
    print(s)
    print("".""*n)

else:
    if k<=n-2:
        a=""#""*k
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print(s)
        print("".""*n)
        print("".""*n)
    else:
        k=k-n+3
        a=""#""*k
        s="".""*((n-k)//2)+a+"".""*((n-k)//2)
        print(""YES"")
        print("".""*n)
        print("".""+""#""*(n-2)+""."")
        s=list(s)
        s[n//2]="".""
        s="""".join(s)
        print(s)
        print("".""*n)",linear,constructive algorithms,612
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 


alphabets = list('abcdefghijklmnopqrstuvwxyz')


def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []
    
    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)
        
    return powerset_orderred
def fastPlrintNextLines(a):
    # 12
    # 3
    # 1
    #like this
    #a is list of strings
    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
# else:
#     input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


def solve():
    n,k = li()
    l = [['.' for i in range(n)] for j in range(4)]
    print(""YES"")
    if k%2==0:
        for i in range(1,k//2+1):
            l[1][i]='#'
            l[2][i]='#'
    else:
        if (k>n-2):
            
            for i in range(1,n-1):
                l[1][i]='#'
            k-=(n-2)
        if k>0:
            i = n//2
            if k%2==1:
                l[2][i]='#'
                k-=1
            i = n//2+1
            for i in range(n//2+1,n//2+1+k//2):
                l[2][i]='#'
            k = k//2
            for i in range(n//2-1,-1,-1):
                if k==0:
                    break
                k-=1
                l[2][i]='#'
    for i in l:
        print(''.join(i))


t = 1
# t = int(input())
for _ in range(t):
    solve()
    
",linear,constructive algorithms,3689
"n,k=map(int,input().split())
if(k%2==0):
    print(""YES"")
    print('.'*n)
    print('.'+'#'*(k//2)+'.'*(n-1-k//2))
    print('.'+'#'*(k//2)+'.'*(n-1-k//2))
    print('.'*n)
else:
    print(""YES"")
    print('.'*n)
    if(k<=n-2):
        print('.'*((n-k)//2)+'#'*k+'.'*((n-k)//2))
        print('.'*n)
    else:
        print('.'+'#'*(n-2)+'.')
        print('.'+'#'*((k-n+2)//2)+'.'*(n-2-k+n-2)+'#'*((k-n+2)//2)+'.')
    print('.'*n)
",linear,constructive algorithms,435
"from sys import stdin

n, k = map(int, stdin.readline().split())
out = [['.'] * n for _ in range(4)]
if k & 1:
    out[1][n >> 1] = '#'
    k -= 1

for i in range(1, 3):
    l, r = 1, n - 2
    for j in range(1, n - 2):
        if k:
            k -= 1
            if j & 1:
                out[i][l] = '#'
                l += 1
            else:
                out[i][r] = '#'
                r -= 1

for i in range(1, 3):
    if k:
        k -= 1
        out[i][n >> 1] = '#'
print('YES\n%s' % ('\n'.join([''.join(x) for x in out])))
",linear,constructive algorithms,538
"n,k=map(int,input().split())
s=[["".""]*n for i in range(4)]
if k%2==0:
  for j in range(1,n-1):
    if k==0:
      break
    s[1][j]=""#""
    s[2][j]=""#""
    k-=2
else:
  cen=n//2
  s[1][cen]=""#""
  k-=1
  for i in range(1,3):
    for j in range(1,cen):
      if k>0:
        k-=2
        s[i][j]=s[i][-j-1]=""#""
if k==0:
  print(""YES"")
  for i in range(4):
    print("""".join(s[i]))
else:
  print(""NO"")",linear,constructive algorithms,398
"def solution(n, k):
    ret = [['.' for _ in range(n)] for _ in range(4)]
    if 1 == k & 1:
        ret[1][n >> 1] = '#'
        for i in range(1, n >> 1):
            if k < 2:
                break
            k -= 2
            ret[1][i] = '#'
            ret[1][n - 1 - i] = '#'
        for i in range(1, n >> 1):
            if k < 2:
                break
            k -= 2
            ret[2][i] = '#'
            ret[2][n - 1 - i] = '#'
    else:
        for i in range(1, n - 1):
            if k < 2:
                break
            k -= 2
            ret[1][i] = '#'
            ret[2][i] = '#'


    print('YES')
    for i in range(4):
        print(''.join(ret[i]))


solution(*map(int, input().split()))
",linear,constructive algorithms,721
"n, k = map(int, input().split())
grid = [['.']*n for i in range(4)]
if k % 2 == 0:
    for i in range(k//2):
        grid[1][1+i], grid[2][1+i] = '#', '#'
else:
    m = n//2
    if k > n - 2:
        for i in range(1, n-1):
            grid[1][i] = '#'
        for i in range(1, (k-n+2)//2 + 1):
            grid[2][m+i], grid[2][m-i] = '#', '#'
    else:
        grid[1][m] = '#'
        if k > 1:
            for i in range(1, k//2 + 1):
                grid[1][m-i], grid[1][m+i] = '#', '#'
print('YES')
for i in grid:
    print(''.join(i))",linear,constructive algorithms,543
"def getIntList():
    return list(map(int, input().split()));
nbColumn, h=getIntList();
if (nbColumn-2)*2<h:
    print('NO')
else:
    print('YES')
    if h%2==0:
        print('.'*nbColumn);
        print('.'+'#'*(h//2)+'.'*(nbColumn-1-h//2));
        print('.'+'#'*(h//2)+'.'*(nbColumn-1-h//2));
        print('.'*nbColumn);
    else:
        print('.'*nbColumn);
        hFirst=min(h, nbColumn-2);
        countPoint=(nbColumn-hFirst)//2;
        print('.'*countPoint+'#'*hFirst+'.'*countPoint);
        hSecond=(h-hFirst)//2;
        countPoint=nbColumn-2*hSecond-2;
        print('.'+'#'*hSecond+'.'*countPoint+'#'*hSecond+'.');
        print('.'*nbColumn);   ",linear,constructive algorithms,665
"n, k = map(int, input().split())
print(""YES"")
for i in range(n):
    print(""."", end = '')
print()
if k&1:
    if k <= n-2:
        tmp = (n-k)>>1
        for i in range(tmp):
            print(""."", end = '')
        for i in range(k):
            print(""#"", end = '')
        for i in range(tmp):
            print(""."", end = '')
        print()
        for i in range(n):
            print(""."", end = '')
        print()
    else:
        print(""."", end = '')
        for i in range(n-2):
            print(""#"", end = '')
        print(""."")
        k -= n-2
        print(""."", end = '')
        for i in range(k>>1):
            print(""#"", end = '')
        for i in range(n-k-2):
            print(""."", end = '')
        for i in range(k>>1):
            print(""#"", end = '')
        print(""."")
else:
    k = k>>1
    for j in range(2):
        print(""."", end = '')
        for i in range(k):
            print(""#"", end = '')
        for i in range(n-k-1):
            print(""."", end = '')
        print()
for i in range(n):
    print(""."", end = '')
print()

",linear,constructive algorithms,1061
"s = input()
while s!="""":
	if s==s[::-1]:
		s=s[:(len(s)-1)]
	else:
		break
print(len(s))",linear,"brute force,implementation,strings",88
"#!/usr/bin/python3
#Antipalindrome
s=input()
for i in range(len(s),0,-1):
    if s[:i]!=s[i-1::-1]:
        print(i)
        break
else:
    print(0)
",linear,"brute force,implementation,strings",150
"def palin(s):
    global ans
    if (s[::-1] != s or len(s) == 0):
        return len(s)
    else:
        return palin(s[1:])
s = input()
print(palin(s))",linear,"brute force,implementation,strings",154
"s = input()

def palindrome(s):
    i=0
    j=len(s)-1
    p=True
    while i<=j:
        if s[i]!=s[j]:
            p=False
            break
        i+=1
        j-=1
    return p

ans=0
for i in range(len(s)):
    for j in range(len(s)-1, i,-1):
        if not palindrome(s[i:j+1]):
            ans=max(ans, len(s[i:j+1]))
            break

print(ans)






",linear,"brute force,implementation,strings",362
"s = input()
n = len(s)
Ans = 0
for i in range(n):
    for j in range(i + 1, n):
        L = i
        R = j
        while L < R and s[L] == s[R]:
            L += 1
            R -= 1
        if L < R and Ans < j - i + 1:
            Ans = j - i + 1
print(Ans)
",linear,"brute force,implementation,strings",261
"s = input()
def is_pal(s):
      if s == s[::-1]:
            return True
      else:
            return False
if not is_pal(s):
      print(len(s))
else:
      not_eq = False
      for i in range(len(s)-1):
            if s[i] != s[i+1]:
                  print(len(s)-1)
                  not_eq = True
                  break
      if not not_eq:
            print(0)",linear,"brute force,implementation,strings",370
"s=input()
c=c1=0
for i in range(len(s)//2):
    if s[i]==s[len(s)-i-1]:
        c+=1
for i in range(len(s)):
    if s[i]==s[0]:
        c1+=1
if c1==len(s):
    print(0)
elif c==len(s)//2:
    print(len(s)-1)
else:
    print(len(s))",linear,"brute force,implementation,strings",232
"s=input()
while(len(s)>0):
    if s!=s[::-1]:
        break
    else:
        s=s[1:]
print(len(s))",linear,"brute force,implementation,strings",99
"
s=input()


while(1):
        if(len(s)==1):
                print(0)
                break
            
        elif(s==s[::-1]):
            
            s=s[1:]
        
        
        
        else:
            print(len(s))
            break",linear,"brute force,implementation,strings",249
"from collections import deque
import sys
input = sys.stdin.readline
# sys.setrecursionlimit(10**5)
def bfs(start,graph,explored):
    queue = deque([start])
    visited = {start}
    ele = 0
    while queue:
        node = queue.popleft()
        explored.add(node)
        neighbours = graph[node]
        cnt = 0
        for neighbour in neighbours:
            if neighbour not in visited and neighbour not in explored:
                cnt += 1

        if e[0] == 0 and cnt != 1:
            ele = node
            break

        else:
            for neighbour in neighbours:
                if neighbour not in visited:
                    queue.append(neighbour)
                    visited.add(neighbour)

    return ele

from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc


@bootstrap
def solve(i):
    cnt = 0
    visited.add(i)
    for k in graph[i]:
        if k not in visited:
            cnt += 1

    if cnt >= 1:
        for k in graph[i]:
            if k not in visited:
                yield solve(k)
                break

    else:
        r[0] = i

    yield

n = int(input())
graph = {}
for _ in range(n-1):
    a,b = map(int,input().split())
    if a in graph:
        graph[a].append(b)

    else:
        graph[a] = [b]

    if b in graph:
        graph[b].append(a)

    else:
        graph[b] = [a]

roots = []
visited = set()
ele = 0
e = [ele]
for i in graph:
    if len(graph[i]) == 1:
        roots.append(i)

x = roots[0]
ans = []
ele = bfs(x,graph,visited)
ans.append((str(x),str(ele)))
# r = [0]
for i in graph[ele]:
    r = [0]
    if i not in visited:
        y = solve(i)
        ans.append([str(r[0]),str(ele)])

if len(visited) == n:
    sys.stdout.write(""Yes\n"")
    q = str(len(ans))
    sys.stdout.write(q+""\n"")
    for i in ans:
        e = "" "".join(i)
        sys.stdout.write(e + ""\n"")

else:
    sys.stdout.write(""No\n"")",linear,"implementation,trees",2369
"a = int(input())
s = {}
ans = 0
for i in range(a - 1):
    v, c = map(int, input().split())
    if v in s:
        s[v].append(c)
    else:
        s[v] = [c]
    if c in s:
        s[c].append(v)
    else:
        s[c] = [v]
c = 0
for i in range(1, a + 1):
    if len(s[i]) > 2:
        c += 1
        ans = i
if c > 1:
    print(""No"")
elif c == 0:
    print(""Yes"")
    print(1)
    for i in s:
        if len(s[i]) == 1:
            print(i, end="" "")
else:
    print(""Yes"")
    print(len(s[ans]))
    k = []
    for i in s:
        if len(s[i]) == 1:
            k.append(i)
    for i in k:
        print(min(ans, i), max(ans, i))
",linear,"implementation,trees",633
"import os, sys
from io import BytesIO, IOBase


def main():
    n = rint()
    deg, edges = [0] * n, rints_2d(n - 1)
    for u, v in edges:
        deg[u - 1] += 1
        deg[v - 1] += 1

    coun = [0, deg.count(1), deg.count(2)]

    if n - coun[1] == 1:
        print(f'Yes\n{n - 1}')
        [print(*x) for x in edges]

    elif coun[1] + coun[2] == n:
        print(f'Yes\n1\n{deg.index(1) + 1} {n - deg[::-1].index(1)}')

    elif n - sum(coun) == 1:
        for i in range(n):
            if deg[i] > 2:
                print(f'Yes\n{deg[i]}')
                for j in range(n):
                    if deg[j] == 1:
                        print(i + 1, j + 1)
                exit()
    else:
        print('No')


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",linear,"implementation,trees",2750
"import os, sys
from io import BytesIO, IOBase


def main():
    n = rint()
    deg, edges = [0] * n, rints_2d(n - 1)
    if n == 2:
        exit(print(f'Yes\n1\n1 2'))

    for u, v in edges:
        deg[u - 1] += 1
        deg[v - 1] += 1

    ix = deg.index(max(deg))

    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:
        print(f'Yes\n{deg.count(1)}')

        for i in range(n):
            if deg[i] == 1:
                print(i + 1, ix + 1)
    else:
        print('No')


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",linear,"implementation,trees",2522
"import os, sys
from io import BytesIO, IOBase


def main():
    n = rint()
    deg = [0] * n
    if n == 2:
        exit(print(f'Yes\n1\n1 2'))

    for i in range(n - 1):
        u, v = rints()
        deg[u - 1] += 1
        deg[v - 1] += 1

    ix = deg.index(max(deg))

    if deg[ix] < 3 or deg.count(1) + deg.count(2) == n - 1:
        print(f'Yes\n{deg.count(1)}')

        for i in range(n):
            if deg[i] == 1:
                print(i + 1, ix + 1)
    else:
        print('No')


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [rstr() for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",linear,"implementation,trees",2525
"# Fast IO Region
import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
# Get out of main function
def main():
    pass
# decimal to binary
def binary(n):
    return (bin(n).replace(""0b"", """"))
# binary to decimal
def decimal(s):
    return (int(s, 2))
# power of a number base 2
def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
# if  number is prime in √n time
def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
# list to string ,no spaces
def lts(l):
    s = ''.join(map(str, l))
    return s
# String to list
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# Sieve for prime numbers in a range
def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1
            # print(p)
    return (cnt)
# for positive integerse only
def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)
# 1000000007
mod = int(1e9) + 7
import math
#import random
#import bisect
#from fractions import Fraction
#from collections import OrderedDict
#from collections import deque
########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################
########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################
########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################
########################                         from collections import deque                              ########################
########################                         ASCII of A-Z= 65-90                                        ########################
########################                         ASCII of a-z= 97-122                                       ########################
########################                         d1.setdefault(key, []).append(value)                       ########################
#sys.setrecursionlimit(300000)          #Gives memory limit exceeded if used a lot
#for ___ in range(int(input())):
def deep(node):
    visited[node-1]=1
    if(len(d[node])==1):
        return node
    for c in d[node]:
        if(visited[c-1]!=1):
            return(deep(c))

n=int(input())
d={}
for i in range(n-1):
    u,v=map(int,input().split())
    d.setdefault(u,[]).append(v)
    d.setdefault(v,[]).append(u)
node=1
for key in d:
    if(len(d[key])>len(d[node])):
        node=key
ans=[]
visited=[0]*n
visited[node-1]=1
for c in d[node]:
    while(True):
        visited[c-1]=1
        if(len(d[c])==1):
            ans.append([node,c])
            break
        for child in d[c]:
            if(visited[child-1]!=1):
                c=child
                break
if(sum(visited)==n):
    print(""Yes"")
    print(len(ans))
    for c in ans:
        print(*c)
else:
    print(""No"")























",linear,"implementation,trees",5415
"import sys
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))

n=iinput()
d={}
for i in range(n - 1):
    u,v=rinput()
    d.setdefault(u,[]).append(v)
    d.setdefault(v,[]).append(u)
node=1
for key in d:
    if(len(d[key])>len(d[node])):
        node=key
ans=[]
visited=[0]*n
visited[node-1]=1
for c in d[node]:
    while(True):
        visited[c-1]=1
        if(len(d[c])==1):
            ans.append([node,c])
            break
        for child in d[c]:
            if(visited[child-1]!=1):
                c=child
                break
if(sum(visited)==n):
    print(""Yes"")
    print(len(ans))
    for c in ans:
        print(*c)
else:
    print(""No"")",linear,"implementation,trees",839
"# Fast IO Region
import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
# Get out of main function
def main():
    pass
# decimal to binary
def binary(n):
    return (bin(n).replace(""0b"", """"))
# binary to decimal
def decimal(s):
    return (int(s, 2))
# power of a number base 2
def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
# if  number is prime in √n time
def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
# list to string ,no spaces
def lts(l):
    s = ''.join(map(str, l))
    return s
# String to list
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# Sieve for prime numbers in a range
def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1
            # print(p)
    return (cnt)
# for positive integerse only
def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)
# 1000000007
mod = int(1e9) + 7
import math
#import random
#import bisect
#from fractions import Fraction
#from collections import OrderedDict
#from collections import deque
########################                         mat=[[0 for i in range(n)] for j in range(m)]                      ########################
########################                         list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist            ########################
########################                         Speed: STRING < LIST < SET,DICTIONARY                      ########################
########################                         from collections import deque                              ########################
########################                         ASCII of A-Z= 65-90                                        ########################
########################                         ASCII of a-z= 97-122                                       ########################
########################                         d1.setdefault(key, []).append(value)                       ########################
#sys.setrecursionlimit(300000)          #Gives memory limit exceeded if used a lot
#for ___ in range(int(input())):
n=int(input())
d={}
for i in range(n-1):
    u,v=map(int,input().split())
    d.setdefault(u,[]).append(v)
    d.setdefault(v,[]).append(u)
node=1
for key in d:
    if(len(d[key])>len(d[node])):
        node=key
ans=[]
visited=[0]*n
visited[node-1]=1
for c in d[node]:
    while(True):
        visited[c-1]=1
        if(len(d[c])==1):
            ans.append([node,c])
            break
        for child in d[c]:
            if(visited[child-1]!=1):
                c=child
                break
if(sum(visited)==n):
    print(""Yes"")
    print(len(ans))
    for c in ans:
        print(*c)
else:
    print(""No"")",linear,"implementation,trees",5228
"# _
#####################################################################################################################

def main():
    nNodes = int(input())
    neighborsOf = {node: [] for node in map(str, range(1, nNodes+1))}
    threeNeighborNodeExists, threeNeighborNode = False, None
    for i in range(1, nNodes):
        node1, node2 = input().split()
        neighborsOf[node1].append(node2), neighborsOf[node2].append(node1)
        if len(neighborsOf[node1]) == 3:
            if threeNeighborNodeExists:
                return 'No'
            threeNeighborNodeExists, threeNeighborNode = True, node1
        elif len(neighborsOf[node2]) == 3:
            if threeNeighborNodeExists:
                return 'No'
            threeNeighborNodeExists, threeNeighborNode = True, node2

    if threeNeighborNodeExists:
        return tnnDecompositionFrom(neighborsOf, threeNeighborNode+' ')

    return decompositionFrom(neighborsOf)


def tnnDecompositionFrom(tree, threeNeighborNode):
    paths = tuple(threeNeighborNode + node for node in tree if len(tree[node]) == 1)
    return f'Yes\n{len(paths)}\n' + '\n'.join(paths)


def decompositionFrom(tree):
    return 'Yes\n1\n' + ' '.join(node for node in tree if len(tree[node]) == 1)


if __name__ == '__main__':
    print(main())
    # main()
",linear,"implementation,trees",1305
"n,m,a,b=[int(x) for x in input().split()]
if n>m:
	if n%m==0:
		print(0)
	else:
		t1=n%m
		print(min(t1*b,(m-t1)*a))
elif n==m:
	print(0)
else:
	print(min(n*b,(m-n)*a))",linear,"implementation,math",168
"n,m,a,b=map(int, input().split())
print(min(n%m*b, (m-n%m)*a))",linear,"implementation,math",62
"n,m,a,b=map(int,input().split())
z=(n%m)*b
x=((n//m+1)*m-n)*a
y=min(z,x)
print(y if y>0 else 0)",linear,"implementation,math",95
"n,m,a,b=[int(x)for x in input().split()]
if n<m:print(min(a*(m-n),b*n))
else:print(min(b*(n%m),a*(m-(n%m)) ))",linear,"implementation,math",109
"#Winners never quit, Quitters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping
from itertools import groupby as gb
from fractions import Fraction as fr

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#Winners never quit, Quitters never win
n,m,a,b=map(int,input().split())
if n%m:
    ul=(n//m)+1
    ll=n//m
    print(min(((ul*m)-n)*a, (n-(ll*m))*b))
else:
    print(0)
",linear,"implementation,math",2130
"
n,m,a,b = map(int,input().split())


if n%m==0:
    print(0)
else:
    k = n%m
    print(min(k*b,(m-k)*a))",linear,"implementation,math",107
"n,m,a,b = map(int,input().split())
if n%m!=0:
    mn = n//m * m
    mx = n//m * m + m
    print(min(((n - mn) * b),((mx - n) * a)))
else:print(0) ",linear,"implementation,math",146
"n, m, a, b = map(int, input().split())
print(min(n%m*b, (m-n%m)*a))
",linear,"implementation,math",68
"from sys import stdin
n, m, a, b = map(int, stdin.readline().split())
x = n%m
print(min(a *(m-x), b*x))",linear,"implementation,math",103
"inf=10**9

n=int(input())
t=[0]*n
m={}
for j in range(n):


    s=input()


    bal=0
    req=0

    for i in s:
        if i=="")"":
            bal-=1
        else:
            if bal<0:
                req+=bal
                bal=1
            else:
                bal+=1

    if req<0:
        if bal>0:
            req=inf
        else:
            req+=bal
    else:
        req=bal

    t[j]=req

    if req not in m:
        m[req]=1
    else:
        m[req]+=1

res=0

for i in t:
    if i>=0:
        if -i in m:
            res+=m[-i]

print(res)
",linear,implementation,558
"import sys
import io, os
input = sys.stdin.readline

n = int(input())
S = [str(input().rstrip()) for i in range(n)]
from collections import defaultdict
d1 = defaultdict(lambda: 0)
d2 = defaultdict(lambda: 0)
ans = 0
for i, s in enumerate(S):
    cum1 = 0
    flag1 = True
    for c in s:
        if c == '(':
            cum1 += 1
        else:
            cum1 -= 1
        if cum1 < 0:
            flag1 = False
    if flag1:
        ans += d2[cum1]
    cum2 = 0
    flag2 = True
    for i in reversed(range(len(s))):
        c = s[i]
        if c == ')':
            cum2 += 1
        else:
            cum2 -= 1
        if cum2 < 0:
            flag2 = False
    if flag2:
        ans += d1[cum2]
    if cum1 == 0 and cum2 == 0 and flag1 and flag2:
        ans += 1
    if flag1:
        d1[cum1] += 1
    if flag2:
        d2[cum2] += 1

print(ans)
",linear,implementation,854
"
op=[0]*1000000
cl=[0]*1000000
def fun(s):
    v = []
    for i in range(len(s)):
        l = len(v)
        if s[i]=='(':
            v.append(s[i])
        elif l>0 and v[l-1]=='(':
            v.pop()
        else :
            v.append(')')
    
    l = len(v)
    if  l==0:
        op[0]+=1
        cl[0]+=1
    elif v[0]==v[l-1]:
        if  v[0]=='(':
            op[l]+=1
        else :
            cl[l]+=1

t = int ( input() )
while t>0:
    t-=1
    s = str ( input() )
    fun(s)
ans = 0
for i in range(1000000):
    ans+=(op[i] * cl[i])

print(ans)",linear,implementation,561
"def main():
    c,r,o,e=0,0,[0]*300000,[0]*300000
    for _ in range(int(input())):
        s=input()
        l,n=0,0
        for i in s:
            if i=='(':
                l+=1
            else:
                if l!=0:
                    l-=1
                else:
                    n+=1
        if l==0 and n==0:
            c+=1
        elif l!=0 and n!=0:
            pass
        elif l!=0:
            o[l]+=1
        else:
            e[n]+=1
    for i in range(300000):
        if e[i] and o[i]:
            r+=e[i]*o[i]
    print(pow(c,2)+r)
if __name__=='__main__':
    main()",linear,implementation,594
"from sys import  stdin 
input=stdin.readline
from  collections import defaultdict
def num(s):
    l,r=0,0
    for i in s:
        if l==0 and i=="")"":
            r+=1
        elif i==""("":
            l+=1
        elif l and i=="")"":
            l-=1
    return (l,r)

def f(mp,cnt):
    ans=0
    # print(mp,cnt)
    for l in cnt:
        # print(mp,ans)
        if l.count(0)<1:
            continue
        if l!=(0,0) and l==l[::-1]:
            continue
        # print(""l hai"",l)
        t=mp[l[::-1]]
        t2=mp[l[::-1]]
        ans+=t
        if t and l!=l[::-1]:
            mp[l]-=1
    return ans

cnt=[]
mp=defaultdict(int)
for i in range(int(input())):
    s=input()
    l=num(s)
    # print(l,s)
    cnt.append(l)
    mp[l]+=1
print(f(mp,cnt))",linear,implementation,758
"from sys import  stdin
input=stdin.readline
from  collections import defaultdict
def num(s):
    l,r=0,0
    for i in s:
        if l==0 and i=="")"":
            r+=1
        elif i==""("":
            l+=1
        elif l and i=="")"":
            l-=1
    return (l,r)

def f(mp,cnt):
    ans=0
    for l in cnt:
        if l.count(0)<1:
            continue
        t=mp[l[::-1]]
        ans+=t
        if t and l!=l[::-1]:
            mp[l]-=1
    return ans

cnt=[]
mp=defaultdict(int)
for i in range(int(input())):
    s=input()
    l=num(s)
    cnt.append(l)
    mp[l]+=1
print(f(mp,cnt))",linear,implementation,589
"from collections import defaultdict
from sys import stdin

all_in = stdin.read().splitlines()

n = int(all_in[0])
s = all_in[1:]

one = defaultdict(lambda: 0)
two = defaultdict(lambda: 0)

for el in s:
    I = 0
    min_ = 0

    for char in el:
        I += {'(': 1, ')': -1}[char]
        min_ = min(min_, I)

    if I >= 0 and min_ == 0:
        one[I] += 1

    if I <= 0 and min_ == I:
        two[I] += 1

ans = 0
for el in one.keys():
    ans += one[el] * two[-el]

print(ans)
",linear,implementation,484
"n = int(input())

from collections import defaultdict

first = defaultdict(int)
second = defaultdict(int)
for _ in range(n):
    s = input().strip()
    count = 0
    min_count = 0
    for c in s:
        if c == '(': count += 1
        else: count -= 1
        min_count = min(count, min_count)
    if min_count >= 0: first[count] += 1
    if count == min_count: second[count] += 1

res = 0
for k, v in first.items():
    res += v * second[-k]

print(res)
",linear,implementation,457
"n = int(input())
a = list(map(int, input().strip().split()))

b = set(a)
res = len(b)
if 0 in b:
    res -= 1
print(res)
",linear,"implementation,sortings",121
"# A. Nastya and an Array

n = int(input())
a = set(map(int, input().split()))

ans = len(a) - 1 if 0 in a else len(a)
print(ans)
",linear,"implementation,sortings",129
"n = int(input())
a = list(map(int, input().split()))
d = set(a)
if (0 in a): 
    print(len(d)-1)
else:
    print(len(d))",linear,"implementation,sortings",121
"n=int(input())
a=list(map(int,input().split()))
c=0
po=[0]*1000000
ne=[0]*1000000
for i in range(n):
    if(a[i]<0 and ne[a[i]]!=1):
        c+=1
        ne[a[i]]=1
    elif(a[i]>0 and po[a[i]]!=1):
        c+=1
        po[a[i]]=1
print(c)",linear,"implementation,sortings",239
"n=int(input())
l=[int(i) for i in input().split()]
s=set(l)
if 0 in s:
    print(len(s)-1)
else:
    print(len(s))",linear,"implementation,sortings",114
"n=int(input())
l=list(map(int,input().split()))
s=set(l)
x=0
if x in s:
    print(len(s)-1)
else:
    print(len(s))",linear,"implementation,sortings",115
"n = int(input())
a = list(map(int, input().split()))
s = set(a)
s.discard(0)
print(len(s))
",linear,"implementation,sortings",91
"n=int(input())
l1=list(map(int,input().split()))
if len(list(set(l1)))==1 and l1[0]>0:
    print(1)
else:
    l2=list(set(l1))
    x=l1.count(0)
    if x==0:
        print(len(l2))
    else:
        print(len(l2)-1)
    ",linear,"implementation,sortings",220
"n, = map(int,input().split())
arr = set(map(int,input().split()))
print(len(arr)-(0 in arr))
",linear,"implementation,sortings",93
"n=int(input())
a=list(map(int,input().split()))
b=[0]*n
for i in range(n):
    if(i+1>a[i]):
        b[i]=i+1
    else:
        q=(a[i]-(i+1)+n)//n
        b[i]=i+1 + q*n
print(b.index(min(b))+1)",linear,"binary search,math",195
"from math import ceil
def main():
    n=int(input())
    a=list(map(int,input().split( )))
    ans=10**6
    value=10**9+7
    for i in range(n):
        t=ceil((a[i]-i)/n)
        tmp=i+n*t
        if tmp<value:
            value=tmp
            ans=i+1
    print(ans)
main()",linear,"binary search,math",276
"a=int(input())
z=list(map(int,input().split()))
ans=[]
k=len(z)
for i in range(len(z)):
    if((z[i]-i)%len(z)==0):
        ans.append((z[i]-i)//k)
    else:
        ans.append((z[i]-i)//k)
        ans[-1]+=1
t=min(ans)
print(ans.index(t)+1)
",linear,"binary search,math",242
"from sys import stdin,stdout
from math import ceil
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):#nmbr()):
    n=nmbr()
    a=lst()
    p=0
    ans=float('inf')
    for i in range(n):
        turns=ceil((a[i]-i)/n)
        if turns<ans:
            ans=turns
            p=i
    print(p+1)",linear,"binary search,math",353
"num = int(input())
layne = input()
layne = layne.split()
layne = [int(i) for i in layne]
mx = max(layne)
dorf = mx * 2 * num
indx = 1
for i in range(num):
    dor = (layne[i] // num) * num
    if (layne[i] % num) - i > 0:
        dor = dor + num + i + 1
    else:
        dor = dor + i + 1
    if dor < dorf:
        dorf = dor
        indx = i + 1
print(indx)",linear,"binary search,math",360
"import math

n = int(input())
a = list(map(lambda x : int(x), input().split()))
q = len(a)

earliest_time = pow(10, 9) + 1000
earliest_queue = 1
for i in range(q):
    n = int(max(0, math.ceil((a[i] + 1 - (i + 1)) / q)))
    t = (i + 1) + n * q
    if t < earliest_time:
        earliest_time = t
        earliest_queue = i + 1

print(earliest_queue)
",linear,"binary search,math",351
"n = int(input())
arr = list(map(int, input().split()))

for i in range(n):
    arr[i] = (arr[i]-i)//n + (1 if (arr[i]-i)%n>0 else 0)
print(arr.index(min(arr))+1)
",linear,"binary search,math",162
"import math

n=int(input())
a=list(map(int ,input().split()))
x=10**9+2
y=0
for i in range(n):
    if(x>math.ceil((a[i]-i)/n)*n+i+1):
        x=math.ceil((a[i]-i)/n)*n+i+1
        y=i+1
print(y)",linear,"binary search,math",194
"n = int(input())
a = list(map(int, input().strip().split()))

amin = min(a)
for i in range(n):
    a[i] -= amin
ans = amin % n
cnt = 0
while True:
    if a[ans] <= cnt:
        break
    ans = (ans + 1) % n
    cnt += 1
print(ans + 1)

",linear,"binary search,math",236
"from collections import defaultdict
import sys
import bisect
input=sys.stdin.readline

n,m=map(int,input().split())
a=[int(i) for i in input().split()if i!='\n']
rem=[[] for i in range(m)]
req=n//m
ans=0
for i in range(n):
    rem[a[i]%m].append([a[i],i])
ind=m-1
for i in range(m):
    size=len(rem[i])
    if size>req:
        ind=i
    if size<req:
        ok=False
        for j in range(ind,-1,-1):
            while len(rem[j])>req:
                pop,_=rem[j].pop()
                rem[i].append([pop+(i-j)%m,_])
                if len(rem[i])==req:
                    ok=True
                    break
            if ok:
                break
            ind-=1
        else:
            ind=m-1
            for j in range(ind,-1,-1):
                while len(rem[j])>req:
                    pop,_=rem[j].pop()
                    rem[i].append([pop+(i-j)%m,_])
                    if len(rem[i])==req:
                        ok=True
                        break
                if ok:
                    break
                ind-=1
            
out=[0]*(n)
for i in rem:
    for j in i:
        out[j[1]]=j[0]
print(sum(out)-sum(a))
out=' '.join(map(str,out))
print(out)
                    
                
    
        
        
    
        
    
    
",linear,"data structures,greedy,implementation",1273
"from collections import defaultdict
import sys
import bisect
input=sys.stdin.readline

n,m=map(int,input().split())
a=[int(i) for i in input().split()if i!='\n']
rem=[[] for i in range(m)]
req=n//m
ans=0
for i in range(n):
    rem[a[i]%m].append([a[i],i])
ind=m-1
for i in range(m):
    size=len(rem[i])
    if size>req:
        ind=i
    if size<req:
        ok=False
        for j in range(ind,ind-m,-1):
            while len(rem[j])>req:
                pop,_=rem[j].pop()
                rem[i].append([pop+(i-j)%m,_])
                if len(rem[i])==req:
                    ok=True
                    break
            if ok:
                break
            ind-=1
            
out=[0]*(n)
for i in rem:
    for j in i:
        out[j[1]]=j[0]
print(sum(out)-sum(a))
out=' '.join(map(str,out))
print(out)
                    
                
    
        
        
    
        
    
    
",linear,"data structures,greedy,implementation",899
"
from sys import stdin
input = stdin.buffer.readline

n,m=map(int,input().split())
arr=[int(x) for x in input().split()]

dp=[[] for i in range(m)]
for i in range(n):
    dp[arr[i]%m].append(i)

res=0
k=n//m
ans=arr.copy()
s=[]
for t in range(2):
    for i in range(m):
        if len(dp[i])<k:
            while len(s)!=0 and len(dp[i])<k:
                x=s.pop()
                y=arr[x]%m
                if i>y:
                    ans[x]=ans[x]+(i-y)
                    res=res+(i-y)
                else:
                    ans[x]=ans[x]+(m-1-y)+(i+1)
                    res=res+(m-1-y)+(i+1)    
                dp[i].append(""xxx"")
        if len(dp[i])>k:
            while len(dp[i])>k:
                s.append(dp[i].pop())   

print(res)
print(*ans)",linear,"data structures,greedy,implementation",765
"n,m=map(int, input().split())
a=list(map(int, input().split()))
t=n//m
remain=[[] for i in range(m)]
for i in range(n):
    x=a[i]%m
    remain[x].append(i)
ans=0
f=[]
for i in range(2*m):
    cur=i%m
    while len(remain[cur])>t:
        elm=remain[cur].pop()
        f.append([elm,i])
    while len(remain[cur])<t and len(f)!=0:
        elm,j=f.pop()
        remain[cur].append(elm)
        a[elm]+=abs(i-j)
        ans+=abs(i-j)
print(ans)
print(*a)
",linear,"data structures,greedy,implementation",453
"#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(200001)] 
pp=[0]*200001
def SieveOfEratosthenes(n=200000): 
      
    # Create a boolean array ""prime[0..n]"" and initialize 
    #  all entries it as true. A value in prime[i] will 
    # finally be false if i is Not a prime, else true. 
    
    p = 2
    while (p * p <= n): 
          
        # If prime[p] is not changed, then it is a prime 
        if (prime[p] == True): 
              
            # Update all multiples of p 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
#---------------------------------running code------------------------------------------
n,m=map(int, input().split())
a=list(map(int, input().split()))
t=n//m
remain=[[] for i in range(m)]
for i in range(n):
    x=a[i]%m
    remain[x].append(i)
ans=0
f=[]
for i in range(2*m):
    cur=i%m
    while len(remain[cur])>t:
        elm=remain[cur].pop()
        f.append([elm,i])
    while len(remain[cur])<t and len(f)!=0:
        elm,j=f.pop()
        remain[cur].append(elm)
        a[elm]+=abs(i-j)
        ans+=abs(i-j)
print(ans)
print(*a)
",linear,"data structures,greedy,implementation",8843
"# n, m = map(int, input().split())
#
# arr = [int(z) for z in input().split()]
# modvals = []
#
# for i in range(n):
#     modvals.append([arr[i] % m, i])
#
# modvals.sort()
#
# rem = {}
# used = {}
#
# for i in range(m):
#     rem[i] = 0
#     used[i] = 0
#
# for i in modvals:
#     rem[i[0]] += 1
#
# # print(rem)
# cnt = 0
#
# mm1rec = []
#
# for i in range(n):
#     elem = modvals[i]
#
#     if used[elem[0]] < n//m:
#         used[elem[0]] += 1
#     else:
#         if elem[0] != m-1:
#             used[elem[0]+1] += 1
#             arr[elem[1]] += 1
#             cnt += 1
#         else:
#             used[m - 1] += 1
#             mm1rec.append(elem[1])
#
#
# if used[m-1] > n//m:
#     for i in range(m-1):
#         elem = [i, 0]
#         while used[i] < n//m:
#             # arr[elem[1]] += abs(elem[0] + 1)
#             used[i] += 1
#             used[m - 1] -= 1
#             arr[mm1rec[-1]] += abs(i + 1)
#             mm1rec.pop()
#             cnt += abs(i + 1)
#
#
# print(cnt)
#
# arrstr = [str(z) for z in arr]
#
# print(' '.join(arrstr))
#
# #print(used, mm1rec)
#
#
#
#

from collections import deque

n, m = map(int, input().split())

arr = [int(z) for z in input().split()]

mods = [0 for i in range(m)]
placement = [[] for i in range(m)]

# for i in arr:
#     mods[i % m] += 1
#
# for i in range(m):
#     mods[i] -= n//m

for i in range(n):
    mods[arr[i] % m] += 1
    placement[arr[i] % m].append(i)

cnt = 0
queue = deque()
target = n//m
for i in range(2*m):
    mod = i % m
    if mods[mod] > n//m:
        # cnt += mods[mod] - target
        for c in range(mods[mod] - target):
            queue.append([i, placement[mod][c]])
        mods[mod] = target

    elif mods[mod] < target:
        while len(queue) > 0 and mods[mod] < target:
            elem, indice = queue.popleft()
            mods[mod] += 1
            cnt += (mod - elem) % m
            arr[indice] += (mod - elem) % m

print(cnt)
print(' '.join([str(i) for i in arr]))








",linear,"data structures,greedy,implementation",1987
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]


z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())


def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)


dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --If you Know some-one , Then you probably don't know him !

    --Try & again try

""""""
##################################################---START-CODING---###############################################



n, m = zz()
arr = zzz()
s = sum(arr)
x = [[] for i in range(m)]
for i in range(n): x[arr[i] % m].append(i)
j = 0
for i in range(m):
    while len(x[i]) > n // m:
        while j < i or len(x[j % m]) >= n // m: j += 1
        k = x[i].pop()
        arr[k] += (j - i) % m
        x[j % m].append(k)
print(sum(arr) - s)
print(*arr)
",linear,"data structures,greedy,implementation",3099
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]


z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())


def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)


dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --If you Know some-one , Then you probably don't know him !

    --Try & again try

""""""
##################################################---START-CODING---###############################################


n,m=zzz()
arr = zzz()
s = sum(arr)
idx = [[] for i in range(m)]
for i in range(n):
    idx[arr[i]%m].append(i)
j=0
for i in range(m):
    while len(idx[i])>n//m:
        while j<i or len(idx[j%m])>=n//m:j+=1
        last = idx[i].pop()
        arr[last]+=(j-i)%m
        idx[j%m].append(last)
print(sum(arr)-s)
print(*arr)


",linear,"data structures,greedy,implementation",3094
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]


z, zz = fast, lambda: (map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())


def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer, end='\n'): stdout.write(str(answer) + end)


dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --If you Know some-one , Then you probably don't know him !

    --Try & again try

""""""
##################################################---START-CODING---###############################################


n,m=zzz()
arr = zzz()
s = sum(arr)
idx = [[] for i in range(m)]
for i in range(n):
    idx[arr[i]%m].append(i)

j=0
for i in range(m):
    while len(idx[i])>n//m:
        while True:
            if j<i:j+=1
            elif len(idx[j%m])>=n//m:
                j+=1
            else:break
        last = idx[i].pop()
        arr[last]+=(j-i)%m
        idx[j%m].append(last)
print(sum(arr)-s)
print(*arr)


",linear,"data structures,greedy,implementation",3175
"import sys, heapq

n = int(sys.stdin.readline())
key = []
for i in ['S', 'M', 'L']:
    for j in range(4):
        key.append(j * 'X' + i)
prev = dict().fromkeys(key, 0)
now = dict().fromkeys(key, 0)
for _ in range(n):
    prev[sys.stdin.readline().rstrip()] += 1
for _ in range(n):
    now[sys.stdin.readline().rstrip()] += 1
for i in key:
    temp = min(prev[i], now[i])
    prev[i] -= temp
    now[i] -= temp
ans = 0
for i in key:
    ans += now[i]
print(ans)

",linear,"greedy,implementation",464
"n=int(input())
a=b=[]
k=0
for _ in range(n): 
	a.append(input())
for i in range(n):
	t=input()
	if t in a:
		a.remove(t)
print(len(a))",linear,"greedy,implementation",134
"n=int(input())
l1=[]
l2=[]
for _ in range(n):
    l1.append(input())
for _ in range(n):
    l2.append(input())
c=0
for i in range(n):
    if(l1[i]  in l2):
        l2.remove(l1[i])
    else:
        c+=1
#print(l1,l2)
print(c)
        
        

    ",linear,"greedy,implementation",250
"n = int(input())
 
a = [input() for _ in range(n)]
b = [input() for _ in range(n)]
 
cost = 0
for s in [""M"", ""S"", ""XS"", ""XXS"", ""XXXS"", ""L"", ""XL"", ""XXL"", ""XXXL""]:
    ca = a.count(s)
    cb = b.count(s)
    cost += ca - min(ca, cb)
    
print(cost)",linear,"greedy,implementation",247
"def solve():
    n = int(input())
    a_dicts = [{}, {}]
    for j in range(2):
        for i in range(n):
            x = input()
            if x in a_dicts[j]:
                a_dicts[j][x] += 1
            else:
                a_dicts[j][x] = 1
            if x not in a_dicts[1 - j]:
                a_dicts[1 - j][x] = 0
    c = 0
    for k in a_dicts[0]:
        c += abs(a_dicts[0][k] - a_dicts[1][k])
    return c // 2

print(solve())",linear,"greedy,implementation",444
"x = int(input())
list1 = []
for i in range(x):
    value = input()
    list1.append(value)

for i in range(x):
    value = input()
    if value in list1:
        list1.remove(value)

print(len(list1))

",linear,"greedy,implementation",202
"from collections import Counter

n = int(input())
a = Counter()
b = Counter()
for _ in range(n):    
    a[input().strip()] += 1
for _ in range(n):
    b[input().strip()] += 1
ans = 0
for key in b:
    ans += max(b[key] - a[key], 0)
# print(a)
# print(b)
print(ans)",linear,"greedy,implementation",265
"import sys, os.path
if(os.path.exists('input.txt')):
	sys.stdin = open(""input.txt"",""r"")
	

t = int(input())
last = []
current = []

for i in range(t):
	last.append(str(input()))
for i in range(t):
	current.append(str(input()))

for i in range(len(last)):
	if last[i] in current:
		current[current.index(last[i])] = ""*""
		last[i] = ""*""

last.sort()
current.sort()

total = 0
for i in range(len(last)):
	if last[i] == current[i]:
		continue
	else:
		total+=1
	
print(total)


",linear,"greedy,implementation",474
"#winners never quit, quiters never win
from collections import deque as de
import math
from collections import Counter as cnt
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
# A optimized school method based 
# Python3 program to check 
# if a number is prime 


def isPrime(n) : 

	# Corner cases 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	# This is checked so that we can skip 
	# middle five numbers in below loop 
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    # create an empty list and later I will
    # run a for loop with range() function using the append() method to add elements to the list.
    prime_factors = []

    # First get the number of two's that divide number
    # i.e the number of 2's that are in the factors
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2

    # After the above while loop, when number has been
    # divided by all the 2's - so the number must be odd at this point
    # Otherwise it would be perfectly divisible by 2 another time
    # so now that its odd I can skip 2 ( i = i + 2) for each increment
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i


    # Here is the crucial part.
    # First quick refreshment on the two key mathematical conjectures of Prime factorization of any non-Prime number
    # Which is - 1. If n is not a prime number AT-LEAST one Prime factor would be less than sqrt(n)
    # And - 2. If n is not a prime number - There can be AT-MOST 1 prime factor of n greater than sqrt(n).
    # Like 7 is a prime-factor for 14 which is greater than sqrt(14)
    # But if the above loop DOES NOT go beyond square root of the initial n.
    # Then how does that greater than sqrt(n) prime-factor
    # will be captured in my prime factorization function.
    # ANS to that is - in my first for-loop I am dividing n with the prime number if that prime is a factor of n.
    # Meaning, after this first for-loop gets executed completely, the adjusted initial n should become
    # either 1 or greater than 1
    # And if n has NOT become 1 after the previous for-loop, that means that
    # The remaining n is that prime factor which is greater that the square root of initial n.
    # And that's why in the next part of my algorithm, I need to check whether n becomes 1 or not,
    #This code is taken by rohan paul's github
    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
#here we go......................
#winners never quit, quitters never win
n=int(input())
pp=n
nn=n

pl=[]
nl=[]
while pp:
    pp-=1
    pl.append(input())
while nn:
    nn-=1
    nl.append(input())
ans=0
pmc=pl.count(""M"")
mc=nl.count(""M"")
if pmc < mc:
    ans+=mc -pmc
psc=pl.count(""S"")
sc=nl.count(""S"")
if psc < sc:
    ans+=sc -psc

plc=pl.count(""L"")
lc=nl.count(""L"")
if plc < lc:
    ans+=lc -plc

pxlc=pl.count(""XL"")
xlc=nl.count(""XL"")
if pxlc < xlc:
    ans+=xlc -pxlc

pxxlc=pl.count(""XXL"")
xxlc=nl.count(""XXL"")
if pxxlc < xxlc:
    ans+=xxlc -pxxlc

pxxxlc=pl.count(""XXXL"")
xxxlc=nl.count(""XXXL"")
if pxxxlc < xxxlc:
    ans+=xxxlc -pxxxlc

pxsc=pl.count(""XS"")
xsc=nl.count(""XS"")
if pxsc < xsc:
    ans+=xsc -pxsc

pxxsc=pl.count(""XXS"")
xxsc=nl.count(""XXS"")
if pxxsc < xxsc:
    ans+=xxsc -pxxsc

pxxxsc=pl.count(""XXXS"")
xxxsc=nl.count(""XXXS"")
if pxxxsc < xxxsc:
    ans+=xxxsc -pxxxsc
print(ans)

",linear,"greedy,implementation",4147
"n,M=map(int,input().split())
a=[0]+[int(x) for x in input().split()]+[M]

t1=[]
t2=[]
for i in range(n+1):
    if i%2==0:
        t1.append(a[i+1]-a[i])
    else:
        t2.append(a[i+1]-a[i])
t2.append(0)

import math
ans=sum(t1)
p=0
q=sum(t2)
for i in range(math.ceil(n/2)):
    p=p+t1[i]
    q=q-t2[i-1]
    ans=max(ans,p+q-1)
print(ans)
",linear,greedy,342
"N,M=map(int,input().split())
light=[0]+[int(_) for _ in input().split()]+[M]
sumlist=[]
sumlight,ans=0,-10**30
for i in range(N+1):
    sumlight+=(-1)**(i+1)*light[i]
    sumlist.append(sumlight)
for i in range(1,N+1):
    if light[i]>light[i-1]+1:
        ans=max(ans,2*sumlist[i-1]-sumlight+(-1)**(i+1)*(light[i]-1))
    if light[i]<light[i+1]-1:
        ans=max(ans,2*sumlist[i]-sumlight+(-1)**i*(light[i]+1))
if N%2==0:
    print(max(ans,sumlight+M))
else:
    print(max(ans+M,sumlight))",linear,greedy,491
"N,M=map(int,input().split())
L=[0]+[int(_) for _ in input().split()]+[M]
sumL=[0]
ans=-10**30
for i in range(1,N+1):
    sumL.append(sumL[-1]-(-1)**i*L[i])
for i in range(1,N+1):
    if L[i]>L[i-1]+1:
        ans=max(ans,2*sumL[i-1]-sumL[-1]-(-1)**(i)*(L[i]-1))
    if L[i]<L[i+1]-1:
        ans=max(ans,2*sumL[i]-sumL[-1]+(-1)**i*(L[i]+1))
if N%2==0:
    print(max(ans,sumL[-1]+M))
else:
    print(max(ans+M,sumL[-1]))",linear,greedy,419
"n, M = map(int, input().strip().split())
a = list(map(int, input().strip().split()))

a.insert(0, 0)
n += 1

lit = [0] * (n + 1)
for i in range(1, n):
    if i % 2 == 0:
        lit[i] = lit[i - 1]
    else:
        lit[i] = lit[i - 1] + a[i] - a[i - 1]
if n % 2 == 0:
    lit[n] = lit[n - 1]
else:
    lit[n] = lit[n - 1] + M - a[n - 1]
# print(lit)

ans = lit[n]
for i in range(n):
    pre_lit = lit[i]
    post_lit = M - a[i] - (lit[n] - lit[i])    
    # print(i, pre_lit, post_lit)
    if i > 0 and a[i - 1] + 1 < a[i]:
        if i % 2 == 0:
            ans = max(ans, pre_lit + 1 + post_lit)
        else:
            ans = max(ans, pre_lit - 1 + post_lit)
    if (i + 1 < n and a[i] + 1 < a[i + 1]) or (i + 1 == n and a[n - 1] + 1 < M):
        if i % 2 == 0:
            ans = max(ans, pre_lit + post_lit + 1)
        else:
            ans = max(ans, pre_lit + post_lit - 1)    
print(ans)",linear,greedy,898
"n, M = map(int, input().split())
A = list(map(int, input().split()))
A = [0]+A+[M]
D = []
for i in range(n+1):
    D.append(A[i+1]-A[i])
#print(D)
E = []
O = []
for i, d in enumerate(D):
    if i%2 == 0:
        E.append(d)
        O.append(0)
    else:
        O.append(d)
        E.append(0)
from itertools import accumulate
CE = [0]+E
CE = list(accumulate(CE))
CO = [0]+O
CO = list(accumulate(CO))

#print(CE)
#print(CO)
ans = CE[-1]
for i in range(n+1):
    if D[i] == 1:
        continue
    temp = CE[i]+(D[i]-1)+CO[-1]-CO[i+1]
    #print(i, temp)
    ans = max(ans, temp)
print(ans)
",linear,greedy,590
"from sys import stdin, stdout

get_string = lambda: stdin.readline().strip('\n')
get_intmap = lambda: map( int, get_string().split(' ') )
#get_intmap

def testcase():
    n, M = get_intmap()
    a = [0] + list(get_intmap()) + [M]
    ontime = [0] * (n + 1)
    tmp = 0
    for ind in range(n, -1, -1):
        if ind %2 == 0: #light will be on from now
            tmp += a[ind + 1] - a[ind]#total ontime from ind
        ontime[ind] = tmp
    mx = ontime[0]
    #insert at ai + 1 or ai+1 - 1
    for ind in range(n + 1):#iterate over segments
        l,r = a[ind], a[ind+1]
        if r - l <= 1: continue
        for x in (l+1, r-1):
            newtime = ontime[0] - ontime[ind]
            if ind % 2 == 0:
                newtime += x - l
            else:
                newtime += r - x
            newtime += (M - r) - ontime[ind]
            mx = max(mx, newtime)
    print(mx)
        

    

testcase();quit()
for t in range(int(input())):
    testcase()
",linear,greedy,967
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):#nmbr()):
    n,m=lst()
    a=lst()
    a=[0]+a+[m]
    n=len(a)
    suf=[0]*n
    suf[n-2]=abs(a[-2]-a[-1])
    for i in range(n-3, -1, -1):
        suf[i]=a[i+1]-a[i]+suf[i+2]
    ans=suf[0]
    cost=0
    for i in range(1, n):
        if i&1:
            v=a[i]-1-a[i-1]
            if v!=0:ans=max(ans, cost+v+suf[i])
            cost+=a[i]-a[i-1]
        else:
            v=a[i-1]+1
            if v!=a[i]:ans=max(ans, cost+a[i]-v+(suf[i+1] if i+1<n else 0))
    print(ans)",linear,greedy,602
"n, m=[int(k) for k in input().split()]
w=[int(k) for k in input().split()]
w=[0]+w+[m]
c, d=[], []
res=0
for j in range(n+1):
    c.append(res)
    if j%2==0:
        res+=w[j+1]-w[j]
res=0
for j in range(n+1, -1, -1):
    if j%2==0 and j!=n+1:
        res+=w[j+1]-w[j]
    d.append(res)
d=d[::-1]
mx=d[0]
for j in range(n+1):
    mx=max(c[j]+(w[j+1]-w[j]-1)+(m-w[j+1]-d[j+1]), mx)
#print(c)
#print(d)
print(mx)",linear,greedy,411
"a,b = map(int,input().split())
d = list(map(int,input().split()))
e = []
e1= []
mx = 0
current = 0
for i in range(len(d)):
    if i%2 == 0:
        e.append(d[i]-current)
    else:
        e1.append(d[i]-current)
    current=d[i]
if i%2 == 0:
    e1.append(b-current)
else:
    e.append(b-current)
mx = sum(e)
su = 0
su2 = sum(e1)
for i in range(len(e)):
    su+=e[i]
    mx = max(mx,su+su2-1)
    try:
        su2-=e1[i]
    except:
        break
print(mx)
    
",linear,greedy,463
"# https://codeforces.com/problemset/problem/1004/A
# 900

n, k = map(int, input().split())
l = list(map(int, input().split()))

o = 2
for i in range(n):
    if i+1 == n:
        break

    d = abs(l[i] - l[i+1]) / k
    if d ==  2:
        o += 1
    elif d > 2:
        o += 2

print(o)",linear,implementation,287
"a=list(map(int,input().split()))
t=a[0]
d=a[1]
arr=list(map(int,input().split()))
count=0
for i in range(t-1):
    if(arr[i+1]-arr[i]==2*d):
        count+=1
    elif(arr[i+1]-arr[i]>2*d):
        count+=2
print(count+2)",linear,implementation,220
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr())
    n,d=lst()
    a=sorted(lst())
    s=set()
    for i in range(n):
        x=a[i]-d
        left=a[i-1] if i>=1 else float('inf')
        if abs(x-left)>=d:s.add(x)
        x=a[i]+d
        right=a[i+1] if i+1<n else float('inf')
        if abs(x-right)>=d:s.add(x)
    print(len(s))",linear,implementation,426
"# https://codeforces.com/problemset/problem/1004/A

import math

n, d = [int(x) for x in input().split(' ')]
pos = [int(x) for x in input().split(' ')]

# med = []
# for i in range(1,n+1):
# 	med.append((pos[i-1] + pos[i]) / 2)

# sx = [x - d for x in pos]
# dx = [x + d for x in pos]

# print(med)


count = 2

for i in range(1,n):
	if math.fabs(pos[i] - pos[i-1]) > 2*d:
		count += 2
	elif math.fabs(pos[i] - pos[i-1]) == 2*d:
		count += 1
	else:
		continue;

print(count)
",linear,implementation,475
"n, d = map(int, input().split())
lst = list(map(int, input().split()))
lst.sort()
Ans = 2
for i in range(1, n):
    if lst[i] - lst[i - 1] > 2 * d:
        Ans += 2
    elif lst[i] - lst[i - 1] == 2 * d:
        Ans += 1
print(Ans)
",linear,implementation,232
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    # @timer
    def __init__(self):        
        n, d = map(int, input().strip().split())
        x = list(map(int, input().strip().split()))
        ans = set()
        for i in range(n):
            for z in [-d, d]:
                y = x[i] + z
                dmin = min(abs(y - xi) for xi in x)
                if dmin == d:
                    ans.add(y)
        print(len(ans))

solver()",linear,implementation,733
"import math
n,d=map(int,input().split())
p=list(map(int,input().split()))
q=[]
for i in range(len(p)-1):
    q.append(abs(p[i+1]-p[i]))
count=0
##print(q)
for k in q:
    if k==2*d:
        count+=1
    elif k>=2*d:
        count+=2
##    print(k,""-"",count)
##    print(count,math.floor(k/2),math.floor((k/2)/d)*2)
    
print(count+2)
",linear,implementation,335
"#Winners never quit, quiters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    


def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#winners never quit, quitters never win
n,d=map(int,input().split())
x=list(map(int,input().split()))
ans=0
for i in range(1,n):
    diff=x[i]-x[i-1]
    #print(x[i]-d)
    #print(x[i-1]+d,""xnwxnwisj"")
    if diff >= 2*d:
        ans+=min(2,(x[i]-d)-(x[i-1]+d)+1)
        #print(ans,""ans"")
ans+=2
print(ans)",linear,implementation,2132
"n,d=[int(x) for x in input().split("" "")]
a=[int(x) for x in input().split("" "")]
pos=2
for i in range(n-1):
    l=a[i]+d
    r=a[i+1]-d
    if l==r:
        pos+=1
    elif l<r:
        pos+=2
print(pos)
",linear,implementation,203
"from operator import itemgetter

def main():
    n,m=map(int,input().split( ))
    a=[]
    for _ in range(m):
        x,y=map(int,input().split( ))
        x-=1;y-=1
        a.append((x,y))
    a=sorted(a,key=itemgetter(0,1))

    ans=[-1]*n
    for l,r in a:

        if ans[l]==-1:
            
            flag=1

            for i in range(l,r+1):
                if flag:
                    ans[i]=1
                else:
                    ans[i]=0
                flag^=1
        else:

            flag=1
            x=ans[l]
            for i in range(l,r+1):

                if flag:
                    ans[i]=x
                else:
                    ans[i]=x^1
                flag^=1
    for i in range(n):
        if ans[i]==-1:
            ans[i]=0

    ans=map(str,ans)
    print(''.join(ans))
main()",linear,"constructive algorithms,greedy,implementation,math",823
"a, b = map(int, input().split())
q, r = divmod(a, 2)
print('01'*q + '0'*r)
",linear,"constructive algorithms,greedy,implementation,math",75
"import sys, heapq

n, m = map(int, sys.stdin.readline().split())
for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
ans = [0] * n
for i in range(1, n, 2):
    ans[i] = 1
print(''.join(map(str, ans)))
",linear,"constructive algorithms,greedy,implementation,math",218
"import math
n,k=map(int,input().split())
for _ in range(k):
    l,r=map(int,input().split())
for i in range(1,n+1):
    if i%2==0:
        print('0',end='')
    else:
        print('1',end='')
print()

",linear,"constructive algorithms,greedy,implementation,math",202
"n,m=map(int,input().split())
l=list()
r=list()
for _ in range(m):
    a,b=map(int,input().split())
    l.append(a)
    r.append(b)
for i in range(n):
    if(i%2==0):
        print(0,end='')
    else:
        print(1,end='')
",linear,"constructive algorithms,greedy,implementation,math",224
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    def __init__(self):
        n, m = map(int, input().strip().split())
        segs = list()
        for i in range(m):
            segs.append(list(map(int, input().strip().split())))
        
        def calc(s, segs):
            res = 0
            for x in segs:
                ones = sum(s[x[0]:x[1] + 1])
                res += ones * (x[1] - x[0] + 1 - ones)
            return res

        s1 = [0 for i in range(n)]
        s2 = [1 for i in range(n)]
        for i in range(n):
            if i % 2 == 0:
                s1[i] = 1
                s2[i] = 0

        ans = s1 if calc(s1, segs) > calc(s2, segs) else s2
        print(''.join(map(str, ans)))
        
solver()",linear,"constructive algorithms,greedy,implementation,math",1021
"n,m=map(int,input().split())
arr=[]
for i in range(m):
  arr.append(list(map(int,input().split())))
k=0;ans=str()
for i in range(n):
  ans+=str(k^1)
  k=k^1
print(ans)
",linear,"constructive algorithms,greedy,implementation,math",168
"n,m = map(int,input().split())
for _ in range(m):
    x,y = map(int,input().split())

cnt = 0
ans = []
for i in range(n):
    if cnt%2 == 0:
        ans.append(""0"")

    else:
        ans.append(""1"")

    cnt += 1

print("""".join(ans))",linear,"constructive algorithms,greedy,implementation,math",234
"n,m=map(int,input().split())
c=0;ans=str()
for i in range(n):
  ans+=str(c^1)
  c=c^1
print(ans)
",linear,"constructive algorithms,greedy,implementation,math",97
"s=input()
n=len(s)
l=[[0,0,0] for i in range(n)]
ans=0
x=int(s[0])%3
if(x==0):
    ans+=1
else:
    l[0][x]=1
for i in range(1,n):
    x=int(s[i])%3
    if(x==0):
        ans+=1
        continue
    
    if(l[i-1][3-x]>0):
        ans+=1
        l[i][3-x]=0
        l[i][x]=0
    else:
        if(l[i-1][x]!=0):
            l[i][1]=1
            l[i][2]=1
        else:
            l[i][x]=1

print(ans)",linear,"dp,greedy,number theory",403
"


s = input()


count = 0



i = 0

while i < len(s):

    
    if int(s[i]) % 3 == 0:

        count += 1
        i += 1

    elif i < len(s)-1 and (int(s[i:i+2]) % 3 == 0 or int(s[i+1]) % 3 == 0 ):

        count += 1
        i +=2

    elif i < len(s)-2 and ( int(s[i+1:i+3]) % 3 == 0 or int(s[i:i+3]) % 3 == 0 or s[i+2] == '0') :

        count += 1
        i += 3

    else:

        i +=1

    

print(count)



",linear,"dp,greedy,number theory",419
"n=input()
ans=0
r,c=0,0
for i in range(len(n)):
    r+=int(n[i])
    c+=1
    if int(n[i])%3==0 or r%3==0 or c==3:
        ans+=1
        r,c=0,0
print(ans)",linear,"dp,greedy,number theory",156
"n=input()
ans=0
r,c=0,0
for i in n:
    r+=int(i)
    c+=1
    if int(i)%3==0 or r%3==0 or c==3:
        ans+=1
        r,c=0,0
print(ans)",linear,"dp,greedy,number theory",138
"s = input()
n = len(s)
ans = 0
c = 0
l = []
for i in range(n):
    a = int(s[i])%3
    if a==0:
        ans+=1
        c = 0
        l = []
    else:
        if c==0:
            l.append(int(s[i]))
            c+=1
        elif c==1:
            if (a+l[0])%3==0:
                ans+=1
                c = 0
                l = []
            else:
                c+=1
        else:
            ans+=1
            c=0
            l = []
print(ans)",linear,"dp,greedy,number theory",450
"import sys
from math import sqrt,log2
from collections import Counter

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n=input()
ct=0
i=0
s=[]
while i <len(n):
    if not int(n[i])%3:
        ct+=1
        s.clear()
    else:
        t=int(n[i])%3
        if 3-t in s:
            ct+=1
            s.clear()
        else:
            s.append(t)
    if len(s)==3:
        ct+=1
        s.clear()
    i+=1

print(ct)",linear,"dp,greedy,number theory",421
"from os import path;import sys,time
mod = int(1e9 + 7)
from math import ceil, floor,gcd,log,log2 ,factorial,sqrt
from collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations
from string import ascii_lowercase ,ascii_uppercase
from bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')
I = lambda :int(sys.stdin.buffer.readline())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
grid = lambda  r :[lint() for i in range(r)]
localsys = 0
start_time = time.time()
#left shift --- num*(2**k) --(k - shift)
nCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)
def ceill(n,x):
    return (n+x -1 )//x
T =0

def solve():
	arr = list(map(int , S()))
	s , cnt , ans = 0 , 0 ,0
	for i in arr:
		s , cnt = s + i , cnt + 1
		if i % 3 ==0 or cnt % 3 ==0 or s % 3 ==0:
			s , cnt,ans  =0 , 0 , ans + 1
	print(ans)














	# n = I()
	# a = lint()
	# l , r ,ans = [1]*n , [1]*n , 1
	# for i in range(1 , n):
	# 	if a[i] > a[i-1]:
	# 		l[i] = l[i-1] + 1 #from left sort of prefix 
	# 	ans = max(ans , l[i]) 

	# for i in range(n-2 ,-1 ,-1 ):
	# 	if a[i+1] > a[i]:
	# 		r[i] =r[i+1] +1
	# 	ans = max(ans , r[i])

	# for i in range(1 , n - 1):
	# 	if a[i-1] < a[i+1]: #skipping one element
	# 		ans = max(ans , l[i-1] + r[i+1])
	# print(ans)

















def run():
    if (path.exists('input.txt')):
        sys.stdin=open('input.txt','r')
        sys.stdout=open('output.txt','w')


run()
T = I() if T else 1
for _ in range(T):
    solve()


if localsys:
    print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")


",linear,"dp,greedy,number theory",1695
"from os import path;import sys,time
mod = int(1e9 + 7)
from math import ceil, floor,gcd,log,log2 ,factorial,sqrt
from collections import defaultdict ,Counter , OrderedDict , deque;from itertools import combinations,permutations
from string import ascii_lowercase ,ascii_uppercase
from bisect import *;from functools import reduce;from operator import mul;maxx = float('inf')
I = lambda :int(sys.stdin.buffer.readline())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
grid = lambda  r :[lint() for i in range(r)]
localsys = 0
start_time = time.time()
#left shift --- num*(2**k) --(k - shift)
nCr = lambda n, r: reduce(mul, range(n - r + 1, n + 1), 1) // factorial(r)
def ceill(n,x):
    return (n+x -1 )//x
T =0

def solve():
	arr = list(map(int , S()))
	d ,s, ans  = {0} , 0 , 0
	for i in arr:
		s+=i
		s%=3
		if s in d :
			ans+=1
			s =0
			d = {0}
		d.add(s)
	print(ans)















	# n = I()
	# a = lint()
	# l , r ,ans = [1]*n , [1]*n , 1
	# for i in range(1 , n):
	# 	if a[i] > a[i-1]:
	# 		l[i] = l[i-1] + 1 #from left sort of prefix 
	# 	ans = max(ans , l[i]) 

	# for i in range(n-2 ,-1 ,-1 ):
	# 	if a[i+1] > a[i]:
	# 		r[i] =r[i+1] +1
	# 	ans = max(ans , r[i])

	# for i in range(1 , n - 1):
	# 	if a[i-1] < a[i+1]: #skipping one element
	# 		ans = max(ans , l[i-1] + r[i+1])
	# print(ans)

















def run():
    if (path.exists('input.txt')):
        sys.stdin=open('input.txt','r')
        sys.stdout=open('output.txt','w')


run()
T = I() if T else 1
for _ in range(T):
    solve()


if localsys:
    print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")


",linear,"dp,greedy,number theory",1659
"# import itertools
# import bisect
# import math
from collections import defaultdict, Counter
import os
import sys
from io import BytesIO, IOBase

# sys.setrecursionlimit(10 ** 5)
ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())


def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)


def lcm(a, b): return (a * b) // gcd(a, b)


def main():
    # for _ in "" "" * int(input()):
    s = li()
    n = len(s)
    cnt = 0
    sm = 0
    for i in range(n):
        s[i] = int(s[i]) % 3
    i = 0
    while i < n:
        if s[i] == 0:
            cnt += 1
            sm = 0
            i += 1
        else:
            sm += s[i]
            if sm % 3 == 0:
                sm = 0
                cnt += 1
                i += 1
            else:
                if i + 1 < n and s[i] + s[i + 1] == 3:
                    i += 2
                    cnt += 1
                    sm = 0
                else:
                    i += 1
    print(cnt)


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",linear,"dp,greedy,number theory",2829
"# A. Game Shopping

n, m = map(int, input().split())
c = list(map(int, input().split()))
a = list(map(int, input().split()))

ans = 0
i = 0
for bill in a:
    try:
        i += next(ind for ind, el in enumerate(c[i:]) if el <= bill) + 1
        ans += 1
    except StopIteration:
        break

print(ans)
",linear,implementation,306
"n ,m  = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))
ans = 0
for i in range(len(a)):
    if (len(b) == 0):
        break
    if (b[0] >= a[i]):
        ans += 1
        del b[0]
print(ans)
",linear,implementation,248
"n,m=map(int,input().split())
c=list(map(int,input().split()))
a=list(map(int,input().split()))
j,res=0,0
for i in range(n):
    if j < m:
        if c[i] <= a[j]:
            j+=1
            res+=1
print(res)",linear,implementation,209
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

j = 0
for i in range(n):
    if j<m and arr2[j]>=arr1[i]:
        j+=1
print(j)
",linear,implementation,188
"games,bills = map(int,input().split())
g = list(map(int,input().split()))
b=list(map(int,input().split()))
total = 0
i=0
j=0

while(i < games and j < bills):
    if g[i] <= b[j]:
        total+=1
        i+=1
        j+=1
    elif g[i] > b[j]:
        i+=1
print(total)",linear,implementation,269
"n, m = map(int, input().split())
k = list(map(int, input().split()))
p = list(map(int, input().split()))
a = 0
b = 0
ans = 0
while a != n and b != m:
    if p[b] >= k[a]:
        ans += 1
        a += 1
        b += 1
    else:
        a += 1
print(ans)
",linear,implementation,254
"import re
def main():

    total_games, total_notes = map(int, input().split())
    games = [int(i) for i in input().split()]
    notes = [int(i) for i in input().split()]
    note = 0
    for game in games:
        if notes[note] >= game:
            note += 1
        if note == total_notes:
            break
    print(note)



main()",linear,implementation,337
"n, m = map(int, input().split())
c = list(map(int, input().split()))
a = list(map(int, input().split()))

x = 0
for i in range(n):
	try:
		if a[0] >= c[i]:
			x += 1
			a.pop(0)
	except IndexError:
		pass

print(x)",linear,implementation,214
"

def main():
    n, m = list(map(int, input().split()))
    c = list(map(int, input().split()))
    a = list(map(int, input().split()))
    c_i= 0
    a_i= 0
    bought = 0
    while c_i!= n and a_i!= m:
        if(a[a_i]>=c[c_i]):
            a_i+=1
            c_i+=1
            bought+=1
        else:
            c_i+=1
    print(bought)
if __name__ == ""__main__"":
    main()",linear,implementation,381
"from os import path
import sys,time
# mod = int(1e9 + 7)
# import re
from math import ceil, floor,gcd,log,log2 ,factorial
from collections import * 
# from bisect import *
maxx = float('inf')
#----------------------------INPUT FUNCTIONS------------------------------------------#
I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().strip('\n')
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
#left shift --- num*(2**k) --(k - shift)
s=S()
ans = s.replace('1','')+'2'
t =  ans.find('2')
# print(ans,t)
print(ans[:t]+'1'*s.count('1')+ans[t:len(ans)-1])






if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",linear,"greedy,implementation",1024
"s = input()
t = s.count('1')
s = s.replace('1', '')
i = s.find('2')
if i == -1:
    print(s + '1'*t)
else:
    print(s[:i] + '1'*t + s[i:])",linear,"greedy,implementation",139
"s = input()
one = s.count('1')
zero = 0
ind = -1
for i in range(len(s)):
    if s[i]=='2':
        ind=i
        break
    if s[i]=='0':
        zero+=1
d = """"
if ind==-1:
    print(""0""*zero+""1""*one)
    exit()
d =  d + ""0""*zero+""1""*one
for i in s[ind:]:
    if i!='1':
        d+=i
print(d)        
        
    
",linear,"greedy,implementation",314
"fast=lambda:stdin.readline().strip()
zzz=lambda:[int(i) for i in fast().split()]
z,zz=input,lambda:list(map(int,z().split()))
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from re import *
from sys import *
from math import *
from heapq import *
from queue import *
from bisect import *
from string import *
from itertools import *
from collections import *
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from collections import Counter as cc
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def output(answer):stdout.write(str(answer))
###########################---Test-Case---#################################
""""""

  If you Know me , Then you probably don't know me !


""""""
###########################---START-CODING---##############################


s=fast()
ans=s.replace('1','')+'2'
t=ans.find('2')
print(ans[:t]+'1'*s.count('1')+ans[t:-1])
        



",linear,"greedy,implementation",990
"
import bisect
from itertools import accumulate
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n): 
    prime=[]
    primes = [True for i in range(n+1)] 
    p = 2
    while (p * p <= n): 
          
        if (primes[p] == True): 
            prime.append(p)
            for i in range(p * p, n+1, p): 
                primes[i] = False
        p += 1
    return prime
def factors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac
#--------------------------------------------------------
a = input()
b = a.count('1')
a = a.replace('1','')
c = a.find('2')
if c==-1:
    a = (a+ '1'*b)
else:
    a = a[:c]+ '1'*b + a[c:]
print(a)
",linear,"greedy,implementation",2799
"a=input()
c1=a.count('1')
a=a.split('2')
lex='0'*a[0].count('0')+'1'*c1
n=len(a)
for i in range(1,n):
  lex=lex+'2'+'0'*a[i].count('0')
print(lex)
     			 	 	       	 	 	 	   	",linear,"greedy,implementation",177
"import sys

input=sys.stdin.readline
inf = 1e10
mod = int(1e9 + 7)
t=1;
# t=int(input())
for _ in range(t):
    # n, k= map(int, input().split())
    # v=list(map(int, input().split()))
    s=input()
    c=s.count('1')
    c1, i=0, 0
    while(i<len(s) and s[i]!='2'):
        if(s[i]=='0'):c1+=1
        i+=1
    print('0'*c1, end="""")
    print('1'*c, end="""")
    while(i<len(s)):
        if(s[i]!='1'):
            print(s[i], end="""")
        i+=1",linear,"greedy,implementation",449
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    # @timer
    def __init__(self):
        pass

    def __call__(self):
        s = list(input().strip())
        n = len(s)

        res = list()
        p = n - 1        
        ones = 0
        zeros = 0
        while p >= 0:
            if s[p] == '0':
                zeros += 1
            elif s[p] == '1':
                ones += 1
            elif s[p] == '2':
                res.extend(['0'] * zeros)
                res.append('2')
                zeros = 0
            p -= 1
        res.extend(['1'] * ones)
        res.extend(['0'] * zeros)
        res.reverse()
        print(''.join(map(str, res)))

solver()()",linear,"greedy,implementation",966
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
#sys.setrecursionlimit(111111) 
INF=99999999999999999999999999999999
def outIn(x):
    print(x, flush=True)
    return input()
def main():

    mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    ###CODE
    tc = 1
    for _ in range(tc):
        s=rs()
        d=Counter(s)
        if '1' in d:
            news=""""
            for i in s:
                if i!='1':
                    news+=i
            ans=""""
            ind=len(news)
            for i in range(len(news)):
                if news[i]=='2':
                    ind=i
                    break
                
            ans=news[0:ind]+'1'*d['1']+news[ind:]
            ws(ans)
        else:
            ws(s)
                
                
            
                    
                    
                     
                
        
                        

            
            
                    
                
                
        
                
                          
            
        
    
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",linear,"greedy,implementation",3836
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    # @timer
    def __init__(self):
        pass

    def __call__(self):
        n, m = map(int, input().strip().split())

        y = 0
        for _ in range(m):
            x, d = map(int, input().strip().split())
            if d >= 0:  
                y += d * (n - 1) * n // 2
            else:
                if n % 2 != 0:
                    l = (n - 1) // 2
                    y += d * l * (l + 1)
                else:
                    l = n // 2
                    y += d * (l * (l + 1) - l)
            y += x * n
        y /= n
        print(f'{y:.9f}')

solver()()",linear,"greedy,math",923
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

n, m = map(int, input().split())

MAX = 0
MIN = 10**18
for i in range(n):
    l = i*(i+1)//2
    r = (n-1-i)*(n-1-i+1)//2
    MAX= max(MAX, l+r)
    MIN = min(MIN, l+r)

ans = 0
for i in range(m):
    x, d = map(int, input().split())
    ans += n*x
    if d  >= 0:
        ans += d*MAX
    else:
        ans += d*MIN
print(ans/n)
",linear,"greedy,math",416
"from sys import stdin,stdout
from math import gcd,sqrt,factorial,pi,inf
from collections import deque,defaultdict
from bisect import bisect,bisect_left
from time import time
from itertools import permutations as per
from heapq import heapify,heappush,heappop,heappushpop
input=stdin.readline
R=lambda:map(int,input().split())
I=lambda:int(input())
S=lambda:input().rstrip('\r\n')
L=lambda:list(R())
P=lambda x:stdout.write(str(x)+'\n')
lcm=lambda x,y:(x*y)//gcd(x,y)
nCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N
inv=lambda x:pow(x,N-2,N)
sm=lambda x:(x**2+x)//2
N=10**9+7

n,k=R()
s=0
for i in range(k):
	x,d=R()
	s+=n*x
	if d<0:
		s+=sm(n//2)*d+sm(n//2-(n+1)%2)*d
	else:
		s+=sm(n-1)*d
print(s/n)",linear,"greedy,math",697
"n,m=map(int,input().split())
arr=[]
for i in range(m):
    arr.append(list(map(int,input().split())))
count=0
for i in range(m):
    count +=arr[i][0] *(n)
    if n %2==1 and arr[i][1] <0:
        count +=(n//2)*(n//2 +1)*arr[i][1]
    if n %2==1 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1]//2
    if n %2==0 and arr[i][1] <0:
        count +=(n//2)*(n//2 -1)*arr[i][1]
        count +=(n//2) *arr[i][1]
    if n %2==0 and arr[i][1] >0:
        count +=(n) *(n-1) *arr[i][1] //2
print(count /n)",linear,"greedy,math",506
"import sys
 
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
def li(): return [int(i) for i in input().split()]
def lli(rows): return [li() for _ in range(rows)]
def si(): return input()
def ii(): return int(input())
def ins(): return input().split()


n,m=MI()
posf=(n*(n-1))//2
if(n%2!=0):
    negf=(n//2)*(n//2+1)
else:
    negf=(n//2)*(n//2-1)+n//2
ans=0
for i in range(m):
    x,d=MI()
    ans+=n*x
    if(d>=0):
        ans+=posf*d
    else:
        ans+=negf*d
print(ans/n)",linear,"greedy,math",831
"n, m = map(int, input().split())
res = 0
mx = (n-1)*n//2
mn = 0
if n&1:
    mn = (n//2)*(n//2+1)
else:
    mn = n*n//4
for i in range(m):
    x, d = map(int, input().split())
    res += x*n
    if d > 0:
        res += mx*d
    else:
        res += mn*d
print('%.10f'%(res/n))
",linear,"greedy,math",277
"n, m = map(int, input().split())
a = (n * (n - 1)) // 2
n2 = n // 2
b = n2 * (n2 + 1)
if n % 2 == 0:
    b -= n2
s = 0
for i in range(m):
    x, d = map(int, input().split())
    s += x * n
    s += d * (a if d > 0 else b)

print(s / n)
",linear,"greedy,math",237
"import time
from copy import deepcopy
import itertools
from bisect import bisect_left
from bisect import bisect_right
import math
from collections import deque
from collections import Counter


def read():
    return int(input())


def readmap():
    return map(int, input().split())


def readlist():
    return list(map(int, input().split()))


n, m = readmap()
X = []
D = []
for _ in range(m):
    x, d = readmap()
    X.append(x)
    D.append(d)

summ = n * sum(X)

for i in range(m):
    d = D[i]
    if d < 0:
        if n % 2 == 1:
            summ += d * (n // 2) * (n // 2 + 1)
        else:
            summ += d * (n // 2) * (n // 2)
    else:
        summ += d * (n - 1) * n // 2

print(summ / n)",linear,"greedy,math",708
"n, m = map(int,input().split())


max_dist = (n - 1)* n//2
min_dist = max_dist
curr_value = max_dist
for i in range(n):
    curr_value = i * (i + 1) // 2 + (n - 1 - i)*(n - i)//2
    min_dist = min(min_dist, curr_value)

answer = 0
add_value = 0

for i in range(m):
    x, d = map(int, input().split())
    answer+=x
    if d >= 0:
        add_value += d*max_dist
    else:
        add_value += d * min_dist

        
print(answer + (add_value / n))
    
            
",linear,"greedy,math",468
"#------------------------template--------------------------#
import os
import sys
# from math import *
from collections import *
# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()


n=Int()
a=array()

series = [1]
fact = 1
for i in range(n+1):
    series.append(((series[-1]*2)%M + fact)%M)
    fact = (fact*2)%M


ind = n-1
ans=0

for i in range(n):
    ans = (ans + (a[i]*series[ind])%M )%M
    ind-=1

print(ans)





















",linear,"combinatorics,math,probabilities",2596
"from sys import stdin, stdout


def main():
    p = 998244353  # Constante brindada por el problema
    n = int(stdin.readline())
    a = list(readline())
    answer = a[-1]
    pow_ = 1  # Potencia de 2
    for i in range(n - 1, 0, -1):  # Se analizan todas las dificultades
        answer = (answer + a[i - 1] * (2 + n - i) * pow_ % p) % p  # Se calcula la expresion
        pow_ = pow_ * 2 % p  # Se aumenta la potencia de 2
    return answer


def readline():  # Metodo para leer una linea completa, dividirla en elementos y convertirlos en numeros enteros
    return map(int, stdin.readline().strip().split())


if __name__ == '__main__':
    stdout.write(str(main()) + '\n')
",linear,"combinatorics,math,probabilities",681
"# by the authority of GOD     author: manhar singh sachdev #

def some_random_function():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function5():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

import os,sys
from io import BytesIO,IOBase

def main():
    mod = 998244353
    powe = [1]
    for _ in range(10**6):
        powe.append((powe[-1]*2)%mod)
    n = int(input())
    a = list(map(int,input().split()))
    ans,dp,dp1 = (a[0]*powe[n-1])%mod,a[0],0
    for i in range(1,n):
        if i == 1:
            dp = (dp+a[i])%mod
        else:
            dp = (dp*2+a[i]-dp1)%mod
        ans = (ans+powe[n-i-1]*dp)%mod
        dp1 = a[i]
    print(ans)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def some_random_function1():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function2():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function3():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function4():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function6():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function7():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function8():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

if __name__ == '__main__':
    main()",linear,"combinatorics,math,probabilities",4972
"import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    # @timer
    def __init__(self):
        pass

    def __call__(self):
        MOD = 998244353
        N = 1000007
        pow2 = [0] * N        

        n = int(input())
        a = list(map(int, input().strip().split()))

        pow2[0] = 1
        for i in range(n):
            pow2[i + 1] = (2 * pow2[i]) % MOD

        res = 0
        for i in range(1, n):
            tmp = (a[i - 1] * (n + 2 - i)) % MOD
            res += (pow2[n - 1 - i] * tmp) % MOD
            res %= MOD
        res += a[n - 1]
        res %= MOD            
        print(res)        

solver()()",linear,"combinatorics,math,probabilities",918
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#---------------------------------Lazy Segment Tree--------------------------------------
# https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp
class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)
 
        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]
 
        def prod(l, r):
            assert 0 <= l <= r <= _n
 
            if l == r:
                return _e
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)
 
            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1
 
            return _op(sml, smr)
 
        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)
 
            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2
 
            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)
 
        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])
 
        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])
 
        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id
 
        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)
 
        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply
 
 
MIL = 1 << 20
 
 
def makeNode(total, count):
    # Pack a pair into a float
    return (total * MIL) + count
 
 
def getTotal(node):
    return math.floor(node / MIL)
 
 
def getCount(node):
    return node - getTotal(node) * MIL
 
 
nodeIdentity = makeNode(0.0, 0.0)
 
 
def nodeOp(node1, node2):
    return node1 + node2
    # Equivalent to the following:
    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )
 
 
identityMapping = -1
 
 
def mapping(tag, node):
    if tag == identityMapping:
        return node
    # If assigned, new total is the number assigned times count
    count = getCount(node)
    return makeNode(tag * count, count)
 
 
def composition(mapping1, mapping2):
    # If assigned multiple times, take first non-identity assignment
    return mapping1 if mapping1 != identityMapping else mapping2
#-------------------------------------------------------------------------
prime = [True for i in range(10)] 
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n): 
          
        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p): 
                pp[i]+=1
                prime[i] = False
        p += 1
#---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res
#---------------------------------running code------------------------------------------

n = int(input())
a = list(map(int, input().split()))
difficulty = a[0]
expectation = a[0] % 998244353
for i in range(1, n):
    expectation = expectation * 2 + difficulty + a[i]
    difficulty = difficulty * 2 + a[i]
    expectation %= 998244353
    difficulty %= 998244353
print(expectation)",linear,"combinatorics,math,probabilities",12949
"M = 0x3b800001
wa = 0;
n = int(input())
a = list(map(int, input().split()))
now = 1
wa += a[-1]
for i in range(n - 1)[::-1]:
    wa += (now * (n - i - 1) + now * 2) * a[i]
    wa %= M
    now *= 2
    now %= M
print(wa % M)
",linear,"combinatorics,math,probabilities",224
"MOD = 998244353

def main():
    n = int(input())
    a = [int(x) for x in input().split(' ')]
    
    p, sp, s, ss = 0, 0, 0, 0
    for x in a:
        ss = (2 * ss + s) % MOD
        s = (s + x) % MOD
        p = (ss + sp + s) % MOD
        sp = (sp + p) % MOD
    print(p)

if __name__ == '__main__':
    main()
",linear,"combinatorics,math,probabilities",316
"n = int(input())
ans = 0
mod = 998244353
a = list(map(int, input().split()))
p = 1 / 2

for i in range(n):
    ans = (ans + (i + 2) * (p * a[n - i - 1] % mod) % mod) % mod
    p = (2 * p) % mod

print(int(ans) % mod)",linear,"combinatorics,math,probabilities",216
"n = int(input())
a = list(map(int, input().split()))


s = a[0] % 998244353
y = a[0]
for x in a[1:]:

	s = s * 2 + y + x
	y = y * 2 + x

	s %= 998244353
	y %= 998244353


	# print(s)

# print(a)
# print(c)

print(s)
",linear,"combinatorics,math,probabilities",216
"n=int(input())
m=int(input())
a=list(map(int, input().split()))
b=list(map(int, input().split()))
curr=m
f=0
if b[0]!=1:
    curr+=(curr)/(b[0]-1)
else:
    f=1
for i in range(n-1,-1,-1):
    if a[i]!=1:
        curr+=(curr)/(a[i]-1)
    else:
        f=1
    if i>0:
        if b[i]!=1:
            curr+=(curr)/(b[i]-1)
        else:
            f=1
if f:
    print(-1)
else:
    print(curr-m)
",linear,"binary search,math",396
"###############################
# https://codeforces.com/contest/1010/problem/A
# 2021/01/12
# WenhuZhang
################################
from sys import stdin
import collections
import copy
import math


n = int(stdin.readline())
m = int(stdin.readline())
up = list(map(int, stdin.readline().split()))
down = list(map(int, stdin.readline().split()))

def check(x):
    weight = m + x
    fuel = x
    for i in range(n):
        f = weight/up[i]
        if fuel<f:
            return False
        else:
            weight -= f
            fuel -= f
        f = weight/down[i]
        if fuel<f:
            return False
        else:
            weight -= f
            fuel -= f
    return True


l = 0
r = 1e9 + 1e-6

for ii in range(100):
    mid = (r + l)/2
    # print(mid)
    if(check(mid)):
        r = mid
    else:
        l = mid
    if r-l <= 1e-10:
        break
if l >= 1e9+ 1e-6:
    print(-1)
else:
    print(""%.10f"" %l)

",linear,"binary search,math",940
"# -*- coding: utf-8 -*-
# @Time    : 2021/1/12 10:14 上午
# @Author  : qu
# @Email   : quzhenqing@zju.edu.cn
# @File    : A. Fly.py
from sys import stdin

EPS = 1e-6
n = int(stdin.readline())
m = int(stdin.readline())
a = list(map(int, stdin.readline().split()))
b = list(map(int, stdin.readline().split()))
b.append(b[0])


def check(f):
    fuel_left = f
    total_weight = float(m + fuel_left)
    for i in range(n):
        cost = total_weight / a[i]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost

        cost = total_weight / b[i + 1]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost
        if fuel_left < 0:
            return False
    return True


def binary_search(left, right):
    mid = (left + right) / 2
    if abs(left - right) < EPS:
        return mid
    if check(mid):
        return binary_search(left, mid)
    else:
        return binary_search(mid, right)


res = binary_search(0, 1e9 + 1)
# if (n == 196):
#     print(res)
if res - 1e9 > EPS:
    print(-1)
else:
    print(""%.10f"" % res)
",linear,"binary search,math",1077
"# -*- coding: utf-8 -*-
# @Time    : 2021/1/12 10:14 上午
# @Author  : qu
# @Email   : quzhenqing@zju.edu.cn
# @File    : A. Fly.py
from sys import stdin

EPS = 1e-6
n = int(stdin.readline())
m = int(stdin.readline())
a = list(map(int, stdin.readline().split()))
b = list(map(int, stdin.readline().split()))
b.append(b[0])


def check(f):
    fuel_left = f
    total_weight = float(m + fuel_left)
    for i in range(n):
        cost = total_weight / a[i]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost

        cost = total_weight / b[i + 1]
        fuel_left = fuel_left - cost
        total_weight = total_weight - cost
        if fuel_left < 0:
            return False
    return True


def binary_search(left, right):
    mid = (left + right) / 2
    if abs(left - right) < EPS:
        return mid
    if check(mid):
        return binary_search(left, mid)
    else:
        return binary_search(mid, right)


res = binary_search(0, 1e9 + 1)
if res - 1e9 > EPS:
    print(-1)
else:
    print(""%.10f"" % res)
",linear,"binary search,math",1043
"import sys
import math
import heapq
import bisect
from collections import Counter
from collections import defaultdict
from io import BytesIO, IOBase
import string


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
        self.BUFSIZE = 8192

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, self.BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def get_int():
    return int(input())


def get_ints():
    return list(map(int, input().split(' ')))


def get_int_grid(n):
    return [get_ints() for _ in range(n)]


def get_str():
    return input().split(' ')


def yes_no(b):
    if b:
        return ""YES""
    else:
        return ""NO""


def prefix_sums(a):
    p = [0]
    for x in a:
        p.append(p[-1] + x)
    return p


def binary_search(good, left, right, delta=1, right_true=False):
    limits = [left, right]
    while limits[1] - limits[0] > delta:
        if delta == 1:
            mid = sum(limits) // 2
        else:
            mid = sum(limits) / 2
        if good(mid):
            limits[int(right_true)] = mid
        else:
            limits[int(~right_true)] = mid
    if good(limits[int(right_true)]):
        return limits[int(right_true)]
    else:
        return False


def solve_a():
    n = get_int()
    m = get_int()
    a = get_ints()
    b = get_ints()

    def good(k):
        for i in range(n):
            k -= (m + k) / a[i]
            k -= (m + k) / b[i]
        return k >= 0

    ans = binary_search(good, 0, 10 ** 9 + 1, delta=10 ** (-6), right_true=True)
    if not ans:
        return -1
    else:
        return ans


print(solve_a())
",linear,"binary search,math",3143
"i=input
i()
m=int(i())
v=m
try:
 for a in map(int, (i()+' '+i()).split()):v*=a/(a-1)
except:v=m-1
print(v-m)",linear,"binary search,math",108
"from math import ceil
def test(f):
    for i in range(n):
        if (r1+ f) > f * lift[i]:
            return 0
        f -= (r1 + f) / lift[i]
        if (r1+ f) > f * land[i + 1]:
            return 0
        f -= (r1 + f) / land[i + 1]
    return 1
p=int(input())
total_wgt=int(input());r1=total_wgt
lift=list(map(int,input().split()))
land=list(map(int,input().split()));n=len(land);ans=1e20
lift+=[lift[0]];land+=[land[0]]
l=0.0;r=1e20
for i in range(1000):
  mid=(l+r)/2.0
  #print(mid)
  if test(mid):r=mid
  else:l=mid
if r<1e19:
    print('%.17f' %r)
else:
    print(-1)
",linear,"binary search,math",581
"n = int(input())
m = int(input())
a = [int(i) for i in input().split()]
b = [int(i) for i in input().split()]

low = 1
high = 1000000000
ans = -1

while low<=high:
	if high-low < 0.000001: low = high 
	mid = low+(high-low)/2
	try_val = mid
	init_wt = m+try_val
	isPossible = True
	for i in range(n):
		req1 = init_wt/a[i]
		try_val -= req1
		if try_val<=0: 
			isPossible = False
			break
		j=(i+1)%n
		init_wt -= req1
		req2 = init_wt/b[j]
		try_val -= req2
		if try_val<0 or (i<n-1 and try_val==0): 
			isPossible = False
			break
		init_wt -= req2
	if isPossible:
		ans = mid
		high = mid-0.000001
	else: low = mid+0.000001

if (ans==-1):
	isPossible = True
	try_val = 1000000000.000001
	init_wt = m+try_val
	for i in range(n):
		req1 = init_wt/(a[i])
		try_val -= req1
		if try_val<=0:
			#print(""lol"") 
			isPossible = False
			break
		j=(i+1)%n
		init_wt -= req1
		req2 = init_wt/(b[j])
		try_val -= req2
		if try_val<0 or (i<n-1 and try_val==0): 
			isPossible = False
			break
		init_wt -= req2
	if isPossible: ans = 1000000000
print(ans)",linear,"binary search,math",1046
"import sys
readline = sys.stdin.readline

N = int(readline())
M = float(readline())
A = list(map(int, readline().split()))
B = list(map(int, readline().split()))
B = B[1:] + [B[0]]
C = []
for a, b in zip(A[::-1], B[::-1]):
    C.append(b)
    C.append(a)

if 1 in C:
    print(-1)
else:
    M0 = M
    for c in C:
        M += M/(c-1)
    
    print(M-M0)",linear,"binary search,math",355
"n,k =  map(int,input().split())

def tonny(i) :
	return (ord(i)-96)
a= sorted(input())
a=list(map(tonny,a))
a=sorted(list(set(a)))
ans=[a.pop(0)]
k-=1
for j in a :
	if j-ans[-1] >1 and k>0 :
		k-=1
		ans.append(j)
	if k==0 :
		break
if k!=0 :
	print(-1)
else:
	print(sum(ans))
",linear,"greedy,implementation,sortings",277
"import sys
input = sys.stdin.readline

############ ---- Input Functions ---- ############
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def cint(c):
    return ord(c) - 96
####################################################

def find_min_weight(n, k, stages):
    n = len(stages)
    min_weight = float('inf')

    def backtrack(s, w, t):
        nonlocal min_weight 

        if t >= k:
            min_weight = min(min_weight, w)
            return

        if s >= n - 1:
            return

        for i in range(s+1, n, 1):
            if stages[i] - stages[s] > 1:
                backtrack(i, w+stages[i], t+1)

    backtrack(0, stages[0], 1)

    if min_weight == float('inf'):
        return -1

    return min_weight    


n, k = inlt()
stages = list(set(map(cint, insr())))
stages.sort()
print(find_min_weight(n, k, stages))
",linear,"greedy,implementation,sortings",909
"a, b = map(int, input().split())
c = input()
sorted(c)
summa = 0
count = 0
j = -2
i = 0
abc = ""abcdefghijklmnopqrstuvwxyz""
while i < 26 and count < b:
    if abc[i] in c and i-2 >= j:
        summa += i+1
        count += 1
        j = i
    i += 1
if count < b:
    print(-1)
else:
    print(summa)",linear,"greedy,implementation,sortings",299
"a, b = map(int, input().split())
c = input()
su = 0
cnt = 0
j = -2
i = 0
lis = ""abcdefghijklmnopqrstuvwxyz""
while i < 26 and cnt < b:
    if lis[i] in c and i-2 >= j:
        su += i+1
        cnt += 1
        j = i
    i += 1
if cnt < b:
    print(-1)
else:
    print(su)
    	  			 		 	 		 	 			 			",linear,"greedy,implementation,sortings",301
"a, b = map(int, input().split())
c = input()
su = 0
cnt = 0
j = -2
i = 0
lis = ""abcdefghijklmnopqrstuvwxyz""
while i < 26 and cnt < b:
    if lis[i] in c and i-2 >= j:
        su += i+1
        cnt += 1
        j = i
    i += 1
if cnt < b:
    print(-1)
else:
    print(su)
	  			  	  	 			 		  					",linear,"greedy,implementation,sortings",299
"#Winners never quit, quiters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    


def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#winners never quit, quitters never win
n,k=map(int, input().split())
kk=list(map(str, input()))
s=sorted(list(set(kk)))
if k > 13:
    print(-1)
else:
    dic={}
    for index, value in enumerate(""abcdefghijklmnopqrstuvwxyz""):
        dic[value]= index+1
    #print(dic)
    ans=0
    ans+=dic[s[0]]
    k-=1
    curr=s[0]
    for i in range(1,len(s)):
        if k:
            if dic[s[i]]>dic[curr]+1:
                ans+=dic[s[i]]
                curr=s[i]
                k-=1
            if k==0:
                break
    if k==0:
        print(ans)
    else:
        print(-1)   
    
    
",linear,"greedy,implementation,sortings",2425
"n,k = map(int, input().split())
s = input()
l = []
for i in s:
    a = ord(i)-96
    if a not in l:
        l.append(a)
l.sort()
c = l[0]
a = 1
b = l[0]
for i in range(1,len(l)):
    if a==k:
        break
    if (l[i]-b)>1:
        a += 1
        c += l[i]
        b = l[i]
if a<k:
    print(-1)
else:
    print(c)",linear,"greedy,implementation,sortings",315
"n, k = map(int, input().split())
s = input()
a = [0] * 26
for i in s:
    a[ord(i) - ord('a')] = 1
ans = 0
i = 0
while i < 26:
    if a[i] > 0:
        ans += i + 1
        k -= 1
        i += 1
        if k == 0:
            print(ans)
            break
    i += 1
else:
    print(-1)",linear,"greedy,implementation,sortings",285
"n,k=map(int,input().split())
l=input()
l=sorted(l)
ans=l[0]
sum=ord(l[0])
index=0
for j in range(1,n):
    if len(ans)<k:
        if ord(l[j])-ord(l[index])>1:
            ans=ans+l[j]
            sum=sum+ord(l[j])
            index=j
    else:
        break
if len(ans)==k:
    sum=sum-96*k
    print(sum)
else:
    print(-1)        
        







    


             



",linear,"greedy,implementation,sortings",375
"n,x = list(map(int, input().split()))
a = set(map(int, input().split()))

if len(a) < n :
    print(0)
else :
    d = set()
    p = 0
    for i in a :
        d.add(i&x)
        if i&x != i and i&x in a :
            print(1)
            p = 1
            break
    if len(d) < n and p == 0 :
        print(2)
    elif p != 1 :
        print(-1)
",linear,greedy,346
"n,x=list(map(int,input().split()))
b=list(map(int,input().split()))
d={}
flag=0
for i in b:
    if d.get(i):
        flag=1
        break
    else:
        d[i]=1
if flag:
    print(0)
else:
    flag=0
    c=set()
    for i in b:
        a=i&x
        c.add(a)
        if d.get(a) and a!=i:
            flag=1
            break
    if flag:
        print(1)
    elif len(c)<n and flag==0:
        print(2)
    else:
        print(-1)

        
        
",linear,greedy,453
"import sys, heapq

n, x = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
res = dict().fromkeys(set(arr), 0)
for i in arr:
    res[i] += 1
can = False
for i in res:
    if res[i] >= 2:
        can = True
        break
if can:
    print(0)
else:
    res = dict().fromkeys([i for i in range(max(arr) + 1)])
    for i in res:
        res[i] = []
    for i in range(n):
        temp = set()
        now = arr[i]
        cnt = 0
        while True:
            added = False
            before = len(temp)
            temp.add(now)
            after = len(temp)
            if before == after:
                break
            heapq.heappush(res[now], cnt)
            now = now & x
            cnt += 1
    ans = 9876543210
    for i in res:
        if len(res[i]) >= 2:
            ans = min(ans, heapq.heappop(res[i]) + heapq.heappop(res[i]))
    print(ans if ans != 9876543210 else -1)",linear,greedy,927
"from sys import stdin,stdout
from itertools import accumulate
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr())
    n,x=lst()
    a=lst()
    ans=0
    s=set(a)
    if len(s) != n:
        print(0)
        continue
    for i in range(n):
        v=a[i]
        a[i]&=x
        if a[i] in s and v!=a[i]:
            # print(s,a[i])
            ans=1
            break
    if ans==1:print(1)
    elif len(set(a))==n:print(-1)
    else:print(2)",linear,greedy,503
"n,x = list(map(int, input().split()))
arr = list(map(int, input().split()))
f = [0]*100100
s = [0]*100100
can = [False]*100100
for i in range(n):
    f[arr[i]]+=1
    s[arr[i]&x]+=1
    if (arr[i]&x != arr[i]):
        can[arr[i]&x] = True
ans = 3
for i in range(len(f)):
    if f[i] >= 2:
        ans = 0
        break
    if f[i] == 1 and s[i] >= 1:
        if can[i]:
            ans = min(ans,1)
    if s[i] >= 2:
        ans = min(ans,2)
if ans == 3:
    print(-1)
else:
    print(ans)
",linear,greedy,491
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
# sys.setrecursionlimit(111111) 
 
def main():
    

  
 

          
                  
    # mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    

            


    ###CODE
    tc = 1
    for _ in range(tc):
        n,x=ria()
        a=ria()
        d=Counter(a)
        sa=set(a)
        if len(sa)<n:
            print(0)
        else:
            c=0
            for i in a:
                k=i&x
                if k!=i and k in d:
                    c=1
                    print(1)
                    break            
            if c==0:
                z=[]
                for i in a:
                    z.append(i&x)
                if len(set(z))<n:
                    print(2)
                else:
                    print(""-1"")
        
        
                
        
            
        
                    
                                    
                
        
            
                    
                    
        
            
        
        
        
            
            
            
            
            
        
        
                    
            
        
        
                    
                
        
        
            
                
        

            
        

               
            
        
              
                
        
        
            
        
        
            
            
        
        
                
                
                
                
            
        
        
            
           
        
            
                    

                                 
                
                
        

                
        
        
        
            
        
        
                
            
        
        
                    
        
        
        
            
                    
            

                
            
            
                
            
                
            
            
            
            
                
            
        
        
        
        
        
        
        
                    
        
        
        
                
                
        
            
            
            
        

                    
        
                
        
        
                        
        
                            

        

                
            
        

                
            
                    
                
                
        
        
         
        

                        
                            
                
        
                            
                    

                
            
        
                
            
                
        
        
        
                             
        
            
        
        
            
                        
                        
                    
            
        
        
        
        
        
                        
       

        
                           
        
        
        
            
        
        
        
                      

      
                            
            
        
        
            
            
            
            
            
        
        
        
            
        
        
        
            
        
        
        
        
            
            
        
        
        
        
        
        
        
                
                
                    
        
        
            
            
        
                
            
            
        
        
        
        
                
        
            
        
                
        
        
            
        
       
            

                
        
        
        
   
            
        
        
        
        
            
        
                
        
        
        
            
            
        
        
            
        
        

        
        
            
        
        
            
        
                        

        
        
            
     
        
        
            
        
        
                
            
        
        
        
                
            
        

            
             
        
            
        
        
        
                
        
            
        
        
        
        
                
        
        
            
        
        
        
        
                
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",linear,greedy,7428
"n, x = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
s = set(a)
mv = 999
if len(s) < n:
    print(0)
else:
    for i in a:
        if i & x != i and i & x in s:
            print(1)
            break
    else:
        k = [i & x for i in a]
        if len(set(k)) < n:
            print(2)
        else:
            print(-1)
",linear,greedy,352
"import sys,math
a,b=map(int,input().split())
l=list(map(int,input().split()))
t=[[-1,0] for i in range(100001)]
for i in range(a):
    if t[l[i]][0]!=-1:print(0);sys.exit()
    t[l[i]][0]=3
s=math.inf
for i in range(a):
    if t[l[i]&b][0]!=-1:
        #print(l[i],t[l[i]&b])
        if l[i]&b!=l[i] and t[l[i]&b][0]!=1:
            t[l[i]&b]=[1,min(2,t[l[i]&b][1]+1)]
        #print(l[i],t[l[i]&b])
    else:t[l[i]&b]=[2,1]
#for i in range(11):print(t[i])
for i in range(a):
    if t[l[i]&b][1]!=0 and t[l[i]&b][0]==1:s=min(s,t[l[i]&b][1])
if s==math.inf:
    print(-1)
else:
    print(s)
",linear,greedy,590
"n,x = list(map(int, input().split()))
a = set(map(int, input().split()))
 
if len(a) < n :
    print(0)
else :
    d = set()
    p = 0
    for i in a :
        d.add(i&x)
        if i&x != i and i&x in a :
            print(1)
            p = 1
            break
    if len(d) < n and p == 0 :
        print(2)
    elif p != 1 :
        print(-1)",linear,greedy,346
"n=int(input())
a=[]
for i in range(n):
    l=[int(i) for i in input().split()]
    if i==0:
        t=sum(l)
    a.append(sum(l))
a.sort(reverse=True)
print(a.index(t)+1)",linear,implementation,170
"test=int(input())
first=[]
for i in range(test):
    list_=list(map(int,input().split()))
    sum_=sum(list_)
    first.append(sum_)
first_sum=first[0]
count=0
for i in first:
    if first_sum<i:
        count=count+1 
    else:
        continue
print(count+1)",linear,implementation,260
"n=int(input())
S=[]
for i in range(n):
    A=[int(i) for i in input().split()]
    S.append(sum(A))
if S[0]==max(S):
    print(""1"")
    exit()
thomas=S[0]
rank=1
S.sort(reverse=True)
for i in S:
    if i == thomas:
        print(rank)
        exit()
    else:
        rank+=1            ",linear,implementation,287
"n = int(input())
r = 1
t = sum(map(int, input().split()))
for i in range(n - 1):
    if sum(map(int, input().split())) > t:
        r += 1

print(r)",linear,implementation,148
"rank = 1
n = int(input())
score = sum(map(int,input().split()))
for i in range(n-1):
    student = sum(map(int,input().split()))
    if(student > score):
        rank += 1
print(rank)",linear,implementation,183
"# import os

n = int(input())

r = []
for _ in range(n):
    a,b,c,d = map(int,input().split())
    r.append(sum([a,b,c,d]))

thomas = r[0]
print(sorted(r, reverse=True).index(thomas)+1)
",linear,implementation,187
"n = int(input())

l = []
for i in range(n):
    c = list(map(int, input().split()))
    l.append(sum(c))

m = l[0]
l.sort(reverse=True)
for i in range(len(l)):
    if m == l[i]:
        print(i+1)
        break


    
",linear,implementation,218
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():
    # mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
   

    tc=1
    for _ in range(tc):
        n=ri()
        ans=[]
        i=1
        k=1
        t=0
        while True:
            k=i*i
            if k<=n:
                t=i
            else:
                break
            i+=1
        a=[]
        z=[]
        for i in range(n):
            z+=[i+1]
            if len(z)==t:
                a=z+a
                z=[]
        a=z+a
        wia(a)
        
        

            
                    
                
        
        
            
                
        

            
        

               
            
        
              
                
        
        
            
        
        
            
            
        
        
                
                
                
                
            
        
        
            
           
        
            
                    

                                 
                
                
        

                
        
        
        
            
        
        
                
            
        
        
                    
        
        
        
            
                    
            

                
            
            
                
            
                
            
            
            
            
                
            
        
        
        
        
        
        
        
                    
        
        
        
                
                
        
            
            
            
        

                    
        
                
        
        
                        
        
                            

        

                
            
        

                
            
                    
                
                
        
        
         
        

                        
                            
                
        
                            
                    

                
            
        
                
            
                
        
        
        
                             
        
            
        
        
            
                        
                        
                    
            
        
        
        
        
        
                        
       

        
                           
        
        
        
            
        
        
        
                      

      
                            
            
        
        
            
            
            
            
            
        
        
        
            
        
        
        
            
        
        
        
        
            
            
        
        
        
        
        
        
        
                
                
                    
        
        
            
            
        
                
            
            
        
        
        
        
                
        
            
        
                
        
        
            
        
       
            

                
        
        
        
   
            
        
        
        
        
            
        
                
        
        
        
            
            
        
        
            
        
        

        
        
            
        
        
            
        
                        

        
        
            
     
        
        
            
        
        
                
            
        
        
        
                
            
        

            
             
        
            
        
        
        
                
        
            
        
        
        
        
                
        
        
            
        
        
        
        
                
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",linear,"constructive algorithms,greedy",6799
"n = int(input())
m = int(n**.5)
a = []

for i in range(0, n, m):
    for j in range(i, min(i+m, n)):
        a.append(min(i+m, n)-j + i)

print(' '.join(str(_) for _ in a))
",linear,"constructive algorithms,greedy",173
"n = int(input())
m = int(n**.5)
a = []
 
for i in range(0, n, m):
    for j in range(i, min(i+m, n)):
        a.append(min(i+m, n)-j + i)
 
print(' '.join(str(_) for _ in a))",linear,"constructive algorithms,greedy",174
"import math
n = int(input())
A = [i + 1 for i in range(n)]
x = int(math.sqrt(n))
X = [A[i:i + x] for i in range(0, len(A), x)]
X = X[::-1]
f = [item for sublist in X for item in sublist]
print(*f)",linear,"constructive algorithms,greedy",196
"import math
def getx(n):
    return math.floor(math.sqrt(n))
def getans(n,x):
    l1=[i for i in range(n,0,-1)]
    l2=[]
    i=0
    while(i<n):
        l2=l2+sorted(l1[i:i+x])
        i+=x
    return l2
n=int(input())
a=getx(n)
ans=getans(n,a)
ans1=[str(i) for i in ans]
print(' '.join(ans1))",linear,"constructive algorithms,greedy",294
"import functools
import time
from collections import Counter

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        elapsed = time.perf_counter() - stime
        print(f""{func.__name__} in {elapsed:.4f} secs"")
        return res
    return wrapper

class solver:
    # @timer
    def __init__(self):
        pass

    def __call__(self):
        n = int(input())
        minv = n + 1
        mini = n
        for l in range(1, n + 1):
            v = l + (n + l - 1) // l
            if v < minv:
                minv = v
                mini = l       

        ref = [i + 1 for i in range(n)]
        l = mini        
        res = list()
        p = n - 1
        while p >= 0:
            pp = max(0, p - l + 1)            
            res.extend(ref[pp:p + 1])
            p = pp - 1
        print(' '.join(map(str, res)))


solver()()",linear,"constructive algorithms,greedy",944
"ceil1 = lambda a, b: (a + b - 1) // b
n = int(input())
sq = int(n ** .5)
sq2, ans, cur = ceil1(n, sq), [], 0

for i in range(sq2 - 1):
    cur += sq
    ans.extend([x for x in range(cur, cur - sq, -1)])

ans.extend([x for x in range(n, cur, -1)])
print(' '.join(map(str, ans)))
",linear,"constructive algorithms,greedy",278
"def inp1():
    return int(input())
def inp2():
    return list(map(int,input().split()))
def inp3():
    return map(int,input().split())
if 1:
#for _ range(int(input(()))):
    n=inp1()
    x=int(n**0.5)
    i=0
    y=n
    ans=[]
    while(i<n):
          arr=[]
          for j in range(x):
              if y==0:
                  break
              arr.append(y)
              y-=1
              i+=1
              if y==0:
                  break
          arr=arr[::-1]
          for j in arr:
              ans.append(j)
    print(*ans)
",linear,"constructive algorithms,greedy",546
"n=int(input())
ans=[]
m=int(n**0.5)
x=n
while x-m>0:
  for i in range(1,m+1):
    ans.append(x-m+i)
  x-=m
for i in range(1,x+1):
  ans.append(i)
print(*ans)",linear,"constructive algorithms,greedy",157
"import sys, string

n, m = map(int, sys.stdin.readline().split())
s = list(sys.stdin.readline().rstrip())
t = list(sys.stdin.readline().rstrip())
idx = -1
for i in range(n):
    if s[i] == '*':
        idx = i
if idx == -1:
    if s == t:
        print('YES')
    else:
        print('NO')
else:
    if m < n - 1:
        print('NO')
    else:
        s_left = s[0 : idx]
        s_right = s[idx + 1 : n]
        a = len(s_left)
        b = len(s_right)
        t_left = []
        t_right = []
        for i in range(a):
            t_left.append(t[i])
            t[i] = ''
        for i in range(b):
            t_right.append(t[m - i - 1])
        if s_left == t_left and s_right == t_right[::-1]:
            print('YES')
        else:
            print('NO')",linear,"brute force,implementation,strings",764
"n, m = map(int, input().split())
a = input()
b = input()
flag = 0
for c in a:
    if(c == '*'):
        flag = 1
if(flag == 1):
    a1, a2 = a.split('*')
    Len1 = len(a1)
    Len2 = len(a2)
    b1 = b[:Len1]
    b2 = ''
    if(Len2):
        b2 = b[-Len2:]
    #print(a1, b1, a2, b2)
    if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)):
        print('YES')
    else:
        print('NO')
else:
    if(a == b):
        print('YES')
    else:
        print('NO')

   	 	   	 			 		 	 			 	  		 	",linear,"brute force,implementation,strings",499
"import math
#t=int(input())
#for i in range(t):
n,m = map(int, input().strip().split(' '))
#lst = list(map(int, input().strip().split(' ')))
s=input()
t=input()
if '*' not in s:
    if s==t:
        print('YES')
    else:
        print('NO')
elif n>m+1:
    print('NO')
elif n==1 and s=='*':
    print('YES')
else:
    s=list(s)
    t=list(t)
    if s[0]=='*':
        if s[1:]==t[-(len(s[1:])):]:
            print('YES')
        else:
            print('NO')
    elif s[-1]=='*':
        if s[:n-1]==t[:n-1]:
            print('YES')
        else:
            print('NO')
    else:
        ind=s.index('*')
        #print(ind)
        #print(s[ind+1:])
        #print(t[-len(s[ind+1:]):])
        if s[:ind]==t[:ind] and s[ind+1:]==t[-len(s[ind+1:]):]:
            print('YES')
        else:
            print('NO')
        

",linear,"brute force,implementation,strings",828
"n, m = map(int, input().split())
a = input()
b = input()
flag = 0
for c in a:
    if(c == '*'):
        flag = 1
if(flag == 1):
    a1, a2 = a.split('*')
    Len1 = len(a1)
    Len2 = len(a2)
    b1 = b[:Len1]
    b2 = ''
    if(Len2):
        b2 = b[-Len2:]
    if(a1 == b1 and a2 == b2 and Len1 + Len2 <= len(b)):
        print('YES')
    else:
        print('NO')
else:
    if(a == b):
        print('YES')
    else:
        print('NO')",linear,"brute force,implementation,strings",439
"n,m = map(int, input().split())
a= input()
b = input()
if '*' in a:
    c = a.replace('*','')
    i = a.index('*')
    if c==b:
        print(""YES"")
    elif a[:i]==b[:i]:
        t = a[i+1:]
        #print(t)
        tt = b[m - n+1+i:]
        #print(tt)
        if t ==tt and n-1<=m:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")
elif n>m:
    print(""NO"")
else:
    if a==b:
        print(""YES"")
    else:
        print(""NO"")
",linear,"brute force,implementation,strings",475
"n, m = map(int, input().split())
s = input()
t = input()
if ""*"" in s:
    front, back = s.split(""*"")
    if len(t) >= len(s) - 1 and t.startswith(front) and t.endswith(back):
        print(""YES"")
    else:
        print(""NO"")
else:
    print(""YES"" if s == t else ""NO"")
",linear,"brute force,implementation,strings",269
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################
import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 


alphabets = list('abcdefghijklmnopqrstuvwxyz')


def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):
    """"""
    L is a list.
    The function returns the power set, but as a list of lists.
    """"""
    cardinality=len(L)
    n=2 ** cardinality
    powerset = []
    
    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
        
    #the function could stop here closing with
    #return powerset

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)
        
    return powerset_orderred
def fastPlrintNextLines(a):
    # 12
    # 3
    # 1
    #like this
    #a is list of strings
    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
# else:
#     input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1
# t = int(input())
for _ in range(t):
    n,m = li()
    s = list(si())
    t = list(si())
    if '*' not in s:
        if s==t:
            print(""YES"")
        else:
            print(""NO"")
        continue
    i = s.index('*')
    if s[:i]==t[:i]:
        s = s[i:]
        t = t[i:]
        s=s[::-1]
        t = t[::-1]
        i = s.index('*')
        
        if len(t)>=i and s[:i]==t[:i]:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")
    
",linear,"brute force,implementation,strings",4097
"n,m=map(int,input().split())
s=input()
t=input()
if n-1>m:
    print('NO')
else:
    try:
        a=s.index('*')
    except:
        a=-1
    if a==-1:
        if s==t:
            print('YES')
        else:
            print('NO')
    else:
        f=True
        for i in range(a):
            if s[i]!=t[i]:
                print('NO')
                exit()
        i=1
        while m-i>=a and n-i>a:
            if s[n-i]!=t[m-i]:
                print('NO')
                exit()
            i+=1
        print('YES')",linear,"brute force,implementation,strings",525
"
n,m=map(int,input().split())
s=input()
t=input()
if n==1:
	if s==t or s=='*':
		print('YES')
	else:
		print('NO')
elif s.count('*')==0:
	if s==t:
		print('YES')
	else:
		print('NO')
elif n>m+1:
	print('NO')
else:
	l=s.split('*')
	x=t[:len(l[0])]
	y=t[-len(l[1]):]
	if (l[0]==x and l[1]==y) or (s[:1]=='*' and l[1]==y) or (l[0]==x and s[-1:]=='*'):
		print('YES')
	else:
		print('NO')",linear,"brute force,implementation,strings",384
"import sys, string

n, k = map(int, sys.stdin.readline().split())
arr = list(sys.stdin.readline().rstrip())
st = []
ans = []
for i in range(n):
    if k <= 0:
        break
    else:
        if arr[i] == '(':
            st.append((arr[i], i))
        else:
            if st and st[-1][0] == '(':
                k -= 2
                ans.append(st.pop())
                ans.append((arr[i], i))
            else:
                st.append((arr[i], i))

ans.sort(key=lambda x: x[1])
res = []
for i in ans:
    res.append(i[0])
print(''.join(res))",linear,greedy,548
"line = input().split()
n, k = int(line[0]), int(line[1])
line = input()
if n == k:
    print(line)
 
else:
    ans = []
    arr = []
    for i in line:
        arr.append(i)
 
    for i in range(n):
        if len(ans) == k//2:
            break
        if arr[i] == '(':
            ans.append(i)
    for i in range(n-1, -1, -1):
        if len(ans) == k:
            break
        if arr[i] == ')':
            ans.append(i)
    ans.sort()
    for i in ans:
        print(arr[i], end="""")",linear,greedy,489
"n,k = map(int,input().split())
s = input()
a = (n-k)//2
s1 = s.replace('(','',a)
s2 = s1.replace(')','',a)
print(s2)",linear,greedy,116
"#Winners never quit, quiters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    


def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#winners never quit, quitters never win
n,k=map(int,input().split())
s=list(map(str, input()))
dic={}
for i in range(n):
    if s[i]==""("":
        arrStack.my_push([i,""(""])
    else:
        if arrStack.my_peak()[1]==""("":
            index=arrStack.my_peak()[0]
            dic[index]=1
            dic[i]=1
            k-=2
            arrStack.my_pop()
    if k==0:
        break
ans =""""
for i in range(n):
    if i in dic:
        ans+=s[i]
print(ans)
",linear,greedy,2280
"import sys
# sys.setrecursionlimit(300000)
# Get out of main functoin
def main():
    pass
# decimal to binary
def binary(n):
    return (bin(n).replace(""0b"", """"))
# binary to decimal
def decimal(s):
    return (int(s, 2))
# power of a number base 2
def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
# if  number is prime in √n time
def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
# list to string ,no spaces
def lts(l):
    s = ''.join(map(str, l))
    return s
# String to list
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# Sieve for prime numbers in a range
def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1
            # print(p)
    return (cnt)
# for positive integerse only
def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)
# 1000000007
mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()
# s=input()
def iinp(): return int(input())
# n=int(input())
def nninp(): return map(int, sys.stdin.readline().strip().split())
# n, m, a=[int(x) for x in input().split()]
def llinp(): return list(map(int, sys.stdin.readline().strip().split()))
# a=list(map(int,input().split()))
def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
# d1.setdefault(key, []).append(value)
# ASCII of A-Z= 65-90
# ASCII of a-z= 97-122
import random
from collections import OrderedDict
from fractions import Fraction
#for __ in range(iinp()):
n,k=nninp()
s=ssinp()
ans=[]
lb=k//2
rb=k//2
for c in s:
    if(lb>0):
        if(c==""(""):
            lb-=1
        else:
            rb-=1
        ans.append(c)
    elif(rb>0):
        if(c=="")""):
            ans.append(c)
            rb-=1
    elif(lb==0 and rb==0):
        break
p(lts(ans))





"""""" Stuff you should look for
    int overflow, array bounds
    special cases (n=1?)
    do something instead of nothing and stay organized
    WRITE STUFF DOWN
	DON'T GET STUCK ON ONE APPROACH """"""
",linear,greedy,2795
"import sys
# sys.setrecursionlimit(300000)
# Get out of main functoin
def main():
    pass
# decimal to binary
def binary(n):
    return (bin(n).replace(""0b"", """"))
# binary to decimal
def decimal(s):
    return (int(s, 2))
# power of a number base 2
def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
# if  number is prime in √n time
def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
# list to string ,no spaces
def lts(l):
    s = ''.join(map(str, l))
    return s
# String to list
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# Sieve for prime numbers in a range
def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1
            # print(p)
    return (cnt)
# for positive integerse only
def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)
# 1000000007
mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()
# s=input()
def iinp(): return int(input())
# n=int(input())
def nninp(): return map(int, sys.stdin.readline().strip().split())
# n, m, a=[int(x) for x in input().split()]
def llinp(): return list(map(int, sys.stdin.readline().strip().split()))
# a=list(map(int,input().split()))
def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
#list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist
# d1.setdefault(key, []).append(value)
# ASCII of A-Z= 65-90
# ASCII of a-z= 97-122
#import random
#from collections import OrderedDict
#from fractions import Fraction
#============Speed: STRING < LIST < SET,DICTIONARY==========================
#for __ in range(iinp()):
n,k=nninp()
s=ssinp()
ans=[]
lb=k//2
rb=k//2
for c in s:
    if(lb>0):
        if(c==""(""):
            lb-=1
        else:
            rb-=1
        ans.append(c)
    elif(rb>0):
        if(c=="")""):
            ans.append(c)
            rb-=1
    elif(lb==0 and rb==0):
        break
p(lts(ans))

"""""" Stuff you should look for
    int overflow, array bounds
    special cases (n=1?)
    do something instead of nothing and stay organized
    WRITE STUFF DOWN
	DON'T GET STUCK ON ONE APPROACH""""""
",linear,greedy,2958
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################
import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 


alphabets = list('abcdefghijklmnopqrstuvwxyz')


def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):
    """"""
    L is a list.
    The function returns the power set, but as a list of lists.
    """"""
    cardinality=len(L)
    n=2 ** cardinality
    powerset = []
    
    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
        
    #the function could stop here closing with
    #return powerset

    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)
        
    return powerset_orderred
def fastPlrintNextLines(a):
    # 12
    # 3
    # 1
    #like this
    #a is list of strings
    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
# else:
#     input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
t = 1
# t = int(input())
for _ in range(t):
    n,k = li()
    s = list(si())
    cnt = 0
    ans = []
    covered = 0
    for i in range(n):
        if (s[i]=='('):
            cnt+=1
            ans.append('(')
        else:
            ans.append(')')
            covered+=1
        if cnt==k//2:
            break
    ans+=[')']*(k//2-covered)
    print(''.join(ans))",linear,greedy,3966
"try:
    n,k=list(map(int,input().split("" "")))
    s=input()
    s=list(s)
    if len(s)>k:
        p='('*(k//2)
        p=list(p)
        c=0
        for i in range(0,len(s)):
            if s[i]==')':
                p.insert(i,')')
                c+=1
                if c==k//2:
                    break
        print("""".join(p))
                
            
                
    
    else:
        print("""".join(s))
    
except:
    pass",linear,greedy,445
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():
    # mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    tc=1
    for _ in range(tc):
        
        s=2*rs()+""333""
        le=(len(s)-3)//2
        a=[]
        for i in s:
            if i=='b':
                a.append(0)
            if i=='w':
                a.append(1)
            if i=='3':
                a.append(3)
        pehla=[0,1]*len(s)
        
        doosra=[1,0]*len(s)
        # print(*a)
        # print(*pehla)
        # print(*doosra)
        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==pehla[i]:
                k[i]=1
        ans=0
        t=0
        for i in k:
            if i==1:
                t+=1
                # print(t)
            else:
                ans=max(t,ans)
                t=0
        # print(*k)
        k=[0]*len(s)
        for i in range(len(s)):
            if a[i]==doosra[i]:
                k[i]=1
        
        t=0
        for i in k:
            if i==1:
                t+=1
                # print(t)
            else:
                ans=max(t,ans)
                t=0
        # print(*k)
        
        print(min(le,ans))
        
                    
                
        
        
            
                
        

            
        

               
            
        
              
                
        
        
            
        
        
            
            
        
        
                
                
                
                
            
        
        
            
           
        
            
                    

                                 
                
                
        

                
        
        
        
            
        
        
                
            
        
        
                    
        
        
        
            
                    
            

                
            
            
                
            
                
            
            
            
            
                
            
        
        
        
        
        
        
        
                    
        
        
        
                
                
        
            
            
            
        

                    
        
                
        
        
                        
        
                            

        

                
            
        

                
            
                    
                
                
        
        
         
        

                        
                            
                
        
                            
                    

                
            
        
                
            
                
        
        
        
                             
        
            
        
        
            
                        
                        
                    
            
        
        
        
        
        
                        
       

        
                           
        
        
        
            
        
        
        
                      

      
                            
            
        
        
            
            
            
            
            
        
        
        
            
        
        
        
            
        
        
        
        
            
            
        
        
        
        
        
        
        
                
                
                    
        
        
            
            
        
                
            
            
        
        
        
        
                
        
            
        
                
        
        
            
        
       
            

                
        
        
        
   
            
        
        
        
        
            
        
                
        
        
        
            
            
        
        
            
        
        

        
        
            
        
        
            
        
                        

        
        
            
     
        
        
            
        
        
                
            
        
        
        
                
            
        

            
             
        
            
        
        
        
                
        
            
        
        
        
        
                
        
        
            
        
        
        
        
                
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",linear,"constructive algorithms,implementation",7432
"s = input()
s = s*3
n = len(s)
m,curr=1,1
for i in range(n-1):
    if s[i]!=s[i+1]:
        curr+=1
        m=max(curr,m)
    else:
        curr=1
print(min(m,n//3))
",linear,"constructive algorithms,implementation",166
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################

import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from sys import stdin

import math 



def ncr(n, r, p):  #using fermat's little theorem
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

  
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
          
    for i in range(3,int(math.sqrt(n))+1,2): 
          

        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
    
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 


def si():
    return input()

# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")


# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

# t = int(input())
t = 1
for _ in range(t):
    s = si()
    s = s*3
    m = 0
    c = 1
    for i in range(1,len(s)):
        if (s[i]!=s[i-1]):
            c+=1
        else:
            m = max(m,c)
            c = 1
    m = max(m,c)
    
    m = min(m,len(s)//3)
    print(m)",linear,"constructive algorithms,implementation",2423
"s=input().strip()
s=s+s

n=len(s)
an=1
m=1
#print(s)
for i in range(1,n):
    if s[i]!=s[i-1]:
        m+=1
        an = max(an, m)
    else:
        an = max(an, m)
        m=1
    #print(an)
print(min(an,n//2))",linear,"constructive algorithms,implementation",212
"s=list(input())
ans=0
far=0
for i in range(len(s)-1):
    if(s[i]!=s[i+1]):
        far+=1
        continue
    if(s[0]!=s[-1]):
        s[:i+1]=s[:i+1][::-1]
        s[i+1:]=s[i+1:][::-1]
        far+=1
    else:
        ans=max(ans,far+1)
        far=0
    #print(s)
print(max(far+1,ans))
# b w w w b w w b w
",linear,"constructive algorithms,implementation",311
"import sys
input=sys.stdin.readline
s=list(input().rstrip())
n=len(s)
s.extend(s)
cnt=0
c=1
for i in range(len(s)-1):
  if s[i]!=s[i+1]:
    c+=1
  else:
    cnt=max(c,cnt)
    c=1
cnt=max(cnt,c)
print(min(cnt,n))",linear,"constructive algorithms,implementation",213
"a=input()
n=len(a)
b=[]
c=0
d=0
for i in range(1,n):
    if a[i]==a[i-1]:
        b.append(['bw'.find(a[c]),i-c])
        d=max(d,i-c)
        c=i
b.append(['bw'.find(a[c]),n-c])
d=max(d,n-c)
if d<n and b[0][0]==(b[-1][0]+b[-1][1])%2:
    d=max(d,b[-1][1]+b[0][1])
print(d)",linear,"constructive algorithms,implementation",273
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

#?############################################################


def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

#?############################################################


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


#?############################################################

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))


#?############################################################

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

#?############################################################


def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime


#?############################################################

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

#?############################################################


def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

#?############################################################


def mapin():
    return map(int, input().split())

#?############################################################


# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
# python3 15.py<in>

s = list(input())
n = len(s)
l = [1]
for i in range(n-1):
    if(s[i]!= s[i+1]):
        l[-1]+=1
    else:
        l.append(1)

ans = max(l)
if(len(l)>1):
    if(s[0]!= s[-1]):
        ans = max(ans, l[0]+l[-1])
# print(l)
print(ans)

    



",linear,"constructive algorithms,implementation",2343
"def check(st):
    count = 1
    i = 1
    pre = st[0]
    maxi = 0
    pre_indx = 0
    indx = [0 for i in range(n)]
    while i<n:
        if pre != st[i]:
            count+=1
        else:
            indx[pre_indx] =count
            count=1
            pre_indx=i
        pre =st[i]
        i+=1
    indx[pre_indx] =count
    return indx

st=input()
n=len(st)
actual_indx=check(st)
reverse_indx=check(st[::-1])
if st[0] ==st[-1]:
    print(max(actual_indx))
else:
    print(min(n,max(max(actual_indx[1:]),actual_indx[0] +reverse_indx[0])))",linear,"constructive algorithms,implementation",545
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())
c = [int(i) for i in input().split()]
a = [int(i)-1 for i in input().split()]
vis = [-1]*n
ans = 0
for i in range (n):
    ind = i
    while(vis[ind]==-1):
        vis[ind]=i
        ind = a[ind]
    if vis[ind]==i:
        start = ind
        ind = a[ind]
        cost = c[start]
        while(ind!=start):
            cost = min(cost, c[ind])
            ind = a[ind]
        ans+=cost
print(ans)
",linear,"dfs and similar,graphs",495
"import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

n = int(input())
C = list(map(int, input().split()))
A = list(map(int, input().split()))
A = [a-1 for a in A]

visit = [False]*n
loops = []
for i in range(n):
    if not visit[i]:
        s = [i]
        temp = set()
        temp.add(i)
        flag = False
        while s:
            v = s.pop()
            if visit[A[v]]:
                break
            if A[v] in temp:
                flag = True
                p = A[v]
                break
            else:
                s.append(A[v])
                temp.add(A[v])
        if flag:
            loop = [p]
            nv = A[p]
            cnt = 0
            while nv != p:
                loop.append(nv)
                nv = A[nv]
            loops.append(loop)
        for v in temp:
            visit[v] = True
#print(loops)
ans = 0
for l in loops:
    m = 10**18
    for i in l:
        m = min(m, C[i])
    ans += m
print(ans)
",linear,"dfs and similar,graphs",987
"import sys
import io, os
import math
from heapq import *
gcd = math.gcd
sqrt = math.sqrt
ceil = math.ceil
# arr=list(map(int, input().split()))
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
def strinp(testcases):
    k = 5
    if (testcases == -1 or testcases == 1):
        k = 1
    f = str(input())
    f = f[2:len(f) - k]
    return f
def ind(ch):
    return ord(ch)-ord(""a"")
def main():
    n=int(input())
    b=[0]
    cost=b+list(map(int, input().split()))
    arr=b+list(map(int, input().split()))
    nv=[-1]*(n+1)
    colors=[]
    c=0
    for i in range(1,n+1):
        if(nv[i]!=-1):
            continue
        nv[i]=c
        dest=arr[i]
        while(nv[dest]==-1):
            nv[dest]=c
            dest=arr[dest]
        if(nv[dest]==c):
            colors.append(dest)
        c+=1
    s=0
    for i in colors:
        mi=cost[i]
        nxt=arr[i]
        while(nxt!=i):
            mi=min(mi,cost[nxt])
            nxt=arr[nxt]
        s+=mi
    print(s)
main()",linear,"dfs and similar,graphs",998
"# ///////////////////////////////////////////////////////////////////////////
# //////////////////// PYTHON IS THE BEST ////////////////////////
# ///////////////////////////////////////////////////////////////////////////
import sys,os,io
from sys import stdin
import math 
from collections import defaultdict
from heapq import heappush, heappop, heapify
from bisect import bisect_left , bisect_right
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")




alphabets = list('abcdefghijklmnopqrstuvwxyz')



#for deep recursion__________________________________________-
from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,p - 2, p)) % p

def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    # c = dict(Counter(l))
    return list(set(l))
    # return c

def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 

#____________________GetPrimeFactors in log(n)________________________________________
def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i): 
                if (spf[j] == j):
                    spf[j] = i
    return spf
def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]  
    return ret
#____________________________________________________________



def SieveOfEratosthenes(n): 
    #time complexity = nlog(log(n))
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def si():
    return input()
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))


# ///////////////////////////////////////////////////////////////////////////
# //////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////
# ///////////////////////////////////////////////////////////////////////////
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
    input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def solve():
    n = ii()
    c = [0] + li()
    a = [0] + li()
    vis = [False]*(n+1)
    ans = 0


    d = defaultdict(lambda:0)
    cycleno = 0


    for i in range(1,n+1):
        if (vis[i]==False):
            cur = i 
            first = i 

            while vis[cur]==False:
                d[cur] = cycleno
                vis[cur]=True
                cur = a[cur]
            # print(first,cur)
            # print(""_______________________________"")
            if d[cur]==cycleno:
                min_ = c[cur]
                first = cur
                cur = a[cur]
                
                while first!=cur:
                    # print(first,cur)
                    min_ = min(c[cur],min_)
                    cur = a[cur]
                ans+=min_
            cycleno+=1
                
        
            # print(cur,first)
    print(ans)





t = 1
# t = ii()
for _ in range(t):
    solve()
",linear,"dfs and similar,graphs",5926
"import sys

rd = lambda : sys.stdin.readline().rstrip()

n = int(rd())
c = list(map(int, rd().split()))
a = list(map(lambda x: int(x)-1, rd().split()))

visited = [-1] * (n)
res = 0

for i in range(n):
    trace = []
    
    t = i
    mn = 1e9
    while visited[t] == -1:
        visited[t] = i
        trace.append(t)
        t = a[t]
        
    if visited[t] != i:
        continue
        
    while len(trace) > 0:
        v = trace.pop()
        mn = min(mn, c[v]) 
        
        if t == v: break
    
    res += mn
    
print(res)
    ",linear,"dfs and similar,graphs",547
"input()
c = list(map(int, input().split()))
a = list(map(int, input().split()))

u = [0] * len(a)

ans = 0

for i in range(len(a)):
    if u[i] != 0:
        continue
    idx = i
    while u[idx] == 0:
        u[idx] = 1
        idx = a[idx] - 1
    
    if (u[idx] == 2):
        idx = i
        while u[idx] == 1:
            u[idx] = 2
            idx = a[idx] - 1
        continue

    start = idx
    mn = c[idx]
    u[idx] = 2
    while a[idx] - 1 != start:
        idx = a[idx] - 1
        mn = min(mn, c[idx])
        u[idx] = 2

    idx = i
    while u[idx] == 1:
        u[idx] = 2
        idx = a[idx] - 1
    ans += mn
print(ans)
",linear,"dfs and similar,graphs",642
"input()
c = list(map(int, input().split()))
a = list(map(int, input().split()))

u = [0] * len(a)

ans = 0

for i in range(len(a)):
    if u[i] != 0:
        continue
    idx = i
    while u[idx] == 0:
        u[idx] = 1
        idx = a[idx] - 1
    
    if (u[idx] == 2):
        idx = i
        while u[idx] == 1:
            u[idx] = 2
            idx = a[idx] - 1
        continue

    start = idx
    mn = c[idx]
    u[idx] = 2
    while a[idx] - 1 != start:
        idx = a[idx] - 1
        mn = min(mn, c[idx])
        u[idx] = 2

    idx = i
    while u[idx] == 1:
        u[idx] = 2
        idx = a[idx] - 1
    ans += mn
print(ans)",linear,"dfs and similar,graphs",641
"n = int(input())
c = [0] + [int(j) for j in input().split()]
a = [0] + [int(j) for j in input().split()]
vis = [0] * (n + 1)
ans = 0
for i in range(1, n + 1):
    x = i
    while vis[x] == 0:
        vis[x] = i
        x = a[x]
    if vis[x] != i:
        continue
    v = x
    mn = c[x]
    while a[x] != v:
        x = a[x]
        mn = min(mn, c[x])
    ans += mn
print(ans)
",linear,"dfs and similar,graphs",379
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest

def main():
    # mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    def intersection(l1,r1,l2,r2):
        if l1>r2 or r1<l2:
            return [0,0]
        else:
            return [max(l1,l2),min(r1,r2)]
    tc=1
    for _ in range(tc):
        n=ri()
        pref=[]
        suff=[]
        z=[]
        for i in range(n):
            z.append(ria())
        # print(z)
        pix,piy=intersection(z[0][0],z[0][1],z[0][0],z[0][1])
        six,siy=intersection(z[-1][0],z[-1][1],z[-1][0],z[-1][1])
        for i in range(n):
            pix,piy=intersection(pix,piy,z[i][0],z[i][1])
            pref.append([pix,piy])
        for i in range(n-1,-1,-1):
            six,siy=intersection(six,siy,z[i][0],z[i][1])
            suff.append([six,siy])
        suff=suff[::-1]
        ans=max(suff[1][1]-suff[1][0],pref[n-2][1]-pref[n-2][0])
        for i in range(1,n-1):
            intersect=intersection(pref[i-1][0],pref[i-1][1],suff[i+1][0],suff[i+1][1])
            ans=max(ans,intersect[1]-intersect[0])
        # print(pref)
        # print(suff)
        wi(ans)            

            
                    
                
        
        
            
                
        

            
        

               
            
        
              
                
        
        
            
        
        
            
            
        
        
                
                
                
                
            
        
        
            
           
        
            
                    

                                 
                
                
        

                
        
        
        
            
        
        
                
            
        
        
                    
        
        
        
            
                    
            

                
            
            
                
            
                
            
            
            
            
                
            
        
        
        
        
        
        
        
                    
        
        
        
                
                
        
            
            
            
        

                    
        
                
        
        
                        
        
                            

        

                
            
        

                
            
                    
                
                
        
        
         
        

                        
                            
                
        
                            
                    

                
            
        
                
            
                
        
        
        
                             
        
            
        
        
            
                        
                        
                    
            
        
        
        
        
        
                        
       

        
                           
        
        
        
            
        
        
        
                      

      
                            
            
        
        
            
            
            
            
            
        
        
        
            
        
        
        
            
        
        
        
        
            
            
        
        
        
        
        
        
        
                
                
                    
        
        
            
            
        
                
            
            
        
        
        
        
                
        
            
        
                
        
        
            
        
       
            

                
        
        
        
   
            
        
        
        
        
            
        
                
        
        
        
            
            
        
        
            
        
        

        
        
            
        
        
            
        
                        

        
        
            
     
        
        
            
        
        
                
            
        
        
        
                
            
        

            
             
        
            
        
        
        
                
        
            
        
        
        
        
                
        
        
            
        
        
        
        
                
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",linear,"greedy,math,sortings",7392
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    t=int(input())
    tup=[]
    for _ in range(t):
        l,r=inar()
        tup.append([l,r])
    tup.sort()
    l=tup[0][0]
    r=tup[0][1]
    prefix=[[l,r]]
    for i in range(1,t):
        if l>tup[i][1] or r<tup[i][0]:
            prefix.append([-1,-1])
            for j in range(i+1,t):
                prefix.append([-1, -1])
            break

        l=max(l,tup[i][0])
        r=min(r,tup[i][1])
        prefix.append([l,r])
    l = tup[-1][0]
    r = tup[-1][1]
    suffix = []
    for i in range(t):
        suffix.append([-1,-1])
    suffix[-1][0]=l
    suffix[-1][1]=r
    for i in range(t-2,-1,-1):
        if l > tup[i][1] or r < tup[i][0]:
            break

        l = max(l, tup[i][0])
        r = min(r, tup[i][1])
        suffix[i][0]=l
        suffix[i][1]=r
    ans=0
    for i in range(t):
        if i==0:
            ans=max(ans,abs(suffix[i+1][0]-suffix[i+1][1]))
            continue
        if i==t-1:
            ans=max(ans,abs(prefix[i-1][0]-prefix[i-1][1]))
            continue
        prefix_l=prefix[i-1][0]
        prefix_r=prefix[i-1][1]
        suffix_l=suffix[i+1][0]
        suffix_r=suffix[i+1][1]
        l=max(prefix_l,suffix_l)
        r=min(prefix_r,suffix_r)
        ans=max(ans,max(0,r-l))
    print(ans)





if __name__ == '__main__':
    main()



",linear,"greedy,math,sortings",1469
"import sys
import math
import collections
import bisect
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    starting=[]
    ending=[]
    points=[]
    for i in range(n):
        x,y=get_ints()
        starting.append(x)
        ending.append(y)
    ans=0
    start_count=collections.Counter(starting)
    end_count=collections.Counter(ending)
    s=starting.copy()
    s.sort()
    e=ending.copy()
    e.sort()
    maxim=max(starting)
    minim=min(ending)
    #print(maxim,minim)
    for i in range(n):
        if starting[i]==maxim:
            if start_count[maxim]>1:
                loc_max=maxim
            else:
                pos=bisect.bisect_left(s,maxim)
                loc_max=s[pos-1]
        else:
            loc_max=maxim
        if ending[i]==minim:
            if end_count[minim]>1:
                loc_min=minim
            else:
                pos=bisect.bisect_right(e,minim)
                loc_min=e[pos]
        else:
            loc_min=minim
        ans=max(ans,loc_min-loc_max)
        #print(loc_max,loc_min)
    print(ans)",linear,"greedy,math,sortings",1247
"import sys

input = sys.stdin.readline


def intersection(segs):
    end = float('inf')
    start = - float('inf')
    for l, r in segs:
        end = min(end, r)
        start = max(start, l)
    return start, end


def solve():
    n = int(input())
    segs = [tuple([int(x) for x in input().split(' ')]) for s in range(n)]
    starts = {}
    ends = {}
    x = intersection(segs)
    for l, r in segs:
        if r in starts:
            starts[r] = max(starts[r], l)
        else:
            starts[r] = l
        if l in ends:
            ends[l] = min(ends[l], r)
        else:
            ends[l] = r

    b = segs.copy()
    b.remove((x[0], ends[x[0]]))
    y = intersection(b)

    c = segs.copy()
    c.remove((starts[x[1]], x[1]))
    z = intersection(c)

    return max(x[1] - x[0], y[1] - y[0], z[1] - z[0], 0)

print(solve())
",linear,"greedy,math,sortings",841
"l1=l2=-1
r1=r2=1<<30
for i in range(int(input())):
 l,r=map(int,input().split())
 if l>l1:il,l1,l2=i,l,l1
 elif l>l2:l2=l
 if r<r1:ir,r1,r2=i,r,r1
 elif r<r2:r2=r
print(max(0,(r2-l2,max(r1-l2,r2-l1))[il!=ir]))",linear,"greedy,math,sortings",209
"from sys import stdin
input=stdin.readline

def intersec(arr):
    a=sorted(arr,key=lambda s:s[0],reverse=True)
    b=sorted(arr,key=lambda s:s[1])

    x, y = 0, 0
    if a[0]==b[0]:
        return max(b[1][1]-a[1][0],0)
    else:
        x=b[0][1]-a[1][0]
        y=b[1][1]-a[0][0]
    return max(x,y,0)
blanck=[]
for i in range(int(input())):
    a,b=map(int,input().strip().split())
    blanck.append([a,b])
print(intersec(blanck))",linear,"greedy,math,sortings",435
"from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

#?############################################################


def isPrime(x):
    for i in range(2, x):
        if i*i > x:
            break
        if (x % i == 0):
            return False
    return True

#?############################################################


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p


#?############################################################

def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            l.append(int(i))
            n = n / i
    if n > 2:
        l.append(n)
    return list(set(l))


#?############################################################

def power(x, y, p):
    res = 1
    x = x % p
    if (x == 0):
        return 0
    while (y > 0):
        if ((y & 1) == 1):
            res = (res * x) % p
        y = y >> 1
        x = (x * x) % p
    return res

#?############################################################


def sieve(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime


#?############################################################

def digits(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c

#?############################################################


def ceil(n, x):
    if (n % x == 0):
        return n//x
    return n//x+1

#?############################################################


def mapin():
    return map(int, input().split())

#?############################################################
def solve(final, n):
    fifi = [[final[j][i] for j in range(n)] for i in range(n)] 
 
    k = []
    for i in range(n):
        k.append(sum(final[i]))
    a = max(k)-min(k)
    
    a = a*a
    k = []
    for i in range(n):
        k.append(sum(fifi[i]))
    b = max(k)-min(k)
    
    b = b*b
    
    
    return a+b
    
    
def inte(a, b, c, d):
    a = max(a, c)
    b = min(b, d)
    
    return [a, b]

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
# python3 15.py<in>op
n = int(input())
l = []
for i in range(n):
    a, b = mapin()
    l.append([a, b])
    
    
f= []
ff = []
a = 0
b = 10000000000000
f.append([a, b])
for i in range(n):
    x = inte(a, b, l[i][0], l[i][1])
    a = x[0]
    b = x[1]
    f.append([a, b])
a = 0
b = 10000000000000
ff = [[] for i in range(n)]
for i in reversed(range(n)):
    x = inte(a, b, l[i][0], l[i][1])
    a = x[0]
    b = x[1]
    ff[i] = [a, b]
ff.append([0, 100000000000000])
ans = 0  
for i in range(n):
    a = f[i]
    b = ff[i+1]
    y = inte(a[0], a[1], b[0], b[1])
    if(y[1]>= y[0]):
        ans = max(ans, y[1]-y[0])
    
    
# print(f, ff)/
print(ans)

    
    ",linear,"greedy,math,sortings",3154
"# import itertools
# import bisect
# import math
from collections import defaultdict
import os
import sys
from io import BytesIO, IOBase

# sys.setrecursionlimit(10 ** 5)
ii = lambda: int(input())
lmii = lambda: list(map(int, input().split()))
slmii = lambda: sorted(map(int, input().split()))
li = lambda: list(input())
mii = lambda: map(int, input().split())
msi = lambda: map(str, input().split())


def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)


def lcm(a, b): return (a * b) // gcd(a, b)


def main():
    # for _ in "" "" * int(input()):
    n = ii()
    d = defaultdict(int)
    ll = defaultdict(list)
    rr = defaultdict(list)
    llst = []
    rlst = []
    lst = []
    for i in range(n):
        l, r = mii()
        lst.append([l,r])
        llst.append(l)
        rlst.append(r)
        ll[l].append(r)
        rr[r].append(l)
    left = max(llst)
    right = min(rlst)
    lleft = min(ll[left])
    lright = max(rr[right])
    lst.remove([left,lleft])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    mx = max(0,pr-pl)
    lst.append([left,lleft])
    lst.remove([lright,right])
    pl = max(i[0] for i in lst)
    pr = min(i[1] for i in lst)
    print(max(mx, max(0,pr-pl)))


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
",linear,"greedy,math,sortings",2919
"from collections import defaultdict
from collections import deque
import sys
input = sys.stdin.readline

def bfs(s):
    q = deque()
    q.append(s)
    dist = [-1] * (n + 1)
    dist[s] = 0
    p = []
    parent = [1] * (n + 1)
    ok = [0] * (n + 1)
    while q:
        i = q.popleft()
        d = dist[i]
        if d < 3:
            ok[i] = 1
        p.append(i)
        for j in G[i]:
            if dist[j] == -1:
                q.append(j)
                dist[j] = d + 1
                parent[j] = i
    ans = 0
    while p:
        i = p.pop()
        j = parent[i]
        if not ok[i]:
            ok[j] = 1
            ans += 1
            for k in G[j]:
                ok[k] = 1
    return ans

n = int(input())
G = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)
ans = bfs(1)
print(ans)",linear,"dp,graphs,greedy",882
"from sys import stdin
n = int(stdin.readline())
g = dict()
for i in range(n-1):
    u,v = map(int,stdin.readline().split())
    g.setdefault(u-1,[]).append(v-1)
    g.setdefault(v-1, []).append(u-1)
st = [0]
rank = [0]*n
tree = [0]*n
msk = [0]*n
rd = dict()
while len(st)>0:
    top = st.pop()
    msk[top] = 1
    for c in g[top]:
        if msk[c] == 0:
            st.append(c)
            tree[c] = top
            rank[c] = rank[top]+1
            rd.setdefault(rank[c], []).append(c)
max_rank = max(rank)
reach = [0]*n
build = [0]*n
ans = 0
for r in range(max_rank, 2, -1):
    for node in rd[r]:
        if reach[node] == 0:
            reach[node] = 1
            reach[tree[node]] = 1
            reach[tree[tree[node]]] = 1
            build[tree[node]] = 1
print(sum(build))",linear,"dp,graphs,greedy",785
"import sys
from collections import deque
import heapq
input = sys.stdin.readline

N=int(input())
EDGE=[list(map(int,input().split())) for i in range(N-1)]

EDGELIST=[[] for i in range(N+1)]

for i,j in EDGE:
    EDGELIST[i].append(j)
    EDGELIST[j].append(i)

#EDGES=[[] for i in range(N+1)]
REDG=[None for i in range(N+1)]
QUE=deque([1])
check=[0]*(N+1)
DEPTH=[None]*(N+1)
i=0
while QUE:
    NQUE=deque()
    i+=1
    
    while QUE:
        x=QUE.pop()
        DEPTH[x]=i
        check[x]=1
        for to in EDGELIST[x]:
            if check[to]==1:
                continue
            else:
                #EDGES[x].append(to)
                REDG[to]=x
                NQUE.append(to)
    QUE=NQUE


check=[0]*(N+1)
check[1]=1
#NEXT=[]

#for i in EDGES[1]:
#    check[i]=1
#    NEXT.append(i)

#for j in NEXT:
#    for k in EDGES[j]:
#        check[k]=1


LEAF=[]
for i in range(2,N+1):
    if len(EDGELIST[i])==1:
        LEAF.append((-DEPTH[i],i))

QUE=LEAF
heapq.heapify(QUE)
ANS=0

#print(check,QUE)

while QUE:
    dep,x=heapq.heappop(QUE)
    if check[x]!=0 or dep>=-3:
        continue

    if check[REDG[x]]==2:
        continue

    if check[x]==0:
        check[x]=1
    if check[REDG[REDG[x]]]==0:
        check[REDG[REDG[x]]]=1
    check[REDG[x]]=2   
    heapq.heappush(QUE,(-DEPTH[REDG[REDG[REDG[x]]]],REDG[REDG[REDG[x]]]))
    ANS+=1

    #print(x,QUE,check)

print(ANS)



",linear,"dp,graphs,greedy",1397
"import sys
from collections import deque
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))

n = inp()
edges = [[] for _ in range(n)]
for _ in range(n-1):
    a,b = inpl()
    a,b = a-1,b-1
    edges[a].append(b)
    edges[b].append(a)
dist = [-1] * n
dist[0] = 0
pa = [-1] * n
se = set()
pq = []
q = deque()
q.append(0)
while q:
    now = q.popleft()
    for nx in edges[now]:
        if dist[nx] != -1:
            continue
        pa[nx] = now
        dist[nx] = dist[now] + 1
        if dist[nx] > 2:
            se.add(nx)
            pq.append((dist[nx], nx))
        q.append(nx)
pq = pq[::-1]
res = 0
ind = 0
while se:
    d,v = pq[ind]
    ind += 1
    if not v in se: 
        continue
    res += 1
    pv = pa[v]
    se.discard(pv)
    for nv in edges[pv]:
        se.discard(nv)
print(res)",linear,"dp,graphs,greedy",891
"
import sys

def get_new_edges(graph):
    n = len(graph)
    far_vertex = []
    pi = [None]*n
    visit = [False]*n
    visit[0]
    queue = [[0,0]]
    i = 0    
    while True:
        if i >= len(queue): break
        current, d = queue[i]
        i += 1
        visit[current] = True
        for v in graph[current]:
            if not visit[v]:
                u = [v, d+1]
                pi[v] = current
                queue.append(u)
                if d+1 > 2:
                    far_vertex.append(u)
    
    far_vertex.sort(key=lambda x: -x[1])

    pos = [None]*n
    for i, e in enumerate(far_vertex):
        pos[e[0]] = i

    count = 0
    for i in range(len(far_vertex)):
        if not far_vertex[i]: continue
        vertex, depth = far_vertex[i]
        father = pi[vertex]
        count += 1
        if pos[father]:
            far_vertex[pos[father]] = None
        for u in graph[father]:
            if pos[u]:
                far_vertex[pos[u]] = None

    return count
    
def read_int_line():
    return map(int, sys.stdin.readline().split())

vertex_count = int(input())
graph = [[] for _ in range(vertex_count)]

for i in range(vertex_count - 1):
    v1, v2 = read_int_line()
    v1 -= 1
    v2 -= 1
    graph[v1].append(v2)
    graph[v2].append(v1)

print(get_new_edges(graph))


    
",linear,"dp,graphs,greedy",1320
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(200001)] 
pp=[0]*200001
def SieveOfEratosthenes(n=200000): 
      
    # Create a boolean array ""prime[0..n]"" and initialize 
    #  all entries it as true. A value in prime[i] will 
    # finally be false if i is Not a prime, else true. 
    
    p = 2
    while (p * p <= n): 
          
        # If prime[p] is not changed, then it is a prime 
        if (prime[p] == True): 
              
            # Update all multiples of p 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
#---------------------------------running code------------------------------------------
n=int(input())
a=list(map(int,input().split()))
if n==1:
    print(1)
    sys.exit(0)
dp=[[-1 for j in range (5)] for i in range (n)]
for i in range (1,min(2,n)):
    if a[i]<a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k>j:
                    ch=k
            dp[i][j]=ch
    elif a[i]>a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k<j:
                    ch=k
            dp[i][j]=ch
    else:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k!=j:
                    ch=k
            dp[i][j]=ch
for i in range (2,n):
    if a[i]<a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k>j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch
    elif a[i]>a[i-1]:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k<j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch
    else:
        for j in range (5):
            ch=-1
            for k in range (5):
                if k!=j and dp[i-1][k]!=-1:
                    ch=k
            dp[i][j]=ch
#print(dp)
ind=-1
for i in range (5):
    if dp[-1][i]!=-1:
        ind=i
if ind==-1:
    print(ind)
    sys.exit(0)
res=[ind+1]
for i in range (n-1,0,-1):
    res.append(dp[i][ind]+1)
    ind=dp[i][ind]
print(*res[::-1])",linear,"constructive algorithms,dp",9889
"n=int(input())
arr=list(map(int,input().split()))
dp=[[-1 for i in range(5+1)] for j in range(n)]
for i in range(1,6):
    dp[0][i] =1
for i in range(1,n):
    if arr[i] > arr[i - 1]:
        for j in range(1,6):
            for k in range(1,j):
                if dp[i-1][k]==1:
                    dp[i][j] =1
                    break
    elif arr[i] <arr[i-1]:
        for j in range(1,6):
            for k in range(j+1,6):
                if dp[i-1][k] ==1:
                    dp[i][j]=1
                    break
    else:
        for j in range(1,6):
            for k in range(1,6):
                if j ==k:
                    continue
                if dp[i-1][k] ==1:
                    dp[i][j] =1
                    break
ans=[]
for i in range(1,6):
    if dp[n-1][i]==1:
        ans.append(i)
        break
if len(ans) ==0:
    print(-1)
    exit()
for i in range(n-2,-1,-1):
    curr=ans[-1]
    if arr[i] >arr[i+1]:
        for j in range(curr+1,6):
            if dp[i][j] ==1:
                ans.append(j)
                break
    elif arr[i] <arr[i+1]:
        for j in range(1,curr):
            if dp[i][j] ==1:
                ans.append(j)
                break
    else:
        for j in range(1,6):
            if j ==curr:
                continue
            if dp[i][j] ==1:
                ans.append(j)
                break
ans=ans[::-1]
print(*ans)
",linear,"constructive algorithms,dp",1389
"n = int(input())
arr = list(map(int, input().split()))
pal = 1 if arr[1] > arr[0] else 3 if arr[0] == arr[1] else 5
b = True
arr_pal = [pal]
for i in range(n - 2):
    if arr[i + 1] > arr[i]:
        if pal == 5:
            b = False
            break
        if arr[i + 2] < arr[i + 1]:
            pal = 5
            arr_pal.append(pal)
        else:
            pal += 1
            arr_pal.append(pal)
    elif arr[i + 1] < arr[i]:
        if pal == 1:
            b = False
            break
        if arr[i + 2] > arr[i + 1]:
            pal = 1
            arr_pal.append(pal)
        else:
            pal -= 1
            arr_pal.append(pal)
    else:
        if arr[i + 2] > arr[i + 1]:
            pal = 2 if pal == 1 else 1
            arr_pal.append(pal)
        elif arr[i + 2] < arr[i + 1]:
            pal = 4 if pal == 5 else 5
            arr_pal.append(pal)
        else:
            pal = 4 if pal < 4 else 3
            arr_pal.append(pal)
if arr[-2] < arr[-1]:
    if pal == 5:
        b = False
    else:
        pal += 1
        arr_pal.append(pal)
elif arr[-2] > arr[-1]:
    if pal == 1:
        b = False
    else:
        pal -= 1
        arr_pal.append(pal)
else:
    pal = 3 if pal == 5 else 5
    arr_pal.append(pal)
if b:
    print(*arr_pal)
else:
    print(-1)",linear,"constructive algorithms,dp",1296
"n = int(input())
a = list(map(int, input().split()))
res = []
if n == 1:
    print(1)
    exit(0)

i = 0
if a[0] < a[1]:

    if i >= n - 2:
        res = [1]
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res = [1]
            cur = 2
        elif a[i + 1] > a[i + 2]:
            res = [1]
            cur = 5
        else:
            res = [1]
            cur = 2

    # res = [1]
    # cur = 2
elif a[0] > a[1]:

    if i >= n - 2:
        res = [5]
        cur = 4
    else:
        if a[i + 1] < a[i + 2]:
            res = [5]
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res = [5]
            cur = 4
        else:
            res = [5]
            cur = 4

    # res = [5]
    # cur = 4
else:
    if i >= n - 2:
        res.append(1)
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res.append(2)
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res.append(4)
            cur = 5
        else:
            res.append(2)
            cur = 3

for i in range(1, n - 1):
    if not (1 <= cur <= 5):
        # print(i, res)
        print(-1)
        exit(0)
    res.append(cur)
    if a[i] > a[i + 1]:

        if i >= n - 2:
            cur -= 1
        else:
            if a[i + 1] < a[i + 2]:
                cur = min(cur - 1, 1)
            elif a[i + 1] > a[i + 2]:
                cur -= 1
            else:
                cur -= 1

        # cur -= 1
    elif a[i] < a[i + 1]:

        if i >= n - 2:
            cur += 1
        else:
            if a[i + 1] < a[i + 2]:
                cur += 1
            elif a[i + 1] > a[i + 2]:
                cur = max(cur + 1, 5)
            else:
                cur += 1

        # cur += 1
    else:
        if i >= n - 2:
            if cur != 3:
                cur = 3
            else:
                cur = 2
        else:
            if a[i + 1] < a[i + 2]:
                if cur == 1:
                    cur = 2
                else:
                    cur = 1
            elif a[i + 1] > a[i + 2]:
                if cur == 5:
                    cur = 4
                else:
                    cur = 5
            else:
                if cur != 3:
                    cur = 3
                else:
                    cur = 2
if not (1 <= cur <= 5):
    # print(i, res)
    print(-1)
    exit(0)
res.append(cur)
print(*res)
",linear,"constructive algorithms,dp",2382
"n = int(input())
a = iter(map(int, input().split()))
prev_type = 3
prev_res = 2
curr_a = next(a)
res = []
for _ in range(1):
	for next_a in a:
		if next_a > curr_a:
			if prev_type == 1 or prev_res == 1:
				prev_res += 1
				if prev_res == 5:
					break
			else:
				prev_res = 1
			prev_type = 1
		elif next_a < curr_a:
			if prev_type == 2 or prev_res == 5:
				prev_res -= 1
				if prev_res == 1:
					break
			else:
				prev_res = 5
			prev_type = 2
		else:
			if prev_type == 1:
				prev_res += 1
			elif prev_type == 2:
				prev_res -= 1
			elif prev_res != 2:
				prev_res = 2
			else:
				prev_res = 3
			prev_type = 3
		res.append(prev_res)
		curr_a = next_a
	else:
		if prev_type == 1:
			res.append(prev_res + 1)
		elif prev_type == 2:
			res.append(prev_res - 1)
		elif prev_res != 1:
			res.append(1)
		else:
			res.append(2)
		print(*res)
		break
else:
	print('-1')
",linear,"constructive algorithms,dp",881
"n = int(input())
ar = [int(i) for i in input().split()]

if n == 1:
    print(1)
    exit()

if ar[1] > ar[0]:
    li = [1]
elif ar[1] < ar[0]:
    li = [5]
else:
    li = [3]

c = 1
while c != n:
    j = 0

    if ar[c] > ar[c - 1]:
        while c != n and ar[c] > ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] + 1)
            if li[-1] == 6:
                print(-1)
#                print(*li)
                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] + 1)
        else:
            li.append(5)

    elif ar[c] < ar[c - 1]:
        while c != n and ar[c] < ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] - 1)
            if li[-1] == 0:
                print(-1)
 #               print(*li)
                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] - 1)
        else:
            li.append(1)

    else:
        while c != n and ar[c] == ar[c - 1]:
            c += 1
            j += 1
        for i in range(j):
            if li[-1] > 3:
                li.append(li[-1] - 1)
            else:
                li.append(li[-1] + 1)
        if c != n and ar[c] > ar[c - 1]:
            if li[-2] == 1:
                li[-1] = 2
            else:
                li[-1] = 1
        elif c != n and ar[c] < ar[c - 1]:
            if li[-2] == 5:
                li[-1] = 4
            else:
                li[-1] = 5

#print(c)
if max(li) > 5 or min(li) < 1:
    print(-1)
else:
    print(*li)
",linear,"constructive algorithms,dp",1596
"n = int(input())
a = list(map(int, input().split()))
res = []
if n == 1:
    print(1)
    exit(0)

i = 0
if a[0] < a[1]:

    if i >= n - 2:
        res = [1]
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res = [1]
            cur = 2
        elif a[i + 1] > a[i + 2]:
            res = [1]
            cur = 5
        else:
            res = [1]
            cur = 2

elif a[0] > a[1]:

    if i >= n - 2:
        res = [5]
        cur = 4
    else:
        if a[i + 1] < a[i + 2]:
            res = [5]
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res = [5]
            cur = 4
        else:
            res = [5]
            cur = 4

else:
    if i >= n - 2:
        res.append(1)
        cur = 2
    else:
        if a[i + 1] < a[i + 2]:
            res.append(2)
            cur = 1
        elif a[i + 1] > a[i + 2]:
            res.append(4)
            cur = 5
        else:
            res.append(2)
            cur = 3

for i in range(1, n - 1):
    if not (1 <= cur <= 5):
        print(-1)
        exit(0)
    res.append(cur)
    if a[i] > a[i + 1]:

        if i >= n - 2:
            cur -= 1
        else:
            if a[i + 1] < a[i + 2]:
                cur = min(cur - 1, 1)
            elif a[i + 1] > a[i + 2]:
                cur -= 1
            else:
                cur -= 1

    elif a[i] < a[i + 1]:

        if i >= n - 2:
            cur += 1
        else:
            if a[i + 1] < a[i + 2]:
                cur += 1
            elif a[i + 1] > a[i + 2]:
                cur = max(cur + 1, 5)
            else:
                cur += 1
    else:
        if i >= n - 2:
            if cur != 3:
                cur = 3
            else:
                cur = 2
        else:
            if a[i + 1] < a[i + 2]:
                if cur == 1:
                    cur = 2
                else:
                    cur = 1
            elif a[i + 1] > a[i + 2]:
                if cur == 5:
                    cur = 4
                else:
                    cur = 5
            else:
                if cur != 3:
                    cur = 3
                else:
                    cur = 2
if not (1 <= cur <= 5):
    print(-1)
    exit(0)
res.append(cur)
print(*res)",linear,"constructive algorithms,dp",2238
"
def get_fingering(notes):
    fingering = []
    diff = 0
    next_diff = None
    finger = 0
    for i in range(len(notes) - 1):
        next_diff = notes[i+1] - notes[i]
        if diff == 0:
            if next_diff > 0:
                finger = 1 + (finger == 1)
            elif next_diff < 0:
                finger = 5 - (finger == 5)
            else:
                finger = 3 + (finger == 3)
        elif diff > 0:
            if finger == 5:
                return None
            if next_diff < 0:
                finger = 5
            else:
                finger += 1
        else:
            if finger == 1:
                return None
            if next_diff > 0:
                finger = 1
            else:
                finger -= 1
        fingering.append(finger)
        diff = next_diff

    return fingering


_ = input()
notes = [int(x) for x in input().split()]
notes.append(notes[-1])

fingering = get_fingering(notes)

if fingering:
    print(*fingering)
else:
    print(-1)

",linear,"constructive algorithms,dp",1011
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))
PLACE=[None]*(n+1)
for i in range(n):
    PLACE[A[i]]=i

al=n


WINLIST=[None]*(n+1)#0:そこに行けば必敗,1:そこにいけば必勝

def move(n,al):
    place=PLACE[n]
    for i in range(place,-1,-n):
        if A[i]>n and WINLIST[A[i]]==""B"":
            WINLIST[n]=""A""
            return
            
    for i in range(place,al,n):
        if A[i]>n and WINLIST[A[i]]==""B"":
            WINLIST[n]=""A""
            return 

    else:
        WINLIST[n]=""B""
        return 
   

for j in range(n,0,-1):
    move(j,al)


ANS=""""
for i in A:
    ANS+=WINLIST[i]

print(ANS)
",linear,"brute force,dp,games",632
"n = int(input())
a = [int(s) for s in input().split()]
ans = [None]*n

def get(p):
    # print(ans)
    if ans[p] is not None:
        return ans[p]
    elif a[p] == 1:
        ans[p] = ""A""
    elif a[p] == n:
        ans[p] = ""B""
    else:
        for i in range(p+a[p], n, a[p]):
            if a[i] > a[p]:
                if get(i) == ""B"":
                    ans[p] = ""A""
                    return ans[p]
        for i in range(p-a[p], -1, -a[p]):
            if a[i] > a[p]:
                if get(i) == ""B"":
                    ans[p] = ""A""
                    return ans[p]
        ans[p] = ""B""
    return ans[p]

if n == 1:
    print(""B"")
else:
    for i in range(n-1, -1, -1):
        get(i)
    print(''.join(ans))",linear,"brute force,dp,games",726
"n = int(input())
l = [0]+list(map(int,input().split()))
from collections import defaultdict
ans = ['A','B']
x = defaultdict(int)
table = [-1]*(n+1)
for i in range(1,n+1):
	x[l[i]] = i

table[x[n]] = 1
for i in range(n-1,0,-1):
	if(x[i]-i>0):
		for j in range(x[i],0,-i):
			if(l[j]>i):
				if(table[j]==1):
					table[x[i]] = 0
					break
	if(n-i>0 and table[x[i]]==-1):
		for j in range(x[i],n+1,i):
			if(l[j]>i):
				if(table[j]==1):
					table[x[i]] = 0
					break

	if(table[x[i]]==-1):
		table[x[i]] = 1

for i in table[1:]:
	print(ans[i],end='')",linear,"brute force,dp,games",552
"def wins(mem, l, pos):
	# print(pos)
	if mem[pos] != 0:
		return mem[pos] == 1

	val = l[pos]

	lo = pos - val
	while lo >= 0:
		if l[lo] > val and not wins(mem, l, lo):
			mem[pos] = 1
			return True
		lo -= val

	hi = pos + val
	while hi < len(l):
		if l[hi] > val and not wins(mem, l, hi):
			mem[pos] = 1
			return True
		hi += val

	mem[pos] = 2
	return False



n = int(input())
l = list(map(int, raw_input().split()))

mem = [0 for i in range(n)]
ans = """"
for i in range(n):
	ans += ""A"" if wins(mem, l, i) else ""B""

print(ans)
",linear,"brute force,dp,games",534
"from collections import deque
from sys import stdin
lines = deque(line.strip() for line in stdin.readlines())

def nextline():
    return lines.popleft()

def types(cast, sep=None):
    return tuple(cast(x) for x in strs(sep=sep))

def ints(sep=None):
    return types(int, sep=sep)

def strs(sep=None):
    return tuple(nextline()) if sep == '' else tuple(nextline().split(sep=sep))

def main():
    # lines will now contain all of the input's lines in a list
    n = int(nextline())
    a = ints()
    bs = set()
    moves = {}
    for i in range(n):
        moves[a[i]] = list(a[j] for j in range(i % a[i], n, a[i]) if a[j] > a[i])
    winners = {}
    for i in range(n, 0, -1):
        winner = 'A' if any(winners[j] == 'B' for j in moves[i]) else 'B'
        if winner == 'B':
            bs.add(i)
        winners[i] = winner
    print(''.join(winners[ai] for ai in a))


if __name__ == '__main__':
    main()
",linear,"brute force,dp,games",916
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))
  
 
",linear,"brute force,dp,games",269
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()

s1 = input() +'0'
s2 = input() +'0'

res = 0

i = 0
while i<N:
    if s1[i] != s2[i]:
        if s1[i+1] == s2[i] and s2[i+1] == s1[i]:
            res+=1
            i+=2
            continue
        res+=1
    i+=1
print(res)

    






",linear,"dp,greedy,strings",966
"n = int(input())
a = input()
b = input()

c = [10**10 for i in range(n + 10)]

c[0] = 0 if a[0] == b[0] else 1

for i in range(1, n):
    if a[i] == b[i]:
        c[i] = c[i - 1]
    elif a[i] == b[i - 1] and a[i - 1] == b[i]:
        c[i] = (1 + c[i - 2] if i > 1 else 1)
    c[i] = min(c[i], c[i - 1] + 1)
    
print(c[n - 1])
",linear,"dp,greedy,strings",329
"def read():
    return [c == '1' for c in input()]
n = int(input())
a, b = read(), read()

res = 0

i = 0
while i + 1 < n:
    if a[i] != b[i] and a[i] != a[i+1] and b[i] != b[i+1]:
        a[i] = b[i]
        a[i+1] = b[i+1]
        res += 1
        i += 2
    else:
        i += 1

for i in range(n):
    if a[i] != b[i]:
        res += 1

print(res)",linear,"dp,greedy,strings",352
"n = int(raw_input())
a = list(raw_input())
b = list(raw_input())

ans = 0

for i in range(n - 1):
    if a[i] == b[i]:
        continue
    if a[i + 1] == b[i + 1]:
        continue

    if a[i] == b[i + 1] and a[i + 1] == b[i]:
        a[i], a[i + 1] = a[i + 1], a[i]
        ans += 1


for i in range(n):
    ans += a[i] != b[i]

print(ans)
",linear,"dp,greedy,strings",343
"n = int(input())
a = list(map(int, input()))
b = list(map(int, input()))

ans = sum(q != w for q, w in zip(a, b))
i = 1
while i < n:
    aii = a[i - 1]
    ai = a[i]
    bii = b[i - 1]
    bi = b[i]
    if aii + ai == 1 and bii + bi == 1 and aii != bii and ai != bi:
        ans -= 1
        i += 1
    i += 1

print(ans)
",linear,"dp,greedy,strings",322
"n = int(input())
a = list(input())
b = list(input())

count = 0
skip_next = False
for idx in range(n - 1):
    if skip_next:
        skip_next = False
        continue
    if a[idx] != b[idx] and a[idx] == b[idx + 1] and a[idx + 1] == b[idx]:
        count += 1
        a[idx] = b[idx]
        a[idx + 1] = b[idx + 1]
        skip_next = True

for idx in range(n):
    if a[idx] != b[idx]:
        count += 1
        # a[idx] = b[idx]

print(count)
",linear,"dp,greedy,strings",449
"n = int(input())
a = list(input())
b = list(input())

ans = 0
i = 0
while i < n:
    if a[i] != b[i]:
        ans += 1
        if i < n - 1 and a[i] == b[i + 1] and b[i] == a[i + 1]:
            i += 1
    i += 1
print(ans)
",linear,"dp,greedy,strings",224
"n  = int(input())

a  = list(map(int, input().strip()))
b  = list(map(int, input().strip()))

res = 0

for j in range(n-1):
    if (a[j]== 0) and (a[j+1 ] == 1 ) and (b[j] == 1) and (b[j+1 ] == 0):
        res +=1
        a[j ] = 1
        a[j+1] = 0
        
    elif  (a[j]== 1) and (a[j+1] ==0 ) and (b[j] == 0) and (b[j+1 ] == 1):
        res +=1
        a[j ] = 0
        a[j+ 1] = 1 

for j in range(n):
    if a[j] != b[j]:
        res += 1

print(res)",linear,"dp,greedy,strings",459
"n = int(input())
a = str(input())
b = str(input())
k = True
result = 0
for i in range(n):
    if a[i] == b[i]:
        if k == False:
            result += 1
        k = True
    else:
        if k == False and z != a[i]:
            result += 1
            k = True
        elif k == False and z == a[i]:
            result += 1
        else:
            k = False
            z = a[i]
if k == False:
    result += 1
print(result)",linear,"dp,greedy,strings",431
"n = int(input())
graph = [set() for tr in range(n+2)]
i = 1
while i < n:
	x, y = map(int, input().split())
	graph[x].add(y)
	graph[y].add(x)
	i += 1
a = iter(map(int, input().split()))
try:
	assert next(a) == 1
	q = [1]
	for v in q:
		gv = graph[v]
		gv1 = tuple(gv)
		for tr2 in gv1:
			u = next(a)
			assert u in gv
			gv.remove(u)
			graph[u].remove(v)
			q.append(u)
	print(""Yes"")
except AssertionError:
	print(""No"")
",linear,"dfs and similar,graphs,shortest paths,trees",421
"from collections import deque
n = int(input())
graph = [set() for i in range(n + 1)]
graph[0].add(1)
graph[1].add(0)
for i in range(n - 1):
    x, y = map(int, input().split())
    graph[x].add(y)
    graph[y].add(x)
a = list(map(int, input().split()))
q = deque()
q.append(0)
i = 0
par = [0] * (n + 1)
while len(q):
    v = q.popleft()
    graph[v].discard(par[v])
    l = len(graph[v])
    if graph[v] != set(a[i:i + l]):
        print(""No"")
        break
    for j in range(i, i + l):
        q.append(a[j])
        par[a[j]] = v
    i += l
else:
    print(""Yes"")",linear,"dfs and similar,graphs,shortest paths,trees",566
"from collections import deque

def removeUsed(adj, used):
    to_remove = []
    for s in adj:
        if used[s]: to_remove.append(s)
    for s in to_remove:
        adj.remove(s)

def solve(a, s): # a - adjacenct list [[],[]...], seq
    if s[0] != 0: return False
    q = deque()
    q.append(0)
    i, n, cur = 1, len(a), -1
    used = [False]*n
    used[0] = True
    while i < n:
        if cur == -1:
            cur = q.popleft()
            removeUsed(a[cur], used)
        if not a[cur]:
            cur = -1
            continue
        cur_s = s[i]
        i += 1
        if cur_s not in a[cur]:
            return False # not connected
        a[cur].remove(cur_s)
        q.append(cur_s)
        used[cur_s] = True
    return True

n = int(input())
a = [set() for i in range(n)]
for i in range(n-1):
    u, v = map(int, input().split())
    a[u-1].add(v-1)
    a[v-1].add(u-1)
s = [(x-1) for x in map(int, input().split())]
print(""Yes"" if solve(a, s) else ""No"")
",linear,"dfs and similar,graphs,shortest paths,trees",976
"from collections import defaultdict

n = int(raw_input())
t = defaultdict(list)
for _ in range(n - 1):
    u, v = map(int, raw_input().split())
    t[u].append(v)
    t[v].append(u)
a = list(map(int, raw_input().split()))
o = {a_: i for i, a_ in enumerate(a)}

i = 0
q = [1]
lv = {1: 0}
par = {1: 1}
while i < len(q):
    u = q[i]
    i += 1
    for v in t[u]:
        if v not in lv:
            lv[v] = lv[u] + 1
            q.append(v)
            par[v] = u

depths = defaultdict(list)
for x in a:
    depths[lv[x]].append(o[par[x]])

ans = a[0] == 1
if ans:
    for d in depths.values():
        if not all(d[i] <= d[i + 1] for i in range(len(d) - 1)):
            ans = False
            break

if ans:
    l = [lv[x] for x in a]
    ans = all(l[i] <= l[i + 1] for i in range(len(l) - 1))

print(('No', 'Yes')[ans])
",linear,"dfs and similar,graphs,shortest paths,trees",822
"n=int(input())
dict1={}
for i in range(n-1):
    x,y=map(int,input().split())
    try:
        dict1[y].append(x)
    except:
        KeyError
        dict1[y]=[x]
    try:
        dict1[x].append(y)
    except:
        KeyError
        dict1[x]=[y]    
arr=list(map(int,input().split()))
if(arr[0]!=1):
    print(""No"")
else:
    j=0
    i=1
    flag=0
    while(i<n and j<n):
        if(arr[j] in dict1[arr[i]]):
            i+=1
        else:
            j+=1
    if(i!=n and j==n):
        print('No')
    else:
        print('Yes')

",linear,"dfs and similar,graphs,shortest paths,trees",537
"n = int(input())

d = {}

for i in range(n-1):
	a,b = map(int,input().split())

	try:
		d[a].append(b);
	except:
		d[a] = [b]
	try:
		d[b].append(a);
	except:
		d[b] = [a]

array = list(map(int,input().split()))
flag=0;

if array[0]==1:

	i = 1;
	j = 0;

	while ( j < n and i < n ):
		if ( array[j] in d[array[i]] ):
			i+=1;
		else:
			j+=1;
	if j==n and i!=n:
		flag=1;
else:
	flag=1;

if flag==1:
	print(""No"")
else:
	print(""Yes"")",linear,"dfs and similar,graphs,shortest paths,trees",432
"from sys import stdin
from collections import deque
n=int(stdin.readline())
g=dict()
for i in range(n-1):
    a,b=map(int,stdin.readline().strip().split())
    g.setdefault(a, set()).add(b)
    g.setdefault(b, set()).add(a)
a=[int(x) for x in stdin.readline().strip().split()]
ans = True
if n > 1 and a[0] == 1:
    q=deque()
    m=[0]*(n+1)
    q.append(1)
    m[1]=1
    right=1
    while len(q) > 0 and ans:
        first = q.popleft()
        cnt = 0
        for v in g[first]:
            if m[v] == 0:
                cnt += 1
        for i in range(right, right+cnt):
            if m[a[i]] == 0 and a[i] in g[first]:
                m[a[i]] = 1
                q.append(a[i])
            else:
                ans = False
                break
        right += cnt
else:
    ans = a[0] == 1
if ans:
    print(""Yes"")
else:
    print(""No"")
",linear,"dfs and similar,graphs,shortest paths,trees",846
"from sys import stdin
from collections import deque
n=int(stdin.readline())
g=dict()
for i in range(n-1):
    a,b=map(int,stdin.readline().split())
    g.setdefault(a, set()).add(b)
    g.setdefault(b, set()).add(a)
a=[int(x) for x in stdin.readline().split()]
ans = True
if n > 1 and a[0] == 1:
    q=deque()
    m=[0]*(n+1)
    q.append(1)
    m[1]=1
    right=1
    while len(q) > 0 and ans:
        first = q.popleft()
        cnt = 0
        for v in g[first]:
            if m[v] == 0:
                cnt += 1
        for i in range(right, right+cnt):
            if m[a[i]] == 0 and a[i] in g[first]:
                m[a[i]] = 1
                q.append(a[i])
            else:
                ans = False
                break
        right += cnt
else:
    ans = a[0] == 1
if ans:
    print(""Yes"")
else:
    print(""No"")
",linear,"dfs and similar,graphs,shortest paths,trees",830
"from collections import Counter
n, k = map(int, input().split())
c = Counter(input())
ans = min(c[chr(ord('A') + i)] for i in range(k))
print(k * ans)
",linear,"implementation,strings",151
"read = lambda: map(int, input().split())
n, k = read()
s = input()
c = [0] * 26
for i in range(n):
    if s[i] <= chr(ord('A') + k - 1):
        c[ord(s[i]) - ord('A')] += 1
print(min(c[:k]) * k)",linear,"implementation,strings",195
"n, k = map(int, input().split(' '))
s = input()
m = 10 ** 10
for i in range(k):
    c = chr(ord('A') + i)
    m = min(m, s.count(c))
print(m * k)",linear,"implementation,strings",145
"ct = [0]*26

n, k =[int(i) for i in input().split()]
s = input()

for i in s:
    ct[ord(i)-ord('A')]+=1

print(min(ct[:k])*k)
",linear,"implementation,strings",127
"import sys
import string


def ria():
    return [int(i) for i in input().split()]


n, k = ria()
mp = {}
for i in string.ascii_uppercase[:k]:
    mp[i] = 0
for i in input():
    if i in mp:
        mp[i] += 1
print(min(mp.values())*k)",linear,"implementation,strings",235
"n, k = map(int, input().split())
count = [0] * k
for c in input():
    count[ord(c) - ord(""A"")] += 1
print(k * min(count))

",linear,"implementation,strings",124
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())
from collections import Counter

alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

n, k = mi()
s = input().strip()
c = Counter(s)
mn = 10 ** 9
for ch in alpha[:k]:
    mn = min(mn, c[ch])
print(mn * k)
",linear,"implementation,strings",303
"from collections import Counter


if __name__ == ""__main__"":
    n, k = map(int, input().split())
    s = input()
    c = Counter(s)
    min_symbols = min(c[chr(ord(""A"") + i)] for i in range(k))
    print(min_symbols * k)
",linear,"implementation,strings",222
"n, k = map(int, input().split())
s = list(input())
a = ord('A')
cnt = [0] * k
for ch in s:
    cnt[ord(ch) - a] += 1
print(k * min(cnt))",linear,"implementation,strings",136
"import sys
import string


def ria():
    return [int(i) for i in input().split()]


n = ria()[0]
ar = ria()

if n == 1:
    print(ar[0])
    exit(0)

onlyNegs = True
onlyPos = True

if max(ar) >= 0:
    onlyNegs = False
if min(ar) <= 0:
    onlyPos = False

if onlyNegs:
    print(abs(sum(ar)) + max(ar) * 2)
    exit(0)

if onlyPos:
    print(abs(sum(ar)) - min(ar) * 2)
    exit(0)

print(sum([abs(i) for i in ar]))
",linear,"dp,greedy,implementation",419
"n = int(input())
a = list(map(int, input().split()))
if n == 1:
	print(a[0])
else:
	prod_minus = False
	for i in range(n - 1):
		if a[i] * a[i + 1] <= 0:
			prod_minus = True
			break
	Min_abs = float(""inf"")
	Sum = 0
	for num in a:
		Sum += abs(num)
		if abs(num) < Min_abs:
			Min_abs = abs(num)

	if prod_minus:
		print(Sum)
	else:
		print(Sum - 2 * Min_abs)",linear,"dp,greedy,implementation",360
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except ModuleNotFoundError:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()

za = getIntList()
if N==1:
    print(za[0])
    sys.exit()
t1 = max(za)
t2 = min(za)
if t2>=0:
    print(sum(za) - 2*t2)
    sys.exit()
if t1<=0:
    print(2*t1 - sum(za))
    sys.exit()

res = 0
for x in za:
    res+= abs(x)

print(res)







",linear,"dp,greedy,implementation",971
"import sys
import os

def solve(slimes):
    if len(slimes) == 1:
        return slimes[0]

    havePos = False
    haveNeg = False

    for s in slimes:
        if s > 0:
            havePos = True
        elif s < 0:
            haveNeg = True

    if havePos and haveNeg:
        return sum(map(abs, slimes))
    elif not havePos:
        m = max(slimes)
        return sum(list(map(abs, slimes))) + 2 * m
    elif not haveNeg:
        m = min(slimes)
        return sum(list(map(abs, slimes))) - 2 * m
    else:
        return 0

def main():
    n = int(input())
    slimes = list(map(int, input().split()))
    print(solve(slimes))


if __name__ == '__main__':
    main()",linear,"dp,greedy,implementation",676
"#Problem D: Slime

n = int(input())

a = input().split()

for i in range(n):
    a[i] = int(a[i])

if(n==1):
    print(a[0]) #Obvious Case
else:
    sm = 0
    havePositive = False
    haveNegative = False

    for c in a:
        if(c==0):
            haveNegative = True
            havePositive = True
        elif(c>0):
            havePositive = True
            sm += c
        else:
            haveNegative = True
            sm -= c

    if(haveNegative and havePositive):
        print(sm) #Final Answer
    else:
        for i in range(n):
            a[i] = abs(a[i])
        #Get the minimum
        ans = sum(a)
        low = a[0]
        for c in a:
            low = min(low,c)
        #Final Answer
        print(ans-2*low)
",linear,"dp,greedy,implementation",741
"n=int(input())
A=list(map(int,input().split()))

if n==1:
    print(A[0])

elif n==2:
    print(abs(A[0]-A[1]))

else:
    SUM=0
    for i in range(n):
        SUM+=abs(A[i])
    ANS=0

    for i in range(n-1):
        if ANS<SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1]):
            ANS=SUM-abs(A[i])-abs(A[i+1])+abs(A[i]-A[i+1])

    print(ANS)
",linear,"dp,greedy,implementation",345
"n = int(input())
arr = list(map(int, input().strip().split()))
k = min(arr)
h = max(arr)
s = 0
for i in arr:
    if i >= 0:
        s += i
    else:
        s -= i

if n == 1:
    print(arr[0])
elif ((k < 0 and h >= 0)):
    print(s)
else:
    if (k >= 0):
        print(s - 2 * k)
    else:
        print(s + 2 * h)",linear,"dp,greedy,implementation",316
"n = int(input())
xs = [int(x) for x in input().split()]
prefix = [-1 for i in range(n)]
suffix = [-1 for i in range(n)]
prefix[0] = 0
pre_has_neg = [False for i in range(n)]
suffix[-1] = 0
suf_has_neg = [False for i in range(n)]
for i in range(n):
	if i == 0:
		prefix[i] = xs[i]
	else:
		prefix[i] = prefix[i-1] + xs[i]
for i in reversed(range(n)):
	if i == n-1:
		suffix[i] = xs[i]
	else:
		suffix[i] = suffix[i+1] + xs[i]
for i in range(n):
	if i == 0:
		pre_has_neg[i] = xs[i] <= 0
	else:
		pre_has_neg[i] = pre_has_neg[i-1] or xs[i] <= 0
for i in reversed(range(n)):
	if i == n-1:
		suf_has_neg[i] = xs[i] <= 0
	else:
		suf_has_neg[i] = suf_has_neg[i+1] or xs[i] <= 0

prebignum = [None for i in range(n)]
sufbignum = [None for i in range(n)]
for i in range(n):
	if i == 0:
		prebignum[i] = xs[i]
	else:
		prebignum[i] = min(prebignum[i-1], xs[i])
for i in reversed(range(n)):
	if i == n-1:
		sufbignum[i] = xs[i]
	else:
		sufbignum[i] = min(sufbignum[i+1], xs[i])

neg_pre = [100000 for i in range(n)]
neg_suf = [100000 for i in range(n)]

for i in range(n):
	if i == 0:
		neg_pre[i] = min(xs[i], -xs[i])
	else:
		neg_pre[i] = neg_pre[i-1] + min(xs[i], -xs[i])

for i in reversed(range(n)):
	if i == n-1:
		neg_suf[i] = min(xs[i], -xs[i])
	else:
		neg_suf[i] = neg_suf[i+1] + min(xs[i], -xs[i])

ans = -100000000000000000
for i in range(n):
	#print(i, ""----"")
	tans = xs[i]
	if i == 0:
		pass
	elif pre_has_neg[i-1]:
		tans -= neg_pre[i-1]
	else:
		tans += prefix[i-1]
		tans -= prebignum[i-1]*2

	if i == n-1:
		pass
	elif suf_has_neg[i+1]:
		tans -= neg_suf[i+1]
	else:
		tans += suffix[i+1]
		tans -= sufbignum[i+1]*2
		#print(suffix[i+1], sufbignum[i+1])
	ans = max(ans, tans)

print(ans)",linear,"dp,greedy,implementation",1698
"#from random import random, randint
#from sys import stdout

#n, k = map(int, input().split())
n = int(input())

if n==1:
    a = input()
    print(a)
else:    
    a = list(map(int, input().split()))
    b = [abs(i) for i in a]
    if min(a)*max(a) > 0:
        print(sum(b)-2*min(b))
    else:
        print(sum(b))
",linear,"dp,greedy,implementation",318
"n = int(input())
a = list(map(int, input().split()))
mx = -1
for step, elem in enumerate(a):
    if elem > mx + 1:
        print(step + 1)
        exit(0)
    else:
        mx = max(mx, elem)
print(-1)
",linear,implementation,202
"n = int(input())
a = [int(i) for i in input().split()]
c = 0
for i in range(n):
    if a[i] > c:
        print(i+1)
        break
    else:
        c = max(a[i]+1, c)
else:
    print(-1)
",linear,implementation,187
"n = int(input())
a = list(map(int, input().split()))

mex = -1
for i in range(n):
    if a[i] <= mex:
        continue
    elif a[i] == mex + 1:
        mex += 1
    else:
        print(i+1)
        exit()
print(-1)",linear,implementation,215
"n = int(input())
arr = list(map(int, input().split()))
arr1 = [arr[0]]
m = -1
for i, v in enumerate(arr):
    if v > m + 1:
        print(i+1)
        break
    m = max(m, v)
else:
    print(-1)

",linear,implementation,196
"import sys
a = list(map(int, sys.stdin.readlines()[1][:-1].split()))
mx = 0
for i in range(len(a)):
	if a[i] > mx:
		print(i+1)
		sys.exit(0)
	mx = max(mx,a[i] + 1)
print(-1)",linear,implementation,174
"n = int(input())
a = list(map(int, input().split()))
mx = -1
ans = -1
for i in range(n):
    if a[i] > mx+1:
        ans = i+1
        break
    else:
        mx = max(mx, a[i])
print(ans)",linear,implementation,188
"from math import *
#n,k=map(int,input().split())
#A = list(map(int,input().split()))
n=int(input())
A = list(map(int,input().split()))
ans =-1
maxs = 0
for j in range(n):
    if(A[j] > maxs):
        ans = j+1
        break
    else:
        maxs = max(maxs,A[j]+1)
print(ans)",linear,implementation,276
"n = int(input())
a = list(map(int, input().split()))
max_el = -1;
er = -1;
for i in range(len(a)):
    if a[i] - max_el > 1:
        er = i + 1;
        break
    if a[i] > max_el:
        max_el = a[i]

print(er)
",linear,implementation,214
"n = int(input())
a = list(map(int, input().split()))
s = 0

for j, i in enumerate(a):
    if i > s:
        print(j + 1)
        exit()
    if i == s:
        s += 1

print(-1)
",linear,implementation,177
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(200001)] 
pp=[0]*200001
def SieveOfEratosthenes(n=200000): 
      
    # Create a boolean array ""prime[0..n]"" and initialize 
    #  all entries it as true. A value in prime[i] will 
    # finally be false if i is Not a prime, else true. 
    
    p = 2
    while (p * p <= n): 
          
        # If prime[p] is not changed, then it is a prime 
        if (prime[p] == True): 
              
            # Update all multiples of p 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
#---------------------------------running code------------------------------------------
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",linear,"greedy,implementation",8661
"from collections import defaultdict
n,k=map(int,input().split())
arr=list(map(int,input().split()))
xors=defaultdict(int)
xors[0]=1
comp=(1<<k)-1
xor=0
ans=n*(n+1)//2
for a in arr:
    xor^=a
    if(xors[xor]>xors[comp^xor]):
        xor^=comp
    ans-=xors[xor]
    xors[xor]+=1
print(ans)",linear,"greedy,implementation",290
"from collections import defaultdict
n, k = map(int, input().split())
a = [0] + list(map(int, input().split()))
h = defaultdict(int)
for i in range(n):
	a[i + 1] ^= a[i]
for i in range(n + 1):
	h[min(a[i] ^ ((1 << k) - 1), a[i])] += 1
ans = 0
for x, t in h.items():
	a = t // 2
	b = t - a
	ans += a * (a - 1) // 2 + b * (b - 1) // 2
ans = (n * (n + 1)) // 2 - ans
print(ans)
",linear,"greedy,implementation",374
"n, k = map(int, raw_input().split())
a = map(int, raw_input().split())
for i in range(n):
    ai = a[i]
    nai = ((1<<k) - 1)^ai
    if nai < ai:
        a[i] = nai

from collections import Counter
C = Counter()
C[0] += 1
S = 0
cnt = 0
for j, ai in enumerate(a):
    nai = ((1<<k) - 1)^ai
    v1, v2 = C[S^ai], C[S^nai]
    if v1 <= v2:
        cnt += j + 1 - v1
        S ^= ai
        C[S] += 1
    else:
        cnt += j + 1 - v2
        S ^= nai
        C[S] += 1
print(cnt)
    
",linear,"greedy,implementation",485
"from math import *
#n,k=map(int,input().split())
#A = list(map(int,input().split()))
n,k = map(int,input().split())
ans = [0] * n
#^xor
lul = 2**k - 1
A = list(map(int,input().split()))
ans[0]  = A[0]
for j in range(1, n):
    ans[j] = ans[j-1]^A[j]
#print(ans)
d = dict()
for j in range(n):
    if ans[j] in d:
        d[ans[j]]+=1;
    else:
        d[ans[j]] = 1
#print(d)
ans =0
def huy(n):
    return n*(n-1)//2
for j in d:
    now = d[j]
    #print(d[j],j)
    xor = lul^j
    cur = now

    if xor in d :

        now2 = d[xor]
        #print(now,xor)
        cur += now2



        ans += huy(cur//2+cur%2)
        ans+=huy(cur//2)
        if j ==0:
            ans+=2*(cur//2)
    else:
        if(j==0 or xor ==0):
            ans+= 2*(cur//2)
        ans += 2*huy(cur // 2 + cur % 2)
        ans += 2*huy(cur // 2)
print(huy(n+1) - ans//2)",linear,"greedy,implementation",850
"def add(num):
    if(num<=1):
        return 0
    return (num*(num-1))//2
    
    
n,k=map(int,input().split())

a=list(map(int,input().split()))
pre=[a[0]]
base=(2**(k))-1
hb=2**(k-1)
for i in range(1,n):
    pre.append(a[i]^pre[-1])
    
cnt=dict()
cnt[0]=[0,0]

for i in range(n):
    if(pre[i]>=hb):
        if(base-pre[i] not in cnt):
            cnt[base-pre[i]]=[0,0]
        cnt[base-pre[i]][1]+=1
    else:
        if(pre[i] not in cnt):
            cnt[pre[i]]=[0,0]
        cnt[pre[i]][0]+=1
cnt1=0
#print(pre)
#print(cnt)
for i in cnt.values():
    sum1=i[0]+i[1]
    cnt1+=add(sum1//2)
    cnt1+=add((sum1+1)//2)
cnt1+=sum(cnt[0])//2
#print(cnt1)
print((n*(n+1))//2 - cnt1)
    
    

    
",linear,"greedy,implementation",705
"from collections import defaultdict
n,k = map(int,input().split())
arr = list(map(int,input().split()))
xors = defaultdict(int)
xors[0]=1
comp = (1<<k)-1
ans = n*(n+1)//2
xor = 0
for a in arr:
	xor^=a
	if xors[xor]>xors[comp^xor]:
		xor^=comp
	ans-=xors[xor]
	xors[xor]+=1
print(ans)",linear,"greedy,implementation",283
"n, k = [int(i) for i in input().split()]
d = dict()
d[0] = 1
x = 0
for i in [int(i) for i in input().split()]:
    x ^= i
    v = min(x, (1 << k) - x - 1)
    if v not in d.keys():
        d[v] = 0
    d[v] += 1
ans = 0
for k, v in d.items():
    c1 = v // 2
    c2 = v - c1
    ans += c1 * (c1 - 1) // 2 + c2 * (c2 - 1) // 2
print(n * (n - 1) // 2 + n - ans)
",linear,"greedy,implementation",360
"n,k=list(map(int,input().split()))
arr=list(map(int,input().split()))
newarr=[0]

for num in arr:
  newarr+=[newarr[-1]^num]
dic={}
for num in newarr:
  x=(min(num,2**k-1-num),max(num,2**k-1-num))
  if x in dic:
    dic[x]+=1
  else:
    dic[x]=1
ans=0
for elem in dic:
  m=dic[elem]
  half=m//2
  ans+=half*(half-1)/2
  half=m-half
  ans+=half*(half-1)/2
ans=n*(n+1)/2-ans
print(int(ans))
  
    
",linear,"greedy,implementation",398
"#!/usr/bin/python
# encoding:UTF-8
# Filename:Base.py

import sys
import random
import copy
from itertools import permutations, combinations
from math import sqrt, fabs, ceil
from collections import namedtuple

# ------Util Const--------

in_file_path = ""input.txt""
output_file_path = ""output.txt""

SUBMIT = True


def get_array(x, initial=None):
    dimension = len(x)
    if dimension == 1:
        return [copy.deepcopy(initial) for _ in range(x[0])]
    else:
        return [get_array(x[1:], initial) for _ in range(x[0])]


def read_num(fin, num_type=int):
    tmp_list = [num_type(x) for x in fin.readline().strip().split()]
    if len(tmp_list) == 1:
        return tmp_list[0]
    else:
        return tuple(tmp_list)

def read_num_list(fin, num_type=int):
    return [num_type(x) for x in fin.readline().strip().split()]


# def solve(fin):
#     n = read_num(fin)
#     ans_set = None
#     for i in range(n):
#         tmp_list = read_num_list(fin)
#         if ans_set == None:
#             ans_set = set(tmp_list[1:])
#         else:
#             ans_set &= set(tmp_list[1:])
#
#     print(' '.join([str(x) for x in ans_set]))

# def solve(fin):
#     n, m = read_num(fin)
#     a = [0] * m
#     b = [0] * int(sqrt(n))
#     for i in range(1, n + 1):
#         a[i * i % m] += 1
#
#     ans = 0
#     for x in range(m):
#         y = (m - x) % m
#         ans += a[x] * a[y]
#     print(ans)

# def BFS_count(x, chs, count):
#     q = []
#     q.append(x)
#     while (q)
#     return count[x]

def solve(fin):
    n = read_num(fin)
    f = read_num_list(fin)
    new_f = [0] + f
    for i in range(0, n):
        new_f[i] -= 1
    f = new_f
    # print(f)
    chs = get_array([n], [])
    for i, p in enumerate(f):
        if p >= 0:
            chs[p].append(i)
    # print(chs)
    q = [x for x in range(0, n) if not chs[x]]
    vis = [0] * n
    count = [0] * n
    while q:
        x = q.pop(0)
        if not chs[x]:
            count[x] = 1
        if f[x] >= 0:
            vis[f[x]] += 1
            # print(vis[f[x]], len(chs[f[x]]))
            if vis[f[x]] == len(chs[f[x]]):
                q.append(f[x])
            count[f[x]] += count[x]


    # print(chs)
    count = sorted(count)
    print(' '.join([str(x) for x in count]))

if __name__ == '__main__':
    if SUBMIT:
        solve(sys.stdin)
    else:
        solve(open(in_file_path, 'r'))
",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",2379
"n = int(input())
if n == 1:
    print(1)
else:
    adj = [[] for i in range(n+10)]
    s = input().split()
    for i in range(2,n+1):
        pi = int(s[i-2])
        adj[i].append(pi)
        adj[pi].append(i)
        
    num = 1
    curr = [1]
    nextcurr = []
    disco = [1]
    visited = {1:True}
    while num < n:
        for v in curr:
            for w in adj[v]:
                if w not in visited:
                    nextcurr.append(w)
                    visited[w] = True
                    disco.append(w)
                    num += 1
        curr = nextcurr
        nextcurr = []

    nl = {}
    nlvals = {}
    for v in disco[::-1]:
        nl[v] = max(sum(nl.get(w,0) for w in adj[v]),1)
        nlvals[nl[v]] = nlvals.get(nl[v],0)+1
    colors = {}
    leaves = nlvals[1]
    colors[1] = leaves
    for c in range(2, leaves+1):
        colors[c] = colors[c-1] + nlvals.get(c,0)

    ans = """"
    j = 1
    for i in range(1, n+1):
        while colors[j] < i:
            j += 1
        ans += str(j) + ' '
    print(ans.strip())
",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",1053
"n = int(input())
p = [0,0] + [int(w) for w in input().split()]

d = [0] * (n+1)

for i in range(n, 1, -1):
    if d[i] == 0:
        d[i] = 1
    d[p[i]] += d[i]

if n == 1:
    d[1] = 1

d = d[1:]
d.sort()

print(*d)
",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",218
"from operator import itemgetter
#int(input())
#map(int,input().split())
#[list(map(int,input().split())) for i in range(q)]
#print(""YES"" * ans + ""NO"" * (1-ans))
n = int(input())
if n == 1:
    print(1)
else:
    pi = list(map(int,input().split()))
    ai = [1] * (n+1)
    ai[0] = 10**9
    for i in pi:
        ai[i] = 0
    for i in range(n-2,-1,-1):
        ai[pi[i]] += ai[i+2]
    ai.sort()
    for i in range(n):
        print(ai[i],end="" "")
",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",448
"n = int(input())
tr = {}
p = [int(s) for s in input().split()]
for i in range(n-1):
    if not tr.get(p[i]-1):
        tr[p[i]-1] = []
    tr[p[i]-1].append(i+1)
# print(tr)
lc = [-1 for i in range(n)]
def get_lc(i):
    if lc[i] == -1:
        if tr.get(i):
            lc[i] = 0
            for j in tr[i]:
                lc[i] += get_lc(j)
        else:
            lc[i] = 1
    return lc[i]
for i in range(n-1, -1, -1):
    get_lc(i)
print(*sorted(lc))",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",458
"n = int(input())
p = [0,0] + [int(w) for w in input().split()]
d = [0] * (n+1)

for i in range(n, 1, -1):
    if d[i] == 0:
        d[i] = 1
    d[p[i]] += d[i]
if n == 1:
    d[1] = 1
d = d[1:]
d.sort()
print(*d)",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",213
"n=int(input())
fa=[0,0]+list(map(int,input().split()))
delta=[0]*(n+1)
suml=[0]*(n+1)
for i in range(n,0,-1):
	if suml[i]==0:
		suml[i]=1
	delta[suml[i]]+=1
	suml[fa[i]]+=suml[i]

for i in range(1,n+1):
	delta[i]+=delta[i-1]
ans=0
for i in range(1,n+1):
	while delta[ans]<i:
		ans+=1
	print(""%d ""%ans,end="""")
print(""\n"")",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",320
"n=int(input())
p=[0,0]+list(map(int,input().split()))
d=[0]*(n+1)
for i in range(n,1,-1):
    if d[i]==0:
        d[i]=1
    d[p[i]]+=d[i]
if n==1:
    d[1]=1
d=d[1:]
d.sort()
print(*d)",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",185
"from sys import stdin
from collections import Counter

class Node:
    def __init__(self,val):
        self.val=val
        self.forw=set()
        self.cou=0

    def __str__(self):
        return f'{self.val} {self.forw} {self.cou}'

n=int(stdin.readline())
arr=[Node(i) for i in range(1,n+1)]
c=2
for x in map(int,stdin.readline().split()):
    arr[x-1].forw.add(c)
    c+=1


dct=Counter()
lst = [1]
while len(lst):
    fl = 0
    for i in arr[lst[-1]-1].forw:
        lst.append(i)
        fl = 1
        break
    if fl:
        arr[lst[-2]-1].forw.remove(i)
    if not fl:
        if arr[lst[-1]-1].cou ==0:
            arr[lst[-1]-1].cou=1
        dct[arr[lst[-1]-1].cou]+=1
        k=arr[lst.pop()-1].cou
        if len(lst):arr[lst[-1]-1].cou+=k

y=1
for _ in range(n):
    while not dct[y]:
        y+=1
    dct[y]-=1
    print(y,end=' ')",linear,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",849
"import sys
import string
from math import gcd
import getpass
import math
from decimal import Decimal


def ria():
    return [int(i) for i in input().split()]


if getpass.getuser() != 'frohenk':
    filename = 'half'
    # sys.stdin = open('input.txt')
    # sys.stdout = open('output.txt', 'w')
else:
    sys.stdin = open('input.txt')

n = ria()[0]
if n == 1:
    print(1)
    exit(0)

if n == 2:
    print(1, 2)
    exit(0)

if n == 3:
    print(1, 1, 3)
    exit(0)

ar = [0] * 30

for i in range(30):
    ar[i] = n // (2 ** i) - n // (2 ** (i + 1))
sd = 0
for i in range(30):
    if sd == n - 1:
        if n==(2**i):
            print(2**i)
        else:
            print(n-n%(2**(i-1)))
        exit(0)
    for j in range(ar[i]):
        print(2 ** i, end=' ')
        sd += 1
",linear,"constructive algorithms,math",785
"n = int(input())
if n == 1:
	print(""1"")
elif n == 2:
	print(""1 2"")
else:
	base = 1
	gap = 2
	cur = base
	next = 1
	ans = ''
	for i in range(n - 1):
		ans += str(base) + ' '
		next = cur
		cur += gap
		if cur > n:
			base *= 2
			gap *= 2
			cur = base
		next = max(next, cur)
	ans += str(next)
	print(ans)",linear,"constructive algorithms,math",305
"from sys import stdout
def main():
    n = int(raw_input())
    k = 2
    a = []
    m = n
    while 1:
        t = n / k
        if t <= 1:
            k /= 2
            a.extend([k] * m)
            a[-1] = n / k * k
            break
        a.extend([k / 2] * (m - t))
        m = t
        k *= 2
    stdout.write(' '.join(map(str, a)))
main()
",linear,"constructive algorithms,math",350
"def solve(n,k):
    print(1*k,end = ' ')
    if n==2:
        print(2*k,end = ' ')
    if n == 3:
        print(k,3*k,end = ' ')
    else:
        temp = n//2
        if(n%2 == 0): temp -= 1
        print((str(k)+' ')*temp,end='')
        if(n>3):
            solve(n//2,k*2)

n = int(input())
solve(n,1)",linear,"constructive algorithms,math",304
"n = int(input())
a = [0]*n;

def fun(n,ptr1):
	global a

	if n == 1:
		a[ptr1] = 1;

	elif n == 2:

		a[ptr1] = 1;
		ptr1+=1;
		a[ptr1] = 2;
	elif n == 3:
		a[ptr1] = 1;
		ptr1 +=1;
		a[ptr1] = 1;
		ptr1+=1;
		a[ptr1]=3;
	
	else:
		itera = n - n//2;
		
		for i in range(itera):
			a[ptr1] = 1;
			ptr1+=1;

		fun(n//2,ptr1);
		for i in range((n//2)):
			a[ptr1] = 2*a[ptr1];
			ptr1+=1;

fun(n,0);
for i in a:
	print(i,end="" "");

print();",linear,"constructive algorithms,math",438
"from math import log2
n = int(input())
if n == 1:
    print(1)
    exit()
elif n == 3:
    print(1, 1, 3)
    exit()
l = [1] * (n // 2)
if n % 2 == 1:
    l.append(1)

xn = int(log2(n))
tmp = n - len(l)
for i in range(2, xn+1):
    fn = tmp // 2
    if tmp % 2 == 1:
        fn += 1
    tmp -= fn
    l += ([pow(2, i-1)] * fn)
l.append((n // pow(2, xn - 1)) * pow(2, xn - 1))
print(' '.join(str(i) for i in l))",linear,"constructive algorithms,math",410
"n = int(input())
res = []
multiplier = 1
while n > 1:
	new_n = n // 2
	res.extend((multiplier,)*(n-new_n))
	if n == 3:
		multiplier *= 3
	else:
		multiplier *= 2
	n = new_n
res.extend((multiplier,)*n)
print(*res)
",linear,"constructive algorithms,math",213
"n, s = map(int, input().split())
res = 0
for i in range(n, 0, -1):
    res += s//i
    s = s % i
print(res)",linear,"greedy,implementation,math",107
"n, s = map(int, input().split())
cnt = 0
for i in range(n, 0, -1):
    cnt += s // i
    s %= i
print(cnt)",linear,"greedy,implementation,math",106
"n, s = map( int, input().split() )

ans = 0
while s > 0:
    a = s // n
    s -= n * a
    ans += a
    n -= 1

print( ans )
",linear,"greedy,implementation,math",125
"def init_input():
    import os
    from sys import stdin
    it = iter(os.read(stdin.fileno(), 10 ** 7).split())
    return lambda: next(it).decode(), lambda: int(next(it)), lambda: float(next(it))
ns, ni, nf = init_input()

MOD = 10 ** 9 + 7

n, q = ni(), ni()
s = 'x' + ns()
c = [0] * (n + 1)
for i in range(1, n + 1):
    c[i] = c[i - 1] + (s[i] == '1')

p2 = [1] * (2 * n + 1)
for i in range(1, 2 * n + 1):
    p2[i] = p2[i - 1] * 2 % MOD

out = []
for qq in range(q):
    l, r = ni(), ni()
    o = c[r] - c[l - 1]
    z = (r - l + 1) - o
    ans = (p2[o + z] - 1 - p2[z] + 1) % MOD
    out.append(ans)
print(*out, sep='\n')
",linear,"greedy,implementation,math",630
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

def add(a,b):
	return (a+b)%1000000007

def mul(a,b):
	return (a*b)%1000000007

def sub(a,b):
	return (a-b+1000000007)%1000000007

def qpow(a, b):
	r = 1
	k = a
	for i in range(17):
		if b & (1<<i):
			r = mul(r, k)
		k = mul(k, k)
	return r

n, q = mints()
a = list(minp())
c = [0]*(n+1)
for i in range(n):
	c[i+1] = c[i] + int(a[i])
for i in range(q):
	l, r = mints()
	k = (r-l+1)
	o = c[r]-c[l-1]
	z = sub(qpow(2,o),1)
	print(mul(z,qpow(2,k-o)))",linear,"greedy,implementation,math",609
"import sys
mod=10**9+7
n,q=map(int,sys.stdin.readline().split())
S=sys.stdin.readline().strip()
LR=[list(map(int,sys.stdin.readline().split())) for i in range(q)]

LIST=[0]
for s in S:
    if s==""1"":
        LIST.append(LIST[-1]+1)
    else:
        LIST.append(LIST[-1])

def count(m,n,mod):
    return (pow(2,m,mod)-1)*pow(2,n,mod)%mod

for l,r in LR:
    print(count(LIST[r]-LIST[l-1],r-l+1-LIST[r]+LIST[l-1],mod))
    
",linear,"greedy,implementation,math",423
"import sys
input_file = sys.stdin
C = (10**9+7)
[n, q] = list(int(i) for i in input_file.readline().split())
temp = input_file.readline()
lst = []
for char in temp[:-1]:
    lst.append(int(char))
    
new_lst = [(0, 0)]
for i in lst:
    if i == 0:
        new_lst.append((new_lst[-1][0]+1, new_lst[-1][1]))
    else:
        new_lst.append((new_lst[-1][0], new_lst[-1][1]+1))

ls = [1]
for i in range(n):
    ls.append(ls[-1]*2 % C)

for line in input_file:
    [l, r] = list(int(i) for i in line[:-1].split())
    q = (new_lst[r][0] - new_lst[l-1][0], new_lst[r][1] - new_lst[l-1][1])
    print((ls[sum(q)] - ls[q[0]]) % C)

",linear,"greedy,implementation,math",627
"from sys import stdin,stdout
n,q=map(int,input().split())
mod=1000000007
o=[]
s=[]
r=m=0
a=input()
for i in a:
    if i=='0':
        r+=1
    else:
        m+=1
    o.append(r)
    s.append(m)
z=[1]
#print(o)
for i in range(100000):
    z.append((z[-1]*2)%mod)
for j in range(q):
    l,r=(int(j) for j in stdin.readline().split())
    m=r-l+1
    zs=o[r-1]-o[l-1]+(a[l-1]=='0')
    os=m-zs
    #print(zs,os)
    if zs!=0:
        print((((z[os]-1)%mod)*((z[zs])%mod))%mod)
    else:
        print(((z[os]-1)%mod))
    
    
    
",linear,"greedy,implementation,math",530
"n, q = map(int, raw_input().split())
l = raw_input()
cnt1, cnt0 = [0]*(n+1), [0]*(n+1)
mod = 10**9 + 7
for i in range(len(l)):
	if l[i] == '1':
		cnt1[i+1] = cnt1[i] + 1
		cnt0[i+1] = cnt0[i]
	else:
		cnt0[i+1] = cnt0[i] + 1
		cnt1[i+1] = cnt1[i]
pow2 = [1]
for i in range(1, 10**5 + 10):
	pow2.append((2*pow2[-1])%mod)
for i in range(q):
	l, r = map(int, raw_input().split())
	ones = cnt1[r] - cnt1[l-1]
	zeroes = cnt0[r] - cnt0[l-1]
	t1 = (pow2[ones] - 1)%mod
	t2 = (((pow2[ones] - 1)%mod)*(pow2[zeroes] - 1))%mod
	print((t1+t2)%mod)",linear,"greedy,implementation,math",535
"# Causes TLE
# C++17 implemention -> 1062c.cpp

MOD = 1000000007

def main():
    buf = input()
    buflist = buf.split()
    n = int(buflist[0])
    q = int(buflist[1])
    buf = input()
    x = buf
    sum_list = [0] # sentinel / one indexing
    for i, deliciousness in enumerate(x):
        sum_list.append(int(deliciousness) + sum_list[i])
    enjoyment_list = [0]
    for i in range(n):
        enjoyment_list.append((enjoyment_list[i] * 2 + 1) % MOD)
    query_list = []
    for i in range(q):
        buf = input()
        buflist = buf.split()
        l = int(buflist[0]) # one indexing
        r = int(buflist[1]) # one indexing
        query_list.append((l, r))
    for i, query in enumerate(query_list):
        l = query[0]
        r = query[1]
        banhmi_count = r - l + 1
        delicious_count = sum_list[r] - sum_list[l - 1]
        non_delicious_count = banhmi_count - delicious_count
        enjoyment = 0
        # main part
        if delicious_count == 0:
            enjoyment = 0
        else:
            enjoyment += enjoyment_list[delicious_count]
            enjoyment += (enjoyment_list[banhmi_count] - enjoyment_list[delicious_count] - enjoyment_list[non_delicious_count])
            enjoyment = enjoyment % MOD
        print(enjoyment)

if __name__ == '__main__':
    main()
",linear,"greedy,implementation,math",1312
"from sys import *
mod=1000000007
n,q=map(int,stdin.readline().split())
s=str(stdin.readline())
arr=[]
count=0
for i in s:
	if(i=='1'):
		count+=1
	arr.append(count)
#q=int(input())
ansarr=[]
for i in range(q):
	x,y=map(int,input().split())
	if(x==1):
		total1=arr[y-1]
	else:
		total1=arr[y-1]-arr[x-2]
	total0=(y-x+1-total1)	
	ans=pow(2,y-x+1,mod)%mod
	ans=((((ans%mod)-(pow(2,total0,mod)%mod))%mod)+mod)%mod	
	ansarr.append(ans)
stdout.write('\n'.join(map(str, ansarr)))",linear,"greedy,implementation,math",472
"import math 

if __name__ == '__main__':
	
	n,q = [int(x) for x in raw_input().split()]
	qq = str(raw_input())
	s = [ int(x) for x in qq] 
	prefix = [0]*n
	prefix[0]= s[0]
	temp = [0]*(n+1)
	temp[0]=1
	mod = (pow(10,9)//1)+7
	for i in range(1,n):
		prefix[i] += prefix[i-1] + s[i]
		temp[i] =( 2*(temp[i-1]%mod) )%mod

	temp[n] = (2*(temp[n-1]%mod))%mod
	ansarr=[]
	while q> 0:
		q-=1
		l,r = [int(x)-1 for x in raw_input().split()]
		a = prefix[r]-prefix[l]+s[l]
		d = r-l+1
		val1 = temp[d] 
		val2 = temp[d-a] 
		# val2 = val2%mod
		ansarr.append((val1-val2)%mod)
	print('\n'.join(map(str, ansarr)))",linear,"greedy,implementation,math",602
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()
#print(N)
re = 0
for i in range(2,N):

    t = N // i -1
    re += t * i

print(re *4)






",linear,"dfs and similar,graphs,implementation,math",895
"import sys
n=int(input())

if n<=3:
    print(0)
    sys.exit()

score=0
import math
def score(x):
    ANS=0
    xr=math.ceil(math.sqrt(x))

    LIST=[]
    for i in range(1,xr+3):
        if x%i==0:
            LIST.append(i)
            LIST.append(x//i)

    LIST=sorted(list(set(LIST)))

    for l in LIST[1:-1]:
        ANS+=x//l

    return ANS

ANS=0
for i in range(4,n+1):
    ANS+=score(i)

print(ANS*4)
    

",linear,"dfs and similar,graphs,implementation,math",419
"i = input()
i = int(i)
v = 0
g = 2
s = 4
while g <= i:
	while s <= i:
		v = v + int(s / g * 4)
		s = s + g
	g = g + 1
	s = g * 2
print(str(v))",linear,"dfs and similar,graphs,implementation,math",142
"n = int(input())
r = 0
i = 2
while i*2 <=n:
	a = int(n/i)
	r += (a+2)*(a-2+1)/2
	i += 1
print(int(4*r))
",linear,"dfs and similar,graphs,implementation,math",104
"n = int(input())
sum = 0

for i in range(2, n + 1):  
  j = 2
  while(j * i <= n):
    sum += i
    j += 1
print(4 * sum)",linear,"dfs and similar,graphs,implementation,math",121
"from math import sqrt, floor, ceil
n = int(input())

ran = list(range(2, 1+n//2))
xx = [ d*(n//d-1)     for d in ran]
print(sum(xx)*4)
",linear,"dfs and similar,graphs,implementation,math",135
"n = int(input())
rang = list(range(2,n//2+1))
a = [i*(n//i-1) for i in rang]
print(sum(a)*4)
",linear,"dfs and similar,graphs,implementation,math",93
"from __future__ import division
from sys import stdin, stdout


def write(x):
    stdout.write(str(x) + ""\n"")


n = int(stdin.readline())
out = 0
for i in range(2, n + 1):
    out += 4 * (n // i - 1) * i

write(out)
",linear,"dfs and similar,graphs,implementation,math",216
"n=int(input())
c=0
for j in range(2,1+n//2):
	e=0
	i=n//j
	e+=(i*(i+1))//2
	e-=1
	if e>0:
		c+=e
print(c*4)",linear,"dfs and similar,graphs,implementation,math",107
"import math
n,k=map(int,input().split())
edges=[]
for i in range(n-1):
    edges.append(tuple(map(int,input().split())))
degreelist=[]
for i in range(min(k+1,math.floor(math.log2(n))+10)):
    degreelist.append({})
degrees=degreelist[0]
for i in range(1,n+1):
    degrees[i]=0
for guy in edges:
    degrees[guy[0]]+=1
    degrees[guy[1]]+=1
small=[]
center=None
done=False
for i in range(k):
    if not done:
        small=[]
        for guy in degrees:
            if degrees[guy]==2:
                print(""No"")
                done=True
                break
            if degrees[guy]==3:
                small.append(guy)
                if center==None: 
                    center=guy
                elif center!=guy:
                    print(""No"")
                    done=True
                    break
            elif degrees[guy]>1:
                small.append(guy)
        degrees=degreelist[i+1]
        if center!=None and center not in small:
            if not done:
                print(""No"")
            done=True
            break
        elif len(small)==0:
            if not done:
                print(""No"")
            done=True
            break
        for guy in small:
            degrees[guy]=0
        for guy in edges:
            if guy[0] in degrees and guy[1] in degrees:
                degrees[guy[0]]+=1
                degrees[guy[1]]+=1
        for guy in degrees:
            if degrees[guy]>1 and degreelist[i][guy]!=degrees[guy]:
                if not done:
                    print(""No"")
                done=True
                break
    else:
        break
if not done:
    if len(degreelist[-1])==1:
        print(""Yes"")
    else:
        print(""No"")",linear,"dfs and similar,graphs,shortest paths",1705
"from sys import exit
n = int(input())
if n <= 10:
    for i in range(n):
        print(0, i)
    exit()
# 1 4 7 10
print(0, 0)
for i in range(4, n + 1, 3):
    k = (i // 3) * 2
    print(k, 0)
    print(k - 1, 1)
    print(k - 2, 2)
k = ((n + 1) // 3) * 2
if n % 3 == 0:
    print(k - 1, 1)
    print(k - 2, 2)
elif n % 3 == 2:
    print(k - 2, 2)






# Thu Jan 07 2021 13:59:45 GMT+0300 (Москва, стандартное время)
",linear,constructive algorithms,418
"n = int(input())
k = n // 3
ans = []
for i in range(k):
    ans += [(0, 2 * i)]
    ans += [(1, 2 * i + 1)]
    ans += [(2, 2 * i)]
for i in range(n % 3):
    ans += [(-1000, -1000 + i)]
res = """"
for i in ans:
    res += "" "".join(map(str, i)) + ""\n""
print(res)",linear,constructive algorithms,260
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()
#print(N)

zz = ( (1,-1), (0,2), (1,-1) )
now = (0,0)
for i in range(N):
    print(now[0],now[1])
    now = ( now[0] + zz[i%3] [0] , now[1] + zz[i%3][1])

    




",linear,constructive algorithms,879
"n = int(input())

print('0 0')
n-=1
k = n // 2
p = n - k
x = -k//2
while k > 0:
    if x != 0:
        print(x, 0)
        k -= 1
    x += 1
y = -p//2
while p > 0:
    if y != 0:
        print(0, y)
        p -= 1
    y += 1",linear,constructive algorithms,224
"n = int(input())
ans = [(0, 0)]
for i in range(1, n):
    ans.append((0, i))
    ans.append((i, 0))
    ans.append((0, -i))
    ans.append((-i, 0))
for i in range(n):
    print(str(ans[i][0]) + ' ' + str(ans[i][1]))
",linear,constructive algorithms,216
"n= int(input())
for i in range(n//3):
    print(-2,1+i*2)
for i in range(n-n//3):
    print(1,i)",linear,constructive algorithms,96
"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

n = int(input())
above = n // 3
below = n - above
for i in range(above):
    print(2 * i + 1, 3)
for i in range(below):
    print(i, 0)
",linear,constructive algorithms,184
"n=int(input())
for i in range(n//3):
    print(2*i,0)
    print(2*i+1,0)
    print(2*i+1,3)
for i in range(n%3):
    print(2*(n//3)+i,0)",linear,constructive algorithms,136
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n = ii()
a = li()
b = li()

done = set()
j = 0
ans = []
for i in range(n):
    if b[i] in done:
        ans.append(0)
    else:
        c = 0
        while a[j] != b[i]:
            done.add(a[j])
            j += 1
            c += 1
        done.add(a[j])
        j += 1
        ans.append(c + 1)
print(*ans)",linear,"implementation,math",424
"n = int(input())
ai = list(map(int,input().split())) 
bi = list(map(int,input().split()))
ai2 = [0] * (n+1)
n2 = 0
for i in range(n):
    num = 0
    if ai2[bi[i]] != 1:
        for j in range(n2,n):
            ai2[ai[j]] = 1
            if ai[j] == bi[i]:
                num = j + 1 - n2
                n2 = j + 1
                break
    print(num,end="" "")",linear,"implementation,math",362
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
ha={}
for i in range(n):
    ha[a[i]]=i
removed=0
out=""""
for i in range(n):
    if ha[b[i]]<removed:
        out+=""0 ""
    else:
        out+=str(ha[b[i]]-removed+1)+"" ""
        removed=ha[b[i]]+1
print(out[:-1])",linear,"implementation,math",293
"n=int(input())
A=list(map(int,input().split()))
B=list(map(int,input().split()))



REVA=[None]*(n+1)

for i in range(n):
    REVA[A[i]]=i+1

top=0
ANSLIST=[]

for b in B:
    if REVA[b]>top:
        ANSLIST.append(REVA[b]-top)
        top=REVA[b]
    else:
        ANSLIST.append(0)

for ans in ANSLIST:
    print(ans,end="" "")

    
",linear,"implementation,math",334
"def main():
    n = int(input())

    arr = list(map(int, input().split()))
    numb = [0 for i in range(n + 1)]
    for i in range(len(arr)):
        numb[arr[i]] = i + 1

    brr = list(map(int, input().split()))
    ind = 0
    for c in brr:
        total = 0
        num = numb[c]
        if num > ind:
            total = num - ind
            ind = num
        print(total, end=' ')

main()",linear,"implementation,math",396
"
def main():
    n = int(input())
    a = list(map(lambda x: int(x), input().split("" "")))
    b = list(map(lambda x: int(x), input().split("" "")))
    now = 0
    ans = []
    h = set()
    for i in range(n):
        count = 0
        while b[i] not in h:
            h.add(a[now])
            now += 1
            count += 1
        ans.append(str(count))
    print("" "".join(ans))


if __name__ == '__main__':
    main()
",linear,"implementation,math",421
"# Author:      Divesh Uttamchandani
# Institution: BITS Pilani
n = int(input().strip())
a = list(map(int,input().strip().split()))
b = list(map(int,input().strip().split()))
pos_of = [-1 for i in range(2*10**5+1)]

for i,ele in enumerate(a):
    pos_of[ele]=i+1

current_pos = 0
ans=[]
for i in b:
    if(pos_of[i]>current_pos):
        ans.append(pos_of[i]-current_pos)
        current_pos=pos_of[i]
    else:
        ans.append(0)

print(' '.join(list(map(str,ans))))
# <> with <3 using Termicoder:
# https://termicoder.github.io
",linear,"implementation,math",532
"n = int(input())
a = input().split()
d = {}
k = 0
for i in range(len(a)):
    d[a[i]] = i
for s in input().split():
    if d[s] != -1:
        c = d[s]
        print(c - k + 1, end=' ')
        for i in range(k, c + 1):
            d[a[i]] = -1
        k = c + 1
    else:
        print(0, end=' ')
    #print(d)
    #print(a)
",linear,"implementation,math",327
"n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
a=a[::-1]
c=[0]*n
bk=[]
for i in range(n):
    co=0
    if c[b[i]-1]==0:
        while a[-1]!=b[i]:
            co+=1
            c[a[-1]-1]=1
            a.pop()
        co+=1
        c[a[-1]-1]=1
        a.pop()
    bk.append(co)
print(*bk)
                
        ",linear,"implementation,math",349
"n, m = map(int, input().split())
xs = list(map(int, input().split()))
ts = list(map(int, input().split()))

ps = [x for x, t in zip(xs, ts) if t == 0]
ds = [x for x, t in zip(xs, ts) if t == 1]
ans = [0] * m

di = 0
for pi, p in enumerate(ps):
    while di < m - 1 and abs(ds[di] - p) > abs(ds[di + 1] - p):
        di += 1

    if di >= m:
        ans[m - 1] += n - pi
        break

    ans[di] += 1


print(' '.join(map(str, ans)))
",linear,"implementation,sortings",435
"n, m = map(int, input().split())
xs = [int(k) for k in input().split()]
ts = [int(k) for k in input().split()]
pos = [-1 for i in range(n + m)]
if ts[0]:
    pos[0] = 0
for i in range(1, n + m):
    pos[i] = pos[i - 1]
    if ts[i]:
        pos[i] += 1
result = [0 for i in range(m)]
left = 0
leftC = 0
right = 0
rightC = 0
for i in range(n + m):
    if ts[i] == 0:
        right = max(i, right)
        while right + 1 < n + m and not ts[right]:
            right += 1
        mP, mD = 0, 20000000
        if ts[left]:
            mP = pos[left]
            mD = xs[i] - xs[left]
        if ts[right] and xs[right] - xs[i] < mD:
            mD = xs[right] - xs[i]
            mP = pos[right]
        result[mP] += 1
    else:
        left = i
print(*result)
",linear,"implementation,sortings",759
"import sys, math
from sys import stdin, stdout

rem = 10 ** 9 + 7
inf=10**18
sys.setrecursionlimit(10 ** 6 + 7)
#from resource import *; setrlimit(RLIMIT_STACK, (RLIM_INFINITY, RLIM_INFINITY))
take = lambda: map(int, stdin.readline().split())
from heapq import heappush, heappop, heapify
from collections import deque
from bisect import *


n,m=take()
arr=take()
check=take()
cnt=[0 for i in range(n+m)]

left=[-1 for i in range(n+m)]
right=[-1 for i in range(n+m)]
prev=-1
for i in range(n+m):
    if check[i]==0:
        left[i]=prev
    else:
        prev=i
prev=-1
for i in range(n+m-1,-1,-1):
    if check[i]==0:
        right[i]=prev
    else:
        prev=i
for i in range(n+m):
    if check[i]==1:
        continue
    a=left[i]
    b=right[i]
    if a==-1 and b==-1:
        continue
    if a==-1 and b!=-1:
        cnt[b]+=1
    if a!=-1 and b==-1:
        cnt[a]+=1
    if a!=-1 and b!=-1:
        if abs(arr[i]-arr[a])<=abs(arr[i]-arr[b]):
            cnt[a]+=1
        else:
            cnt[b]+=1
ans=[]
for i in range(n+m):
    if check[i]==1:
        ans.append(str(cnt[i]))
stdout.write(' '.join(ans))


",linear,"implementation,sortings",1120
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

n,m = mints()
a = list(mints())
b = list(mints())
l = [None]*(n+m)
r = [None]*(n+m)
c = [0]*(n+m)
x = None
for i in range(len(a)):
	l[i] = x
	if b[i] == 1:
		x = i
x = None
for i in range(len(a)-1,-1,-1):
	r[i] = x
	if b[i] == 1:
		x = i
for i in range(len(a)):
	if b[i] == 0:
		aa = a[i]
		ll = l[i]
		rr = r[i]
		if ll == None:
			if rr != None:
				c[rr] += 1
		elif rr == None:
			c[ll] += 1
		else:
			if aa-a[ll] <= a[rr]-aa:
				c[ll] += 1
			else:
				c[rr] += 1

for i in range(len(a)):
	if b[i] == 1:
		print(c[i], end=' ')
",linear,"implementation,sortings",695
"def solve(n, m, x, t):
    r = [0] * n
    d = [0] * m
    ans = [0] * m
    cr = 0
    cd = 0
    for i in range(n+m):
        if t[i]:
            d[cd] = x[i]
            cd += 1
        else:
            r[cr] = x[i]
            cr += 1
    cn = 0
    for i in range(m-1):
        mid = (d[i] + d[i+1]) // 2
        while cn < n and r[cn] <= mid:
            cn += 1
            ans[i] += 1
    ans[-1] += n - sum(ans)
    return ' '.join(str(i) for i in ans)


def main():
    n, m = [int(i) for i in input().split()]
    x = [int(i) for i in input().split()]
    t = [int(i) for i in input().split()]
    print(solve(n, m, x, t))


main()
",linear,"implementation,sortings",645
"n,m = map(int,input().split())
xi = list(map(int,input().split()))
ti = list(map(int,input().split()))
ai = [0] * (m+2)
ar = [0] * (m+2)
ar[-1] = 10**11
ar[0] = -100000000000
j = 1
n2 = n + m
for i in range(n2):
    if ti[i] == 1:
        ar[j] = xi[i]
        j += 1
i1 = 0
i2 = 1
for i in range(n2):
        if ti[i] == 1:
            i2 += 1
            i1 += 1
            continue
        num = xi[i] - ar[i1]
        num2 = ar[i2] - xi[i]
        if num <= num2:
            ai[i1] += 1
        else:
            ai[i2] += 1
for i in range(1,m+1):
    print(ai[i],end="" "")
",linear,"implementation,sortings",579
"n, m = map(int, input().split())
dist = [int(x) for x in input().split()]
taxi = [int(x) for x in input().split()]
dists = {}
d = []
for person in range(len(taxi)):
    if taxi[person]:
        dists[dist[person]] = 0
        d.append(dist[person])
start = 0
d.append(10**11)
for person in range(len(taxi)):
    if taxi[person] == 0:
        while dist[person] > d[start + 1]:
            start += 1
        if abs(dist[person] - d[start]) <= abs(dist[person] - d[start + 1]):
            dists[d[start]] += 1
        else:
            dists[d[start + 1]] += 1
for d in dists:
    print(dists[d] if d!=10**11 else '', end=' ')

",linear,"implementation,sortings",628
"import sys

num_riders, _ = map(int, next(sys.stdin).split())

houses = map(int, next(sys.stdin).split())
is_rider = map(int, next(sys.stdin).split())

current_left_driver = None
current_citizens = []

result = []

for house, is_rider in zip(houses, is_rider):
    if is_rider:
        if current_left_driver is None:
            result.append(len(current_citizens))
        else:
            result.append(0)
            for citizen in current_citizens:
                if abs(citizen - current_left_driver) <= abs(citizen - house):
                    result[-2] += 1
                else:
                    result[-1] += 1

        current_citizens = []
        current_left_driver = house
    else:
        current_citizens.append(house)

result[-1] += len(current_citizens)

print(' '.join(map(str, result)))
",linear,"implementation,sortings",816
"n, m = map(int, input().split())
arr = list(map(int, input().split()))
t = list(map(int, input().split()))
taxi = list()
for i in range(len(arr)):
    if t[i] == 1:
        taxi.append(arr[i])
taxi2 = list()
kek = 1
for i in range(len(taxi) - 1):
    taxi2.append([kek, taxi[i] + (taxi[i + 1] - taxi[i]) // 2])
    kek = taxi[i] + (taxi[i + 1] - taxi[i]) // 2 + 1
taxi2.append([kek, arr[-1]])
taxi3 = [0] * m
j = 0
for i in range(len(arr)):
    if arr[i] > taxi2[j][1]:
        j += 1
    if t[i] != 1:
        taxi3[j] += 1
print("" "".join(map(str, taxi3)))
",linear,"implementation,sortings",558
"'''input
5
1 4 1 2 1
5
2 2 2 2 2

3
1 1 1
5
1 4 1 1 1

'''
n = int(input())
a = list(map(int, input().split()))
b = []
c = []
e = []
for i in range(n):
	if a[i] == 1:
		b += [i]
for i in range(n):
	if a[i] != 1:
		c += [[a[i], i]]
if not c:
	print(""NO"")
	exit(0)
ans = len(c)
for i in range(len(c) - 1):
	e += [(c[i][1], c[i + 1][1])]
	c[i][0] -= 1
	c[i + 1][0] -= 1
if b:
	e += [(b[-1], c[-1][1])]
	c[-1][0] -= 1
	b.pop()
	ans += 1
if b:
	e += [(b[-1], c[0][1])]
	c[0][0] -= 1
	b.pop()
	ans += 1
i = 0
while b:
	while i < len(c) and c[i][0] == 0:
		i += 1
	if i == len(c):
		print(""NO"")
		exit(0)
	e += [(b[-1], c[i][1])]
	c[i][0] -= 1
	b.pop()


print(""YES"", ans - 1)
print(len(e))
for (x, y) in e:
	print(x + 1, y + 1)
",linear,"constructive algorithms,graphs,implementation",722
"from __future__ import division
from sys import stdin, stdout

def write(x):
    stdout.write(str(x) + ""\n"")


n = int(stdin.readline())
a = map(int, stdin.readline().split())
assert n == len(a)
cap = [0] + a[:]

ones = []
others = []

for i in range(n):
    if a[i] == 1:
        ones.append(i + 1)
    else:
        others.append(i + 1)

if len(others) == 0:
    if len(ones) == 1:
        write(""YES 0"")
        write(""0"")
    else:
        write(""NO"")
    exit()

dia = len(others)
graph = []

for j in range(len(others) - 1):
    graph.append((others[j], others[j + 1]))
    cap[others[j]] -= 1
    cap[others[j + 1]] -= 1

if len(ones) > 0:
    this = ones.pop()
    graph.append((this, others[0]))
    cap[others[0]] -= 1
    dia += 1

if len(ones) > 0:
    this = ones.pop()
    graph.append((this, others[-1]))
    cap[others[-1]] -= 1
    dia += 1

done = False
for j in range(len(others)):
    while cap[others[j]] > 0:
        if len(ones) > 0:
            this = ones.pop()
            graph.append((this, others[j]))
            cap[others[j]] -= 1
        else:
            done = True
            break

    if done:
        break
if len(ones) > 0:
    write(""NO"")
else:
    write(""YES "" + str(dia - 1))
    write(len(graph))
    for a,b in graph:
        write(str(a) + "" "" + str(b))",linear,"constructive algorithms,graphs,implementation",1300
"
def solve():
    n = int(input())
    max_degs = [int(x) for x in input().split()]

    B = [[i+1, x] for i, x in enumerate(max_degs) if x >= 2]
    S = [[i+1, x] for i, x in enumerate(max_degs) if x < 2]

    if 2 + sum(b - 2 for _, b in B) < len(S):
        print('NO')
        return

    print('YES', len(B) + min(len(S), 2) - 1)
    print(n-1)

    # B edges
    for k in range(len(B) - 1):
        i, x = B[k]
        i_n, _ = B[k+1]
        print(i, i_n)
        B[k][1] -= 1
        B[k+1][1] -= 1

    k = 0
    for i, (s_idx, _) in enumerate(S):
        if i == 0:
            print(B[0][0], s_idx)
            B[0][1] -= 1
        elif i == 1:
            print(B[-1][0], s_idx)
            B[-1][1] -= 1
        else:
            while B[k][1] == 0:
                k += 1
            print(B[k][0], s_idx)
            B[k][1] -= 1


solve()
",linear,"constructive algorithms,graphs,implementation",855
"n = int(input())
T = input().split(' ')
for i in range(n):
    T[i]=int(T[i])
L=[]
M=[]
t=0
ip=0
IP=[]
for i in range(n):
    if T[i]>=2:
        L.append(i+1)
        M.append(T[i])
        t+=T[i]
    else:
        ip+=1
        IP.append(i+1)
if t-(2*len(L)-2)<ip:
    print(""NO"")
else:
    for i in range(1, len(L)-1):
        M[i]-=2
    if len(L)>=2:
        M[0]-=1
        M[-1]-=1
    print(""YES"",end=' ')
    if ip==0:
        print(len(L)-1)
    elif ip==1:
        print(len(L))
    else:
        print(len(L)+1)
    print(len(L)-1+ip)
    if ip>=1:
        print(IP[0], end=' ')
        print(L[0])
        M[0]-=1
    if ip>=2:
        print(IP[-1], end=' ')
        print(L[-1])
        M[-1]-=1
    k=1
    ind=0
    while k < ip-1:
        if M[ind]==0:
            ind+=1
        else:
            print(IP[k], end=' ')
            print(L[ind])
            M[ind]-=1
            k+=1
    for i in range(len(L)-1):
        print(L[i], end=' ')
        print(L[i+1])
",linear,"constructive algorithms,graphs,implementation",984
"n = int(input())
a = [int(s) for s in input().split()]
os = 0
oss = []
nos = 0
nos_0 = -1
nos_1 = -1
sumnos = 0
for i in range(n):
    if a[i] == 1:
        os += 1
        oss.append(i+1)
    else:
        sumnos += a[i]
        nos += 1
        if nos_0 == -1:
            nos_0 = i+1
        nos_1 = i+1

if os <= sumnos-(2*(nos-1)):
    es = []
    oss_i = 0
    ans = nos-1
    if os >= 1:
        ans += 1
        es.append((nos_0, oss[0]))
        oss_i += 1
    if os >= 2:
        ans += 1
        es.append((nos_1, oss[1]))
        oss_i += 1
    print(""YES"", ans)
    prev_nos = -1
    for i in range(n):
        if a[i] > 1:
            if prev_nos != -1:
                es.append((prev_nos+1, i+1))
            for j in range(a[i]-2):
                if oss_i >= os:
                    break
                es.append((i+1, oss[oss_i]))
                oss_i += 1
            prev_nos = i
    print(len(es))
    for e in es:
        print(*e)
else:
    print(""NO"")



",linear,"constructive algorithms,graphs,implementation",983
"import sys

n=int(input())
A=list(map(int,input().split()))

#import random
#A=[random.randint(1,3) for i in range(10)]
#n=len(A)
#A=[2, 1, 1, 1, 3, 1, 2, 3, 1, 3]
#n=10

if sum(A)<2*n-2:
    print(""NO"")
    sys.exit()

ONES=A.count(1)
print(""YES"",min(n-1,n-ONES+1))

NOONE=[]
for i in range(n):
    if A[i]!=1:
        NOONE.append([A[i],i+1])

#print(NOONE)
ANS=[]
for i in range(1,len(NOONE)):
    ANS.append((NOONE[i-1][1],NOONE[i][1]))
    NOONE[i-1][0]-=1
    NOONE[i][0]-=1

#print(NOONE,ANS)

NOONE=[[1,NOONE[-1][1]]]+NOONE[0:-1]+[[NOONE[-1][0]-1,NOONE[-1][1]]]

#print(NOONE)
LENNO=len(NOONE)

j=0
for i in range(n):
    while j<LENNO and NOONE[j][0]==0:
        j+=1
    if A[i]!=1:
        continue
    ANS.append((i+1,NOONE[j][1]))
    NOONE[j][0]-=1


print(len(ANS))
for a,b in ANS:
    print(a,b)
    
        
",linear,"constructive algorithms,graphs,implementation",826
"n=int(input())
a=list(map(int,input().split()))
leaf=[i+1 for i in range(n) if a[i]==1]
root_w=[i+1 for i in range(n) if a[i]!=1]
root_r=[a[i-1]-2 for i in root_w]
l_path=root_w
if(len(leaf)!=0):
    l_path=[leaf[0]]+l_path
    leaf=leaf[1:]
if(len(leaf)!=0):
    l_path=l_path+[leaf[0]]
    leaf=leaf[1:]

if sum(root_r)<len(leaf):
    print(""NO"")
else:
    print(""YES {}"".format(len(l_path)-1))
    print(n-1)
    for i in range(len(l_path)-1):
        print(""{} {}"".format(l_path[i],l_path[i+1]))
    for l in leaf:
        while(len(root_r)>0 and root_r[0]==0):
            root_w = root_w[1:]
            root_r = root_r[1:]
        print(""{} {}"".format(l,root_w[0]))
        root_r[0] = root_r[0]-1
",linear,"constructive algorithms,graphs,implementation",705
"n = int(input())
a = tuple(map(int, input().split()))
if n * 2 > sum(a) + 2:
	print(""NO"")
else:
	n1 = []
	on = []
	for i in range(n):
		if a[i] != 1:
			n1.append(i)
		else:
			on.append(i)
	print(""YES"", len(n1) + min(2, len(on)) - 1)
	print(n - 1)
	n1it = iter(n1)
	next(n1it)
	for v, u in zip(n1, n1it):
		print(v + 1, u + 1)
	if on:
		print(on.pop() + 1, n1[-1] + 1)
	if on:
		print(on.pop() + 1, n1[0] + 1)
	on = iter(on)
	for n11 in n1:
		for i in range(a[n11] - 2):
			try:
				print(n11 + 1, next(on) + 1)
			except StopIteration:
				break
		else:
			continue
		break
",linear,"constructive algorithms,graphs,implementation",576
"from collections import namedtuple
n = int(input())
vertex = namedtuple('vertex', ['degree', 'id'])
a, b, c = [], [], 0

rr = list(map(int, input().split()))

for i in range(n):
    tmp = rr[i]
    v = vertex(tmp, i + 1)
    if tmp > 1:
        a.append(v)
    else:
        b.append(v)
    c += tmp

if c < (n - 1)*2:
    print('NO')
else:
    if len(a) == 0:
        print('YES 1')
        print('1 2')
    else:
        print('YES', len(a) - 1 + min(2, len(b)))
        print(n - 1)
        for i in range(len(a)):
            if i == 0:
                continue
            print(a[i - 1].id, a[i].id)
        if len(b) > 0:
            print(b[0].id, a[0].id)
        if len(b) > 1:
            print(b[1].id, a[-1].id)
        j = 2
        for i in range(len(a)):
            if j >= len(b):
                yes = 1
                break
            k = a[i].degree - 2
            yes = 0
            for t in range(k):
                print(a[i].id, b[j].id)
                j += 1
                if j >= len(b):
                    yes = 1
                    break
            if yes == 1:
                break",linear,"constructive algorithms,graphs,implementation",1123
"from collections import Counter
n,c=map(int,input().split())
a=list(map(int,input().split()))
counter=Counter()
minus=0
count=a.count(c)
maxi=0
for i in range(n):
    if a[i]!=c:
        if counter[a[i]]<minus:
            counter[a[i]]=minus
        counter[a[i]]+=1
        maxi=max(maxi,counter[a[i]]+count-minus)
    else:
        minus+=1
print(max(maxi,minus))",linear,"binary search,dp,greedy",366
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def main():
    n,c = map(int,input().split())
    a = list(map(int,input().split()))
    nums = [[0] for _ in range(500001)]
    freq,minus = [0]*500001,0
    for i in a:
        if i == c:
            minus += 1
        else:
            freq[i] += 1
            nums[i].append(freq[i]-minus)
    tot = minus
    suff = [i[:] for i in nums]
    for i in range(500001):
        for j in range(len(nums[i])-2,0,-1):
            suff[i][j] = max(suff[i][j],suff[i][j+1])
    freq,ans = [0]*500001,tot
    for i in a:
        if i == c:
            continue
        freq[i] += 1
        ans = max(ans,suff[i][freq[i]]-nums[i][freq[i]]+1+tot)
    print(ans)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",linear,"binary search,dp,greedy",2436
"from __future__ import division
from sys import stdin, stdout
from collections import Counter

def write(x):
    stdout.write(str(x) + ""\n"")


n, c = map(int, stdin.readline().split())
a = map(int, stdin.readline().split())
assert len(a) == n

tel = Counter()
target_count_last = Counter()
targets = 0
best = 0


for num in a:
    if num == c:
        targets += 1
    else:
        since_last = targets - target_count_last[num]
        target_count_last[num] = targets
        tel[num] = max(0, tel[num] - since_last)
        tel[num] += 1
        best = max(best, tel[num])

write(targets + best)
",linear,"binary search,dp,greedy",599
"n, c = map(int, input().split())
res1 = [0] * 500001
res = 0
for ai in map(int, input().split()):
	res1[ai] = max(res1[ai], res1[c])
	res1[ai] += 1
	res = max(res, res1[ai] - res1[c])
print(res + res1[c])
",linear,"binary search,dp,greedy",205
"n, c = map(int, input().split())
cnt = [0] * 500005
ans = 0
for v in map(int, input().split()):
    if v == c:
        cnt[c] = cnt[c] + 1
    else:
        if cnt[v] < cnt[c]:
            cnt[v] = cnt[c]
        cnt[v] += 1
    ans = max(ans, cnt[v] - cnt[c])
print(ans + cnt[c])
",linear,"binary search,dp,greedy",281
"n,tar=[int(i) for i in input().split()]
a=[int(i) for i in input().split()]

from collections import defaultdict
d=defaultdict(lambda:[])
count=0
for i in range(n):
    d[a[i]].append(i)
    if a[i]==tar:
        count+=1

presum=[1 if a[0]==tar else 0]
for e in a[1:]:
    if e==tar:
        presum.append(presum[-1]+1)
    else:
        presum.append(presum[-1])

final = 0
for k,v in d.items():
    if k==tar:
        continue

    t=1
    tt=1
    for i in range(1,len(v)):
        ind=v[i]
        preind=v[i-1]

        t -= presum[ind] - presum[preind]
        t=max(t,0)
        t+=1
        tt=max(tt,t)

    final=max(final,tt)

print(final + count)",linear,"binary search,dp,greedy",659
"t=list(map(int,input().split()))
n=t[0]
c=t[1]
a=list(map(int,input().split()))
f=[]
for i in range(0,500001):
	f.append(0)
l=[]
for i in range(0,500001):
	l.append([0])
m=0
for i in range(n):
	l[a[i]].append(f[a[i]]-m)
	if a[i]==c:
		m+=1
	f[a[i]]+=1
	l[a[i]].append(f[a[i]]-m)
ma=0
for i in l:
	mi=0
	for j in i:
		if(j<mi):
			mi=j
		if(ma<j-mi):
			ma=j-mi
print(m+ma)",linear,"binary search,dp,greedy",372
"n,val=map(int,input().split());
a=[0]+list(map(int,input().split()));
suma=[0 for i in range(n+1)];
mx=0;
target=0;
for i in range(1,n+1):
	suma[i]=suma[i-1];
	mx=max(mx,a[i]);
	if (a[i]==val):
		target+=1;
		suma[i]+=1;

ans=0;
pre=[0 for i in range(mx+1)];
dp=[0];
for i in range(1,n+1):
	dp.append(max(1,1+dp[pre[a[i]]]-suma[i]+suma[pre[a[i]]]));
	if (a[i]!=val):
		ans=max(ans,dp[i]);
	pre[a[i]]=i;
print(ans+target);",linear,"binary search,dp,greedy",421
"n,c = map(int,input().split("" ""))
nums = list(map(int,input().split("" "")))
# c is the target number
# number of c values seen
cPast = 0
countC = 0

for value in nums:
	if value == c:
		countC += 1

def sawC(groupsList):
	for key,groups in groupsList.items():
		if groups[-1] < 0:
			groups[-1] -= 1
		else:
			groups += [-1]
	return groupsList

solution = countC
#other numbers, highest count stored in hash table
groupsList = {}
for num in nums:
	if num == c:
		groupsList = sawC(groupsList)
	elif num in groupsList.keys():
		if groupsList[num][-1] > 0:
			groupsList[num][-1] += 1
		else:
			groupsList[num] += [1]
	else:
		groupsList[num] = [1]

for key,groups in groupsList.items():
	# actually counting if good
	#print(""groups: "",groups)
	maxDiff = 1
	currDiff = 0
	newDiff = 0
	for group in groups:
		currDiff += group
		if group > currDiff:
			currDiff = group
		if currDiff > maxDiff:
			maxDiff = currDiff
	if maxDiff + countC > solution:
		solution = countC + maxDiff
print(solution)
	
						
			







",linear,"binary search,dp,greedy",1014
"
from itertools import permutations, chain

def get_plots(a,b):

  ax,ay = a
  bx,by = b

  for x in range(ax,bx,1 if ax < bx else -1):
    yield (x,ay)
  for y in range(ay,by,1 if ay < by else -1):
    yield (bx,y)

def solve(points):

  for a,b,c in permutations(points):
    ax,ay = a
    bx,by = b
    cx,cy = c
    if min(ax,bx) <= cx <= max(ax,bx) and min(ay,by) <= cy <= max(ay,by):
      return list(chain(get_plots(a,c), get_plots(c,b), [b]))

  def it():
    for a,b,c in permutations(points):
      ax,ay = a
      bx,by = b
      m = (ax,by)
      L = list(chain(get_plots(a,m),get_plots(b,m), get_plots(c,m), [m]))
      yield (len(L),L)

  return min(it())[1]



points = [tuple(map(int,input().split())) for _ in range(3)]

res = solve(points)
print(len(res))
for x,y in res:
  print(x,y)
",linear,"greedy,implementation",804
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

# B. Minimum Diameter Tree

from collections import Counter

n, s = mi()
d = Counter()
for i in range(n - 1):
    u, v = mi()
    d[u] += 1
    d[v] += 1

l = sum(v == 1 for v in d.values())
ans = s / l * 2
print('%.10f' % (ans,))
",linear,"greedy,implementation,trees",345
"n , s = map(int, input().split())
d = [0] * (n + 1)
cnt = 0
for i in range(0 , n - 1):
    a , b = map(int, input().split())
    d[a - 1] += 1
    d[b - 1] += 1
for i in range(0 , n):
    if(d[i] == 1):
        cnt += 1
print(2.0 * s / cnt)
        
",linear,"greedy,implementation,trees",250
"n,s=map(int,input().split())
a=[0]*(n+1)

if n==2:
  print(s)
  exit(0)

for _ in range(n-1):
  u,v=map(int,input().split())
  a[u]+=1
  a[v]+=1

print(2.0*s/a.count(1))",linear,"greedy,implementation,trees",169
"n,s=map(int,input().split())
degs=[0]*n
for i in range(n-1):
    a,b=map(int,input().split())
    degs[a-1]+=1
    degs[b-1]+=1
print(2*s/degs.count(1))",linear,"greedy,implementation,trees",152
"n , s = map(int,input().split())
a = [0] * (n+1)
for _ in range(n-1) :
    u , v=map(int, input().split())
    a[u] += 1
    a[v] += 1
print(2.0*s/a.count(1))",linear,"greedy,implementation,trees",158
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

from collections import Counter

n, s = mi()
d = Counter()
for i in range(n - 1):
    u, v = mi()
    d[u] += 1
    d[v] += 1

l = sum(v == 1 for v in d.values())
ans = s / l * 2
print('%.10f' % (ans,))",linear,"greedy,implementation,trees",316
"n,s = [int(x) for x in input().split()]
v=[ [] ]
for i in range(n):
	v.append([])
	
for i in range(n-1):
	a, b =[int(x) for x in input().split()]
	v[a].append(b)
	v[b].append(a)

ans =0
for i in range(1,n+1):
	if len(v[i])==1:
		ans+=1
	
print(2*s/ans)
",linear,"greedy,implementation,trees",253
"n, s = map(int, input().split())
l = [0 for i in range(n)]
for i in range(n-1):
	a, b = map(int, input().split())
	l[a-1]+=1
	l[b-1]+=1
count = 0
for i in range(n):
	if(l[i]==1):
		count+=1
print((s/count)*2)",linear,"greedy,implementation,trees",208
"n=int(input())
l=list(map(int,input().split()))
s=input()
water=0
grass=0
cgrass=0
time=0
seen=False
for i in range(n):
    if s[i]==""G"":
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
            cgrass+=dist
        else:
            dist-=water
            time+=2*water
            cgrass+=water
            water=0
            time+=3*dist
            grass+=dist
    elif s[i]==""W"":
        water+=l[i]
        time+=2*l[i]
        seen=True
    else:
        dist=l[i]
        if water>=dist:
            water-=dist
            time+=2*dist
        else:
            dist-=water
            time+=2*water
            water=0
            if cgrass>=dist:
                cgrass-=dist
                grass+=dist
                time+=3*dist
            else:
                dist-=cgrass
                grass+=cgrass
                time+=3*cgrass
                cgrass=0
                if grass>=dist:
                    grass-=dist
                    time+=3*dist
                else:
                    dist-=grass
                    time+=3*grass
                    grass=0
                    if seen:
                        time+=4*dist
                    else:
                        time+=6*dist
print(time)",linear,"constructive algorithms,greedy",1278
"n=int(input())
l=list(map(lambda x:int(x)*2,input().split("" "")))
t=list(map(lambda x:""GWL"".index(x),input()))
mins=[0 for i in range(0,n+1)]
for i in range(n-1,-1,-1):
	if t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)
	else:mins[i]=mins[i+1]+l[i]
curs=ans=st=0
for i in range(0,n):
	if(t[i]==0):
		curs+=l[i];ans+=l[i]*5
		if(curs>mins[i+1]):
			ol=(curs-mins[i+1])//2
			ol=min(ol,l[i])
			ans-=4*ol;curs-=2*ol
	if(t[i]==1):
		st=1;curs+=l[i];ans+=l[i]*3
	if(t[i]==2):
		if(curs<l[i]):
			ol=l[i]-curs;curs=l[i]
			ans+=ol*(3 if st else 5)
		curs-=l[i];ans+=l[i]
if curs>0:ans-=curs//2*2
print(ans//2)",linear,"constructive algorithms,greedy",594
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b


def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(e,g)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)


n, a, b = read(0)
sol = solve()
print(sol)",linear,"constructive algorithms,greedy",982
"def read(type = 1):
    if type:
        file = open(""input.dat"", ""r"")
        n = int(file.readline())
        a = list(map(int, file.readline().split()))
        b = file.readline()
        file.close()
    else:
        n = int(input().strip())
        a = list(map(int, input().strip().split()))
        b = input().strip()
    return n, a, b


def solve():
    sol = 0
    e = 0
    big = 0
    g = 0
    for i in range(n):
        if b[i] == ""W"":
            big = 1
            sol += 3 * a[i]
            e += a[i]
        if b[i] == ""G"":
            sol += 5 * a[i]
            e += a[i]
            g += 2*a[i]
        if b[i] == ""L"":
            sol += a[i]
            e -= a[i]
            if e < 0:
                if big:
                    sol -= 3 * e
                else:
                    sol -= 5 * e
                e = 0
        g = min(g, e)
    if e:
        sol -= 2*g
        sol -= (e-g)
    return int(sol)


n, a, b = read(0)
sol = solve()
print(sol)",linear,"constructive algorithms,greedy",983
"n=input()
l=list(map(lambda x:int(x)*2,raw_input().split("" "")))
t=list(map(lambda x:""GWL"".index(x),raw_input()))
mins=[0 for i in range(0,n+1)]
for i in range(n-1,-1,-1):
	if t[i]!=2:mins[i]=max(mins[i+1]-l[i],0)
	else:mins[i]=mins[i+1]+l[i]
curs=ans=st=0
for i in range(0,n):
	if(t[i]==0):
		curs+=l[i];ans+=l[i]*5
		if(curs>mins[i+1]):
			ol=(curs-mins[i+1])//2
			ol=min(ol,l[i])
			ans-=4*ol;curs-=2*ol
	if(t[i]==1):
		st=1;curs+=l[i];ans+=l[i]*3
	if(t[i]==2):
		if(curs<l[i]):
			ol=l[i]-curs;curs=l[i]
			ans+=ol*(3 if st else 5)
		curs-=l[i];ans+=l[i]
if curs>0:ans-=curs//2*2
print(ans//2)",linear,"constructive algorithms,greedy",597
"n = int(input())
dis = list(map(lambda x: int(x) << 1, input().split()))
ter = input()
st, ans = 0, 0
time = {'G': 5, 'W': 3, 'L': 1}
delta = {'G':1, 'W':1, 'L':-1}
hasWater = False
convert = 0
for i in range(n):
	st += dis[i] * delta[ter[i]]
	ans += dis[i] * time[ter[i]]
	# print('st = %d, ans = %d' % (st, ans))
	if ter[i] == 'W':
		hasWater = True
	elif ter[i] == 'G':
		convert += dis[i]
	if st < 0:
		if hasWater:
			ans += (-st) * 3
		else:
			ans += (-st) * 5
		st = 0
	convert = min(convert, st // 2)
	# print('convert = %d' % convert)
	# print('ans = %d' % ans)
ans -= 4 * convert
ans -= 2 * (st // 2 - convert)
print(ans // 2)


",linear,"constructive algorithms,greedy",640
"n = int(input())
a = list(map(int, input().split()))
q = (10 ** 6) * [-1]
pnt = -1
ans = ""YES""
for i in range(n):
    if pnt == -1:
        pnt += 1
        q[pnt] = a[i]
    else :
        if q[pnt] == a[i] or abs(q[pnt] - a[i]) % 2 == 0:
            q[pnt] = -1
            pnt -= 1
        else:
            pnt += 1
            q[pnt] = a[i]
if pnt > 0 :
    ans = ""NO""
print(ans)
        
",linear,"greedy,implementation,math",394
"n=int(input())
a=list(map(int,input().split()))
b=0
for i in range(n):
    if a[i]%2==1:
        if i%2==0:
            b+=1
        else:
            b-=1
if n%2==0:
    if b==0:
        print(""YES"")
    else:
        print(""NO"")
else:
    if b==0 or b==1:
        print(""YES"")
    else:
        print(""NO"")",linear,"greedy,implementation,math",308
"#!/usr/bin/env python
# coding: utf-8

# In[4]:


import math
n=int(input())
columns=list(map(int, input().rstrip().split()))


# In[5]:


modcolumns=[i%2 for i in columns]


# In[6]:


test=0


# In[7]:


previouslist=[]


for i in range(0,n):
    if len(previouslist)==0:
        previouslist.append(modcolumns[i])
        
    elif modcolumns[i]==previouslist[-1]:
        previouslist.pop()
        
    else:
        previouslist.append(modcolumns[i])
    
    
    
    
        
if len(previouslist)<=1:
    print(""YES"")
else:
    print(""NO"")


# In[ ]:


",linear,"greedy,implementation,math",563
"n = int(input())
a = list(map(int, input().split()))
b = []
for i in range(n):
    a[i] %= 2
    if len(b) != 0:
        if b[-1] == a[i]:
            b.pop()
        else:
            b.append(a[i])
    else:
        b.append(a[i])
if len(b) > 1:
    print(""NO"")
else:
    print(""YES"")
",linear,"greedy,implementation,math",287
"n = int(input())
a = [int(_) & 1 for _ in input().split()]
v = [a[0]]
for i in range(1, n):
    if v and v[-1] == a[i]:
        v.pop()
    else:
        v.append(a[i])
print(""NO"" if len(v) > 1 else ""YES"")
",linear,"greedy,implementation,math",206
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')


",linear,"greedy,implementation,math",203
"i = int(input())
s = input().split()

l = []
for j in s:
    if not l or  int(j)%2 != l[-1]:
        l.append(int(j)%2)
    else:
        l.pop()

if len(l) < 2:
    print('YES')
else:
    print('NO')
",linear,"greedy,implementation,math",201
"def f():
    b = [a[0]]
    for e in a[1:]:
        if b != []:
            if e == b[-1] or abs(e-b[-1])%2==0:
                b.pop()

            else:
                b.append(e)
        else:
            b.append(e)

    for i in range(1,len(b)):
        if abs(b[i]-b[i-1])%2:
            print('NO')
            return

    print('YES')

n=int(input())
a=[int(i) for i in input().split()]


f()",linear,"greedy,implementation,math",401
"n=int(input())
a=list(map(int,input().split()))
st=[a[0]]
for i in range(1,n):
    if len(st)>0 and st[-1]%2==a[i]%2:
        st.pop()
    else:
        st.append(a[i])
if len(st)<=1:
    print(""YES"")
else:
    print(""NO"")
    ",linear,"greedy,implementation,math",227
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        #print(*args, **kwargs, file=sys.stderr)
        # in python 3.4 **kwargs is invalid???
        print(*args,  file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()
#print(N)

zb = getIntList()

za1 = [0]
za2 = [zb[0]]

for i in range(1, N//2):
    t1 = zb[i] - za1[-1]
    if t1 <= za2[-1]:
        za1.append(za1[-1])
        za2.append(t1)
        continue
    t2 = zb[i] - za2[-1]
    if t2 >= za1[-1]:
        za1.append(t2)
        za2.append(za2[-1])
        continue
    assert False

zr = za1 + za2[ : :-1]
zs = []
for x in zr:
    zs .append(str(x))
    

r = ' '.join(zs)

print(r)








",linear,greedy,1238
"n = int(input())

b = list(map(int, input().split()))
a1 = [0]
a2 = [b[0]]

for x in b[1:]:
	new_a = a1[-1]
	if x - new_a > a2[-1]:
		new_a = x - a2[-1]
	new_a2 = x - new_a
	a1.append(new_a)
	a2.append(new_a2)
print(*(a1+a2[::-1]))",linear,greedy,231
"# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import itertools
import sys

""""""
created by shhuan at 2018/12/15 22:46

""""""

N = int(input())
B = [int(x) for x in input().split()]

A = [0] * N

i, j = N//2-1, N//2
A[i] = B[-1] // 2
A[j] = B[-1] // 2 if B[-1] % 2 == 0 else B[-1] // 2 + 1
l, r = A[i], A[j]
for bi in range(len(B)-2, -1, -1):
    b = B[bi]
    i -= 1
    j += 1

    if b-l >= A[j-1]:
        A[i] = l
        A[j] = b-l
        r = b-l
    else:
        A[j] = r
        A[i] = b-r
        l = b-r

print(' '.join(map(str, A)))
",linear,greedy,591
"n=int(input())//2
a=list(map(int,input().split(' ')))
b=[0]*n
a.reverse()
for i in a:
    b.append(i)
mem=b[-1]
c=0
for i in range(n-1):
    if b[-2-i]-c>mem:
        c=b[-2-i]-mem
    b[-2-i]-=c
    b[1+i]+=c
    mem=b[-2-i]
for i in b:
    print(i,end=' ')
",linear,greedy,259
"n = int(input())
b = list(map(int, input().split(' ')))

a = [0] * n

minV = 0
maxV = b[0]

m = n //2

a[n - 1] = b[0]

i = 1
j = n - 2

while(i < m):
  if(b[i] - minV > 0 and b[i] - minV <= maxV):
    a[i] = minV
    a[j] = b[i] - minV
    maxV = min(maxV, b[i] - minV)
  else:
    a[i] = b[i] - maxV
    a[j] = maxV
    minV = max(minV, b[i] - maxV)

  i += 1
  j -= 1

print(' '.join(map(str, a)))
",linear,greedy,401
"n = int(input())
b = list(map(int, input().split()))
a = [0] * (2 * (len(b)))
a[-1] = b[0]
for i in range(1, len(b)):
    if b[i] - a[i - 1] <= a[-i]:
        a[i] = a[i - 1]
        a[-i - 1] = b[i] - a[i - 1]
    else:
        a[-i - 1] = a[-i]
        a[i] = b[i] - a[-i - 1]
print(*a)
",linear,greedy,289
"n = int(input())
b = list(map(int, input().split()))
ff = []
ss = []
for i in  b[::-1]:
    q = i
    f = q // 2
    if q % 2:
        s = f + 1
    else:
        s = f
    if len(ff) == 0:
        ff = [f]
        ss = [s]
    else:
        if f > ff[-1] or s < ss[-1]:
            d = max(f - ff[-1], ss[-1] - s)
            f -= d
            s += d
        ff.append(f)
        ss.append(s)
print(*(ff[::-1] + ss))",linear,greedy,418
"import sys
sys.setrecursionlimit(2000)
from collections import Counter

if __name__ == ""__main__"":

    # single variables
    n = [int(val) for val in input().split()][0]
    b = [int(val) for val in input().split()]

    l = 0
    r = b[0]
    a = [0] * n
    for i in range(n//2):
        a[i] = l
        a[n-1-i] = r
        if(i != n//2-1):
            val = b[i+1]
            summ = l + r
            if(summ == val):
                continue
            elif(summ > val):
                diff = summ - val
                r -= diff
            elif(summ < val):
                diff = val - summ
                l += diff

    for i in a:
        print(i, end=' ')
    print('')
       


",linear,greedy,698
"n = int(input())
b = [int(w) for w in input().split()]
a = [0]*n

l = n//2 - 1
r = n//2

a[l] = b[l] // 2
a[r] = b[l] - a[l]

while l > 0:
    if b[l-1] >= b[l]:
        a[l-1] = a[l]
        a[r+1] = b[l-1] - a[l]
    else:
        a[r+1] = a[r]
        a[l-1] = b[l-1] - a[r]
    l -= 1
    r += 1

print(*a)
",linear,greedy,311
"def clc(mid):
    sm , i , cp = 0 , 1 , n
    cur = 1
    while(cp + 1 > cur):
        sm = sm + i * cur
        i+= 1
        cp -= cur
        cur = cur * mid
    return sm + i * cp

n , s = map(int,input().split())

sm = n * (n + 1) // 2
dp = [0] * 100005
x = [0] * 100005
y = [0] * 100005
x[0] = 1
if s + 1 < 2 * n:
    print(""No"")
    exit()
if s > sm:
    print(""No"")
    exit()
else:
    print(""Yes"")

l = 0
r = n 
while r - l > 1:
    mid = (r + l) // 2
    if(clc(mid) > s):
        l = mid
    else:
        r = mid
i = 2
while( i < n + 1):
    y[i] = i + r
    y[i] -= 2
    y[i] = y[i] // r
    x[i] = x[y[i]] + 1
    if(dp[x[i]] == 0):
        dp[x[i]] = i
    i = i + 1
mx = x[n]
ip = n
s = s - clc(r)
while(s != 0):
    if(x[ip] != x[ip - 1]):
        ip = ip - 1;
    if(s > mx - x[ip]):
        y[ip] = dp[mx]
        mx = mx + 1
        s -= mx - x[ip]
        x[ip] = mx
        dp[mx] = ip
    else:
        y[ip] = dp[s + x[ip] - 1]
        s = 0
    ip = ip - 1
i = 2
while(i < n + 1):
    print(y[i])
    i = i + 1

    
",linear,"binary search,constructive algorithms,dfs and similar,graphs,greedy,trees",1044
"import math
def f(n,k):
    if k==1:
        return (n*(n+1))//2
    a=math.floor(math.log(n,k))
    b=sum(k**i for i in range(a+1))
    c=sum((i+1)*k**i for i in range(a+1))
    if n<b:
        return c-(b-n)*(a+1)
    else:
        return c+(n-b)*(a+2)
n,s=map(int,input().split())
if s==(n*(n+1))//2:
    print(""Yes"")
    a=[str(i+1) for i in range(n-1)]
    print("" "".join(a))
elif s>(n*(n+1))//2:
    print(""No"")
elif s<2*n-1:
    print(""No"")
else:
    mini=1
    maxi=n-1
    curr=1
    while True:
        a,b=f(n,curr),f(n,curr+1)
        if b>s:
            mini=curr+1
            curr=math.ceil((curr+maxi)/2)
        elif a<=s:
            maxi=curr-1
            curr=(curr+mini)//2
        else:
            opt=curr+1
            break
    depths=[0,1]+[0]*(n-1)
    ins=1
    ind=2
    while True:
        a=min(opt**(ind-1),n-ins)
        depths[ind]=a
        ind+=1
        ins+=a
        if ins==n:
            break
    left=s-b
    far=ind-1
    bulk=ind-1
    if depths[bulk]==1:
        bulk-=1
    while left>0:
        if far+1-bulk<=left:
            far+=1
            left-=far-bulk
            depths[far]+=1
            depths[bulk]-=1
            if depths[bulk]==1:
                bulk-=1
        else:
            depths[bulk]-=1
            depths[bulk+left]+=1
            left=0
    verts=[None]*far
    sumi=0
    for i in range(far):
        verts[i]=list(range(sumi+1,sumi+1+depths[i+1]))
        sumi+=depths[i+1]
    out=""""
    for i in range(1,far):
        for j in range(len(verts[i])):
            out+=str(verts[i-1][j//opt])+"" ""
    print(""Yes"")
    print(out)",linear,"binary search,constructive algorithms,dfs and similar,graphs,greedy,trees",1609
"n, s = map(int, input().split())
if not 2*n - 1 <= s <= n * (n+1) // 2:
    print('No')
    exit()
print('Yes')

def ok(d):
    dep, cur, sum, m = 2, 1, 1, 0
    while cur + m < n:
        m += cur
        cur = min(n - m, cur * d)
        sum += cur * dep
        dep += 1
    return sum <= s

l, r = 1, n
while l < r:
    mid = (l+r) // 2
    if ok(mid):
        r = mid
    else:
        l = mid + 1

a, me = [l-1] * (n+1), [_ for _ in range(n+1)]
sum, low = n * (n+1) // 2, 2
while n > low and sum > s:
    dest = min(sum-s, n-low)
    sum -= dest
    me[n] -= dest
    a[me[n]+1] += l
    a[me[n]] -= 1
    if not a[low]: low += 1
    n -= 1
me, l, dg = sorted(me[1:]), 0, 0
for i in me[1:]:
    while me[l] < i-1 or dg == r:
        dg = 0
        l += 1
    print(l+1, end=' ')
    dg += 1
",linear,"binary search,constructive algorithms,dfs and similar,graphs,greedy,trees",797
"import math
EPS = 1e-6

hhh = None

def solve():
    n, M = [int(x) for x in input().split()]

    if out_of_solution_bounds(n, M):
        print('No')
        return

    b = find_optimal_b(n, M)

    heights = fast_find_optimal_height_distribution(n, M, b)
    parents = build_tree(n, b, heights)
    print('Yes')
    print(*parents[1:])

def out_of_solution_bounds(n, M):
    return M < 2*n - 1 or (n * (n+1)) // 2 < M

def find_optimal_b(n, M):
    begin = 1
    end = n
    while begin != end:
        mid = (begin + end) // 2
        if get_min_H_given_b(n, mid) <= M:
            end = mid
        else:
            begin = mid + 1
    b = end
    return b

def get_min_H_given_b(n, b):
    if b == 1: return (n*(n+1)) // 2
    m = math.floor(math.log((b-1)*n+1) / math.log(b) + EPS)
    nl = round((b**m - 1) / (b - 1))
    return (m*b**(m+1) - (m+1)*b**m + 1) // (b - 1)**2 + (m+1) * (n - nl)

def fast_find_optimal_height_distribution(n, M, b):
    begin = 0
    end = n+1
    H_fn = lambda L : (L*(L+1))//2 + get_min_H_given_b(n - L, b) + (L > 0)*(n - L)

    while begin != end:
        mid = (begin + end) // 2
        if H_fn(mid) <= M:
            begin = mid + 1
        else:
            end = mid
    L = begin - 1

    if L == n:
        return [1 for _ in range(n)]

    unif_branch_h = uniform_height_distribution(n - L, b)
    if L == 0:
        h = unif_branch_h
    else:
        h = [int(i < L) for i in range(n)]
        for i, x in enumerate(unif_branch_h, 1):
            h[i] += x

    return locally_increase_H(h, M, b)

def uniform_height_distribution(n, b):
    h = [0 for _ in range(n)]
    h[0] = 1
    i = 0
    to_fill = n-1
    while to_fill > 0:
        i += 1
        h[i] = min(b*h[i-1], to_fill)
        to_fill -= h[i]
    return h

def locally_increase_H(h, M, b):
    i = 1
    while not (b * (h[i-1]) >= (h[i] - 1) and b * (h[i] - 1) >= (h[i+1] + 1)):
        i += 1

    H = sum(i*x for i, x in enumerate(h, 1))
    while H < M:
        if b * (h[i-1] - 1) >= (h[i] + 1):
            i -= 1
        else:
            while not b * (h[i] - 1) >= (h[i+1] + 1):
                i += 1
        h[i] -= 1
        h[i+1] += 1
        H += 1

    return h

def build_tree(n, b, h):
    p = [None for _ in range(n)]
    p[0] = 1

    i = 1
    j = 0
    for k in range(1, n):
        if j == h[i]:
            i += 1
            j = 0
        p[k] = k - j - h[i-1] + (j // b) + 1
        j += 1
    return p

if __name__ == '__main__':
    solve()

",linear,"binary search,constructive algorithms,dfs and similar,graphs,greedy,trees",2487
"def good(max_branch, s, n):
    nodes = 0
    can = 1
    lowest_s = 0
    depth = 1
    while(nodes < n):
        added = min(n - nodes, can)
        lowest_s += added * depth
        nodes += added
        can *= max_branch
        depth += 1
    return lowest_s <= s


n, s = map(int, input().split())

if s < 2 * n - 1 or s * 2 > n * (n + 1):
    print('No')
else:
    lo, hi = 1, n
    while lo < hi:
        mid = (lo + hi) >> 1
        if good(mid, s, n) == False:
            lo = mid + 1
        else:
            hi = mid

    max_branch = lo

    level_size = [1] * (n + 1)
    node_level = [i for i in range(n + 1)]
    cur_node = n
    cur_level = 1
    cur_sum = n * (n + 1) // 2
    can = 1
    while cur_sum > s:
        if level_size[cur_level] == can:
            cur_level += 1
            can *= max_branch
            
        if cur_sum - (cur_node - cur_level) < s:
            cur_level = cur_node - (cur_sum - s)
                
        node_level[cur_node] = cur_level
        level_size[cur_level] += 1
        cur_sum -= cur_node - cur_level
        cur_node -= 1

    #print(cur_sum)
    #print(node_level)
    
    node_list = [[] for _ in range(n + 1)]
    for i in range(1, n + 1):
        node_list[node_level[i]].append(i)

    pre = 0
    children = [0] * (n + 1)
    parent = [-1] * (n + 1)
    seen_nodes = 1
    for level in range(2, n + 1):
        idx = 0
        if not node_list[level - 1]:
            assert seen_nodes == n
            break
        cur_father = node_list[level - 1][0]
        for node in node_list[level]:
            if children[cur_father] == max_branch:
                idx += 1
                cur_father = node_list[level - 1][idx]
            children[cur_father] += 1
            parent[node] = cur_father
            seen_nodes += 1
            
    print('Yes')
    print(*parent[2:])
",linear,"binary search,constructive algorithms,dfs and similar,graphs,greedy,trees",1858
"n,v = map(int, input().split())
ans = min(v, n-1)
for i in range(n - v - 1):
    ans += i+2
print(ans)",linear,"dp,greedy,math",102
"n, v = map(int, input().strip().split())
answer = 0
n -= 1
if n <= v:
    print(n)
else:
    answer =v

    for i in range(1,n-v + 1):

        answer += (i + 1)
    print(answer)",linear,"dp,greedy,math",179
"from collections import defaultdict as dd
import math
def nn():
	return int(input())

def li():
	return list(input())

def mi():
	return map(int, input().split())

def lm():
	return list(map(int, input().split()))



n,v=mi()

dist=n-1

if v>=dist:
	print(dist)

else:
	off=dist-v
	prices=[i+2 for i in range(off)]
	print(v+sum(prices))
",linear,"dp,greedy,math",337
"def solve(n, v):
    fuel = min(n - 1, v)
    cost = fuel
    for i in range(2, n):
        if fuel >= n - 1:
            break
        fuel += 1
        cost += i
    return cost

n, v = map(int, input().split())
print(solve(n, v))
",linear,"dp,greedy,math",233
"n, v = list(map(int, input().strip().split()))

remaining_dist = n - 1
adding = min(remaining_dist, v)
cost = adding

remaining_dist -= adding

i = 2
while remaining_dist > 0:
    cost += i
    i += 1
    remaining_dist -= 1

print(cost)
",linear,"dp,greedy,math",238
"n, v = map(int, raw_input().split())

res=0
fuel=0
for i in range(1,n):
    miss = min(v-fuel, n-i-fuel)
    res+=i*miss
    fuel+=miss-1
    if v-fuel==0:
        print(res)
        exit(0)
print(res)",linear,"dp,greedy,math",201
"def read_nums():
    return [int(x) for x in input().split()]


def main():
    n, v = read_nums()
    res = 0
    cur_tank = 0
    for c in range(1, n+1):
        need_to_by = min(v - cur_tank, n - c - cur_tank)
        res += need_to_by * c
        cur_tank += need_to_by
        cur_tank -= 1
    print(res)


if __name__ == '__main__':
    main()
",linear,"dp,greedy,math",351
"a,b=map(int,input().split())
if b>=a-1:
    print(a-1)
else:
    summ=b
    k=a-b
    for i in range(2,k+1):
        summ+=i
    print(summ)
",linear,"dp,greedy,math",141
"n, v = [int(item) for item in input().split()]

x = 0
c = 0
for i in range(1, n):
    if x < n - i:
        c += i * min((n - i), v - x)
        x += min((n - i), v - x)
    x -= 1

print(c)
",linear,"dp,greedy,math",191
"n = int(input())
s = input()
b = 0
for i in s:
    if i == '+':
        b += 1
    else:
        b -= 1
        b = max(b, 0)
print(b)",linear,"implementation,math",134
"def go():
    n = int(input())
    a = [i for i in input()]
    x = 0
    for i in a:
        if i == '-':
            x = max(0, x - 1)
        else:
            x += 1
    return x

print(go())
",linear,"implementation,math",196
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n = read_int()
    s = read()
    stones = 0
    for c in s:
        if c == '+':
            stones += 1
        else:
            stones -= 1
            if stones < 0:
                stones = 0
    write(stones)

main()
",linear,"implementation,math",920
"n=int(input())
s=input()
cur=0
for a in s:
    cur=max(cur,0)
    if(a=='-'):
        cur-=1
    else: cur+=1
    cur=max(cur,0)
print(cur)",linear,"implementation,math",139
"n=int(input())
s=input()
ans=0
for i in s:
    if(i=='+'):
        ans+=1
    else:
        ans-=1
    if(ans<0):
        ans=0
print(ans)",linear,"implementation,math",138
"n = int(input())
s = input()
ans = 10000
for i in range(0, 105):
	f = True
	x = i
	for c in s:
		if c == '-':
			x -= 1
		else:
			x += 1
		if x < 0:
			f = False
	if f:
		ans = min(ans, x)
print(ans)
",linear,"implementation,math",201
"n = int(input())
s = input()
maxn = 0
now = 0
for i in s:
    if i == '+':
        now += 1
    else:
        now -= 1
    maxn = max(maxn, -now)
print(now + maxn)",linear,"implementation,math",163
"n = int(input())
s = input()
t = 0
for i in s:
    if i == '+':
        t += 1
    else:
        t = max(t - 1, 0)

print(max(t, 0))
",linear,"implementation,math",133
"n = int(input())
s = input()
t = 0
mn = 0
for i in s:
    if i == '-':
        t-=1
    else:
        t+=1
    mn = min(mn, t)
print(-mn+t)",linear,"implementation,math",139
"n = int(input())
nums = [int(x) for x in input().split()]
ans = 10 ** 12
for idx, num in enumerate(nums):
    dist = max(idx, n - idx - 1)
    curr = num // dist
    ans = min(ans, curr)
print(ans)",linear,"implementation,math",197
"def main():
    from sys import stdin, stdout

    def read():
        return stdin.readline().rstrip('\n')

    def read_array(sep=None, maxsplit=-1):
        return read().split(sep, maxsplit)

    def read_int():
        return int(read())

    def read_int_array(sep=None, maxsplit=-1):
        return [int(a) for a in read_array(sep, maxsplit)]

    def write(*args, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in args) + end)

    def write_array(array, **kwargs):
        sep = kwargs.get('sep', ' ')
        end = kwargs.get('end', '\n')
        stdout.write(sep.join(str(a) for a in array) + end)

    n = read_int()
    nums = read_int_array()
    out = nums[0]
    first = nums[0]
    for i in range(1, n):
        out = min(out, min(nums[i], first) // i)
    last = nums[-1]
    for i in range(n-2, 0, -1):
        out = min(out, min(nums[i], last) // (n-1 - i))
    write(out)

main()
",linear,"implementation,math",983
"def main():
    n = int(input())
    arr = list(map(int, input().split()))
    ans = 10 ** 10
    for i in range(n):
        x = i if i > n - i - 1 else n - i - 1
        ans = min(ans, arr[i] // x)
    print(ans)
main()",linear,"implementation,math",220
"n = int(input())
A = list(map(int, input().split()))
k = 10 ** 10
for i in range(1, n - 1):
    k = min(k, min(A[0], A[i]) // i)
    k = min(k, min(A[-1], A[i]) // (n - i - 1))
k = min(k, min(A[0], A[-1]) // (n - 1))
print(k)",linear,"implementation,math",225
"n = int(input())
arr = list(map(int, input().split()))
res = float('inf')
for i in range(1, n):
    res = min(res, min(arr[i], arr[0]) // i)
for i in range(n - 1):
    res = min(res, min(arr[i], arr[n - 1]) // (n - 1 - i))
print(res)
",linear,"implementation,math",234
"n = int(input())
a = list(map(int, input().split()))
ans = float('inf')
for i in range(n):
    ans = min(ans, a[i] // max(i,  n - i - 1))
print(ans)",linear,"implementation,math",148
"n = int(input())
a = list(map(int, input().split()))
max1 = float('inf')
for q in range(len(a)):
    if q >= n-q-1:
        max1 = min(max1, min(a[q], a[0])//q)
    if q <= n-q-1:
        max1 = min(max1, min(a[q], a[-1]) // (n-q-1))
print(max1)
",linear,"implementation,math",246
"n=int(input())
a=list(map(int,input().split()))
k=min(a[0],a[-1])//(n-1)
for i in range(1,n-1):
    k=min(k,min(a[0],a[i])//i,min(a[i],a[-1])//(n-1-i))
print(k)
",linear,"implementation,math",161
"n = int(input())
l = list( map( int, input().split() ) )
ans = max(l)
for i in range(n):
    ans = min( ans, l[ i ] // max( i, n - i - 1 ))
print( ans )",linear,"implementation,math",152
"
import math

n, m = map(int, input().split())

b = list(map(int, input().split()))
g = list(map(int, input().split()))

first_max = 0
second_max = 0
for i in range(n):
	if b[i] < first_max and b[i] > second_max:
		second_max = b[i]
	if b[i] >= first_max:
		second_max = first_max
		first_max = b[i]

# print(first_max, second_max)
first_min = min(g)

if first_max > first_min:
	print(-1)
else:
	total = sum(b) * m + sum(g) - m * first_max + (first_max - second_max) * (first_min != first_max)
	print(total)
",linear,"greedy,implementation,math",508
"n, m = map(int, input().split())
a = []
b = []
ma = 0
macount = 0
mi = 1000000000000000000000000000
su = 0
for el in map(int, input().split()):
    if el > ma:
        ma = el
        macount = 1
    elif el == ma:
        macount += 1
    a.append(el)
for el in map(int, input().split()):
    mi = min(el, mi)
    b.append(el)
    su += el
if ma > mi:
    print(-1)
elif ma == mi or macount > 1:
    f = True
    for i in range(n):
        if a[i] == ma and f:
            f = False
        else:
            su += a[i] * m
    print(su)
else:
    secmax = 0
    for el in a:
        if el > secmax and el < ma:
            secmax = el
    f = True
    for i in range(n):
        if a[i] == ma and f:
            f = False
        else:
            su += a[i] * m
    print(su + ma - secmax)
",linear,"greedy,implementation,math",793
"import sys


def second_largest(numbers):
    count = 0
    m1 = m2 = float('-inf')
    for x in numbers:
        count += 1
        if x > m2:
            if x >= m1:
                m1, m2 = x, m1
            else:
                m2 = x
    return m2 if count >= 2 else None


n, m = map(int, input().split())
boys = list(map(int, input().split()))
girls = list(map(int, input().split()))
firstMax = max(boys)
secondMax = second_largest(boys)
minGrills = min(girls)
minSum = 0
if firstMax > minGrills:
    print(-1)
    sys.exit()
elif firstMax == minGrills:
    minSum = m * (sum(boys) - firstMax) + sum(girls)
elif n == 1:
    print(-1)
    sys.exit()
else:
    minSum = m * sum(boys) + sum(girls) - (m-1) * firstMax - secondMax
print(minSum)
",linear,"greedy,implementation,math",748
"n, m = map(int, input().split())
B = list(map(int, input().split()))
G = list(map(int, input().split()))
if min(G) < max(B):
    print(-1)
    exit(0)
cnt = 0
z = max(B)
y = 0
f = 1
f2 = 0
for i in B:
    if i != z or f2:
        y = max(y, i)
    else:
        f2 = 1
for i in G:
    if i == z:
        f = 0
    cnt += i - z
if f:
    cnt += z - y
print(cnt + sum(B) * m)",linear,"greedy,implementation,math",373
"import sys
import collections
import math
import heapq
import bisect
from operator import itemgetter

def getint():
    return int(input())

def getints():
    return [int(x) for x in input().split(' ')]

n, m = getints()
b = getints()
g = getints()

result = 0

bMax, bMax2, bSum = -1, -1, 0
for i, bb in enumerate(b):
    bSum += bb
    if bb > bMax:
        bMax2, bMax = bMax, bb
    elif bb > bMax2:
        bMax2 = bb

gMin, gSum = float('inf'), 0
for j, gg in enumerate(g):
    gSum += gg
    if gg < gMin:
        gMin = gg

if bMax > gMin:
    result = -1
else:
    result = bSum * m
    result += gSum
    result -= bMax * m
    if gMin > bMax:
        result += bMax - bMax2

print(str(result))",linear,"greedy,implementation,math",705
"#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
# from fractions import *
# from functools import *
from heapq import *
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M = 998244353
EPS = 1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()

        

for _ in range(1):

    n,k = value()
    
    rep = [1] + [0]*((n-k)//2)
    cur = 0
    
    ans = []
    j = 0
    for i in range(n):
        ans.append(rep[j])
        j = (j + 1)%len(rep)
    
    if(k == 1): ans = [1] + [0]*(n - 1)
    print(*ans,sep = '')
    
        
        
            
        
    
                
            
    
        
        
        
    
    
    
        
        
        
    

            
            
    
            
    
    
            
        
        
    


    
        



    




















    




",linear,"brute force,greedy,constructive algorithms,math,strings",2943
"n,k = map(int, input().split())
d = (n-k)//2+1
ans = ['1' if (i+1)%d==0 else '0' for i in range(n)]
print(''.join(ans))
",linear,"brute force,greedy,constructive algorithms,math,strings",120
"N, K = map(int, input().split())
if N == K:
    print(""0""*N)
elif K == 1:
    print(""0""*(N-1) + ""1"")
elif K == 3:
    print(""1"" + ""0""*(N-4) + ""101"")
else:
    res = [""0""]*N
    for i in range(0, N, N//2-K//2+1):
        res[i] = ""1""
    print(''.join(res))",linear,"brute force,greedy,constructive algorithms,math,strings",256
"import os
import sys

def log(*args, **kwargs):
    if os.environ.get('CODEFR'):
        print(*args, **kwargs)


n, k = tuple(map(int, input().split()))

s = '0'*((n-k)//2) + '1'

for i in range(n):
    print(s[i % len(s)], end='')
print()

",linear,"brute force,greedy,constructive algorithms,math,strings",242
"n, k = list(map(int,input().split()))
chuj_twojej_starej = (n - k) // 2 + 1
i = 1
while True:
	if i % chuj_twojej_starej == 0:
		print(0, end = """")
	else:
		print(1, end = """")
	if i == n:
		break
	i += 1",linear,"brute force,greedy,constructive algorithms,math,strings",203
"n, k = map(int, input().split())

strr = """"
while len(strr) < n:
    strr += ""0"" * ((n-k) // 2) + ""1""
strr = strr[:n]
print(strr)",linear,"brute force,greedy,constructive algorithms,math,strings",129
"n, k = [int(x) for x in input().split()]

ans = """"
while len(ans) < n:
    ans += '1' * ((n - k) // 2) + '0';
ans = ans[:n]
print(ans)",linear,"brute force,greedy,constructive algorithms,math,strings",134
"n,k=map(int,input().strip().split())
d=(n-k)//2+1
x=['1' if (i+1)%d==0 else '0' for i in range(n)]
print(''.join(x))",linear,"brute force,greedy,constructive algorithms,math,strings",116
"n,k=map(int,input().split())
d=(n-k)//2
s=0
while s!=n:
    if (s+1)%(d+1)==0:
        print(""1"",end="""")
    else :
        print(""0"",end="""")
    s+=1
",linear,"brute force,greedy,constructive algorithms,math,strings",151
"import sys
input = sys.stdin.readline


from collections import deque
N, Q = map(int, input().split())
que = deque([int(a) for a in input().split()])
ma = max(que)

X = []
k = -1
c = 0
while c <= k+N+5:
    a = deque.popleft(que)
    b = deque.popleft(que)
    
    X.append((a, b))
    c += 1
    if a > b:
        a, b = b, a
    if k < 0 and b == ma:
        k = c
    deque.appendleft(que, b)
    deque.append(que, a)

for _ in range(Q):
    i = int(input()) - 1
    if i <= k:
        print(*X[i])
    else:
        i = (i-k)%(N-1)+k
        print(*X[i])

",linear,"data structures,implementation",561
"from collections import defaultdict as dd, deque
import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,q = map(int,input().split())
S = [int(x) for x in input().split()]
Q = deque(S)

n = len(Q)
res = []
for i in range(n):
    a = Q.popleft()
    b = Q.popleft()
    Q.appendleft(max(a,b))
    Q.append(min(a,b))
    res.append((a,b))

A = list(Q)

def solve(t):
    if t < len(res):
        return res[t-1]
    t -= len(res) + 1
    t %= n-1
    return A[0],A[t+1]

for _ in range(q):
    t = int(input())
    print(*solve(t))
    
#def brute(t):
#    Q = deque(S)
#    for i in range(t):
#        a = Q.popleft()
#        b = Q.popleft()
#
#        Q.appendleft(max(a,b))
#        Q.append(min(a,b))
#    return a,b

#for i in range(1,1000):
#    assert brute(i) == solve(i)
",linear,"data structures,implementation",994
"import sys
input = sys.stdin.readline
from collections import deque

n,q=map(int,input().split())
A=deque(map(int,input().split()))
Q=[int(input()) for i in range(q)]

ANS=[0]

for l in range(10**5+1):
    x=A.popleft()
    y=A.popleft()

    ANS.append((x,y))

    if x>y:
        A.appendleft(x)
        A.append(y)
    else:
        A.appendleft(y)
        A.append(x)


ANS0=A[0]
B=list(A)[1:]

for q in Q:
    if q<=10**5+1:
        print(*ANS[q])
    else:
        print(ANS0,B[(q-10**5-2)%(n-1)])
",linear,"data structures,implementation",504
"n, q = map(int, input().split())
nums = list(map(int, input().split()))
""""""
algo:
store the combos until the maximum element reaches the front of the deque
then the order of the rest of the deque only changes by 2nd element going to end
so let cutoff = number of operation which causes the max element to reach front
if mj <= cutoff then output mjth combo stored
if mj > cutoff  then output = (max, (mj-cutoff-1)%(len-1)+1)
""""""

m = max(nums)#max element
# print(nums)
# print(m)
ab = []
while nums[0] < m:
    ab.append([nums[0], nums[1]])
    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))
# print(ab)

for i in range(q):
    mj = int(input())
    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))
    print(a + "" "" + b)



    
",linear,"data structures,implementation",799
"n,q = map(int, raw_input().split())
nums = list(map(int, raw_input().split()))
""""""
algo:
store the combos until the maximum element reaches the front of the deque
then the order of the rest of the deque only changes by 2nd element going to end
so let cutoff = number of operation which causes the max element to reach front
if mj <= cutoff then output mjth combo stored
if mj > cutoff  then output = (max, (mj-cutoff-1)%(len-1)+1)
""""""

m = max(nums)#max element
# print(nums)
# print(m)
ab = []
while nums[0] < m:
    ab.append([nums[0], nums[1]])
    nums.append(nums.pop(1)) if nums[0]>nums[1] else nums.append(nums.pop(0))
# print(ab)

for i in range(q):
    mj = int(input())
    a, b = map(str, ab[mj-1] if mj <= len(ab) else (m, nums[(mj-len(ab)-1)%(len(nums)-1) +1]))
    print(a + "" "" + b)
",linear,"data structures,implementation",798
"from collections import deque
n, q = map(int, input().split())
a = deque(map(int, input().split()))
b = []
m = a.index(max(a))
for i in range(m):
    a0, a1 = a.popleft(), a.popleft()
    b.append([a0, a1])
    if a0 < a1:
        a0, a1 = a1, a0
    a.appendleft(a0)
    a.append(a1)
for i in range(q):
    c = int(input())
    if c <= m:
        print('{} {}'.format(b[c-1][0], b[c-1][1]))
    else:
        c -= m+1
        c %= n-1
        print('{} {}'.format(a[0], a[c+1]))
",linear,"data structures,implementation",480
"from sys import stdin,stdout
input=stdin.readline

def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))
 
n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(input())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",linear,"data structures,implementation",559
"from sys import stdin,stdout
def count(audrey,imba,banget):
    return((imba-audrey-1)%(banget-1))
 
n,q=map(int,input().split())
L=list(map(int,input().split()))
maxi=max(L)
indexmax=L.index(maxi)
P=[]
for i in range(indexmax):
    P.append((L[0],L[1]))
    if L[0]<L[1]:
        L.append(L.pop(0))
    else:
        L.append(L.pop(1))
Y=tuple(L[1:])
for p in range(q):
    m=int(stdin.readline())
    if m<=indexmax:
        print(str(P[m-1][0])+' '+str(P[m-1][1]))
    else:
        stdout.write(str(maxi)+' '+str(Y[count(indexmax,m,n)])+'\n')",linear,"data structures,implementation",546
"# import sys
# input = sys.stdin.readline
n,queries = list(map(int,input().split()))
l = list(map(int,input().split()))
if(queries==0):
	exit()
maxval = max(l)
pairs = []
count = 0
f = l[0]
secix = 1
while(f!=maxval):
	# print(l)
	count+=1
	f = l[0]
	s = l[secix]
	pairs.append([f,s])
	f,s= max(f,s), min(f,s)
	l[0] = f
	l.append(s)
	secix+=1
# print(secix)
l = [l[0]]+l[secix:]
# print(l)
for i in range(n-1):
	pairs.append([maxval,l[1+i]])
# print(pairs)
for m in range(queries):
	q = int(input())
	if(q<=count):
		print(str(pairs[q-1][0]),str(pairs[q-1][1]))
	else:
		q-=(count+1)
		pos = count+(q%(n-1))
		print(str(pairs[pos][0]),str(pairs[pos][1]))",linear,"data structures,implementation",654
"n = int(input())
ans = 1
for i in range(1, n):
    ans += i * 4
print(ans)",linear,"dp,implementation,math",74
"n = int(input())
ans = 1
for i in range(n):
    ans += i * 4
print(ans)",linear,"dp,implementation,math",71
"def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))

n = getN()
mid = n * 2 -1
ans = -mid
while(mid > 0):
    ans += mid*2
    mid -= 2

print(ans)",linear,"dp,implementation,math",189
"n = int(input())
summ = 1
for i in range(1, n):
    summ+=i*4
print(summ)",linear,"dp,implementation,math",73
"n = int(input())
ans = 1
for i in range(n):
    ans += 4 * i
print(ans)

",linear,"dp,implementation,math",73
"import math
import sys

#imgur.com/Pkt7iIf.png

#n, m = map(int, input().split())
#n = int(input())
#d = list(map(int, input().split()))

n = int(input())
r = 0
t = 1
for i in range(n-1):
    r += t*2
    t += 2
print(r + t)
",linear,"dp,implementation,math",225
"n = int(input())
wyn = 1
x = 4
for i in range(n - 1):
	wyn += x
	x += 4
print(wyn)",linear,"dp,implementation,math",82
"n=int(input())
answer=0
for i in range(1,2*n-2,2):
    answer+=i
print(answer*2+2*n-1)
",linear,"dp,implementation,math",87
"#    !/usr/bin/env python3
#    encoding: UTF-8
#    Modified: <21/Jun/2019 10:37:27 PM>


#    ✪ H4WK3yE乡
#    Mohd. Farhan Tahir
#    Indian Institute Of Information Technology (IIIT), Gwalior


import sys
import os
from io import IOBase, BytesIO


def main():
    n = int(input())
    x = 2 * n - 1
    ans = x
    x -= 2
    curr = 0
    while x > 0:
        curr += x
        x -= 2
    print(ans + 2 * curr)


BUFSIZE = 8192


class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def get_array(): return list(map(int, sys.stdin.readline().split()))


def get_ints(): return map(int, sys.stdin.readline().split())


def input(): return sys.stdin.readline().strip()


if __name__ == ""__main__"":
    main()
",linear,"dp,implementation,math",2232
"n = int(input())
A = list(map(int, input().split()))
if n == 1:
    if A[0] >= 0:
        print(A[0])
    else:
        print(-A[0]-1)
    exit(0)
for i in range(n):
    if A[i] < 0:
        pass
    else:
        A[i] = -A[i]-1
if n % 2 == 0:
    print(*A)
    exit(0)
mim = 0
indmim = 0
for i in range(n):
    if A[i] < mim:
        mim = A[i]
        indmim = i
A[indmim] = -A[indmim]-1
print(*A)
",linear,"greedy,implementation",400
"n = int(input())
l = list(map(int,input().split()))
m = 0
for i in range(n):
	if l[i] >= 0:
		l[i] = -l[i] - 1
for i in range(n):
	if l[i] < 0 :
		m += 1
if m % 2 == 0:
	for i in range(n):
		print(l[i], end = "" "")
else:
	maksi = -1000000000000
	for i in range(n):
		if abs(l[i]) > maksi:
			maksi = abs(l[i])
			mk = i
	l[mk] = -l[mk] - 1
	for i in range(n):
		print(l[i], end = "" "")",linear,"greedy,implementation",383
"n = int(input())
a = list(map(int, input().split()))
for i in range(n):
    if a[i]>=0:
        a[i] = -a[i]-1
x = min(a)

if len(a)%2==1:
    for i in range(n):
        if a[i]==x:
            a[i] = -a[i]-1
            break
print(*a)",linear,"greedy,implementation",236
"# coding: utf-8
import sys
from heapq import heappush, heappop, heapify
sys.setrecursionlimit(int(1e7))

def main():
    n = int(input().strip())
    a = [int(x) for x in input().split()]
    a = [-x-1 if x>=0 else x for x in a]
    if n%2==1:
        _, i = min((x,i) for i,x in enumerate(a))
        a[i] = -a[i]-1
    print(*a)
    return

while 1:
    try: main()
    except EOFError: break",linear,"greedy,implementation",394
"n=int(input())
l1=list(map(int,input().split()))
if n%2==0:
    for i in range(n):
        if l1[i]>=0:
            l1[i]=-1*l1[i]-1
else :
    for i in range(n):
        if l1[i]>=0:
            l1[i]=-1*l1[i]-1
    l1[l1.index(min(l1))]=l1[l1.index(min(l1))]*-1 -1
print(' '.join(str(x) for x in l1))",linear,"greedy,implementation",302
"n = int(input())
a = []
for i in map(int, input().split()):
    if abs(-i-1)>abs(i):
        a.append(-i-1)
    else:
        a.append(i)

c = 0
for i in a:
    if i<0:
        c+=1
if c%2:
    me=0
    for i in range(len(a)):
        if a[i]<a[me]:
            me=i
    a[me]=-a[me]-1
print(*a)
",linear,"greedy,implementation",296
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int,sys.stdin.readline().strip().split()))

for i in range (0, n):
    if a[i] >= 0:
        a[i] = - a[i] - 1

if n % 2 == 1:
    i = a.index(min(a))
    a[i] = - a[i] - 1

a = list(map(str,a))
print("" "".join(a))

",linear,"greedy,implementation",278
"n = int(input())
a = list(map(int, input().split()))

max_mod = 0
max_i = -1
for i in range(n):
	if a[i] >= 0:
		a[i] = -a[i] - 1
	if -a[i] > max_mod:
		max_mod = -a[i]
		max_i = i

if n % 2 == 1:
	a[max_i] = -a[max_i] - 1

print(' '.join(list(map(str, a))))
",linear,"greedy,implementation",259
"n = int(input())
a = list(map(int,input().split()))

for i in range(n):
    if a[i] >= 0:
        a[i] = -a[i]-1

if n%2:
    m = min(a)
    for i in range(n):
        if a[i] == m:
            a[i] = -a[i]-1
            break

print(*a)
",linear,"greedy,implementation",238
"""""""
NTC here
""""""
from sys import setcheckinterval,stdin
setcheckinterval(1000)

#print(""Case #{}: {} {}"".format(i, n + m, n * m))

iin=lambda :int(stdin.readline())
lin=lambda :list(map(int,stdin.readline().split()))

n,q=lin()
a=lin()
if q==0:
    exit()
Q=[iin() for i in range(q)]
sq=set(Q)
mx=max(Q)
d=dict()
ch=1
for i in range(min(mx,n+1)):
    if ch==n:
        ch=1
    if i+1 in sq:d[i+1]=[a[0],a[ch]]
    if a[0]<a[ch]:
        a[0],a[ch]=a[ch],a[0]
    ch+=1

for i in Q:
    if i>n:
        x=n-1 if i%(n-1)==0 else i%(n-1)
        print(a[0],a[x])
    else:
        print(*d[i])




",linear,"data structures,implementation",596
"import sys

n, q = list(map(int,sys.stdin.readline().strip().split()))
a = list(map(int,sys.stdin.readline().strip().split()))
m = [0] * q

M = max(a)
i = 0
x = a[0]
L = []
L1 = []
L2 = []
while x != M:
    L1.append(x)
    L2.append(a[i+1])
    i = i + 1
    if x < a[i]:
        L.append(x)
        x = a[i]
    else:
        L.append(a[i])

b = a[i+1:] + L

for j in range (0, q):
    m = int(sys.stdin.readline().strip())
    if m <= i:
        print(str(L1[m-1]) + "" "" + str(L2[m-1]))
    else:
        print(str(x) + "" "" + str(b[(m - i - 1) % (n-1)]))
",linear,"data structures,implementation",558
"def getN():
    return int(input())
def getList():
    return list(map(int, input().split()))

from collections import deque

n, m = getList()
nums = getList()
mxnum = max(nums)
d = deque(nums)

qr = []
for i in range(m):
    qr.append(getN())

log = []

rot = 0
while(True):
    # print(d)
    a = d.popleft()
    b = d.popleft()
    log.append((a, b))
    if a > b:
        a, b = b, a

    d.append(a)
    d.appendleft(b)

    rot += 1

    if b == mxnum:
        break



for q in qr:
    if q <= rot:
        print(log[q - 1][0], log[q - 1][1])
    else:
        res = q -  rot - 1
        print(b, d[res % (n-1) + 1  ])

# print(d)
""""""
5 10
1 2 5 4 3
1
2
3
4
5
6
7
8
9
10
""""""
",linear,"data structures,implementation",682
"import sys
# from bisect import bisect_right
# gcd
# from fractions import gcd
# from math import ceil, floor
# from copy import deepcopy
# from itertools import accumulate
# l = ['a', 'b', 'b', 'c', 'b', 'a', 'c', 'c', 'b', 'c', 'b', 'a']
# print(S.most_common(2))  # [('b', 5), ('c', 4)]
# print(S.keys())  # dict_keys(['a', 'b', 'c'])
# print(S.values())  # dict_values([3, 5, 4])
# print(S.items())  # dict_items([('a', 3), ('b', 5), ('c', 4)])
# from collections import Counter
# import math
# from functools import reduce
#
# fin = open('./test/in_1.txt', 'r')
# sys.stdin = fin
input = sys.stdin.readline
def ii(): return int(input())
def mi(): return map(int, input().rstrip().split())
def lmi(): return list(map(int, input().rstrip().split()))
def li(): return list(input().rstrip())
# template



if __name__ == '__main__':

    # write code
    n,q = mi()
    a = lmi()
    i = 0
    max_a = max(a)
    t = a.index(max_a)
    last = a[0]
    Lis = []
    tmp = []
    for i in range(1, t + 1):
        Lis.append((last,a[i]))
        if last < a[i]:
            tmp.append(last)
            last = a[i]
        else:
            tmp.append(a[i])
    # print(Lis)
    anslist = a[t+1:] + tmp
    # print(last)
    # print(anslist)
    # print(tmp)
    for i in range(q):
        tm = ii()
        if 1 <= tm <= t:
            print(Lis[tm - 1][0],Lis[tm - 1][1])
        else:
            print(max_a,anslist[(tm-t-1)%len(anslist)])",linear,"data structures,implementation",1442
"#import resource
import sys
#resource.setrlimit(resource.RLIMIT_STACK, [0x100000000, resource.RLIM_INFINITY])
#import threading
#threading.Thread(target=main).start()
#threading.stack_size(2**26)
#sys.setrecursionlimit(10**6)
mod=(10**9)+7
#fact=[1]
#for i in range(1,100001):
#    fact.append((fact[-1]*i)%mod)
#ifact=[0]*100001
#ifact[100000]=pow(fact[100000],mod-2,mod)
#for i in range(100000,0,-1):
#    ifact[i-1]=(i*ifact[i])%mod
from sys import stdin, stdout
import bisect
from bisect import bisect_left as bl
from bisect import bisect_right as br
import itertools
import collections
import math
import heapq
from random import randint as rn
from Queue import Queue as Q
def modinv(n,p):
    return pow(n,p-2,p)
def ncr(n,r,p):
    t=((fact[n])*((ifact[r]*ifact[n-r])%p))%p
    return t
def ain():
    return map(int,sin().split())
def sin():
    return stdin.readline().strip()
def GCD(x,y):
    while(y):
        x, y = y, x % y
    return x
def isprime(x):
    if(x==1):
        return False
    elif(x<4):
        return True
    for i in range(2,int(math.sqrt(x))+1):
        if(x%i==0):
            return False
    return True
""""""**************************************************************************""""""
n,q=ain()
a=ain()
g=max(a)
d=collections.deque(a)
f=0
an1=[]
while(d[0]!=g):
    f+=1
    x=d.popleft()
    y=d.popleft()
    an1.append(str(x)+"" ""+str(y))
    if(y==g):
        d.appendleft(y)
        d.append(x)
        break
    if(x<y):
        d.appendleft(y)
        d.append(x)
    else:
        d.appendleft(x)
        d.append(y)
r=[]
ans=[]
for i in range(n):
    r.append(str(d.popleft()))
for i in range(q):
    b=int(sin())
    if(b<=f):
        ans.append(an1[b-1])
    else:
        b-=f
        b-=1
        b%=(n-1)
        ans.append(r[0]+"" ""+r[b+1])
stdout.write(""\n"".join(ans))
",linear,"data structures,implementation",1820
"n, q = map(int,input().split())
ai = list(map(int,input().split()))
ar  = []
ar3 = []
num = 1
nummm = max(ai)
if ai[0] != nummm:
    num2 = ai[0]
    for i in range(1,n):
        ar3 += [[num2,ai[i]]]
        if ai[i] == nummm:
            ar += [num2]
            num = i+1
            break
        if ai[i] > num2:
            ar += [num2]
            num2 = ai[i]
        else:
            ar += [ai[i]]
ar2 = []
for i in range(num,n):
    ar2 += [ai[i]]
for i in range(len(ar)):
    ar2 += [ar[i]]
num = len(ar3)
for i in range(q):
    m = int(input())
    if m <= num:
        print(ar3[m-1][0],ar3[m-1][1])
    else:
        m -= num
        m -= 1
        print(nummm,ar2[m % (n-1)])
",linear,"data structures,implementation",692
"# alpha = ""abcdefghijklmnopqrstuvwxyz""
# prime = 998244353 
INF = 1000_000_000

# from heapq import heappush, heappop
# from collections import defaultdict
# from math import sqrt
from collections import deque      
    
t = 1#int(input())

for test in range(t):
    # n = int(input())
    n,q = map(int, input().split())
    arr = list(map(int, input().split()))
    maxval = max(arr)
    d = deque(arr)
    ans = {}
    count = 1
    # print(""check"",d[0], maxval)
    while d[0]!=maxval:
        a = d.popleft()
        b = d.popleft()
        ans[count] = (a,b)
        count+=1
        d.append(min(a,b))
        d.appendleft(max(a,b))
    n = n-1
    for i in range(q):
        m = int(input())
        if m in ans:
            print(ans[m][0],ans[m][1])
        else:
            m = m - count
            print(maxval, d[1+(m%n)])
",linear,"data structures,implementation",838
"import sys
import math
input = sys.stdin.readline

n,q=map(int,input().split())

arr=list(map(int,input().split()))
for i in range(n):
	arr.append(0)
maxx=0

ind=arr.index(max(arr))
ans=[]
ptr1=0
ptr2=n
for i in range(ind):
	ans.append([arr[ptr1],arr[ptr1+1]])
	if arr[ptr1]>arr[ptr1+1]:
		arr[ptr2]=arr[ptr1+1]
		arr[ptr1+1]=arr[ptr1]
	else:
		arr[ptr2]=arr[ptr1]
	ptr1+=1
	ptr2+=1
#print(arr)
for i in range(q):
	m=int(input())

	if m<=ind:
		print(*ans[m-1])
	else:
		m-=ind
		m=m%(n-1)
		if m==0:
			m+=n-1
		print(arr[ind],arr[ind+m])",linear,"data structures,implementation",539
"a, b = map(int, input().split())
A = list(map(int, input().split()))
A.append(-1)
B = []
Z = []
AN = []
x, y = A[0], A[1]
for i in range(a - 1):
    Z.append((x, y))
    if x > y:
        B.append(y)
        y = A[i + 2]
    else:
        B.append(x)
        x, y = y, A[i + 2]
for i in range(b):
    w = int(input())
    if w <= len(Z):
        AN.append(Z[w - 1])
    else:
        w = w % len(B)
        AN.append((x, B[w - 1]))
for W in AN:
    print(*W)",linear,"data structures,implementation",458
"n,m,k = list(map(int,input().split()))

l = list(map(int,input().split()))

out = 0
d = 0

while m > d:
    nex = l[d]
    page = (nex - d - 1)//k
    add = 1
    while d + add < m and (page * k) < l[d + add] - d  <= (page + 1) * k:
        add += 1
    d += add
    out += 1

print(out)
    
",linear,"implementation,two pointers",293
"import sys

n, m, k = list(map(int,sys.stdin.readline().strip().split()))
p = list(map(int,sys.stdin.readline().strip().split()))
i = 0
c = 0
d = 0
while i < m:
    c = c + 1
    d2 = d
    x = k*((p[i]-d2-1)//k) + k
    while p[i]-d2 <= x:
        i = i + 1
        d = d + 1
        if i == m:
            break
print(c)

",linear,"implementation,two pointers",324
"n,m,k = map(int,input().split())
P = [int(x) for x in input().split()]
P.reverse()

# pages of size k
ops = 0
i = 1
while P:
    # while space left
    #   fill elements and count special
    #   remove special
    #   ops += 1

    # put elements in while not special

    # then onto next page

    nxt = P[-1]
    togo = nxt - i
    skip = togo//k*k
    i += skip

    space = k
    while space:
        special = 0
        while P and P[-1] < i + space:
            special += 1
            P.pop()
        i += space
        if not special:
            break
        ops += 1
        space = special

print(ops)
",linear,"implementation,two pointers",617
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
A=list(map(int,input().split()))
A.append(n+1)
COMP=[]
NOW=0
for a in A:
    if a-NOW-1!=0:
        if a-NOW-1>2*k:
            COMP.append([(a-NOW-1)%k+k,0])
        else:
            COMP.append([a-NOW-1,0])
    COMP.append([1,1])
    NOW=a
    
COMP.pop()

#print(COMP)

ANS=0
NOW_PAGE=0
NOW_SCORE=0

pa=0
LEN=len(COMP)
while pa<LEN:
    i,j=COMP[pa]
  
    if NOW_PAGE+i<=k:
        NOW_PAGE += i
        NOW_SCORE += j
        pa+=1

    else:
        if NOW_SCORE>0:

            COMP[pa][0]-=k-NOW_PAGE
            NOW_PAGE=k-NOW_SCORE

            ANS+=1
            NOW_SCORE=0

        else:
            if NOW_PAGE==k:
                NOW_PAGE=0
                
            else:              
                COMP[pa][0]-=k-NOW_PAGE
                NOW_PAGE=k-NOW_SCORE

    #print(i,j,pa,NOW_PAGE,NOW_SCORE,ANS,COMP)

if NOW_SCORE>0:
    ANS+=1
    
print(ANS)

        
        
    
",linear,"implementation,two pointers",969
"n,m,k=map(int,input().split())
p=list(map(int,input().split()))
count=0
delete=0
now=0
while now<m:
    up=((p[now]-delete-1)//k+1)*k+delete
    while now<m and p[now]<=up:
        now+=1
        delete+=1
    count+=1
print(count)",linear,"implementation,two pointers",231
"n, m, k = map(int, input().split())
mi = list(map(int, input().split()))

ans = 0
items_to_del = 0
shift = 1
c_page = None
for el in mi:
    if c_page is None:
        c_page = (el - shift) // k
        items_to_del = 1
    else:
        page = (el - shift) // k
        if page != c_page:
            shift += items_to_del
            ans += 1
            c_page = (el - shift) // k
            items_to_del = 1
        else:
            items_to_del += 1
if items_to_del != 0:
    ans += 1
print(ans)
",linear,"implementation,two pointers",503
"from sys import stdin, stdout
n,m,k = [int(x) for x in stdin.readline().rstrip().split()]
L = [int(x) for x in stdin.readline().rstrip().split()]
off=1
page=-1
c=0
ans=0
for l in L:
    p=(l-off)//k
    if p==page:
        c+=1
    else:
        off+=c
        c=1
        ans+=1
        page=(l-off)//k
    
stdout.write( str(ans) + ""\n"" )",linear,"implementation,two pointers",340
"n, m, k = map(int, input().split(' '))
p = tuple(map(int, input().split(' ')))


d = 0
part = (p[0]-1) // k
moves = 0
skip = 0

for pi in p:
    if (pi-1-d) // k == part:
        skip += 1
        continue
    d += skip
    part = (pi-1-d) // k
    skip = 1
    moves += 1

print(moves+1)
",linear,"implementation,two pointers",289
"import math
import collections

def func(a, k):
    if a % k != 0:
        mod = 1
    else:
        mod = 0
    return math.floor(a / k) * k + mod * k
 
n, m, k = input().split()
list = input().split()
k = int(k)
temp = k
size = 0
answer = 0
c = 0
c2 = 0
check = 'false'
used = 0

temp = func(int(list[0]), k)
for i in range(len(list)):
    list[i] = int(list[i])
    used = 0
    if list[i] <= temp:
        c += 1
        check = 'true'
        used = 1
    if list[i] >= temp:
        if check is 'true':
            answer += 1
            check = 'false'
            temp += c
            c = 0
            if list[i] - c <= temp and used == 0:
                c += 1
                check = 'true'
                used = 1
            else:
                temp = temp + func(int(list[i]) - temp, k)
                if list[i] - c <= temp and used == 0:
                    c += 1
                    check = 'true'
                    used = 1
        elif check is 'false':
            temp = temp + func(int(list[i]) - temp, k)
            if list[i] - c <= temp and used == 0:
                c += 1
                check = 'true'
                used = 1
    
 
print(answer if check is 'false' else answer + 1)",linear,"implementation,two pointers",1223
"# Author : nitish420 --------------------------------------------------------------------
import os
import sys
from io import BytesIO, IOBase

from collections import Counter

def main():
    n=int(input())
    a=list(map(int,input().split()))
    d=dict()
    z=0
    s=0
    for item in a:
        if item in d:
            d[item]+=1
            z=item
        else:
            d[item]=1
        s+=item

    if len(a)-len(d)>=2:
        print(""cslnb"")
        exit()
    if len(a)==len(d):
        z=(n*(n-1))//2
        if (s-z)%2:
            print(""sjfnb"")
        else:
            print(""cslnb"")
        
    else:
        if z-1 in d or z==0:
            print(""cslnb"")
        else:
            zz=(n*(n-1))//2
            if (s-zz)%2:
                print(""sjfnb"")
            else:
                print(""cslnb"")

        
    


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')


# endregion

if __name__ == '__main__':
    main()",linear,games,2565
"n = int(input())
a = list(map(int,input().split()))

dupes = 0
dupeVal = -1
d = set()
for el in a:
    if el in d:
        dupes += 1
        dupeVal = el
    else:
        d.add(el)

inPlay = True
if dupes > 1:
    print('cslnb')
    inPlay = False
elif dupes == 1:
    if dupeVal == 0 or (dupeVal - 1) in d:
        print('cslnb')
        inPlay = False

if inPlay:
    finalSum = (n*(n-1))//2
    Sum = sum(a)
    if (Sum - finalSum) % 2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
    
",linear,games,508
"from collections import defaultdict as dd, deque
n = int(input())
A = [int(x) for x in input().split()]
n = len(A)

C = dd(int)
for a in A:
    C[a] += 1

thedup = None
ndup = 0
screwed = False
for c in C:
    if C[c] > 2:
        screwed = True
    elif C[c] == 2:
        if c == 0:
            screwed = True
        thedup = c
        ndup += 1

import sys
if screwed or ndup > 1:
    print('cslnb')
else:
    if ndup == 1:
        if C[thedup-1] != 0:
            print('cslnb')
            sys.exit()
        

    target = sum(range(n))
    cur = sum(A)
    togo = cur - target

    if togo%2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
",linear,games,662
"#!/usr/bin/python3
# -*- coding: utf-8 -*-

import sys

def rl(proc=None):
    if proc is not None:
        return proc(sys.stdin.readline())
    else:
        return sys.stdin.readline().rstrip()

def srl(proc=None):
    if proc is not None:
        return list(map(proc, rl().split()))
    else:
        return rl().split()

def main():
    rl()
    a = srl(int)
    a.sort()
    cnt = 0
    for i in range(0, len(a)-1):
        if a[i] == a[i+1]:
            a[i] -= 1
            cnt += 1
            break
    if a[0] < 0:
        print('cslnb')
        return

    for i in range(0, len(a)-1):
        if a[i] == a[i+1]:
            print('cslnb')
            return

    for i, x in enumerate(a):
        cnt += x - i

    print('sjfnb' if (cnt & 1) else 'cslnb')


if __name__ == '__main__':
    main()
",linear,games,811
"n = int(input())
a = sorted(list(map(int,input().split())))
bal = 0
if a.count(0)>1:
    print('cslnb')
    exit()
if n-len(set(a))>1:
    print('cslnb')
    exit()
if n-len(set(a))==1:
    for i in range(1,n):
        if a[i]==a[i-1]:
            if a[i]-1 in a:
                print('cslnb')
                exit()
            break
if n==1:
    print('cslnb' if not a[0] % 2 else 'sjfnb')
    exit()

for i in range(n):
    bal+=a[i]-i
print('sjfnb'if bal%2 else 'cslnb')",linear,games,475
"n = int(input())
a = sorted(list(map(int, input().split())))
duplicates = {}
d = None
delta = 0
for i, el in enumerate(a, 1):
    if el not in duplicates:
        duplicates[el] = 0
    else:
        d = el
        duplicates[el] += 1
    min_value = i-1
    delta += el - min_value
if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):
    print('cslnb')
elif delta == 0:
    print('cslnb')
elif delta % 2 == 1:
    print('sjfnb')
else:
    print('cslnb')
",linear,games,506
"n = int(raw_input())
a = sorted(list(map(int, raw_input().split())))
duplicates = {}
d = None
delta = 0
for i, el in enumerate(a, 1):
    if el not in duplicates:
        duplicates[el] = 0
    else:
        d = el
        duplicates[el] += 1
    min_value = i-1
    delta += el - min_value
if sum(duplicates.values()) > 1 or duplicates.get(0, 0) >= 1 or (d is not None and d-1 in duplicates):
    print('cslnb')
elif delta == 0:
    print('cslnb')
elif delta % 2 == 1:
    print('sjfnb')
else:
    print('cslnb')",linear,games,513
"import sys


def is_winning_state(nims, n):
    keys = set(nims)
    counts = dict.fromkeys(keys, 0)
    for nim in nims:
        counts[nim] += 1
    if 0 in keys and counts[0] > 1:
        return True
    lose_count = 0
    for k in keys:
        if counts[k] > 2:
            return True
        if counts[k] > 1 and (k - 1) in keys and counts[k - 1] > 0:
            return True
        if counts[k] > 1:
            lose_count += 1
    if lose_count > 1:
        return True
    return False

def main():
    n = int(input())
    nims = list(map(int, input().split()))
    if is_winning_state(nims, n):
        print('cslnb')
    else:
        x = sum(nims) - (n * (n - 1)) // 2
        if x % 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')

main()
",linear,games,783
"from collections import Counter
import sys
readline = sys.stdin.readline


def check(A):
    CA = Counter(A)
    if CA[0] >= 2:
        return False
    cnt = 0
    for k, v in CA.items():
        if v > 2:
            return False
        if v == 2 and CA[k-1] >= 1:
            return False
        if v >= 2:
            cnt += 1
    if cnt >= 2:
        return False
    L = len(A)
    if (sum(A) - L*(L-1)//2) % 2 == 0:
        return False
    return True
    
N = int(readline())
if check(list(map(int, readline().split()))):
    print('sjfnb')
else:
    print('cslnb')
 	  		 		  		    	 					  			",linear,games,606
"import sys
import copy
input = sys.stdin.readline

n,k=map(int,input().split())
C=list(input().strip())

def JUDGE(C):
    ANS_one=0
    ANS_zero=0

    for c in C:
        if c==""0"":
            ANS_zero+=1
        else:
            break

    for c in C[::-1]:
        if c==""0"":
            ANS_zero+=1
        else:
            break

    for c in C:
        if c==""1"":
            ANS_one+=1
        else:
            break

    for c in C[::-1]:
        if c==""1"":
            ANS_one+=1
        else:
            break

    if ANS_zero>=n-k or ANS_one>=n-k:
        return 1
    else:
        return 0

if JUDGE(C)==1:
    print(""tokitsukaze"")
    sys.exit()

if k>=n-1:
    print(""quailty"")
    sys.exit()
if k<n/2:
    print(""once again"")
    sys.exit()
    

CAN1=copy.copy(C)
CAN2=copy.copy(C)

if C[0]==""0"":
    for i in range(1,k+1):
        CAN1[i]=""1""
else:
    for i in range(1,k+1):
        CAN1[i]=""0""

if C[-1]==""0"":
    for i in range(n-1,n-k-1,-1):
        CAN2[i]=""1""
else:
    for i in range(n-2,n-k-2,-1):
        CAN2[i]=""0""

if JUDGE(CAN1)==1 and JUDGE(CAN2)==1:
    print(""quailty"")
    sys.exit()
else:
    print(""once again"")
    sys.exit()
    
    
    
",linear,"brute force,games,greedy",1185
"import sys
import copy
input = sys.stdin.readline
n,k=map(int,raw_input().split())
C=list(raw_input().strip())
def JUDGE(C):
    ANS_one=0
    ANS_zero=0
    for c in C:
        if c==""0"":
            ANS_zero+=1
        else:
            break
    for c in C[::-1]:
        if c==""0"":
            ANS_zero+=1
        else:
            break
    for c in C:
        if c==""1"":
            ANS_one+=1
        else:
            break
    for c in C[::-1]:
        if c==""1"":
            ANS_one+=1
        else:
            break
    if ANS_zero>=n-k or ANS_one>=n-k:
        return 1
    else:
        return 0
if JUDGE(C)==1:
    print(""tokitsukaze"")
    sys.exit()
if k>=n-1:
    print(""quailty"")
    sys.exit()
if k<n/2:
    print(""once again"")
    sys.exit()
CAN1=copy.copy(C)
CAN2=copy.copy(C)
if C[0]==""0"":
    for i in range(1,k+1):
        CAN1[i]=""1""
else:
    for i in range(1,k+1):
        CAN1[i]=""0""
if C[-1]==""0"":
    for i in range(n-1,n-k-1,-1):
        CAN2[i]=""1""
else:
    for i in range(n-2,n-k-2,-1):
        CAN2[i]=""0""
if JUDGE(CAN1)==1 and JUDGE(CAN2)==1:
    print(""quailty"")
    sys.exit()
else:
    print(""once again"")
    sys.exit()",linear,"brute force,games,greedy",1159
"import sys

def sum_range(l, r):
    if r < l: return 0
    if l == 0: return sum[r]
    return sum[r] - sum[l - 1]

n, k = map(int, input().split())

cards = input()

sum = [0] * n
sum[0] = 1 if cards[0] == '1' else 0
for i in range(1, n):
    sum[i] += sum[i - 1]
    if cards[i] == '1':
        sum[i] += 1

min0 = min1 = n
max0 = max1 = -1
for i in range(0, n):
    if cards[i] == '1':
        min1 = min(min1, i)
        max1 = i
    else:
        min0 = min(min0, i)
        max0 = i
        
toki = False
qual = True
for i in range(0, n - k + 1):
    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + k == n:
        toki = True
    if sum_range(0, i - 1) + sum_range(i + k, n - 1) + 0 == 0:
        toki = True
        
    prefix = sum_range(0, i - 1) == 0
    suffix = sum_range(i + k, n - 1) == 0
    if i > 0 and i + k < n and (prefix ^ suffix) == 0:
        qual = False
    if i - min0 > k or i - min1 > k or max0 - (i + k - 1) > k or max1 - (i + k - 1) > k:
        qual = False

if toki == True:
    print('tokitsukaze')
elif qual == True:
    print('quailty')
else:
    print('once again')",linear,"brute force,games,greedy",1107
"#!/usr/bin/env python3

def win1():
    if n==k or r[k+1]==n or l[n-k]==1:
        return True
    for i in range(2,n-k+1):
        if l[i-1]==1 and r[i+k]==n and a[i-1]==a[i+k]:
            return True
    return False

def win2():
    if 2*k<n:
        return False
    for i in range(2,n-k+1):
        if l[i-1]!=1 or r[i+k]!=n:
            return False
    return True

if __name__ == ""__main__"":
    s=input().split()
    n,k=int(s[0]),int(s[1])
    s=input().split()
    a=[0]
    l=[0 for i in range(n+1)]
    r=[0 for i in range(n+1)]
    for c in s[0]:
        a.append(int(c))
    l[1],r[n]=1,n
    for i in range(2,n+1):
        if a[i-1]==a[i]:
            l[i]=l[i-1]
        else:
            l[i]=i
        if a[n-i+1]==a[n-i+2]:
            r[n-i+1]=r[n-i+2]
        else:
            r[n-i+1]=n-i+1
    # print(l,r)
    if win1():
        print(""tokitsukaze"")
    elif win2():
        print(""quailty"")
    else:
        print(""once again"")
 		  	   		 	  	 	 	    	 	   	",linear,"brute force,games,greedy",988
"cards=list(input().split())
lm=[0]*9
lp=[0]*9
ls=[0]*9
for item in cards:
    if item[1]=='m':
        lm[int(item[0])-1]+=1
    elif item[1]=='p':
        lp[int(item[0])-1]+=1
    else :
        ls[int(item[0])-1]+=1
if max(lm)==3 or max(lp)==3 or max(ls)==3:
    print(0)
else :
    flag=0
    def seq_checker(li):
        flag=0
        for i in range(9):
            if flag==0:
                if lm[i]==1:
                    flag=1
            else :
                if lm[i]==1:
                    flag+=1
                else :
                    break
        return flag
    if seq_checker(lm)==3 or seq_checker(lp)==3 or seq_checker(ls)==3:
        print(0)
    elif max(lm)==2 or max(lp)==2 or max(ls)==2:
        print(1)
    else :
        m=0
        for i in range(0,7):
            m=max(sum(lm[i:i+3]),sum(lp[i:i+3]),sum(ls[i:i+3]),m)
        print(3-m)",linear,"brute force,implementation",875
"m={""s"":[0]*9, ""m"":[0]*9, ""p"":[0]*9}
for e in input().split():
    m[e[1]][int(e[0])-1]+=1
ret=2
for t in ""smp"":
    l=m[t]
    if max(l)>=2:
        ret=min(ret, 3-max(l))
    else:
        for i in range(7):
            seq = sum(l[i:i+3])
            ret = min(ret, 3-seq)
print(ret)",linear,"brute force,implementation",285
"a = input().split()
st = set([])
cnt = [[0 for i in range(9)] for i in range(3)]
for e in a:
    cnt['mps'.index(e[1])][int(e[0]) - 1] = 1
    st.add(e)
answ = len(st) - 1
for i in range(3):
    for j in range(7):
        answ = min(answ, 3 - sum(cnt[i][j:j + 3]))
print(answ)",linear,"brute force,implementation",276
"s = [0] * 10
m = [0] * 10
p = [0] * 10
D = list(input().split())
for i in D:
    if i[1] == 'p':
        p[int(i[0])] += 1
    elif i[1] == 'm':
        m[int(i[0])] += 1
    else:
        s[int(i[0])] += 1

need = 3
for i in range(1, 10):
    need = min(3 - p[i], need)
    need = min(3 - s[i], need)
    need = min(3 - m[i], need)
    if i <= 7:
        tmp = 0
        tmp += min(1, p[i])
        tmp += min(1, p[i + 1])
        tmp += min(1, p[i + 2])
        need = min(3 - tmp, need)
        tmp = 0
        tmp += min(1, m[i])
        tmp += min(1, m[i + 1])
        tmp += min(1, m[i + 2])
        need = min(3 - tmp, need)
        tmp = 0
        tmp += min(1, s[i])
        tmp += min(1, s[i + 1])
        tmp += min(1, s[i + 2])
        need = min(3 - tmp, need)

print(need)
",linear,"brute force,implementation",787
"from sys import stdin, stdout

#N = int(input())

#arr = [int(x) for x in stdin.readline().split()]

s = input()

s = s.split(' ')

#print(s)

M = [0]*9
P = [0]*9
S = [0]*9

for pile in s:
    pile = list(pile)
    #print(pile)
    num = int(pile[0])
    tile = pile[1]
    
    if tile=='s':
        S[num-1] += 1
    elif tile=='p':
        P[num-1] += 1
    elif tile=='m':
        M[num-1] += 1
        
for i in range(9):
    if M[i]==3:
        print(0)
        quit()
    if P[i]==3:
        print(0)
        quit()
    if S[i]==3:
        print(0)
        quit()
        
for i in range(7):
    if M[i]==1 and M[i+1]==1 and M[i+2]==1:
        print(0)
        quit()
    if P[i]==1 and P[i+1]==1 and P[i+2]==1:
        print(0)
        quit()
    if S[i]==1 and S[i+1]==1 and S[i+2]==1:
        print(0)
        quit()

for i in range(9):
    if M[i]==2:
        print(1)
        quit()
    if P[i]==2:
        print(1)
        quit()
    if S[i]==2:
        print(1)
        quit()
        
for i in range(8):
    if M[i]==1 and M[i+1]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+1]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+1]==1:
        print(1)
        quit()
        
for i in range(7):
    if M[i]==1 and M[i+2]==1:
        print(1)
        quit()
    if P[i]==1 and P[i+2]==1:
        print(1)
        quit()
    if S[i]==1 and S[i+2]==1:
        print(1)
        quit()
        
print(2)
        
    
        ",linear,"brute force,implementation",1459
"
def main():
    buf = input()
    buflist = buf.split()
    hand = buflist;
    t = []
    for i in range(3):
        t.append([])
        for j in range(9):
            t[i].append(0)
    for x in hand:
        idx = 0
        if x[1] == 'm':
            idx = 0
        elif x[1] == 'p':
            idx = 1
        elif x[1] == 's':
            idx = 2
        t[idx][int(x[0])-1] += 1
    max_cons = 0
    max_mult = 0
    for i in range(3):
        cons = [0, 0, 0]
        for j in range(9):
            cons[0] = cons[1]
            cons[1] = cons[2]
            if t[i][j] > 0:
                cons[2] = 1
            else:
                cons[2] = 0
            max_cons = max(sum(cons), max_cons)
            max_mult = max(max_mult, t[i][j])
    print(3 - max(max_cons, max_mult))

if __name__ == '__main__':
    main()
",linear,"brute force,implementation",833
"s = input()
ans = 2
s1 = s[0:2]
s2 = s[3:5]
s3 = s[6:8]
def func(inp):
    ans = 2
    num = int(inp[0])
    c = inp[1]
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num + 2)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num + 1)+c) != -1) - int(s.find(str(num - 1)+c) != -1))
    ans = min( ans, 2 - int(s.find(str(num - 1)+c) != -1) - int(s.find(str(num - 2)+c) != -1))
    ans = min( ans, 3 - s.count(inp))
    return ans
ans = min(ans,func(s1))
ans = min(ans,func(s2))
ans = min(ans,func(s3))
print(ans)
",linear,"brute force,implementation",541
"s = input().split()
hand = {'m': [], 'p': [], 's':[]}

for item in s:
	hand[item[1]].append(int(item[0]))


min_steps_needed = 10

for symb in ['m', 'p', 's']:
	hand[symb] = sorted(hand[symb])
	for start in range(1, 10):
		a_needed = 10
		b_needed = 10

		a_needed = 3 - hand[symb].count(start)

		b1, b2, b3 = 0, 0, 0
		if hand[symb].count(start) > 0:
			b1 = 1
		if hand[symb].count(start+1) > 0:
			b2 = 1
		if hand[symb].count(start+2) > 0:
			b3 = 1

		b_needed = 3 - b1 - b2 - b3

		if a_needed < min_steps_needed:
			min_steps_needed = a_needed
		if b_needed < min_steps_needed:
			min_steps_needed = b_needed



# print(s)
# print(hand)
print(min_steps_needed)",linear,"brute force,implementation",668
"m=[x for x in input().split()]
tiles=[[0 for i in range(9)] for j in range(3)]
for i in range(len(m)):
    g=int(m[i][0])-1
    h=(m[i][1])    
    if h==""m"":
        tiles[0][g]+=1
    elif h==""p"":
        tiles[1][g]+=1
    else:
        tiles[2][g]+=1
if m[0]==m[1] and m[1]==m[2]:
    print(0)
elif m[0]==m[1]:
    print(1)
elif m[0]==m[2]:
    print(1)
elif m[1]==m[2]:
    print(1)
else:
    n=False
    for i in range(3):
        for j in range(9):
            if tiles[i][j]!=0:
                if j!=8 and tiles[i][j+1]!=0:
                    if j!=7 and tiles[i][j+2]!=0:
                        print(0)
                        n=True
                        break
                    else:
                        print(1)
                        n=True
                        break
                elif j!=7 and j!=8 and tiles[i][j+2]!=0:
                    print(1)
                    n=True
                    break
    if n==False:
        print(2)",linear,"brute force,implementation",969
"n, m, k = map(int, input().split())
arr = [int(x) for x in input().split()]
modulo = 0
tmp = 0
op = 1
cur = (arr[0] - 1) // k
for i in range(m):
    if (arr[i] - 1 - modulo) // k != cur:
        modulo += tmp
        cur = (arr[i] - 1 - modulo) // k
        tmp = 0
        op += 1
    tmp += 1
print(op)",linear,implementation,304
"n,m,k = map(int,input().split())
pi = list(map(int,input().split()))
num = 1
ans = 0
i = 0
while i < m:
    temp = (pi[i] - num) // k
    temp2 = i
    i += 1
    while i < m :
        if temp != (pi[i] - num) // k:
            break
        i += 1
    num += (i - temp2)
    ans += 1
print(ans)
",linear,implementation,296
"n = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
k = n[2]
ans = 0
dele = 1
i = 0
while(i<n[1]):
	count = 1
	while(((i+count)<n[1]) and (a[(i+count)]-dele)//k == (a[i]-dele)//k):
		count += 1
	# print(count,(a[(i+count)]-dele)//k,(a[i]-dele)//k)
	ans += 1
	dele += count
	i += count
print(ans)",linear,implementation,319
"#573_C

import math

ln = [int(i) for i in input().split("" "")]

n = ln[0]
m = ln[1]
k = ln[2]

p = [int(i) for i in input().split("" "")]

i = 0
ct = 0
ops = 0
while i < len(p):
    nm = p[i] - ct
    if nm % k == 0:
        mnm = nm
    else:
        mnm = (nm // k) * k + k
    si = i
    while p[i] - ct <= mnm:
        i += 1
        if i >= len(p):
            break
    ct += i - si
    ops += 1
    if i >= len(p):
        break
print(ops)
",linear,implementation,445
"from collections import deque

n, m, k = map(int, input().split())
a = deque([int(i) for i in input().split()])

oper = 0
rem = 0
while a:
    x = a.popleft()
    pg = (x - 1 - rem) // k
    lrem = 1
    while a and (a[0] - 1 - rem) // k == pg:
        a.popleft()
        lrem += 1
    rem += lrem
    oper += 1
print(oper)
",linear,implementation,325
"reduced = 1
n, m ,k = map(int,input().split())

p = list(map(int, input().split()))

p.reverse()
cnt = 0
while(len(p)):
    
    cnt1 = 1
    first = p.pop()
    fack = ((first - reduced)//k) * k
    while(len(p) and p[-1] - fack - reduced < k):
        cnt1 += 1
        p.pop()
    
    reduced += cnt1
    cnt += 1
print(cnt)",linear,implementation,328
"n,m,k=map(int,input().split())
arr=list(map(int,input().split()))
arr+=[0]*m
ans=0
pos=0
while arr[pos]!=0:
  page=(arr[pos]-pos-1)//k
  tmp=1
  for i in range(1,k):
    if pos+i>=2*m-1:
      break
    if (arr[pos+i]-pos-1)//k==page:
      tmp+=1
    else:
      break
  pos+=tmp
  ans+=1
print(ans)",linear,implementation,300
"from sys import stdin
from bisect import bisect_right as br

from collections import deque
n,m,k=map(int,stdin.readline().strip().split())
s=deque(map(int,stdin.readline().strip().split()))
lim=k
ans=0
while len(s)!=0:
    x=br(s,lim)
    for i in range(x):
        s.popleft()
    if x!=0:
        ans+=1
        lim+=x
    else:
        if len(s)>0:
            x=s[0]-lim
            if x%k==0:
                x=x//k
            else:
                x=(x//k)+1
            lim+=x*k
        
print(ans)
",linear,implementation,507
"ints=[int(x) for x in input().split()]
n=ints[0] # number of ints
m=ints[1] # num special
k=ints[2] # divider
special=[int(x) for x in input().split()]
numOn=0
numOps=0
while numOn<m:
    numOps+=1
    op=((special[numOn]-numOn-1)//(k))*k+k+numOn+1
    while numOn<m and special[numOn]<op:
        numOn+=1
print(numOps)",linear,implementation,320
"n=int(input())
a=[int(x) for x in input().split()]
pro=n*(n-1)//2
dic={}
for item in a:
    if item not in dic:
        dic[item]=1
    else:
        dic[item]+=1
counter=0
for item in dic:
    if 0 in dic and dic[0]>=2:
        print('cslnb')
        break
    if dic[item]>2:
        print('cslnb')
        break
    elif dic[item]==2:
        if counter==1 or item-1 in dic:
            print('cslnb')
            break
        else:
            counter=1
else:
    if (sum(a)-pro)%2==1:
        print('sjfnb')
    else:
        print('cslnb')
",linear,games,547
"n = int(input())
a = list(map(int, input().split()))
d = {}
for ai in a:
	if ai in d:
		d[ai] += 1
	else:
		d[ai] = 1
if max(d.values()) >= 3 or 0 in d and d[0] >= 2 or list(d.values()).count(2) >= 2:
	print('cslnb')
	exit()
for i in d:
	if d[i] == 2 and i - 1 in d:
		print('cslnb')
		exit()
s = sum(a)
if s >= n * (n - 1) // 2:
	if (s - n * (n - 1) // 2) % 2 == 0:
		print('cslnb')
	else:
		print('sjfnb')
else:
	pass

",linear,games,421
"n=int(input())
arr=list(map(int,input().split()))
dic={}
for val in arr:
  if val not in dic:
    dic[val]=1
  else:
    dic[val]+=1
flag1=True
if 0 in dic:
  if dic[0]>=2:
    flag1=False
cnt=0
for val in dic.keys():
  if dic[val]>=3:
    flag1=False
    break
  if dic[val]==2:
    cnt+=1
    if val-1 in dic:
      flag1=False
      break
if cnt>=2:
  flag1=False
if flag1==False:
  print('cslnb')
else:
  flag2=(n*(n-1)//2+sum(arr))%2
  if flag2==1:
    print('sjfnb')
  else:
    print('cslnb')",linear,games,499
"n = int(input())
lst = [int(i) for i in input().split()]
st = set()
flag = False
count = 0
for i in lst:
    if i not in st:
        st.add(i)
    else:
        flag = True
        count+=1
        lol = i
sum1 = n*(n-1)//2
if count>1:
    print('cslnb')
    quit()
if not flag:    
    if (sum(lst)- sum1)% 2 == 0:
        print('cslnb')
    else:
        print('sjfnb')
else:
    if (lol-1) in lst or lol == 0:
        print('cslnb')
    else:
        if (sum(lst)- sum1)% 2 == 0:
            print('cslnb')
        else:
            print('sjfnb')
",linear,games,551
"n = int(input())

arr = list(map(int, input().split()))

solved = False
s = sum(arr)
if s == 0:
	print(""cslnb"")
	solved = True

if not solved:
	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		print('cslnb')
		solved = True

	if not solved:
		for key in n_num.keys():
			if n_num[key] >= 3:
				print(""cslnb"")
				solved = True

		ind_pairs = []
		if not solved:
			for key in n_num.keys():
				if n_num[key] == 2:
					ind_pairs.append(key)

			if len(ind_pairs) >= 2:
				print(""cslnb"")
				solved = True
			elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
				print(""cslnb"")
				solved = True
			else:
				# print('s', s)
				sum_targ = n*(n-1) // 2
				# print('sum_targ', sum_targ)
				dif_sum = s - sum_targ
				# print(""dif_sum"", dif_sum)
				if dif_sum % 2 == 0:
					print(""cslnb"")
				else:
					print(""sjfnb"")",linear,games,912
"n = int(input())
a = [int(i) for i in input().split()]

total = sum(a)
final = n * (n-1) // 2
repeated = []
count = {}

for i in a:
    try:
        count[i] += 1
        repeated.append(i)
    except KeyError:
        count[i] = 1


# for i, num in enumerate(a):
#     if i in a[:i]:
#         repeated.append(i)

moves = total - final

if len(repeated) > 1:
    print('cslnb')

elif 0 in repeated:
    print('cslnb')

elif len(repeated) == 1 and repeated[0] - 1 in a:
    print('cslnb')

else:
    if moves % 2 == 0 or moves <= 0:
        print('cslnb')
    else:
        print('sjfnb')
",linear,games,589
"def solve(n, arr):
	s = sum(arr)
	if s == 0:
		return ""cslnb""

	n_num = {}

	for item in arr:
		if item in n_num:
			n_num[item] += 1
		else:
			n_num[item] = 1

	if 0 in n_num and n_num[0] >= 2:
		return 'cslnb'

	for key in n_num.keys():
		if n_num[key] >= 3:
			return ""cslnb""

	ind_pairs = []
	for key in n_num.keys():
		if n_num[key] == 2:
			ind_pairs.append(key)

	if len(ind_pairs) >= 2:
		return ""cslnb""
	elif len(ind_pairs) == 1 and (ind_pairs[0]-1) in n_num:
		return ""cslnb""
	else:
		# print('s', s)
		sum_targ = n*(n-1) // 2
		# print('sum_targ', sum_targ)
		dif_sum = s - sum_targ
		# print(""dif_sum"", dif_sum)
		if dif_sum % 2 == 0:
			return ""cslnb""
		else:
			return ""sjfnb""


n = int(input())

arr = list(map(int, input().split()))
print(solve(n, arr))

",linear,games,772
"import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()
 
ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n, k = mi()
ans = None
for x in range(1, n + 1):
    if x * (x + 3) == 2 * (k + n):
        ans = n - x
        break
print(ans)",linear,"binary search,brute force,math",321
"turns, candies = map(int, input().split())
summ = 0
turn = 0
while candies != summ - (turns - turn):
    turn += 1
    summ += turn
print(turns - turn)",linear,"binary search,brute force,math",151
"n, k = map(int, input().split())
c = 1
while c * (c + 1) // 2 < k:
    c += 1
while c * (c + 1) // 2 - (n - c) != k:
    c += 1
print(n - c)
",linear,"binary search,brute force,math",141
"n, k = [int(i) for i in input().split()]
for i in range(100*k+100*n):
    if i*(i+1) == (n+k-i)*2:
        print(n-i)
        break",linear,"binary search,brute force,math",131
"from collections import Counter

n, k = map(int, input().split())

for p in range(n+1):
    if p*(p+1)//2 - (n-p) == k:
        print(n-p)
        break
",linear,"binary search,brute force,math",153
"import sys

def input():
    return sys.stdin.readline().strip()

def dinput():
    return int(input())

def tinput():
    return input().split()

def rinput():
    return map(int, tinput())

def rt(x1, x2, y3):
    print(0.5 * (x2 + x1) * y3)

def main():
    n, k = rinput()
    i = 0
    t = 0
    while k > i:
        t += 1
        i += t
    c = n - t
    i -= c
    while i != k:
        t += 1
        i += t + 1
        c -= 1
    print(c)
main()",linear,"binary search,brute force,math",455
"from math import*
n,k=map(int,input().split())
s=1
dob=2
for i in range(1,n):
    s+=dob
    dob+=1
    if s-(n-i-1)==k:
        print(n-i-1)
        exit()
print(0)

",linear,"binary search,brute force,math",167
"
n,k = map(int,input().split())

for puts in range(10**9):
    candy = puts*(puts+1)//2
    if candy - (n-puts) == k:
        print(n-puts)
        exit(0)





",linear,"binary search,brute force,math",161
"from sys import stdin
from collections import deque
c=int(stdin.readline().strip())
for cas in range(c):
    n,m=map(int,stdin.readline().strip().split())
    s=deque(stdin.readline().strip())
    arr=[""R"",""G"",""B""]
    ans=n+3
    for k in range(1):

        for  i in range(3):
            x=i

            dp=[0 for i in range(n+1)]
            for j in range(n):

                if s[j]!=arr[x]:
                    dp[j+1]+=1
                dp[j+1]+=dp[j]
                if j+1>=m:

                    ans=min(ans,dp[j+1]-dp[j+1-m])
                x+=1
                x=x%3

    print(ans)
                
            
    
            
            
1
",linear,implementation,663
"from sys import stdin
import math

rgb = 'RGB'

for query in range(int(stdin.readline())):
    n, k = map(int, stdin.readline().split())
    s = stdin.readline()

    ans = math.inf
    for start in range(3):
        dp = [0 for i in range(n + 1)] 
        for i in range(n):
            cur = rgb[(start + i) % len(rgb)]
            dp[i + 1] = dp[i] + int(s[i] != cur)
        for i in range(n - k + 1):
            ans = min(ans, dp[i + k] - dp[i])
    print(ans)


",linear,implementation,469
"import sys
input = sys.stdin.readline

q=int(input())

for testcases in range(q):
    n,k=map(int,input().split())
    S=list(input().strip())

    for i in range(n):
        if S[i]==""R"":
            S[i]=0
        elif S[i]==""G"":
            S[i]=1
        else:
            S[i]=2

    ANS=1<<50



    for mod in range(3):
        SUM=0
        for i in range(k):
            if S[i]%3!=(mod+i)%3:
                SUM+=1

        ANS=min(ANS,SUM)


        for i in range(k,n):
            if S[i-k]!=(mod+(i-k))%3:
                SUM-=1
            if S[i]!=(mod+i)%3:
                SUM+=1



            ANS=min(ANS,SUM)

    print(ANS)

        
                
        

    
",linear,implementation,688
"Q = int(input())
for _ in range(Q):
    N, K = map(int, input().split())
    S = input()
    X = [{""R"":0, ""G"":1, ""B"":2}[s] for s in S]
    mi = K
    for i in range(3):
        d = 0
        for j in range(N):
            if X[j] != (i+j) % 3:
                d += 1
            if j >= K and X[j-K] != (i+j-K) % 3:
                d -= 1
            if j >= K-1:
                mi = min(mi, d)
    print(mi)
",linear,implementation,410
"def matches(pos, c, case):
    if case==0:
        return pos%3==""RGB"".index(c)
    elif case==1:
        return pos%3==""GBR"".index(c)
    else:
        return pos%3==""BRG"".index(c)

q = int(input())
for _ in range(q):
    n, k = map(int, input().split())

    s = input()

    mglobal = k

    r=g=b=0

    for i, c in enumerate(s[:k]):
            
        r += not matches(i, c, 0)
        g += not matches(i, c, 1)
        b += not matches(i, c, 2)
    
    mglobal = min([mglobal, r, g, b])
    for i, c in enumerate(s[k:]):
        i+=k
        r += -(not matches(i-k, s[i-k], 0)) + (not matches(i, c, 0))    
        g += -(not matches(i-k, s[i-k], 1)) + (not matches(i, c, 1))    
        b += -(not matches(i-k, s[i-k], 2)) + (not matches(i, c, 2))    
    
        mglobal = min([mglobal, r, g, b])

    print(mglobal)
",linear,implementation,829
"def solve(d, n, k):
    mv = sum(d[0:k])
    v = mv
    for i in range(1, n-k+1):
        mv = mv + d[i+k-1] - d[i-1]
        v = min(v, mv)
    return v

for _ in range(int(input())):
    n, k = tuple(map(int, input().split()))
    s = input()
    st = 'RGB' * (n//3 + 3)
    diff1, diff2, diff3 = [0 for _ in range(n)], [0 for _ in range(n)], [0 for _ in range(n)]

    for i in range(n):
        if s[i] != st[i]: diff1[i] = 1
        if s[i] != st[i+1]: diff2[i] = 1
        if s[i] != st[i+2]: diff3[i] = 1

    print(min(solve(diff1, n, k), solve(diff2, n, k), solve(diff3, n, k)))",linear,implementation,587
"'''input
3
5 2
BGGGG
5 3
RBRGR
5 5
BBBRR
'''
import sys
from collections import defaultdict as dd

mod=10**9+7

def ri(flag=0):
	if flag==0:
		return [int(i) for i in sys.stdin.readline().split()]
	else:
		return int(sys.stdin.readline())


for _ in range(int(input())):
	n,k = ri()
	a = input()
	rgb= [0 for i in range(n)]
	gbr= [0 for i in range(n)]
	brg= [0 for i in range(n)]

	for i in range(n):
		if i%3==0:
			if a[i]!=""R"":
				rgb[i]+=1
		if i%3==1:
			if a[i]!=""G"":
				rgb[i]+=1
		if i%3==2:
			if a[i]!=""B"":
				rgb[i]+=1

	for i in range(n):
		if i%3==0:
			if a[i]!=""G"":
				gbr[i]+=1
		if i%3==1:
			if a[i]!=""B"":
				gbr[i]+=1
		if i%3==2:
			if a[i]!=""R"":
				gbr[i]+=1

	for i in range(n):
		if i%3==0:
			if a[i]!=""B"":
				brg[i]+=1
		if i%3==1:
			if a[i]!=""R"":
				brg[i]+=1
		if i%3==2:
			if a[i]!=""G"":
				brg[i]+=1

	for i in range(1,n):
		rgb[i]+=rgb[i-1]
		brg[i]+=brg[i-1]
		gbr[i]+=gbr[i-1]


	ans = 999999999
	#print(rgb,gbr,brg)
	for i in range(k-1,n):
		#print(i,i-k)
		if i-k ==-1:
			ans = min(ans,rgb[i],gbr[i],brg[i])
		else:
			ans = min(ans, rgb[i]- rgb[i-k] , gbr[i]- gbr[i-k], brg[i]- brg[i-k] )

	print(ans)






",linear,implementation,1154
"q = int(input())
for t in range(q):
    n, k = map(int, input().split())
    rgb = input()
    dp = [0] * 3
    dp[0] = [0] * (n + 1)
    dp[1] = [0] * (n + 1)
    dp[2] = [0] * (n + 1)
    for i in range(0, n):
        if rgb[i] == 'R':
            dp[0][i + 1] = dp[2][i]
            dp[1][i + 1] = dp[0][i] + 1
            dp[2][i + 1] = dp[1][i] + 1
        if rgb[i] == 'G':
            dp[0][i + 1] = dp[2][i] + 1
            dp[1][i + 1] = dp[0][i]
            dp[2][i + 1] = dp[1][i] + 1
        if rgb[i] == 'B':
            dp[0][i + 1] = dp[2][i] + 1
            dp[1][i + 1] = dp[0][i] + 1
            dp[2][i + 1] = dp[1][i]
    repl = k
    dif = k % 3
    for j in range(3):
        for i in range(1, n - k + 2):
            repl = min(repl, -dp[j][i - 1] + dp[(j + dif) % 3][i + k - 1])
    print(repl)
",linear,implementation,819
"import sys
input = sys.stdin.readline
q = int(input())
for i in range(q):
    n, k = map(int, input().split())
    s = input()
    R, G, B = 0, 0, 0
    ans = float('inf')
    for j in range(n):
        if j % 3 == 0:
            if s[j] == 'R':
                G += 1
                B += 1
            elif s[j] == 'G':
                R += 1
                B += 1
            else:
                R += 1
                G += 1
        elif j % 3 == 1:
            if s[j] == 'R':
                G += 1
                R += 1
            elif s[j] == 'G':
                G += 1
                B += 1
            else:
                R += 1
                B += 1
        else:
            if s[j] == 'R':
                R += 1
                B += 1
            elif s[j] == 'G':
                R += 1
                G += 1
            else:
                G += 1
                B += 1
        if j >= k - 1:
            ans = min(ans, R, G, B)
            if (j - k + 1) % 3 == 0:
                if s[j - k + 1] == 'R':
                    G -= 1
                    B -= 1
                elif s[j - k + 1] == 'G':
                    R -= 1
                    B -= 1
                else:
                    R -= 1
                    G -= 1
            elif (j - k + 1) % 3 == 1:
                if s[j - k + 1] == 'R':
                    G -= 1
                    R -= 1
                elif s[j - k + 1] == 'G':
                    G -= 1
                    B -= 1
                else:
                    R -= 1
                    B -= 1
            else:
                if s[j - k + 1] == 'R':
                    R -= 1
                    B -= 1
                elif s[j - k + 1] == 'G':
                    R -= 1
                    G -= 1
                else:
                    G -= 1
                    B -= 1

    print(ans)",linear,implementation,1865
"import sys
input = sys.stdin.readline
Q = int(input())
D = {""R"":0, ""G"":1, ""B"":2}
for _ in range(Q):
    N, K = map(int, input().split())
    S = input()
    mi = K
    for i in range(3):
        d = 0
        for j in range(N):
            if D[S[j]] != (i+j) % 3:
                d += 1
            if j >= K and D[S[j-K]] != (i+j-K) % 3:
                d -= 1
            if j >= K-1:
                mi = min(mi, d)
    print(mi)
",linear,"data structures,dp,implementation,two pointers",434
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    a=10**9
    ans=[[0]*n for i in range(3)]
    curr=['R','G','B']
    for l in range(3):
        z=l
        for j in range(n):
            if s[j]!=curr[z]:
                ans[l][j]=1
            z+=1
            z%=3
    for i in range(3):
        ans[i]=[0]+ans[i]
    for l in range(3):
        z=l
        for j in range(1,n+1):
            ans[l][j]+=ans[l][j-1]
    for l in range(3):
        for j in range(1,n-k+2):
            a=min(a,ans[l][j+k-1]-ans[l][j-1])
   # print(ans)
    print(a)
            ",linear,"data structures,dp,implementation,two pointers",656
"def main():
    q = int(input())
    ans = []
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        pr1 = [0]
        pr2 = [0]
        pr3 = [0]        
        for i in range(n):
            count1 = 0
            count2 = 0
            count3 = 0
            if i % 3 == 0:
                if s[i] != ""R"":
                    count1 += 1
                if s[i] != ""G"":
                    count2 += 1
                if s[i] != ""B"":
                    count3 += 1
            if i % 3 == 1:
                if s[i] != ""G"":
                    count1 += 1
                if s[i] != ""B"":
                    count2 += 1
                if s[i] != ""R"":
                    count3 += 1 
            if i % 3 == 2:
                if s[i] != ""B"":
                    count1 += 1
                if s[i] != ""R"":
                    count2 += 1
                if s[i] != ""G"":
                    count3 += 1
            pr1.append(pr1[-1] + count1)
            pr2.append(pr2[-1] + count2)
            pr3.append(pr3[-1] + count3)
            j = i + 1
            if j >= k:
                count1 = pr1[j] - pr1[j - k]
                count2 = pr2[j] - pr2[j - k]
                count3 = pr3[j] - pr3[j - k]
                min_ans = min(min_ans, count1, count2, count3)     
        ans.append(min_ans)
    print(*ans, sep=""\n"")

main()",linear,"data structures,dp,implementation,two pointers",1404
"import sys
input = lambda: sys.stdin.readline().strip()

nxt = {'R':'G', 'G':'B', 'B':'R'}

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    s = input()
    res = []
    for start in ['R', 'G', 'B']:
        mis = []
        cur = start
        for j in range(k):
            if s[j]!=cur: mis.append(1)
            else: mis.append(0)
            cur = nxt[cur]
        res.append(sum(mis))
        for j in range(k, n):
            res.append(res[-1]+int(s[j]!=cur)-mis[j-k])
            if s[j]!=cur: mis.append(1)
            else: mis.append(0)
            cur = nxt[cur]
    print(min(res))
",linear,"data structures,dp,implementation,two pointers",625
"import sys
input = sys.stdin.readline
q = int( input() )
rgb = ""RGB""
for _ in range( q ):
    n, k = map( int, input().split() )
    s = input()
    ans = n
    for i in range( 3 ):
        r = [ 0 ]
        l = i
        for c in s:
            r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) )
            l = ( l + 1 ) % 3
            if len( r ) > k:
                ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] )
    print( ans )
",linear,"data structures,dp,implementation,two pointers",440
"t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    if n == 1:
        print(0)
    else:
        max1 = max2 = -1
        for q in a:
            if q > max1:
                max1, max2 = q, max1
            elif q > max2:
                max2 = q
        print(max(0, min(max2-1, len(a)-2)))
",linear,"greedy,math,sortings",343
"import sys

n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))
i = a.index(max(a))
v = True
for j in range (0, i):
    if a[j] > a[j+1]:
        v = False
for j in range (i, n-1):
    if a[j] < a[j+1]:
        v = False
if v == True:
    print(""YES"")
else:
    print(""NO"")",linear,"greedy,implementation",316
"def main():
    import sys
    input = sys.stdin.readline
    
    n = int(input())
    arr = list(map(int, input().split()))
    idx = arr.index(n)
    ok = 1
    for i in range(1, idx):
        if arr[i] < arr[i - 1]:
            ok = 0
    for i in reversed(range(idx, n - 1)):
        if arr[i] < arr[i + 1]:
            ok = 0
    if ok:
        print(""YES"")
    else:
        print(""NO"")
    
    return 0

main()",linear,"greedy,implementation",419
"n = int(input())
arr = [int(x) for x in input().split()]
x = arr.index(max(arr))
cur = max(arr)
l = x - 1
r = x + 1
ok = 1
for i in range(n - 1):
    if l < 0:
        ok *= (arr[r] < cur)
        cur = arr[r]
        r += 1
    elif r >= n:
        ok *= (arr[l] < cur)
        cur = arr[l]
        l -= 1
    else:
        if arr[l] > arr[r]:
            ok *= (arr[l] < cur)
            cur = arr[l]
            l -= 1
        else:
            ok *= (arr[r] < cur)
            cur = arr[r]
            r += 1
print(""YES"" if ok else ""NO"")",linear,"greedy,implementation",541
"n=int(input())
arr=list(map(int,input().split()))
maxval=max(arr)
maxindex=-1
for i in range(n):
	if(arr[i]==maxval):
		maxindex=i
		break

flag=0
temp=maxval
for i in range(maxindex-1,-1,-1):
	if(temp<=arr[i]):
		flag=1
		break
	else:
		temp=arr[i]

temp=maxval
for i in range(maxindex+1,n):
	if(arr[i]>=temp):
		flag=1
		break
	else:
		temp=arr[i]

if(flag==0):
	print(""YES"")
else:
	print(""NO"")
",linear,"greedy,implementation",397
"n = int(input())
a = list(map(int,input().split()))
fl = False
ans = True
for i in range(n-1):
    if a[i+1]>a[i]:
        if fl:
            ans = False
    else:
        fl = True
if ans:
    print('YES')
else:
    print('NO')",linear,"greedy,implementation",228
"n = int(input())
a = list(map(int, input().split()))

c = 0

for i in range(1, n-1):
    if a[i] > a[i-1] and a[i] > a[i+1]:
        c +=1
    if a[i] == a[i-1] or a[i] == a[i+1]:
        print('NO')
        exit()
    if a[i] <= a[i-1] and a[i] <= a[i+1]:
        print('NO')
        exit()
if c>1:
    print('NO')
else:
    print('YES')",linear,"greedy,implementation",338
"n = int(input())
a = list(map(int,input().split()))
rev = [-1] * (n + 1)
for i, j in enumerate(a):
    rev[j] = i

mx = max(a)

# [l, r]
l = a.index(mx)
r = l

for i in range(n - 1, 0, -1):
    idx = rev[i]
    if idx == l - 1:
        l -= 1
    elif idx == r + 1:
        r += 1
    else:
        print('NO')
        exit()
print('YES')",linear,"greedy,implementation",338
"n = int(input())
l = list(map(int, input().split()))
to = l.index(max(l))
ok = 1
for i in range(1, to):
    if (l[i] <= l[i - 1]):
        ok = 0
        break
for i in range(to + 1, n):
    if (l[i] >= l[i - 1]):
        ok = 0
        break
if ok:
    print('YES')
else:
    print('NO')",linear,"greedy,implementation",288
"t=int(input())
g=list(map(int,input().split()))
k=max(g)
flag=True
i=0
while g[i]!=k:
    if i!=0 and g[i]<g[i-1]:
        print(""NO"")
        exit()
    i+=1
i+=1
while i<t and g[i]!=k:
    if i!=0 and g[i]>g[i-1]:
        print(""NO"")
        exit()
    i+=1
print(""YES"")",linear,"greedy,implementation",272
"import io, sys
input = lambda f=io.StringIO(sys.stdin.buffer.read().decode()).readline: f().rstrip()

ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())

n, m, k = mi()
a = [None] + li()
p = [0] * (n + 1)
for i in range(1, n + 1):
    p[i] = p[i - 1] + a[i]
s = [10 ** 16 for _ in range(m)]
s[0] = k
ans = 0
for i in range(1, n + 1):
    ans = max(ans, p[i] - min(s))
    s[i % m] = min(s[i % m], p[i])
    s[i % m] += k
print(ans)
",linear,"dp,greedy,math",470
"import sys

input = sys.stdin.readline


def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)


def lcm(a, b):
    return (a * b) / gcd(a, b)

def main():
    n,r=map(int, input().split())
    a=list(map(int, input().split()))
    ans=[]
    ans.append(r)
    for i in range(1,n):
        ymax=r
        for j in range( i):
            if abs(a[j]-a[i])<=2*r:
                ymax=max(ymax, ans[j]+(4*r*r-(a[i]-a[j])**2)**0.5)
        ans.append(ymax)
    print(*ans)
    # for i in range(15):
    #     print(x[i],end=' ')













    return

if __name__==""__main__"":
    main()

",quadratic,"brute force,geometry,implementation,math",605
"n,r=list(map(int,input().split()))
x=list(map(int,input().split()))
y=[r]*n
for i in range(1,n):
    for j in range(i):
        d=abs(x[i]-x[j])
        if d<=2*r:
            y[i]=max(y[i],y[j]+(4*r*r-d*d)**(0.5))
print(*y)",quadratic,"brute force,geometry,implementation,math",224
"import math as m

nDiscs, r = [int(x) for x in input().split()]

x = [int(x) for x in input().split()]
y = []

for i in range(len(x)):
    tempY = [r]
    for j in range(i):
        diffX = abs(x[i] - x[j])
        if diffX <= (2 * r):
            addY = m.sqrt((4 * r * r) - (diffX * diffX))
            tempY.append(y[j] + addY)
    y.append(max(tempY))

for i in range(len(y)):
    print(y[i], end=' ')
print()

		 	   				    	 	 		  	 			  	",quadratic,"brute force,geometry,implementation,math",446
"import math

n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r]

for i in range(1, n):
    _y = r
    for j in range(i):
        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):
            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))
    y.append(round(_y, 6))
    
print(' '.join(map(str, y)))
",quadratic,"brute force,geometry,implementation,math",349
"n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r] * n
for i in range(n):
    for j in range(i):
        if not (abs(x[i] - x[j]) > 2 * r):
            y[i] = max(y[i], (4 * r ** 2 - (x[i] - x[j]) ** 2) ** 0.5 + y[j])
for i in y:
    print(i, end=' ')
	  		 			 		 	 		 	  		 	 		  	",quadratic,"brute force,geometry,implementation,math",309
"import math
def C1():
    n, r = map(int, input().split())
    x_cord = [int(x) for x in input().split()]

    y_cord = []
    # y cordinate of contacted Disk
    contactedDisk = 0
    for i, x in enumerate(x_cord):
        if len(y_cord) == 0:
            y_cord.append(r)
        else:
            y_cord.append(r)
            for j in range(i):
                diff = abs(x_cord[i] - x_cord[j])
                if diff <= 2 * r:
                    y_cord[i] = max(y_cord[i], math.sqrt(4*r*r - diff ** 2) + y_cord[j])


    for i in y_cord:
        print(i, end= "" "")


if __name__=='__main__':
    C1()
	   				    								 		  	  	 	",quadratic,"brute force,geometry,implementation,math",638
"import bisect
from itertools import accumulate, count
import os
import sys
import math
from decimal import *
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
 
def input(): return sys.stdin.readline().rstrip(""\r\n"")
def isPrime(n) :
    if (n <= 1) : return False
    if (n <= 3) : return True
    if (n % 2 == 0 or n % 3 == 0) : return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
def SieveOfEratosthenes(n):
    prime = []
    primes = [True for i in range(n + 1)]
    p = 2
    while p * p <= n:
 
        if primes[p] == True:
            prime.append(p)
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1
    primes[1]=False
    primes[0]=False
    return primes
def primefactors(n):
    fac=[]
    while(n%2==0):
        fac.append(2)
        n=n//2
    for i in range(3,int(math.sqrt(n))+2):
        while(n%i==0):
            fac.append(i)
            n=n//i
    if n>1:
        fac.append(n)
    return fac
def factors(n):
    fac=set()
    fac.add(1)
    fac.add(n)
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0:
            fac.add(i)
            fac.add(n//i)
    return list(fac)
def NcR(n, r):
     
    p = 1
    k = 1
    if (n - r < r):
        r = n - r
 
    if (r != 0):
        while (r):
            p *= n
            k *= r
            m = math.gcd(p, k)
            p //= m
            k //= m
 
            n -= 1
            r -= 1
    else:
        p = 1
    return p
def Log2(x):
    if x == 0:
        return False;
 
    return (math.log10(x) /
            math.log10(2));
def isPowerOfTwo(n):
    return (math.ceil(Log2(n)) ==
            math.floor(Log2(n)));
#--------------------------------------------------------codeby apurva3455/AD18
n, r = map(int, input().split())
x = [int(i) for i in input().split()]
c = []
 
 
for i in range(n):
    k = r
    for x1, j in c:
        d = abs(x[i] - x1)
        if d <= 2 * r:
            k = max(k, j + (4 * r ** 2 - d * d) ** 0.5)
    c.append([x[i], k])
    print(k)
     ",quadratic,"brute force,geometry,implementation,math",3705
"import math
n, r = [int(x) for x in input().split()]
x = [int(x) for x in input().split()]
ans = []
for i in range(n):
    t = r
    for j in range(i):
        a = abs(x[i] - x[j])
        if a <= 2 * r:
            t2 = (2 * r)**2
            t2 -= a**2
            t2 = math.sqrt(t2) + ans[j]
            t = max(t, t2)
    ans.append(t)
for k in ans:
    print(k)
	 				 			 		  			 				   					",quadratic,"brute force,geometry,implementation,math",398
"#Problem Set C: Collaborated with no one

import math

n_r = list(map(int, input().split()))

n = n_r[0]
radii = n_r[1]

x_list = list(map(int, input().split()))

temp_arr = []
for i in range(n):
    temp_arr.append(max([radii] + [math.sqrt(4*radii**2 - (x_list[i]-x_list[j])**2) + temp_arr[j]
                    for j in range(i) if abs(x_list[i]-x_list[j]) <= 2*radii])
                    )

for i in temp_arr:
    print(i, end= "" "")
      						 	     			   	   		",quadratic,"brute force,geometry,implementation,math",469
"# Collaborated with Rudransh Singh

from math import sqrt
n, r = input().split()
n = int(n)
r = int(r)
x = []
arr = []
inpArr = input().split("" "")
for i in inpArr:
    x.append(int(i))
    
for i in range(n):
    arr.append(r)
    for j in range(i):
        if (abs(x[j] - x[i]) <= (r * 2)):
            arr[i] = max(arr[i], (arr[j] + sqrt((r*r*4)-((x[j] - x[i])*(x[j] - x[i])))  ))
arr1 = []
for i in arr:
    arr1.append(str(i))
print("" "".join(arr1))
		 	  	 		 	 		   		 	 	    	 	",quadratic,"brute force,geometry,implementation,math",484
"# this is directly from: https://codeforces.com/contest/908/submission/46821547
# you can disregard this answer if desired

n, r = map(int, input().split())
y = []
x = list(map(int, input().split()))
for xi in x:
    yi = r
    for tx, ty in zip(x, y):
        if xi - 2 * r <= tx <= xi + 2 * r:
            dy = (4.0 * r ** 2 - (tx - xi) ** 2) ** 0.5
            yi = max(yi, ty + dy)
    y.append(yi)
print(*y)

				  			 		 					   		   		 	",quadratic,"brute force,geometry,implementation,math",444
"#Collaborated with no one
#Problem C

ans = []
import math
disks_rad = [int(x) for x in input().split("" "")]
nums = [int(x) for x in input().split("" "")]
r = disks_rad[1]
ans.append(r)
for i in range(1, disks_rad[0]):
  y_cord = r
  for j in range(i):
      if ((nums[i] - nums[j]) ** 2) <= ((r ** 2) * 4):
          y_cord = max(y_cord,
                        ans[j] +
                        math.sqrt(4 *
                                  (r ** 2) -
                                  (nums[j] - nums[i]) ** 2
                                )
                      )
  ans.append(y_cord)
print("" "".join([str(x) for x in ans]))
	 		    								  	  		  		 			",quadratic,"brute force,geometry,implementation,math",660
"import math

n, r = map(int, input().split())
x = list(map(int, input().split()))
y = [r]

for i in range(1, n):
    _y = r
    for j in range(i):
        if 4 * r * r >= (x[i] - x[j]) * (x[i] - x[j]):
            _y = max(_y, y[j] + math.sqrt(4 * r * r - (x[i] - x[j]) * (x[i] - x[j])))
    y.append(_y)

print(' '.join(map(str, y)))
",quadratic,"brute force,geometry,implementation,math",335
"R = lambda: map(int, input().split())

n, r = R()
xs = list(R())
ys = []
for i in range(n):
    ys.append(max([((2 * r) ** 2 - abs(xs[i] - xs[j]) ** 2) ** 0.5 + ys[j] for j in range(i) if abs(xs[i] - xs[j]) <= 2 * r], default=r))
print(*ys)",quadratic,"brute force,geometry,implementation,math",240
"n,r = map(int,input().split())
x_coord = list(map(int,input().split()))
d = {}
for i in x_coord:
    final = r

    for j in range(i-r,i+r+1):
        check = d.get(j,[-1,-1])
        if check[0] > 0:
            potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5
            final = max(potential,final)
    for j in range(i-r,i+r+1):
        d[j] = (i,final)
    print(final)",quadratic,"brute force,geometry,implementation,math",381
"n,r = map(int,input().split())
x_coord = list(map(int,input().split()))
d = {}
for i in x_coord:
    final = r
    for j in range(i-r,i+r+1):
        check = d.get(j,[-1,-1])
        if check[0] > 0:
            potential = check[1] + ((4*r*r)-((i-check[0])**2))**.5
            final = max(potential,final)
    for j in range(i-r,i+r+1):
        d[j] = (i,final)
    print(final,end = "" "")",quadratic,"brute force,geometry,implementation,math",390
"from math import *
a,r = map(int,input().split())
x = list(map(int,input().split()))
y = [0]*a
for i in range(a):
    h = r
    for j in range(i):
        if abs(x[i]-x[j])<=2*r:
            h = max(h,sqrt((2*r)**2 - (x[i]-x[j])**2)+y[j])
    y[i] = h
    print(h, end = "" "")
",quadratic,"brute force,geometry,implementation,math",276
"from collections import defaultdict

def E1():

    mod = 10 ** 9 + 7

    comb = [[1]]
    for i in range(1, 1010):
        x = [1]
        for j in range(1, i):
            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)
        x.append(1)
        comb.append(x)

    dp = [1]
    for i in range(1, 1010):
        r = 0
        for k in range(i):
            r += dp[k] * comb[i - 1][k]
            r %= mod
        dp.append(r)

    m, n = map(int, input().split())

    ns = [0 for __ in range(m)]
    for j in range(n):
        temp = input()
        s = [int(i) for i in temp]
        for i in range(m):
            ns[i] |= s[i] << j

    dd = defaultdict(int)
    for e in ns:
        dd[e] += 1

    ans = 1
    for b in dd.values():
        ans = ans * dp[b] % mod

    print(ans)

if __name__=='__main__':
    E1()
	 	 	   	   			  				  	 	 	 	",quadratic,"bitmasks,combinatorics,dp,math",863
"#Problem Set E: Collaborated with no one
from collections import defaultdict

mod_v = 1000000007

temp_arr = [[1]]
for i in range(1,1010):
    a = [1]
    for k in range(1,i):
        a.append((temp_arr[i-1][k-1]+temp_arr[i-1][k]) % mod_v)
    a.append(1)
    temp_arr.append(a)


ans_arr = [1]
for i in range(1,1010):
    res = 0
    for j in range(i):
        res += ans_arr[j] * temp_arr[i-1][j]
        res %= mod_v
    ans_arr.append(res)


n_list=list(map(int, input().split()))

n = n_list[0]
lines = n_list[1]

new_list = [0 for __ in range(n)]

for i in range(lines):
    input1 = list(map(int, input()))
    for k in range(n):
        new_list[k] |= input1[k] << i

default_d = defaultdict(int)
for k in new_list:
    default_d[k] += 1

answer = 1
for n in default_d.values():
    answer = answer * ans_arr[n] % mod_v

print(answer)
  		 	 	  	    	 	 		   		 	  	",quadratic,"bitmasks,combinatorics,dp,math",874
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap,0,len(heap)-1)
from math import gcd as Gcd
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,readline().split())
S=[readline().rstrip() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",quadratic,"bitmasks,combinatorics,dp,math",3180
"import math
import sys
from collections import deque,defaultdict
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,readline().split())
S=[readline().rstrip() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",quadratic,"bitmasks,combinatorics,dp,math",2846
"import math
from collections import defaultdict

def Extended_Euclid(n,m):
    stack=[]
    while m:
        stack.append((n,m))
        n,m=m,n%m
    if n>=0:
        x,y=1,0
    else:
        x,y=-1,0
    for i in range(len(stack)-1,-1,-1):
        n,m=stack[i]
        x,y=y,x-(n//m)*y
    return x,y

class MOD:
    def __init__(self,p,e=1):
        self.p=p
        self.e=e
        self.mod=self.p**self.e

    def Pow(self,a,n):
        a%=self.mod
        if n>=0:
            return pow(a,n,self.mod)
        else:
            assert math.gcd(a,self.mod)==1
            x=Extended_Euclid(a,self.mod)[0]
            return pow(x,-n,self.mod)

    def Build_Fact(self,N):
        assert N>=0
        self.factorial=[1]
        self.cnt=[0]*(N+1)
        for i in range(1,N+1):
            ii=i
            self.cnt[i]=self.cnt[i-1]
            while ii%self.p==0:
                ii//=self.p
                self.cnt[i]+=1
            self.factorial.append((self.factorial[-1]*ii)%self.mod)
        self.factorial_inv=[None]*(N+1)
        self.factorial_inv[-1]=self.Pow(self.factorial[-1],-1)
        for i in range(N-1,-1,-1):
            ii=i+1
            while ii%self.p==0:
                ii//=self.p
            self.factorial_inv[i]=(self.factorial_inv[i+1]*ii)%self.mod

    def Fact(self,N):
        return self.factorial[N]*pow(self.p,self.cnt[N],self.mod)%self.mod

    def Fact_Inv(self,N):
        if self.cnt[N]:
            return None
        return self.factorial_inv[N]

    def Comb(self,N,K,divisible_count=False):
        if K<0 or K>N:
            return 0
        retu=self.factorial[N]*self.factorial_inv[K]*self.factorial_inv[N-K]%self.mod
        cnt=self.cnt[N]-self.cnt[N-K]-self.cnt[K]
        if divisible_count:
            return retu,cnt
        else:
            retu*=pow(self.p,cnt,self.mod)
            retu%=self.mod
            return retu

def Bell_Numbers(N,mod,prime=False):
    bell_numbers=[0]*(N+1)
    bell_numbers[0]=1
    MD=MOD(mod)
    if prime:
        MD.Build_Fact(min(mod-2,N-1))
        for i in range(1,min(mod,N+1)):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
        for i in range(mod,N+1):
            bell_numbers[i]=(bell_numbers[i-mod+1]+bell_numbers[i-mod])%mod
    else:
        MD.Build_Fact(N-1)
        for i in range(1,N+1):
            bell_numbers[i]=sum(bell_numbers[j]*MD.Comb(i-1,j) for j in range(i))%mod
    return bell_numbers

M,N=map(int,input().split())
S=[input() for i in range(N)]
dct=defaultdict(int)
for i in range(M):
    tpl=()
    for j in range(N):
        tpl+=(S[j][i],)
    dct[tpl]+=1
ans=1
mod=10**9+7
bell=Bell_Numbers(M,mod)
for c in dct.values():
    ans*=bell[c]
    ans%=mod
print(ans)",quadratic,"bitmasks,combinatorics,dp,math",2736
"# Problem G

num = input()
num_list = []
for i in range(len(num)):
  num_list.append(int(num[i]))
myMod = (10 ** 9) + 7
length = len(num_list)
f = [0] * (length + 1)
t = [1] * (length + 1)
for i in range(length):
    f[i+1] = (f[i] * 10 + 1) % myMod
    t[i+1] = (t[i] * 10) % myMod
ans = 0
for i in range(1, 10):
    dp = [0] * (length + 1)
    for j in range(length):
        dp[j+1] = (dp[j] * i + (10 - i) * (dp[j] * 10 + t[j])) % myMod
    c = 0
    ctr = 0
    for k in num_list:
        z = min(i, k)
        o = k - z
        ans += o * (dp[length-1-ctr] * t[c+1] + f[c+1] * t[length-1-ctr]) % myMod
        ans += z * (dp[length-1-ctr] * t[c] + f[c] * t[length-1-ctr]) % myMod
        ans %= myMod
        c += k >= i
        ctr += 1
    ans += f[c]
    if ans >= myMod:
        ans -= myMod
print(ans)
 	     	 				   	  	 		 	  		",quadratic,"dp,math",842
"import sys
from random import *
from bisect import *
#from collections import deque
pl=1
from math import gcd,sqrt
from copy import *
sys.setrecursionlimit(10**5)
if pl:
	input=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('outpt.txt','w')
 
def li():
	return [int(xxx) for xxx in input().split()]
def fi():
	return int(input())
def si():
	return list(input().rstrip())	
def mi():
	return 	map(int,input().split())	
 
		
t=1

		
while t>0:
	t-=1
	n=fi()
	mod=10**9+7
	dp=[[0 for i in range(n+5)] for j in range(n+5)]
	prev=""-1""
 
	for i in range(n):
		p=input().rstrip()
		if i==0:
			dp[i][0]=1
		else:
			
			c=0
			if prev=='f':
				for j in range(n):
					dp[i][j+1]=dp[i-1][j]
			else:	
				for j in range(n,-1,-1):
					c=(c+dp[i-1][j])%mod
					dp[i][j]=c	
				
		prev=p
	
	print(sum(dp[n-1])%mod)					
				",quadratic,dp,845
"n = int(input())
s = [input() for i in range(n)]
MOD = 10**9 + 7

dps = [[0]*(n + 3) for i in range(n + 1)]
dpf = [[0]*(n + 3) for i in range(n + 1)]

for k in range(n + 1):
    dps[0][k] = 1

for pos, char in enumerate(s):
    if char == ""s"":
        #dps[pos + 1][depth] = dps[pos][depth]  + .... + dps[pos][pos] + dpf[pos][depth]
        for depth in range(pos + 2):
            dps[pos + 1][depth] = dpf[pos][depth] - \
                dpf[pos][depth - 1] + dps[pos][pos] - dps[pos][depth - 1]
            #sum(dps[pos][k] for k in range(depth, pos + 1))

            dps[pos + 1][depth] += dps[pos + 1][depth - 1]
            dps[pos + 1][depth] %= MOD

        for p in range(pos + 2, n+1):
            dpf[pos + 1][p] += dpf[pos + 1][p - 1]
            dpf[pos + 1][p] %= MOD
        continue

    else:
        #dpf[pos + 1][depth] =  dpf[pos][depth - 1] + dps[pos][depth - 1] + .......... + depth[pos][pos]
        #dps[pos + 1][depth] = impossible
        for depth in range(1, pos + 2):
            dpf[pos + 1][depth] = dpf[pos][depth - 1] - \
                dpf[pos][depth - 2] + dps[pos][pos] - dps[pos][depth - 2]
            #sum(dps[pos][k] for k in range(depth - 1, pos + 1))
            dpf[pos + 1][depth] += dpf[pos + 1][depth - 1]
            dpf[pos + 1][depth] %= MOD
        for p in range(pos + 2, n+1):
            dpf[pos + 1][p] += dpf[pos + 1][p - 1]
            dpf[pos + 1][p] %= MOD


ans = dps[n][n] % MOD
print(ans)
",quadratic,dp,1452
"n=int(input())
f=[input().strip()==""f"" for ii in range(n)]
mod=10**9+7
def summ(a,b):
 return (a+b)%mod
dp=[1]
for ii in range(1,n):
 pf=f[ii-1]
 if pf:
  dp.insert(0,0)
 else:
  for jj in reversed(range(1,len(dp))):
   dp[jj-1]=summ(dp[jj-1],dp[jj])
ans=0
for vv in dp:
 ans=summ(ans,vv)
print(ans)
	 		       		 	 	 	 					  		",quadratic,dp,329
"MOD = int(1e9+7)
n = int(input())
a = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if a[i] == 'f':
        dp.append(0)
        continue
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % MOD
print(dp[-1])
",quadratic,dp,238
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 1000000007;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if n < 0 or r < 0 or r > n: return 0;
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    C();

def D():
    [n,m,k] = ti();
    w = [[] for i in range(n)];
    for i in range(n):
        w[i] = ts();

    mn = [[0 for j in range(k+1)] for i in range(n+1)];
    for i in range(1,n+1):
        for j in range(k+1):
            c = 0;
            st,en = -1,-1;
            for x in range(m):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            mn[i][j] = en-st+1 if st != -1 and en != -1 else 0;
            st,en = -1,-1;
            c = 0;
            for x in range(m-1,-1,-1):
                if w[i-1][x] == '1':
                    if c == j and st == -1: st = x;
                    if c < j: c += 1;
                    if c == j: en = x;
            if st != -1 and en != -1 >= 0:
                mn[i][j] = min(mn[i][j], st-en+1);

    dp = [[9999999999999999 for j in range(k+1)] for i in range(n+1)];
    for i in range(k+1):
        dp[0][i] = 0;
    for i in range(1,n+1):
        for j in range(k+1):
            for x in range(k+1):
                if j-x >= 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-x]+mn[i][x]);

    print(dp[n][k]);

def C():
    n = pi();
    s = [];
    mxI = 0;
    for i in range(n):
        c = input();
        s.append(c[:len(c)-1]);
        if s[len(s)-1] == 'f': mxI += 1;
    dp = [[0 for j in range(mxI+1)] for i in range(n)];
    dp[0][0] = 1;
    preSum = [1 for i in range(mxI+1)];
    pre = 1;
    for i in range(1,n):
        sm = 0;
        pre = 0;
        for j in range(mxI+1):
            if s[i-1] == 'f':
                dp[i][j] = dp[i-1][j-1]%mod;
            else:
                dp[i][j] = (preSum[mxI]%mod-(pre if j != 0 else 0)%mod)%mod;
            pre = preSum[j];
            preSum[j] = ((preSum[j-1] if j != 0 else 0)%mod+dp[i][j]%mod)%mod;

    print(preSum[mxI]%mod);

main();",quadratic,dp,2761
"n = int(input())
mod = 10**9+7
dp = [0]*(n+1)
dp[0] = 1
for i in range(n):
    nx = [0]*(n+1)
    s = str(input())
    if s == 'f':
        nx[0] = 0
        for j in range(1, n+1):
            nx[j] = dp[j-1]
            nx[j] %= mod
    else:
        nx[n] = dp[n]
        for j in reversed(range(n)):
            nx[j] = nx[j+1]
            nx[j] += dp[j]
            nx[j] %= mod
    if i != n-1:
        dp = nx
print(sum(dp)%mod)
",quadratic,dp,436
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(200001)] 
pp=[0]*200001
def SieveOfEratosthenes(n=200000): 
      
    # Create a boolean array ""prime[0..n]"" and initialize 
    #  all entries it as true. A value in prime[i] will 
    # finally be false if i is Not a prime, else true. 
    
    p = 2
    while (p * p <= n): 
          
        # If prime[p] is not changed, then it is a prime 
        if (prime[p] == True): 
              
            # Update all multiples of p 
            for i in range(p * p, n+1, p): 
                prime[i] = False
        p += 1
#---------------------------------running code------------------------------------------
MOD = int(1e9+7)
n = int(input())
a = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if a[i] == 'f':
        dp.append(0)
        continue
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % MOD
print(dp[-1])",quadratic,dp,8651
"n = int(input())

def prefix_sums(A):
    n = len(A)
    P = [0] * n
    P[0] = A[0]
    for k in range(1, n):
        P[k] = int((P[k - 1] + A[k]) % (1e9+7))
    return P

arr = [[0] * n for _ in range(n)]
    

s = ''
for i in range(n):
    inst = input()
    s += inst

    
def find_ans():
    idx = 0
    for i in range(len(arr)-1):    
        arr[0][0] = 1

        if s[i] == 'f':            
            for j in range(0, len(arr)):    
                arr[i+1][0] = 0
                if j > 0:
                    arr[i+1][j] = arr[i][j-1]
                    idx = i+1

        else:
            val = 0
            arr[i+1] = prefix_sums(arr[i][::-1])[::-1]
    return arr

if n == 1 or 'f' not in s:
    if s[0] == 's':
        print(1)
    else:
        print(int(sum(find_ans()[-1]) % (1e9+7)))
else:
    print(int(sum(find_ans()[-1]) % (1e9+7)))
                ",quadratic,dp,878
"modulo = int(1e9+7)
n = int(input())
arr = [input() for i in range(n)]
dp = [1]
for i in range(n):
    if arr[i] == 'f':
        dp.append(0)
        continue;
    for j in range(1, len(dp)):
        dp[j] = (dp[j] + dp[j-1]) % modulo
print(dp[-1])",quadratic,dp,248
"import sys
lines = int(sys.stdin.readline())
dp = [0] * lines
f = 1
dp[0] = 1

for i in range(lines):
  char_in = sys.stdin.readline()[0]
  if char_in == 'f':
    f += 1
  else:
    # num ways to write the statements
    # the more for loops, the more we can combination
    # any single statement can be the indent of anything previously
    # sum over previous, but also update all of previous
    for j in range(1, f):
      dp[j] = (dp[j] + dp[j- 1]) % 1000000007
print(dp[f - 1])",quadratic,dp,484
"n = int(input().rstrip())
arr = []
mod = pow(10,9) + 7
indent_num = 0
for i in range(n):
    arr.append(input().rstrip())
    if arr[i] == 'f':
        indent_num += 1
dp = [0 for i in range(indent_num + 1)]
first_block_index = 0
max_indent = 0
for i in arr:
    if i != 'f':
        break
    first_block_index += 1
    max_indent += 1

dp[max_indent] = 1
#print(dp)
cur_indent = 0
pref = [0 for i in range(indent_num + 1)]
def cal_pref(dp, pref):
    pref[0] = dp[0]
    for i in range(1, len(dp)):
        pref[i] = pref[i - 1] + dp[i]

for i in range(first_block_index + 1,n):
    if arr[i] == 'f':
        cur_indent += 1
        max_indent += 1
        continue
   
    cur = [0 for i in range(indent_num + 1)]
    cal_pref(dp, pref)
    for j in range(cur_indent,indent_num + 1):
        res_idx = j - cur_indent
        res_result = pref[res_idx - 1] if res_idx > 0 else 0
        cur[j] = (pref[indent_num] - res_result) % mod
        #cur[j] = sum(dp[j - cur_indent:indent_num + 1]) % mod
    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]
    dp = cur
    cur_indent = 0
    #print(i,arr[i], dp)


print(sum(dp) % mod)
",quadratic,dp,1147
"n = int(input().rstrip())
arr = []
mod = pow(10,9) + 7
indent_num = 0
for i in range(n):
    arr.append(input().rstrip())
    if arr[i] == 'f':
        indent_num += 1
dp = [0 for i in range(indent_num + 1)]
max_indent = 0

#print(dp)
cur_indent = 0
pref = [0 for i in range(indent_num + 1)]

def cal_pref(dp, pref):
    pref[0] = dp[0]
    for i in range(1, len(dp)):
        pref[i] = pref[i - 1] + dp[i]

for i in range(n):
    if arr[i] == 'f':
        cur_indent += 1
        max_indent += 1
        continue
    cur = [0 for i in range(indent_num + 1)]
    cal_pref(dp, pref)
    for j in range(cur_indent,indent_num + 1):
        res_idx = j - cur_indent
        res_result = pref[res_idx - 1] if res_idx > 0 else 0
        cur[j] = (pref[indent_num] - res_result) % mod
        #cur[j] = sum(dp[j - cur_indent:indent_num + 1]) % mod
    cur[max_indent] = 1 if not cur[max_indent] else cur[max_indent]
    dp = cur
    cur_indent = 0
    #print(i,arr[i], dp)


print(sum(dp) % mod)
",quadratic,dp,989
"from sys import stdin,stdout
from collections import deque
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
PI=float('inf')
M=10**9+7
for _ in range(1):#nmbr()):
    n=nmbr()
    s=[input() for _ in range(n)]
    dp=[[0 for _ in range(n+1)] for _ in range(n+1)]
    dp[0][0]=1
    for i in range(1,n):
        for j in range(n):
            if i>=1 and s[i-1]=='f':
                if j>=1:dp[i][j]=dp[i-1][j-1]-(dp[i-1][j])
            elif i>=1:
                dp[i][j]=dp[i-1][j]
            dp[i][j]%=M
        for k in range(n-1,-1,-1):
            dp[i][k]=(dp[i][k]+dp[i][k+1])%M
    # print(*dp,sep='\n')
    print(dp[n-1][0]%M)",quadratic,dp,662
"M=10**9+7
n=int(input())
a=[]
for i in range(n):
    a.append(input())
dp=[[0]*(n+5) for i in range(n+2)]
dp[0][0]=1
for i in range(1,n):
    count=0
    if a[i-1]=='f':
        for j in range(n-2,-1,-1):
            if dp[i-1][j]>0:
                dp[i][j+1]=(dp[i][j+1]+dp[i-1][j])%M
    else:
        for j in range(n-2,-1,-1):
            if dp[i-1][j]>0:
                count=(count+dp[i-1][j])%M
            dp[i][j]=(dp[i][j]+count)%M
print(sum(dp[n-1])%M)",quadratic,dp,465
"import sys
input=sys.stdin.readline
n=int(input())
c=["" ""]+[input().rstrip() for i in range(n)]
mod=10**9+7
dp=[[0]*(n+1) for i in range(n+1)]
dp[1][0]=1
sdp=[0]*(n+1)
sdp[0]=1
for i in range(1,n+1):
    if i>=2 and c[i-1]==""f"":
        for j in range(1,n+1):
            dp[i][j]=dp[i-1][j-1]
            dp[i][j]%=mod
        dp[i][0]=0
    else:
        for j in range(n+1):
            dp[i][j]=sdp[j]
            dp[i][j]%=mod
    sdp=[dp[i][j] for j in range(n+1)]
    for j in range(1,n+1)[::-1]:
        sdp[j-1]+=sdp[j]
        sdp[j-1]%=mod
print(sdp[0]%mod)",quadratic,dp,568
"mod=10**9+7
n=int(input())
l=[]
c=0
for i in range(n):
    l.append(input())
dp=[[0]*(n+2) for i in range(n+1)]
for i in range(n+2):
    dp[n][i]=1
for i in range(n-1,0,-1):
    s=0
    for j in range(n+1):
        s+=dp[i+1][j]
        s%=mod
        if l[i-1]=='f':
            dp[i][j]=dp[i+1][j+1]
        else:
            dp[i][j]=s

print(dp[1][0])
    
",quadratic,dp,361
"from sys import stdin,stdout,setrecursionlimit
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor	
from bisect import bisect_right as br,bisect_left as bl
from heapq import *
mod = 10**9+7


def solve():
	n = it()
	v=[0]*(n+1)
	for i in range(1,n+1):
		v[i] = input()
	
	dp=[[0]*(n+2) for _ in range(n+1)]

	for l in range(n+2):
		dp[n][l] = 1

	for i in range(n-1,0,-1):
		curr_sum = 0
		for l in range(n):
			curr_sum += dp[i+1][l]
			curr_sum%=mod
			if v[i] == 'f':
				dp[i][l] = dp[i+1][l+1]
			else:
				dp[i][l]= curr_sum

	print(dp[1][0])

solve()
",quadratic,dp,746
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])",quadratic,dp,207
"MOD=int(1e9+7)
n=int(input())
a=[]
for i in range(n):
    a.append(input())
a="""".join(a)
dp,s=[],[]
for i in range(n+1):
    dp.append([0]*(n+1))
    s.append([0]*(n+1))
dp[0][0]=1
s[0][0]=1
for i in range(1,n):
    for j in range(0,n):
        if a[i-1]=='f':
            dp[i][j+1]=dp[i-1][j]%MOD
        elif a[i-1]=='s':
            dp[i][j]=s[i-1][j]%MOD
    
    for j in reversed(range(n)):
        s[i][j]+=(dp[i][j]+s[i][j+1])%MOD
print(s[n-1][0]%MOD)
#sum from all levels

",quadratic,dp,483
"import sys
input = sys.stdin.readlines()
n = int(input[0].strip())
m = 10**9 + 7
curr = [0] * (n+20)
last = [0] * (n+20)
curr[0] = 1
for s in range(1,n):
    last, curr = curr, last
    if input[s]=='f\n':
        curr[0] = 0
        for i in range(len(last)-1):
            curr[i+1] = last[i]
    elif input[s]=='s\n':
        curr[-1] = 0
        for i in range(len(last)-2, -1, -1):
            curr[i] = (curr[i+1] + last[i]) % m
s = 0
for x in curr:
    s = (s + x) % m
print(s)",quadratic,dp,484
"def add(a,b):
	a = a%(1000000000+7)
	b=b%(1000000000+7)
	return (a+b)%(1000000000+7)



n  =int(input())
i=1
statements = []
dp = [[0 for i in range(n)] for i in range(n)]
prefix = [[0 for i in range(n)] for i in range(n)]
while(i<=n):
	s = input()
	statements.append(s)
	i+=1

dp[0][0]=1
prefix[0][0]=1
j=1
while(j<n):
	dp[0][j]=0
	prefix[0][j] = dp[0][j] + prefix[0][j-1]
	j+=1

i=1
while(i<n):
	if(statements[i-1]=='f'):
		j=1
		while(j<n):
			dp[i][0]=0
			prefix[i][0]=0
			dp[i][j] = dp[i-1][j-1]
			prefix[i][j] = add(prefix[i][j-1],dp[i][j])

			j+=1
	else:
		j=0
		while(j<n):
			if(j==0):
				dp[i][j] = prefix[i-1][n-1]
			else:
				dp[i][j] = prefix[i-1][n-1] - prefix[i-1][j-1]
			prefix[i][j] = add(prefix[i][j-1],dp[i][j])
			j+=1
	# print(prefix)
	i+=1

# i=0
# while(i<n):
# 	j=0
# 	while(j<n):
# 		print(dp[i][j])
# 		j+=1
# 	i+=1

# print(dp)

ans = 0
j=0
while(j<n):
	ans=add(ans,dp[n-1][j])
	j+=1

print(ans%(1000000000+7))

",quadratic,dp,946
"def add(x,j):
	x = x % (1000000000+7)
	j=j % (1000000000+7)
	return (x+j) % (1000000000+7)

statements = []
n  =int(input())
i=1
j=1
temp = [[0 for i in range(n)] for i in range(n)]
earlier = [[0 for i in range(n)] for i in range(n)]
temp[0][0]=1
earlier[0][0]=1

while(i<=n):
	s = input()
	statements.append(s)
	i+=1
while(j<n):
	temp[0][j]=0
	earlier[0][j] = temp[0][j] + earlier[0][j-1]
	j+=1
i=1
while(i<n):
	if(statements[i-1]=='f'):
		j=1
		while(j<n):
			temp[i][0]=0
			earlier[i][0]=0
			temp[i][j] = temp[i-1][j-1]
			earlier[i][j] = add(earlier[i][j-1],temp[i][j])

			j+=1
	else:
		j=0
		while(j<n):
			if(j==0):
				temp[i][j] = earlier[i-1][n-1]
			else:
				temp[i][j] = earlier[i-1][n-1] - earlier[i-1][j-1]
			earlier[i][j] = add(earlier[i][j-1],temp[i][j])
			j+=1
	i+=1

ans = 0
j=0
while(j<n):
	ans=add(ans,temp[n-1][j])
	j+=1

print(ans%(1000000000+7))",quadratic,dp,873
"n = int(input())
dp = [1]
for IND in range(n):
    c = input()
    if c == ""f"":
        dp.insert(0,0)
    else:
        for i in range(len(dp)-2, -1, -1): dp[i] = (dp[i] + dp[i+1]) % 1000000007
print(dp[0])
",quadratic,dp,208
"import sys


class fenwick():
    """"""
    This Tree Data Structure speeds up caliculating summations of partial sum 
    and also updating subsets of sequences. Both queries finish in logarithmic times.
    """"""
    # 1-indexed

    def __init__(self, n):
        self.n = n
        self.data = [0]*(n+1)

    def to_sum(self, i):
        # return sigma(a_j) (0<=j<=i)
        s = 0
        while i > 0:
            s += self.data[i]
            i -= (i & -i)
        return s

    def add(self, i, x):
        #a_i -> a_i + x
        while i <= self.n:
            self.data[i] += x
            i += (i & -i)

    def get(self, i, j):
        # return sigma(a_k) (i<=k<=j)
        # assert 1<=i<=j<= N
        return self.to_sum(j)-self.to_sum(i-1)


def input():
    return sys.stdin.buffer.readline()


n = int(input())
permutation = list(map(int, input().split()))
seq = [(permutation[i], i + 1) for i in range(n)]
seq.sort(reverse=True)

m = int(input())
query = [tuple(map(int, input().split())) for i in range(m)]

#count whole inversion

WHOLE_INVERSION = 0
fenwick_1 = fenwick(n)

for value, index in seq:
    WHOLE_INVERSION += fenwick_1.get(1, index)
    fenwick_1.add(index, 1)

for l, r in query:
    d = r - l + 1
    WHOLE_INVERSION += d*(d-1)//2
    if WHOLE_INVERSION % 2 != 0:
        print(""odd"")
    else:
        print(""even"")

",quadratic,"brute force,math",1348
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def inv_cnt(b):
    c = 0
    visited = set()
    for i in range(len(b)):
        if i + 1 in visited:
            pass
        else:
            visited.add(i)
            path = [i + 1]
            while b[path[-1] - 1] != path[0]:
                visited.add(b[path[-1] - 1])
                path.append(b[path[-1] - 1])
            c += len(path) - 1
    return c % 2



def solve():
    n = int(input())
    a = [int(x) for x in input().split(' ')]
    x = inv_cnt(a)
    m = int(input())
    for query in range(m):
        l, r = [int(x) for x in input().split(' ')]
        x = (x + (r - l + 1) // 2) % 2
        if x:
            print(""odd"")
        else:
            print(""even"")

solve()


",quadratic,"brute force,math",2471
"n = int(input())
a = list(map(int, input().split()))
m = int(input())
parity = 0
for i in range(n):
    for j in range(i + 1, n):
        if a[i] > a[j]:
            parity ^= 1
res = []
for _ in range(m):
    l, r = map(int, input().split())
    s = r - l + 1
    parity ^= (s * (s - 1) // 2) % 2
    res.append(""odd"" if parity else ""even"")
print(""\n"".join(res))",quadratic,"brute force,math",363
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=None):
        self.BIT=[0]*(n+1)
        self.num=n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        self.mod = mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.buffer.readline()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
a = li()

inv = 0
for i in range(n):
    for j in range(i+1,n):
        if a[i] > a[j]:
            inv += 1
inv %= 2

m = int(input())
for _ in range(m):
    l,r = mi()
    L = r-l+1

    all = L*(L-1)//2
    if all%2==1:
        inv = 1 - inv

    print(""odd"" if inv else ""even"")
",quadratic,"brute force,math",19573
"import sys
readline = sys.stdin.readline

N = int(readline())
A = list(map(int, readline().split()))
Q = int(readline())

cnt = 0
for i in range(N):
    for j in range(i+1, N):
        if A[i] > A[j]:
            cnt += 1

cnt %= 2

Ans = [None]*Q
for qu in range(Q):
    l, r = map(int, readline().split())
    if (r-l+1)*(r-l)//2 & 1:
        cnt ^= 1
    
    Ans[qu] = 'odd' if cnt else 'even'

print('\n'.join(Ans))",quadratic,"brute force,math",420
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n = inp()
a = inpl()
res = 0
for i in range(n):
    for j in range(i+1,n):
        if a[i] > a[j]:
            res = 1-res
for _ in range(inp()):
    l,r = inpl(); m = r-l+1
    swap = m*(m-1)//2
    if swap%2: res = 1-res
    print('odd' if res else 'even')",quadratic,"brute force,math",812
"# ---------------------------iye ha aam zindegi---------------------------------------------
import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
#threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
#sys.setrecursionlimit(300000)

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------game starts now----------------------------------------------------import math
class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1


class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):
        """"""
        Side effect!!! Changes node. Node should have exactly one child
        """"""
        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n


# -----------------------------------------------binary seacrh tree---------------------------------------
class SegmentTree1:
    def __init__(self, data, default=300006, func=lambda a, b: min(a , b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------game starts now----------------------------------------------------import math
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


# --------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m


# --------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z


# --------------------------------------------------product----------------------------------------
def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por


# --------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] <=key):
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count


# --------------------------------------------------binary----------------------------------------
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)


# --------------------------------------------------binary------------------------------------
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord
#-----------------------------------------trie---------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None  # left node for 0
        self.right = None  # right node for 1
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data
#-------------------------bin trie-------------------------------------------
n=int(input())
l=list(map(int,input().split()))
fi=[""even"",""odd""]
q=defaultdict(int)
e=[0]*(n+1)
s=SegmentTree(e)
ans=0
for j in range(n):
    ans+=s.query(l[j]+1,n)
    s.__setitem__(l[j],1)
fi1=ans
for i in range(int(input())):
    a,b=map(int,input().split())
    a-=1
    b-=1
    fi1+=((b-a+1)*(b-a))//2
    print(fi[fi1%2])",quadratic,"brute force,math",19421
"import sys
input = sys.stdin.buffer.readline

n = int(input())
a = list(map(int,input().split()))

parity = 0
for i in range(n):
    for j in range(i+1,n):
        if a[j] < a[i]:
            parity ^= 1

m = int(input())
for i in range(m):
    l,r = map(int,input().split())

    dist = (r-l+1)
    pairs = (dist-1)*(dist)//2

    if pairs & 1:
        parity ^= 1

    if parity:
        print(""odd"")
    else:
        print(""even"")",quadratic,"brute force,math",434
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import collections
import itertools
import bisect
import heapq
# sys.setrecursionlimit(100000)
# ^^^TAKE CARE FOR MEMORY LIMIT^^^
import random


def main():
    pass


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def binary(n):
    return (bin(n).replace(""0b"", """"))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)

def primeFactorsCount(n):
    cnt=0
    while n % 2 == 0:
        cnt+=1
        n = n // 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            cnt+=1
            n = n // i
    if n > 2:
        cnt+=1
    return (cnt)

def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum


def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m


def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)


def p2(n):
    c = 0
    while (n % 2 == 0):
        n //= 2
        c += 1
    return c


def seive(n):
    primes = [True] * (n + 1)
    primes[1] = primes[0] = False
    i = 2
    while (i * i <= n):
        if (primes[i] == True):
            for j in range(i * i, n + 1, i):
                primes[j] = False
        i += 1
    pr = []
    for i in range(0, n + 1):
        if (primes[i]):
            pr.append(i)
    return pr


def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p


def denofactinverse(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (pow(fac, m - 2, m))


def numofact(n, m):
    fac = 1
    for i in range(1, n + 1):
        fac = (fac * i) % m
    return (fac)

def sod(n):
    s = 0
    while (n > 0):
        s += n % 10
        n //= 10
    return s

n=int(input())
l=list(map(int,input().split()))
inv=0
for i in range(1,n):
    for j in range(0,i):
        if(l[j]>l[i]):
            inv+=1
#print(inv)
for i in range(0,int(input())):
    f,r=map(int,input().split())
    p=(r-f+1)//2
    #print(p)
    inv+=p%2
    #print(inv)
    if(inv%2):
        print(""odd"")
    else:
        print(""even"")
",quadratic,"brute force,math",5254
"from collections import Counter
from math import *
import sys
mod=1000000007

def pro(arr,q):
    n=len(arr)
    ans=0
    for i in range(n):
        for j in range(i+1,n):
            if(arr[i]>arr[j]):
                ans+=1
    
    res=ans%2
    for x,y in q:
        k= y-x + 1
        k=k//2
        k=k%2
        res= k^res
        if(res):
            print('odd')
        else:
            print('even')
n=int(input())
arr=list(map(int,input().split()))
t=int(input())
que=[]
for i in range(t):
    que.append(list(map(int,input().split())))
pro(arr,que)",quadratic,"brute force,math",563
"import io
import os

input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n = int(input())

arr = [int(z) for z in input().split()]

q = int(input())

inv = 0

for i in range(n):

    for j in range(n):

        if i < j and arr[i] > arr[j]:

            inv += 1

        inv = inv % 2

for query in range(q):

    l, r = map(int, input().split())

    diff = r - l

    s = diff//2

    if diff % 2:
        s += 1

    inv = (inv + (s % 2)) % 2

    if inv:
        print(""odd"")
    else:
        print(""even"")

# for query in range(q):
#
#     l, r = map(int, input().split())
#
#     arr = arr[:l-1] + arr[l-1:r][::-1] + arr[r:]
#
#     inv = 0
#
#     for i in range(n):
#
#         inv += max(0, arr[i] - (i+1))
#
#     if inv % 2:
#         print(""odd"")
#     else:
#         print(""even"")
#
#     print(inv)

",quadratic,"brute force,math",827
"n=int(input())
w=[int(k) for k in input().split()]
m=int(input())
c=0
for i in range(n):
    for j in range(i+1, n):
        if w[i]>w[j]:
            c+=1
c%=2
for j in range(m):
    l, r=[int(k) for k in input().split()]
    x=r-l+1
    if x!=1 and (x*(x-1)//2)%2:
        c=not c
    if c:
        print(""odd"")
    else:
        print(""even"")",quadratic,"brute force,math",345
"from sys import stdin, stdout

n = int(stdin.readline())
values = list(map(int, stdin.readline().split()))

cnt = 0
for i in range(n):
    for j in range(i + 1, n):
        if values[i] > values[j]:
            cnt += 1

m = int(stdin.readline())
for i in range(m):
    l, r = map(int, stdin.readline().split())
    n = r - l + 1
    
    cnt += n * (n - 1) // 2
    cnt &= 1
    
    if cnt == 1:
        stdout.write('odd\n')
    else:
        stdout.write('even\n')",quadratic,"brute force,math",468
"import sys
f=sys.stdin
n=int(f.readline())
a=list(map(int,f.readline().split()))
s=0
for i in range(n):
    for j in range(i):
        s^=a[j]>a[i]
q=int(f.readline())
for i in range(q):
    l,r=map(int,f.readline().split())
    s^=(r-l+1)*(r-l)//2%2
    print(['even','odd'][s])",quadratic,"brute force,math",279
"if __name__ == ""__main__"":
    n = int(input())
    nums = [int(a) for a in input().strip().split()]
    counts = 0

    for i in range(n-1):
        for j in range(i + 1, n):
            if nums[i] > nums[j]:
                counts += 1

    ans = counts % 2
    ans_tmp = []
    m = int(input())
    for i in range(m):
        l, r = [int(a) for a in input().strip().split()]

        tmp = r - l + 1
        tmp_count = (tmp * (tmp - 1) // 2)
        if tmp_count % 2 == 1:
            ans = (ans + 1) % 2
        ans_tmp.append(ans)
    
    for i in range(m):
        ans = ans_tmp[i]
        if ans % 2 == 1:
            print(""odd"")
        else:
            print(""even"")

 	  		 	 	 	    	  		 		    	 	",quadratic,"brute force,math",712
"n = int(input())
d = list(map(int, input().split()))
odd = 0
for i in range(n):
    for j in range(i, n):
        if(d[i]>d[j]): odd ^= 1

m = int(input())
ans = []
for i in range(m):
    l, r = map(int, input().split())
    k = r-l+1
    if( (k*(k-1)/2) %2): odd ^= 1
    ans.append( ""odd"" if odd else ""even"")

print('\n'.join(ans))",quadratic,"brute force,math",333
"import sys
input=sys.stdin.readline
def getsum(BITTree,i):
    i=i+1
    s = 0
    while i > 0:
        s += BITTree[i]
        i -= i & (-i) 
    return(s) 
def updatebit(BITTree , n , i ,v):
    i=i+1
    while i <= n:
        BITTree[i] += v
        i += i & (-i)
    #print(BITTree)
n=int(input())
lista=[int(i) for i in input().split()]
invercount=0
bitTree=[0]*(n+2)
for k in reversed(lista):
        updatebit(bitTree,n+1,k,1)
        counter=getsum(bitTree,k-1)
        invercount+=counter
m=int(input())
for i in range(m):
    l,r=map(int,input().split())
    summa=((r-l+1)*(r-l))/2
    if (invercount+summa)%2:
        print('odd')
        invercount=1
    else:
        print('even')
        invercount=0
    
",quadratic,"brute force,math",722
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            print('even')
        else:
            print('odd')


main()",quadratic,"brute force,math",553
"def main():
    import sys
    input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    ans = []
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            ans.append('even')
        else:
            ans.append('odd')
    print('\n'.join(ans))

main()",quadratic,"brute force,math",601
"def main():
    # import sys
    # input = sys.stdin.readline

    n = int(input())
    a = list(map(int, input().split()))
    cnt = 0
    for i in range(n):
        for j in range(i+1, n):
            if a[i] > a[j]:
                cnt += 1
    even = cnt % 2 == 0
    q = int(input())
    ans = []
    for _ in range(q):
        l, r = map(int, input().split())
        len = r - l + 1
        pairs = len * (len-1) // 2
        if pairs % 2 == 1:
            even = not even
        if even:
            ans.append('even')
        else:
            ans.append('odd')
    print('\n'.join(ans))


main()",quadratic,"brute force,math",606
"# def main():
import sys
input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))
cnt = 0
for i in range(n):
    for j in range(i+1, n):
        if a[i] > a[j]:
            cnt += 1
even = cnt % 2 == 0
q = int(input())
ans = []
for _ in range(q):
    l, r = map(int, input().split())
    len = r - l + 1
    pairs = len * (len-1) // 2
    if pairs % 2 == 1:
        even = not even
    if even:
        ans.append('even')
    else:
        ans.append('odd')
print('\n'.join(ans))


# main()",quadratic,"brute force,math",514
"import sys
input = sys.stdin.readline
maxn = int(1510)
ST = [0 for _ in range(4 * maxn)]
def update(id, l, r, val):
    if l == r == val:
        ST[id] = 1
        return
    if l > val or r < val:
        return
    mid = int((l + r) / 2)
    update(id * 2, l, mid, val)
    update(id * 2 + 1, mid + 1, r, val)
    ST[id] = ST[id * 2] + ST[id * 2 + 1]
    return
def get(id, l, r, x, y):
    if l > y or r < x:
        return 0
    if x <= l and r <= y:
        return ST[id]
    mid = int((l + r) / 2)
    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)
n, res = int(input()), 0
for x in list(map(int, input().split())):
    res ^= get(1, 1, n, x + 1, n) % 2
    update(1, 1, n, x)
for i in range (int(input())):
    x, y = list(map(int, input().split()))
    if int((y - x) * (y - x + 1) / 2) & 1:
        res ^= 1
    if res:
        print(""odd"")
    else:
        print(""even"")",quadratic,"brute force,math",904
"import sys
input = sys.stdin.readline
maxn = int(1e5 + 10)
ST = [0] * (4 * maxn)
def update(id, l, r, val):
    if l == r == val:
        ST[id] = 1
        return
    if l > val or r < val:
        return
    mid = int((l + r) / 2)
    update(id * 2, l, mid, val)
    update(id * 2 + 1, mid + 1, r, val)
    ST[id] = ST[id * 2] + ST[id * 2 + 1]
    return
def get(id, l, r, x, y):
    if l > y or r < x:
        return 0
    if x <= l and r <= y:
        return ST[id]
    mid = int((l + r) / 2)
    return get(id * 2, l, mid, x, y) + get(id * 2 + 1, mid + 1, r, x, y)
n, res = int(input()), 0
for x in list(map(int, input().split())):
    res ^= get(1, 1, n, x + 1, n) % 2
    update(1, 1, n, x)
for i in range (int(input())):
    x, y = list(map(int, input().split()))
    if int((y - x) * (y - x + 1) / 2) & 1:
        res ^= 1
    if res:
        print(""odd"")
    else:
        print(""even"")",quadratic,"brute force,math",896
"def arr_inp():
    return [int(x) for x in stdin.readline().split()]


def nCr(n, r):
    f, m = factorial, 1
    for i in range(n, n - r, -1):
        m *= i
    return int(m // f(r))


from math import factorial
from sys import stdin

n, a, ans, tem = int(input()), arr_inp(), [], 0
mem = [0] * (n + 1)

for i in range(n):
    for j in range(a[i] - 1, 0, -1):
        if not mem[j]:
            tem += 1
    mem[a[i]] = 1

for i in range(int(input())):
    l, r = arr_inp()
    tem += nCr(r - l + 1, 2)
    ans.append('odd' if tem % 2 else 'even')

print('\n'.join(ans))
",quadratic,"brute force,math",573
"n = int(input())
l = list(map(int, input().split()))
odd = 0
for i in range(n):
    for j in range(i, n):
        if(l[i]>l[j]): odd ^= 1
 
m = int(input())
ans = []
for i in range(m):
    ll, r = map(int, input().split())
    k = r-ll+1
    if( (k*(k-1)/2) %2): odd ^= 1
    ans.append( ""odd"" if odd else ""even"")
 
print('\n'.join(ans))",quadratic,"brute force,math",337
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict


BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
mod=10**9+7
n=int(input())
a=list(map(int,input().split()))
c=0
for i in range (1,n):
    for j in range (i):
        if a[j]>a[i]:
            c+=1
c=c%2
m=int(input())
for i in range (m):
    l,r=map(int,input().split())
    s=(r-l+1)//2
    if s%2==1:
        c=(c+1)%2
    if c==0:
        print(""even"")
    else:
        print(""odd"")",quadratic,"brute force,math",2373
"import zlib, base64
exec(zlib.decompress(base64.b64decode(b'eJyFV8lu2zAQPTdfIenAUGhR9FygXxLk4MJu4SJwAscJSIEfX4nLzHtDpT0kGM6+j3w83IYfw8M0BhemL8M0+pBiWuYMBzdGtwjYgMUpWGRWtnFJq6Srkh7g4JqSjW9Jm3wKjdYohIzALkivfuX/m02nYBUJ2ZNVLjZPAM5hrFTR5BFGasLg/RbOvPniIsSU0AXAtMgMnanRShPVFx+QA+jRad5CyWhoMUbIqCBL0RII5jSZd+Fg+sLB7dpNWOItRcaFNKqVyFpKgdkR9ELB2PpzhIJGt1amli/aSDlOQ1W5ymHiJFsYYHCkD0VZsMSmDSMl1XpmYM2R9HtTwgOYgCe3KLwXmJUdMRaiID+w28WKfGVICbfyzMaHNKq36IWCC+Qp7gTLoVYRL+28GH6Pjb7JmDjJ1l6AsDu2CGFzJR5RM58wnDCZ/8it9nlXgzYrihNlNr2dFmUoamj1pv961Y93meJ9B62u0gF2rkXzB3qlJziEzfWuYFHWPJQLSrNZExXlgesBaI1S7dDm4v6AYYZkwNRD40AGaBck3vYLibQi4e7Mpzdhf7YtAgh+loaltc0HVw5zYkuEsS7ggJBtuAiJjOrDswaBanOqF9E6C7ebnO0wdKn5+BjM3k1HOl5245pj1yknlqH5iOnZ4TG5pSsPGSN7oesOHf3AbWGaglqiO/MpdM2Q3zUjZBNwYFBD7Q46XvMWlWxICAFca8Mq7x2nQwpdqS0Pa6nXHaxAQUZTtby1qnH+YLH6sFyySaV6qRYumsLpNS4dRyPdzjkSFitEDDDFtXB6irVwggtgVE55RYBFZW4rWm62iMd91wK4JjOL11vfO9LMUS85aODCdWuK7Mu3g7BkuNqOLKSfJwXMY8k/hxLiokkkR2bGIdiZtTWOCWVgH+1NYMPDXMl+q8siUffUp05hY4Q6alBt8DSSVi3jvlzTAppNKU8dpwppDSokDq2uhenx7tfzdTgP58twPVx+n/z5clv/Xt5ufp7n73efXq4b5ni4PZzeD09++vZzGj4P9/df/zyfL/7p/Hrz19P76fp6OqrcPD/Od38BvToehw==')))
 			   	 	   	   	  		 	  			 	",quadratic,"bitmasks,dp,shortest paths",1172
"# -*- coding: utf-8 -*-
dat = ""硼磷碳磷溴硼氧磷氮硫氮氯氟溴硼磷碳硼硫碳氯溴硼磷碳硼硫溴硼磷碳硼氯碳硫溴硼磷碳硼氯溴硼氧硼硫碳硼氯氮磷氮硫碳氯氟溴硼氧磷氮硫碳氯氟溴硼磷碳硫碳氯溴硼氧硼硫碳氯氮硼氯碳硫氮磷氟溴硼磷碳氯溴硼氧硼氯碳硫氮磷氟溴硼磷碳硫溴硼氧硼硫碳氯氮磷氟溴硼磷碳氧硫氮氯氟溴硼磷溴硼硫碳硼氯碳磷溴硼硫碳硼氯溴硼氧硼磷碳硼氯氮磷碳氯氮硫氟溴硼氧磷碳氯氮硫氟溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟溴硼氧磷碳硫氮氯氟溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮硼磷碳硼硫碳氯溴硼氧氧磷氮硫氟碳氯氮磷碳硫氟溴硼磷碳硫碳氯氮硼硫碳硼氯碳磷溴硼磷碳硫碳氯氮硼硫碳硼氯溴硼磷碳氯氮硼硫碳硼氯碳磷溴硼磷碳氯氮硼硫碳硼氯溴硼磷碳硫氮硼硫碳硼氯碳磷溴硼磷碳硫氮硼硫碳硼氯溴硼磷碳氧硫氮氯氟氮硼硫碳硼氯碳磷溴硼磷氮硼硫碳硼氯溴硼硫碳磷碳氯溴硼氧硼磷碳氯氮硼氯碳磷氮硫氟溴硼硫碳氯溴硼氧硼氯碳磷氮硫氟溴硼磷碳硼氯碳硫氮硼硫碳磷碳氯溴硼磷碳硼氯氮硼硫碳磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氯溴硼磷碳硼氯氮硼硫碳氯溴硼磷碳硫碳氯氮硼硫碳磷碳氯溴硼氧硼磷碳氯氮硼氯碳磷氮硫氟氮硼磷碳硫碳氯溴硼氧磷碳硫氟碳氯溴硼氧硼氯碳磷氮硫氟氮硼磷碳氯溴硼磷碳硫氮硼硫碳磷碳氯溴硼氧硼硫碳氯氮磷氟氮硼硫碳磷碳氯溴硼磷碳硫氮硼硫碳氯溴硼磷氮硼硫碳氯溴硼硫碳磷溴硼氧硼磷碳氯氮硫氟溴硼硫碳氧磷氮氯氟溴硼硫溴硼磷碳硼氯碳硫氮硼硫碳磷溴硼磷碳硼氯氮硼硫碳磷溴硼磷碳硼氯碳硫氮硼硫碳氧磷氮氯氟溴硼磷碳硼氯氮硼硫溴硼磷碳硫碳氯氮硼硫碳磷溴硼氧硼磷碳氯氮硫氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼硫碳磷溴硼磷碳氯氮硼硫溴硼磷碳硫氮硼硫碳磷溴硼氧硼磷碳硼硫碳氯氮磷碳硫氟溴硼磷碳氧硫氮氯氟氮硼硫碳磷溴硼磷氮硼硫溴硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳磷碳硫溴硼磷碳硼硫氮硼氯碳磷碳硫溴硼氯碳硫溴硼氧硼硫碳磷氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳硫溴硼磷碳硼硫氮硼氯碳硫溴硼磷碳硫碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳硫氮磷氟氮硼氯碳磷碳硫溴硼氧磷碳氯氟碳硫溴硼氧硼硫碳磷氮氯氟氮硼磷碳硫溴硼磷碳氯氮硼氯碳硫溴硼磷氮硼氯碳硫溴硼氯碳磷溴硼氧硼磷碳硫氮氯氟溴硼磷碳硼硫碳氯氮硼氯碳磷溴硼磷碳硼硫氮硼氯碳磷溴硼氯碳氧磷氮硫氟溴硼氯溴硼磷碳硼硫碳氯氮硼氯碳氧磷氮硫氟溴硼磷碳硼硫氮硼氯溴硼磷碳硫碳氯氮硼氯碳磷溴硼氧硼磷碳硫氮氯氟氮硼磷碳硫碳氯溴硼磷碳氯氮硼氯碳磷溴硼氧硼磷碳硼氯碳硫氮磷碳氯氟溴硼磷碳硫氮硼氯碳磷溴硼磷碳硫氮硼氯溴硼磷碳氧硫氮氯氟氮硼氯碳磷溴硼磷氮硼氯溴硼硫碳磷碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼硫碳磷碳氯溴硼硫碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳磷氮硫氟氮硼氯碳磷碳硫溴硼硫碳磷碳氯氮硼氯碳硫溴硼氧硼硫碳磷氮氯氟氮硼硫碳磷碳氯溴硼硫碳氯氮硼氯碳硫溴硼氧硼硫碳硼氯碳磷氮硫碳氯氟溴硼磷碳硫碳氯氮硼硫碳磷碳氯氮硼氯碳磷碳硫溴硼氧硼磷碳硫氮硼硫碳磷氮氯氟氮硼磷碳硫碳氯氮硼硫碳磷碳氯溴硼氧磷碳硫氟碳氯氮硼氯碳磷碳硫溴硼氧硼氯碳磷氮硫氟氮硼磷碳氯氮硼氯碳磷碳硫溴硼氧磷碳氯氟碳硫氮硼硫碳磷碳氯溴硼氧硼硫碳磷氮氯氟氮硼磷碳硫氮硼硫碳磷碳氯溴硼氧磷碳硫氟碳氯氮硼氯碳硫溴硼磷氮硼硫碳氯氮硼氯碳硫溴硼氧硫碳氯氟碳磷溴硼氧硼磷碳硫氮氯氟氮硼硫碳磷溴硼硫碳氯氮硼氯碳磷溴硼硫氮硼氯碳磷溴硼硫碳磷氮硼氯碳硫溴硼硫碳磷氮硼氯溴硼硫碳氧磷氮氯氟氮硼氯碳硫溴硼硫氮硼氯溴硼氧硫碳氯氟碳磷氮硼磷碳硫碳氯溴硼氧硼磷碳硫氮氯氟氮硼磷碳硫碳氯氮硼硫碳磷溴硼氧磷碳硫氟碳氯氮硼氯碳磷溴硼磷碳氯氮硼硫氮硼氯碳磷溴硼氧磷碳氯氟碳硫氮硼硫碳磷溴硼磷碳硫氮硼硫碳磷氮硼氯溴硼磷碳硫氮硼硫碳氯氮硼氯碳磷溴硼氧磷碳硫碳氯氟溴磷碳硫碳氯溴硼氧磷氮硫氮氯氟氮磷碳硫碳氯溴硼磷碳硼硫碳氯氮磷碳硫碳氯溴硼磷碳硼硫氮磷碳硫碳氯溴硼磷碳硼氯碳硫氮磷碳硫碳氯溴硼磷碳硼氯氮磷碳硫碳氯溴硼氧硼硫碳硼氯氮磷氮硫碳氯氟氮磷碳硫碳氯溴硼氧磷氮硫碳氯氟氮磷碳硫碳氯溴硫碳氯溴硼氧磷氮硫氮氯氟氮硫碳氯溴硼磷碳氯氮硫碳氯溴硼磷碳硼硫氮硫碳氯溴硼磷碳硫氮硫碳氯溴硼磷碳硼氯氮硫碳氯溴硼磷碳氧硫氮氯氟氮硫碳氯溴硼磷氮硫碳氯溴硼硫碳硼氯碳磷氮磷碳硫碳氯溴硼硫碳硼氯氮磷碳硫碳氯溴硼氧硼磷碳硼氯氮磷碳氯氮硫氟氮磷碳硫碳氯溴硼氧磷碳氯氮硫氟氮磷碳硫碳氯溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮磷碳硫碳氯溴硼氧磷碳硫氮氯氟氮磷碳硫碳氯溴硼氧硼磷碳硼硫氮磷碳硫氮氯氟氮硼磷碳硼硫碳氯氮磷碳硫碳氯溴硼氧氧磷氮硫氟碳氯氮磷碳硫氟氮磷碳硫碳氯溴硼硫碳硼氯碳磷氮硫碳氯溴硼硫碳硼氯氮硫碳氯溴硼磷碳氯氮硼硫碳硼氯碳磷氮硫碳氯溴硼氧磷碳氯氮硫氟氮硫碳氯溴硼磷碳硫氮硼硫碳硼氯碳磷氮硫碳氯溴硼氧磷碳硫氮氯氟氮硫碳氯溴硼磷碳氧硫氮氯氟氮硼硫碳硼氯碳磷氮硫碳氯溴硼磷氮硼硫碳硼氯氮硫碳氯溴磷碳氯溴硼氧磷氮硫氮氯氟氮磷碳氯溴硼硫碳氯氮磷碳氯溴硼磷碳硼硫氮磷碳氯溴硼磷碳硼氯碳硫氮磷碳氯溴硼磷碳硼氯氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氯氮磷碳氯溴硼氧磷氮硫碳氯氟氮磷碳氯溴氧磷氮硫氟碳氯溴硼氧磷氮硫氮氯氟氮氧磷氮硫氟碳氯溴氯溴硼磷碳硼硫氮氯溴硼磷碳硫氮磷碳氯溴硼氧硼硫碳氯氮磷氟氮磷碳氯溴硼磷碳硫氮氯溴硼磷氮氯溴硼硫碳磷氮磷碳氯溴硼硫碳硼氯氮磷碳氯溴硼硫碳氧磷氮氯氟氮磷碳氯溴硼硫氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳磷氮磷碳氯溴硼氧磷碳硫氮氯氟氮磷碳氯溴硼磷碳硼氯碳硫氮硼硫碳氧磷氮氯氟氮磷碳氯溴硼磷碳硼氯氮硼硫氮磷碳氯溴硼硫碳磷氮硫碳氯溴硼氧硼磷碳氯氮硫氟氮硫碳氯溴硼硫碳磷氮氯溴硼硫氮氯溴硼磷碳硫氮硼硫碳磷氮磷碳氯溴硼磷碳硼氯氮硼硫碳磷氮硫碳氯溴硼磷碳硫氮硼硫碳磷氮氯溴硼磷氮硼硫氮氯溴磷碳硫溴硼氧磷氮硫氮氯氟氮磷碳硫溴硼磷碳硼硫碳氯氮磷碳硫溴硼磷碳硼硫氮磷碳硫溴硼氯碳硫氮磷碳硫溴硼磷碳硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳硫氮磷碳硫溴硼氧磷氮硫碳氯氟氮磷碳硫溴氧磷氮氯氟碳硫溴硼氧磷氮硫氮氯氟氮氧磷氮氯氟碳硫溴硼磷碳氯氮磷碳硫溴硼氧硼氯碳硫氮磷氟氮磷碳硫溴硫溴硼磷碳硼氯氮硫溴硼磷碳氯氮硫溴硼磷氮硫溴硼氯碳磷氮磷碳硫溴硼硫碳硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳磷氮磷碳硫溴硼氧磷碳氯氮硫氟氮磷碳硫溴硼氯碳氧磷氮硫氟氮磷碳硫溴硼氯氮磷碳硫溴硼磷碳硼硫碳氯氮硼氯碳氧磷氮硫氟氮磷碳硫溴硼磷碳硼硫氮硼氯氮磷碳硫溴硼氯碳磷氮硫碳氯溴硼氧硼磷碳硫氮氯氟氮硫碳氯溴硼磷碳氯氮硼氯碳磷氮磷碳硫溴硼磷碳硼硫氮硼氯碳磷氮硫碳氯溴硼氯碳磷氮硫溴硼氯氮硫溴硼磷碳氯氮硼氯碳磷氮硫溴硼磷氮硼氯氮硫溴氧硫氮氯氟碳磷溴硼氧磷氮硫氮氯氟氮氧硫氮氯氟碳磷溴硼硫碳氯氮磷碳硫溴硼氧硼氯碳磷氮硫氟氮磷碳硫溴硼氯碳硫氮磷碳氯溴硼氧硼硫碳磷氮氯氟氮磷碳氯溴硼硫碳氯氮硼氯碳硫氮磷碳硫溴硼磷碳硼硫氮硼氯碳硫氮磷碳氯溴氧磷氮硫氟碳氯氮磷碳硫溴硼氧磷氮硫氮氯氟氮氧磷氮硫氟碳氯氮磷碳硫溴磷碳硫氮氯溴硼磷碳硼硫氮磷碳硫氮氯溴磷碳氯氮硫溴硼磷碳硼氯氮磷碳氯氮硫溴硫氮氯溴硼磷氮硫氮氯溴磷溴硼硫碳硼氯氮磷溴硼硫碳氯氮磷溴硼硫氮磷溴硼氯碳硫氮磷溴硼氯氮磷溴硼硫碳氯氮硼氯碳硫氮磷溴硼硫氮硼氯氮磷溴磷氮硫碳氯溴硼硫碳硼氯氮磷氮硫碳氯溴磷氮氯溴硼硫氮磷氮氯溴磷氮硫溴硼氯氮磷氮硫溴磷氮硫氮氯溴硼磷氮磷"".split('溴')
d1, d2 = ""硼碳氮氧氟磷硫氯"", ""!&|()xyz""
for i in range(int(input())):
	s = dat[eval(""0b"" + ''.join(list(reversed(input()))))]
	for i in range(8): s = s.replace(d1[i], d2[i])
	print(s)
",quadratic,"bitmasks,dp,shortest paths",3172
"x = int('00001111', 2)
y = int('00110011', 2)
z = int('01010101', 2)
E = set()
T = set()
F = {('x', x), ('y', y), ('z', z)}
prv = (set(), set(), set())
fam = 2 ** 8
tmpl = '#' * 99
ans = [tmpl] * fam
def cmpr(E):
    global ans
    ans = [tmpl] * fam
    for e in E:
        if len(ans[e[1]]) > len(e[0]) or len(ans[e[1]]) == len(e[0]) and ans[e[1]] > e[0]:
            ans[e[1]] = e[0]
    return set((j, i) for i, j in enumerate(ans) if j != tmpl)
while prv != (E, T, F):
    prv = E.copy(), T.copy(), F.copy()
    for f in prv[2]:
        F.add(('!' + f[0], ~f[1] & (fam - 1)))
        T.add(f)
        for t in prv[1]:
            T.add((t[0] + '&' + f[0], t[1] & f[1]))
    for t in prv[1]:
        E.add(t)
    for e in prv[0]:
        if e not in F:
            F.add(('(' + e[0] + ')', e[1]))
        for t in prv[1]:
            E.add((e[0] + '|' + t[0], e[1] | t[1]))
    E, T, F = cmpr(E), cmpr(T), cmpr(F)
cmpr(E)
n = int(input())
for i in range(n):
	print(ans[int(input(), 2)])",quadratic,"bitmasks,dp,shortest paths",990
"from heapq import *

MSIZE = 1 << 8
def GetVal(s):
    ans = 0
    for i in range(8):
        if s[i] == '1':
            ans = ans + (1 << i)
    return ans

def GetNot(s):
    return MSIZE - 1 - s;

xVal = GetVal('00001111')
yVal = GetVal('00110011')
zVal = GetVal('01010101')

# 0 - |
# 1 - &
# 2 - !
# 3 - ()

def Dijkstra():
    depth = [['Z' * 585 for i in range(4)] for i in range(MSIZE)]
    depth[xVal][3] = 'x'
    depth[yVal][3] = 'y'
    depth[zVal][3] = 'z'

    pq = []
    def push(kek):
        heappush(pq, kek)
    def pop():
        return heappop(pq)
    push([1, xVal, 3])
    push([1, yVal, 3])
    push([1, zVal, 3])
    while len(pq) > 0:
        l, i, j = pop();
        if len(depth[i][j]) < l: continue
        for x in range(MSIZE):
            for y in range(4):
                nxt1 = depth[i][j] + '|' + depth[x][y]
                nxt2 = depth[x][y] + '|' + depth[i][j]
                nxt = min(nxt1, nxt2)
                val = (i | x)
                if len(depth[val][0]) == len(nxt) and depth[val][0] > nxt:
                    depth[val][0] = nxt
                    push([len(nxt), val, 0])
                elif len(depth[val][0]) > len(nxt):
                    depth[val][0] = nxt
                    push([len(nxt), val, 0])
        if j > 0:
            for x in range(MSIZE):
                for y in range(1, 4):
                    nxt1 = depth[i][j] + '&' + depth[x][y]
                    nxt2 = depth[x][y] + '&' + depth[i][j]
                    nxt = min(nxt1, nxt2)
                    val = (i & x)
                    if len(depth[val][1]) == len(nxt) and depth[val][1] > nxt:
                        depth[val][1] = nxt
                        push([len(nxt), val, 1])
                    elif len(depth[val][1]) > len(nxt):
                        depth[val][1] = nxt
                        push([len(nxt), val, 1])
        if j > 2:
            val = GetNot(i)
            nxt = '!' + depth[i][j]
            if len(depth[val][2]) == len(nxt) and depth[val][2] > nxt:
                depth[val][2] = nxt
                push([len(nxt), val, 2])
            elif len(depth[val][2]) > len(nxt):
                depth[val][2] = nxt
                push([len(nxt), val, 2])
        nxt = '(' + depth[i][j] + ')'
        val = i
        if len(depth[val][3]) == len(nxt) and depth[val][3] > nxt:
            depth[val][3] = nxt
            push([len(nxt), val, 3])
        elif len(depth[val][3]) > len(nxt):
            depth[val][3] = nxt
            push([len(nxt), val, 3])
    answer = []
    for i in range(MSIZE):
        ans = 'Z' * 585
        for j in range(4):
            if len(ans) > len(depth[i][j]):
                ans = depth[i][j]
            elif len(ans) == len(depth[i][j]) and ans > depth[i][j]:
                ans = depth[i][j]
        answer.append(ans)
    return answer
kek = Dijkstra()

q = int(input())
for i in range(q):
    print(kek[GetVal(input())])",quadratic,"bitmasks,dp,shortest paths",2936
"# from typing import List, Set, Dict, Tuple, Text, Optional
from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
import functools
import random
from atexit import register
from io import BytesIO
import __pypy__  # type: ignore

EPS = 10**-12

#########
# INPUT #
#########


class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):
    # type: () -> str
    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

##########
# OUTPUT #
##########


class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):
    # type: (str) -> None
    self.out.append(str(text))

  def writeLine(self, text):
    # type: (str) -> None
    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

###########
# LIBRARY #
###########


def bootstrap(f, stack=[]):
  # Deep Recursion helper.
  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst
  # Usage:

  # @bootstrap
  # def recur(n):
  #   if n == 0:
  #     yield 1
  #   yield (yield recur(n-1)) * n
  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc


class CycleFindDirected(object):
  '''
  >>> tp = CycleFindDirected(6)
  >>> tp.find() is None
  True
  >>> tp.add_edge(1, 2)
  >>> tp.add_edge(2, 4)
  >>> tp.add_edge(2, 3)
  >>> tp.add_edge(3, 0)
  >>> tp.add_edge(1, 3)
  >>> tp.find() is None
  True
  >>> tp.add_edge(0, 1)
  >>> len(tp.find())
  4
  >>> tp.add_edge(3, 1)
  >>> tp.find() is not None
  True
  >>> tp = CycleFindDirected(2)
  >>> tp.add_edge(0, 1)
  >>> tp.add_edge(1, 1)
  >>> tp.find()
  [1, 1]
  >>> tp = CycleFindDirected(2)
  >>> tp.add_edge(0, 1)
  >>> tp.add_edge(1, 0)
  >>> tp.find() in [[0, 1], [1, 0]]
  True

  Tested in: 
  '''

  def __init__(self, n):
    # type: (int) -> None
    self.n = n
    self.adj = [[] for _ in range(n)]

  def add_edge(self, u, v):
    # type: (int, int) -> None
    assert 0 <= u < self.n
    assert 0 <= v < self.n
    self.adj[u].append(v)

  @bootstrap
  def dfs(self, node):
    self.color[node] = 1
    for i in self.adj[node]:
      if self.color[i] == 0:
        # unvisited
        self.parent[i] = node
        if (yield self.dfs(i)):
          yield True

      elif self.color[i] == 1:
        self.cycle_end = node
        self.cycle_start = i
        yield True

    self.color[node] = 2
    yield False

  def find(self):
    self.color = [0] * self.n
    self.parent = [-1] * self.n
    self.cycle_end = -1
    self.cycle_start = -1

    for i in range(self.n):
      if not self.color[i] and self.dfs(i):
        answer = []
        node_begin = self.cycle_start
        node_end = self.cycle_end
        answer.append(node_begin)
        while node_end != node_begin:
          answer.append(node_end)
          node_end = self.parent[node_end]

        answer.reverse()
        if len(answer) == 1:
          # special case of self loop
          return [node_begin, node_begin]
        return answer

    return None


#########
# LOGIC #
#########


def main(inp, out):
  # type: (Input, Output) -> any
  n, m = map(int, inp.rawInput().split())
  edges = []
  base = CycleFindDirected(n)
  for _ in range(m):
    u, v = map(int, inp.rawInput().split())
    u -= 1
    v -= 1
    edges.append((u, v))
    base.add_edge(u, v)

  cycle = base.find()
  if not cycle:
    out.writeLine(""YES"")
    return

  cycle.append(cycle[0])

  bad_edges = set()
  cycle_edges = []
  for u, v in zip(cycle[:-1], cycle[1:]):
    bad_edges.add((u, v))
    cycle_edges.append((u, v))

  cf = CycleFindDirected(n)
  for edge in edges:
    if edge not in bad_edges:
      cf.add_edge(edge[0], edge[1])

  for edge in cycle_edges:
    for toadd in cycle_edges:
      if toadd != edge:
        cf.adj[toadd[0]].append(toadd[1])

    if not cf.find():
      out.writeLine('YES')
      return

    for toadd in cycle_edges:
      if toadd != edge:
        cf.adj[toadd[0]].pop()

  out.writeLine('NO')

###############
# BOILERPLATE #
###############


output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",quadratic,"dfs and similar,graphs",4780
"import sys


def prepare():
    stack = [i for i in range(n) if deg[i] == 0]
    cnt = 0
    while stack:
        v = stack.pop()
        cnt += 1
        for dest in adj[v]:
            deg[dest] -= 1
            if deg[dest] == 0:
                stack.append(dest)
        adj[v].clear()

    return cnt == n


def solve(st):
    stack = [st]
    visited = [0]*n
    cnt = 0
    while stack:
        v = stack.pop()
        cnt += 1
        for dest in adj[v]:
            if dest == st:
                continue
            visited[dest] += 1
            if deg[dest] == visited[dest]:
                stack.append(dest)

    return cnt == m


n, m = map(int, sys.stdin.buffer.readline().decode('utf-8').split())
adj = [[] for _ in range(n)]
rev = [[] for _ in range(n)]
deg = [0]*n
for u, v in (map(int, line.decode('utf-8').split()) for line in sys.stdin.buffer):
    adj[u-1].append(v-1)
    rev[v-1].append(u-1)
    deg[v-1] += 1

ok = prepare()
if ok:
    print('YES')
    exit()

m = len([1 for i in range(n) if deg[i] > 0])
for i in range(n):
    if deg[i] == 1 and solve(i):
        print('YES')
        exit()

print('NO')
",quadratic,"dfs and similar,graphs",1136
"

def my_solve(n, m, graph, mask):
	if do_dfs_bool(n,graph,mask.copy()):
		c = get_cyclic(n, graph, mask)
		for u,v in c:
			graph[u].remove(v)
			if not do_dfs_bool(n,graph,mask.copy()):
				return 'YES'
			graph[u].append(v)
		return ""NO""
	return ""YES""

def get_cyclic(n, graph, mask):
	c,v = do_dfs(n,graph,mask)
	path = []
	i = 0
	begin = False
	if c:
		for u in c.keys():
			if c[u] == v:
				begin = True
				path.append((c[u],u))
			elif begin:
				path.append((c[u],u))
		tmp = list(c.keys())
		if len(tmp):
			path.append((tmp[-1],v))
	return path

def do_dfs_bool(n, graph, mask):
	colors = [0]*(n+5)
	for u in graph.keys():
		if not u in mask.keys():
			if dfs_bool(u,graph,mask,colors):
				return True
	return False


def dfs_bool(u, graph, mask,colors):
	colors[u] = 1
	mask[u] = True
	for v in graph[u]:
		if colors[v] == 1:
			return True
		if colors[v] == 0:
			if dfs_bool(v,graph,mask,colors):				
				return True
	colors[u] = 2
	return False

def do_dfs(n, graph, mask):
	colors = [0]*(n+5)
	c = {}
	for u in graph.keys():
		if not u in mask.keys():
			c = {}
			p, v = dfs(u,graph,mask,c,colors)
			if p and v:
				return (p,v)


def dfs(u, graph, mask, c, colors):
	colors[u] = 1
	for v in graph[u]:
		if colors[v] == 1:
			return (c, v)
		if colors[v] == 0:
			c[v] = u
			p,w = dfs(v,graph,mask,c,colors)
			if w:
				return (p,w)
	colors[u] = 2
	if len(c) > 0:
		if u in c.keys():
			del c[u]
	return (c, None)

def test(n, m, edges):
	graph = {}
	mask = {}
	for u,v in edges:
		if u not in graph.keys():
			graph[u] = []
		graph[u].append(v)
		if v not in graph.keys():
			graph[v] = []
	return my_solve(n, m, graph, mask)


if __name__ == '__main__':
	n,m = [int(x) for x in input().split()]
	edges = []
	for i in range(0,m):
		u,v = [int(x) for x in input().split()]
		edges.append((u,v))
	print(test(n, m, edges))",quadratic,"dfs and similar,graphs",1842
"import sys

input = sys.stdin.readline


def get_input():
    n, m = [int(x) for x in input().split(' ')]
    digraph = [[] for _ in range(n + 1)]
    for _ in range(m):
        c1, c2 = [int(x) for x in input().split(' ')]
        digraph[c1].append(c2)

    return digraph


def dfs(graph, u=-1, v=-1):
    n = len(graph)

    pi = [None] * n
    color = ['white'] * n
    for node in range(1, n):
        if color[node] == 'white':
            cicle = dfs_visit(graph, node, color, pi, u, v)
            if cicle is not None:
                return cicle
    return None


def dfs_visit(graph, root, color, pi, u, v):
    stack = [root]

    while stack:
        current_node = stack[-1]

        if color[current_node] != 'white':
            stack.pop()
            color[current_node] = 'black'
            continue

        color[current_node] = 'grey'
        for adj in graph[current_node]:
            if (current_node, adj) == (u, v):
                continue

            if color[adj] == 'white':
                pi[adj] = current_node
                stack.append(adj)
            elif color[adj] == 'grey':
                cicle = [adj]
                while current_node != adj:
                    cicle.append(current_node)
                    current_node = pi[current_node]
                cicle.append(adj)
                return cicle  
    return None


if __name__ == ""__main__"":
    digraph = get_input()
    cicle = dfs(digraph)
    if cicle is None:
        print(""YES"")
    else:
        cicle.reverse()
        for i in range(len(cicle) - 1):
            c = dfs(digraph, cicle[i], cicle[i + 1])
            if c is None:
                print(""YES"")
                break
        else:
            print(""NO"")
",quadratic,"dfs and similar,graphs",1740
"def detect_cycle(n,edges):
        visited = [False]*n
        stack = []
        color = [0]*n
        for v in range(n):
            if not visited[v]:
                if dfs_visit(v,edges,visited,stack,color):
                    return stack
        return None 
     
def dfs_visit(v,edges,visited,stack,color):
        visited[v] = True
        stack.append(v)
        color[v] = 1
        for u in edges[v]:
            if not visited[u]:
               if dfs_visit(u,edges,visited,stack,color):
                   return True
                    
            elif color[u] == 1:
                stack.append(u)
                return True
        
        color[v] = 2
        stack.pop(stack.index(v))
        return False
     
if __name__ == '__main__':
        n,m = map(int,input().split())
        edges = [[] for i in range(n)]
        for _ in range(m):
            u,v  = map(int,input().split())
            edges[u - 1].append(v - 1)
     
        inCycle = detect_cycle(n,edges)   
        if inCycle:
            possible = False
            index = inCycle.index(inCycle[-1])
            inCycle = inCycle[index:]
            for v in range(len(inCycle) - 1):
                edges[inCycle[v]].remove(inCycle[v + 1])
                if detect_cycle(n,edges) is None:
                    possible = True
                    break
                else:
                    edges[inCycle[v]].append(inCycle[v + 1])
        else: possible = True
print('YES' if possible else 'NO')
",quadratic,"dfs and similar,graphs",1500
"from collections import deque, defaultdict, Counter
from itertools import product, groupby, permutations, combinations
from math import gcd, floor, inf, log2, sqrt, log10
from bisect import bisect_right, bisect_left
from statistics import mode
from string import ascii_uppercase

cases = int(input())
matrix1 = []
for _ in range(cases):
    matrix1.append(list(input()))

matrix2 = []
for _ in range(cases):
    matrix2.append(list(input()))

def transpose(matrix):
    return [list(x) for x in zip(*matrix)]

def reverse_row(matrix):
    return matrix[::-1]

def reverse_column(matrix):
    return [x[::-1] for x in matrix]
def rotate_90(matrix):
    """"""this is counterclockwise, which is same as 270 clockwise""""""
    return reverse_row(transpose(matrix))

def rotate_180(matrix):
    """"""same for both clockwise and counterclockwise""""""
    return reverse_row(reverse_column(matrix))
def rotate_270(matrix):
    """"""this is counterclockwise, which is same as 90 clockwise""""""
    return reverse_column(transpose(matrix))

if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")

    exit()

matrix2 = reverse_row(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()

matrix2 = reverse_column(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()
matrix2 = transpose(matrix2)
if matrix1 == matrix2 or matrix1 == reverse_row(matrix2) or matrix1 == reverse_column(matrix2) \
    or matrix1 == rotate_90(matrix2) or matrix1 == rotate_180(matrix2) or matrix1 == rotate_270(matrix2):
    print(""Yes"")
    exit()
else:
    print(""No"")

",quadratic,implementation,2064
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy


def main():
    n = rint()
    a1, a2 = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n))
    for i in range(4):
        if a2.mat in [a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()]:
            exit(print('Yes'))
    print('No')


class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

            if id != None:
                for i in range(r):
                    self.mat[i][i] = 1

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat


# FASTIO REGION
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",quadratic,implementation,4564
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy


def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])


class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

            if id != None:
                for i in range(r):
                    self.mat[i][i] = 1

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat


# FASTIO REGION
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",quadratic,implementation,4564
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy


def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])


class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def __add__(self, other):
        mat0 = Matrix(self.r, self.c)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][j] = self.mat[i][j] + other.mat[i][j]

        return mat0

    def __mul__(self, other):
        mat0 = Matrix(self.r, other.c)

        for i in range(self.r):
            for j in range(other.c):
                for k in range(self.c):
                    mat0.mat[i][j] += self.mat[i][k] * other.mat[k][j]

        return mat0

    def dot_mul(self, other):
        res = 0
        for i in range(self.r):
            for j in range(self.c):
                res += self.mat[i][j] * other.mat[j][i]

        return res

    def trace(self):
        res = 0
        for i in range(self.r):
            res += self.mat[i][i]

        return res

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def mat_pow(self, mat, p, mod=None):
        sq = Matrix(mat.r, mat.r, id=1)

        while p:
            if p & 1:
                p -= 1
                sq = sq * mat

            p //= 2
            mat = mat * mat

        return sq.mat


# FASTIO REGION
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",quadratic,implementation,4462
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy


def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph(), a1.flipv(), a1.fliph(), a1.flipv()])
    print(['No', 'Yes'][a2.mat in ans])


class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat



# FASTIO REGION
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",quadratic,implementation,3404
"import os, sys
from io import BytesIO, IOBase
from copy import deepcopy


def main():
    n = rint()
    a1, a2, ans = Matrix(n, n, rstr_2d(n)), Matrix(n, n, rstr_2d(n)), []
    for i in range(4):
        ans.extend([a1.rotate(), a1.fliph()])
        a1.fliph()
    print(['No', 'Yes'][a2.mat in ans])


class Matrix:
    def __init__(self, r, c, mat=None, id=None):
        self.r, self.c = r, c

        if mat != None:
            self.mat = deepcopy(mat)
        else:
            self.mat = [[0 for i in range(c)] for j in range(r)]

    def rotate(self):
        mat0 = Matrix(self.c, self.r)

        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[j][self.r - (i + 1)] = self.mat[i][j]

        self.mat, self.r, self.c = deepcopy(mat0.mat), self.c, self.r
        return self.mat

    def flipv(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[i][self.c - (j + 1)] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat

    def fliph(self):
        mat0 = Matrix(self.r, self.c)
        for i in range(self.r):
            for j in range(self.c):
                mat0.mat[self.r - (i + 1)][j] = self.mat[i][j]

        self.mat = deepcopy(mat0.mat)
        return self.mat


# FASTIO REGION
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


BUFSIZE = 8192
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
rstr = lambda: input().strip()
rstrs = lambda: [str(x) for x in input().split()]
rstr_2d = lambda n: [list(rstr()) for _ in range(n)]
rint = lambda: int(input())
rints = lambda: [int(x) for x in input().split()]
rint_2d = lambda n: [rint() for _ in range(n)]
rints_2d = lambda n: [rints() for _ in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b

if __name__ == '__main__':
    main()
",quadratic,implementation,3386
"#!/usr/bin/python3

import copy


def rotate90(n, f):
    return [[f[n - j - 1][i] for j in range(n)] for i in range(n)]

def fliphor(n, f):
    return [[f[i][n - j - 1] for j in range(n)] for i in range(n)]

def flipver(n, f):
    return [[f[n - i - 1][j] for j in range(n)] for i in range(n)]

def eq(n, f, g):
    for i in range(n):
        for j in range(n):
            if f[i][j] != g[i][j]:
                return False
    return True


n = int(input())
f = [list(input()) for i in range(n)]
g = [list(input()) for i in range(n)]

for doflipv in range(2):
    for dofliph in range(2):
        for nrot in range(4):
            h = copy.deepcopy(f)
            if dofliph == 1:
                h = fliphor(n, h)
            if doflipv == 1:
                h = flipver(n, h)
            for i in range(nrot):
                h = rotate90(n, h)
            if eq(n, h, g):
                print(""Yes"")
                exit(0)

print(""No"")",quadratic,implementation,944
"N = int(input())
m1 = []
m2 = []
ms = []
for n in range(N):
    m1.append(input())
for n in range(N):
    m2.append(input())

ms = [
    m2,
    [x[::-1] for x in m2],
    [x for x in reversed(m2)],
]

a = []
for m in ms:
    a.append(m)
    a.append([x[::-1] for x in reversed(m)])
    a.append([''.join(m[j][i] for j in range(N - 1, -1, -1)) for i in range(N)])
    a.append([''.join(m[j][i] for j in range(N)) for i in range(N - 1, -1, -1)])

ms = a
print(['NO', 'YES'][m1 in ms])
",quadratic,implementation,484
"N = int(input())
s1 = [list(input()) for i in range(N)]
s2 = [list(input()) for i in range(N)]

def rotate(s):
    ret = [[None for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            ret[i][j] = s[j][N-1-i]
    return ret

def v_mirror(s):
    return list(reversed(s))

def h_mirror(s):
    return [list(reversed(row)) for row in s]

def solve():
    global s1
    for i in range(4):
        if s1 == s2: return True
        if v_mirror(s1) == s2: return True
        if h_mirror(s1) == s2: return True
        if v_mirror(h_mirror(s1)) == s2: return True
        s1 = rotate(s1)
    return False

print('Yes' if solve() else 'No')
",quadratic,implementation,677
"n=int(input())
ns=[]
for i in range(n):
    s=input()
    ns.append(s)
ns2=[]
for i in range(n):
    s=input()
    ns2.append(s)


def rotate(i,j):
    return j,n-1-i
def flip(i,j):
    return j,i

def main():
    same=True
    for i in range(n): # 0
        for j in range(n):
            if ns[i][j]!=ns2[i][j]:
                same=False
                break
        if same==False:
            break
    if same:
        return True

    same=True
    for i in range(n):  # 1
        for j in range(n):
            a, b = rotate(i, j)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):  # 2
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):  # 3
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = rotate(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n): # 0
        for j in range(n):
            a,b=flip(i,j)
            if ns[a][b]!=ns2[i][j]:
                same=False
                break
        if same==False:
            break
    if same:
        return True

    same=True
    for i in range(n):  # 1
        for j in range(n):
            a, b = rotate(i, j)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):  # 2
        for j in range(n):
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True

    same=True
    for i in range(n):
        for j in range(n):  # 3
            a, b = rotate(i, j)
            a, b = rotate(a, b)
            a, b = rotate(a, b)
            a, b = flip(a, b)
            if ns[i][j] != ns2[a][b]:
                same = False
                break
        if same == False:
            break
    if same:
        return True
    else:
        return False

if main():
    print('Yes')
else:
    print('No')



",quadratic,implementation,2668
"def solve(board):
  n=len(board)
  ans=0
  for i in range(n):
    for j in range(n):
      if board[i][j] is 'X':
        ans+=2**(i*n+j)
  return ans 

def reverse_array(arr):
  for i in range(len(arr)):
    arr[i].reverse()

def rotate(matrix, degree):
    if degree == 0:
        return matrix
    elif degree > 0:
        return rotate(zip(*matrix[::-1]), degree-90)
    else:
        return rotate(zip(*matrix)[::-1], degree+90)

def make_list(board):
    board=list(board)
    arr=[]
    for i in range(len(list(board))):
        arr.append(list(board[i]))
    return arr

def add_rotations(board,st):
  for i in range(4):
    st.add(solve(board))
    reverse_array(board)
    st.add(solve(board))
    reverse_array(board)
    board=make_list(rotate(board, 90))
    

n=int(input())
arr1=[]
arr2=[]
for _ in range(n):
    arr1.append(list(input().strip()))
for _ in range(n):
    arr2.append(list(input().strip()))
s=set()
s.add(solve(arr1))
add_rotations(arr1,s)
l1=len(s)
#print(s,arr1,arr2)
s.add(solve(arr2))
add_rotations(arr2,s)
#print(s)
l2=len(s)
if l1==l2:
    print(""Yes"")
else:
    print(""No"")",quadratic,implementation,1110
"N = int(input())
first = []
second = []
for i in range(N):
    first.append([s for s in input()])
for i in range(N):
    second.append([s for s in input()])

def rotate_90(matrix):
    return list(zip(*matrix[::-1]))

def flip(matrix):
    return matrix[::-1]

def compare_matrices(first, second):
    for i in range(N):
        for j in range(N):
            if first[i][j] != second[i][j]:
                return False
    return True

def wrap(first, second):
    if compare_matrices(first, second) == True:
        return 'Yes'
    hold_first = first[::]
    for _ in range(3):
        first = rotate_90(first)
        if compare_matrices(first, second) == True:
            return 'Yes'
    first = hold_first
    first = flip(first)
    if compare_matrices(first, second) == True:
        return 'Yes'
    for _ in range(3):
        first = rotate_90(first)
        if compare_matrices(first, second) == True:
            return 'Yes'
    return 'No'

print(wrap(first, second))",quadratic,implementation,984
"from itertools import chain, combinations, permutations

def powerset(iterable):
    """"""
    powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)
    """"""
    xs = list(iterable)
    # note we return an iterator rather than a list
    return chain.from_iterable(combinations(xs,n) for n in range(len(xs)+1))

n = int(input())
cl1 = []
cl2 = []
for i in range(n):
  s = input()
  a = []
  for j in range(n):
    a.append(s[j])
  cl1.append(a)

for i in range(n):
  s = input()
  a = []
  for j in range(n):
    a.append(s[j])
  cl2.append(a)

def copy(m):
  res = []
  for i in range(n):
    a = []
    for j in range(n):
      a.append(m[i][j])
    res.append(a)
  return res

def pow(m):
  res = []
  for i in range(n):
    a = []
    for j in range(n):
      a.append(m[n-1-j][i])
    res.append(a)
  return res
  
def vert(m):
  res = []
  for i in range(n):
    res.append(m[i][::-1])
  return res
  
def gor(m):
  res = []
  for i in range(n):
    a = []
    for j in range(n):
      a.append(m[i][n-1-j])
    res.append(a)
  return res

comblist = [[1], []]
cm = [pow, pow, pow, vert, gor]
cm = list(powerset(cm))
res = False
if cl1 == cl2:
  res = True
else:
  for x in cm:
    for y in permutations(x):
      t = copy(cl1)
      for z in y:
        t = z(t)
      if t==cl2:
        res = True
      
if res:
  print('Yes')
else:
  print('No')",quadratic,implementation,1363
"#codeforces.com/contest/958/problem/A1
def flipH(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[i][N-j-1]
    return B

def flipV(A,N):
    B=[[0 for i in range(N)] for j in range(N)]
    for i in range(N):
        for j in range(N):
            B[i][j]=A[N-i-1][j]
    return B

def rotate90(A):
    ans = zip(*A[::-1])
    ans=list(map(list,ans))
    return ans

def check(A,B,N):
    for i in range(N):
        for j in range(N):
            if A[i][j]!=B[i][j]:
                return False
    return True

N=int(input())
A=[]
X=[]
for i in range(N):
    A.append(list(input()))
for i in range(N):
    X.append(list(input()))
B=flipH(A,N)
C=flipV(A,N)
flag=False
for i in range(4):
    if check(A,X,N) or check(B,X,N) or check(C,X,N):
        flag=True
        break
    else:
        A=rotate90(A)
        B=rotate90(B)
        C=rotate90(C)
if flag:
    print(""Yes"")
else:
    print(""No"")",quadratic,implementation,974
"import copy
n = int(input())
flg=0
mat1 = []
mat2 = []

mats = []
for i in range(0, n): mat1.append(tuple(input().strip()))
for i in range(0, n): mat2.append(tuple(input().strip()))
mats.append(mat2)
matu = copy.copy(mat2)
matv = copy.copy(mat2)
matv = list(zip(*matv))
mats.append(matv)

mattem = copy.copy(matu)
for i in range(0, 3):
	mattem = list(zip(*list(reversed(mattem))))
	mats.append(mattem)
mattem = copy.copy(matv)
for i in range(0, 3):
	mattem = list(zip(*list(reversed(mattem))))
	mats.append(mattem)

flg = 0
for cmat in mats:
	flg2 = 1
	for ri in range(0, n):
		if cmat[ri]!=mat1[ri]:
			flg2=0
			break
	if flg2==1:
		flg=1
		break
if flg==1: print(""Yes"")			
else: print(""No"")

",quadratic,implementation,695
"def rotate(L):
    L1 = ['' for i in range(n)]
    for i in range(n):
        for j in range(n):
            L1[n - j - 1] += L[i][j]
    return L1

def flip_v(L):
    L1 = []
    for i in range(n):
        L1.append(L[i][::-1])
    return L1

def flip_h(L):
    L1 = []
    for i in range(n):
        L1.append(L[n - i - 1])
    return L1

n = int(input())
L = []
M = []
for i in range(n):
    L.append(input())
for i in range(n):
    M.append(input())
L1 = rotate(L)
L2 = rotate(L1)
L3 = rotate(L2)
L4 = flip_v(L)
L5 = flip_h(L)
L6 = rotate(L4)
L7 = rotate(L6)
L8 = rotate(L7)
L9 = rotate(L5)
L10 = rotate(L9)
L11 = rotate(L10)
if L == M or L1 == M or L2 == M or L3 == M or L4 == M or L5 == M or L6 == M or L7 == M or L8 == M or L9 == M or L10 == M or L11 == M:
    print('Yes')
else:
    print('No')",quadratic,implementation,802
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')
",quadratic,implementation,668
"


def rotate(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()

    for x in range (0,n):
        for y in range (0,n):
            newli[x][y] = li[n-1-y][x]
    return newli

def flipV(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()
    newli.reverse()
    return newli

def flipH(li):
    newli = []
    for x in range (0,n):
        newli.append([])
        newli[x] = li[x].copy()

    for x in range (0,n):
        newli[x].reverse()
    return newli



n = int(input())
#print((s+1)*s//2-s+1)
#print('Ehab' if s%2==1 else 'Mahmoud')

li1, li2, li3, templi = [], [], [], []

for x in range (0,n):
    li1.append([])
    li2.append([])
    li3.append([])
    templi.append([])
    li1[x]=list(input())

for x in range (0,n):
    li2[x]=list(input())

#identical
if ( li1 ==li2 ):
    print('Yes')
    exit()

#flip horizontal
templi = flipH(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

#flip vertical
templi = flipV(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

#rotate1
templi = rotate(li2)
if ( li1 ==templi ):
    print('Yes')
    exit()

#rotate2
templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

#rotate3
templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

#flip
templi = flipH(li2)
templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

templi = rotate(templi)
if ( li1 ==templi ):
    print('Yes')
    exit()

print('No')    
",quadratic,implementation,1605
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

n = int(input())
a = [list(input()) for i in range(n)]
b = [list(input()) for i in range(n)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(n)] for u in range(n)]
    for t in range(n):
        for u in range(n):
            c[t][u] = b[u][n - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')",quadratic,implementation,667
"N = int(input())
map_1 = [list(input()) for i in range(N)]
map_2 = [list(input()) for i in range(N)]

maps = list()

maps.append([[map_2[i][j] for j in range(N)] for i in range(N)])
maps.append([[map_2[i][N - 1 - j] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - i][j] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - i][N - 1 - j] for j in range(N)] for i in range(N)])
maps.append([[map_2[j][i] for j in range(N)] for i in range(N)])
maps.append([[map_2[j][N - 1 - i] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - j][i] for j in range(N)] for i in range(N)])
maps.append([[map_2[N - 1 - j][N - 1 - i] for j in range(N)] for i in range(N)])

print(('No', 'Yes')[any(map_1 == el for el in maps)])
",quadratic,implementation,756
"def rotate_90(a):
    b=[]
    for x in range(len(a)):
        l=[]
        for y in range(len(a)-1,-1,-1):
            l.append(a[y][x])
        b.append(l)
    return b
def flip(a):
    b=[]
    for x in range(len(a)):
        l=[]
        for y in range(len(a)-1,-1,-1):
            l.append(a[x][y])
        b.append(l)
    return b
n=int(input())
l=[]
for i in range(n):
    a=input()
    l2=[]
    for i2 in a:
        l2.append(i2)
    l.append(l2)
l2=[]
for i in range(n):
    a=input()
    l3=[]
    for i2 in a:
        l3.append(i2)
    l2.append(l3)
d='no'
for i in range(4):
    l = rotate_90(l)
    if l==l2:
        d='yes'
l=flip(l)
for i in range(4):
    l = rotate_90(l)
    if l==l2:
        d='yes'
print(d)
",quadratic,implementation,728
"#def pr():
#	print()
#	for i in range(n):
#		for j in range(n):
#			print(map1[i][j], end = """")
#		print()
#	print()
#-----------------------------------------------
def check():
	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[i][j]:
				f = False
				break
	if f:
		return True
	
	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[n - 1 - i][j]:
				f = False
				break
	if f:
		return True
	
	f = True
	for i in range(n):
		for j in range(n):
			if map1[i][j] != map2[i][n - 1 - j]:
				f = False
				break
	if f:
		return True
	

def rotate():
	wk1=[]
	for i in range(n):
		wk1.append([])
		for j in range(n):
			wk1[i].append(map1[i][j])
	
	for i in range(n):
		for j in range(n):
			map1[i][j] = wk1[j][n - 1 - i]


n = int(input())
map1 = []
for i in range(n):
	st = input()
	map1.append([])
	for j in st:
		map1[i].append(j)

map2 = []
for i in range(n):
	st = input()
	map2.append([])
	for j in st:
		map2[i].append(j)


f = False
for k in range(4):
	if check():
		f = True
		break
	rotate()

if f:
	print(""Yes"")
else:
	print(""No"")
",quadratic,implementation,1093
"n = int(input())
map1 = [list(input()) for i in range(n)]
map2 = [list(input()) for i in range(n)]

def vFlip (m):
    return([list(reversed(i)) for i in m])
    
def hFlip(m):
    return(list(reversed(m)))
    
def rotate(m):
    return(list(zip(*reversed(m))))
 
def check(): 
    global map1
    for i in range(4):
        if map1 == map2:
            return(True)
        if vFlip(map1)==map2:
            return(True)
        if hFlip(map1)==map2:
            return(True)
        if vFlip(hFlip(map1))==map2:
            return(True)
        map1 = rotate(map1)
    return(False)
    
print('YES' if check() else 'NO')",quadratic,implementation,624
"import copy
lista=[]
listb=[]
temp=[]
a=int(input())
flag=0
mark=0

for i in range(0,a):
    str=input()
    for j in range(0,a):
        temp.append(str[j])
    lista.append(temp)
    temp=[]
    
for i in range(0,a):
    str=input()
    for j in range(0,a):
        temp.append(str[j])
    listb.append(temp)
    temp=[]

listacpy =copy.deepcopy(lista)
#一来就比
for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
mark=0
#转90°
for i in range(0,a):
    for j in range(0,a):
        listacpy[a-1-j][i]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1

mark = 0

#转180°
for i in range(0,a):
    for j in range(0,a):
        listacpy[a-1-i][a-1-j]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
  
mark = 0

#转270°
for i in range(0,a):
    for j in range(0,a):
        listacpy[j][a-1-i]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
mark = 0

#翻面
listtemp=copy.deepcopy(lista)
for i in range(0,a):
    for j in range(0,a):
        lista[i][j]=listtemp[i][a-1-j]


#翻面后直接比
listacpy =copy.deepcopy(lista)
for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
mark = 0
#转90°
for i in range(0,a):
    for j in range(0,a):
        listacpy[a-1-j][i]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1
mark = 0


#转180°
for i in range(0,a):
    for j in range(0,a):
        listacpy[a-1-i][a-1-j]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1

mark = 0

#转270°
for i in range(0,a):
    for j in range(0,a):
        listacpy[j][a-1-i]=lista[i][j]

for i in range(0,a):
    for j in range(0,a):
        if(listacpy[i][j]!=listb[i][j]):
            mark=1
            break
    if(mark==1):
        break
if(mark==0):
    flag=1

 
if(flag==1):
    print(""yes"")
else:
    print(""no"")",quadratic,implementation,2643
"n=int(input())
a=[]
b=[]
for i in range(n):
    a.append(input())
for i in range(n):
    b.append(input())

def h(d):
    c=[]
    for i in range(n):
        c.append(d[n-i-1])
    return c
def r(d):
    c=[]
    for i in range(n):
        temp=""""
        for j in range(n):
            temp+=d[j][n-i-1]
        c.append(temp)
    return c
yes=0
for i in range(4):
    if a==b:
        print('YES')
        yes=1
        break
    a=r(a)
if yes==0:
    a=h(a)
    for i in range(4):
        if a==b:
            print('YES')
            yes=1
            break
        a=r(a)
if yes==0:
    print('NO')
    
    ",quadratic,implementation,613
"def check(x, y):
    return ''.join([''.join(s) for s in x]) == ''.join([''.join(s) for s in y])

re = int(input())
a = [list(input()) for i in range(re)]
b = [list(input()) for i in range(re)]
for i in range(4):
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = b[::-1]
    for j in range(2):
        if check(a, b):
            print('Yes')
            exit(0)
        b = [s[::-1] for s in b]
    c = [['' for t in range(re)] for u in range(re)]
    for t in range(re):
        for u in range(re):
            c[t][u] = b[u][re - t - 1]
    b = c[:]
    if check(a, b):
        print('Yes')
        exit(0)
print('No')",quadratic,implementation,675
"def ints():
 return map(int,input().split())
n,m=ints()
c=ints()
aa=[0]*(n+1)
for cc in c:
 aa[cc]+=1
print(min(aa[1:]))
 			  			 		 		 		  		 		  	",quadratic,implementation,149
"n,m = map(int, input().split())
tL0 = list(map(int, input().split()))
tL = [0] * n
score = 0

for i in range(m):
    tL[tL0[i] - 1] += 1
    if(0 not in tL):
        score += 1
        for i in range(n):
            tL[i] = tL[i] - 1

print(score)",quadratic,implementation,247
"n,m=map(int,input().split())
c=input().split()
col=[0]*n
for i in range(len(c)):
    col[int(c[i])-1]+=1
print(min(col))",quadratic,implementation,120
"n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [0] * n
for i in a:
    b[i - 1] += 1
b.sort()
print(b[0])
",quadratic,implementation,134
"#Winners never quit, quiters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#Winners never quit, Quitters never win
n,m=map(int,input().split())
c=list(map(int,input().split()))
kk=get_frequency(c)
if len(set(c))==n:
    print(min(kk.values()))
else:
    print(0)



    
",quadratic,implementation,2081
"import collections, bisect
n, m = map(int, input().split())
arr = list(map(int, input().split()))
cs = collections.Counter(arr)
print(min(cs[x] for x in range(1, n + 1)))
",quadratic,implementation,171
"n,useless=list(map(int,input().split()))
arr=list(map(int,input().split()))
for x in range(1,n+1):
    if x not in arr:
        print(0)
        break
else:
    print(arr.count(min(arr,key=lambda x:arr.count(x))))",quadratic,implementation,213
"n, m = list(map(int, input().split()))
square = [0] * n
l = list(map(int, input().split()))
for x in l:
    square[x-1] += 1
print(min(square))
    
",quadratic,implementation,149
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,m = mi()
a = li()
size = [0 for i in range(n)]
for i in range(m):
    size[a[i]-1] += 1
print(min(size))
",quadratic,implementation,15681
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
cnt = [0]*n
c = inpl_1()
for x in c: cnt[x] += 1
print(min(cnt))",quadratic,implementation,631
"n,m=map(int,input().split())
count=[0]*n
a=list(map(int,input().split()))
for i in range(m):
    count[a[i]-1]+=1
print(min(count))",quadratic,implementation,131
"n, m = map(int, input().split())
A = list(map(int, input().split()))
L = [0]*n
for i in range(m):
    L[A[i]-1] += 1
print(min(L))",quadratic,implementation,130
"if __name__==""__main__"":
    dic={}
    n,m=map(int,input().split())
    li=list(map(int,input().split()))
    c=0
    for i in range(n):
        dic.setdefault(i+1,0)
    for i in li:
        if 0 not in dic.values():
            c=c+1
            for j in range(1,n+1):
                dic[j]=dic[j]-1

        dic[i]=dic[i]+1
    if 0 not in dic.values():
        c=c+1
    print(c)
",quadratic,implementation,386
"if __name__ == '__main__':
		n,m = map(int, input().split())
		l = list(map(int, input().split()))
		d = dict()
		if len(set(l)) < n:
			print(0)
		else:
			for i in range (m):
				d.setdefault(l[i],0)
				d[l[i]]+=1
			min1 = 999999999
			for i in d.values():
				if i < min1 :
					min1 = i
			print(min1)",quadratic,implementation,307
"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
n,m=map(int,input().split())
l=list(map(int,input().split()))
x=dc(int)
c=0
p=0
#print(l)
for i in l:
    x[i]+=1
    f=1
    for i in range(1,n+1):
        if x[i]==0:
            f=0
            break
    if f:
        p+=1
        for i in range(1,n+1):
            x[i]-=1
        
print(p)",quadratic,implementation,576
"a, b = map(int, input().split())
arr = list(map(int, input().split()))
mn = float(""inf"")
for i in range(1, a+1):
    mn = min(mn, arr.count(i))

print(mn)


",quadratic,implementation,157
"n, m = map(int, input().split())
daf1 = list(map(int, input().split()))
daf2 = dict()

for i in range(n):
    daf2[i+1] = 0

for i in daf1:
    if i in daf2.keys():
        daf2[i] += 1

print(min(daf2.values()))
",quadratic,implementation,213
"I=lambda:map(int,input().split())
n,m=I()
q={}
for i in range(1,n+1):q[i]=0
for i in I():q[i]+=1
print(min(q.values()))",quadratic,implementation,119
"import itertools

n = int(input())
a = []
for i in range(4):
    a.append([input() for _ in range(n)])
    if i < 3:
        assert input() == ''

best = 4*n*n
for p in itertools.permutations(a):
    for s in range(2):
        count = 0
        for i in range(4):
            for r in range(n):
                for c in range(n):
                    if p[i][r][c] != str((s + (i//2 + r) + (i % 2 + c)) % 2):
                        count += 1
        best = min(best, count)
print(best)
",quadratic,"bitmasks,brute force,implementation",487
"a=int(input())
l=[]
total=0
for i in range(4):
    line=''

    for x in [0]*a:
        line+=input()    
    l.append(line)
    input() if i!=3 else 0
l=sorted(l,key=lambda i: i[0::2].count('1')+i[1::2].count('0'))[::-1]
for z,v in enumerate(l):
    if z<2:
        for i in range(a**2):
            total += v[i]!='0' if i%2 else v[i]!='1'
    else:
        for i in range(a**2):
            total += v[i]!='1' if i%2 else v[i]!='0'
print(total)",quadratic,"bitmasks,brute force,implementation",447
"import bisect
import math
import itertools
import sys

# import sys.stdout.flush() use for interactive problems
alpha = 'abcdefghijklmnopqrstuvwxyz'
inf = 1e17


# Max = 10**6
# primes = []
# prime = [True for i in range(10**6+1)]
# p = 2
# while (p * p <= Max+1):
#
#     # If prime[p] is not
#     # changed, then it is a prime
#     if (prime[p] == True):
#
#         # Update all multiples of p
#         for i in range(p * p, Max+1, p):
#             prime[i] = False
#     p += 1
#
# for p in range(2, Max+1):
#     if prime[p]:
#         primes.append(p)
def calc1(grid):
    l = len(grid)
    cnt = 0
    for i in range(l):
        for j in range(l):
            if (i+j) % 2 and grid[i][j]:
                cnt += 1
            if (i+j) % 2 == 0 and grid[i][j] == 0:
                cnt += 1
    return cnt

def calc2(grid):
    l = len(grid)
    cnt = 0
    for i in range(l):
        for j in range(l):
            if (i+j) % 2 and grid[i][j] == 0:
                cnt += 1
            if (i+j) % 2 == 0 and grid[i][j]:
                cnt += 1
    return cnt
def solve(n,grids):
    one = []
    zero = []
    for grid in grids:
        one.append(calc1(grid))
        zero.append(calc2(grid))
    take = [3,5,6,9,10,12]
    answer = inf
    for mask in range(16):
        cnt = 0
        if mask not in take:
            continue
        if mask in take:
            if mask & 1:
                cnt += one[3]
                pass
            else:
                cnt += zero[3]
                pass
            if mask & 2:
                cnt += one[2]
                pass
            else:
                cnt += zero[2]
                pass
            if mask & 4:
                cnt += one[1]
                pass
            else:
                cnt += zero[1]
                pass
            if mask & 8:
                cnt += one[0]
                pass
            else:
                cnt += zero[0]
                pass
        answer = min(answer,cnt)
    return answer

t = 1#int(input())
ans = []
for _ in range(t):
    n = int(input())
    #n, u, r, d, l = map(int, input().split())
    #a,b = map(int, input().split())
    # s = input()
    # arr = list(input())
    # arr = [int(x) for x in input().split()]
    # c = [int(x) for x in input().split()]

    # b = [int(x) for x in input().split()]
    # s = input()
    # t = input()
    grids = []
    for i in range(4):
        grid = []
        for j in range(n):
            arr = list(map(int,list(input())))
            grid.append(arr)
        if i != 3:
            s = input()
        grids.append(grid)
    # options = [int(x) for x in input().split()]
    """"""ladders = []
    for j in range(l):
        ladders.append([int(x) for x in input().split()])""""""
    """"""queries = []
    for j in range(q):
        queries.append(list(map(int, input().split())))""""""
    # s = list(input())
    # start,end = map(int,input().split())

    ans.append(solve(n,grids))

for test in ans:
    print(test)",quadratic,"bitmasks,brute force,implementation",2988
"import sys

# For getting input from input.txt file 
# sys.stdin = open('input.txt', 'r')  
  
# Printing the Output to output.txt file 
# sys.stdout = open('output.txt', 'w') 
# from math import log2
try:    
    # t=int(input())

    # for _ in range(t):
    def check(n):
        count1=0
        s=""""
        while(n!=0):
            if n%2:
                count1+=1
                s=""1""+s
            else:
                s=""0""+s
            n//=2
        return s
    
    def solve(flag,n,l):
        temp_ans=0
        for i in range(n):
            y=(z[flag]^int(l[i],2) )
            b=bin(y)
            temp_ans+=b.count(""1"")
            flag=not(flag)
        # print(temp_ans)
        return temp_ans
                
    
    
    n=int(input())
    l1 = [input() for y in range(n)]
    temp=input()
    l2 = [input() for y in range(n)]
    temp=input()
    l3 = [input() for y in range(n)]
    temp=input()
    l4 = [input() for y in range(n)]
    
    z=[]
    s=0
    for i in range(n):
       if i%2==1:
           s+=(2**i)
    z.append(s)
    z.append( z[0] ^ (2**n-1) ) 
    ans=m=sys.maxsize
    for i in range(2,17):
        s=check(i)
        if s.count(""1"")==2:
            s=(4-len(s))*""0""+s
            res=sys.maxsize
            for i in range(4):
                if i==0:
                    x=l1
                elif i==1:
                    x=l2
                elif i==2:
                    x=l3
                else:
                    x=l4
                  
                if s[i]==""1"":
                    res+=min(res,solve(1,n,x))
                else:
                    res+=min(res,solve(0,n,x))
            ans=min(ans,res-m)
    print(ans)  

                
except EOFError:
    pass",quadratic,"bitmasks,brute force,implementation",1739
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n):
        self.BIT=[0]*(n+1)
        self.num=n

    def query(self,idx):
        res_sum = 0
        while idx > 0:
            res_sum += self.BIT[idx]
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        while idx <= self.num:
            self.BIT[idx] += x
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matrix[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matrix[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matrix[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]+other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matrix[i][j]-other._matrix[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matrix[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matrix[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matrix[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import log,gcd

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n = int(input())
P = permutations([i for i in range(4)])
plus = [(0,0),(0,n),(n,0),(n,n)]

A = []
for i in range(4):
    tmp = [input() for i in range(n)]
    if i!=3:
        _ = input()
    A.append(tmp)

tmp = [[0 for i in range(2*n)] for j in range(2*n)]
res = 10**17
for p in P:
    for k in range(4):
        x,y = plus[p[k]]
        for i in range(n):
            for j in range(n):
                tmp[i+x][j+y] = int(A[k][i][j])

    ans_1 = 0
    ans_2 = 0
    for i in range(2*n):
        for j in range(2*n):
            if tmp[i][j]==(i+j)%2:
                ans_1 += 1
            else:
                ans_2 += 1

    res = min(res,ans_1,ans_2)

print(res)
",quadratic,"bitmasks,brute force,implementation",16246
"n=int(input())
pieces=[]
blacks=[0]*4
whites=[0]*4
for i in range(4):
    grid=[]
    for j in range(n):
        grid.append(input())
    if i<3:
        input()
    count=0
    for j in range(n):
        for k in range(n):
            if (int(grid[j][k])+j+k)%2:
                count+=1
    blacks[i]=count
    whites[i]=n*n-count
ans=4*n*n
for white1 in range(3):
    for white2 in range(white1+1,4):
        for black1 in range(4):
            if black1==white1 or black1==white2:
                continue
            for black2 in range(black1+1,4):
                if black2==white1 or black2==white2:
                    continue
                ans=min(ans,whites[white1]+whites[white2]+blacks[black1]+blacks[black2])
print(ans)",quadratic,"bitmasks,brute force,implementation",736
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n = inp()
s = []
for _ in range(4):
    tmp = [input() for i in range(n)]
    if _<3: input()
    s.append(tmp)
res = INF
for pt in itertools.combinations(range(4),2):
    cnt = 0
    for k in range(4):
        f = 1 if k in pt else 0
        for i in range(n):
            for j in range(n):
                if (i+j+f)%2 != int(s[k][i][j]): cnt += 1
    res = min(res, cnt)
print(res)",quadratic,"bitmasks,brute force,implementation",939
"n = int(input())
s = [["""" for _ in range(n)] for __ in range(4)]
for i in range(3):
    for j in range(n):
        s[i][j] = input()
    input()
for j in range(n):
    s[3][j] = input()
res = int(1e13)
for i in range(24):
    perm = [0, 1, 2, 3]
    L = [0]*4
    tmp = i
    for j in range(4):
        L[j] = tmp % (4-j)
        tmp //= (4-j)
    LL = [0]*4
    for j in range(4):
        LL[j] = perm[L[j]]
        for k in range(L[j], 3-j):
            perm[k] = perm[k+1]
    lu, ru, ld, rd = LL[0], LL[1], LL[2], LL[3]
    Map = [s[lu][_][:]+s[ru][_][:] for _ in range(n)] + [s[ld][_][:]+s[rd][_][:] for _ in range(n)]
    cnt0, cnt1 = 0, 0
    for j in range(2*n):
        for k in range(2*n):
            if (j+k) % 2:
                if Map[j][k] == '0':
                    cnt0 += 1
                else:
                    cnt1 += 1
            else:
                if Map[j][k] == '1':
                    cnt0 += 1
                else:
                    cnt1 += 1
    res = min(res, cnt0, cnt1)
print(res)",quadratic,"bitmasks,brute force,implementation",1023
"from sys import stdin
input = stdin.readline

n = int(input())
a = []
for i in range(4):
    a.append([[int(x) for x in list(input().rstrip())] for _ in range(n)])
    if i < 3: input()
b = []
for i in range(4):
    b.append([])
    for j in range(2):
        c = 0
        for y in range(n):
            for x in range(n):
                if j == 1:   
                    z = (x + y) % 2
                else:
                    z = 1 - (x + y) % 2
                c += a[i][y][x] != z
        b[-1].append(c)
ans = float(""inf"")
for i in (3, 5, 6, 9, 10, 12):
    ans = min(ans, b[0][i & 1] + b[1][i >> 1 & 1] + b[2][i >> 2 & 1] + b[3][i >> 3 & 1])
print(ans)",quadratic,"bitmasks,brute force,implementation",662
"# link: https://codeforces.com/problemset/problem/961/C

import os, sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
from math import ceil
mod = 10 ** 9 + 7 

def get_original_pieces(x):
    common = (pow(x, 2) - 1) // 2
    first_piece = ""10""*common + '1'
    second_piece = '0' + ""10""*common
    return [first_piece, second_piece]

# number of test cases
for _ in range(1):
    n = int(input())
    pieces = ["""" for _ in range(4)]
    original_pieces = get_original_pieces(n)
    i = 0
    for _ in range(3 + (n*4)):
        s = input()
        if s:
            pieces[i] += s
        else:
            i += 1   
    #print(pieces) 
    till = pow(n, 2)
    fp = [[0,i] for i in range(4)]
    sp = [[0,i] for i in range(4)]
    for i in range(4):
        fpc, spc = 0, 0
        for j in range(till):
            if pieces[i][j] != original_pieces[0][j]:
                fpc += 1
            if pieces[i][j] != original_pieces[1][j]:
                spc += 1
        fp[i][0] = fpc
        sp[i][0] = spc
    fp.sort()
    sp.sort()
    ans1 = fp[0][0] + fp[1][0]
    ans2 = sp[0][0] + sp[1][0]
    for i in range(4):
        if sp[i][1] not in [fp[0][1], fp[1][1]]: ans1 += sp[i][0]
        if fp[i][1] not in [sp[0][1], sp[1][1]]: ans2 += fp[i][0]
    ans = min(ans1, ans2)
    print(ans)                            ",quadratic,"bitmasks,brute force,implementation",2970
"from itertools import permutations

n = int(input())
a = []
for i in range(4):
    a.append([list(map(int, list(input()))) for j in range(n)])
    if i < 3:
        input()

ans = 10 ** 10
for i in permutations(a, 4):
    cnt = 0
    total = 0
    for j in i:
        if cnt < 2:
            cnt2 = 0
            for p in j:
                for q in p:
                    if q != cnt2 % 2:
                        total += 1
                    cnt2 += 1
        else:
            cnt2 = 1
            for p in j:
                for q in p:
                    if q != cnt2 % 2:
                        total += 1
                    cnt2 += 1
        cnt += 1

    ans = min(ans, total)

print(ans)",quadratic,"bitmasks,brute force,implementation",701
"import itertools

n = int(input())
boards = []
for i in range(4):
    boards.append([])
    for j in range(n):
        boards[-1].append(list(map(int, list(input()))))
    if i < 3: input()

ans = n * n * 4


def check_board(corner, board):
    ans = 0
    for i in range(n):
        for j in range(n):
            if board[i][j] != corner:
                ans += 1
            corner = 1 - corner
    return ans


def solve(corner, p):
    ans = check_board(corner, boards[p[0]])
    ans += check_board(1- corner, boards[p[1]])
    ans += check_board(1 - corner, boards[p[2]])
    ans += check_board(corner, boards[p[3]])

    return ans


for p in itertools.permutations(range(4), 4):
    ans = min(ans, solve(1, p))
    ans = min(ans, solve(0, p))

print(ans)",quadratic,"bitmasks,brute force,implementation",762
"# _
#####################################################################################################################

def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*-(-nSquares//2)

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)


def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [(sum(1 for i in range(nSquares) if piece[i] != squares[:-1][i]),
                          sum(1 for i in range(nSquares) if piece[i] != squares[1:][i]))
                         for piece in brokenPieces]
    possible_nSquares.sort(key=lambda x: x[0])

    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]


if __name__ == '__main__':
    print(main())
    # main()
",quadratic,"bitmasks,brute force,implementation",1173
"# _
#####################################################################################################################

def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*-(-nSquares//2)

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)


def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [(sum(piece[i] != squares[:-1][i] for i in range(nSquares)),
                          sum(piece[i] != squares[1:][i] for i in range(nSquares)))
                         for piece in brokenPieces]
    possible_nSquares.sort(key=lambda x: x[0])

    return possible_nSquares[0][0] + possible_nSquares[1][0] + possible_nSquares[2][1] + possible_nSquares[3][1]


if __name__ == '__main__':
    print(main())
    # main()
",quadratic,"bitmasks,brute force,implementation",1163
"# _
#####################################################################################################################

def main():
    pieces_Dimension = int(input())
    piece1 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece2 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece3 = ''.join(input() for _ in range(pieces_Dimension))
    input()
    piece4 = ''.join(input() for _ in range(pieces_Dimension))

    brokenPieces = (piece1, piece2, piece3, piece4)
    nSquares = pieces_Dimension*pieces_Dimension
    squares = '01'*(nSquares//2) + '0'

    return nSquaresToRecolorIn(brokenPieces, nSquares, squares)


def nSquaresToRecolorIn(brokenPieces, nSquares, squares):
    possible_nSquares = [sum(piece[i] != squares[i] for i in range(nSquares)) for piece in brokenPieces]
    possible_nSquares.sort()

    return 2*nSquares + possible_nSquares[0] + possible_nSquares[1] - possible_nSquares[2] - possible_nSquares[3]


if __name__ == '__main__':
    print(main())
    # main()
",quadratic,"bitmasks,brute force,implementation",1034
"n=int(input())
c=[0]*4
for k in range(4):
 for i in range(n):
  s=input()
  for j in range(n):
   if(i+j)%2!=int(s[j]):c[k]+=1
 if k<3:input()
c.sort()
print(c[0]+c[1]+2*n*n-c[2]-c[3])
",quadratic,"bitmasks,brute force,implementation",185
"n = int(input())

parts = []
for i in range(4):
    part = []
    for _i in range(n):
        part.append([int(x) for x in input()])
    parts.append(part)

    if i < 3:input()

processed_parts = []
for part in parts:
    dt1 = 0
    exp = 1

    for h in range(n):
        for w in range(n):
            if part[h][w] != exp:
                dt1 += 1
            exp = (exp+1) % 2

    dt2 = 0
    for h in range(n):
        for w in range(n):
            if part[h][w] != exp:
                dt2 += 1
            exp = (exp+1) % 2

    processed_parts.append([dt1, dt2])

ans = n*n*4

for i in range(3):
    for j in range(i+1, 4):
        a = 0
        for k, part in enumerate(processed_parts):
            if k == i or k == j:
                a += part[0]
            else:
                a += part[1]
        ans = min(ans, a)

print(ans)",quadratic,"bitmasks,brute force,implementation",847
"import heapq


def doxor(a, b):
    cnt = 0
    for i in range(len(a)):
        for j in range(len(a[0])):
            cnt += a[i][j] ^ b[i][j]
    return cnt


n = int(input())

a, b = [], []
for i in range(n):
    ai, bi = [], []
    for j in range(n):
        if i % 2 == 0:
            ai.append(j % 2)
            bi.append((j % 2) ^ 1)
        else:
            ai.append((j % 2) ^ 1)
            bi.append(j % 2)
    a.append(ai)
    b.append(bi)

board = []
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])
input()
board.append([list(map(int, list(input()))) for _ in range(n)])

a_cnts = []
b_cnts = []
for b0 in board:
    heapq.heappush(a_cnts, doxor(b0, a))
    heapq.heappush(b_cnts, doxor(b0, b))

print(heapq.heappop(a_cnts) + heapq.heappop(a_cnts) +
      heapq.heappop(b_cnts) + heapq.heappop(b_cnts))
",quadratic,"bitmasks,brute force,implementation",978
"n = int(input())

lst1 = []
for x in range(n):
    lst1.append(input().split())
    
s = input()

lst2 = []
for x in range(n):
    lst2.append(input().split())

s = input()

lst3 = []
for x in range(n):
    lst3.append(input().split())

s = input()

lst4 = []
for x in range(n):
    lst4.append(input().split())

ans_b1 = 0
ans_w1 = 0
for x in range(n):
    for y in range(n):
        if (x + y) & 1 == 0:
            if lst1[x][0][y] == '0':
                ans_b1 += 1
            else:
                ans_w1 += 1
        else:
            if lst1[x][0][y] == '1':
                ans_b1 += 1
            else:
                ans_w1 += 1

ans_b2 = 0
ans_w2 = 0
for x in range(n):
    for y in range(n):
        if (x + y) & 1 == 0:
            if lst2[x][0][y] == '0':
                ans_b2 += 1
            else:
                ans_w2 += 1
        else:
            if lst2[x][0][y] == '1':
                ans_b2 += 1
            else:
                ans_w2 += 1

ans_b3 = 0
ans_w3 = 0
for x in range(n):
    for y in range(n):
        if (x + y) & 1 == 0:
            if lst3[x][0][y] == '0':
                ans_b3 += 1
            else:
                ans_w3 += 1
        else:
            if lst3[x][0][y] == '1':
                ans_b3 += 1
            else:
                ans_w3 += 1

ans_b4 = 0
ans_w4 = 0
for x in range(n):
    for y in range(n):
        if (x + y) & 1 == 0:
            if lst4[x][0][y] == '0':
                ans_b4 += 1
            else:
                ans_w4 += 1
        else:
            if lst4[x][0][y] == '1':
                ans_b4 += 1
            else:
                ans_w4 += 1

print((2 * n) ** 2 - max(ans_b1 + ans_b2 + ans_w3 + ans_w4, ans_b1 + ans_w2 + ans_b3 + ans_w4, ans_b1 + ans_w2 + ans_w3 + ans_b4, ans_w1 + ans_b2 + ans_b3 + ans_w4, ans_w1 + ans_b2 + ans_w3 + ans_b4, ans_w1 + ans_w2 + ans_b3 + ans_b4))
",quadratic,"bitmasks,brute force,implementation",1869
"n = int(input())
chess = []
for w in range(3):
    chess.append([input() for i in range(n)])
    input()
chess.append([input() for i in range(n)])

issue = {0:0, 1:0, 2:0, 3:0}
reversed_issue = {0:0, 1:0, 3:0}

for w in range(4):
    chessdesk = [chess[0] + chess[3]] + [chess[1] + chess[2]]
    for s in range(2 * n):
        chessdesk[0][s] += chessdesk[1][s]
    chessdesk.pop(1)
    chessdesk = chessdesk[0]
    colour = chessdesk[0][0]

    for i in range(2 * n):
        for j in range(2 * n):
            if (i + j) % 2 == 0:
                if chessdesk[i][j] != colour:
                    issue[w] += 1
            else:
                if chessdesk[i][j] == colour:
                    issue[w] += 1

    reversed_issue[w] = 4 * n**2 - issue[w]              
    if w == 0:
        chess[0], chess[3] = chess[3], chess[0]
    elif w == 1:
        chess[1], chess[3] = chess[3], chess[1]
    elif w == 2:
        chess[1], chess[2] = chess[2], chess[1]

print(min(min(issue.values()), min(reversed_issue.values())))",quadratic,"bitmasks,brute force,implementation",1025
"from itertools import permutations as p
rd = lambda: map(int, input())
def f(n, t):
    a = 0
    f = 1
    for i in range(n):
        for x in rd():
            if x != f:
                a += 1
            f = 1 - f
    if t < 3:
        rd()
    return a
n = int(input())
m = []
b = [-1, -1, 1, 1]
for i in range(4):
    m.append(f(n, i))
print(2 * n ** 2 + min(sum(x * y for x, y in zip(q, m)) for q in set(p(b))))
",quadratic,"bitmasks,brute force,implementation",419
"rd = lambda: map(int, input())
def f(n, t):
    a = sum(i + j & 1 == x for i in range(n) for j, x in enumerate(rd()))
    if t < 3:
        rd()
    return a
n = int(input())
m = sorted([f(n, i) for i in range(4)])
print(2 * n * n + m[0] + m[1] - m[2] - m[3])
",quadratic,"bitmasks,brute force,implementation",260
"import atexit
import io
import sys

# Buffering IO
_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
    

def main():
    n = int(input())
    s = []
    for i in range(4):
        df = 0
        for k in range(n):
            l = input()
            for j in range(n):
                if int(l[j]) == (k + j) % 2:
                    df += 1
        if i <3 :
            input()
        s.append(df)
    
    print( min(s[0] + s[1] + n*n-s[2] + n*n-s[3],
        s[0] + s[2] + n*n-s[1] + n*n-s[3],
        s[0] + s[3] + n*n-s[1] + n*n-s[2],
        s[1] + s[2] + n*n-s[0] + n*n-s[3],
        s[1] + s[3] + n*n-s[0] + n*n-s[2],
        s[2] + s[3] + n*n-s[0] + n*n-s[1]))
        
        
    
    
    

    
if __name__ == '__main__':
    main()
        ",quadratic,"bitmasks,brute force,implementation",932
"import sys,os,io
from sys import stdin
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_left , bisect_right
import math 


alphabets = list('abcdefghijklmnopqrstuvwxyz')


def isPrime(x):
    for i in range(2,x):
        if i*i>x:
            break
        if (x%i==0):
            return False
    return True
def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 
def SieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def si():
    return input()
def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
def power_set(L):

    cardinality=len(L)
    n=2 ** cardinality
    powerset = []
    
    for i in range(n):
        a=bin(i)[2:]
        subset=[]
        for j in range(len(a)):
            if a[-j-1]=='1':
                subset.append(L[j])
        powerset.append(subset)
    powerset_orderred=[]
    for k in range(cardinality+1):
        for w in powerset:
            if len(w)==k:
                powerset_orderred.append(w)
        
    return powerset_orderred
def fastPlrintNextLines(a):
    # 12
    # 3
    # 1
    #like this
    #a is list of strings
    print('\n'.join(map(str,a)))

def sortByFirstAndSecond(A):
    A = sorted(A,key = lambda x:x[0])
    A = sorted(A,key = lambda x:x[1])
    return list(A)

#__________________________TEMPLATE__________________OVER_______________________________________________________


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"") ; sys.stdout = open(""output.txt"",""w"") 
else:
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline


def solve():
    n,k = li()
    p = li()
    groups = [-1]*256
    newar = [-1]*n
    for i in range(n):
        # print(groups[:15])
        color  = p[i]
        j = color
        # print(color)
        if groups[color]!=-1:
            newar[i]=groups[color]
            continue

        while(j>0) :
            if groups[j]!=-1:
                break
            if color-j+1==k:
                break
            j-=1

        # print(""color,j"",color,j)
        if groups[j]==-1:
            for h in range(j,color+1):
                groups[h]=j 
            newar[i]=groups[color]
            continue
        if color-j<k:
            alreadySize = j-groups[j]+1
            # print(""alreadySize"",alreadySize)
            if alreadySize+color-j<=k:
                for h in range(j+1,color+1):
                    groups[h]=groups[h-1]
                newar[i]=groups[color]
                continue
            else:
                for h in range(j+1,color+1):
                    groups[h]=j+1 
                newar[i]=groups[color]
                continue
        else:
            for h in range(j+1,color+1):
                groups[h]=j+1 
            newar[i]=groups[color]
            continue
    print(*newar)




            





t = 1
# t = int(input())
for _ in range(t):
    solve()
    
",quadratic,"games,greedy",4203
"def solution(n, k, arr):
    ret = []
    grp = [None for _ in range(256)]
    for i in arr:
        if grp[i]:
            continue
        l = None
        j = 1
        for j in range(1, k):
            if i - j < 0:
                break
            if grp[i - j] is not None:
                l = i - j
                break
        if l is not None and grp[l] > i - k:
            grp[i] = grp[l]
        else:
            ll = l + 1 if l else max(0, i - k + 1)
            for j in range(ll, i + 1):
                grp[j] = ll
    for i in arr:
        ret.append(grp[i])
    return ret


n, k = map(int, input().split())
arr = list(map(int, input().split()))
print(' '.join(map(str, solution(n, k, arr))))
",quadratic,"games,greedy",714
"n,k=map(int,input().split())
arr=list(map(int,input().split()))
par=[i for i in range(260)]
path=[-1 for i in range(260)]
for i in range(n):
    j=arr[i]
    if path[j] >=0:
        par[j] =par[path[j]]
        continue
    jump=1
    while j>0 and path[j] ==-1 and jump <k:
        path[j] =arr[i]
        j-=1
        jump +=1
    if arr[i] -par[j] +1 <=k:
            par[arr[i]] =par[j]
            path[j] =arr[i]
    else:
        par[arr[i]] =par[j+1]
for i in range(n):
    print(par[arr[i]],end=' ')
print()",quadratic,"games,greedy",516
"def getIntList():
    return list(map(int, input().split()));
n, k = getIntList();
p=getIntList();
choosed=[False]*256;
left=[i for i in range(256)];
for i, x in enumerate(p):
    if not choosed[x]:
        best=x;
        #print(x-1, max(-1, x-k));
        for j in range(x-1, max(-1, x-k), -1):
            #print('try ',j)
            if not choosed[j]:
                best=j;
            else:
                if x-left[j]<k:
                    best=left[j];
                break;
        #print('best=',best)
        for j in range(best, x+1):
            choosed[j]=True;
            left[j]=best;
    p[i]=left[x];
print(' '.join(map(str, p)));",quadratic,"games,greedy",654
"n, k = [int(x) for x in input().split()]

ps = [int(x) for x in input().split()]

mapping = [-1 for _ in range(256)]

res = []
for p in ps:
    if mapping[p] == -1:
        j = p - k + 1
        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):
            j += 1
        for i in range(j, p+1):
            mapping[i] = j
    
    res.append(mapping[p])
print("" "".join(map(str, res)))
",quadratic,"games,greedy",395
"n, k = map(int, input().split())
P = map(int, input().split())

parent = list(range(256))
sz = [1] * 256
def rt(x):
    if x != parent[x]:
        parent[x] = rt(parent[x])
    return parent[x]

def u(rx, ry):
    parent[ry] = rx
    sz[rx] += sz[ry]

ans = [0] * n
for i, p in enumerate(P):
    rx = rt(p)
    while rx > 0 and sz[rx] + sz[rt(rx - 1)] <= k:        
        u(rt(rx - 1), rx)
        rx = rt(p)
    ans[i] = rt(p)
print(' '.join(map(str, ans)))
",quadratic,"games,greedy",461
"import atexit
import io
import sys

# Buffering IO
_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
    

def main():
    n, k = [int(x) for x in input().split()]
    p = [int(x) for x in input().split()]
    t = []
    g={}
    for x in p:
        if x in g:
            t.append(g[x])
            continue
        kk = x - 1
        while True:
            if kk in g:
                if x - g[kk] < k:
                    ttt = g[kk]
                else:
                    ttt= kk + 1
                for i in range(kk +1 , x + 1):
                    g[i] = ttt
                t.append(g[x])
                break
            elif kk<0 or x - kk == k:
                for i in range(kk +1 , x + 1):
                    g[i] = kk + 1
                t.append(g[x])
                break
            kk -= 1
            
    print(' '.join((str(x) for x in t)))
            
    
if __name__ == '__main__':
    main()
        ",quadratic,"games,greedy",1106
"
def solve():
    num_pixels, max_group_size = (int(x) for x in input().split())
    pixels = [int(x) for x in input().split()]
    groups = [None for _ in range(256)]

    for pixel in pixels:
        if groups[pixel] is None:
            smallest_of_group = pixel
            while smallest_of_group >= 0 and smallest_of_group > pixel - max_group_size and groups[smallest_of_group] is None:
                smallest_of_group -= 1

            if smallest_of_group >= 0 and groups[smallest_of_group] is not None and pixel - groups[smallest_of_group] + 1 <= max_group_size:
                group_color = groups[smallest_of_group]
            else:
                group_color = smallest_of_group + 1
            smallest_of_group += 1
            for color in range(smallest_of_group, pixel + 1):
                groups[color] = group_color

    print(*(groups[pixel] for pixel in pixels))

solve()
",quadratic,"games,greedy",899
"def main():
    n, k = map(int, input().split())
    p = list(map(int, input().split()))
    solve(n, k, p)

def solve(n, k, p):
    group = 256 * [None]
    r = p[:]
    for i, pi in enumerate(p):
#        print([(i, gi) for i, gi in enumerate(group)if gi is not None])
        if group[pi] is not None:
            r[i] = group[pi][0]
        else:
            lo = pi
            while lo >= 0 and pi - lo < k and group[lo] is None:
                lo -= 1
            if lo < 0 or pi - lo == k:
                lo += 1
                hi = pi + 1
            else: # group[lo] is not None
                if pi - group[lo][0] < k:
                    lo = group[lo][0]
                    hi = pi + 1
                else:
                    lo += 1
                    hi = pi + 1
            lohi = (lo, hi)
            for j in range(lo, hi):
                group[j] = lohi
            r[i] = group[pi][0]
    print("" "".join(map(str, r)))

main()
",quadratic,"games,greedy",956
"n,k=map(int,input().split())
p=list(map(int,input().split()))

arr=[[] for i in range(256)]
ans=[]
for i in p:
    j=i
    if len(arr[i])==0:
        c=0
        while c<k and j>=0:
            if len(arr[j])+c>k:
                break
            #temp=len(arr[j])
            if len(arr[j])!=0:
                arr[i].extend(arr[j])
                break
            arr[j]=arr[i]
            arr[j].append(j)
            j-=1
            c+=1
        arr[i].sort()
    ans.append(arr[i][0])
print(*ans)
#print(arr)
",quadratic,"games,greedy",518
"n,k = [int(s) for s in input().split()]
p = [int(s) for s in input().split()]

map = {}
res = []

for pi in p:
    if map.get(pi) is None:
        key = pi
        for j in range(pi, pi-k, -1):
            if j < 0: break
            if map.get(j) is None:
                key = j
            else:
                if map[j] >= pi-k+1: key = map[j]
                break
        for j in range(pi, key-1, -1):
            if map.get(j):
                break
            map[j] = key
    res.append(map[pi])

print(*res, sep="" "")
",quadratic,"games,greedy",530
"N, K = input().split()
N, K = int(N), int(K)
P = [int(x) for x in input().split()]
A = [None]*256
A[0] = 0
for i in range(N):
    pn = P[i]
    if A[pn] is None:
        for j in range(K-1, -1, -1):
            if pn < j: continue
            if A[pn-j] is None:
                A[pn-j] = pn-j
                break
            else:
                if A[pn-j] + K - 1 >= pn:
                    break
        for jj in range(j, -1, -1):
            A[pn-jj] = A[pn-j]
print(*[A[P[i]] for i in range(N)])
",quadratic,"games,greedy",505
"n, k = [int(i) for i in input().split()]
p = [int(i) for i in input().split()]
ans = [-1] * (max(p) + 1)
ans[0] = 0
for i in range(n):
	if ans[p[i]] < 0:
		position = p[i] - k + 1
		for j in range(max(0,p[i] - k + 1), p[i] + 1):
			if ans[j] < 0:
				position = j
				break
		j = max(0, position - 1)
		key = ans[j]
		count = 0
		while j >= 0:
			if ans[j] != key:
				position1 = j + 1
				break
			j -= 1
			count += 1
		if count + p[i] + 1 - position > k:
			key = position
		for j in range(position, p[i] + 1):
			ans[j] = key

for i in range(n):
	if i != len(p) - 1:
		wk1 = "" ""
	else:
		wk1 = ""\n""
	print(ans[p[i]], end = wk1)
",quadratic,"games,greedy",633
"n,k = map(int,input().split())
l = [int(x) for x in input().split()]
maps = []
for _ in range(256):
	maps.append(['empty',0])
output = []
for innum in l:
	if maps[innum][0] == 'chosen':
		outnum = maps[innum][1]
	elif maps[innum][0] == 'potential':
		outnum = maps[innum][1]
		i = innum
		while i >= 0 and maps[i][0] == 'potential':
			maps[i] = ['chosen',outnum]
			i -= 1
	else:
		i = innum
		while i >= 0 and i >= innum - (k-1) and maps[i][0] != 'chosen':
			i -= 1
		i += 1
		outnum = i
		for j in range(outnum,innum+1):
			maps[j] = ['chosen',outnum]
		if innum < 255:
			for j in range(innum+1,min(256,outnum+k)):
				if maps[j][0] != 'chosen':
					maps[j] = ['potential',outnum]
	output.append(str(outnum))
print(' '.join(output))
",quadratic,"games,greedy",739
"n, k = map(int, input().split())
ps = list(map(int, input().split()))
if k == 1:
    print(' '.join([str(i) for i in ps]))
    exit()

g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(1, k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",quadratic,"games,greedy",842
"n, k = map(int, input().split())
ps = list(map(int, input().split()))


g = [None for i in range(256)]
f = [None for i in range(256)]
ans = []
for i in range(n):
    p = ps[i]
    if g[p] is not None:
        ans.append(g[p])
        f[p] = 1
    else:
        gb= 0
        for j in range(k):
            ind = p - j
            if f[ind] is not None:
                gb = ind +1
                break
            if ind <= 0:
                break
            if j == k-1:
                gb = ind
        ans.append(gb)
        for j in range(k):
            if gb+j >= 256:
                break
            if f[gb + j] is None:
                g[gb+j] = gb
            else:
                break
        f[gb] = 1
        f[p] = 1
print(' '.join([str(i) for i in ans]))",quadratic,"games,greedy",776
"n, k = map(int, input().strip().split())
data = map(int, input().strip().split())
sol = []
mapping = [(-1,1000)]*256
for x in data:
    if mapping[x][0] == -1:
        for i in range(max(x-k+1,0), x+1):
            if mapping[i][0] == -1:
                if i > 0 and mapping[i-1][1]+(x-i+1) <= k:
                    p = mapping[i-1][1]+1
                    for j in range(i, x+1):
                        mapping[j] = (mapping[i-1][0], p)
                        p += 1
                else:                    
                    p = 1
                    for j in range(i, x+1):
                        mapping[j] = (i, p)
                        p += 1
                break
    sol.append(mapping[x][0])
print(' '.join(map(str, sol)))",quadratic,"games,greedy",742
"import sys

n, k = map(int, next(sys.stdin).rstrip().split())

xs = list(map(int, next(sys.stdin).rstrip().split()))

mapka = {}
lengths = {}

result = []

for x in xs:
    
    if x in mapka:
        result.append(mapka[x])
    else:
        left = max(0, x - k + 1)
        range_potential = x - left
        for i in range(range_potential, -1, -1):
            potential_left = x - i
            if potential_left not in mapka:
                result.append(potential_left)
                for y in range(potential_left, x + 1):
                    mapka[y] = potential_left

                lengths[potential_left] = x - potential_left + 1

                break
            else:

                if lengths[mapka[potential_left]] + (x - potential_left) <= k:
                    result.append(mapka[potential_left])
                    for y in range(mapka[potential_left] + lengths[mapka[potential_left]], x + 1):
                        mapka[y] = mapka[potential_left]
                        lengths[mapka[potential_left]] += 1

                    break
            
print(' '.join(map(str, result)))
",quadratic,"games,greedy",1112
"a = [0 for i in range(0, 256)]
n,k = input().split(' ')
k = int(k)
for c in input().split(' '):
        c = int(c)
        if a[c] != 0:
            print(a[c]-1, end=' ')
        else:
            for x in range(c, c-k, -1):
                if a[x] == 0:
                    i = x
                else:
                    if c-a[x]+1<k:
                        i = a[x]-1
                    break
                if x == 0:
                    break
            for x in range(int(i), c+1):
                a[x] = i + 1
            print(i, end=' ')
",quadratic,"games,greedy",553
"n, k = [int(x) for x in input().split()]
ps = [int(x) for x in input().split()]
mapping = [-1 for _ in range(256)]

res = []
for p in ps:
    if mapping[p] == -1:
        j = p - k + 1
        while j < 0 or (mapping[j] != -1 and mapping[j] + k <= p):
            j += 1
        for i in range(j, p+1):
            mapping[i] = j
    res.append(mapping[p])
print("" "".join(map(str, res)))",quadratic,"games,greedy",387
"def main():
	n, k = [int(_) for _ in input().split()]
	a = [int(_) for _ in input().split()]

	p = [-1] * 256
	p[0] = 0

	for x in a:
		if p[x] < 0:
			for y in range(x - 1, max(-1, x - k), -1):
				if p[y] >= 0:
					if p[y] + k > x:
						p[x] = p[y]
					else:
						p[x] = p[y + 1] = y + 1

					break
			if p[x] < 0:
				p[x] = p[x - k + 1] = x - k + 1

	b = [p[x] for x in a]

	print(' '.join(map(str, b)))

if __name__ == '__main__':
	main()",quadratic,"games,greedy",448
"n,k=[int(x)for x in input().split()]
ns=[int(x) for x in input().split()]
done=[None]*256
ans=[None]*n
for i in range(n):
    c=ns[i]
    if done[c]==None:
        j=c
        while True:
            if j<0 or c-j>=k or (done[j]!=None and done[j]!=-1):
                break
            j-=1
        j+=1
        for kk in range(k):
            if kk+j>=256 or (done[kk+j]!=None and done[kk+j]!=-1):
                break
            if kk+j<=c:
                done[kk+j]=j
            else:
                done[kk+j]=-1
    elif done[c]==-1:
        j=c
        while True:
            if done[j]!=None and done[j]!=-1:
                break
            j-=1
        a=done[j]
        for kk in range(j,c+1):
            done[kk]=a
    else:
        pass
    ans[i]=done[c]
    # print(ans[i])
    # print(done)
    # if ans[i]==146:
    #     print(ans[i])
    #     print(done)
    #     input()
ans=[str(x)for x in ans]
print(' '.join(ans))



",quadratic,"games,greedy",950
"n,k=map(int,input().split())

ar=[-1 for i in range(256)]
ls=list(map(int,input().split()))

for e in ls:
    if ar[e]==-1:
        tmp=max(0,e-k+1)
        for i in range(tmp,e+1):
            if ar[i]!=-1 and ar[i]!=i:
                tmp+=1
                continue
            else:
                while i<=e:
                    ar[i]=tmp
                    i+=1
    print(ar[e],end="" "")
",quadratic,"games,greedy",395
"n, k = map(int, input().split())
a = list(map(int, input().split()))
c = [-1]*256

ans = [0]*n
for i in range(n):
    if c[a[i]] == -1:
        for j in range(a[i], max(-1, a[i]-k), -1):
            if c[j] != -1:
                if (c[j] +k) > a[i]:
                    c[a[i]] = c[j]
                else:
                    c[a[i]] = j+1
                break
        if c[a[i]] == -1:
            c[a[i]] = max(0, a[i]-k+1)
        for xx in range(c[a[i]], a[i]):
            c[xx] = c[a[i]]
    ans[i] = str(c[a[i]])

print(' '.join(ans))
",quadratic,"games,greedy",545
"n, k = list(map(int, input().split()))
p = list(map(int, input().split()))
processed = set()
color = {}
length = {}
ans = []

def exists(p, elt, d):
    for e in p:
        if e > elt:
            if e <= elt + d:
                return True
            elif e - d <= elt + d:
                return False
    return False

def exists2(p, elt, d):
    for e in p:
        if e > elt:
            if e <= elt + d:
                return False
            elif e - d <= elt + d:
                return [True, e - d]
    return False
        

for i in range(n):
    elt = p[i]
    if elt in processed:
        ans.append(color[elt])
    else:
        processed.add(elt)
        new = 1
        run = True
        for j in range(1, k):
            if elt - j < 0:
                break
            elif (elt - j) not in processed:
                processed.add(elt - j)
                new += 1
            elif length[elt - j] + new <= k:
                for i2 in range(length[elt - j] + new):
                    color[elt - i2] = color[elt - j]
                length[elt] = length[elt - j] + new
                run = False
                break
            else:
                break
        if run:
            for j in range(new):
                color[elt - j] = elt - new + 1
            length[elt] = new
s = str(color[p[0]])
for elt in p[1:]:
    s += ' ' + str(color[elt])
print(s)

",quadratic,"games,greedy",1394
"import sys
import math
input = sys.stdin.readline
from functools import cmp_to_key;

def pi():
    return(int(input()))
def pl():
    return(int(input(), 16))
def ti():
    return(list(map(int,input().split())))
def ts():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
mod = 998244353;
f = [];
def fact(n,m):
    global f;
    f = [1 for i in range(n+1)];
    f[0] = 1;
    for i in range(1,n+1):
        f[i] = (f[i-1]*i)%m;

def fast_mod_exp(a,b,m):
    res = 1;
    while b > 0:
        if b & 1:
            res = (res*a)%m;
        a = (a*a)%m;
        b = b >> 1;
    return res;

def inverseMod(n,m):
    return fast_mod_exp(n,m-2,m);

def ncr(n,r,m):
    if r == 0: return 1;
    return ((f[n]*inverseMod(f[n-r],m))%m*inverseMod(f[r],m))%m;

def main():
    B();

dp = [];
def D():
    [n,k] = ti();
    a = ti();
    a = sorted(a);
    cnt = [0 for i in range(n)];
    for i in range(n):
        c = 0;
        for j in range(i,n):
            if a[j]-a[i] <= 5: c+=1;
            else:break;
        cnt[i] = c;
     
    global dp;
    dp = [[0 for j in range(k+1)] for i in range(n+1)];
    ans = 0;
    for i in range(n):
        for j in range(k+1):
            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            if j+1 <= k:
                dp[i+cnt[i]][j+1] = max(dp[i+cnt[i]][j+1], dp[i][j]+cnt[i]);
    print(dp[n][k]);

def B():
    n = pi();
    a = ti();
    q = pi();

    mat = [[0 for j in range(n)] for i in range(n)];
    dp = [[0 for i in range(n)] for j in range(n)];
    for i in range(n):
        for j in range(n):
            if i == j:
                mat[i][j] = a[i];
                dp[i][j] = a[i];
    i = 0;
    x = 1;
    while x < n:
        j = x;
        i = 0;
        while j < n:
            mat[i][j] = mat[i][j-1] ^ mat[i+1][j];
            j += 1;
            i += 1;
        x += 1;
    
    i = 0;
    x = 1;
    while x < n:
        j = x;
        i = 0;
        while j < n:
            dp[i][j] = max(mat[i][j], dp[i][j-1], dp[i+1][j]);
            j += 1;
            i += 1;
        x += 1;
        
    for i in range(q):
        [l,r] = ti();
        print(dp[l-1][r-1]);

            


main();",quadratic,dp,2205
"n = int(input())
values = list(map(int, input().split()))
queries = int(input())

dp = [[0] * 5009 for i in range(5009)]

for i in range(n):
    dp[0][i] = values[i]

for i in range(1, n): # 0 is already populated
    for j in range(n-i+1):
        top = dp[i-1][j]
        right = dp[i-1][j+1]
        dp[i][j] = top ^ right

for i in range(1, n):
    for j in range(n-i+1):
        top = dp[i-1][j]
        right = dp[i-1][j+1]
        dp[i][j] = max(right, max(dp[i][j], top))

for i in range(queries):
    left, right = map(int, input().split())
    last_row = (right - 1) - (left - 1)
    last_column = (left - 1)
    print(dp[last_row][last_column])
    


",quadratic,dp,663
"import sys
input=sys.stdin.buffer.readline

n=int(input())
a=list(map(int,input().split()))
dp=[[0]*(n) for i in range(n)]
for i in range(n):
    dp[i][i]=a[i]
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=dp[j][j+count-1]^dp[j+1][j+count]
    count+=1
count=1
for i in range(n-1):
    for j in range(n-i-1):
        dp[j][j+count]=max(dp[j][j+count],dp[j][j+count-1],dp[j+1][j+count])
    count+=1
for i in range(int(input())):
    l,r=map(int,input().split())
    l-=1
    r-=1
    print(dp[l][r])",quadratic,dp,532
"import sys

n = int(sys.stdin.readline())
a = list(map(int, sys.stdin.readline().split(' ')))
Array = [a]
 
for i in range(n - 1):
    aux = []
    for j in range(1, len(Array[-1])):
        aux.append(Array[-1][j-1] ^ Array[-1][j])
    Array.append(aux)
 
for j in range(1, len(Array)):
    for k in range(len(Array[j])):
        Array[j][k] = max(Array[j][k], Array[j-1][k], Array[j - 1][k + 1])
 
q = int(sys.stdin.readline())
for i in range(q):
    l, r = map(int, sys.stdin.readline().split(' '))
    sys.stdout.write(str(Array[r - l][l - 1]) + '\n')
 					 	 			  		  			 		  	  	",quadratic,dp,586
"def main():
    n = int(input())
    a = list(map(int, input().split(' ')))
    array = []
    array.append(a)
    
    for i in range(n - 1):
        aux = []
        for j in range(1, len(array[-1])):
            xor = array[-1][j-1] ^ array[-1][j]
            aux.append(xor)
        array.append(aux)
    
    for j in range(1, len(array)):
        for k in range(len(array[j])):
            maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1])
            array[j][k] = maximo
    
    q = int(input())
    for i in range(q):
        l, r = map(int, input().split(' '))
        print(str(array[r - l][l - 1]))

main()
	 		 	  				 		 		 				 				",quadratic,dp,660
"def main():
    n = int(input())
    a = list(map(int, input().split(' ')))
    array = []
    array.append(a)
    
    for i in range(n - 1):
        aux = []
        for j in range(1, len(array[-1])):
            xor = array[-1][j-1] ^ array[-1][j]
            aux.append(xor)
        array.append(aux)
    
    for j in range(1, len(array)):
        for k in range(len(array[j])):
            maximo = max(array[j][k], array[j-1][k], array[j - 1][k + 1])
            array[j][k] = maximo
    
    q = int(input())
    aux2 = []
    for i in range(q):
        l, r = map(int, input().split(' '))
        aux2.append((l,r))

    for i in aux2:
        l, r = i[0], i[1]
        print(str(array[r - l][l - 1]))

main()
 	 			 	 			 			     	 		 	  		",quadratic,dp,750
"def main():
    n = int(input())
    a = list(map(int, input().split(' ')))
    array = []
    array.append(a)

    for i in range(n - 1):
        aux = []
        for j in range(1, len(array[-1])):
            xor = (array[-1][j-1] ^ array[-1][j])
            aux.append(xor)
        array.append(aux)

    for j in range(1, len(array)):
        for k in range(len(array[j])):
            maximo = max(array[j][k], array[j-1][k], array[j-1][k+1])
            array[j][k] = maximo

    q = int(input())
    aux2 = []

    for i in range(q):
        l, r = map(int, input().split(' '))
        aux2.append((l, r))

    for i in aux2:
        l, r = i[0], i[1]
        print(str(array[r-l][l-1]))

main()",quadratic,dp,702
"import sys
input=sys.stdin.readline
n=int(input())
a=list(map(int,input().split()))
f=[[0]*n for i in range(n)]
for i in range(n):
    f[0][i]=a[i]
for i in range(1,n):
    for j in range(n-i):
        f[i][j]=f[i-1][j]^f[i-1][j+1]
for i in range(1,n):
    for j in range(n-i):
        f[i][j]=max(f[i][j],f[i-1][j],f[i-1][j+1])
q=int(input())
for _ in range(q):
    l,r=map(int,input().split())
    print(f[r-l][l-1])",quadratic,dp,418
"import sys
input = lambda : sys.stdin.readline().rstrip()

sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))

### セグメント木(はやい)
class SG:
    def __init__(self, n, v=None):
        self._n = n
        self.geta = 0
        x = 0
        while (1 << x) < n:
            x += 1
        self._log = x
        self._size = 1 << self._log
        self._d = [ninf] * (2 * self._size)
        if v is not None:
            for i in range(self._n):
                self._d[self._size + i] = v[i]
        for i in range(self._size - 1, 0, -1):
            self._update(i)
    def _update(self, k):
        self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])
    def update(self, p, x):
        assert 0 <= p < self._n
#         x -= self.geta
        p += self._size
        self._d[p] = x
        for i in range(1, self._log + 1):
#             self._update(p >> i)
            k = p>>i
            self._d[k] = op(self._d[2 * k], self._d[2 * k + 1])
    def get(self, p):
        assert 0 <= p < self._n
        return self._d[p + self._size] # + self.geta
    def check(self):
        return [self.get(p) for p in range(self._n)]
    def query(self, left, right):
        # [l,r)の総和
        assert 0 <= left <= right <= self._n
        sml = ninf
        smr = ninf
        left += self._size
        right += self._size
        # 外側から計算していく(lは小さい側から, rは大きい側から)
        while left < right:
            if left & 1:
                sml = op(sml, self._d[left])
                left += 1
            if right & 1:
                right -= 1
                smr = op(self._d[right], smr)
            left >>= 1
            right >>= 1
        return op(sml, smr) # + self.geta
#     def update_all(self, v):
#         # 全体加算
#         self.geta += v
    def query_all(self):
        return self._d[1] # + self.geta
    def max_right(self, left, f):
        """"""f(op(a[l], a[l + 1], ..., a[r - 1])) = true となる最大の r
        -> rはf(op(a[l:r+1]))がFalseになる最小のr
        """"""
#         assert 0 <= left <= self._n
#         assert f(ninf)
        if left == self._n:
            return self._n
        left += self._size
        sm = ninf
        first = True
        while first or (left & -left) != left:
            first = False
            while left % 2 == 0:
                left >>= 1
            if not f(op(sm, self._d[left])):
                while left < self._size:
                    left *= 2
                    if f(op(sm, self._d[left])):
                        sm = op(sm, self._d[left])
                        left += 1
                return left - self._size
            sm = op(sm, self._d[left])
            left += 1
        return self._n
    def min_left(self, right, f):
        """"""f(op(a[l], a[l + 1], ..., a[r - 1])) = true となる最小の l
        """"""
#         assert 0 <= right <= self._n
#         assert f(ninf)
        if right == 0:
            return 0
        right += self._size
        sm = ninf
        first = True
        while first or (right & -right) != right:
            first = False
            right -= 1
            while right > 1 and right % 2:
                right >>= 1
            if not f(op(self._d[right], sm)):
                while right < self._size:
                    right = 2 * right + 1
                    if f(op(self._d[right], sm)):
                        sm = op(self._d[right], sm)
                        right -= 1
                return right + 1 - self._size
            sm = op(self._d[right], sm)
        return 0
op = max
ninf = 0

n = int(input())
a = list(map(int, input().split()))
vs = [[0]*(n-i) for i in range(n)]
vs[0] = a
for i in range(1,n):
    for j in range(n-i):
        vs[i][j] = vs[i-1][j]^vs[i-1][j+1]
def f(l,r):
    return vs[r-l][l]
ms = [[0]*n for _ in range(n)]
for l in range(n):
    ms[l][l] = f(l,l)
    for r in range(l+1,n):
        ms[l][r] = max(ms[l][r-1], f(l,r))
sgs = []
for r in range(n):
    l = [ms[l][r] for l in range(r+1)]
    sg = SG(len(l), l)
    sgs.append(sg)
q = int(input())
ans = []
for _ in range(q):
    l,r = map(int, input().split())
    l -= 1
    r -= 1
    val = sgs[r].query(l,r+1)
    ans.append(val)
#     break
write(""\n"".join(map(str, ans)))",quadratic,dp,4276
"from sys import stdin


def main():
    n = int(input())
    aa = list(map(int, input().split()))
    dp = [aa]
    for i in range(n - 1, 0, -1):
        aa = aa[:]
        for j in range(i):
            aa[j] ^= aa[j + 1]
        del aa[-1]
        dp.append(aa)
    aa = dp[0]
    for i, bb in enumerate(dp[1:], 1):
        a = aa[0]
        for j, b in enumerate(bb):
            c = aa[j + 1]
            bb[j] = max(a, b, c)
            a = c
        aa = bb
    input()
    res = stdin.read().splitlines()
    for i, s in enumerate(res):
        lo, hi = map(int, s.split())
        res[i] = str(dp[hi - lo][lo - 1])
    print('\n'.join(res))


if __name__ == '__main__':
    main()
",quadratic,dp,689
"from sys import stdin, stdout
n=int(input())
s=list(map(int,stdin.readline().strip().split()))
dp=[[-1 for i in range(n+1)]for j in range(n+1)]
for i in range(n):
    dp[0][i]=s[i]
for i in range(1,n):
    for j in range(n-i):
        dp[i][j]=dp[i-1][j]^dp[i-1][j+1]
for i in range(1,n):
    for j in range(n-i):
        dp[i][j]=max(dp[i-1][j],dp[i-1][j+1],dp[i][j])
q=int(input())
ans=""""
for i in range(q):
    l,r=map(int,stdin.readline().strip().split())
    print(dp[r-l][l-1])
",quadratic,dp,484
"n = int(input())
*a, = map(int, input().split())
dp = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n):
    dp[0][i] = a[i]
for i in range(1, n):
    for j in range(n - i + 1):
        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]
for i in range(1, n):
    for j in range(n - i):
        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])
for i in range(int(input())):
    l, r = map(int, input().split())
    print(dp[r - l][l - 1])",quadratic,dp,455
"#t=int(input())
t=1
for _ in range(t):
    n=int(input())
    l=list(map(int,input().split()))
    dp=[[0 for j in range(n)] for i in range(n)]
    for i in range(n):
        dp[0][i]=l[i]
    for i in range(1,n):
        for j in range(n-i):
            dp[i][j]=dp[i-1][j]^dp[i-1][j+1]
    
    for i in range(1,n):
        for j in range(n-i):
            dp[i][j]=max(dp[i][j],dp[i-1][j],dp[i-1][j+1])
    
    q=int(input())
    for __ in range(q):
        x,y=map(int,input().split())
        x-=1
        y-=1
        print(dp[y-x][x])",quadratic,dp,542
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict


BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
n = int(input())
*a, = map(int, input().split())
dp = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n):
    dp[0][i] = a[i]
for i in range(1, n):
    for j in range(n - i + 1):
        dp[i][j] = dp[i - 1][j] ^ dp[i - 1][j + 1]
for i in range(1, n):
    for j in range(n - i):
        dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i - 1][j + 1])
for i in range(int(input())):
    l, r = map(int, input().split())
    print(dp[r - l][l - 1])",quadratic,dp,2490
"# ---------------------------iye ha aam zindegi---------------------------------------------
import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------game starts now----------------------------------------------------import math
class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1


class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):
        """"""
        Side effect!!! Changes node. Node should have exactly one child
        """"""
        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n


# -----------------------------------------------binary seacrh tree---------------------------------------
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

# -------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


# --------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m


# --------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z


# --------------------------------------------------product----------------------------------------
def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por


# --------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] <= key):
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count


# --------------------------------------------------binary----------------------------------------
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)


# --------------------------------------------------binary------------------------------------
n=int(input())
l=list(map(int,input().split()))
dp=[[0 for i in range(n)]for i in range(n)]
for i in range(n):
    dp[i][i]=l[i]
for i in range(n-1,-1,-1):
    for j in range(i+1,n):
        dp[i][j]=max(dp[i][j],dp[i][j-1]^dp[i+1][j])
for i in range(n-1,-1,-1):
    for j in range(i+1,n):
        dp[i][j]=max(dp[i][j],dp[i][j-1],dp[i+1][j])
for i in range(int(input())):
    l,r=map(int,input().split())
    l-=1
    r-=1
    print(dp[l][r])",quadratic,dp,15355
"from sys import stdin
from operator import xor

rints = lambda: [int(x) for x in stdin.readline().split()]
n, a, m = int(input()), [rints()], int(input())
qur, out = [rints() for _ in range(m)], []

for i in range(1, n):
    a.append(list(map(xor, a[-1][:-1], a[-1][1:])))

for i in range(n - 1):
    a[i + 1] = list(map(max, a[i][:-1], a[i][1:], a[i + 1]))

for l, r in qur:
    out.append(a[r - l][l - 1])

print('\n'.join(map(str, out)))
",quadratic,dp,441
"from sys import stdin
from operator import xor

rints = lambda: [int(x) for x in stdin.readline().split()]
n, a, m = int(input()), [rints()], int(input())
qur, out = [rints() for _ in range(m)], []

for i in range(1, n):
    a.append(map(xor, a[-1][:-1], a[-1][1:]))

for i in range(n - 1):
    a[i + 1] = map(max, a[i][:-1], a[i][1:], a[i + 1])

for l, r in qur:
    out.append(a[r - l][l - 1])

print('\n'.join(map(str, out)))
",quadratic,dp,429
"import sys
input=sys.stdin.readline
n=int(input())
ar=list(map(int,input().split()))
dic={}
li=[]
for i in range(n):
    xx=[]
    for j in range(n-i):
        xx.append(0)
    li.append(xx.copy())
for i in range(n):
    for j in range(n-i):
        if(i==0):
            li[i][j]=ar[j]
        else:
            li[i][j]=li[i-1][j]^li[i-1][j+1]
for i in range(1,n):
    for j in range(n-i):
        li[i][j]=max(li[i][j],li[i-1][j],li[i-1][j+1])
for _ in range(int(input())):
    l,r=map(int,input().split())
    print(li[r-l][l-1])",quadratic,dp,533
"#!/usr/bin/env python3
#
# XOR-pyramid
#
import sys, os

def read_int(): return int(input())
def read_ints(): return list(map(int, input().split()))
#------------------------------------------------------------------------------#

n = read_int()
a = read_ints()
dp = [[0] * n for _ in range(n)]
f = [[0] * n for _ in range(n)]
for i in range(n - 1, -1, -1):
	f[i][i] = a[i]
	for j in range(i + 1, n):
		f[i][j] = f[i][j - 1] ^ f[i + 1][j]
for i in range(n - 1, -1, -1):
	dp[i][i] = f[i][i]
	for j in range(i + 1, n):
		dp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j])
q = read_int()
for _ in range(q):
	l, r = read_ints()
	print(dp[l - 1][r - 1])

	  		 	   		   	  	 		 					",quadratic,dp,679
"#!/usr/bin/env python3
#
# XOR-pyramid
#
import sys, os

def read_int(): return int(input())
def read_ints(): return list(map(int, input().split()))
#------------------------------------------------------------------------------#

n = read_int()
a = read_ints()
dp = [[0] * n for _ in range(n)]
f = [[0] * n for _ in range(n)]
for i in range(n - 1, -1, -1):
	f[i][i] = dp[i][i] = a[i]
	for j in range(i + 1, n):
		f[i][j] = f[i][j - 1] ^ f[i + 1][j]
		dp[i][j] = max(f[i][j], dp[i][j - 1], dp[i + 1][j])
q = read_int()
for _ in range(q):
	l, r = read_ints()
	print(dp[l - 1][r - 1])

 	 	  			   		   	  					   			",quadratic,dp,615
"s, l= list(map(int,input().split()))
sig = []
utp = []
if s == 0 or l ==0:
    print('NO')
    quit()
for i in range(s):
    sig.append(list(map(int,input())))
for i in range(0,l):
    out = 0
    for x in range(0,s):
        out+=sig[x][i]
    utp.append(out)
sig = sorted(sig,key = sum)
for i in range(0,s):
    res1=0
    for x in range(0,l):
        if utp[x]-sig[i][x] <=0:
            break
        else:
            res1+=1
    if res1 == l:
        print('YES')
        quit()
        
print('NO')
",quadratic,implementation,506
"n,m=map(int,input().split())
a=[int(input(),2)for _ in range(n)]
 
s=t=0
for x in a:
    t|=s&x
    s|=x
print(('YES','NO')[all(x&s&~t for x in a)])",quadratic,implementation,148
"def fun(grid,counter,n,m):
    for i in range(n):
        possible=True
        for j in range(m):
            if grid[i][j]=='1' and counter[j]==1:
                possible=False
                break
        if possible:
            return True
    return False

n,m=[int(_) for _ in input().split("" "")]
grid,counter=[],[0]*m
for _ in range(n):
    s=input()
    for i in range(m):
        if s[i]=='1':
            counter[i]+=1
    grid.append(s)
if fun(grid,counter,n,m):
    print(""YES"")
else:
    print(""NO"")
    
",quadratic,implementation,521
"n, m = map(int,input().split())
X = []
for i in range(n):
    a = input()
    U = [char for char in a]
    X.append(U)
nums = []
for i in range(m):
    t = 0 
    for j in range(n):
        t += int(X[j][i])
    nums.append(t)

for i in range(n):
    ok = True 
    for j in range(m):
        if X[i][j] == '1':
            if nums[j]>1:
                continue 
            else:
                ok = False 
    if ok == True:
        print(""YES"")
        quit()
print(""NO"")",quadratic,implementation,476
"#Winners never quit, quiters never win............................................................................
from collections import deque as de
import math
from collections import Counter as cnt
from functools import reduce
from typing import MutableMapping

def factors(n):    
    return set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
class My_stack():
    def __init__(self):
        self.data = []
    def my_push(self, x):
        return (self.data.append(x))
    def my_pop(self):
        return (self.data.pop())
    def my_peak(self):
        return (self.data[-1])
    def my_contains(self, x):
        return (self.data.count(x))
    def my_show_all(self):
        return (self.data)
    def isEmpty(self):
      return len(self.data)==0

arrStack = My_stack()    
def decimalToBinary(n): 
    return bin(n).replace(""0b"", """")

def isPrime(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True

	
	if (n % 2 == 0 or n % 3 == 0) : 
		return False

	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6

	return True

def get_prime_factors(number):
    prime_factors = []
    while number % 2 == 0:
        prime_factors.append(2)
        number = number / 2
    for i in range(3, int(math.sqrt(number)) + 1, 2):
        while number % i == 0:
            prime_factors.append(int(i))
            number = number / i

    if number > 2:
        prime_factors.append(int(number))

    return prime_factors
def get_frequency(list):
    dic={}
    for ele in list:
        if ele in dic:
            dic[ele] += 1
        else:
            dic[ele] = 1
    return dic
def Log2(x): 
    return (math.log10(x) / 
            math.log10(2)); 

def isPowerOfTwo(n): 
    return (math.ceil(Log2(n)) == math.floor(Log2(n))); 

   
#here we go......................
#winners never quit, quitters never win
n,m=map(int,input().split())
l=[list(map(int,input())) for i in range(n)]
dic={}
discarded={}
for i in range(n):
    for j in range(m):
        if l[i][j]==1 :
            if j+1 not in discarded:
                if j+1 not in dic:
                    dic[j+1]=i+1
                else:
                    del dic[j+1]
                    discarded[j+1]=1

#print(dic)  
#print(discarded)  
if len(dic)==0:
    print(""YES"")
else:
    kk=list(dic.values())
    temp=list(set(kk))
    if len(temp)==n:
        print(""NO"")
    else:
        print(""YES"")

        


        
    





        ",quadratic,implementation,2516
"if __name__ == '__main__':
    cin = input
    n, m = map(int, cin().split())
    s, l, f = [[] for _ in range(n)], [0] * m, 0

    for i in range(n):
        t = cin()
        for j in range(m):
            if t[j] == ""1"":
                l[j] += int(t[j])
                s[i].append(j)
    for i in range(n):
        r = set(l[c] - 1 for c in s[i])
        if not 0 in r:
            f = not f
            break
    print(""YNEOS""[not f::2])",quadratic,implementation,443
"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n,m = inpl()
s = [inpsl(m) for _ in range(n)]
lampcnt = [0]*m
for i in range(n):
    for j in range(m):
        if s[i][j] == '1':
            lampcnt[j] += 1
res = False
for i in range(n):
    only = False
    for j in range(m):
        if s[i][j] == '1' and lampcnt[j] == 1:
            only = True
    if not only: res = True
print('YES' if res else 'NO')",quadratic,implementation,912
"n, m = map(int, input().split())
x = list(list(map(int , input())) for i in range(n))
res = [0] * m
for i in range(n):
	for j in range(m):
		res[j] += x[i][j]

for i in range(n):
	ok = 1
	for j in range(m):
		if res[j] == 1 and x[i][j] == 1:
			ok = 0
			break
	if ok:
		print(""YES"")
		exit()
print(""NO"")
",quadratic,implementation,305
"n, m = map(int, input().split())
grid = []
for i in range(n):
    grid.append(input())
cnts = [0 for i in range(m)]
for i in range(n):
    for j in range(m):
        cnts[j] += 0 if grid[i][j] == '0' else 1
for i in range(n):
    flag = True
    for j in range(m):
        if grid[i][j] == '1' and cnts[j] == 1:
            flag = False
            break
    if flag:
        print('YES')
        exit(0)
print('NO')
 	    					 	  	 		 					  		 	",quadratic,implementation,448
"import sys
import io, os
input = sys.stdin.readline

n, m = map(int, input().split())
A = [input().rstrip() for i in range(n)]
C = [0]*m
for i in range(n):
    a = A[i]
    for j, c in enumerate(a):
        C[j] += int(c)

for i in range(n):
    a = A[i]
    for j, c in enumerate(a):
        C[j] -= int(c)
    for j in range(m):
        if C[j] == 0:
            break
    else:
        print('YES')
        exit()
        continue
    for j, c in enumerate(a):
        C[j] += int(c)
print('NO')
",quadratic,implementation,499
"from collections import defaultdict, deque
from heapq import heappush, heappop
from math import inf


def solve():
    n, m = map(int, input().split())
    cnt = defaultdict(int)
    res = []
    for i in range(n):
        A = list(map(int, list(input())))
        res.append(A)
        for j in range(m):
            if A[j]:
                cnt[j] += 1
    valid = False
    for r in res:
        j = [i for i in range(m) if r[i]]
        if all(cnt[i] > 1 for i in j):
            valid = True
            break
    if valid:
        print(""YES"")
    else:
        print(""NO"")

t = 1
# t = int(input())
while t:
    t -= 1
    solve()

",quadratic,implementation,639
"from sys import stdin
from functools import reduce
from operator import ior
def get_ints(): return list(map(int, stdin.readline().strip().split()))

nk ,m = get_ints()
a = [int(input(),2) for x in range(nk)]
if nk == 1:
	print(""NO"")
	exit()
num =  reduce(ior,a)
for i in range(nk):
	k = a.copy()
	k.pop(i)
	n = reduce(ior,k)
	if n == num:
		print(""YES"")
		exit()
print(""NO"")",quadratic,implementation,374
"# qumeric
n, m = map(int, input().split())
a = [int(input(), 2) for _ in range(n)]

s = t = 0
for x in a:
    t |= s & x
    s |= x
print((""YES"", ""NO"")[all(x & s & ~t for x in a)])
",quadratic,implementation,181
"# qumeric

from operator import *
n, m = map(int, input().split())
a = [int(input(), 2) for _ in range(n)]
s = t = 0
for x in a:
    t |= s & x
    s |= x
print((""YES"", ""NO"")[all(x & s & ~t for x in a)])
",quadratic,implementation,204
"n, m = map(int, input().split())
tc = [0]*m
ps = []
for _ in range(n):
    temp = input()
    psa = [0]*m
    for i in range(m):
        if temp[i] == '1':
            psa[i] += 1
            tc[i] += 1
    ps.append(psa)
ans = 'NO'

for i in ps:
    c = 0
    for j in range(m):
        if tc[j]-i[j] > 0:
            c += 1
    if c == m:
        ans = 'YES'
        break

print(ans)
",quadratic,implementation,387
"n,m = map(int,input().split())
d = {x:0 for x in range(m)}
l = []
for _ in range(n):
    s = input()
    for x in range(m):
        if s[x]== '1': d[x]+=1
    l.append(s)
for x in l:
    t=0
    for y in range(m):
        if x[y] =='1':
            if d[y] ==1:t = 1;break
    if t==0: print('YES');exit()
print('NO')",quadratic,implementation,317
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):#nmbr()):
    r, c=lst()
    a=[input() for i in range(r)]
    pre=[[0 for i in range(c)] for i in range(r)]
    suf=[[0 for i in range(c)] for i in range(r)]
    for i in range(c):
        pre[0][i]=int(a[0][i])
        suf[r-1][i]=int(a[r-1][i])
    for i in range(1, r):
        for j in range(c):
            pre[i][j]=pre[i-1][j]+int(a[i][j])
    # print(*pre, sep='\n')
    for i in range(r-2, -1 ,-1):
        for j in range(c):
            suf[i][j]=suf[i+1][j]+int(a[i][j])
    ans='NO'
    for i in range(r):
        f=1
        for j in range(c):
            up=down=0
            if i-1>=0:up=pre[i-1][j]
            if i+1<r:down=suf[i+1][j]
            if up+down==0:
                f=0
                break
        if f:
            ans=""YES""
            break
    print(ans)
",quadratic,implementation,916
"n, m = map(int, input().split())
a = [list(map(int, input())) for i in range(n)]

ignorable = [True] * n

for i in range(m):
    cnt = 0
    for j in range(n):
        cnt += a[j][i]
    if cnt == 1:
        for j in range(n):
            if a[j][i]:
                ignorable[j] = False

if any(ignorable):
    print('YES')
else:
    print('NO')
",quadratic,implementation,347
"def main():
    n, m = map(int, input().split())
    a = []
    for i in range(n):
        a.append(input())
    ans = ""NO""
    count = [0] * m
    for i in range(n):
        for j in range(m):
            if (a[i][j] == '1'):
                count[j] += 1
    for i in range(n):
        ans = ""YES""
        for j in range(m):
            if (count[j] == 1 and a[i][j] == '1'):
                ans = ""NO""
                break
        if (ans == ""YES""):
            break
    print(ans)
main()",quadratic,implementation,493
"n, m = [int(v) for v in input().split()]

a = []
for _ in range(n):
    a.append([int(v) for v in input()])

colsums = [sum(a[i][j] for i in range(n)) for j in range(m)]

for row in a:
    if all(rv < sv for (rv, sv) in zip(row, colsums)):
        print(""YES"")
        exit()

print(""NO"")
",quadratic,implementation,289
"import sys
n=int(input())
#n=5
#l=[2,4,5,4,10]
#c=[40,30,20,10,40]
l=list(map(int,input().split()))
c=list(map(int,input().split()))
a=[]
for i in range(1,n-1):
    lr=sys.maxsize
    lc=sys.maxsize
    for j in range(0,i):
        
        if l[i]>l[j]:
            lc=min(lc,c[j])
            #print(lc,l[i])
    for j in range(i+1,n):
        
        if l[j]>l[i]:
            lr=min(lr,c[j])
            #print(lr,l[i])
    if lr<sys.maxsize and lc<sys.maxsize:
        a.append(lr+lc+c[i])
#print(a)
if not a:
    print(-1)
else:
    print(min(a))       
            
            ",quadratic,"brute force,dp,implementation",586
"from sys import stdin,stdout
nmbr=lambda:int(stdin.readline())
lst=lambda:list(map(int,stdin.readline().split()))
for _ in range(1):#nmbr()):
    n=nmbr()
    a=lst()
    b=lst()
    dp=[0]*n
    for i in range(n):
        v=float('inf')
        for j in range(i+1,n):
            if a[j]>a[i]:v=min(v,b[i]+b[j])
        dp[i]=v
    # print(dp)
    for i in range(n):
        v = float('inf')
        for j in range(i + 1, n):
            if a[j] > a[i]: v = min(v, b[i] + dp[j])
        dp[i] = v
    ans=min(dp)
    print(ans if ans!=float('inf') else -1)",quadratic,"brute force,dp,implementation",557
"from sys import stdin,stdout
nmbr = lambda: int(stdin.readline())
lst = lambda: list(map(int, stdin.readline().split()))
for _ in range(1):#nmbr()):
    n=nmbr()
    a=lst()
    b=lst()
    ans=PI=float('inf')
    dp=[[PI for _ in range(4)] for _ in range(n)]
    for i in range(n):
        dp[i][1]=b[i]
        for j in range(i):
            if a[j]<a[i]:
                dp[i][2]=min(dp[i][2],dp[j][1]+b[i])
                dp[i][3]=min(dp[i][3],dp[j][2]+b[i])
                ans=min(ans,dp[i][3])
    print(ans if ans!=PI else -1)",quadratic,"brute force,dp,implementation",535
"import sys
input = sys.stdin.readline
n = int(input())
s = list(map(int,input().split()))
c = list(map(int,input().split()))
d = {}
for i in range(n-1):
    ans = 10**12
    for j in range(i+1,n):
        if s[i] < s[j]:
            ans = min(ans,c[i]+c[j])

    d[i] = ans

ans = 10**12
for i in range(n-2):
    for j in range(i+1,n-1):
        if s[i] < s[j]:
            ans = min(ans,c[i]+d[j])

if ans == 10**12:
    print(-1)

else:
    print(ans)",quadratic,"brute force,dp,implementation",453
"import sys
n = int(input().strip())
sizes = list(map(int, input().strip().split()))
cost = list(map(int, input().strip().split()))
tot = []
for i in range(n):
    tot.append([sizes[i], cost[i]])
ret = False
lcomp = []
for j in range(len(tot)):
    if j > 0 and j < len(tot)-1:
        temp1 = tot[:j]
        temp2 = tot[j+1:]
        mi_1 = sys.maxsize
        ret1 = False
        for i in range(len(temp1)):
            if temp1[i][0] < tot[j][0]:
                mi_1 = min(mi_1, temp1[i][1])
                ret1 = True
        mi_2 = sys.maxsize
        ret2 = False
        for k in range(len(temp2)):
            if temp2[k][0] > tot[j][0]:
                mi_2 = min(mi_2, temp2[k][1])
                ret2 = True
        if ret1 and ret2:
            ret = True
            lcomp.append(mi_1+tot[j][1]+mi_2)
            #print(mi_1, tot[j][1], mi_2)
if ret:
    print(min(lcomp))
else:
    print(-1)
",quadratic,"brute force,dp,implementation",910
"import sys


# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

input = sys.stdin.readline


n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))


ans = float('inf')
for i in range(1, n-1):
    bef = aft = float('inf')
    for j in range(i):
        if a[j] < a[i]:
            bef = min(bef, b[j])
    for j in range(i, n):
        if a[i] < a[j]:
            aft = min(aft, b[j])
    ans = min(ans, b[i]+bef+aft)
print(-1 if ans > 10**9 else ans)




",quadratic,"brute force,dp,implementation",516
"# map(int, input().split("" ""))
n = int(input())
l = list(map(int, input().split("" "")))
l2 = list(map(int, input().split("" "")))
dp_1 = l2.copy()
dp_2 = [9999999999]*n
dp_3 = [9999999999]*n
for i in range(1, n):
    for j in range(i):
        if l[i] > l[j]:
            dp_2[i] = min(dp_2[i], dp_1[j]+l2[i])

for i in range(1,n):
    for j in range(i):
        if l[i] > l[j]:
            dp_3[i] = min(dp_3[i], dp_2[j]+l2[i])

x = min(dp_3)
if x == 9999999999:
    print(-1)
else:
    print(x)",quadratic,"brute force,dp,implementation",493
"# map(int, input().split("" ""))
n = int(input())
l = list(map(int, input().split("" "")))
l2 = list(map(int, input().split("" "")))
dp_1 = l2.copy()
dp_2 = [9999999999]*n
dp_3 = [9999999999]*n
for i in range(1, n):
    for j in range(i):
        if l[i] > l[j]:
            dp_2[i] = min(dp_2[i], dp_1[j]+l2[i])

    for j in range(i):
        if l[i] > l[j]:
            dp_3[i] = min(dp_3[i], dp_2[j]+l2[i])

x = min(dp_3)
if x == 9999999999:
    print(-1)
else:
    print(x)",quadratic,"brute force,dp,implementation",472
"n = int(input())

nums = list(map(int, input().split()))
costs = list(map(int, input().split()))


k = -1

for i in range(n):
    
    kc = -1
    for c in range(i + 1, n):
        if nums[i] < nums[c] and (kc == -1 or kc > costs[c]):
            if kc == -1:
                kc = costs[c]
            kc = costs[c]
     
    if kc > -1:
        nat = kc
        kc = -1
        for c in range(i):
            if nums[i] > nums[c] and (kc == -1 or kc > costs[c]):
                if kc == -1:
                    kc = costs[c]
              
                kc = costs[c]
        
        if kc > -1:
            if k == -1:
                k = nat + kc + costs[i]
            k = min(nat + kc + costs[i], k)

print(k)    

    
    
    
",quadratic,"brute force,dp,implementation",739
"import math
import sys

n=int(input())
s=list(map(int,input().split()))
ce=list(map(int,input().split()))

best=10**9
for j in range(1,n-1):
    a=ce[j];b=10**9;c=10**9
    for i in range(j-1,-1,-1):
        if s[i]<s[j]:
            b=min(b,ce[i])
    for k in range(j+1,n):
        if s[k]>s[j]:
            c=min(c,ce[k])
    best=min(best,a+b+c)

if best>=10**9:
    print(-1)
else:
    print(best)",quadratic,"brute force,dp,implementation",402
"n = int(input())
a = list(map(int,input().split()))
cost = list(map(int,input().split()))
ans  = float(""inf"")
for i in range(n):
    m,r = float(""inf""),float(""inf"")
    for j in range(i):
        if a[j]<a[i]:
            m = min(m,cost[j])
    for k in range(i+1,n):
        if a[k]>a[i]:
            r = min(r,cost[k])
    ans = min(ans,cost[i]+m+r)
print(ans if ans!=float(""inf"") else -1)
",quadratic,"brute force,dp,implementation",392
"import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
#sys.setrecursionlimit(111111) 
INF=99999999999999999999999999999999

def main():
    
    mod=1000000007
    # InverseofNumber(mod)
    # InverseofFactorial(mod)
    # factorial(mod)
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    
    ###CODE
    tc = 1
    for _ in range(tc):
        n=ri()
        s=ria()
        c=ria()
        ans=INF
        for i in range(n):
            mid=s[i]
            mcl=INF
            mrl=INF
            for j in range(i-1,-1,-1):
                if s[j]<mid:
                    mcl=min(mcl,c[j])
            for j in range(i+1,n):
                if s[j]>mid:
                    mrl=min(mrl,c[j])
            ans=min(ans,c[i]+mcl+mrl)
        if ans==INF:
            wi(-1)
        else:
            wi(ans)
                    
            
            
        
                        
                
                
            
                    
                    
                     
                
        
                        

            
            
                    
                
                
        
                
                          
            
        
    
        
    #<--Solving Area Ends
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    
                
class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()


class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)


class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush


if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    main()
    ",quadratic,"brute force,dp,implementation",3891
"class SegTree:
    def __init__(self, init_val, ide_ele, segfunc):
        self.n = len(init_val)
        self.num = 2**(self.n-1).bit_length()
        self.ide_ele = ide_ele
        self.segfunc = segfunc
        self.seg = [ide_ele]*2*self.num
        # set_val
        for i in range(self.n):
            self.seg[i+self.num] = init_val[i]
        # built
        for i in range(self.num-1, 0, -1):
            self.seg[i] = self.segfunc(self.seg[2*i], self.seg[2*i+1])

    def update(self, k, x):
        k += self.num
        self.seg[k] = x
        while k:
            k = k >> 1
            self.seg[k] = self.segfunc(self.seg[2*k], self.seg[2*k+1])

    def query(self, l, r):
        if r <= l:
            return self.ide_ele
        l += self.num
        r += self.num
        lres = self.ide_ele
        rres = self.ide_ele
        while l < r:
            if r & 1:
                r -= 1
                rres = self.segfunc(self.seg[r], rres)
            if l & 1:
                lres = self.segfunc(lres, self.seg[l])
                l += 1
            l = l >> 1
            r = r >> 1
        res = self.segfunc(lres, rres)
        return res

    def __str__(self): # for debug
        arr = [self.query(i,i+1) for i in range(self.n)]
        return str(arr)

n = int(input())
S = list(map(int, input().split()))
C = list(map(int, input().split()))
SA = list(set(S))
SA = sorted(SA)
d = {}
for i, s in enumerate(SA):
    d[s] = i
S = [d[s] for s in S]
L = [0]*n
R = [0]*n
INF = 10**18
N = len(d)
seg = SegTree([INF]*(N+1), INF, min)
seg.update(S[0], C[0])
for i in range(1, n-1):
    s = S[i]
    L[i] = seg.query(0, s)
    seg.update(s, C[i])

seg = SegTree([INF]*(N+1), INF, min)
seg.update(S[-1], C[-1])
for i in reversed(range(1, n-1)):
    s = S[i]
    R[i] = seg.query(s+1, seg.n)
    seg.update(s, C[i])

#print(L)
#print(R)
ans = INF
for i in range(1, n-1):
    ans = min(ans, L[i]+C[i]+R[i])
if ans >= INF:
    print(-1)
else:
    print(ans)
",quadratic,"brute force,dp,implementation",1972
"from collections import Counter
import string
import math
import sys
# sys.setrecursionlimit(10**6) 
from fractions import Fraction
def array_int():
    return [int(i) for i in sys.stdin.readline().split()]
def vary(arrber_of_variables):
    if arrber_of_variables==1:
        return int(sys.stdin.readline())
    if arrber_of_variables>=2:
        return map(int,sys.stdin.readline().split()) 
def makedict(var):
    return dict(Counter(var))
testcases=1
for _ in range(testcases):
    n=vary(1)
    indices=array_int()
    cost=array_int()
    ans=float('inf')
    mint=[]
    for i in range(n):
        ans=float('inf')
        total=cost[i]
        flag=0
        for j in range(i):
            if indices[i]>indices[j]:
                ans=min(ans,cost[j])
                flag=1
        if flag!=0:
            total+=ans
            ans=float('inf')
            flag=0
            for k in range(i+1,n):
                if indices[k]>indices[i]:
                    ans=min(ans,cost[k])
                    flag=1
            if flag!=0:
                total+=ans
                mint.append(total)
            else:
                continue
        else:
            continue
    if len(mint)>0:
        print(min(mint))
    else:
        print(-1)


                

                

        ",quadratic,"brute force,dp,implementation",1304
"import sys
def get_ints(): return list(map(int, sys.stdin.readline().strip().split()))

def solve(N, S, C):
    dp = [float('inf')] * N
    for i in range(1, N):
        for j in range(i):
            if S[j] < S[i]:
                dp[i] = min(dp[i], C[j] + C[i])

    dp2 = [float('inf')] * N
    for i in range(N - 1, 0, -1):
        for j in range(i + 1, N, 1):
            if S[i] < S[j]:
                dp2[j] = min(dp2[j], dp[i] + C[j])

    ans = min(dp2)
    if ans == float('inf'):
        return -1
    return ans

N = int(input())
S = get_ints()
C = get_ints()

print(solve(N, S, C))
",quadratic,"brute force,dp,implementation",597
"I=lambda:list(map(int,input().split()))
n,s,a=int(input()),I(),I()
t=3*10**9
q=[0]*n
for i in range(n-1,-1,-1):
    u=10**8
    for j in range(i-1,-1,-1):
        if s[i]>s[j]:u=min(u,a[j])
    q[i]=u
for i in range(n):
    for j in range(i+1,n):
        if s[i]<s[j]:t=min(t,a[i]+a[j]+q[i])
print(t if t<=sum(a)else -1)",quadratic,"brute force,dp,implementation",320
"n=int(input())
s=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=[float('inf')]*(n)
for i in range(1,n):
    mn=float('inf')
    for j in range(i):
        if s[i]>s[j]:
            mn=min(mn,c[i]+c[j])
    dp[i]=mn
res=float('inf')
for i in range(1,n):
    for j in range(i):
        if s[i]>s[j]:
            res=min(res,c[i]+dp[j])
if res==float('inf'):
    res=-1
print(res)
            
    
    ",quadratic,"brute force,dp,implementation",420
"import bisect
n=int(input())
s=list(map(int,input().split()))
c=list(map(int,input().split()))
ans=10**18
for mid in range(1,n-1):
  l1=[c[i] for i in range(mid) if s[i]<s[mid]]+[10**18]
  l2=[c[i] for i in range(mid+1,n) if s[i]>s[mid]]+[10**18]
  ans=min(ans,min(l1)+c[mid]+min(l2))
if ans>=10**18:
  print(-1)
else:
  print(ans)",quadratic,"brute force,dp,implementation",331
"from math import inf


n = int(input())
s_list = list(map(int, input().split()))
c_list = list(map(int, input().split()))

total_min = inf
for j in range(n):
    min_i = inf
    for i in range(0, j):
        if s_list[i] < s_list[j]:
            min_i = min(min_i, c_list[i])

    min_k = inf
    for k in range(j + 1, n):
        if s_list[k] > s_list[j]:
            min_k = min(min_k, c_list[k])

    total_min = min(total_min, min_i + c_list[j] + min_k)
if total_min != inf:
    print(total_min)
else:
    print(-1)",quadratic,"brute force,dp,implementation",519
"from os import path
import sys,time, collections as c , math , pprint as p , itertools as it , operator as op
maxx , localsys , mod = float('inf'), 0 , int(1e9 + 7) 
if (path.exists('input.txt')):  sys.stdin=open('input.txt','r') ;   sys.stdout=open('output.txt','w')
input = sys.stdin.readline
n = int(input()) ; s = list(map(int , input().split())) ; c = list(map(int , input().split()))
ans = maxx
for mid in range(1 , n - 1):
    l = [maxx] + [c[i] for i in range(mid) if s[i] < s[mid]]
    r = [maxx] + [c[i] for i in range(mid+1 , n) if s[i] > s[mid]]
    ans = min(ans , min(l) + c[mid] + min(r))
print(ans if ans != float('inf') else -1)














# for _ in  range(int(input())):
#     n = int(input())
#     a , i , j ,ok = [[int(i) for i in input().rstrip('\n')] for _ in range(2)] , 0 , 0 , True
#     while j < n :
#         if a[i][j] > 2:
#             if a[i^1][j] < 3:
#                 break
#             else:
#                 i^=1
#         j+=1
#     print('YES' if i==1 and j == n else 'NO')
#for example suppose if you are at row 1 and standing on the curled tile which will obviously lead to another row
#and if this row has ( | or - ) then obviously you have no other way to move forward
#all other combinations are viable




# n = int(input()) ; g = c.defaultdict(list)
# for _ in range(n-1):
#     u , v = map(int , input().split())
#     g[u].append(v)
#     g[v].append(u)
# v , q  , ans  = [0]*(n+1) , [(1 ,1 ,0)] , 0 #p , cnt , height
# while q :
#     p , cnt , h = q.pop()
#     v[p] , c = 1 , 0
#     for i in g[p]:
#         if not v[i]:
#             c+=1
#     if c == 0 :
#         ans+= cnt*h
#     else:
#         for i in g[p]:
#             if not v[i]:
#                 q.append((i , cnt/c , h+1))
#                 v[i] = 1
#     print(q,ans , p, cnt , h)
# print('%.14f'%(ans))
# #probability of the horse taking the route to each of the child of the parent * length of the journey = expected value for that vertex




# def ok(p , s):
#     cnt , need =0 , 0
#     for i in s:
#         if p[need] == i:
#             cnt+=1 ; need ^= 1
#     if cnt % 2 and p[0] != p[1]:
#         cnt-=1
#     return cnt

# for _ in range(int(input())):
#     s = input().rstrip('\n') ; n , ans = len(s) , maxx
#     for i in range(10):
#         for j in range(10):
#             ans = min(ans , n - ok((str(i) , str(j)), s))
#     print(ans)
#This problem was so easy oh gawd , so you can only make left cyclic shift = right cyclic shift , when there are at most
#2 characters
#(incase of 1 ch) at the same time if total string has only character it is valid no matter how you see it 
#(incase of 2 ch) all the characters at odd positions must be equal , and all the characters at even position must be equal





# n , k = map(int , input().split()) ; s = input().rstrip('\n')
# ans = a = b = j = 0
# for i in range(n):
#     a , b = (a+1 , b) if s[i] == 'a' else (a , b+1 )
#     if min(a, b) > k :
#         a , b = (a -1 , b) if s[j] == 'a' else (a , b -1) ; j+=1
#     else:
#         ans+=1
# print(ans)
# #two - pointer method , if at any point min(a , b )> k then keep on decreasing from the beginning untill and unless you get min(a , b) 
# #less than k",quadratic,"brute force,dp,implementation",3203
"n = int(input())
ls1 = [int(i) for i in input().split()]
ls2 = [int(i) for i in input().split()]

ans = float('inf')

for i in range(1, n - 1):
    l = [ls2[j] for j in range(0, i) if ls1[j] < ls1[i]]
    r = [ls2[j] for j in range(i + 1, n) if ls1[j] > ls1[i]]

    if len(l) and len(r):
        ans = min(ans, min(l) + min(r) + ls2[i])

print([-1 , ans][ans != float('inf')])",quadratic,"brute force,dp,implementation",377
"n, a, b = map(int,input().split())
if a>1 and b>1: print(""NO""); exit()
if 2<=n<=3 and a == b == 1: print(""NO""); exit()
print(""YES"")

if b == 1:
    adj = [[0]*n for i in range(n)]
    conn = n
    for i in range(n):
        if conn == a: break
        adj[i][i+1] = adj[i+1][i] = 1
        conn-= 1
        if conn == a: break
elif a == 1:
    adj = [[1]*n for i in range(n)]
    conn = n
    for i in range(n): adj[i][i] = 0
    for i in range(n):
        if conn == b: break
        adj[i][i+1] = adj[i+1][i] = 0
        conn-= 1
        if conn == b: break

for row in adj:
    print(*row, sep='')
",quadratic,"constructive algorithms,graphs,implementation",601
"# python3

def readline(): return map(int, input().split())


def main():
    n, a, b = readline()
    if a > 1 and b > 1:
        print('NO')
        return

    if n in [2, 3] and a == 1 and b == 1:
        print('NO')
        return
    
    matrix = [[i in [j + 1, j -1] for i in range(n)] for j in range(n)]

    a, b = n + 1 - a, n + 1 - b
    if a != n:
        matrix = [[False for i in range(n)] for j in range(n)]
        for i in range(n):
            for j in range(n):
                if i < a and j < a and i != j:
                    matrix[i][j] = True
    elif b != n:
        matrix = [[False for i in range(n)] for j in range(n)]
        for i in range(n):
            for j in range(n):
                if i >= b or j >= b:
                    matrix[i][j] = True
                if i == j:
                    matrix[i][j] = False

    print('YES')
    for row in matrix:
        print("""".join(map(lambda x: '1' if x else '0', row)), flush=False)

if __name__ == '__main__':
    main()
",quadratic,"constructive algorithms,graphs,implementation",1007
"#     Educational Codeforces Round 45 (Rated for Div. 2)
import collections
from functools import cmp_to_key
#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )

import sys
def getIntList():
    return list(map(int, input().split()))    

 
            
    
n,a,b = getIntList()
a0 = a
b0 = b
if a0>b0:
    a0,b0 = b,a
if n==2 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()
if n==3 and (a0,b0) == (1,1):
    print('NO')
    sys.exit()    
if a>1 and b>1:
    print('NO')
    sys.exit()

mat = [['0' for y in range(n)]for x in range(n)]
mat1 = [['1' for y in range(n)]for x in range(n)]
if b==1:
    for x in range(n-a):
        mat[x][x+1] = '1'
        mat[x+1][x] = '1'
else:
    mat = mat1
    for x in range(n):
        mat[x][x] = '0'
    for x in range(n-b):
        mat[x][x+1] = '0'
        mat[x+1][x] = '0'

print('YES')
for x in range(n):
    print(''.join(mat[x]))
",quadratic,"constructive algorithms,graphs,implementation",886
"def ii():
    return int(input())
def mi():
    return map(int, input().split())
def li():
    return list(mi())

n, a, b = mi()
c = max(a, b)
if a != 1 and b != 1:
    print('NO')
elif n == 2 and c == 1:
    print('NO')
elif n == 3 and c == 1:
    print('NO')
else:
    if a == 1:
        g = [[1] * n for i in range(n)]
        for i in range(n):
            g[i][i] = 0
        for i in range(c - 1, n - 1):
            g[i][i + 1] = g[i + 1][i] = 0
    else:
        g = [[0] * n for i in range(n)]
        for i in range(c - 1, n - 1):
            g[i][i + 1] = g[i + 1][i] = 1
    print('YES')
    for r in g:
        print(''.join(str(x) for x in r))",quadratic,"constructive algorithms,graphs,implementation",657
"def get_sign_1(fo):
	def res(s, f=fo):
		if f**2+s**2 == 2*f*s+1:
			return '1'
		else:
			return '0'
	return res


def get_signs_2(cf, rev):
	cf -= 1
	if rev:
		def res(fo, cff=cf):
			if fo >= cff:
				def res2(s, f=fo):
					if s == f:
						return '0'
					elif s >= cff:
						return '0'
					else:
						return '1'
			else:
				def res2(s, f=fo):
					if s == f:
						return '0'
					else:
						return '1'
			return res2
	else:
		def res(fo, cff=cf):
			if fo >= cff:
				def res2(s, f=fo):
					if s == f:
						return '0'
					elif s >= cff:
						return '1'
					else:
						return '0'
			else:
				def res2(s):
					return '0'
			return res2
	return res
n, a, b = map(int, input().split())
c = a*b
if a+b == c+1 and (c > 1 or n == 1 or n > 3):
	print(""YES"")
	if c == 1:
		get_sign_f = get_sign_1
	else:
		get_sign_f = get_signs_2(c, c == b)
	for foo in range(n):
		print(''.join(map(get_sign_f(foo), range(n))))
else:
	print(""NO"")
",quadratic,"constructive algorithms,graphs,implementation",943
"n,a,b = list( map(int, input().split()))

if min(a,b) >1:
    print('NO')
    exit()

m = max(a,b)

if m == 1:
    if n == 1:
        print('YES')
        print(0)
        exit()
    elif n < 4:
        print('NO')
        exit()
    else:
        print('YES')
        for row in range(n):
            line = ['0']*n
            if row >0:
                line[row-1] = '1'
            if row <n-1:
                line[row+1] = '1'
            print(''.join(line))
    exit()

print('YES')

if a == 1:
    c = '1'
    d = '0'
else:
    c = '0'
    d = '1'
for row in range(n):
    if row < m-1:
        line = [c]*n
    else:
        line = [c]*(m-1)+ [d]*(n-m+1)
    line[row] = '0'

    print(''.join(line))
",quadratic,"constructive algorithms,graphs,implementation",711
"import sys

n,a,b = map(int, sys.stdin.readline().strip().split(' '))

ans = []
g = {i:set({}) for i in range(n)}

if a > 1 and b > 1:
	print(""NO"")
elif a == 1 and b == 1:
	if n == 1:
		print(""YES"")
		print(""0"")
	elif n < 4:
		print(""NO"")
	else:
		for i in range(n-1):
			g[i].add(i+1)
			g[i+1].add(i) 
		for i in range(n):
			tmp = []
			for j in range(n):
				if i in g[j]:
					tmp.append('1')
				else:
					tmp.append('0')
			ans.append(''.join(tmp))
		print(""YES"")
		print('\n'.join(ans))
else:
	swap = False
	if a == 1:
		a, b = b, a
		swap = True
	for i in range(a-1,n-1):
		g[i].add(i+1)
		g[i+1].add(i) 
	if swap:
		for i in range(n):
			tmp = []
			for j in range(n):
				if i == j:
					tmp.append('0')
				elif i not in g[j]:
					tmp.append('1')
				else:
					tmp.append('0')
			ans.append(''.join(tmp))
	else:
		for i in range(n):
			tmp = []
			for j in range(n):
				if i in g[j]:
					tmp.append('1')
				else:
					tmp.append('0')
			ans.append(''.join(tmp))
	print(""YES"")
	print('\n'.join(ans))",quadratic,"constructive algorithms,graphs,implementation",1016
"def read():
    return int(input())


def readlist():
    return list(map(int, input().split()))


def readmap():
    return map(int, input().split())


N, A, B = readmap()

if N == 1:
    print(""YES"")
    print(0)

elif N == 2:
    if A == 1 and B == 2:
        print(""YES"")
        print(""01"")
        print(""10"")
    elif A == 2 and B == 1:
        print(""YES"")
        print(""00"")
        print(""00"")
    else:
        print(""NO"")

elif N == 3:
    if A == 1 and B == 2:
        print(""YES"")
        print(""011"")
        print(""100"")
        print(""100"")
    elif A == 2 and B == 1:
        print(""YES"")
        print(""001"")
        print(""000"")
        print(""100"")
    elif A == 1 and B == 3:
        print(""YES"")
        print(""011"")
        print(""101"")
        print(""110"")
    elif A == 3 and B == 1:
        print(""YES"")
        print(""000"")
        print(""000"")
        print(""000"")
    else:
        print(""NO"")

else:
    if A != 1 and B != 1:
        print(""NO"")
    else:
        print(""YES"")
        if B == 1 and A != 1:
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= A:
                            vec.append(1)
                        else:
                            vec.append(0)
                    mat.append(vec)
                else:
                    vec = [0] * N
                    if i >= A:
                        vec[0] = 1
                    mat.append(vec)

            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
        elif A == 1 and B != 1:
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= B:
                            vec.append(0)
                        else:
                            vec.append(1)
                    vec[i] = 0
                    mat.append(vec)
                else:
                    vec = [1] * N
                    if i >= B:
                        vec[0] = 0
                    vec[i] = 0
                    mat.append(vec)

            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
        else:  # A == 1 and B == 1
            mat = []
            for i in range(N):
                vec = []
                if i == 0:
                    for j in range(N):
                        if j >= 2:
                            vec.append(1)
                        else:
                            vec.append(0)
                    mat.append(vec)
                else:
                    vec = [0] * N
                    if i >= 2:
                        vec[0] = 1
                    mat.append(vec)

            mat[1][2] = 1
            mat[2][1] = 1
            for n in range(N):
                print("""".join(list(map(str, mat[n]))))
",quadratic,"constructive algorithms,graphs,implementation",2939
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
",quadratic,"constructive algorithms,graphs,implementation",322
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
print('\n'.join(map(lambda x: ''.join(map(str, x)), r)))
",quadratic,"constructive algorithms,graphs,implementation",345
"import math;
def getIntList():
    return list(map(int, input().split()));
def getTransIntList(n):
    first=getIntList();
    m=len(first);
    result=[[0]*n for _ in range(m)];
    for i in range(m):
        result[i][0]=first[i];
    for j in range(1, n):
        curr=getIntList();
        for i in range(m):
            result[i][j]=curr[i];
    return result;
n, a, b = getIntList();
if a>1 and b>1:
    print('NO');
elif a==b==1 and (n==2 or n==3):
    print('NO');
else:
    c=max(a, b);
    m=[[0]*n for _ in range(n)];
    for i in range(n-c):
        m[i][i+1]=1;
        m[i+1][i]=1;
    if b>1:
        for i in range(n):
            for j in range(n):
                if i!=j:
                    m[i][j]=1-m[i][j];
    print('YES');
    for i in range(n):
        print(''.join(map(str, m[i])));",quadratic,"constructive algorithms,graphs,implementation",810
"def i_ints():
    return list(map(int, input().split()))

#############

n, a, b = i_ints()
def calc():
    if min(a, b) != 1:
        print(""NO"")
        return
    if a == b == 1 and n in (2, 3):
        print(""NO"")
        return
    
    print(""YES"")
    ONE, ZERO = ""10"" if a > 1 else ""01""

    edges = n - max(a, b)
    line = ""0"" + (ZERO, ONE)[edges>0]*(n>1) + ZERO * (n-2)
    print(line)
    
    for y in range(1, n):
        line = ZERO * (y-1) + (ZERO, ONE)[y<=edges] + ""0""
        if y < n-1:
            line += (ZERO, ONE)[y < edges] + ZERO * (n-y-2)
        print(line)
                
                

calc()

",quadratic,"constructive algorithms,graphs,implementation",629
"n, a, b = map(int, input().split())
if a > 1 < b or a * b == 1 and 1 < n < 4:
    print('NO')
else:
    z, o = ('01', '10')[a < b]
    l = [[z] * n for _ in range(n)]
    for i in range(n):
        l[i][i] = '0'
    for i in range(n - a * b):
        l[i][i + 1] = l[i + 1][i] = o
    print('YES')
    print('\n'.join(map(''.join, l)))",quadratic,"constructive algorithms,graphs,implementation",335
"n, a, b = map(int, input().split())
z, o = ('01', '10')[a < b]
n *= not (a > 1 < b or 1 < n * a * b < 4)
l = [[z] * n for _ in range(n)]
for i in range(n):
    l[i][i] = '0'
for i in range(n - a * b):
    l[i][i + 1] = l[i + 1][i] = o
print(('YES', 'NO')[not n])
print('\n'.join(map(''.join, l)))",quadratic,"constructive algorithms,graphs,implementation",296
"n, a, b = map(int, input().split())
if a != 1 and b != 1:
    print(""NO"")
else:

    con_char = '1'
    discon_char = '0'
    if a == 1:
        con_char = '0'
        discon_char = '1'
        t = a
        a = b
        b = t

    if a > 1:
        print(""YES"")
        n_con = n - a + 1
        for i in range(n):
            res = []
            for j in range(n):
                if i == j:
                    res.append('0')
                elif i < n_con and j < n_con:
                    res.append(con_char)
                else:
                    res.append(discon_char)
            print(''.join(res))
    else:
        if n == 1 or n > 3:
            print(""YES"")
            # a = b = 1
            for i in range(n):
                res = []
                for j in range(n):
                    if i == j:
                        res.append('0')
                    elif abs(i-j) == 1:
                        res.append('1')
                    else:
                        res.append('0')
                print(''.join(res))
        else:
            print(""NO"")
",quadratic,"constructive algorithms,graphs,implementation",1086
"import sys
n,a,b = list(map(int, input().split()))

if a>1 and b>1:
	print('NO')
	sys.exit(0)

if n==3 and a==1 and b==1:
	print('NO')
	sys.exit(0)

if n==2 and a==1 and b==1:
	print('NO')
	sys.exit(0)



t = [[0 for i in range(n)] for j in range(n)]

comp = max(a,b)


for i in range(comp-1, n-1):
	t[i][i+1] = 1
	t[i+1][i] = 1

if b>1:
	for i in range(n):
		for j in range(n):
			if i!=j:
				t[i][j] = 1-t[i][j]
print('YES')
for i in range(n):
	print("""".join(map(str, t[i])))
",quadratic,"constructive algorithms,graphs,implementation",479
"n, a, b = map(int, input().split())
if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))): 
    print(""NO"")
    exit()
res = [[0] * n for _ in range(n)]
for i in range(0, n - max(a, b)):
    res[i][i + 1] = res[i + 1][i] = 1
if a == 1:
    res = [[e ^ 1 for e in l] for l in res]

print(""YES"")
for i in range(n):
    res[i][i] = 0
    print(*res[i], sep='')",quadratic,"constructive algorithms,graphs,implementation",362
"n, a, b = map(int, input().split())
if min(a, b) > 1 or ((n, a, b,) in ((2, 1, 1), (3, 1, 1))): 
    print(""NO"")
    exit()
res = [[0] * n for _ in range(n)]
for i in range(0, n - max(a, b)):
    res[i][i + 1] = res[i + 1][i] = 1
if a == 1:
    res = [[e ^ 1 for e in l] for l in res ]

print(""YES"")
for i in range(n):
    res[i][i] = 0
    print(*res[i], sep='')",quadratic,"constructive algorithms,graphs,implementation",363
"
from collections import defaultdict

n,a,b = map(int,input().split())

hash = defaultdict(list)

# debug
# def dfs(n):
# 
# 
#     bool[n] = True
#     for i in hash[n]:
#         if bool[i] == False:
#             dfs(i)



if a == 1 and b == 1:
    if n == 2 or n == 3:
        print('NO')
        exit()

if a == 1 or b == 1:


    bool = [False]*(n+1)

    if a>n or b>n:
        print('NO')
        exit()
    print('YES')

    l = []
    for i in range(n):
        z = ['0']*(n)
        l.append(z)
    ans = []

    for i in range(n):
        z = ['0']*(n)
        ans.append(z)

    if b == 1:




        for i in range(a-1,n-1):
            # hash[i].add(i+1)
            # hash[i+1].add(i)
            l[i][i+1] = '1'
            l[i+1][i] = '1'
            # hash[i+1].append(i)
            # hash[i].append(i+1)


        # count = 0
        # for i in range(n):
        #     if bool[i] == False:
        #
        #         dfs(i)
        #         count+=1
        # if a == 1 and b == 1:

        for i in l:
            print(''.join(i))
    else:


        ans = []

        for i in range(n):
           z = ['0']*(n)
           ans.append(z)

        for i in range(b-1,n-1):
            # hash[i].add(i+1)
            # hash[i+1].add(i)
            l[i][i+1] = '1'
            l[i+1][i] = '1'
            # hash[i+1].append(i)
            # hash[i].append(i+1)
        # for i in l:
        #     print(*i)
        for i in range(n):
            for j in range(n):
                if i!=j:
                    if l[i][j] == '1':
                        ans[i][j] = '0'
                    if l[i][j] == '0':
                        ans[i][j] = '1'
                        # hash[i+1].append(j+1)
        # count = 0
        # for i in range(n):
        #     if bool[i] == False:
        #
        #         dfs(i)
        #         count+=1


        for i in ans:
            print(''.join(i))



else:
    print('NO')

",quadratic,"constructive algorithms,graphs,implementation",1945
"n,a,b=map(int,input().split())
if a>n:
    print('NO')
    exit()
if b>n:
    print(""NO"")
    exit()
if a==1  and b==1:
    if n==2 or n==3:
        print('NO')
        exit()
if n==1 and a>1 or n==1 and b>1:
    print('NO')
    exit()
if min(a,b)>1:
    print('NO')
    exit() 

def check(mat):
    vis=[0]*n 
    cnt=0
    for i in range(n):
        if vis[i]==0:
            q=[i]
            cnt+=1 
            vis[i]=1  
            while q:
                t=q.pop(0)
                for j in range(n):
                    if mat[t][j]==1 and vis[j]==0:
                        vis[j]=1 
                        q.append(j)
        return cnt 
mat=[[0 for i in range(n)] for j in range(n)]
m=max(a,b)
j=1 
for i in range(n):
    if j<n:
        mat[i][j]=1 
        mat[j][i]=1 
    j+=1 
for i in range(m-1):
    curr=n-i-1 
    for j in range(n):
        if mat[curr][j]==1:
            mat[curr][j]=0 
            mat[j][curr]=0 
if b==1:
    print('YES')
    for i in range(n): 
        print(*mat[i],sep='')
    
else:
    print('YES')
    for i in range(n):
        for j in range(n):
            mat[i][j]=1-mat[i][j]
    for i in range(n):
        mat[i][i]=0
    for i in range(n):
        print(*mat[i],sep='')",quadratic,"constructive algorithms,graphs,implementation",1227
"n, a, b = map(int, input().split())
if (n == 3 or n == 2) and (a == 1 and b == 1):
    print(""NO"")
    exit(0)
g = [[0 for i in range(n)] for j in range(n)]
if a > 1 and b == 1:
    for i in range(n - a - 1, -1, -1):
        g[i][i + 1] = g[i + 1][i] = 1
elif b > 1 and a == 1:
    a, b = b, a
    for i in range(n - a - 1, -1, -1):
        g[i][i + 1] = g[i + 1][i] = 1
    for i in range(n):
        for j in range(n):
            if g[i][j] == 0:
                g[i][j] = 1
            elif g[i][j] == 1:
                g[i][j] = 0
    for i in range(n):
        g[i][i] = 0
elif a == 1 and b == 1:
    for i in range(n - 1):
        g[i][i + 1] = g[i + 1][i] = 1
elif a > 1 and b > 1:
    print(""NO"")
    exit(0)
print(""YES"")
for i in range(n):
    for j in range(n):
        print(g[i][j], end='')
    print()",quadratic,"constructive algorithms,graphs,implementation",816
"n, a, b = map(int, input().split())
z, o = ('01', '10')[a < b]
n *= not (a > 1 < b or 1 < n * a * b < 4)
l = [[z] * n for _ in range(n)]
for i in range(n):
    l[i][i] = '0'
for i in range(n - a * b):
    l[i][i + 1] = l[i + 1][i] = o
print(('YES', 'NO')[not n])
print('\n'.join(map(''.join, l)))

  			      		 			 	 		  						",quadratic,"constructive algorithms,graphs,implementation",328
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
					    	  	    	        	   	",quadratic,"constructive algorithms,graphs,implementation",353
"n, a, b = map(int, input().split())
if min(a, b) > 1 or 1 < n < 4 and max(a, b) == 1:
    print('NO')
    exit()
print('YES')
f = int(a == 1)
g = [a, b][f]
r = [[f] * n for i in range(n)]
for i in range(n):
    r[i][i] = 0
for i in range(n - g):
    r[i][i + 1] ^= 1
    r[i + 1][i] ^= 1
for x in r:
    print(*x, sep='')
johnny=0
 	 	 	 			   		 		  				 				",quadratic,"constructive algorithms,graphs,implementation",360
"# import sys
# input=sys.stdin.readline


n,a,b=list(map(int,input().split()))
d=[]
for i in range(n):
    d.append([""1""]*n)
    d[i][i]=""0""
if [n,a,b]==[2,1,1]:
    print(""NO"")
elif [n,a,b]==[3,1,1]:
    print(""NO"")
elif a==1:
    c=n-b
    for i in range(c):
        d[i][i+1]=""0""
        d[i+1][i]=""0""
    print(""YES"")
    for i in range(n):
        print("""".join(d[i]))
elif a!=1 and b!=1:
    print(""NO"")
else:
    print(""YES"")
    for i in range(a-1):
        for j in range(n):
            d[i][j]=""0""
        for j in range(n):
            d[j][i]=""0""
    for i in range(n):
        print("""".join(d[i]))",quadratic,"constructive algorithms,graphs,implementation",611
"n, a, b = map(int, input().strip().split())

if min(a, b) > 1:
    print('NO')
    exit(0)

M = [[0] * n for _ in range(n)]

if a == 1 and b == 1:
    if n == 1:
        print('YES')
        print('0')
        exit(0)
    if n == 2 or n == 3:
        print('NO')
        exit(0)    
    for i in range(1, n):
        M[i - 1][i] = 1
        M[i][i - 1] = 1    
else:
    # assume b == 1
    s = n - max(a, b) + 1
    for i in range(s):
        for j in range(s):
            if i != j:
                M[i][j] = 1
    if a == 1:
        for i in range(n):
            for j in range(n):
                if i != j:
                    M[i][j] = 1 - M[i][j]

print('YES')
for i in range(n):
    print(''.join(map(str, M[i])))",quadratic,"constructive algorithms,graphs,implementation",723
"n, m = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))
lst = []
for i in range(len(a)):
    if (a[i] in b):
        lst.append(a[i])
if (len(lst) == 0):
    pass
else:
    print(*lst)
",quadratic,implementation,240
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
l=list()
for i in range(m):
    for j in range(n):
        if(y[i]==x[j]):
            l.append(j)
print(' '.join(map(str,[x[i] for i in sorted(l)])))",quadratic,implementation,245
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
l=[]
for i in range(m):
    if y[i] in x:
        l.append(x.index(y[i]))
l.sort()
for i in l:
    print(x[i],end="" "")",quadratic,implementation,213
"n,m=map(int,input().split())
list1=list(map(int,input().split()))
list2=list(map(int,input().split()))
for i in list1:
    if i in list2:
        print(i,end=' ')
",quadratic,implementation,163
"n,m = map(int,input().split())
arr1 = list(map(int,input().split()))
arr2 = list(map(int,input().split()))

print(*sorted([x for x in arr2 if x in arr1],key = lambda k:arr1.index(k)))",quadratic,implementation,183
"# import os

n,m = map(int,input().split())

a = list(map(int,input().split()))
b = list(map(int,input().split()))

r = []

for i in a:
    if i in b:
        r.append(i)
print(' '.join(map(str, r)))


",quadratic,implementation,202
"# sys.setrecursionlimit(300000)
import sys
def main():
    pass
def binary(n):
    # decimal to binary
    return (bin(n).replace(""0b"", """"))
def decimal(s):
    # binary to decimal
    return (int(s, 2))
def pow2(n):
    # power of a number base 2
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
def isPrime(n):
    # if  number is prime in √n time
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
def lts(l):
    # list to string ,no spaces
    s = ''.join(map(str, l))
    return s
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# 1000000007
mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()
#s=input()
def iinp(): return int(input())
#n=int(input())
def nninp(): return map(int, sys.stdin.readline().strip().split())
#n, m, a=[int(x) for x in input().split()]
def llinp(): return list(map(int, sys.stdin.readline().strip().split()))
#a=list(map(int,input().split()))
def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
from collections import OrderedDict
from fractions import Fraction
#for _ in range(iinp()):
n,m=nninp()
x=llinp()
y=llinp()
for c in x:
    if(c in y):
        print(c,end="" "")



",quadratic,implementation,1764
"import sys
import math
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, sys.stdin.readline().strip().split()) 
def listinput(): return list(map(int, sys.stdin.readline().strip().split())) 
n,m=minput()
x=listinput()
y=listinput()
xx=set(x)
yy=set(y)
common=xx.intersection(yy)
for i in x:
    if i in common:
        print(i,end=' ')",quadratic,implementation,404
"a,b=map(int,input().split())
c=list(map(int,input().split()))
d=list(map(int,input().split()))
e=[]
for i in c:
    if i in d:
        e.append(i)
for j in e:
    print(j,end="" "")",quadratic,implementation,179
"n , m=map(int,input().split())
l1=list(map(int,input().split()))
l2=list(map(int,input().split()))
l3=[]
for i in range(n):
    for j in range(m):
        if l1[i]==l2[j]:
            if l1[i] is not l3:
                l3.append(l1[i])
print(*l3)
                ",quadratic,implementation,264
"n,m=map(int,input().split())
seq=list(map(str,input().split()))
fp=list(map(str,input().split()))
checklist=[]
for number in seq:
    if(number in fp):
        checklist.append(number)
print("" "".join(checklist))",quadratic,implementation,211
"n,m = map(int,input().split())
arr1 = [int(i) for i in input().split()]
arr2 = [int(i) for i in input().split()]
# arr3 = []
for first in arr1:
    for second in arr2:
        if first == second:
            # arr3.append(first)
            print(first,end="" "")",quadratic,implementation,261
"n,m=map(int,input().split())
x=list(map(int,input().split()))
y=list(map(int,input().split()))
out=[]
first=11
for a in range(len(x)):
    for b in range(len(y)):
        #print(a,b,end="" "")
        if y[b]==x[a]:
            if first<a:
                first=a;
                out.append(y[b])
                #print(1,first,out,x[a],y[b])
                b+=1
                
            else:
                out.insert(0,y[b])
                #print(2,first,out,x[a],y[b])
                b+=1
                
        else:
            
           # print(first,out,x[a],y[b])
            b+=1
out.reverse()
for a in out:
    print(a)",quadratic,implementation,641
"n, m = map(int, input().split())
a = map(int, input().split())
b = list(map(int, input().split()))
for x in a:
    if x in b:
        print(x, end=' ')

",quadratic,implementation,153
"n,m=(int(x) for x in input().split())
sequence=input().split()[:n]
fingerprint=input().split()[:m]
print("" "".join(i for i in sequence if i in fingerprint))",quadratic,implementation,155
"n,m=map(int,input().split())
l1=list(map(int,input().split()))
l2=list(map(int,input().split()))
# set1=set(l1)
# set2=set(l2)
# final=set1.intersection(set2)

for i in l1:
    if i in l2:
        print(i,end="" "")
    ",quadratic,implementation,218
"n,m=map(int,input().split())
seq=[int(i) for i in input().split()][:n]
f=[int(i) for i in input().split()][:m]
a=[]
for i in range(n):
    for j in range(m):
        if(seq[i]==f[j]):
            a.append(seq[i])

for i in range(len(a)):
    print(a[i],end=' ')",quadratic,implementation,261
"n,k=[int(x) for x in input().split()]
lst1=[int(x) for x in input().split()]
lst2=[int(x) for x in input().split()]
lst3={}
ans=[]
for i in lst2:
    if(i in lst1):
        
        lst3[i]=lst1.index(i)
for i in sorted(lst3,key=lst3.get):
    ans.append(i)
#print(lst3)
print(*ans,sep="" "")
",quadratic,implementation,291
"'''     Design by Dinh Viet Anh(JOKER)
//_____________________________________$$$$$__
//___________________________________$$$$$$$$$
//___________________________________$$$___$
//___________________________$$$____$$$$
//_________________________$$$$$$$__$$$$$$$$$$$
//_______________________$$$$$$$$$___$$$$$$$$$$$
//_______________________$$$___$______$$$$$$$$$$
//________________$$$$__$$$$_________________$$$
//_____________$__$$$$__$$$$$$$$$$$_____$____$$$
//__________$$$___$$$$___$$$$$$$$$$$__$$$$__$$$$
//_________$$$$___$$$$$___$$$$$$$$$$__$$$$$$$$$
//____$____$$$_____$$$$__________$$$___$$$$$$$
//__$$$$__$$$$_____$$$$_____$____$$$_____$
//__$$$$__$$$_______$$$$__$$$$$$$$$$
//___$$$$$$$$$______$$$$__$$$$$$$$$
//___$$$$$$$$$$_____$$$$___$$$$$$
//___$$$$$$$$$$$_____$$$
//____$$$$$$$$$$$____$$$$
//____$$$$$__$$$$$___$$$
//____$$$$$___$$$$$$
//____$$$$$____$$$
//_____$$$$
//_____$$$$
//_____$$$$
'''
from math import *
from cmath import *
from itertools import *
from decimal import *  # su dung voi so thuc
from fractions import *  # su dung voi phan so
from sys import *
from types import CodeType, new_class
#from numpy import *

'''getcontext().prec = x # lay x-1 chu so sau giay phay (thuoc decimal)
Decimal('12.3') la 12.3 nhung Decimal(12.3) la 12.30000000012
Fraction(a) # tra ra phan so bang a (Fraction('1.23') la 123/100 Fraction(1.23) la so khac (thuoc Fraction)
a = complex(c, d) a = c + d(i) (c = a.real, d = a.imag)
a.capitalize() bien ki tu dau cua a(string) thanh chu hoa, a.lower() bien a thanh chu thuong, tuong tu voi a.upper()
a.swapcase() doi nguoc hoa thuong, a.title() bien chu hoa sau dau cach, a.replace('a', 'b', slg)
chr(i) ki tu ma i ord(c) ma ki tu c
a.join['a', 'b', 'c'] = 'a'a'b'a'c, a.strip('a') bo dau va cuoi ki tu 'a'(rstrip, lstrip)
a.split('a', slg = -1) cat theo ki tu 'a' slg lan(rsplit(), lsplit()), a.count('aa', dau = 0, cuoi= len(a)) dem slg
a.startswith('a', dau = 0, cuoi = len(a)) co bat dau bang 'a' ko(tuong tu endswith())
a.index(""aa"") vi tri dau tien xuat hien (rfind())
input = open("".inp"", mode='r')  a = input.readline()
out = open("".out"", mode='w') a.index(val) '''
#inn = open("".inp"", ""r"")

n, m = map(int, (input().split()))
a = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
for x in a:
    if x in b:
        print(x, end = ' ')",quadratic,implementation,2326
"n, m = map(int, input().split())
a = [int(i) for i in input().split()]
b = [int(i) for i in input().split()]
for i in a:
    if i in b:
        print(i, end=' ')",quadratic,implementation,161
"n = int(input())
l = list(map(int,input().split()))
i = 0
ans = 0
while i < len(l)-1:
    if l[i] == l[i+1]:
        i = i+1
        continue

    j = i+1
    ind = -1
    while j < len(l):
        if l[j] == l[i]:
            ind = j
            break

        j = j+1

    while ind > i+1:
        l[ind],l[ind-1] = l[ind-1],l[ind]
        ans += 1
        ind -= 1

    i += 1

print(ans)",quadratic,"greedy,implementation,math",391
"n=int(input())
l=list(map(int,input().split()))
ans=0
m=[]
for i in range(2*n-1,-1,-1):
    if l[i] not in m:
        m.append(l[i])

for tt in range(0,n):
    i=m[tt]
    j=l.index(i)
    l.pop(j)
    k=l.index(i)
    l.insert(k,j)
    ans+=k-j
print(ans)
",quadratic,"greedy,implementation,math",257
"n=int(input())
l=[int(x) for x in input().split()]
ans=0;
while len(l)>0:
	a=l[0]
	l=l[1:]
	ans+=l.index(a)
	l.remove(a)
print(ans)",quadratic,"greedy,implementation,math",131
"n = int(input())
a = list(map(int, input().split()))
ans = 0
pos = 2*n - 2
for i in range(n):
	x = a[-1]
	a.pop(-1)
	y = a.index(x)
	ans += pos - y
	pos -= 2
	a.pop(y)
print(ans)
 	 	   			   		  		  	       	",quadratic,"greedy,implementation,math",209
"n = int(input())
ar = [int(i) for i in input().split()]
ans = 0
for i in range(2*n):
    for j in range(i+1,2*n):
        if ar[i]==ar[j]:
            while j!=i+1:
                ar[j],ar[j-1]=ar[j-1],ar[j]
                j-=1
                ans+=1
print(ans)
		 				 			    		 	  		  	  		",quadratic,"greedy,implementation,math",294
"n = int(input())

pairs = [int(i) for i in input().split("" "")]

N=len(pairs)
N//=2
visited = [False] * (N + 1)  
  
minimumSwaps = 0

for i in range(2 * N) :   
    if (visited[pairs[i]] == False) :  
        visited[pairs[i]] = True 
        count = 0 
        for j in range( i + 1, 2 * N) :   
            if (visited[pairs[j]] == False) : 
                count += 1 
            elif (pairs[i] == pairs[j]) : 
                minimumSwaps += count 
print(minimumSwaps)
       			  			 	  		 	 	   			",quadratic,"greedy,implementation,math",505
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
from io import BytesIO, IOBase
import sys
from collections import defaultdict, deque, Counter
from math import sqrt, pi, ceil, log, inf, gcd, floor
from itertools import combinations, permutations
from bisect import *
from fractions import Fraction
from heapq import *
from random import randint

def main():
    n=int(input())
    a=list(map(int,input().split()))
    ans=0
    for i in range(0,2*n,2):
        if a[i]!=a[i+1]:
            for j in range(i+1,2*n):
                if a[j]==a[i]:
                    for k in range(j,i+1,-1):
                        a[k],a[k-1]=a[k-1],a[k]
                        ans+=1
                    break
    print(ans)

# region fastio
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",quadratic,"greedy,implementation,math",2442
"import sys
input = sys.stdin.readline

'''

'''

n = int(input())
a = list(map(int, input().split()))
swaps = 0
for i in range(0, 2*n, 2):
    if a[i] == a[i+1]:
        continue
    
    c = a[i]
    j = i + 2
    while c != a[j]:
        j += 1
    
    MIN = i+1
    while j > MIN:
        a[j], a[j-1] = a[j-1], a[j]
        j -= 1
        swaps += 1

print(swaps)
",quadratic,"greedy,implementation,math",369
"n=2*int(input())
a=list(map(int,input().split()))
z=0
for i in range(0,n-1,2):
    if a[i]!=a[i+1]:
        for j in range(i+1,n):
            if a[j]==a[i]:
                z+=j-i-1
                a.pop(j)
                a.insert(i+1,a[i])
print(z)",quadratic,"greedy,implementation,math",251
"n=int(input())
arr=list(map(int,input().split()));ans=0
while len(arr)!=0:
 e=arr.pop(0)
 ans+=arr.index(e)
 arr.remove(e)
print(ans)
 

  
",quadratic,"greedy,implementation,math",140
"n=int(input())
a=list(map(int,input().split()))
p=0
while p+1<len(a) and a[p]==a[p+1]:
    p+=2
c=0
while p<len(a):
    if p+1<len(a):
        i=a.index(a[p],p+1)
        c+=i-p-1
        tmp=a.pop(i)
        a.insert(p,tmp)
    while p+1<len(a) and a[p]==a[p+1]:
        p+=2
print(c)",quadratic,"greedy,implementation,math",285
"n=int(input())
lst = list(map(int, input().strip().split(' ')))
c=0
while(len(lst)!=0):
    p=lst[0]
    del lst[0]
    i=lst.index(p)
    c+=i
    del lst[i]
print(c)
    ",quadratic,"greedy,implementation,math",172
"n=int(input())
a=list(map(int,input().split()))
ans=0
while len(a)>0:
    c=a.pop(0)
    i=a.index(c)
    ans+=i
    del a[i]
print(ans)",quadratic,"greedy,implementation,math",136
"n = int(input())

xs = [int(x) for x in input().split()]

seen = {}

res = 0

while xs:
    j = xs.index(xs[0], 1)
    res += j - 1
    xs = xs[1:j] + xs[j+1:]

print(res)
",quadratic,"greedy,implementation,math",172
"n = int(input())
t = list(map(int, input().split()))

sw = 0

while t != []:
	pr = 1 + t[1:].index(t[0])
	#print(pr)
	sw += pr-1
	#print(t[1:pr], t[pr+1:])
	t = t[1:pr] + t[pr+1:]
	#print(t)

print(sw)
",quadratic,"greedy,implementation,math",202
"
import sys
#sys.stdin=open(""data.txt"")
input=sys.stdin.readline

n=int(input())

c=list(map(int,input().split()))
ans=0

for i in range(n):
    # match the first person
    f=c.pop(0)
    g=c.index(f)
    c.pop(g)
    ans+=g

print(ans)",quadratic,"greedy,implementation,math",237
"n = int(input())
l = [-1] * n
r = [-1] * n
a = list(map(int, input().split()))
for i in range(2 * n):
    x = a[i] - 1
    if l[x] == -1: l[x] = i
    r[x] = i
ans = 0
for i in range(n):
    for j in range(n):
        if l[i] < l[j] < r[j] < r[i]: ans += 2
for i in range(n):
    ans += r[i] - l[i] - 1
print(ans // 2)",quadratic,"greedy,implementation,math",318
"#!/usr/bin/env python3

def main():
    n = int(input())
    a = list(map(int, input().split()))
    r = 0
    while a:
        c = a[0]
        del a[0]
        for i in range(len(a)):
            if c == a[i]:
                break
        del a[i]
        r += i
    print(r)

if __name__ == ""__main__"":
    main()
",quadratic,"greedy,implementation,math",318
"def mp():return map(int,input().split())
def it():return int(input())

n,k=mp()
l=list(mp())
ans=0
for i in range(n):
	avg,count=0,0
	for j in range(i,n):
		count+=l[j]
		if j-i+1>=k:
			avg=count/(j-i+1)
		ans=max(avg,ans)
print(ans)
",quadratic,"brute force,implementation,math",235
"def helper(n,k,l):
	
	res = 0
	for i in range(n-k+1):
		base_seg = l[i:i+k]
		sm_bseg = sum(base_seg)
		ln_bseg = len(base_seg)
		ans = sm_bseg/ln_bseg

		for j in range(i+k,n):
			sm_bseg+=l[j]
			ln_bseg+=1
			ans=max(ans,sm_bseg/ln_bseg)


		res = max(res,ans)

	return res

n,k = map(int,input().split())
l = list(map(int,input().split()))

print(helper(n,k,l))",quadratic,"brute force,implementation,math",365
"import sys
import math
import collections
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n,k=get_ints()
    arr=get_list()
    ans=0
    for i in range(n):
        val=arr[i]
        c=1
        sol=0
        if c >= k:
            sol = max(sol, val / c)
        for j in range(i+1,n):
            val+=arr[j]
            c+=1
            if c>=k:
                sol=max(sol,val/c)
        ans=max(sol,ans)
    print(ans)",quadratic,"brute force,implementation,math",599
"def main():
    n,k=map(int,input().split( ))
    a=list(map(int,input().split( )))
    ans=-1*10**9+7
    for i in range(n):
        s=0
        for j in range(i,n):
            s+=a[j]
            if j-i+1>=k:

                ans=max(ans,s/(j-i+1))
    print(ans)

    
main()",quadratic,"brute force,implementation,math",279
"import math
for _ in range(1):
    n,k=map(int,input().split())
    l=list(map(int,input().split()))
    ans=0
    for i in range(n):
	    c=0
	    sum1=0
	    for j in range(i, n):
		    sum1 += l[j]
		    c+=1
		    if c >= k:
			    ans=max(ans,sum1/c)
print(ans)    
                
            
        ",quadratic,"brute force,implementation,math",309
"from collections import Counter
import string
import math
import sys
# sys.setrecursionlimit(10**6) 
from fractions import Fraction
def array_int():
    return [int(i) for i in sys.stdin.readline().split()]
def vary(arrber_of_variables):
    if arrber_of_variables==1:
        return int(sys.stdin.readline())
    if arrber_of_variables>=2:
        return map(int,sys.stdin.readline().split()) 
def makedict(var):
    return dict(Counter(var))
testcases=1
for _ in range(testcases):
    n,k=vary(2)
    num=array_int()
    maxi=0.0
    for i in range(n):
        count=1
        sumt=num[i]
        # print(sumt)
        for j in range(i+1,n):
            sumt+=num[j]
            count+=1
            if count>=k:
                # print(sumt,sumt/count)
                maxi=max(maxi,sumt/count)
        # print(maxi)
    if k==1:
        print(max(maxi,max(num)))
    else:
        print(maxi)
    



",quadratic,"brute force,implementation,math",905
"import sys, heapq

n, k = map(int, sys.stdin.readline().split())
arr = list(map(int, sys.stdin.readline().split()))
pf = [0] * (n + 1)
pf[0] = arr[0]
for i in range(1, n):
    pf[i] = pf[i - 1] + arr[i]
ans = 0
for i in range(n):
    for j in range(n):
        left = i
        right = j
        if right - left + 1 >= k:
            temp = pf[right] - pf[left - 1]
            ans = max(ans, temp / (right - left + 1))
print(ans)",quadratic,"brute force,implementation,math",430
"#------------------------template--------------------------#
import os
import sys
# from math import *
from collections import *
# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M= 998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()




n,k = value()
a = array()

ans = 0

for i in range(n-k+1):

    num = sum(a[i:i+k])
    den = k
    ans = max(ans , num/den)

    for j in range(i+k,n):

        num += a[j]
        den += 1
        ans = max(ans , num/den)

print(ans)
































",quadratic,"brute force,implementation,math",2612
"
import sys
input = sys.stdin.buffer.readline

n,k=map(int,input().split())
arr=[int(x) for x in input().split()]

x=0
dp=[]
for i in range(n):
    x=x+arr[i]
    dp.append(x)

ans=0
for i in range(n):
    for j in range(i+k-1,n):
        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))
print(ans) ",quadratic,"brute force,implementation,math",294
"n, k = map(int, input().split())
li = [int(num) for num in input().split("" "", n - 1)]
ans = []
for i in range(0, n):
    su = 0
    for j in range(i, n):
        su += li[j]
        if (j - i + 1 >= k):
            ans.append(su / (j - i + 1))
print(max(ans))",quadratic,"brute force,implementation,math",259
"from sys import *

n, k = map(int, stdin.readline().split())
arr = list(map(int, stdin.readline().split()))
avg = 0
for i in range(n):
	cnt = 0
	sum = 0
	for j in range(i, n):
		sum += arr[j]
		cnt += 1
		if cnt >= k:
			avg = max(avg, sum / cnt)
print(avg)",quadratic,"brute force,implementation,math",257
"import sys
input = sys.stdin.buffer.readline
 
n,k=map(int,input().split())
arr=[int(x) for x in input().split()]
 
x=0
dp=[]
for i in range(n):
    x=x+arr[i]
    dp.append(x)
 
ans=0
for i in range(n):
    for j in range(i+k-1,n):
        ans=max(ans,((dp[j]-dp[i])+arr[i])/(j-i+1))
print(ans) ",quadratic,"brute force,implementation,math",296
"#=============================================================================
# @abhi_admin    FB UserId: abhiavisekkr     Email Id: abhiavisekkr@gmail.com
#=============================================================================
#------------------------------Dependencies-----------------------------------
#import sys
#import math
#import cmath
#import array
#import string
#import functools #for .reduce()
#import itertools 


#def get_s(): return sys.stdin.readline().strip() 
#def get_i(): return map(int, sys.stdin.readline().strip().split())


#=============================================================================
#----------------------------Keep-Calm-and-Code-------------------------------
#=============================================================================




n, k = map(int, input().split())
arr = list(map(int, input().split()))

rsum = [0]
maxx = 0.0

for i in range(n): rsum.append(rsum[-1] + arr[i])
#print(rsum)

for ki in range(k, n+1):
    for i in range(n-ki+1):
        tot = 0
        #print(i+ki, i)
        avg = (rsum[i+ki] - rsum[i])/ki
        #print(avg)
        maxx = max(maxx, avg)
print(maxx)



#=============================================================================
#-----------------------------ADMIN-ABHI-SHAKE--------------------------------
#=============================================================================",quadratic,"brute force,implementation,math",1392
"n,m=map(int,input().split())
lst=list(map(int,input().split()))
maxx=0
arr=[0]*(n+1)
for i in range(n):
    summ=0
    for j in range(i,n):
        summ+=lst[j]
        arr[j-i]=max(arr[j-i], summ/(j-i+1))
print(max(arr[m-1:]))",quadratic,"brute force,implementation,math",227
"
rd = lambda: list(map(int, input().split()))
n, k = rd()
a = rd()
r = 0
s = [0]
for x in a:
    s.append(s[-1] + x)
for i in range(n - k + 1):
    for j in range(i + k, min(n + 1, i + 2 * k)):
        r = max(r, (s[j] - s[i]) / (j - i))
print(r)
",quadratic,"brute force,implementation,math",247
"import sys
input = sys.stdin.buffer.readline

from collections import deque

n,d,k=map(int,input().split())

if d>=n:
    print(""NO"")
    exit()

graph=[[] for i in range(n+1)]

for i in range(1,d+2):
    graph[i].append(min(i-1,d+1-i))

# print(graph)

for i in range(1,d+1):
    graph[i].append(i+1)
    graph[i+1].append(i)
# print(graph)

deg=[0]*(n+1)
deg[1]=1
deg[d+1]=1
for i in range(2,d+1):
    deg[i]=2
# print(deg)
for i in deg:
    if i>k:
        print(""NO"")
        exit()

p=d+2
for i in range(1,d+2):
    q=deque()
    q.append(i)
    while len(q)!=0:
        x=q.popleft()
        while (graph[x][0]>0 and deg[x]<k and p<=n):
            graph[x].append(p)
            deg[x]=deg[x]+1
            graph[p].append(graph[x][0]-1)
            graph[p].append(x)
            deg[p]=deg[p]+1
            q.append(p)
            p=p+1
    # print(graph)        

if p<=n:
    print(""NO"")
else:
    print(""YES"")  
    vis=[-1]*(n+1)

    for i in range(1,d+2):
        if vis[i]==-1:
            q=deque()
            q.append(i)
            while len(q)!=0:
                x=q.popleft()
                vis[x]=1
                for j in range(1,len(graph[x])):
                    if vis[graph[x][j]]==-1:
                        print(x,graph[x][j])
                        q.append(graph[x][j])

",quadratic,"constructive algorithms,graphs",1310
"import sys

def pprint(s):
    sys.stdout.write(str(s) + ""\n"")

def solve(n, d, k):
    for i in range(1, d+1):
        pprint(str(i)  + ' ' + str(i+1))
        if i + 1 == n:
            exit()

    q = d+2
    for i in range(2, d+1):
        for j in range(k-2):
            pprint(str(i)  + ' ' + str(q))
            if q == n:
                exit()
            q += 1
            def rec(depth, current, head):
                if depth == 0:
                    return current

                for i in range(k-1):
                    pprint(str(head)  + ' ' + str(current))
                    if current == n:
                        exit()
                    current += 1
                        
                    current = rec(depth-1, current, current-1)

                return current

            if i <= (d+2)/2:
                depth = i-2
            else:
                depth = d-i

            q = rec(depth, q, q-1)


    




n, d, k = map(int, input().split())

q = k-1
maxi = 0
if k == 2:
    maxi = d+1
else:
    if d % 2:
        maxi = (q * (1-q**(d//2)) // (1-q) + 1) * 2
    else:
        maxi = (q * (1-q**(d//2-1)) // (1-q) + 1) * 3 + 1

if d == 2:
    maxi = k + 1

if n > maxi or n <= d:
    print(""NO"")
else:
    print(""YES"")
    solve(n, d, k)",quadratic,"constructive algorithms,graphs",1282
"import sys

input = sys.stdin.readline

def main():

	a = input().split("" "")
	n = int(a[0])
	d = int(a[1])
	k = int(a[2])

	if d > n - 1:
		sys.stdout.write(""NO\n"")
		return

	par = [-1 for i in range(n)]
	prevlevel = [0]
	bad = [False for i in range(n)]
	clevel = []
	cdep = 1
	callow = k
	cnode = 1
	firstchild = 1

	for i in range(1, n):

		if len(clevel) == callow:
			prevlevel = clevel
			clevel = []
			cdep += 1
			callow *= (k - 1)
			firstchild *= (k - 1)

		cdiv = k
		if cdep > 1:
			cdiv -= 1
		if cdiv == 0:
			sys.stdout.write(""NO\n"")
			return


		par[cnode] = prevlevel[len(clevel) // cdiv]
		clevel.append(cnode)

		cnode += 1

	mdep = d // 2
	# print(cdep)

	if cdep > mdep + 1:
		sys.stdout.write(""NO\n"")
		return

	if cdep == mdep + 1 and ((d % 2 == 0)):
		sys.stdout.write(""NO\n"")
		return

	# print(par)
	# print(len(clevel))
	if cdep == mdep + 1 and len(clevel) > firstchild:
		sys.stdout.write(""NO\n"")
		return

	attach1 = -1
	attach2 = -1

	d1 = cdep
	d2 = cdep
	
	attach1 = clevel[0]
	if len(clevel) > firstchild:
		attach2 = clevel[-1]
	else:
		attach2 = prevlevel[-1]
		d2 -= 1

	te = attach1
	while te != -1:
		bad[te] = True
		te = par[te]
	te = attach2
	while te != -1:
		bad[te] = True
		te = par[te]

	cptr = n - 1
	while d1 + d2 < d:
		if bad[cptr]:
			cptr -= 1
			continue

		if d2 < d1:
			par[cptr] = attach2
			attach2 = cptr
			d2 += 1
		else:
			par[cptr] = attach1
			attach1 = cptr
			d1 += 1

		cptr -= 1

	sys.stdout.write(""YES\n"")
	for i in range(1, n):
		sys.stdout.write(str(i + 1) + "" "" + str(par[i] + 1) + ""\n"")


main()",quadratic,"constructive algorithms,graphs",1571
"import heapq
import sys
input = sys.stdin.readline

n, d, k = map(int, input().split())
if n == 1 or n <= d:
    ans = ""NO""
elif k == 1:
    ans = ""YES"" if n == 2 and d == 1 else ""NO""
    e = [(1, 2)]
else:
    e = [(i + 1, i + 2) for i in range(d)]
    h = []
    l, r = 1, d + 1
    if k > 2:
        for i in range(2, d + 1):
            heapq.heappush(h, (i, 2, min(i - l, r - i)))
    ans = ""YES""
    for i in range(d + 2, n + 1):
        if not h:
            ans = ""NO""
            break
        j, k0, d0 = heapq.heappop(h)
        e.append((j, i))
        if k0 + 1 < k:
            heapq.heappush(h, (j, k0 + 1, d0))
        if d0 - 1 > 0:
            heapq.heappush(h, (i, 1, d0 - 1))
print(ans)
if ans == ""YES"":
    for u, v in e:
        print(u, v)",quadratic,"constructive algorithms,graphs",762
"from collections import deque
import sys
input = sys.stdin.readline

n, d, k = map(int, input().split())
if n == 1 or n <= d:
    ans = ""NO""
elif k == 1:
    ans = ""YES"" if n == 2 and d == 1 else ""NO""
    e = [(1, 2)]
else:
    e = [(i + 1, i + 2) for i in range(d)]
    q = deque()
    l, r = 1, d + 1
    if k > 2:
        for i in range(2, d + 1):
            q.append((i, 2, min(i - l, r - i)))
    ans = ""YES""
    for i in range(d + 2, n + 1):
        if not q:
            ans = ""NO""
            break
        j, k0, d0 = q.popleft()
        e.append((j, i))
        if k0 + 1 < k:
            q.append((j, k0 + 1, d0))
        if d0 - 1 > 0:
            q.append((i, 1, d0 - 1))
print(ans)
if ans == ""YES"":
    for u, v in e:
        print(u, v)",quadratic,"constructive algorithms,graphs",752
"def main():
    n, d, k = list(map(int, input().split()))
    if n == 2 and d == 1 and k == 1:
        print(""YES"")
        print(""1 2"")
        return 0
    if n == d + 1 and k - 1:
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        return 0
    if  n < d +1 or k <= 2 or d == 1:
        print(""NO"")
        return 0
    if d % 2 == 0:
        if n * (k - 2) > -2 + k * (k - 1) ** (d // 2):
            print(""NO"")
            return 0
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        nodes = d + 1
        leaves = [1 + d // 2]
        dev = 0
        while True:
            new_leaves = []
            for i in leaves:
                for j in range(k - 1 - (i <= d + 1)):
                    nodes += 1
                    print(i, nodes)
                    new_leaves.append(nodes)
                    if nodes == n:
                        return 0
            dev += 1
            leaves = new_leaves + [1 - dev + d // 2, 1 + dev + d // 2]

    else:
        if n * (k - 2) > -2 + k * (k - 1) ** (d // 2) + (k - 2) * (k - 1) ** (d // 2):
            print(""NO"")
            return 0
        print(""YES"")
        for i in range(1, d + 1):
            print(i, i + 1)
        nodes = d + 1
        leaves = [1 + d // 2, 2 + d // 2]
        dev = 0
        while True:
            new_leaves = []
            for i in leaves:
                for j in range(k - 1 - (i <= d + 1)):
                    nodes += 1
                    print(i, nodes)
                    new_leaves.append(nodes)
                    if nodes == n:
                        return 0
            dev += 1
            leaves = new_leaves + [1 - dev + d // 2, 2 + dev + d // 2]
main()
",quadratic,"constructive algorithms,graphs",1747
"def main():
	n, d, k = map(int, input().split())
	if n < d+1 or d > 1 and k == 1:
		print('NO')
		return

	edges = [(1, 2)]
	stack = []
	d2 = d/2
	d21 = d2+1
	for node in range(2, d+1):
		edges.append((node, node+1))
		stack.append([node, d2-abs(d21 - node), k-2])
	next_i = d+2
	while next_i <= n:
		if not stack:
			print('NO')
			return

		node = stack[-1]
		i, remaining_depth, remaining_degree = node
		if remaining_depth == 0 or remaining_degree == 0:
			stack.pop()
			continue

		node[2] -= 1
		edges.append((i, next_i))
		stack.append([next_i, remaining_depth-1, k-1])
		next_i += 1

	print('YES')
	print('\n'.join('{} {}'.format(a, b) for a, b in edges))

main()",quadratic,"constructive algorithms,graphs",672
"
import sys
n,d,k=map(int,input().split())
if(n<=d):
    print('NO')
    sys.exit()
if(k==1 and n>2):
    print('NO')
    sys.exit()

edgestot=[]
edges=[[] for i in range(n)]
tovisit=[]
for i in range(d):
    edgestot.append([i,i+1])
    tovisit.append([i+1,min(i+1,d-i-1)])
    edges[i].append(i+1)
    edges[i+1].append(i)
cur=d+1
while(cur<n and len(tovisit)>0):
    x=tovisit.pop()
    if(x[1]==0):
        continue
    while(len(edges[x[0]])<k and cur<n):
        tovisit.append([cur,x[1]-1])
        edgestot.append([cur,x[0]])
        edges[x[0]].append(cur)
        edges[cur].append(x[0])
        cur+=1

#print(edgestot)
if(len(edgestot)==n-1):
    print('YES')
    for i in range(n-1):
        print(edgestot[i][0]+1,edgestot[i][1]+1)
    
else:
    print('NO')
",quadratic,"constructive algorithms,graphs",773
"#WARNING This code is just for fun. Reading it might give u a brainfreeze

n,d,k = [int(x) for x in input().strip().split(' ')]
l = []
i = 1
if n<=d:
	print(""NO"")
elif k==1:
	if n>2:
		print(""NO"")
	elif n==2:
		print(""YES"")
		print(1,2)
else:
	n+=1
	flag = False
	while i<min(d+1,n):
		l.append(str(i)+"" ""+str(i+1))
		i+=1
	i+=1
	cnt1=0
	cnt2=1
	se=[[2,d+1,1]]
	while cnt1<cnt2:
		start = se[cnt1][0]
		end = se[cnt1][1]
		mode = se[cnt1][2]
		#print(se)
		kk = 3
		while (i<n) and (kk<=k):
			if i<n and not flag:
				j = start
				#print(j,""kk"")
				while i<n and j<end:
					if mode==1:
						c = min(j-start+1,end-j)
					else:
						c = min(end-j,d-end+j)
					if c>1:
						se.append([i,i+c-1,2])
						cnt2+=1
					ki=j
					while i<n and c>0:
						l.append(str(ki)+"" ""+str(i))
						#print(j,i,c)
						c-=1
						ki=i
						i+=1
					j+=1
					
			else:
				flag = True
				break
			kk+=1
		cnt1+=1
	if i<n or flag:
		#print(l)
		print(""NO"")
	else:
		print(""YES"")
		print('\n'.join(l))",quadratic,"constructive algorithms,graphs",995
"n, d, k = map(int, input().split())
num = d+2

def solve():
  global num
  if n == 1: return 'NO'
  if n == 2:
    if d != 1:
      return 'NO'
    else:
      return ""YES\n1 2""
  if k < 2: return 'NO'
  if d > n-1: return 'NO'

  depth = [min(i, d-i) for i in range(d+1)]
  ans = [(i+1, i+2) for i in range(d)]

  def dfs(v, depth):
    global num
    if depth == 0: return
    for i in range(k-1):
      if len(ans) == n-1: return
      v2 = num
      num += 1
      ans.append((v, v2))
      dfs(v2, depth-1)

  for v in range(d+1):
    if depth[v] == 0: continue
    for i in range(k-2):
      if len(ans) == n-1: break
      v2 = num
      num += 1
      ans.append((v+1, v2))
      if depth[v] > 1: dfs(v2, depth[v]-1)

  if len(ans) < n-1: return ""NO""
  return ""YES\n%s""%""\n"".join([""%d %d""%i for i in ans])

print(solve())",quadratic,"constructive algorithms,graphs",829
"from sys import exit

def bad():
    print(""NO"")
    exit()

node = 1
def make_branch(u, d, deg, g, n, k):
    global node
    while deg[u] < k and d > 0 and node < n:
        node += 1
        deg[u] += 1
        deg[node] = 1
        g[u].append(node)
        make_branch(node, d - 1, deg, g, n, k)

def main():
    global node
    n, d, k = map(int, input().split())
    if d >= n or (k == 1 and n > 2):
        bad()

    g = [[] for _ in range(n + 5)]
    deg = [0 for _ in range(n + 5)]

    for i in range(1, d + 1):
        g[i].append(i + 1)
        deg[i] += 1
        deg[i + 1] += 1

    node = d + 1

    LD = 1
    RD = d - 1
    for u in range(2, d + 1):
        make_branch(u, min(LD, RD), deg, g, n, k)
        LD += 1
        RD -= 1

    used = [False for _ in range(n + 5)]
    q = [[1, 1]]
    used[1] = True
    while len(q) > 0:
        u, p = q.pop()
        for v in g[u]:
            if v != p:
                used[v] = True
                q.append([v, u])

    for i in range(1, n + 1):
        if used[i] == False:
            bad()

    print(""YES"")
    for u in range(1, n + 1):
        for v in g[u]:
            print(u, v)

main()


",quadratic,"constructive algorithms,graphs",1168
"def main():
    n, d, k = map(int, input().split())
    r, odd = divmod(d, 2)
    k -= 1
    cap = d + 1 if k == 1 else 1
    if k > 1:
        cap = 2 * (k ** (r + 1) - 1) // (k - 1) if odd else 1 + (k + 1) * (k ** r - 1) // (k - 1)
    if n == 1 or k < 1 < n - 1 or k == 1 and d != n - 1 or d >= n or k > 1 and not d < n <= cap:
        print('NO')
        return

    def dfs(parent, depth):
        stack = []
        for _ in range(k - 1):
            child = rest.pop()
            res.append('%s %s' % (parent, child))
            if depth:
                stack.append((child, depth))
        while stack:
            parent, depth = stack.pop()
            depth -= 1
            for _ in range(k):
                child = rest.pop()
                res.append('%s %s' % (parent, child))
                if depth:
                    stack.append((child, depth))

    res = ['YES']
    for pc in enumerate(range(2, d + 2), 1):
        res.append('%d %d' % pc)
    rest = list(range(n, d + 1, -1))
    try:
        for p in range(r + 1, r + odd + 2):
            dfs(p, r - 1)
        for de, p, q in zip(range(r - 2, -1, -1), range(r, 1, -1), range(r + odd + 2, d + 1)):
            dfs(p, de)
            dfs(q, de)
    except IndexError:
        pass
    print('\n'.join(res))


if __name__ == '__main__':
    main()
",quadratic,"constructive algorithms,graphs",1328
"def main():
    n, d, k = map(int, input().split())
    _min = d+1

    if n < _min:
        print('NO')
    else:
        res = []
        deg = [0] * (n+1)
        dist = [0] * (n+1)

        stack = []
        deg[1] = 1
        for i in range(1, d+1):
            res.append((i, i+1))
            if i > 1:
                deg[i] += 2
            dist[i] = max(i-1, d+1-i)
        dist[d+1] = d
        deg[d+1] = 1

        for i in range(2, d+1):
            stack.append(i)

        next = d+2
        while stack:
            if next > n:
                break
            v = stack.pop()
            if dist[v] < d:
                while next <= n and deg[v] < k:
                    res.append((v, next))
                    deg[v] += 1
                    deg[next] += 1
                    dist[next] = dist[v] + 1
                    if dist[next] < d:
                        stack.append(next)
                    next += 1

        ok = next > n
        ok &= all(deg[i] <= k for i in range(1, n+1))
        ok &= all(dist[i] <= d for i in range(1, n+1))

        if not ok:
            print('NO')
        else:
            print('YES')
            for e in res:
                print(*e)


if __name__ == '__main__':
    main()
",quadratic,"constructive algorithms,graphs",1246
"n,d,k=map(int,input().split())
if n==1:
  print(""NO"")
  exit()
if k==1:
  if n==2 and d==1:
    print(""YES"")
    print(1,2)
  else:
    print(""NO"")
  exit()
if n<d+1:
  print(""NO"")
  exit()
co=1
ans=[]
for i in range(1,d+1):
  ans.append((i,i+1))
  co+=1
def dfs(r,dist,co):
  if 2<=r<=d:
    t=k-2
  else:
    t=k-1
  if co==n:
    return co
  for _ in range(t):
    if dist==d:
      return co
    if co==n:
      return co
    co+=1
    ans.append((r,co))
    co=dfs(co,dist+1,co)
  return co
for i in range(2,d+1):
  co=dfs(i,max(i-1,d-i+1),co)
if co==n:
  print(""YES"")
  for j in ans:
    print(*j)
else:
  print(""NO"")",quadratic,"constructive algorithms,graphs",623
"from collections import deque
n, d, k = map(int, input().split())
if n==1:
    print('NO')
    exit(0)
if n==2:
    if d>1:
        print('NO')
    else:
        print('YES')
        print(1, 2)
    exit(0)
if (not 2<=d<=n-1) or k==1:
    print('NO')
    exit(0)
ans = []
for i in range(d):
    ans.append((i+1, i+2))
now = d+2
for i in range(d-1):
    q = deque([(i+2, min(i, d-i-2))])
    first = True
    while q and len(ans)<n-1:
        node, depth = q.popleft()
        end = now+k-1
        if first:
            end -= 1
        for j in range(now, end):
            ans.append((node, j))
            if len(ans)==n-1:
                break
            if depth>0:
                q.append((j, depth-1))
        now = end
        first = False

if len(ans)==n-1:
    print('YES')
    for i, j in ans:
        print(i, j)
else:
    print('NO')",quadratic,"constructive algorithms,graphs",850
"n, d, k = map(int, input().split())

if d+1 > n:
    print('NO')
    exit()

ans = []
dist = [0]*n
deg = [0]*n
for i in range(d+1):
    if i == 0 or i == d:
        deg[i] = 1
    else:
        deg[i] = 2
    if i != d:
        ans.append((i+1, i+2))
    dist[i] = max(i, d-i)

for i in range(n):
    if deg[i] > k:
        print('NO')
        exit()

from collections import deque
q = deque(list(range(d+1)))
cur = d+1
while q and cur < n:
    v = q.popleft()
    if dist[v] < d and deg[v] < k:
        deg[v] += 1
        dist[cur] = dist[v]+1
        deg[cur] = 1
        ans.append((v+1, cur+1))
        q.append(v)
        q.append(cur)
        cur += 1
    else:
        continue
if cur != n:
    print('NO')
else:
    print('YES')
    for i in range(len(ans)):
        print(*ans[i])
",quadratic,"constructive algorithms,graphs",791
"n, d, k = map(int, input().split())

if d+1 > n:
    print('NO')
    exit()

ans = []
dist = [0]*n
deg = [0]*n
for i in range(d+1):
    if i == 0 or i == d:
        deg[i] = 1
    else:
        deg[i] = 2
    if i != d:
        ans.append((i+1, i+2))
    dist[i] = max(i, d-i)

for i in range(n):
    if deg[i] > k:
        print('NO')
        exit()

from collections import deque
q = deque(list(range(d+1)))
cur = d+1
while q and cur < n:
    v = q.pop()
    if dist[v] < d and deg[v] < k:
        deg[v] += 1
        dist[cur] = dist[v]+1
        deg[cur] = 1
        ans.append((v+1, cur+1))
        q.append(v)
        q.append(cur)
        cur += 1
    else:
        continue
if cur != n:
    print('NO')
else:
    print('YES')
    for i in range(len(ans)):
        print(*ans[i])
",quadratic,"constructive algorithms,graphs",787
"
def construct_tree(n,d, k):
    nodes = []
    edges = []

    if d > n - 1:
        return None
    
    if k == 1 and n > 2:
        return None

    for i in range(1, d+2):
        current_deg = k - 1 if i == 1 or i == d + 1 else k - 2
        current_depth =  min(i-1, d-i+1)
        if current_depth and current_deg:
            nodes.append([i, min(i-1, d-i+1), current_deg])
        if i < d + 1:
            edges.append([i, i+1])

    current_nodes_count = d + 2
    pos = 0
    while current_nodes_count < n + 1:

        if pos >= len(nodes):
            return None

        current = nodes[pos]

        if not current[2]:
            pos += 1
            if pos == len(nodes):
                break
            continue

        if current[1] - 1 and k - 1:
            nodes.append([current_nodes_count, current[1] - 1, k - 1])
        edges.append([current[0], current_nodes_count])
        current[2] -= 1
        current_nodes_count += 1
    
    if current_nodes_count == n + 1:
        return edges
    return None



n, d, k = [int(val) for val in input().split()]
edges = construct_tree(n, d, k)
if edges:
    print('YES')
    print('\n'.join(['{0} {1}'.format(e[0], e[1]) for e in edges]))
else:
    print('NO')

",quadratic,"constructive algorithms,graphs",1237
"import sys
import math
import collections
import bisect
import string
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    s1=list(get_string())
    s2=list(get_string())
    count=0
    ans=[]
    lower=string.ascii_lowercase
    np=0
    for i in lower:
        if s1.count(i)!=s2.count(i):
            np+=1
            break
    if np>0:
        print(-1)
        continue
    pos=dict()
    for i in range(n):
        if s1[i] in pos:
            pos[s1[i]].append(i)
        else:
            pos[s1[i]]=[i]
    for i in range(n):
        if s1[i]==s2[i]:
            continue
        else:
            row=pos[s2[i]]
            no=0
            for j in range(len(row)):
                if row[j]>i:
                    no=row[j]
                    break
            for j in range(no,i,-1):
                ans.append(j)
            s1.pop(no)
            s1.insert(i,s2[i])
            #print(s1)
            pos = dict()
            for j in range(n):
                if s1[j] in pos:
                    pos[s1[j]].append(j)
                else:
                    pos[s1[j]] = [j]
    print(len(ans))
    print(*ans)",quadratic,implementation,1321
"import sys, string

def swap(i, j):
    temp = a[i]
    a[i] = a[j]
    a[j] = temp

n = int(sys.stdin.readline())
a = list(sys.stdin.readline().rstrip())
b = list(sys.stdin.readline().rstrip())
res_a = dict().fromkeys(list(string.ascii_lowercase), 0)
res_b = dict().fromkeys(list(string.ascii_lowercase), 0)

for i in a:
    res_a[i] += 1
for i in b:
    res_b[i] += 1

can = True
for i in res_a:
    if res_a[i] != res_b[i]:
        can = False
        break
if not can:
    print(-1)
else:
    ans = []
    for i in range(n):
        if a[i] == b[i]:
            continue
        else:
            idx = -1
            for j in range(i + 1, n):
                if a[j] == b[i]:
                    idx = j
                    break
            for j in range(idx, i, -1):
                ans.append(j)
                swap(j, j - 1)
    print(len(ans))
    print(' '.join(map(str, ans)))

",quadratic,implementation,892
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n=int(input())
    s=list(input().strip())
    t=list(input().strip())
    res=True
    ans=[]
    for i in range(n):
        if s[i]==t[i]:
            continue
        else:
            ind=-1
            for j in range(i+1,n):
                if t[i]==s[j]:
                    ind=j
                    break
            if ind==-1:
                res=False
                break
            for j in range(ind-1,i-1,-1):
                ans.append(j+1)
                s[j],s[j+1]=s[j+1],s[j]
    if res:
        print(len(ans))
        print(*ans)
    else:
        print(-1)




if __name__ == '__main__':
    main()



",quadratic,implementation,796
"n = int(input())
s = list(str(input()))
t = list(str(input()))
 
from collections import Counter
cs = Counter(s)
ct = Counter(t)
if cs != ct:
    print(-1)
    exit()
 
xs = [[] for _ in range(26)]
xt = [[] for _ in range(26)]
for i in range(n):
    j = ord(s[i])-ord('a')
    xs[j].append(i)
 
for i in range(n):
    j = ord(t[i])-ord('a')
    xt[j].append(i)
 
x = [-1]*n
for i in range(26):
    for j, k in zip(xs[i], xt[i]):
        x[j] = k
 
ans = []
for i in range(n):
    for j in reversed(range(i+1, n)):
        if x[j-1] > x[j]:
            x[j-1], x[j] = x[j], x[j-1]
            ans.append(j)
print(len(ans))
print(*ans)",quadratic,implementation,633
"n = int(input())
s = input()
t = input()
sl = [i for i in s]
tl = [i for i in t]
ans = []
if(''.join(sorted(s))!=''.join(sorted(t))):
    print(-1)
    
    
#birute phoerce
#i = 1 to n 
#j = i+1 to n
else:
    for i in range(n):
        if(sl[i]!=tl[i]):
            for j in range(i+1,n):
                if(sl[j]==tl[i]):
                    break
            for k in range(j-1,i-1,-1):
                sl[k],sl[k+1] = sl[k+1],sl[k]
                ans.append(k+1)
    #print(sl,t)
    print(len(ans))
    for i in ans:
        print(i,end=' ')",quadratic,implementation,548
"n = int(input())
s = list(input())
t = input()
if sorted(s) != sorted(t):
    print(-1)
else:
    lst = [0] * n
    for i in range(n):
        for j in range(n):
            if s[j] == t[i]:
                lst[j] = i + 1
                s[j] = "".""
                break
    ans = 0
    a = []
    for i in range(n):
        for j in range(n - 1):
            if i != j:
                if lst[j] > lst[j + 1]:
                    ans += 1
                    lst[j], lst[j + 1] = lst[j + 1], lst[j]
                    a.append(j+1)
    print(ans)
    print(*a)",quadratic,implementation,562
"n = int(input())
s = list(input())
d = list(input())
if(sorted(s) != sorted(d)):
    print(-1)
else:
    ans = []
    for i in range(n):
        if(s[i] != d[i]):
            for u in range(i+1,n):
                if(s[u] == d[i]):
                    ind = u
                    break
                else:ind = -1
            if(ind == -1):print(-1);exit()    
            cnt = abs(ind - i)
            s.pop(ind)           
            s.insert(i,d[i])
            #print(s)
            for k in range(cnt):
                if(ind > 0):
                    ans.append(ind)
                else:
                    ans.append(1)    
                ind -= 1
    print(len(ans))
    print(*ans) ",quadratic,implementation,698
"# RawCoder : https://bit.ly/RCyouTube
# Author : MehulYK

n = int(input())
s = list(input())
d = list(input())
if(sorted(s) != sorted(d)):
    print(-1)
else:
    ans = []
    for i in range(n):
        if(s[i] != d[i]):
            for u in range(i+1,n):
                if(s[u] == d[i]):
                    ind = u
                    break
                    
            cnt = abs(ind - i)
            s.pop(ind)           
            s.insert(i,d[i])
            #print(s)
            for k in range(cnt):
                if(ind > 0):
                    ans.append(ind)
                else:
                    ans.append(1)    
                ind -= 1
    print(len(ans))
    print(*ans)",quadratic,implementation,699
"n = int(input())

first = list(input())
second = list(input())

swap = list()
can = True

for i in range(n):
    if first[i] != second[i]:
        cont = -1
        for j in range(i,n): 
            if first[j] == second[i]:
                cont = j 
                break
            
        if cont != -1:
            for j in range(cont, i, -1 ):
                first[j], first[j-1] = first[j-1], first[j]
                swap.append(j)
        else:
            can = False

if can: 
    print(len(swap))
    print(*swap, end=' ')

else: 
    print(-1)",quadratic,implementation,558
"if __name__ == '__main__':
    cin = input
    n = int(cin())
    s, t = [*cin()], cin()
    i, r = 0, list()

    if sorted(s) != sorted(t):
        print(-1)
    else:
        while i < n:
            j = i
            while j < n and s[j] != t[i]:
                j += 1
            s[i:j + 1] = s[j:j + 1] + s[i:j]
            r.extend(range(j, i, -1))
            i += 1
        print(len(r))
        print(*r)",quadratic,implementation,415
"import collections
n = int(input())
s = input()
t = input()
if collections.Counter(s) != collections.Counter(t):
    print(-1)
    exit()
sl = list(s)
st = list(t)
ans = []
p = 0
while sl:
    if sl[0] != st[0]:
        k = sl.index(st[0])
        ans.extend(list(range(k + p, p, -1)))
        sl.pop(k)
        st.pop(0)

    else:
        sl.pop(0)
        st.pop(0)
    p += 1
print(len(ans))
print(*ans)
",quadratic,implementation,408
"import sys
input=sys.stdin.readline
def read():return list(map(int,input().split()))
n=int(input())
s=input()
t=input()
if sorted(s)!=sorted(t):
    print(-1)
    quit()
s=list(s)
t=list(t)
ans=[]
for i in range(n):
    for j in range(i,n-1):
        if s[j+1] == t[i]:
            for k in range(j,i-1,-1):
                ans.append(k+1)
                s[k+1], s[k] = s[k], s[k+1]
            break
print(len(ans))
print(*ans)",quadratic,implementation,429
"from sys import stdin,stdout,setrecursionlimit
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush,nlargest
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm , accumulate
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
setrecursionlimit(10**9)
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353
# from sys import stdin
# input = stdin.readline
#def data(): return sys.stdin.readline().strip()
def data(): return input()
def num():return int(input())
def L(): return list(sp())
def LF(): return list(spf())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def spf(): return map(int, input.readline().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
def pmat(A):
    for ele in A:
        print(*ele,end=""\n"")
def pmat2(A):
    for ele in A:
        for j in ele:
            print(j,end='')
        print()
def iseven(n):
    return n%2==0

def seive(r):
    prime=[1 for i in range(r+1)]
    prime[0]=0
    prime[1]=0
    for i in range(r+1):
        if(prime[i]):
            for j in range(2*i,r+1,i):
                prime[j]=0
    return prime
#solution
#ACPC 
#remeber cut ribbon problem
# set data structures faster than binary search sometimes
#bipartite match dfs
#think in problems with recursive manner.
n = int(input())
s = list(input())
t = list(input())
ans = []
for i in range(n):
    for j in range(i,n):
        if s[j] == t[i]:
            for k in range(j, i, -1):
                s[k], s[k-1] = s[k-1], s[k]
                ans.append(k)
            break
if s==t:
    print(len(ans))
    print(' '.join(map(str, ans)))
else:
    print(-1)




endtime = time.time()
#print(f""Runtime of the program is {endtime - starttime}"")",quadratic,implementation,2038
"n=int(input())
s=list(input())
t=list(input())

cnt=0
ans=[]
f1=0
for i in range(n):
    if s[i]==t[i]:
        continue
    f=0
    for j in range(i+1,n):
        if s[j]==t[i]:
            f=1
            for k in range(j,i,-1):
                s[k-1],s[k]=s[k],s[k-1]
                ans.append(k)
            break
    if f==0:
        print(-1)
        exit()

print(len(ans))
print(*ans)",quadratic,implementation,393
"n = int(input())
s = list(input())
t = list(input())

if sorted(t) == sorted(s):
    ans = []
    for i in range(n-1, -1, -1):
        if t[i] != s[i]:
            j = s.index(t[i])
            for k in range(j, i):
                s[k], s[k+1] = s[k+1], s[k]
                ans.append(str(k+1))
    print(len(ans))
    print(' '.join(ans))
else:
    print(-1)
",quadratic,implementation,362
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
########################################################################

m,n=ris()
m,n=m+2,n+2
grid =['.'*n]
grid+=['.'+rl()+'.' for _ in range(m-2)]
grid+=['.'*n]

up=[[0]*n for _ in range(m)]
dw=[[0]*n for _ in range(m)]
lf=[[0]*n for _ in range(m)]
rg=[[0]*n for _ in range(m)]
rs=[[0]*n for _ in range(m)]
cs=[[0]*n for _ in range(m)]

for i in range(1,m-1):
  for j in range(1,n-1):
    if grid[i][j]=='*':
      up[i][j]=1+up[i-1][j]
      lf[i][j]=1+lf[i][j-1]
for i in range(m-1,0,-1):
  for j in range(n-1,0,-1):
    if grid[i][j]=='*':
      dw[i][j]=1+dw[i+1][j]
      rg[i][j]=1+rg[i][j+1]

ans=[]
for i in range(1,m-1):
  for j in range(1,n-1):
    if grid[i][j]=='.':
      continue
    s=min(up[i-1][j],dw[i+1][j],lf[i][j-1],rg[i][j+1])
    if s==0:
      continue
    ans.append((i,j,s))
    rs[i-s][j]+=1
    rs[i+s+1][j]-=1
    cs[i][j-s]+=1
    cs[i][j+s+1]-=1

for i in range(1,m-1):
  for j in range(1,n-1):
    rs[i][j]+=rs[i-1][j]
    cs[i][j]+=cs[i][j-1]

for i in range(1,m-1):
  for j in range(1,n-1):
    if grid[i][j]=='.':
      continue
    if rs[i][j]==0 and cs[i][j]==0:
      print(-1)
      exit()

print(len(ans))
for i,j,s in ans:
  print(i,j,s)
",quadratic,"binary search,dp,greedy",1736
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(10)] 
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n): 
          
        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p): 
                pp[i]+=1
                prime[i] = False
        p += 1
#---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res
#---------------------------------running code------------------------------------------
n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]
#print(h)
#print(v)
for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)",quadratic,"binary search,dp,greedy",10655
"from collections import defaultdict, deque
from heapq import heappush, heappop
from math import inf

ri = lambda : map(int, input().split())

def solve():
    n,m = ri()
    A = [[0 for _ in range(m)] for __ in range(n)]
    left = [[0 for _ in range(m)] for __ in range(n)]
    right = [[0 for _ in range(m)] for __ in range(n)]
    up = [[0 for _ in range(m)] for __ in range(n)]
    down = [[0 for _ in range(m)] for __ in range(n)]
    for r in range(n):
        lst = input()
        for c in range(m):
            if lst[c] == '*':
                A[r][c] = left[r][c] = right[r][c] = up[r][c] = down[r][c] = 1

    for r in range(n):
        for c in range(1, m):
            if A[r][c]:
                left[r][c] += left[r][c-1]
        for c in range(m-2, -1, -1):
            if A[r][c]:
                right[r][c] += right[r][c+1]

    for c in range(m):
        for r in range(1, n):
            if A[r][c]:
                up[r][c] += up[r-1][c]

        for r in range(n-2, -1, -1):
            if A[r][c]:
                down[r][c] += down[r+1][c]
    res = []
    stars = 0

    ROWS = [[0 for _ in range(m)] for __ in range(n)]
    COLS = [[0 for _ in range(m)] for __ in range(n)]

    for r in range(n):
        for c in range(m):
            if A[r][c]:
                can = min(left[r][c], right[r][c], up[r][c], down[r][c])
                can -= 1
                if can > 0:
                    stars += 1
                    res.append((r+1, c+1, can))
                ROWS[r-can][c] += can
                if r+can+1 < n:
                    ROWS[r+can+1][c] -= can
                COLS[r][c-can] += can
                if c+can+1 < m:
                    COLS[r][c+can+1] -= can

    valid = [[False for _ in range(m)] for __ in range(n)]
    for r in range(n):
        curr = 0
        for c in range(m):
            curr += COLS[r][c]
            if curr > 0:
                valid[r][c] = True


    for c in range(m):
        curr = 0
        for r in range(n):
            curr += ROWS[r][c]
            if curr > 0:
                valid[r][c] = True

    for r in range(n):
        for c in range(m):
            if A[r][c] and not valid[r][c]:
                print(-1)
                return
    print(stars)
    for x,y,z in res:
        print(x,y,z)
t = 1
#t = int(input())
while t:
    t -= 1
    solve()

",quadratic,"binary search,dp,greedy",2349
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
s = [list(input().rstrip()) for _ in range(n)]
t = [[1000] * m for _ in range(n)]
ok1 = [[0] * m for _ in range(n)]
ok2 = [[0] * m for _ in range(n)]
for i in range(n):
    si = s[i]
    c = 0
    for j in range(m):
        if si[j] == ""*"":
            c += 1
        else:
            c = 0
        t[i][j] = min(t[i][j], c)
    c = 0
    for j in range(m - 1, -1, -1):
        if si[j] == ""*"":
            c += 1
        else:
            c = 0
        t[i][j] = min(t[i][j], c)
for j in range(m):
    c = 0
    for i in range(n):
        if s[i][j] == ""*"":
            c += 1
        else:
            c = 0
        t[i][j] = min(t[i][j], c)
    c = 0
    for i in range(n - 1, -1, -1):
        if s[i][j] == ""*"":
            c += 1
        else:
            c = 0
        t[i][j] = min(t[i][j], c)
ans = []
for i in range(n):
    for j in range(m):
        tij = t[i][j] - 1
        if tij >= 1:
            ans.append((i + 1, j + 1, tij))
            ok1[max(0, i - tij)][j] += 1
            if i + tij + 1 < n:
                ok1[i + tij + 1][j] -= 1
            ok2[i][max(0, j - tij)] += 1
            if j + tij + 1 < m:
                ok2[i][j + tij + 1] -= 1
for i in range(1, n):
    for j in range(1, m):
        ok1[i][j] += ok1[i - 1][j]
        ok2[i][j] += ok2[i][j - 1]
for i in range(n):
    for j in range(m):
        if s[i][j] == ""*"":
            if not (ok1[i][j] or ok2[i][j]):
                ans = -1
                print(ans)
                exit()
k = len(ans)
print(k)
for ans0 in ans:
    print(*ans0)",quadratic,"binary search,dp,greedy",1606
"n,m=map(int,input().split())
g=[[*input()] for _ in range(n)]
c=[[0 for _ in range(m)] for _ in range(n)]
for i in range(n):
 v=0
 for j in range(m):
  v=(v+1)*(g[i][j]=='*')
  c[i][j]=v
 v=0
 for j in range(m-1,-1,-1):
  v=(v+1)*(g[i][j]=='*')
  c[i][j]=min(c[i][j],v)
for j in range(m):
 v=0
 for i in range(n):
  v=(v+1)*(g[i][j]=='*')
  c[i][j]=min(c[i][j],v)
 v=0
 for i in range(n-1,-1,-1):
  v=(v+1)*(g[i][j]=='*')
  c[i][j]=min(c[i][j],v)
for i in range(n):
 for j in range(m):
  if c[i][j]==1: c[i][j]=0
for i in range(n):
 v=0
 for j in range(m):
  v=max(v-1,c[i][j])
  if v:g[i][j]='.'
 v=0
 for j in range(m-1,-1,-1):
  v=max(v-1,c[i][j])
  if v:g[i][j]='.'
for j in range(m):
 v=0
 for i in range(n):
  v=max(v-1,c[i][j])
  if v:g[i][j]='.'
 for i in range(n-1,-1,-1):
  v=max(v-1,c[i][j])
  if v:g[i][j]='.'
if all(g[i][j]=='.' for i in range(n) for j in range(m)):
 r=[(i+1,j+1,c[i][j]-1) for i in range(n) for j in range(m) if c[i][j]]
 print(len(r))
 for t in r: print(*t)
else:
 print(-1)",quadratic,"binary search,dp,greedy",1006
"import sys
n,m=map(int,input().split())
s=[list(input()) for i in range(n)]
u=[[-1 for i in range(m)] for j in range(n)]
d=[[-1 for i in range(m)] for j in range(n)]
l=[[-1 for i in range(m)] for j in range(n)]
r=[[-1 for i in range(m)] for j in range(n)]
for i in range(m):
    acum=0
    for j in range(n):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        u[j][i]=acum
for i in range(m):
    acum=0
    for j in range(n-1,-1,-1):
        if s[j][i]==""."":
            acum=0
        else:
            acum+=1
        d[j][i]=acum
for i in range(n):
    acum=0
    for j in range(m):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        l[i][j]=acum
for i in range(n):
    acum=0
    for j in range(m-1,-1,-1):
        if s[i][j]==""."":
            acum=0
        else:
            acum+=1
        r[i][j]=acum
ans=[]
t1=[[0 for i in range(m)] for j in range(n)]
t2=[[0 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        d1=min(l[i][j],r[i][j],u[i][j],d[i][j])-1
        if d1>0:
            ans.append([i+1,j+1,d1])
            t1[i+d1][j]+=1
            t1[i-d1][j]-=1
            t2[i][j-d1]+=1
            t2[i][j+d1]-=1
dp=[['.' for i in range(m)] for j in range(n)]
for i in range(n):
    acum=0
    for j in range(m):
        acum+=t2[i][j]
        if acum!=0 or t2[i][j]!=0:
            dp[i][j]='*'
for i in range(m):
    acum=0
    for j in range(n):
        acum+=t1[j][i]
        if acum!=0 or t1[j][i]!=0 :
            dp[j][i]='*'           
if dp!=s:
    print(-1)
    sys.exit()
print(len(ans))
for i in ans:
    print(*i)
        
        
",quadratic,"binary search,dp,greedy",1663
"def main():
    n, m = map(int, input().split())
    ll = [c == '*' for _ in range(n) for c in input()]
    nm = n * m
    RLUD = [*[range(i, i + m) for i in range(0, nm, m)],
            *[range(i, nm, m) for i in range(m)]]
    cc = [1000] * nm
    for f in True, False:
        for r in RLUD:
            v = 0
            for i in r:
                if ll[i]:
                    v += 1
                    if cc[i] > v:
                        cc[i] = v
                else:
                    v = cc[i] = 0
        if f:
            ll.reverse()
            cc.reverse()
    cc = [c if c != 1 else 0 for c in cc]
    for f in True, False:
        for r in RLUD:
            v = 0
            for i in r:
                if v > cc[i]:
                    v -= 1
                else:
                    v = cc[i]
                if v:
                    ll[i] = False
        if f:
            ll.reverse()
            cc.reverse()
    if any(ll):
        print(-1)
    else:
        res = []
        for i, c in enumerate(cc):
            if c:
                res.append(f'{i//m+1} {i%m+1} {c-1}')
        print(len(res), '\n'.join(res), sep='\n')


if __name__ == '__main__':
    main()
",quadratic,"binary search,dp,greedy",1199
"import sys
from math import *

def minp():
	return sys.stdin.readline().strip()

def mint():
	return int(minp())

def mints():
	return map(int, minp().split())

def main():
	n, m = mints()
	res = []
	a = [None]*n
	l = [None]*n
	r = [None]*n
	s = [0]*n
	for i in range(n):
		a[i] = list(minp())
		l[i] = [i for i in range(m)]
		r[i] = [i for i in range(m)]
		s[i] = [0]*m
	for i in range(n):
		j = 0
		b = a[i]
		ll = l[i]
		rr = r[i]
		while j < m:
			if b[j] == '*':
				jj = j+1
				while jj < m and b[jj] == '*':
					jj += 1
				jj -= 1
				for k in range(j,jj+1):
					ll[k] = j
					rr[k] = jj
				j = jj + 1
			else:
				j += 1
	for i in range(m):
		j = 0
		while j < n:
			if a[j][i] == '*':
				jj = j+1
				while jj < n and a[jj][i] == '*':
					jj += 1
				jj -= 1
				for k in range(j,jj+1):
					x = min(i-l[k][i],r[k][i]-i,k-j,jj-k)
					s[k][i] = x
					if x > 0:
						res.append((k+1,i+1,x))
				j = jj + 1
			else:
				j += 1
	for i in range(n):
		j = 0
		ss = s[i]
		rr = r[i]
		c = -1
		while j < m:
			if ss[j] > 0 and c < ss[j]:
				c = ss[j]
			if c >= 0:
				rr[j] = '*'
			else:
				rr[j] = '.'
			j += 1
			c -= 1
		j = m-1
		c = -1
		while j >=0:
			if ss[j] > 0 and c < ss[j]:
				c = ss[j]
			if c >= 0:
				rr[j] = '*'
			c -= 1
			j -= 1
	for i in range(m):
		j = 0
		c = -1
		while j < n:
			x = s[j][i]
			if x > 0 and c < x:
				c = x
			if c >= 0:
				r[j][i] = '*'
			j += 1
			c -= 1
		j = n-1
		c = -1
		while j >=0:
			x = s[j][i]
			if x > 0 and c < x:
				c = x
			if c >= 0:
				r[j][i] = '*'
			if r[j][i] != a[j][i]:
				print(-1)
				exit(0)
			c -= 1
			j -= 1
	print(len(res))
	for i in res:
		print(*i)
main()",quadratic,"binary search,dp,greedy",1657
"def main():
    n, m = map(int, input().split())
    w = [c == '*' for i in range(n) for c in input()]
    nm = n * m
    q = [*[range(i, i + m) for i in range(0, nm, m)],
            *[range(i, nm, m) for i in range(m)]]
    e = [1000] * nm
    for f in True, False:
        for r in q:
            v = 0
            for i in r:
                if w[i]:
                    v += 1
                    if e[i] > v:
                        e[i] = v
                else:
                    v = e[i] = 0
        if f:
            w.reverse()
            e.reverse()
    e = [c if c != 1 else 0 for c in e]
    for f in True, False:
        for r in q:
            v = 0
            for i in r:
                if v > e[i]:
                    v -= 1
                else:
                    v = e[i]
                if v:
                    w[i] = False
        if f:
            w.reverse()
            e.reverse()
    if any(w):
        print(-1)
    else:
        r = []
        for i, c in enumerate(e):
            if c:
                r.append(f'{i//m+1} {i%m+1} {c-1}')
        print(len(r), '\n'.join(r), sep='\n')


main()",quadratic,"binary search,dp,greedy",1133
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
MAP=[list(input().strip()) for i in range(n)]

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        if MAP[i][j]==""*"":
            T0[i][j]=T0[i-1][j]+1
            Y0[i][j]=Y0[i][j-1]+1

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        if MAP[i][j]==""*"":
            T1[i][j]=T1[i+1][j]+1
            Y1[i][j]=Y1[i][j+1]+1

ANS=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):
        score=min(T0[i][j],T1[i][j],Y0[i][j],Y1[i][j])
        if score>=2:
            ANS[i][j]=score

T0=[[0]*(m+1) for i in range(n+1)]
T1=[[0]*(m+1) for i in range(n+1)]
Y0=[[0]*(m+1) for i in range(n+1)]
Y1=[[0]*(m+1) for i in range(n+1)]

for i in range(n):
    for j in range(m):
        T0[i][j]=max(ANS[i][j],T0[i-1][j]-1)
        Y0[i][j]=max(ANS[i][j],Y0[i][j-1]-1)

for i in range(n-1,-1,-1):
    for j in range(m-1,-1,-1):
        T1[i][j]=max(ANS[i][j],T1[i+1][j]-1)
        Y1[i][j]=max(ANS[i][j],Y1[i][j+1]-1)



SUF=[["".""]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if T0[i][j] or T1[i][j] or Y0[i][j] or Y1[i][j]:
            SUF[i][j]=""*""

if SUF!=MAP:
    print(-1)
else:
    ANSLIST=[]
    for i in range(n):
        for j in range(m):
            if ANS[i][j]!=0:
                ANSLIST.append((i+1,j+1,ANS[i][j]-1))

    print(len(ANSLIST))
    for ans in ANSLIST:
        print(*ans)
",quadratic,"binary search,dp,greedy",1559
"# -*- coding: utf-8 -*-

import sys
from itertools import accumulate

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD = 10 ** 9 + 7

def build_grid(H, W, intv, _type, space=True, padding=False):
    if space:
        _input = lambda: input().split()
    else:
        _input = lambda: input()
    _list = lambda: list(map(_type, _input()))
    if padding:
        offset = 1
    else:
        offset = 0
    grid = list2d(H+offset*2, W+offset*2, intv)
    for i in range(offset, H+offset):
        row = _list()
        for j in range(offset, W+offset):
            grid[i][j] = row[j-offset]
    return grid

H, W = MAP()
grid = build_grid(H, W, '#', str, space=0, padding=1)

ans = []
imosw = list2d(H+2, W+2, 0)
imosh = list2d(H+2, W+2, 0)
def check(i, j):
    sz = min(L[i][j], R[i][j], U[i][j], D[i][j])
    if sz > 1:
        imosw[i][j-sz+1] += 1
        imosw[i][j+sz] -= 1
        imosh[i-sz+1][j] += 1
        imosh[i+sz][j] -= 1
        ans.append((i, j, sz-1))

def check2():
    for i in range(1, H+1):
        for j in range(1, W+1):
            if grid[i][j] == '*' and not imosw[i][j] and not imosh[i][j]:
                return False
    return True

L = list2d(H+2, W+2, 0)
R = list2d(H+2, W+2, 0)
U = list2d(H+2, W+2, 0)
D = list2d(H+2, W+2, 0)
for i in range(1, H+1):
    for j in range(1, W+1):
        if grid[i][j] == '.':
            L[i][j] = 0
        else:
            L[i][j] = L[i][j-1] + 1
for i in range(1, H+1):
    for j in range(W, 0, -1):
        if grid[i][j] == '.':
            R[i][j] = 0
        else:
            R[i][j] = R[i][j+1] + 1
for j in range(1, W+1):
    for i in range(1, H+1):
        if grid[i][j] == '.':
            U[i][j] = 0
        else:
            U[i][j] = U[i-1][j] + 1
for j in range(1, W+1):
    for i in range(H, 0, -1):
        if grid[i][j] == '.':
            D[i][j] = 0
        else:
            D[i][j] = D[i+1][j] + 1

for i in range(1, H+1):
    for j in range(1, W+1):
        if grid[i][j] == '*':
            check(i, j)
for i in range(1, H+1):
    for j in range(W+1):
        imosw[i][j+1] += imosw[i][j]
for j in range(1, W+1):
    for i in range(H+1):
        imosh[i+1][j] += imosh[i][j]

if check2():
    print(len(ans))
    [print(h, w, sz) for h, w, sz in ans]
else:
    print(-1)
",quadratic,"binary search,dp,greedy",2813
"n, m = map(int, input().split())
c = []
for j in range(n):
    d = []
    s = input()
    for i in s:
        d.append(i)
    c.append(d)
a = []
b = []
e=[]
g=[]

for j in range(n):
    k=[0]*(m)
    e.append(k)
for j in range(n):
    k=[0]*(m)
    g.append(k)

dpu = []
for j in range(n):
    k=[0]*(m)
    dpu.append(k)
dpd = []
for j in range(n):
    k=[0]*(m)
    dpd.append(k)
dpl = []
for j in range(n):
    k=[0]*(m)
    dpl.append(k)
dpr = []
for j in range(n):
    k=[0]*(m)
    dpr.append(k)
for i in range(n):
    for j in range(m):
        if c[i][j] == ""*"":
            if i>0:
                dpu[i][j]+=dpu[i-1][j]+1
            else:
                dpu[i][j]=1
            if j>0:
                dpl[i][j]=dpl[i][j-1]+1
            else:
                dpl[i][j]=1
i=n-1
while(i>=0):
    j=m-1
    while(j>=0):
        if c[i][j] == ""*"":
            if i<(n-1):
                dpd[i][j] += dpd[i + 1][j] + 1
            else:
                dpd[i][j] = 1
            if j<(m-1):
                dpr[i][j] = dpr[i][j + 1] + 1
            else:
                dpr[i][j] = 1
        j+=-1
    i+=-1
for i in range(1,n-1):
    for j in range(1,m-1):
        if c[i][j] == ""*"":
            k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1)
            if k==0:
                pass
            elif k>0:
                a.append([i+1,j+1,k])
                e[i-k][j]+=1
                if (i+k)<(n-1):
                    e[i+k+1][j]+=-1
                g[i][j-k] += 1
                if (j + k) < (m - 1):
                    g[i][j+k+1] += -1
for i in range(m):
    for j in range(1,n):
        if c[j-1][i]==""*"":
            e[j][i]+=e[j-1][i]
for i in range(n):
    for j in range(1,m):
        if c[i][j-1]==""*"":
            g[i][j]+=g[i][j-1]
f=0
for i in range(n):
    for j in range(m):
        if c[i][j]==""*"" and e[i][j]<=0 and g[i][j]<=0:
            f=1
            break
if f==1:
    print(-1)
else:
    print(len(a))
    for j in a:
        print(*j)












",quadratic,"binary search,dp,greedy",2000
"
n, m = map(int, input().split())
c = []
for j in range(n):
    d = []
    s = input()
    for i in s:
        d.append(i)
    c.append(d)
a = []
b = []
e=[]
g=[]

for j in range(n):
    k=[0]*(m)
    e.append(k)
for j in range(n):
    k=[0]*(m)
    g.append(k)

dpu = []
for j in range(n):
    k=[0]*(m)
    dpu.append(k)
dpd = []
for j in range(n):
    k=[0]*(m)
    dpd.append(k)
dpl = []
for j in range(n):
    k=[0]*(m)
    dpl.append(k)
dpr = []
for j in range(n):
    k=[0]*(m)
    dpr.append(k)
for i in range(n):
    for j in range(m):
        if c[i][j] == ""*"":
            if i>0:
                dpu[i][j]+=dpu[i-1][j]+1
            else:
                dpu[i][j]=1
            if j>0:
                dpl[i][j]=dpl[i][j-1]+1
            else:
                dpl[i][j]=1
i=n-1
while(i>=0):
    j=m-1
    while(j>=0):
        if c[i][j] == ""*"":
            if i<(n-1):
                dpd[i][j] += dpd[i + 1][j] + 1
            else:
                dpd[i][j] = 1
            if j<(m-1):
                dpr[i][j] = dpr[i][j + 1] + 1
            else:
                dpr[i][j] = 1
        j+=-1
    i+=-1
for i in range(1,n-1):
    for j in range(1,m-1):
        if c[i][j] == ""*"":
            k=min(dpd[i][j]-1,dpu[i][j]-1,dpr[i][j]-1,dpl[i][j]-1)
            if k==0:
                pass
            elif k>0:
                a.append([i+1,j+1,k])
                e[i-k][j]+=1
                if (i+k)<(n-1):
                    e[i+k+1][j]+=-1
                g[i][j-k] += 1
                if (j + k) < (m - 1):
                    g[i][j+k+1] += -1
for i in range(m):
    for j in range(1,n):
        if c[j-1][i]==""*"":
            e[j][i]+=e[j-1][i]
for i in range(n):
    for j in range(1,m):
        if c[i][j-1]==""*"":
            g[i][j]+=g[i][j-1]
f=0
for i in range(n):
    for j in range(m):
        if c[i][j]==""*"" and e[i][j]<=0 and g[i][j]<=0:
            f=1
            break
if f==1:
    print(-1)
else:
    print(len(a))
    for j in a:
        print(*j)












",quadratic,"binary search,dp,greedy",2001
"n,m = map(int,input().split())
mat = []

for i in range(n):
    mat.append(list(map(int,input().replace(""*"",""1"").replace(""."",""0""))))

ver,hor = [[0 for i in range(m)] for j in range(n)],[[0 for i in range(m)] for j in range(n)]

dp = [[[0 for i in range(4)]for j in range(m) ] for k in range(n)]
for i in range(1,n):
    for j in range(1,m):
        x,y = n-i-1,m-j-1
        if mat[i][j]==1:
            dp[i][j][0] = max(dp[i][j-1][0],mat[i][j-1]) + 1
            dp[i][j][1] = max(dp[i-1][j][1],mat[i-1][j]) + 1
        if mat[x][y]==1:
            dp[x][y][2] = max(dp[x][y+1][2],mat[x][y+1]) + 1
            dp[x][y][3] = max(dp[x+1][y][3],mat[x+1][y]) + 1

stars = []
for i in range(1,n-1):
    for j in range(1,m-1):
        if mat[i][j]==1:
            s = min(dp[i][j])-1
            if s>0:
                stars.append((i+1,j+1,s))
                ver[i-s][j]+=1
                if i+s+1<n:
                    ver[i+s+1][j] -= 1
                hor[i][j-s]+=1
                if j+s+1<m:
                    hor[i][j+s+1] -= 1

for i in range(1,n):
    for j in range(1,m):
        ver[i][j] += ver[i-1][j]
        hor[i][j] += hor[i][j-1]

chk = True
for i in range(n):
    for j in range(m):
        if mat[i][j] and max(ver[i][j],hor[i][j])<=0:
            chk=False
            break

if chk:
    print(len(stars))
    for i in stars:
        print(*i)
else:
    print(-1)",quadratic,"binary search,dp,greedy",1388
"# ---------------------------iye ha aam zindegi---------------------------------------------
import math
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
mod = 10 ** 9 + 7
mod1 = 998244353
#sys.setrecursionlimit(300000)
# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
BUFSIZE = 8192
#sys.setrecursionlimit(300000)
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------game starts now----------------------------------------------------import math
# -----------------------------------------------binary seacrh tree---------------------------------------
# -------------------game starts now----------------------------------------------------import math
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


# --------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m


# --------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z


# --------------------------------------------------product----------------------------------------
def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por


# --------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count


# --------------------------------------------------binary----------------------------------------
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)
# --------------------------------------------------binary------------------------------------
n,m=map(int,input().split())
l=[]
tot=[]
done=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    l.append(input())
colsum=[[0 for i in range(m)]for j in range(n)]
rowsum=[[0 for i in range(m)]for j in range(n)]
col=[[0 for i in range(m)]for j in range(n)]
row=[[0 for i in range(m)]for j in range(n)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            rowsum[i][j]=1
            colsum[i][j]=1
            row[i][j]=1
            col[i][j]=1
for i in range(n):
    for j in range(1,m):
        if l[i][j]=='.':
            continue
        rowsum[i][j]+=rowsum[i][j-1]
for i in range(n):
    for j in range(m-2,-1,-1):
        if l[i][j]=='.':
            continue
        row[i][j]+=row[i][j+1]
for i in range(m):
    for j in range(n-2,-1,-1):
        if l[j][i]=='.':
            continue
        col[j][i]+=col[j+1][i]
for i in range(m):
    for j in range(1,n):
        if l[j][i]=='.':
            continue
        colsum[j][i]+=colsum[j-1][i]
def check(x,y):
    i=x
    j=y
    ans=min(row[i][j],rowsum[i][j],colsum[i][j],col[i][j])-1
    if ans==0:
        return []
    return [ans]
h=[[0 for i in range(m+1)]for j in range(n)]
v=[[0 for i in range(m)]for j in range(n+1)]
for i in range(n):
    for j in range(m):
        if l[i][j]=='*':
            ans=check(i,j)
            for j1 in ans:
                tot.append([i+1,j+1,j1])
                h[i][j-j1]+=1
                h[i][j+j1+1]-=1
                v[i-j1][j]+=1
                v[i+j1+1][j]-=1
for i in range(n):
    for j in range(1,m):
        h[i][j]+=h[i][j-1]
for i in range(m):
    for j in range(1,n):
        v[j][i]+=v[j-1][i]
#print(h)
#print(v)
for i in range(n):
    for j in range(m):
        if l[i][j]=='*' and h[i][j]==0 and v[i][j]==0:
            print(-1)
            sys.exit(0)
print(len(tot))
for i in tot:
    print(*i)

",quadratic,"binary search,dp,greedy",10439
"import sys
input=lambda:sys.stdin.readline().rstrip()

h,w=map(int,input().split())
s=[list("".""*(w+2))]+[list("".""+input()+""."") for _ in range(h)]+[list("".""*(w+2))]
b=[[0]*(w+2)for _ in range(h+2)]
c=[[0]*(w+2)for _ in range(h+2)]
for i in range(1,h+2):
  for j in range(1,w+2):
    if s[i][j]==""*"":
      b[i][j]=b[i-1][j]+1
      c[i][j]=c[i][j-1]+1
for i in range(h,-1,-1):
  for j in range(w,-1,-1):
    if s[i][j]==""*"":
      b[i][j]=min(b[i][j],b[i+1][j]+1)
      c[i][j]=min(c[i][j],c[i][j+1]+1)
ans=[]
for i in range(1,h+1):
  for j in range(1,w+1):
    t=min(b[i][j],c[i][j])-1
    if t>0:
      ans.append((i,j,t))
b=[[0]*(w+2)for _ in range(h+2)]
c=[[0]*(w+2)for _ in range(h+2)]
for i,j,t in ans:
  b[i-t][j]+=1
  b[i+t+1][j]-=1
  c[i][j-t]+=1
  c[i][j+t+1]-=1
for i in range(h+1):
  for j in range(w+1):
    b[i+1][j]+=b[i][j]
    c[i][j+1]+=c[i][j]
    if i!=0 and j!=0:
      if (b[i][j]+c[i][j]>0)!=(s[i][j]==""*""):
        print(-1)
        exit()

print(len(ans))
for i in ans:print(*i)",quadratic,"binary search,dp,greedy",1002
"def main():

    n,m = map(int, input().split())
    S = [list(str(input())) for _ in range(n)]

    L = [[0]*m for _ in range(n)]
    R = [[0]*m for _ in range(n)]
    U = [[0]*m for _ in range(n)]
    D = [[0]*m for _ in range(n)]

    for i in range(n):
        cnt = 0
        for j in range(m):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                L[i][j] = cnt
        cnt = 0
        for j in reversed(range(m)):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                R[i][j] = cnt

    for j in range(m):
        cnt = 0
        for i in range(n):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                U[i][j] = cnt
        cnt = 0
        for i in reversed(range(n)):
            if S[i][j] == '.':
                cnt = 0
            else:
                cnt += 1
                D[i][j] = cnt

    #print(L)
    #print(R)
    #print(U)
    #print(D)
    #T = [['.']*m for _ in range(n)]
    imosH = [[0]*(m+1) for _ in range(n)]
    imosV = [[0]*m for _ in range(n+1)]
    ans = []
    for i in range(1, n-1):
        for j in range(1, m-1):
            if S[i][j] == '.':
                continue
            l = L[i][j]-1
            r = R[i][j]-1
            u = U[i][j]-1
            d = D[i][j]-1
            s = min([l, r, u, d])
            if s == 0:
                continue
            ans.append((i+1, j+1, s))
            imosV[i-s][j] += 1
            imosV[i+s+1][j] -= 1
            imosH[i][j-s] += 1
            imosH[i][j+s+1] -= 1

    #print(imosH)
    #print(imosV)

    from itertools import accumulate
    for i in range(n):
        imosH[i] = list(accumulate(imosH[i]))
    for j in range(m):
        for i in range(1, n+1):
            imosV[i][j] += imosV[i-1][j]

    #print(imosH)
    #print(imosV)

    #print(T)
    for i in range(n):
        for  j in range(m):
            if S[i][j] == '*':
                if imosH[i][j] <= 0 and imosV[i][j] <= 0:
                    print(-1)
                    exit()
    else:
        print(len(ans))
        for i in range(len(ans)):
            print(*ans[i])

if __name__ == '__main__':
    main()
",quadratic,"binary search,dp,greedy",2265
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]
rstr = lambda: stdin.readline().strip()
rstr_2d = lambda n: [rstr() for _ in range(n)]

n, m = rints()
grid = rstr_2d(n)
row = [[[] for _ in range(m)] for _ in range(n)]
col = [[[] for _ in range(m)] for _ in range(n)]
visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0
visc = [[-1 for _ in range(m)] for _ in range(n)]

for i in range(n):
    be, en = -1, -1
    for j in range(m):
        if grid[i][j] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    row[i][k] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            row[i][k] = [be, en]

for i in range(m):
    be, en = -1, -1
    for j in range(n):
        if grid[j][i] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    col[k][i] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            col[k][i] = [be, en]

for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            all += 1
            hor = min(row[i][j][1] - j, j - row[i][j][0])
            ver = min(col[i][j][1] - i, i - col[i][j][0])
            if hor <= ver:
                ver = hor
            else:
                hor = ver

            if hor > 0 and ver > 0:
                out.append('%d %d %d' % (i + 1, j + 1, hor))
                visr[i][j - ver] = j + ver
                visc[i - hor][j] = i + hor

dis = set()
for i in range(n):
    j, ma = 0, -1
    while j < m:
        ma = max(ma, visr[i][j])
        if ma >= j:
            dis.add((i, j))

        j += 1

for i in range(m):
    j, ma = 0, -1
    while j < n:
        ma = max(ma, visc[j][i])
        if ma >= j:
            dis.add((j, i))

        j += 1

if len(dis) != all:
    print(-1)
else:
    print('%d\n%s' % (len(out), '\n'.join(out)))
",quadratic,"binary search,dp,greedy",2109
"import os, sys, atexit
from cStringIO import StringIO as BytesIO

sys.stdout = BytesIO()
atexit.register(lambda: os.write(1, sys.stdout.getvalue()))
input = BytesIO(os.read(0, os.fstat(0).st_size)).readline


rints = lambda: [int(x) for x in input().split()]
rstr = lambda: input().strip()
rstr_2d = lambda n: [rstr() for _ in range(n)]

n, m = rints()
grid = rstr_2d(n)
row = [[[] for _ in range(m)] for _ in range(n)]
col = [[[] for _ in range(m)] for _ in range(n)]
visr, out, all = [[-1 for _ in range(m)] for _ in range(n)], [], 0
visc = [[-1 for _ in range(m)] for _ in range(n)]

for i in range(n):
    be, en = -1, -1
    for j in range(m):
        if grid[i][j] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    row[i][k] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            row[i][k] = [be, en]

for i in range(m):
    be, en = -1, -1
    for j in range(n):
        if grid[j][i] == '*':
            en += 1
            if be == -1:
                be = en = j
        else:
            if be != -1:
                for k in range(be, en + 1):
                    col[k][i] = [be, en]
            be = -1

    if be != -1:
        for k in range(be, en + 1):
            col[k][i] = [be, en]

for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            all += 1
            hor = min(row[i][j][1] - j, j - row[i][j][0])
            ver = min(col[i][j][1] - i, i - col[i][j][0])
            if hor <= ver:
                ver = hor
            else:
                hor = ver

            if hor > 0 and ver > 0:
                out.append('%d %d %d' % (i + 1, j + 1, hor))
                visr[i][j - ver] = j + ver
                visc[i - hor][j] = i + hor

dis = set()
for i in range(n):
    j, ma = 0, -1
    while j < m:
        ma = max(ma, visr[i][j])
        if ma >= j:
            dis.add((i, j))

        j += 1

for i in range(m):
    j, ma = 0, -1
    while j < n:
        ma = max(ma, visc[j][i])
        if ma >= j:
            dis.add((j, i))

        j += 1

if len(dis) != all:
    print(-1)
else:
    sys.stdout.write('%d\n%s' % (len(out), '\n'.join(out)))
",quadratic,"binary search,dp,greedy",2288
"def norm(x):
    return (x % 998244353 + 998244353) % 998244353

n, k = map(int, input().split())

dp1 = [0]
dp2 = [0]

for i in range(n):
    l = [1]
    cur = 0
    for j in range(n + 1):
        cur += l[j]
        if(j > i):
            cur -= l[j - i - 1]
        cur = norm(cur)
        l.append(cur)
    dp1.append(l[n])
    dp2.append(norm(dp1[i + 1] - dp1[i]))

ans = 0
for i in range(n + 1):
    for j in range(n + 1):
        if(i * j < k):
            ans = norm(ans + dp2[i] * dp2[j])

ans = norm(ans * 2)

print(ans)",quadratic,"combinatorics,dp,math",530
"import sys
from array import array  # noqa: F401


def readline(): return sys.stdin.buffer.readline().decode('utf-8')


n, k = map(int, readline().split())
mod = 998244353

if k == 1:
    print(0)
    exit()


dp1 = [array('i', [0])*n for _ in range(n)]
dp2 = [array('i', [0])*n for _ in range(n)]
dp1[0][0] = 1

for i in range(n-1):
    for j in range(i+1):
        for l in range(j+1):
            dp2[j][0] += dp1[j][l]
            if dp2[j][0] >= mod:
                dp2[j][0] -= mod

            dp2[j+1 if j == l else j][l+1] += dp1[j][l]
            if dp2[j+1 if j == l else j][l+1] >= mod:
                dp2[j+1 if j == l else j][l+1] -= mod

            dp1[j][l] = 0

    dp1, dp2 = dp2, dp1

ans = 0
for i in range(1, n+1):
    t = (k-1) // i
    if t == 0:
        break

    dps1 = array('i', [0])*(t+1)
    dps2 = array('i', [0])*(t+1)
    dps1[0] = 1

    for j in range(n-1):
        for l in range(min(j+1, t)):
            dps2[0] += dps1[l]
            if dps2[0] >= mod:
                dps2[0] -= mod

            dps2[l+1] += dps1[l]
            if dps2[l+1] >= mod:
                dps2[l+1] -= mod

            dps1[l] = 0

        dps1, dps2 = dps2, dps1

    x = sum(dp1[i-1]) % mod
    ans = (ans + x * sum(dps1[:-1])) % mod

print(ans * 2 % mod)
",quadratic,"combinatorics,dp,math",1278
"n, m = list(map(int, input().split()))
temp = 0
a = [list(input()) for i in range(n)]
for i in range(n):
    ok = False
    for j in range(m):
        if (a[i][j] == ""B""):
            pos1 = i
            pos2 = j
            temp += 1
            temp2 = j
            if (j != m-1):
                ok = True
                while True:
                    ok2 = False
                    if (temp2 == m-1):
                        ok2 = True
                        break
                    if (a[i][temp2 + 1] != ""B""):
                        ok2 = True
                        break
                    temp += 1
                    temp2 += 1
            elif (j == m - 1):
                temp = 1
                ok = True
                break
            if (ok2):
                break
    if (ok):
        break
print(temp//2 + pos1 + 1, temp//2 + pos2 + 1)",quadratic,implementation,870
"# A. Find Square

n, m = map(int, input().split())

top = [-1, -1]
bottom = [-1, -1]

matrix = list()
for i in range(n):
    s = input()
    matrix.append(s)

for i in range(n):
    left = matrix[i].find('B')
    if left != -1:
        top[0] = i
        top[1] = left
        break

for i in range(n-1, -1, -1):
    right = matrix[i].rfind('B')
    if right != -1:
        bottom[0] = i
        bottom[1] = right
        break

print(1 + top[0] + (bottom[0] - top[0]) // 2, 1 + top[1] + (bottom[1] - top[1]) // 2)
",quadratic,implementation,515
"# A. Find Square

n, m = map(int, input().split())

top = [-1, -1]
bottom = [-1, -1]

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break
",quadratic,implementation,273
"# A. Find Square

n, m = map(int, input().split())

for i in range(n):
    s = input()
    left = s.find('B')
    if left != -1:
        right = s.rfind('B')
        c = (right - left) // 2 + 1
        print(i + c, left + c)
        break
",quadratic,implementation,239
"n,m=map(int,input().split())
l=[]
for i in range(n):
    s=input()
    l.append(s)
minX,minY,maxX,maxY=n,m,0,0
for i in range(n):
    for j in range(m):
        if l[i][j]=='B':
            minX,minY,maxX,maxY=min(minX,i),min(minY,j),max(maxX,i),max(maxY,j)
print((minX+maxX)//2+1,(minY+maxY)//2+1)",quadratic,implementation,298
"n, m = map(int, input().split())

s = [""""] * n
for i in range(n):
    s[i] = input()

for i in range(n):
    for j in range(m):
        if s[i][j] == 'B':
            cnt = 1
            for k in range(j + 1, m):
                if s[i][k] == 'B':
                    cnt += 1
                else:
                    break

            print(i + 1 + cnt // 2, j + 1 + cnt // 2)
            exit(0)
",quadratic,implementation,400
"n, m = map(int,input().split())
r=0
c=0
f= 1
for i in range(n):
    s = input()
    if  f and ""B"" in s:
        f = 0
        ci = s.index('B')
        cc = s.count(""B"")
        r = i+1+cc//2
        c = ci+cc//2+1
print(r,c)",quadratic,implementation,225
"n, m = map(int, input().split())

a = []


def is_center(a, y, x):
    count1 = count2 = count3 = count4 = 0
    # up
    y1 = y
    x1 = x
    while True:
        y2 = y1 - 1
        if y2 < 0:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count1 += 1
        y1 = y2

    # down
    y1 = y
    x1 = x
    while True:
        y2 = y1 + 1
        if y2 == n:
            break
        c = a[y2][x]
        if c == ""W"":
            break
        count2 += 1
        y1 = y2

    # left
    y1 = y
    x1 = x
    while True:
        x2 = x1 - 1
        if x2 < 0:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count3 += 1
        x1 = x2

    # right
    y1 = y
    x1 = x
    while True:
        x2 = x1 + 1
        if x2 == m:
            break
        c = a[y1][x2]
        if c == ""W"":
            break
        count4 += 1
        x1 = x2

    return count1 == count2 == count3 == count4 and a[y][x] == ""B""


for k in range(n):
    s = input()
    a.append(s)


for y in range(n):
    c = False
    for x in range(m):
        if is_center(a, y, x):
            print(y+1, x+1)
            c = True
            break
    if c:
        break


",quadratic,implementation,1226
"n,m = list(map(int,input().split()))
l = []
for i in range(n) :
    s = input()
    l.append(s)
x1=0
x2=0
y1=0
y2=0
for i in range (n) :
    for j in range(m) :
        if l[i][j]=='B' :
            if x1==0 and y1==0 :
                x1,y1 = [i+1,j+1]
            else :
                x2,y2 = [i+1,j+1]
res = []
x=0
y=0
if x2!=0 :
    x = (x2 - x1) // 2
    y = (y2 - y1) // 2
res.append(x1+x)
res.append(y1+y)
print(*res)",quadratic,implementation,426
"n,m=map(int, input().split())
for i in range(n):
    mt=input()
    if mt.count('B')!=0:
        print(mt.count('B')//2+i+1,mt.count('B')//2+mt.index('B')+1)
        break",quadratic,implementation,171
"'''     Design by Dinh Viet Anh(JOKER)
//_____________________________________$$$$$__
//___________________________________$$$$$$$$$
//___________________________________$$$___$
//___________________________$$$____$$$$
//_________________________$$$$$$$__$$$$$$$$$$$
//_______________________$$$$$$$$$___$$$$$$$$$$$
//_______________________$$$___$______$$$$$$$$$$
//________________$$$$__$$$$_________________$$$
//_____________$__$$$$__$$$$$$$$$$$_____$____$$$
//__________$$$___$$$$___$$$$$$$$$$$__$$$$__$$$$
//_________$$$$___$$$$$___$$$$$$$$$$__$$$$$$$$$
//____$____$$$_____$$$$__________$$$___$$$$$$$
//__$$$$__$$$$_____$$$$_____$____$$$_____$
//__$$$$__$$$_______$$$$__$$$$$$$$$$
//___$$$$$$$$$______$$$$__$$$$$$$$$
//___$$$$$$$$$$_____$$$$___$$$$$$
//___$$$$$$$$$$$_____$$$
//____$$$$$$$$$$$____$$$$
//____$$$$$__$$$$$___$$$
//____$$$$$___$$$$$$
//____$$$$$____$$$
//_____$$$$
//_____$$$$
//_____$$$$
'''
from math import *
from cmath import *
from itertools import *
from decimal import *  # su dung voi so thuc
from fractions import *  # su dung voi phan so
from sys import *
from types import CodeType, new_class
#from numpy import *

'''getcontext().prec = x # lay x-1 chu so sau giay phay (thuoc decimal)
Decimal('12.3') la 12.3 nhung Decimal(12.3) la 12.30000000012
Fraction(a) # tra ra phan so bang a (Fraction('1.23') la 123/100 Fraction(1.23) la so khac (thuoc Fraction)
a = complex(c, d) a = c + d(i) (c = a.real, d = a.imag)
a.capitalize() bien ki tu dau cua a(string) thanh chu hoa, a.lower() bien a thanh chu thuong, tuong tu voi a.upper()
a.swapcase() doi nguoc hoa thuong, a.title() bien chu hoa sau dau cach, a.replace('a', 'b', slg)
chr(i) ki tu ma i ord(c) ma ki tu c
a.join['a', 'b', 'c'] = 'a'a'b'a'c, a.strip('a') bo dau va cuoi ki tu 'a'(rstrip, lstrip)
a.split('a', slg = -1) cat theo ki tu 'a' slg lan(rsplit(), lsplit()), a.count('aa', dau = 0, cuoi= len(a)) dem slg
a.startswith('a', dau = 0, cuoi = len(a)) co bat dau bang 'a' ko(tuong tu endswith())
a.index(""aa"") vi tri dau tien xuat hien (rfind())
input = open("".inp"", mode='r')  a = input.readline()
out = open("".out"", mode='w') a.index(val) '''
#inn = open("".inp"", ""r"")

a = []
n, m = map(int, input().split())
minx, miny, maxx, maxy = n, m, 0, 0
for x in range(n):
    a.append(input())
    for y in range(m):
        if a[x][y] == 'B':
            minx = min(minx, x + 1)
            miny = min(miny, y + 1)
            maxx = max(maxx, x + 1)
            maxy = max(maxy, y + 1)
print((maxx + minx) // 2 , (maxy + miny) // 2)
",quadratic,implementation,2519
"n,m=map(int,input().split())
listi=[]
for i in range(0,n):
    string=input()
    listi.append(string)
rownum=0 
flag=False
for row in listi:
    
    for letter in row:
            if(""B"" in row):
                p=row.index(""B"")
                
                s=row[::-1]
                q=abs(m-s.index(""B"")-1)
                
                if(p==q):
                    print(rownum+1,row.index(row[p])+1)
                    flag=True
                    break
                mr=(q+p)/2
                
                length=abs(q-p+1)
                
                rn= rownum + length//2
                
                print(rn+1,int(mr+1))
                flag=True
                break
            
            
    if(flag==True):
        break
            
    rownum+=1
            ",quadratic,implementation,807
"import math
a,b=map(int,input().split())
c=[]
e=[]
f=0
for i in range(a):
    d=str(input())
    for j in range(b):
        if d[j]==""B"":
            c=c+[i]
            e=e+[j]
p=min(c)
p1=min(e)
p2=max(c)
plus=(max(c)-min(c))//2
p3=p+plus+1
p4=p1+plus+1
print(p3,p4)
",quadratic,implementation,269
"n,m = map(int,input().split())
li = [[j for j in input()] for i in range(n)]

for j in range(m):
    flag = False
    for i in range(n):
        if li[i][j] == ""B"":
            flag = True
            position1 = i
            break
    if(flag == True):
        break
for j in range(m-1,-1,-1):
    flag = False
    for i in range(n-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position2 = i
            break
    if(flag == True):
        break
for i in range(n):
    flag = False
    for j in range(m):
        if li[i][j] == ""B"":
            flag = True
            position3 = j
            break
    if(flag == True):
        break
for i in range(n-1,-1,-1):
    flag = False
    for j in range(m-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position4 = j
            break
    if(flag == True):
        break

avg1 = (position1+position2)//2 + 1
avg2 = (position3 + position4)//2 + 1
print(avg1,avg2)",quadratic,implementation,965
"n,m = map(int,input().split())
li = [[j for j in input()] for i in range(n)]
position1=0
position2=0
position3=0
position4=0
for j in range(m):
    flag = False
    for i in range(n):
        if li[i][j] == ""B"":
            flag = True
            position1 = i
            break
    if(flag == True):
        break
for j in range(m-1,-1,-1):
    flag = False
    for i in range(n-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position2 = i
            break
    if(flag == True):
        break
for i in range(n):
    flag = False
    for j in range(m):
        if li[i][j] == ""B"":
            flag = True
            position3 = j
            break
    if(flag == True):
        break
for i in range(n-1,-1,-1):
    flag = False
    for j in range(m-1,-1,-1):
        if li[i][j] == ""B"":
            flag = True
            position4 = j
            break
    if(flag == True):
        break

avg1 = (position1+position2)//2 + 1
avg2 = (position3 + position4)//2 + 1
print(avg1,avg2)
# print(li)",quadratic,implementation,1024
"from math import *
n,m = map(int,input().split())
li = [[j for j in input()] for i in range(n)]
min1=inf
min2=inf
max1=-inf
max2=-inf
for i in range(n):
    for j in range(m):
        if li[i][j] == ""B"":
            min1 = min(min1,i)
            min2 = min(min2, j)
            max1 = max(max1, i)
            max2 = max(max2, j)
print((min1+max1)//2+1,(min2+max2)//2+1)",quadratic,implementation,371
"n,m=map(int,input().split())
lock=0
for i in range(n):
    s=str(input())
    if(('B' in s) and (lock==0)):
        Rstart=s.index('B')
        cnt=s.count('B')
        Rcen=Rstart+(cnt//2)
        Cstart=i
        Ccen=Cstart+(cnt//2)
        lock=1
        
print(Ccen+1,Rcen+1)        
        
        ",quadratic,implementation,306
"n,m=map(int,input().split())
listi=[]
for i in range(0,n):
    string=input()
    listi.append(string)
rownum=0 
flag=False
for row in listi:
    
    for letter in row:
            if(""B"" in row):
                p=row.index(""B"")
                
                s=row[::-1]
                q=abs(m-s.index(""B"")-1)
                
                if(p==q):
                    print(rownum+1,row.index(row[p])+1)
                    flag=True
                    break
                mr=(q+p)/2
                
                length=abs(q-p+1)
                
                rn= rownum + length//2
                
                print(rn+1,int(mr+1))
                flag=True
                break
            
            
    if(flag==True):
        break
            
    rownum+=1",quadratic,implementation,794
"n, m = map(int, input().split())
x1 = -1
x2 = -1
y1 = -1
y2 = -1
for i in range(n):
    s = input()
    for j in range(m):
        if s[j] == 'B':
            if x1 == -1:
                x1 = j + 1
            x2 = max(x2, j + 1)
            if y1 == -1:
                y1 = i + 1
            y2 = i + 1
print((y1 + y2) // 2, (x1 + x2) // 2)",quadratic,implementation,343
"n,m=input().split()
i=j=-1
while(j<0):
    mat=input()
    j=mat.find('B')
    i+=1
    c=mat.count('B')//2+1
print(i+c,j+c)",quadratic,implementation,124
"### Find Square
n,m=map(int,input().split())
M=[['0' for x in range(m)] for y in range(n)] 
for a in range(n):
    i=input()
    for b in range(len(i)):
        #print(a,b)
        M[a][b]=i[b]
start=[]
end=[]
for a in range(n):
    for b in range(m):
        if M[a][b]=='B':
            if not start:
                #print(1)
                start.append(a+1)
                start.append(b+1)
            else:
                #print(2)
                end.clear()
                end.append(a+1)
                end.append(b+1)
                
#print(start,end)
if not start or not end:
    print(start[0],start[1])
else:
    mid1=int((end[0]+start[0])/2)
    mid2=int((end[1]+start[1])/2)
    print(mid1,mid2)
                ",quadratic,implementation,733
"import sys
# sys.setrecursionlimit(300000)
# Get out of main functoin
def main():
    pass
# decimal to binary
def binary(n):
    return (bin(n).replace(""0b"", """"))
# binary to decimal
def decimal(s):
    return (int(s, 2))
# power of a number base 2
def pow2(n):
    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
# if  number is prime in √n time
def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
# list to string ,no spaces
def lts(l):
    s = ''.join(map(str, l))
    return s
# String to list
def stl(s):
    # for each character in string to list with no spaces -->
    l = list(s)
    # for space in string  -->
    # l=list(s.split("" ""))
    return l
# Returns list of numbers with a particular sum
def sq(a, target, arr=[]):
    s = sum(arr)
    if (s == target):
        return arr
    if (s >= target):
        return
    for i in range(len(a)):
        n = a[i]
        remaining = a[i + 1:]
        ans = sq(remaining, target, arr + [n])
        if (ans):
            return ans
# Sieve for prime numbers in a range
def SieveOfEratosthenes(n):
    cnt = 0
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    for p in range(2, n + 1):
        if prime[p]:
            cnt += 1
            # print(p)
    return (cnt)
# for positive integerse only
def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)
# 1000000007
mod = int(1e9) + 7
def ssinp(): return sys.stdin.readline().strip()
# s=input()
def iinp(): return int(input())
# n=int(input())
def nninp(): return map(int, sys.stdin.readline().strip().split())
# n, m, a=[int(x) for x in input().split()]
def llinp(): return list(map(int, sys.stdin.readline().strip().split()))
# a=list(map(int,input().split()))
def p(xyz): print(xyz)
def p2(a, b): print(a, b)
import math
########################list.sort(key=lambda x:x[1]) for sorting a list according to second element in sublist
#d1.setdefault(key, []).append(value)
###################ASCII of A-Z= 65-90
##########################ASCII of a-z= 97-122
#import random
#######################from collections import OrderedDict
#from fractions import Fraction
#=#####################===========Speed: STRING < LIST < SET,DICTIONARY==========================
#######################from collections import deque
#for __ in range(iinp()):
n,m=nninp()
ans=0
cnt=f=0
for i in range(n):
    s=ssinp()
    r=stl(s)
    cnt=0
    for c in range(len(r)):
        if(r[c]==""W"" and f==0):
            pass
        elif(r[c]==""B"" and f==0):
            cnt+=1
            f=1
        elif(r[c]==""B"" and f==1):
            cnt+=1
        elif(r[c]==""W"" and f==1):
            f=0
            if(cnt%2==1):
                print(i+1+(cnt//2),c-(cnt//2))
                exit()
    if(cnt%2==1):
        print(i+1+cnt//2,c+1-cnt//2)
        exit()
"""""" Stuff you should look for
    int overflow, array bounds
    special cases (n=1?)
    do something instead of nothing and stay organized
    WRITE STUFF DOWN
	DON'T GET STUCK ON ONE APPROACH""""""
",quadratic,implementation,3317
"import sys
import math
from collections import defaultdict,deque

input = sys.stdin.readline
def inar():
    return [int(el) for el in input().split()]
def main():
    n,k=inar()
    st=input().strip()
    res=st
    pos=1
    cnt=1
    while cnt<k:
        suffix=0
        counter=0
        for i in range(pos,len(res)):
            if res[i]==st[suffix]:
                suffix+=1
            else:
                counter=1
                break
        if counter:
            pos+=1
            continue
        if pos>len(res):
            res+=st
            cnt+=1
            pos+=1
            continue
        res+=st[suffix:n]
        cnt+=1
        pos+=1
    print(res)




if __name__ == '__main__':
    main()



",quadratic,"implementation,strings",730
"n,k = map(int,input().split())
s= input()
s1=s
c=0
for i in range(len(s)-1):
    if(s[:i+1]==s[n-i-1:]):
        c=i+1
for i in range(k-1):
    s1+=s[c:]
print(s1)",quadratic,"implementation,strings",163
"from os import path
import sys,time
# mod = int(1e9 + 7)
# import re
from math import ceil, floor,gcd,log,log2 ,factorial
from collections import * 
# from bisect import *
maxx = float('inf')
#----------------------------INPUT FUNCTIONS------------------------------------------#
I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
#left shift --- num*(2**k) --(k - shift)

n , k= tup()
s = S()

fl =0
l = None
for i in range(1, n):
	x =s[i:n]
	for j in range(n):
		if x == s[:j+1]:
			l = j+1
			fl = 1
			break
	if fl :
		break
if fl :
	ans = s + s[l:n]*(k-1)
	print(ans)
else:
	print(s*k)






# n = I()
# ls = [int(i) for i in S()]
# pre , s =[] , 0
# for i in ls:
# 	s+=i
# 	pre.append(s)
# for i in range(n-1):
# 	cnt =0
# 	su =0
# 	for j in range(i+1 , n):
# 		su+=ls[j]
# 		if su == pre[i]:
# 			cnt+=1
# 			su =0
# 	if cnt and su ==0:
# 		print('YES')
# 		exit()
# print('NO')









if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",quadratic,"implementation,strings",1437
"from os import path
import sys,time
# mod = int(1e9 + 7)
# import re
from math import ceil, floor,gcd,log,log2 ,factorial
from collections import * 
# from bisect import *
maxx = float('inf')
#----------------------------INPUT FUNCTIONS------------------------------------------#
I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
#left shift --- num*(2**k) --(k - shift)

n , k = tup()
s , i = S() , 1
while s[i:] != s[:-i] :i+=1
print(s[:i]*k + s[i:])




# n = I()
# ls = [int(i) for i in S()]
# pre , s =[] , 0
# for i in ls:
# 	s+=i
# 	pre.append(s)
# for i in range(n-1):
# 	cnt =0
# 	su =0
# 	for j in range(i+1 , n):
# 		su+=ls[j]
# 		if su == pre[i]:
# 			cnt+=1
# 			su =0
# 	if cnt and su ==0:
# 		print('YES')
# 		exit()
# print('NO')









if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",quadratic,"implementation,strings",1298
"n,k = map(int,input().split())
t = input()
if n==1:
    print(t*k)
else:
    i = len(t)-1
    while i>0 and t[-i:] != t[:i]:
            i-=1
    t2 = t[i:]
    print(t+t2*(k-1))",quadratic,"implementation,strings",178
"from sys import stdin,stdout
def main():
	n,k=map(int,stdin.readline().split( ))
	s=stdin.readline()
	start=-1
	i=0;j=1;prev=1
	while i<n-1:
		while j<n:
			if s[i]==s[j]:
				if start==-1:
					start=j
					prev=j
				i+=1
				j+=1
			else:
				i=0
				j=prev+1
				prev=j
				start=-1
		break
	if start==-1:
		stdout.write(""%s\n""%(s[:n]*k))
	else:
		j = n - start
		stdout.write(""%s\n""%(s[:n]+s[j:n]*(k-1)))
main()

",quadratic,"implementation,strings",418
"def solve():
    n, k = [int(x) for x in input().split(' ')]
    t = input()
    j = 0
    for i in range(1, n):
        if t[:i] == t[-i:]:
            j = i
    s = t + (k - 1) * t[-(n - j):]
    return s

print(solve())

",quadratic,"implementation,strings",224
"n,k=map(int,input().split())
s=input();flag=True;lenn=10**10;ans=0
for i in range(n):
  s1=s+s[n-i-1:]*(k-1);cnt=0
  for i in range(len(s1)-len(s)+1):
     if s1[i:i+len(s)]==s:cnt+=1
  if cnt==k and len(s1)<lenn:ans=s1;lenn=len(s1)
print(ans)
",quadratic,"implementation,strings",244
"def prefix_func(s):
    slen, k = len(s), 0
    p = [0]*slen
    p[0] = 0
    for i in range(1, slen):
        while k>0 and s[k] != s[i]:
            k = p[k-1]
        if s[k] == s[i]:
            k += 1
        p[i] = k
    return p
n,k=map(int,input().split())
s=input()
l=prefix_func(s)[-1]
print(s+s[l:]*(k-1))
",quadratic,"implementation,strings",317
"# 1029A

n, k = [int(num) for num in input().split(' ')]
string = input()


def fn(string, k):
    maximum_match = 0
    for i in range(1, len(string)):
        if string[:i] == string[-i:]:
            maximum_match = i

    answer = list(string)
    extra = list(string[maximum_match:])
    for i in range(k-1):
        answer.extend(extra)

    return ''.join(answer)


print(fn(string, k))
",quadratic,"implementation,strings",394
"
def solve():
    n, k = [int(x) for x in input().split(' ')]
    t = input()
    j = 0
    for i in range(1, n):
        if t[:i] == t[-i:]:
            j = i
    s = t + (k - 1) * t[-(n - j):]
    return s
 
print(solve())",quadratic,"implementation,strings",224
"n,k = map(int,input().split())
s = input()
c=0
for i in range(len(s)):
	if s[:i]==s[-i:]:
		c=i
print(s+s[c:]*(k-1))",quadratic,"implementation,strings",116
"tam,q = [int(i) for i in input().split()]
t = input()
s = t

posi = -1

for j in range(tam-1):
    if(t[:j+1] == t[tam - j -1:]):
        posi = j

add = t[posi+1:]

for j in range(q-1):
    s += add
    
print(s)
	   		     				   	 					 			",quadratic,"implementation,strings",243
"v = input().split()
n = int(v[0])
k = int(v[1])

s = input()
ap = 0

i = 1
while i < n:
    if s[:i] == s[-i:]:
        ap = i

    i += 1

print(s + s[ap:]*(k-1))
  	    					  		 	   			 	  		",quadratic,"implementation,strings",194
"'''

                            Online Python Compiler.
                Code, Compile, Run and Debug python program online.
Write your code in this editor and press ""Run"" button to execute it.

'''
n,kk=map(int,input().split())
s=input()
if(s==s[::-1] or s!=s[::-1]):
    k=""""
    l=0
    for i in reversed(range(1,n)):
        k=s[i]+k
        #print(k)
        if(s.startswith(k)):
            l=len(k)
    ss=s[l:]
    fs=s+(ss*(kk-1))
    print(fs)
        
",quadratic,"implementation,strings",463
"n, k = map(int, input().split())
s = input()
# fail = [-1] * len(s)
# for i in range(1, len(s)):
#     j = fail[i - 1]
#     while j != -1 and s[i - 1] != s[j]:
#         j = fail[j]
#     fail[i] = j + 1
# # print(fail)
# l = fail[-1]
# print(s + s[l:] * (k - 1))
for i in range(1, n):
    if s[:n - i] == s[i:]:
        print(s + s[n - i:] * (k - 1))
        exit()
print(s * k)
",quadratic,"implementation,strings",381
"n, k = map(int, input().split())
s = input()
fail = [-1] * (len(s) + 1)
for i in range(1, len(s) + 1):
    j = fail[i - 1]
    while j != -1 and s[i - 1] != s[j]:
        j = fail[j]
    fail[i] = j + 1
# print(fail)

f1 = fail[-1]
print(s + s[f1:] * (k - 1))",quadratic,"implementation,strings",259
"import sys
input=sys.stdin.readline
def read():return list(map(int,input().split()))
n,k=read()
s=input()[:-1]
ans=""""
for i in range(len(s)+1, 0, -1):
    res=s
    end=s[-i:]
    for j in range(k-1):
        res += end
    cnt=0
    for j in range(len(res)-len(s)+1):
        if res[j:j+len(s)] == s:
            cnt += 1
    if cnt == k:
        ans = res
print(ans)
",quadratic,"implementation,strings",369
"tam,q = [int(i) for i in input().split()]
t = input()
s = t

posi = -1

for j in range(tam-1):
    if(t[:j+1] == t[tam - j -1:]):
        posi = j

add = t[posi+1:]

for j in range(q-1):
    s += add
    
print(s)",quadratic,"implementation,strings",213
"n,k=map(int,input().split())
s=input()

i=-1
for j in range(n-1):
    if s[:j+1]==s[n-j-1:]:
        i=j
add=s[i+1:]
for j in range(k-1):
    s+=add
print(s)",quadratic,"implementation,strings",157
"a = list(map(int, input().split()))
n = a[0]
k = a[1]
s = input()
m = int(-1)
for i in range(0, n - 1):
    ff = int(0)
    for j in range(0, i + 1):
        if s[j] != s[n - i - 1 + j]:
            ff = 1
            break;
    if ff == 0:
        m = i
print(s, end="""")
for i in range(1, k):
    for j in range(m + 1, n):
        print(s[j], end="""")

		 	  	  		 			 	  				 	 					",quadratic,"implementation,strings",384
"n, k = map(int, input().split())
t = input()
i = 1
while t[:-i] != t[i:]:
    i += 1
print(t[:i] * k + t[i:])",quadratic,"implementation,strings",109
"n, k = map(int,input().split())
s = input()
p = len(s)-1
while s[:p] != s[-p:]:
    p =  p -1
print(s + s[p:]*(k-1))",quadratic,"implementation,strings",116
"v = input().split()
n = int(v[0])
k = int(v[1])

s = input()
ap = 0

i = 1
while i < n:
    if s[:i] == s[-i:]:
        ap = i

    i += 1

print(s + s[ap:]*(k-1))",quadratic,"implementation,strings",163
"n,k = map(int,input().split())
s = input()
f = 0
for i in range(1,n):
    if s[:n-i]==s[i:]:
        f=1
        break
if f==0:
    print(s*k)
else:
    j = n-i
    final = s[j:]
    print(s+final*(k-1))",quadratic,"implementation,strings",203
"from os import path
import sys,time
# mod = int(1e9 + 7)
# import re
from math import ceil, floor,gcd,log,log2 ,factorial
from collections import * 
# from bisect import *
maxx = float('inf')
#----------------------------INPUT FUNCTIONS------------------------------------------#
I = lambda :int(sys.stdin.buffer.readline())
tup= lambda : map(int , sys.stdin.buffer.readline().split())
lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]
S = lambda: sys.stdin.readline().replace('\n', '').strip()
def grid(r, c): return [lint() for i in range(r)]
stpr = lambda x : sys.stdout.write(f'{x}' + '\n')
star = lambda x: print(' '.join(map(str, x)))
localsys = 0
start_time = time.time()
if (path.exists('input.txt')):
	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
#left shift --- num*(2**k) --(k - shift)
n = I()
ls = [int(i) for i in S()]
pre , s =[] , 0
for i in ls:
	s+=i
	pre.append(s)
for i in range(n-1):
	cnt =0
	su =0
	for j in range(i+1 , n):
		su+=ls[j]
		if su == pre[i]:
			cnt+=1
			su =0
	if cnt and su ==0:
		print('YES')
		exit()
print('NO')









if localsys:
	print(""\n\nTime Elased :"",time.time() - start_time,""seconds"")
",quadratic,implementation,1176
"n=int(input())
s=input()
l=[]
total=0
p=0
for i in range(0,450):
    sum1=0
    flag=1
    r=0
    for k in range(n):
        sum1=sum1+int(s[k])
        if(sum1>i):
            flag=0
        if(sum1==i):
            sum1=0
            r=r+1
    if(r>=2 and sum1==0 and flag==1):
        print(""YES"")
        p=1
        break
if(p==0):
    print(""NO"")",quadratic,implementation,353
"n=int(input())
a=int(input())

s=0
t=a
b=[]
for i in range(n):
    s+=t%10
    b.append(t%10)
    t//=10
    # print(""***"")
b.reverse()    
# print(b)
i=2
ans=False
# print(s)
if(s==0): ans=True
while(i<=s):
    # print(i)
    if(s%i!=0): 
        i+=1
        continue
    l=s//i
    c=0
    su=0
    for j in range(n):
        if(su>l):
            break
        else:
            su+=b[j]
            if(su==l):
                su=0
                c+=1
    if(c==i):
        ans=True
    # print(i,""**"")    
    i+=1
if(ans): print(""YES"")
else:print(""NO"")",quadratic,implementation,559
"import sys, math

n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().rstrip()))
if len(set(arr)) == 1:
    print('YES')
else:
    val = sum(arr)
    factor = set()
    for i in range(1, int(val ** 0.5) + 1):
        if val % i == 0:
            factor.add(i)
            factor.add(val // i)
    can = False
    for i in factor:
        each = val // i
        if 1 < i <= n:
            idx = 0
            temp = 0
            cnt = 0
            while idx < n:
                if temp + arr[idx] < each:
                    temp += arr[idx]
                elif temp + arr[idx] > each:
                    temp = 0
                else:
                    temp = 0
                    cnt += 1
                idx += 1
            if cnt == i:
                can = True
    print('YES' if can else 'NO')

",quadratic,implementation,830
"from sys import stdin,stdout
def main():
	n=int(stdin.readline())
	s=stdin.readline()
	sum=0
	a=[]
	for v in s:
		if v!='0' and v!='\n':
			a.append(v)
	if not a and n>1:
		return 'YES'
	n=len(a)
	s=a
	for i in range(n-1):
		sum+=int(s[i])
		j=i+1
		check=1
		while j<n:
			temp=int(s[j])
			j+=1
			while j<n:
				if temp>=sum:
					break
				temp+=int(s[j])
				j+=1
			if sum!=temp:
				check=1
				break
		if sum!=temp:
			check=0
		if check:
			return 'YES'
	return 'NO'
print(main())

",quadratic,implementation,491
"import sys, math
 
n = int(sys.stdin.readline())
arr = list(map(int, sys.stdin.readline().rstrip()))
if len(set(arr)) == 1:
    print('YES')
else:
    val = sum(arr)
    factor = set()
    for i in range(1, int(val ** 0.5) + 1):
        if val % i == 0:
            factor.add(i)
            factor.add(val // i)
    can = False
    for i in factor:
        each = val // i
        if 1 < i <= n:
            idx = 0
            temp = 0
            cnt = 0
            while idx < n:
                if temp + arr[idx] < each:
                    temp += arr[idx]
                elif temp + arr[idx] > each:
                    temp = 0
                else:
                    temp = 0
                    cnt += 1
                idx += 1
            if cnt == i:
                can = True
    print('YES' if can else 'NO')
 ",quadratic,implementation,831
"n = int(input())
a = list(input())
smm = 0
for i in range(n):
    a[i] = int(a[i])
    smm += a[i]
ans = ""NO""
sm = smm
for div in range(2, n + 1):
    sm = smm
    if not sm % div:
        sm //= div
        f = 0
        s = 0
        for i in range(n):
            s += a[i]
            if s == sm:
                s = 0
                f += 1
        if f == div:
            ans = ""YES""
            break
print(ans)
",quadratic,implementation,420
"# https://codeforces.com/problemset/problem/1030/C

import sys

lines = sys.stdin.readlines()


def read_a_num(line):
    n = int(line.strip())
    return n


def read_a_str(line):
    line = line.strip()
    return line


def check_ticket(digits):
    for target in range(900):
        seg_i = 0
        seg_sum = 0
        next_flag = False
        for d in digits:
            int_d = int(d)
            if int_d > target:
                next_flag = True
                break
            elif seg_sum + int_d > target:
                if next_flag:
                    break
                next_flag = True
                continue
            elif int_d == target or seg_sum + int_d == target:
                seg_i += 1
                seg_sum = 0
            else:
                seg_sum += int_d

        if next_flag:
            continue

        if seg_i >= 2 and seg_sum == 0:
            return True

    return False


digits = read_a_str(lines[1])
if check_ticket(digits):
    print(""yes"")
else:
    print(""no"")
",quadratic,implementation,1030
"#!/usr/bin/python3

import sys
import argparse
import json

def main():
    n = int(sys.stdin.readline())
    ticket = sys.stdin.readline().rstrip()
    integers = [int(x) for x in ticket]

    zeros = 0
    while zeros < len(integers) and integers[-1*(zeros+1)] == 0:
        zeros += 1

    if zeros > 0 and zeros >= len(integers):
        integers = []
    elif zeros > 0:
        integers = integers[:-1*zeros]
    #print(integers)
    if not integers:
        print(""YES"")
        return
    if len(integers) == 1:
        print(""NO"")
        return

    total = 0
    for i, val in enumerate(integers[:-1]):
        total += val
        splice = integers[i+1:]
        if is_golden(total, splice):
            print(""YES"")
            return
    print(""NO"")

def is_golden(total, integers):
    current_total = 0

    for i, val in enumerate(integers):
        current_total += val
        if current_total < total:
            continue
        elif current_total == total:
            #print(""Here: %s,%s (%s)"" % (total, val, integers[i+1:]))
            splice = integers[i+1:]
            return (not splice) or is_golden(total, splice)
        elif current_total > total:
            return False
    return False

def get_tests():
    tests = [(""5\n73452"", ""YES""),
             (""4\n1248"", ""NO""),
             (""4\n7435"", ""NO""),
             (""8\n0020200"", ""YES""),
             (""99\n999999999999999999999999999999999999999999999918888888888888888888888888888888888888888888888888887"", ""YES""),
             (""84\n123608423980567916563149282633127550576921328162851174479585123236498689270768303090"", ""YES""),
             (""2\n00"", ""YES""),
             (""8\n00020200"", ""YES""),
             (""5\n11980"", ""NO""),
             (""3\n100"", ""NO"")]

    for test in tests:
        print(json.dumps({""input"": test[0], ""output"": test[1]}))

if __name__ == ""__main__"":
    parser = argparse.ArgumentParser()
    parser.add_argument(""--get-tests"", action=""store_true"")
    args = parser.parse_args()

    if args.get_tests:
        get_tests()
    else:
        main()
",quadratic,implementation,2067
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter , defaultdict
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):

#Code

def solve(x , arr ):

    n = len(arr)
    flag = True
    k = []
    i = 0
    while flag:
        sm = 0
        while n > 0 and sm < x :
            sm += int(arr[i])
            i +=1
            n -=1
            if n <= 0 :
                flag = False
                break
        if sm>0:
            k.append(sm)

    return k

n = INT()
s = STR()

if len(set(s)) == 1 :
    print('YES');exit(0)

l = []
t = 0
for i in range(n-1):
    t += int(s[i])
    l.append(t)

#print(l)

v = []
for i in l :
    if i > 0 :
        r = solve(i , s)
        if len(r) > 1 and len(set(r)) == 1 :
            print('YES')
            break
else:
    print('NO')


",quadratic,implementation,1314
"import sys
from collections import deque
import bisect
def chk(l,r,total):
    b = len(l)
    prev = 0
    i = 0
    f = 1
    cnt = 0
    while i < b:
        prev = prev+l[i]
        if cnt == total and prev == r:
            i = i+1
            continue

        if prev == r:
            cnt += 1
            if cnt != total:
                prev = 0

        i = i+1

    if cnt < total or i != b:
        f = 0

    return f


for _ in range(1):
    n = int(input())
    s = input()
    l = []
    som = 0
    for i in s:
        l.append(int(i))
        som += int(i)

    flag = 0
    for i in range(2,n+1):
        if som%i == 0:
            r = som//i
            if chk(l,r,i):
                flag = 1
                break

        if flag:
            break

    if flag:
        print(""YES"")

    else:
        print(""NO"")
",quadratic,implementation,838
"import math
#n,s = map(int, input().strip().split(' '))
n=int(input())
#lst = list(map(int, input().strip().split(' ')))
s2=input()
s2=list(s2)
s=[]
for i in range(n):
    if s2[i]=='0':
        continue
    else:
        s.append(int(s2[i]))
s1=sum(s)
n=len(s)
l=[]
for i in range(2,n+1):
    if s1%i==0:
        l.append(s1//i)
f=0
if len(s)==0:
    f=1
for i in range(len(l)):
    c=0
    if f==1:
        break
    for j in range(n):
        c+=s[j]
        if c==l[i]:
            c=0
            if j==n-1:
                f=1
        elif c<l[i]:
            c=c
        else:
            break
if f==0:
    print('NO')
else:
    print('YES')",quadratic,implementation,649
"def solve():
    n = int(input())
    l = list(map(int,list(input())))
    divisors = []
    total = sum(l)
    for j in range(2,int(sqrt(total))+1):
        if(total%j==0):
            divisors.extend([j,total//j])
    if(total==0):
        print(""YES"")
        return
    if(total!=1):
        divisors.append(1)
    # print(divisors)
    for x in divisors:
        search = x
        index = 0
        summ = 0
        while(index<n):
            summ+=l[index]
            if(summ>search):
                break
            elif(summ==search):
                summ = 0
            index+=1
            # print(summ,search)
        if(summ==0 and index==n):
            print(""YES"")
            return
    print(""NO"")
import sys
import math
import bisect
from sys import stdin,stdout
from math import gcd,floor,sqrt,log
from collections import defaultdict as dd
from bisect import bisect_left as bl,bisect_right as br

inp    =lambda: int(input())
strng  =lambda: input().strip()
jn     =lambda x,l: x.join(map(str,l))
strl   =lambda: list(input().strip())
mul    =lambda: map(int,input().strip().split())
mulf   =lambda: map(float,input().strip().split())
seq    =lambda: list(map(int,input().strip().split()))

ceil   =lambda x: int(x) if(x==int(x)) else int(x)+1
ceildiv=lambda x,d: x//d if(x%d==0) else x//d+1

flush  =lambda: stdout.flush()
stdstr =lambda: stdin.readline()
stdint =lambda: int(stdin.readline())
stdpr  =lambda x: stdout.write(str(x))

solve()



",quadratic,implementation,1471
"
_=input()
n=input()
num=int(n)

list_n=list(n)
list_n_int=list(map(int,n))


lower=max(list_n_int)
total=sum(list_n_int)
upper=int(total/2)

flag=False
if lower == 0:
    print(""YES"")
else:
    for i in range(lower,upper+1):
        flag=True
        p=0
        temp=0
        each=i
        seg=total/each
        if seg.is_integer():
            while p < len(n):

                temp+=list_n_int[p]
                if temp < each:
                    p+=1
                elif temp == each:
                    temp=0
                    p+=1
                else:
                    flag=False
                    break
            if flag:
                print(""YES"")
                break
        else:
            flag=False
    if not flag:
        print(""NO"")
",quadratic,implementation,774
"n = int(input())

arr = [int(z) for z in list(input())]
ans = 0

if n == 2:
    if arr[0] == arr[1]:
        print(""YES"")
    else:
        print(""NO"")
    exit()

for l in range(1, n-1):
    s = sum(arr[:l])
    i = l
    v = [s]
    curr = 0
    while i < n:
        curr += arr[i]
        if i == n-1:
            if curr > s:
                curr -= arr[i]
                v.append(curr)
                curr = arr[i]
            v.append(curr)
        elif curr > s:
            curr -= arr[i]
            v.append(curr)
            curr = arr[i]
        i += 1

    #print(v)

    if len(set(v)) == 1:
        print(""YES"")
        #print(l, s, v)
        ans = 1
        exit()

if not ans:
    print(""NO"")


#
# ans = 0
# for p in range(sum(arr)+1):
#     i = 0
#     curr = 0
#     while i < n:
#         if i == n-1:
#             if curr+arr[i] != p:
#                 break
#             else:
#                 print(""YES"")
#                 ans = 1
#                 exit()
#         curr += arr[i]
#         if curr == p:
#             if i == n-1:
#                 i += 1
#             i += 1
#             curr = 0
#             continue
#         elif curr > p:
#             break
#         elif curr < p:
#             i += 1
#
#     if i == n:
#         print(""YES"")
#         ans = 1
#         exit()
#     #print(p)
#
# if not ans:
#     print(""NO"")",quadratic,implementation,1372
"import sys,math,bisect
from random import randint
inf = float('inf')
mod = 998244353
""========================================""
def lcm(a,b):
    return int((a/math.gcd(a,b))*b)
def gcd(a,b):
    return int(math.gcd(a,b))
def tobinary(n):
    return bin(n)[2:]
def binarySearch(a,x):
    i = bisect.bisect_left(a,x)
    if i!=len(a) and a[i]==x:
        return i
    else:
        return -1
def lowerBound(a, x):
    i = bisect.bisect_left(a, x)
    if i:
        return (i-1)
    else:
        return -1
def upperBound(a,x):
    i = bisect.bisect_right(a,x)
    if i!= len(a)+1 and a[i-1]==x:
        return (i-1)
    else:
        return -1
def primesInRange(n):
    ans = []
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    for p in range(2, n+1):
        if prime[p]:
            ans.append(p)
    return ans
def primeFactors(n):
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n = n // 2
    for i in range(3,int(math.sqrt(n))+1,2):
        while n % i== 0:
            factors.append(i)
            n = n // i
    if n > 2:
        factors.append(n)
    return factors
def isPrime(n,k=5):
    if (n <2):
        return True
    for i in range(0,k):
        a = randint(1,n-1)
        if(pow(a,n-1,n)!=1):
            return False
    return True
""=========================================""
""""""
n = int(input())
n,k = map(int,input().split())
arr = list(map(int,input().split()))
""""""
from collections import deque,defaultdict,Counter
import heapq,string


n=int(input())
s=input()
s=[int(i) for i in s]
flag=False
for i in range(0,(9*n)+1):
    count=0
    sum = 0
    for j in s:
        sum+=j
        if sum==i:
            count+=1
            sum=0
    if count>1 and sum==0:
        print('YES')
        exit(0)
print('NO')
",quadratic,implementation,1910
"n = int(input())
s = input()
 
for sum in range(9 * n + 1):
    cnt = 0
    cursum = 0
    for i in s:
        cursum += int(i)
        if cursum == sum:
            cnt += 1
            cursum = 0
 
    if cursum == 0 and cnt > 1:
        print(""YES"")
        exit(0)
 
print(""NO"")",quadratic,implementation,282
"n = int(input())
a = input()
sum = 0
for x in a:
    sum += int(x)
ans = ""NO""
if sum == 0:
    ans = ""YES""
s = 1
while s * s <= sum and ans == ""NO"":
    if sum % s == 0:
        t = 0
        flag = 0
        for x in a:
            t += int(x)
            if t == s:
                flag = 1
            if t > s:
                if flag == 1:
                    flag = 0
                    t = int(x)
                    if t == s:
                        flag = 1
        if t == s and t != sum:
            ans = ""YES""
        t = 0
        flag = 0
        for x in a:
            t += int(x)
            if t == sum // s:
                flag = 1
            if t > sum // s:
                if flag == 1:
                    flag = 0
                    t = int(x)
                    if t == sum // s:
                        flag = 1
        if t == sum // s and t != sum:
            ans = ""YES""  
    s += 1
print(ans)",quadratic,implementation,931
"from sys import stdout, stdin, setrecursionlimit
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import * 
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from re import *
from os import *

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)


graph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())
def getStr(): return input()
def getInt(): return int(input())
def listStr(): return list(input())
def getStrs(): return input().split()
def isInt(s): return '0' <= s[0] <= '9'
def input(): return stdin.readline().strip()
def zzz(): return [int(i) for i in input().split()]
def output(answer, end='\n'): stdout.write(str(answer) + end)
def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def lcm(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]
daysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --If you Know some-one , Then you probably don't know him !

    --Try & again try, maybe you're just one statement away!


""""""
##################################################---START-CODING---###############################################

n = getInt()

arr = listStr()

for i in range(n):
    arr[i]=int(arr[i])

okk=0
s=0
for i in range(n-1):
    s+=arr[i]
    cnt=0
    ok=1
    sss=0
    for j in range(i+1,n):
        cnt+=arr[j]
        if cnt==s:
            cnt=0
            sss+=1
        if cnt>s:
            ok=0


    if cnt==0 and sss :
        okk=1
        break
print(""YES"" if okk else ""NO"")",quadratic,implementation,3408
"n = int(input())
A = list(map(int, input().split()))

dp = [[1 for j in range(5)] for i in range(n)]
Prev = [[-1 for i in range(5)] for i in range(n)]

for i in range(1, n):
    for j in range(5):
        for finger in range(5):
            if dp[i - 1][finger] == 1:
                if (A[i - 1] < A[i] and finger < j) or (A[i - 1] > A[i] and finger > j) or (A[i - 1] == A[i] and finger != j):
                    dp[i][j] = 1
                    Prev[i][j] = finger
                    break
        else:
            dp[i][j] = 0
finger = 0
for j in range(5):
    if dp[-1][j] == 1:
        finger = j
        path = [finger]
        for i in range(n - 1, 0, -1):
            finger = Prev[i][finger]
            path.append(finger)
        path = path[::-1]
        for i in range(n):
            print(path[i] + 1, end=' ')
        break
else:
    print(-1)
            
",quadratic,"constructive algorithms,dp",876
"n = int(input())
lst = list(map(int, input().split()))
cur = 1
if n == 1:
    print(1)
    exit()
if lst[cur] > lst[cur - 1]:
    a = [1]
elif lst[cur] < lst[cur - 1]:
    a = [5]
else:
    a = [3]
pr = False
while cur != n:
    cnt = 0

    if lst[cur] > lst[cur - 1]:
        while cur != n and lst[cur] > lst[cur - 1]:
            cnt += 1
            cur += 1
        for i in range(cnt - 1):
            a.append(a[-1] + 1)
            if a[-1] >= 5:
                print(-1)
                exit()
        if n != cur and lst[cur] == lst[cur - 1]:
            a.append(a[-1] + 1)
        else:
            a.append(5)



    elif lst[cur] < lst[cur - 1]:
        while cur != n and lst[cur] < lst[cur - 1]:
            cnt += 1
            cur += 1
        for i in range(cnt - 1):
            a.append(a[-1] - 1)
            if a[-1] <= 1:
                print(-1)
                exit()
        if n != cur and lst[cur] == lst[cur - 1]:
            a.append(a[-1] - 1)
        else:
            a.append(1)
    else:
        while cur != n and lst[cur] == lst[cur - 1]:
            cnt += 1
            cur += 1

        for i in range(cnt - 1):
            if a[-1] < 3:
                a.append(a[-1] + 1)
            else:
                a.append(a[-1] - 1)

        if cur != n and lst[cur] > lst[cur - 1]:
            if a[-1] == 1:
                a.append(2)
            else:
                a.append(1)
        else:
            if a[-1] == 5:
                a.append(4)
            else:
                a.append(5)
print(*a)




",quadratic,"constructive algorithms,dp",1552
"n = int(input())
a = list(map(int, input().split()))
dp = [ [False,False,False,False,False] for _ in range(n) ]
dp[0] = [True, True, True, True, True]
for i in range(1, n):
	for j in range(5):
		if a[i] == a[i - 1]:
			for k in range(5):
				if k != j:
					dp[i][j] = dp[i][j] or dp[i - 1][k]
		elif a[i] > a[i - 1]:
			for k in range(j):
				dp[i][j] = dp[i][j] or dp[i - 1][k]
		else:
			for k in range(j + 1, 5):
				dp[i][j] = dp[i][j] or dp[i - 1][k]
if dp[-1].count(True) == 0:
	print(-1)
	exit(0)
j = 0
for k in range(5):
	if dp[-1][k]:
		j = k
ans = []
for i in range(n - 1, -1, -1):
	ans.append(j + 1)
	if i == 0:
		break
	if a[i] == a[i - 1]:
		for k in range(5):
			if k != j and dp[i - 1][k]:
				j = k
				break
	elif a[i] > a[i - 1]:
		for k in range(j):
			if dp[i - 1][k]:
				j = k
				break
	else:
		for k in range(j + 1, 5):
			if dp[i - 1][k]:
				j = k
				break
print(*ans[::-1])",quadratic,"constructive algorithms,dp",902
"from math import fabs
n = int(input())
nots = [int(s) for s in input().split()]
map = [0]
ampl = 0
possible = True
zer = False
f_s = True

for i in range(len(nots) - 1):                      #map
    if nots[i] == nots[i + 1]:
        if ampl != 0:
            map.append(ampl)
            if ampl <= -5 or ampl >= 5: possible = False
        map.append(0)
        zer = True
        ampl = 0
    else:
        if nots[i] < nots[i + 1]:
            if ampl < 0 and f_s != True:
                map.append(ampl)
                if ampl == -5: possible = False
                ampl = 1
            else:
                ampl += 1
        else:
            if ampl > 0 and f_s != True:
                map.append(ampl)
                if ampl == 5: possible = False
                ampl = -1
            else:
                ampl += -1
    f_s = False
if ampl != 0:
    map.append(ampl)
    if ampl == -5 or ampl == 5: possible = False
if len(nots) == 1:
    map.append(0)
map.append(0)

#print(map)

if possible == True:
    if zer == True:
        l = len(map)
        for i in range(1, l - 1):                                       #first step: 4
            if map[i] == 0:
                if map[i - 1] == 4: map[i] = -1
                if map[i - 1] == -4: map[i] = 1
                if map[i + 1] == 4: map[i] = -1
                if map[i + 1] == -4: map[i] = 1

        for i in range(1, l-1):                                        #second: > <
            if map[i] == 0:
                if map[i - 1] >= 0 and map[i + 1] >= 0: map[i] = -1
                if map[i - 1] > 0 and map[i + 1] < 0: map[i] = 1
                if map[i - 1] < 0 and map[i + 1] > 0: map[i] = -1
                if map[i - 1] <= 0 and map[i + 1] <= 0: map[i] = 1

        #print(map)

        fin = []                                                        # third: combining
        ampl = map[1]
        for i in range(1, l - 1):
            if map[i] * map[i + 1] > 0:
                ampl += map[i + 1]
            if map[i] * map[i + 1] < 0:
                fin.append(ampl)
                if ampl >= 5 or ampl <= -5: possible = False
                ampl = map[i + 1]
        fin.append(ampl)

        if possible == True:
            fin[-1] = int(fabs( fin[-1] ) / fin[-1] * (fabs( fin[-1] ) + 1))
            appl = []                                                           # forth: application
            for i in range( len(fin) ):
                if fin[i] > 0:
                    for j in range(1, fin[i] + 1):
                        appl.append(j)
                if fin[i] < 0:
                    for j in range(5, 5 + fin[i], -1):
                        appl.append(j)
        #print(fin)
        #print(""*"")

    else:
        appl = []
        try:
            map[-2] = int(fabs(map[-2]) / map[-2] * (fabs(map[-2]) + 1))
        except ZeroDivisionError:
            appl = [1]                                          # forth: applicature
        for i in range(len(map)):
            if map[i] > 0:
                for j in range(1, map[i] + 1):
                    appl.append(j)
            if map[i] < 0:
                for j in range(5, 5 + map[i], -1):
                    appl.append(j)
        #print(""#"")

    for finger in appl:
        print(finger, end = ' ')
if possible == False:
    print(-1)












",quadratic,"constructive algorithms,dp",3334
"n = int(input())
ar = [int(i) for i in input().split()]

if n == 1:
    print(1)
    exit()

if ar[1] > ar[0]:
    li = [1]
elif ar[1] < ar[0]:
    li = [5]
else:
    li = [3]

c = 1
while c != n:
    j = 0

    if ar[c] > ar[c - 1]:
        while c != n and ar[c] > ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] + 1)
            if li[-1] == 6:
                print(-1)
#                print(*li)
                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] + 1)
        else:
            li.append(5)

    elif ar[c] < ar[c - 1]:
        while c != n and ar[c] < ar[c - 1]:
            c += 1
            j += 1
        for i in range(j-1):
            li.append(li[-1] - 1)
            if li[-1] == 0:
                print(-1)
 #               print(*li)
                exit()
        if c != n and ar[c] == ar[c - 1]:
            li.append(li[-1] - 1)
        else:
            li.append(1)

    else:
        while c != n and ar[c] == ar[c - 1]:
            c += 1
            j += 1
        for i in range(j):
            if li[-1] > 3:
                li.append(li[-1] - 1)
            else:
                li.append(li[-1] + 1)
        if c != n and ar[c] > ar[c - 1]:
            if li[-2] == 1:
                li[-1] = 2
            else:
                li[-1] = 1
        elif c != n and ar[c] < ar[c - 1]:
            if li[-2] == 5:
                li[-1] = 4
            else:
                li[-1] = 5

#print(c)
if max(li) > 5 or min(li) < 1:
    print(-1)
else:
    print(*li)",quadratic,"constructive algorithms,dp",1595
"n = int(input())
melody = [int(x) for x in input().split()]
ref = [[-1] * 5 for _ in range(n)]
can_finish = [[False] * 5 for _ in range(n)]
can_finish[0] = [True] * 5

for idx, key in enumerate(melody[:-1]):
    if not any(can_finish[idx]):
        break
    for finger in range(5):
        if melody[idx] < melody[idx + 1] and can_finish[idx][finger]:
            for i in range(finger + 1, 5):
                can_finish[idx + 1][i] = True
                ref[idx + 1][i] = finger
            break
        elif melody[idx] > melody[idx + 1] and can_finish[idx][finger] and finger > 0:
            for i in range(finger):
                can_finish[idx + 1][i] = True
                ref[idx + 1][i] = finger
        elif melody[idx] == melody[idx + 1] and can_finish[idx][finger]:
            tmp_val, tmp_ref = can_finish[idx + 1][finger], ref[idx + 1][finger]
            can_finish[idx + 1] = [True] * 5
            ref[idx + 1] = [finger] * 5
            can_finish[idx + 1][finger], ref[idx + 1][finger] = tmp_val, tmp_ref

finger = next((i for i in range(5) if can_finish[n - 1][i]), None)
if finger is None:
    print(-1)
else:
    seq = [finger]
    for i in range(n - 1, 0, -1):
        finger = ref[i][finger]
        seq.append(finger)
    print(' '.join(str(x + 1) for x in seq[::-1]))
",quadratic,"constructive algorithms,dp",1301
"n = int(input())
arr = list(map(int, input().split()))
dp = [[0] * 5 for i in range(n)]
dp[0] = [1, 1, 1, 1, 1]

for i in range(1, n):
    if arr[i] > arr[i - 1]:
        for j in range(1, 5):
            dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1])
    elif arr[i] < arr[i - 1]:
        for j in range(3, -1, -1):
            dp[i][j] = max(dp[i - 1][j + 1], dp[i][j + 1])
    else:
        for j in range(5):
            dp[i][j] += (sum(dp[i - 1]) > 0) * (dp[i - 1][j] == 0 or sum(dp[i - 1]) > 1)
if dp[-1] == [0, 0, 0, 0, 0]:
    print(-1)
else:
    ans = [dp[-1].index(1) + 1]
    for i in range(n - 2, -1, -1):
        for j in range(5):
            if dp[i][j] > 0 and ((j + 1 > ans[-1] and arr[i] > arr[i + 1])
                                 or (j + 1 < ans[-1] and arr[i] < arr[i + 1])
                                 or (j + 1 != ans[-1] and arr[i] == arr[i + 1])):
                ans.append(j + 1)
                break
    print(*reversed(ans))
",quadratic,"constructive algorithms,dp",963
"import sys


if __name__ == '__main__':
    cin = sys.stdin

    n = int(next(cin))
    a = list(map(int, next(cin).split()))

    n2idx = {a[i]: i for i in range(n)}

    f = [False] * (n+1)

    for i in range(n, 0, -1):
        idx_lg = n2idx[i]

        win_flag = False
        for j in range(idx_lg%i, n, i):
            if a[j] > i and not f[a[j]]:
                win_flag = True
                break
        f[i] = win_flag
        
    f = ''.join(['A' if f[a_i] else 'B' for a_i in a])
    print(f, flush=True)
",quadratic,"brute force,dp,games",523
"n=int(input())
L=list(map(int,input().split()))
ans=['']*n
revL=[0]*n
ans[-1]='B'
for i in range(n):
    revL[L[i]-1]=i+1
for i in range(n-2,-1,-1):
    t=revL[i]-1
    counter='B'
    for j in range(t,-1,-i-1):
        if j==t:continue
        if ans[L[j]-1]=='B':
            counter='A'
            break
    if counter!='A':
        for k in range(t,n,i+1):
            if k==t:continue
            if ans[L[k]-1]=='B':
                counter='A'
                break
    ans[i]=counter
for i in range(n):
    print(ans[L[i]-1],sep='',end='')",quadratic,"brute force,dp,games",548
"n=int(raw_input())
arr=list(map(int,raw_input().split()))
dict1={}
arr1=[0]*n
for i in range(n):
	arr1[arr[i]-1]=i
for i in range(n):
	dict1[i+1]=[]
for i in range(n):
	for j in range(i-arr[i],-1,-arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
	for j in range(i+arr[i],n,arr[i]):
		if(arr[j]>arr[i]):
			dict1[arr[i]].append(arr[j])
strarr=['.']*n
#print(dict1)
for i in range(n-1,-1,-1):
	if(len(dict1[arr[arr1[i]]])==0):
		strarr[arr1[i]]='B'
	else:
		if(len(dict1[arr[arr1[i]]])==1 and len(dict1[dict1[arr[arr1[i]]][0]])==0):
			strarr[arr1[i]]='A'
		else:
			flag=0
			for j in dict1[arr[arr1[i]]]:
				#print(j)
				#print(arr1[j-1])
				if(strarr[arr1[j-1]]=='B'):
					flag=1
					break
			if(flag==1):
				strarr[arr1[i]]='A'
			else:
				strarr[arr1[i]]='B'
	#print(*strarr)
print("""".join(x for x in strarr))

",quadratic,"brute force,dp,games",834
"n = int(input())
a = [int(i) for i in input().split()]
indx = [0] * n
winners = [''] * n

for i, ai in enumerate(a):
    indx[ai-1] = i

for ai in range(n, 0, -1):
    i = indx[ai-1]
    can_win = False

    for j in range(i + ai, n, ai):
        if a[j] > ai and 'B' == winners[j]:
            can_win = True
            break

    if not can_win:
        for j in range(i - ai, -1, -ai):
            if a[j] > ai and 'B' == winners[j]:
                can_win = True
                break

    if can_win:
        winners[i] = 'A'
    else:
        winners[i] = 'B'

print(''.join(winners))
",quadratic,"brute force,dp,games",593
"n = int(input())

arr = list(map(int, input().split()))

memo = [-1 for i in range(n+1)]
def can_win(idx):
	if memo[idx] != -1: return memo[idx]
	res = False

	delta = arr[idx]
	# right
	nidx = idx + delta
	while nidx < n:
		if arr[nidx] > arr[idx] and not can_win(nidx):
			res = True
			break
		nidx += delta

	#left
	nidx = idx - delta
	while not res and nidx >= 0:
		if arr[nidx] > arr[idx] and not can_win(nidx):
			res = True
			break
		nidx -= delta

	memo[idx] = res
	return res

ans = ['A' if can_win(i) else 'B' for i in range(n)]
print(''.join(ans))
",quadratic,"brute force,dp,games",561
"import collections
import sys

def can_win(i, dp):
    if i in dp:
        return dp[i]
    else:
        for next in possible[i]:
            if not can_win(next, dp):
                dp[i] = True
                return True
        dp[i] = False
        return False

data = sys.stdin.readlines()
nb = int(data[0])
nums = data[1].split(' ') 
nums = [int(c) for c in nums]
possible = [[] for _ in range(nb)]
for i in range(nb):
    if nums[i] == 1:
        possible[i] = [k for k in range(nb) if k != i] 
    else:
        for j in range(i+nums[i], nb, nums[i]):
            if nums[j] > nums[i]:
                possible[i].append(j)
        for j in range(i-nums[i], -1, -nums[i]):
            if nums[j] > nums[i]:
                possible[i].append(j)

res = """"
dp = {}
for i in range(nb):
    if can_win(i, dp):
        res += ""A""
    else:
        res += ""B""
print(res)
        
",quadratic,"brute force,dp,games",886
"from operator import itemgetter
n = int(input())
ai = list(map(int,input().split()))
ai2 = [[ai[i], i] for i in range(n)]
answer = [0] * n
ai2.sort(key = itemgetter(0))
answer[ai2[0][1]] = 1
answer[ai2[-1][1]] = 0
for i in range(n-2,0,-1):
    num = ai2[i][1] % ai2[i][0]
    for j in range(num,n,ai2[i][0]):
        if ai[j] > ai2[i][0] and answer[j] == 0:
            answer[ai2[i][1]] = 1
            break
for i in range(n):
    if answer[i] == 1:
        print(""A"",end="""")
    else:
        print(""B"",end="""")
",quadratic,"brute force,dp,games",514
"a = int(input())
lister = input().split()
lister = [int(i) for i in lister]

ans = dict()
	
def findans(n):
	if n in ans:
		return ans[n]
	mod = n%lister[n]
	ok = True
	if n + lister[n] >= a and n - lister[n] < 0:
		ok = False
	else:
		for i in range(mod, a, lister[n]):
			if i != n and lister[i] > lister[n]:
				ok = ok and findans(i) 
				
		ok = not(ok)
		
	ans[n] = ok
	return ok
	
for i in range(len(lister)):
	findans(i)
	
level = []
for i in range(a):
	if ans[i] == True:
		level.append('A')
	else:
		level.append('B')
		
print(''.join(level))",quadratic,"brute force,dp,games",552
"# from collections import deque

n = int(input())
a = [int(x) for x in input().split()]

a_reverse = a.copy()
status = []
for i in range(n):
    a_reverse[a[i]-1] = i
    status.append(None)


pos = a_reverse[n-1]
status[pos] = False
fails = set()
fails.add(pos)
for i in range(n-1,0,-1):
    i_ = i-1
    pos = a_reverse[i_]
    for k in range((pos+1)%i-1,n,i):
        if k == pos:
            continue
        if k in fails:
            status[pos] = True
            break
    if not status[pos]:
        status[pos] = False
        fails.add(pos)


# BAAAABAB
# ABAAAABBBAABAAB


# status = []
# for i in range(n):
#     status.append(None)

# queue = deque()

# def eval_(pos):
#     pos_status = status[pos]
#     for i in range(n):
#         if i == pos:
#             continue
#         if status[i] != None:
#             continue
#         if  a[i] > a[pos]:
#             continue
#         if (abs(i - pos) % a[i]) == 0:
#             status[i] = not pos_status
#             queue.append(i)

# pos = a.index(n)
# status[pos] = False
# queue.append(pos)
#
# while len(queue) != 0:
#     item = queue.popleft()
#     eval_(item)
#
# print(status)
#
result = """"
for i in status:
    if i == True:
        result=result+""A""
    else:
        result=result+""B""

print(result)




",quadratic,"brute force,dp,games",1289
"n = int(input())
a = [int(x) for x in input().split()]
h = [-1]*(n)
b = [(a[i],i) for i in range(n)]
b.sort(reverse=True)
for e in b:
	# ~ print(e)
	num,idx = e
	flag = True
	allNeg = True
	foundLosing = False
	foundWin = False
	for i in range(idx%num,n,num):
		# ~ print(i)
		if i == idx:
			continue
		if h[i]!= -1:
			allNeg = False
		if h[i] == 0:
			foundLosing = True
			break
		if h[i] == 1:
			foundWin = False
	if allNeg:
		h[idx] = 0
	elif foundLosing:
		h[idx] = 1
	else:
		h[idx] = 0	
	# ~ print("" "".join(str(ss) for ss in h))
for i in range(n):
	if h[i]==0:
		print('B',end='')
	else:
		print('A',end='')
		
# ~ print(h)
",quadratic,"brute force,dp,games",634
"n = int(input())
l = [*map(int, input().split())]

p = [0] * n
for i in range(n): p[l[i] - 1] = i

res = ['?'] * n

for e in range(n, 0, -1):
    i = p[e - 1]
    res[i] = 'B'
    for j in range(i % e, n, e):
        if i != j and l[i] <= l[j] and res[j] == 'B':
            res[i] = 'A'
            break 
print(''.join(res))",quadratic,"brute force,dp,games",326
"n=int(input())
a=[*map(int,input().split())]
b=[0]*n
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",quadratic,"brute force,dp,games",263
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",quadratic,"brute force,dp,games",255
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  if s[i]==0:
   r=range(i%x,n,x)
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   elif any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",quadratic,"brute force,dp,games",257
"n=int(input())
a=[*map(int,input().split())]
s=[0]*n
m=n
while m:
 for i,x in enumerate(a):
  r=range(i%x,n,x)
  if s[i]==0:
   if all(a[j]<=x or s[j]=='A'for j in r):s[i]='B';m-=1
   if any(a[j]>x and s[j]=='B'for j in r):s[i]='A';m-=1
print(''.join(s))",quadratic,"brute force,dp,games",254
"from queue import Queue
n = int(input())
g = [set() for i in range(n+1)]
for i in range(n-1):
    u, v = map(int, input().split())
    g[u].add(v)
    g[v].add(u)

a = list(map(int, input().split()))
if a[0] != 1:
    print(""No"")
    exit()
ptr = 0
i = 1

while i < n:
    par = a[ptr]
    while len(g[par]) != 0:
        if a[i] not in g[par]:
            print(""No"")
            exit()
        else:
            g[par].remove(a[i])
            g[a[i]].remove(par)
        i += 1
    ptr += 1
print(""Yes"")    
                
",quadratic,"dfs and similar,graphs,shortest paths,trees",528
"from itertools import groupby

n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
sums = [(a + b, ind) for (ind, (a, b)) in enumerate(zip(l, r))]
sums.sort()
answer = [None] * n
curr_candies = n
for key, group in groupby(sums, key=lambda i: i[0]):
    for elem in group:
        answer[elem[1]] = curr_candies
    curr_candies -= 1
tl = []
for i in range(n):
    cnt = 0
    for j in range(i):
        if answer[j] > answer[i]:
            cnt += 1
    tl.append(cnt)
tr = []
for i in range(n):
    cnt = 0
    for j in range(i + 1, n):
        if answer[j] > answer[i]:
            cnt += 1
    tr.append(cnt)
if tl != l or tr != r:
    print(""NO"")
else:
    print(""YES"")
    print(' '.join(map(str, answer)))
",quadratic,"constructive algorithms,implementation",749
"#      
import collections, atexit, math, sys, bisect 

sys.setrecursionlimit(1000000)
def getIntList():
    return list(map(int, input().split()))    

try :
    #raise ModuleNotFoundError
    import numpy
    def dprint(*args, **kwargs):
        print(*args, **kwargs, file=sys.stderr)
    dprint('debug mode')
except Exception:
    def dprint(*args, **kwargs):
        pass



inId = 0
outId = 0
if inId>0:
    dprint('use input', inId)
    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #标准输出重定向至文件
if outId>0:
    dprint('use output', outId)
    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #标准输出重定向至文件
    atexit.register(lambda :sys.stdout.close())     #idle 中不会执行 atexit
    
N, = getIntList()
#print(N)

zl = getIntList()
zr = getIntList()

zt = [ (zl[i] + zr[i], i) for i in range(N) ]
zt.sort()
za = [0 for i in range(N) ]
now = N
for i in range(N):
    if i>0 and zt[i-1][0] <zt[i][0]:
        now-=1
    za[ zt[i][1] ] = now

for i in range(N):
    l = 0
    r = 0
    for j in range(i):
        if za[j] > za[i]:
            l+=1
    for j in range(i+1, N):
        if za[j] > za[i]:
            r+=1
    if zl[i] != l or zr[i] != r:
        print('NO')
        sys.exit()
print('YES')
for i in range(N):
    print(za[i],end = ' ')




",quadratic,"constructive algorithms,implementation",1263
"n = input()
l = map(int, raw_input().split())
r = map(int, raw_input().split())



mp = {i:i for i in range(n)}
out = [-1]*n
v = 0

a = n
done = set()
while v < n:
    ids = set()
    for j in range(n):
        if l[j] == r[j] == 0 and j not in done:
            ids.add(j)
            done.add(j)
    if len(ids) == 0:
        print('NO')
        exit()
    v += len(ids)
    for i in ids:
        out[mp[i]] = a
        for j in range(len(l)):
            if j < i:
                r[j] -= 1
            else:
                l[j] -= 1
    a -= 1
print('YES')
print(' '.join(map(str, out)))
",quadratic,"constructive algorithms,implementation",593
"n = int(input())

L = list(map(int, input().split("" "")))
R = list(map(int, input().split("" "")))

LR = list(zip(L,R))

index_to_candies = {}
candy = n

for nn in range(n,0,-1):
    if(len(index_to_candies) == n):
        break

    #print(index_to_candies)
    #print(LR)

    zero_index = []
    for idx, (l,r) in enumerate(LR):
        if (l,r) == (0,0) and not idx in index_to_candies:
            index_to_candies[idx] = nn
            zero_index.append(idx)

    if len(zero_index) == 0:
        print(""NO"")
        exit()

    dec_left = 0
    dec_right = len(zero_index)
    zero_index_idx = 0

    for idx, (l,r) in enumerate(LR):
        if zero_index_idx < len(zero_index) and zero_index[zero_index_idx] == idx:
    #        print(idx)
            zero_index_idx += 1
            dec_left += 1
            dec_right -= 1

        if (l,r) != (0,0):
            LR[idx] = (l-dec_left,r-dec_right)
            if LR[idx][0] < 0 or LR[idx][1] < 0:
                print(""NO"")
                exit()
print(""YES"")
j = []
for i in range(n):
    j.append(str(index_to_candies[i]))
print("" "".join(j))
",quadratic,"constructive algorithms,implementation",1102
"n=int(input())
#x,y,z,t1,t2,t3=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))

s=[0]*n

ans=True

for i in range(n):
    ans=ans and a[i]<=i and b[i]<=(n-i-1)
    s[i]=n-a[i]-b[i]

def qwe(s,j):
    l,r=0,0
    for i in range(len(s)):
        if i<j and s[i]>s[j]: l+=1
        elif i>j and s[i]>s[j]: r+=1
    return l,r



if ans:
    for i in range(n):
        l,r=qwe(s,i)
        ans=ans and a[i]==l and b[i]==r
        
    

    
if ans:
    print('YES')
    for i in range(n):
        print(n-a[i]-b[i],end=' ')
else: print('NO')



",quadratic,"constructive algorithms,implementation",585
"n=int(input())

l=list(map(int,input().split()))
r=list(map(int,input().split()))

a=[[l[i]+r[i],i] for i in range(n)]
a.sort()
#print(a)
candies=[0 for i in range(n)]

if(a[0][0] != 0):
    
    print('NO')
    exit()
else:
    candies[a[0][1]] = n - a[0][0]

for i in range(1,n):
    if(a[i][0] != a[i-1][0] and a[i][0]!=i):
        print('NO')
 #       print(i,a[i])
        exit()
  #  print(a[i][1],n-a[i][0],i)
    candies[a[i][1]] = n - a[i][0]
#print(candies)
for i in range(n):
    l1=0
    r1=0
    for j in range(i):
        if(candies[j]>candies[i]):
            l1+=1
    for j in range(i+1,n):
        if(candies[j]>candies[i]):
            r1+=1
 #   print(l1,r1)
    if(l1 != l[i] or r1 != r[i]):
        print('NO')
        exit()
print('YES')
print(*candies)

",quadratic,"constructive algorithms,implementation",778
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
candies=[]
for i in range(n):
    candies.append(n-l[i]-r[i])
left=[]
for i in range(n):
    guys=0
    for j in range(i):
        if candies[j]>candies[i]:
            guys+=1
    left.append(guys)
right=[]
for i in range(n):
    guys=0
    for j in range(i,n):
        if candies[j]>candies[i]:
            guys+=1
    right.append(guys)
if left==l and right==r:
    print(""YES"")
    candiesstr=""""
    for i in range(n):
        candiesstr+=str(candies[i])+"" ""
    print(candiesstr[:len(candiesstr)-1])
else:
    print(""NO"")",quadratic,"constructive algorithms,implementation",607
"n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
ans = [1 for i in range(n)]

s = [l[i] + r[i] for i in range(n)]
order = [i for i in range(n)]

for i in range(n-1):
    m = i
    for j in range(i+1,n):
        if s[m] < s[j]:
            m = j
    t = s[i]
    s[i] = s[m]
    s[m] = t
    t = order[i]
    order[i] = order[m]
    order[m] = t
cur = 1
for i in range(1,n):
    if s[i-1] > s[i]:
        cur += 1
    ans[order[i]] = cur
for i in range(n):
    k = 0
    for j in range(i):
        if ans[j] > ans[i]:
            k += 1
    if l[i] != k:
        print('NO')
        exit()
    k = 0
    for j in range(i+1,n):
        if ans[j] > ans[i]:
            k += 1
    if r[i] != k:
        print('NO')
        exit()

print('YES')
for i in ans:
    print(i, end=' ')",quadratic,"constructive algorithms,implementation",815
"import sys
n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
res = [0] * n
for i in range(n):
    res[i] = n - l[i] - r[i]
for i in range(n):
    ok = 0
    for j in range(i):
        if res[j] > res[i]:
            ok += 1
    if ok != l[i]:
        print(""NO"")
        sys.exit(0)
    ok = 0
    for j in range(i + 1, n):
        if res[j] > res[i]:
            ok += 1
    if ok != r[i]:
        print(""NO"")
        sys.exit(0)
print(""YES"")
print(' '.join(map(str, res)))
",quadratic,"constructive algorithms,implementation",514
"n = int(input())
flag = True
l , r = list(map(int,input().split())) , list(map(int,input().split()))
ans , check_l , check_r = [n for i in range(n)] , [0 for i in range(n)] , [0 for i in range(n)]
for i in range(n):
    ans[i] -= l[i]+r[i]
for i in range(n):
    cl , cr = 0 , 0
    for j in range(i):
        if ans[j] > ans[i]:
            cl += 1
    for j in range(i+1,n):
        if ans[j] > ans[i]:
            # print(l[j],l[i],j,i)
            cr += 1
    # print(cl,cr)
    if cl != l[i] or cr!=r[i]:
        flag = False
        break
mini = min(ans) - 1
for i in range(n):
    ans[i] -= mini
# print(ans,check_l,check_r,sep='\n')
if flag:
    print(""YES"")
    for i in ans:
        print(i,end= ' ')
else:
    print(""NO"")",quadratic,"constructive algorithms,implementation",732
"n = int(input())
l = list(map(int, input().split()))
r = list(map(int, input().split()))
fl = 0
m = n
s = list(range(n))
for i in range(n):
    s[i] = m - (l[i] + r[i])
    if fl != 1 and s[i] == m:
        fl = 1
for i in range(n):
    ll = 0;
    for j in range(i):
        if s[j] > s[i]:
            ll += 1
    rr = 0
    for j in range(i + 1, n):
        if s[j] > s[i]:
            rr += 1
    if l[i] != ll or rr != r[i]:
        fl = 0
        break

if fl == 1 and l[0] == 0 and r[n - 1] == 0:
    print('YES')
    print(*s)
else:
    print('NO')


",quadratic,"constructive algorithms,implementation",559
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))

cost=[(l[i]+r[i],i) for i in range(n)]

cost.sort()

CANDIES=[None]*n
CANDIES[cost[0][1]]=n

candy=n
for i in range(1,n):
    if cost[i][0]==cost[i-1][0]:
        CANDIES[cost[i][1]]=candy
    else:
        candy-=1
        CANDIES[cost[i][1]]=candy

#print(CANDIES)

check=1    
for i in range(n):
    lc=0
    rc=0
    for j in range(i):
        if CANDIES[j]>CANDIES[i]:
            lc+=1
    for j in range(i+1,n):
        if CANDIES[j]>CANDIES[i]:
            rc+=1

    #print(i,lc,rc)

    if lc!=l[i] or rc!=r[i]:
        check=0

if check==1:
    print(""YES"")
    for c in CANDIES:
        print(c,end="" "")
    #print(CANDIES)
else:
    print(""NO"")
    #print(CANDIES)
          
    
",quadratic,"constructive algorithms,implementation",776
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
c=[n]*n
for i in range(n):
    c[i]-=(r[i]+l[i])
for i in range(n):
    m=0
    for j in range(0,i):
        if c[j]>c[i]:
            m+=1
    if m!=l[i]:
        exit(print('NO'))
for i in range(n):
    m=0
    for j in range(i+1,n):
        if c[j]>c[i]:
            m+=1
    if m!=r[i]:
        exit(print('NO'))
print('YES')
print(*(c))
",quadratic,"constructive algorithms,implementation",423
"#!/usr/bin/python3.5

N = int(input())
L = [int(s) for s in input().split("" "")]
R = [int(s) for s in input().split("" "")]

C = [N - L[i] - R[i] for i in range(0, N)]

for i, x in enumerate(C):
    if C[i] <= 0:
        print(""NO"")
        exit()

    l = 0
    r = 0

    j = i-1
    while j >= 0:
        if C[j] > C[i]:
            l = l + 1
            
        j = j - 1

    j = i+1
    while j < N:
        if C[j] > C[i]:
            r = r + 1

        j = j + 1

    if L[i] != l or R[i] != r:
        print(""NO"")
        exit()

print(""YES"")
for i in range(0, N-1):
    print(C[i], end="" "")

print(C[N-1])

",quadratic,"constructive algorithms,implementation",615
"def main():
    n = int(input())
    left = [int(x) for x in input().strip().split()]
    right = [int(x) for x in input().strip().split()]
    rank = [x + y for (x,y) in zip(left,right)]
    arr = [(n - r) for r in rank]

    # check left
    for i in range(n):
        more = 0
        for j in range(i):
            if arr[j] > arr[i]:
                more += 1
        if more != left[i]:
            print('NO')
            return
    
    # check right
    for i in range(n):
        more = 0
        for j in range(i+1,n):
            if arr[j] > arr[i]:
                more += 1
        if more != right[i]:
            print('NO')
            return

    print('YES')
    for x in arr:
        print(x, end=' ')
    print()


if __name__ == '__main__':
    main()",quadratic,"constructive algorithms,implementation",773
"n = int(input())
L = [int(i) for i in input().split()]
R = [int(i) for i in input().split()]
E = []
otv = [0] * n
for i in range(n):
    sum_ = L[i] + R[i]
    E.append([sum_, i])
E.sort()
for i in range(n):
    x = R[i]
    for j in range(n):
        if (x > 0):
            if (E[j][1] > i):
                otv[E[j][1]] += 1
                x -= 1
        else:
            break
        
    if (x > 0):
        print(""NO"")
        exit()
        
    x = L[i]
    for j in range(n):
        if (x > 0):
            if (E[j][1] < i):
                otv[E[j][1]] += 1
                x -= 1
        else:
            break
        
    if (x > 0):
        print(""NO"")
        exit()

for i in range(n):
    r = 0
    l = 0
    for j in range(i + 1, n):
        if (otv[j] > otv[i]):
            r += 1
    for z in range(i - 1, -1, -1):
        if (otv[z] > otv[i]):
            l += 1
    if (r != R[i]) or (l != L[i]):
        print(""NO"")
        exit()

print(""YES"")
for i in range(n):
    print(otv[i] + 1, end = ' ')
    
    

",quadratic,"constructive algorithms,implementation",1037
"n=int(input())
l=list(map(int,input().split()))
r=list(map(int,input().split()))
if l[0]!=0 or r[n-1]!=0:
    print(""NO"")
    exit(0)
s=[(l[i]+r[i]) for i in range(n)]
m=max(s)+1
k=[]
for i in s:
    k.append(m-i)
l1=[]
r1=[]

for i in range(n):
    c=0
    d=0
    for j in range(0,i):
        if k[j]>k[i]:
            c+=1
    l1.append(c)
    for j in range(i+1,n):
        if k[j]>k[i]:
            d+=1
    r1.append(d)
if l1!=l or r1!=r:
    print(""NO"")
else:
    print(""YES"")
    print(*k)
        
    
    

    ",quadratic,"constructive algorithms,implementation",522
"import collections


def main():
    # # n = int(input())
    # x, y, z, t1, t2, t3 = list(map(int, input().split()))
    # stair = t1 * abs(y - x)
    # ele = t2 * (abs(y - x) + abs(z - x)) + 3 * t3
    # # print(stair, ele)
    # print(""YES"" if ele <= stair else ""NO"")

    # n = int(input())
    # num = list(map(int, input().split()))
    # prevMax, totMax = -1, float('-inf')
    # for i, v in enumerate(num):
    #     totMax = max(totMax, v)
    #     if totMax - prevMax in [0, 1]:
    #         prevMax = totMax
    #     else:
    #         print(i + 1)
    #         return
    # print(-1)

    n = int(input())
    left = list(map(int, input().split()))
    right = list(map(int, input().split()))
    res = [0] * n
    val = n

    if all(not left[i] and not right[i] for i in range(n)):
        print(""YES"")
        print(' '.join(['1'] * n))
        return

    while not all(not left[i] and not right[i] for i in range(n)):
        zeroSet = set()
        for i in range(n):
            if not left[i] and not right[i] and res[i] == 0:
                zeroSet.add(i)
                res[i] = val
        for v in zeroSet:
            for i in range(v + 1, n):
                if i not in zeroSet and res[i] == 0:
                    left[i] -= 1
            for i in range(v):
                if i not in zeroSet and res[i] == 0:
                    right[i] -= 1
        val -= 1
        # print(zeroSet, left, right)
        if not zeroSet:
            print(""NO"")
            return

    for i in range(n):
        if not res[i]:
            res[i] = str(val)
        else:
            res[i] = str(res[i])
    if any(i == '0' for i in res):
        print(""NO"")
        return
    print(""YES"")
    print(' '.join(res))


main()
",quadratic,"constructive algorithms,implementation",1747
"n=int(input())
l=list(map(int, input().split()))
r=list(map(int, input().split()))
maxx=0
s=[]
it=0
for i in range(n):
    s.append(l[i]+r[i])
    if l[i]>i or r[i]>n-i-1:
        it=1
its=list(s)
while maxx<n:
    summ=0
    ll=0
    rr=its.count(-1)
    for i in range(n):
        if its[i]==-1:
            ll+=1
            rr-=1
        if its[i]!=-1 and i<n-1 and r[i]<rr:
            it=1
            break
        if its[i]!=-1 and i>0 and l[i]<ll:
            it=1
            break    
    if it==1:
        break
    for i in range(n):
        if s[i]==maxx:
            s[i]=-maxx
            its[i]=-1
            summ+=1

    if summ==0:
        it=1
        break
    maxx+=summ
if it==1:
    print('NO')
else:
    print('YES')
    for i in s:
        print(i-min(s)+1, end=' ')
    ",quadratic,"constructive algorithms,implementation",798
"def lr(a):
    l = [0] * len(a)
    r = [0] * len(a)
    for i in range(len(a)):
        for j in range(i+1, len(a)):
            if a[j] > a[i]:
                r[i] += 1
            if a[i] > a[j]:
                l[j] += 1
    return l, r


n = int(input())
l = [int(i) for i in input().split()]
r = [int(i) for i in input().split()]
a = [0] * n
for i in range(n):
    for j in range(n):
        if l[j] + r[j] == i:
            a[j] = n-i
l1, r1 = lr(a)
if l1 != l or r1 != r:
    print(""NO"")
else:
    print(""YES"")
    print(' '.join([str(i) for i in a]))
",quadratic,"constructive algorithms,implementation",561
"n = int(input())
l = list(map(int, input().split("" "")))
r = list(map(int, input().split("" "")))

slr = [l[i]+r[i] for i in range(n)]
ans = [n-slr[i] for i in range(n)]

flag = True
if l[0]!=0 or r[n-1]!=0:
	flag= False

for i in range(n):
	great = 0
	for j in range(i+1, n):
		if ans[i]<ans[j]:
			great = great + 1
	if r[i]!=great:
		flag = False
		break
for i in range(n-1, -1, -1):
	great = 0
	for j in range(i-1, -1, -1):
		if ans[i]<ans[j]:
			great = great + 1
	if l[i]!=great:
		flag = False
		break

if flag:
	print(""YES"")
	for i in range(0, n-1):
		print(ans[i], end="" "")
	print(ans[n-1])
else:
	print(""NO"")
",quadratic,"constructive algorithms,implementation",616
"n=int(input())
le=[int(i) for i in input().split()]
ri=[int(i) for i in input().split()]
notp = False
check=[]
for i in range(n):
    check.append(n-le[i]-ri[i])
for i in range(n):
    tot=0
    for j in range(i-1,-1,-1):
        if(check[j]>check[i]):
            tot+=1
    if(tot!=le[i]):
        notp=True
        break
if(notp==False):
    for i in range(n):
        tot=0
        for j in range(i+1,n):
            if(check[j]>check[i]):
                tot+=1
        if(tot!=ri[i]):
            notp=True
            break
if(notp):
    print('NO')
else:
    print('YES')
    print(*check)
    
        
",quadratic,"constructive algorithms,implementation",612
"
#FAILED
n = int(input())
l = [int(i) for i in input().split()]
r = [int(i) for i in input().split()]

items = [(-l[i]-r[i],i) for i in range(n)]
items.sort()
vals = [1] * n
m = 1
for i in range(1, n):
    if items[i-1][0] != items[i][0]:
        m += 1
    vals[items[i][1]] = m

for i in range(n):
    ln = sum(map(lambda x: x-vals[i] > 0, vals[:i]))
    lr = sum(map(lambda x: x-vals[i] > 0, vals[i:]))
    if ln != l[i] or lr != r[i]:
        print('NO')
        break
else:
    print('YES')
    print(' '.join(str(i) for i in vals))
",quadratic,"constructive algorithms,implementation",538
"def main():
    def update(l, r, i, res):
        j = 0
        while j < i:
            if res[j] is None:
                r[j] -= 1
                if r[j] < 0:
                    return False
            j += 1
        j += 1
        while j < n:
            if res[j] is None:
                l[j] -= 1
                if l[j] < 0:
                    return False
            j += 1
        return True

    ilist = {1}
    n = int(input())
    res = [None] * n
    cur = n
    l = [int(x) for x in input().split()]
    r = [int(x) for x in input().split()]

    while ilist and (sum(l) != 0 or sum(r) != 0):
        ilist = set()
        for i in range(n):
            if l[i] == r[i] == 0 and res[i] is None:
                res[i] = cur
                ilist.add(i)
        for i in ilist:
            check = update(l, r, i, res)
            if not check:
                return False
        cur -= 1
    if not ilist:
        return False
    for i in range(n):
        if res[i] is None:
            res[i] = cur
    return res


if __name__ == '__main__':
    res = main()
    if not res:
        print('NO')
    else:
        print('YES')
        for x in res:
            print(x, end=' ')",quadratic,"constructive algorithms,implementation",1205
"def get_input_list():
	return list(map(int, input().split()))

n = int(input())
l = get_input_list()
r = get_input_list()

a = [0 for _ in range(n)]
m = []
m_ = []
for i in range(n):
	m.append(l[i] + r[i])
	m_.append(l[i] + r[i])
m.sort()
ma = m[-1] + 1

for i in range(n):
	a[i] = ma - m_[i]

l_ = []
r_ = []
for i in range(n):
	c = 0
	d = 0
	for j in range(i+1):
		if a[j] > a[i]:
			c += 1
	for j in range(i,n):
		if a[j] > a[i]:
			d += 1
	l_.append(c)
	r_.append(d)
res = True
for i in range(n):
	if l[i] != l_[i] or r[i] != r_[i]:
		res = False
		break
if res:
	print(""YES"")
	for i in range(n):
		a[i] = str(a[i])
	print("" "".join(a))
else:
	print(""NO"")",quadratic,"constructive algorithms,implementation",658
"n = int(input())
a = list(map(int, input().split()))
s = list(map(int, input().split()))
d = []
for q in range(n):
    d.append(a[q]+s[q])
d = [n-q for q in d]
for q in range(n):
    f = 0
    for q1 in range(q):
        if d[q1] > d[q]:
            f += 1
    g = 0
    for q1 in range(q+1, n):
        if d[q1] > d[q]:
            g += 1
    if f != a[q] or g != s[q]:
        print('NO')
        break
else:
    print('YES')
    print(*d)
",quadratic,"constructive algorithms,implementation",442
"R = lambda: map(int, input().split())

n = int(input())
arr1 = tuple(R())
arr2 = tuple(R())

d = dict()
ans = [0]*n

for i in range(n):
    d[i] = [arr1[i], arr2[i]]

def run():
    for nn in range(n, 0, -1):
        s = list()
        for i in d:
            if d[i][0] == d[i][1] == 0:
                s.append(i)
                ans[i] = nn

        if s:
            for i in s: del d[i]
            for i in d:
                l = r = 0
                for j in s:
                    if j < i:
                        l += 1
                    else:
                        r += 1
                if d[i][0] >= l:
                    d[i][0] -= l
                else:
                    return
                if d[i][1] >= r:
                    d[i][1] -= r
                else:
                    return

        else:
            return

run()

if 0 in ans:
    print('NO')
    # print(*ans, sep=' ')
else:
    print('YES')
    print(*ans, sep=' ')",quadratic,"constructive algorithms,implementation",963
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations

def li():
	return list(map(int , input().split()))

def num():
	return map(int , input().split())

def nu():
	return int(input())

def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x

n=nu()
a=li()
b=li()
z=[]
for i in range(n):
	z.append((a[i]+b[i],i))
z.sort()
fl=True
x=[]
cc=0
xp=0
mp={}
np=[]
for i in range(n):
	if(a[i]>i):
		fl=False
	if(b[i]>(n-i-1)):
		fl=False
	if((n-a[i]-b[i])<=0):
		fl=False

if(fl==False):
	print(""NO"")
else:
	zz=[0]*n
	for i in range(n):
		zz[i]=(n-a[i]-b[i])
	for i in range(n):
		xl = 0
		xr = 0
		for j in range(i + 1 , n):
			if (zz[j] > zz[i]):
				xr += 1
		for j in range(i - 1 , -1 , -1):
			if (zz[j] > zz[i]):
				xl += 1
		if (xl != a[i] or xr != b[i]):
			fl = False
			break
	if (fl == True):
		print(""YES"")
		print(*zz)
	else:
		print(""NO"")
",quadratic,"constructive algorithms,implementation",919
"# -*- coding:utf-8 -*-

""""""

created by shuangquan.huang at 12/14/18

""""""
import collections

import sys

N = int(input())
p = [int(x) for x in input().split()]


G = collections.defaultdict(list)

for i, v in enumerate(p):
    u = i + 2
    G[u].append(v)
    G[v].append(u)

root = 1

colors = [0] * (N + 1)
counts = [0] * (N + 1)

q = [root]
parents = [0] * (N+1)
vis = [0] * (N+1)
while q:
    u = q.pop()
    if vis[u]:
        colors[parents[u]] += colors[u]
        continue
    children = [v for v in G[u] if v != parents[u]]
    for v in children:
        parents[v] = u
    
    if children:
        vis[u] = True
        q.append(u)
        q.extend(children)
    else:
        vis[u] = True
        colors[u] = 1
        colors[parents[u]] += 1
        
    





#
#
# def dfs(u, parent):
#     cc, hc = 0, 0
#     for v in G[u]:
#         if v != parent:
#             a, b = dfs(v, u)
#             cc += a
#             hc += b
#     counts[u] = hc + 1
#     cc = cc if cc > 0 else 1
#     colors[u] = cc
#     return cc, hc + 1
#
#
# dfs(1, -1)
#
colors = colors[1:]
colors.sort()
print(' '.join(map(str, colors)))
",quadratic,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",1132
"n=int(input())
if n==1:
    print(1)
else:
    p=list(map(int,input().split()))
    children=[]
    for i in range(n):
        children.append([])
    for i in range(n-1):
        children[p[i]-1].append(i+1)
    layers=[1]+[0]*(n-1)
    layer=[0]
    num=2
    bylayer=[]
    while len(layer)>0:
        bylayer.append(layer)
        newlayer=[]
        for vert in layer:
            for child in children[vert]:
                layers[child]=num
                newlayer.append(child)
        layer=newlayer
        num+=1
    bylayer=bylayer[::-1]
    count=[0]*n
    for layer in bylayer:
        for vert in layer:
            if children[vert]==[]:
                count[vert]=1
            else:
                count[vert]=sum(count[v] for v in children[vert])
    count.sort()
    out=""""
    for guy in count:
        out+=str(guy)+"" ""
    print(out)",quadratic,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",860
"import sys
input=sys.stdin.readline
from collections import defaultdict
graph=defaultdict(list)
n=int(input())
par=[ int(i) for i in input().split() if i!='\n']
bulb=[1]*(n+1)
for i in range(n-1):
    bulb[par[i]]=0
    graph[par[i]].append(i+2)
#print(graph,bulb)
zero=bulb.count(0)
for  i in range(n,0,-1):
    if bulb[i]==0:
        count=0
        for j in graph[i]:
            count+=bulb[j]
        bulb[i]=count
bulb=bulb[1:]
bulb.sort()
sys.stdout.write(' '.join(map(str,bulb)))
",quadratic,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",488
"import sys
input=sys.stdin.readline
from collections import defaultdict
graph=defaultdict(list)
n=int(input())
par=[ int(i) for i in input().split() if i!='\n']
bulb=[1]*(n+1)
for i in range(n-1):
    bulb[par[i]]=0
    graph[par[i]].append(i+2)
#print(graph,bulb,par)
zero=bulb.count(0)
for  i in range(n,0,-1):
    if bulb[i]==0:
        count=0
        for j in graph[i]:
            count+=bulb[j]
        bulb[i]=count
bulb=bulb[1:]
bulb.sort()
sys.stdout.write(' '.join(map(str,bulb)))
",quadratic,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",492
"import sys
import threading
inp = sys.stdin.buffer.readline      
input = lambda: sys.stdin.readline().rstrip()
def I(): return list(map(int,inp().split()))
def main():
    n,=I() ; vis=[0]*n ; st=[0]*n
    if n==1:
        print(1)
        exit(0)
    def dfs(g,e):
        if vis[e]==1: return
        else: 
            vis[e]=1
            for i in g[e]:
                dfs(g,i)
            if len(g[e])==1 and e!=0: st[e]+=1
            for i in g[e]:
                st[e]+=st[i]
    a=[int(i)-1 for i in input().split()]
    g=[[] for i in range(n)]
    for i in range(n-1):
        g[i+1].append(a[i])
        g[a[i]].append(i+1)
    dfs(g,0)
    st.sort()
    print(*st)
sys.setrecursionlimit(2097152)
threading.stack_size(134217728)
main_thread = threading.Thread(target=main)
main_thread.start()
main_thread.join()",quadratic,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",826
"import sys
import threading

def dfs(g, i, p):
    global ans
    count = 0
    for j in g[i]:
        if j == p:
            continue
        count += dfs(g, j, i)
    if count == 0:
        count = 1
    ans.append(count)
    return count

def solve():
    
    n = int(input())
    l = list(map(int, input().split()))
    g = [[] for i in range(n+1)]

    for i in range(1, n):
        g[i+1].append(l[i-1])
        g[l[i-1]].append(i+1)

    dfs(g, 1, 0)
    ans.sort()
    st = ' '.join(map(str, ans))
    print(st)

ans = []
max_recur_size = 10**5*2 + 1000
max_stack_size = max_recur_size*500
 
sys.setrecursionlimit(max_recur_size)
threading.stack_size(max_stack_size)
thread = threading.Thread(target=solve)
thread.start()",quadratic,"constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees",730
"n, m = [int(i) for i in input().split()]
A = []
ct = []
for i in range(n):
    x = list(input())
    y = [0]*m
    A.append(x)
    ct.append(y)
ok = 1
for i in range(n-2):
    for j in range(m-2):
        if A[i][j]=='#' and A[i][j+1]=='#' and A[i][j+2]=='#' and A[i+1][j]=='#' and A[i+2][j]=='#' and A[i+2][j+1]=='#' and A[i+2][j+2]=='#' and A[i+1][j+2]=='#':
            ct[i][j] = 1
            ct[i][j+1] = 1
            ct[i][j+2] = 1
            ct[i+1][j] = 1
            ct[i+1][j+2] = 1
            ct[i+2][j] = 1
            ct[i+2][j+1] = 1
            ct[i+2][j+2] = 1

xct = 0
xhs = 0

for i in range(len(ct)):
    for j in range(len(ct[i])):
        if ct[i][j] == 1:
            xct+=1
        if A[i][j] == '#':
            xhs+=1
if xhs==xct:
    print('YES')
else:
    print('NO')
",quadratic,implementation,799
"def isValid(field, y, x):
	for i in range(3):
		for j in range(3):
			if i == 1 and j == 1:
				continue
			if field[y + i][x + j] == '.':
				return False
	return True
def fill(field, y, x):
	for i in range(3):
		for j in range(3):
			if i == 1 and j == 1:
				continue
			cur[y + i][x + j] = '#'
n, m = list(map(int, input().split()))
sig = []
cur = []
for i in range(n):
	sig += [list(input())]
	cur += [["".""] * m]

for i in range(n - 2):
	for j in range(m - 2):
		if isValid(sig, i, j):
			fill(cur, i, j)

if sig == cur:
	print(""YES"")
else:
	print(""NO"")",quadratic,implementation,558
"def main():
    n, m = map(int, input().split())
    a = []
    for i in range(n):
        s = input()
        b = []
        for l in s:
            b.append(l)
        a.append(b)
    for i in range(1, n - 1):
        for j in range(1, m - 1):
            may = True
            if (a[i][j - 1] == '.' or a[i][j + 1] == '.' or a[i + 1][j - 1] == '.' or a[i + 1][j + 1] == '.' or a[i + 1][j] == '.' or a[i - 1][j - 1] == '.' or a[i - 1][j + 1] == '.' or a[i - 1][j] == '.'):
                may = False
            if (may):
                a[i][j - 1] = a[i][j + 1] = a[i + 1][j - 1] = a[i + 1][j + 1] = a[i + 1][j] = a[i - 1][j - 1] = a[i - 1][j + 1] = a[i - 1][j] = '?'
    for i in range(n):
        for j in range(m):
            if (a[i][j] == '#'):
                print(""NO"")
                return
    print(""YES"")
main()",quadratic,implementation,831
"import sys


def solve(n, m, grid):
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            if cell == 0:
                continue
            must = cell == 1
            if i >= n - 2 or j >= m - 2:
                if must:
                    return 'NO'
                continue
            for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                if grid[i + di][j + dj] == 0:
                    if must:
                        return 'NO'
                    break
            else:
                for di, dj in [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)]:
                    grid[i + di][j + dj] = 2
                grid[i][j] = 2
    return 'YES'


n, m = list(map(int, input().split()))
grid = [['.#'.index(c) for c in line.strip()] for line in sys.stdin.readlines()]
print(solve(n, m, grid))
",quadratic,implementation,880
"n, m = map(int, input().split())

mp = []

for i in range(n):
    line = input().strip()
    
    mp.append(list(map(lambda c: c == '#', line)))

mp1 = [[False for _ in range(m)] for _ in range(n)]

for i in range(1, n - 1):
    for j in range(1, m - 1):
        f = all(mp[i - 1][j - k] for k in range(-1, 1+1))
        f = f and all(mp[i + 1][j - k] for k in range(-1, 1+1))
        f = f and (mp[i][j - 1] and mp[i][j + 1])
        
        if not f:
            continue
        
        for ik in range(-1, 2):
            for jk in range(-1, 2):
                if ik == 0 and jk == 0:
                    continue
                mp1[i + ik][j + jk] = True

if all(all(mp[i][j] == mp1[i][j] for j in range(m)) for i in range(n)):
    print('YES')
else:
    print('NO')
        ",quadratic,implementation,784
"n, m = map(int, input().split())
u = []
u1 = []
for i in range(n):
    u.append(list(input()))
    u1.append(['.'] * m)
for i in range(n - 2):
    for j in range(m - 2):
        ok = True
        for k in range(3):
            if u[i][j + k] != '#' or u[i + k][j] != '#':
                ok = False
                break
##        print(ok)
        if ok:
            if u[i + 2][j + 1] != '#' or u[i + 2][j + 2] != '#' or u[i + 1][j + 2] != '#':
                ok = False
            else:
                for k in range(3):
                    u1[i][j + k] = '#'
                    u1[i + k][j] = '#'
                u1[i + 2][j + 1] = '#'  
                u1[i + 2][j + 2] = '#'
                u1[i + 1][j + 2] = '#'
ok = True
##for i in u:
##    print(i)
##for i in u1:
##    print(i)
for i in range(n):
    for j in range(m):
        if u[i][j] != u1[i][j]:
            ok = False
            break
    if not ok:
        break
if ok:
    print('YES')
else:
    print('NO')
",quadratic,implementation,983
"n,m=map(int,input().split())
s=[]
st=set()
cst=set()
for i in range(n):
    s.append(input())
    for j in range(len(s[i])):
        if s[i][j]=='#':
            st.add((i,j))
for i in range(1,n-1):
    for j in range(1,m-1):
        if s[i-1][j-1]!='#':
            continue
        if s[i - 1][j ] != '#':
            continue
        if s[i-1][j+1]!='#':
            continue
        if s[i][j-1]!='#':
            continue
        if s[i][j+1]!='#':
            continue
        if s[i+1][j-1]!='#':
            continue
        if s[i+1][j]!='#':
            continue
        if s[i+1][j+1]!='#':
            continue
        cst.add((i-1,j))
        cst.add((i - 1, j-1))
        cst.add((i - 1, j+1))
        cst.add((i + 1, j))
        cst.add((i + 1, j-1))
        cst.add((i + 1, j+1))
        cst.add((i , j+1))
        cst.add((i , j-1))
if len(cst)==len(st):
    print('YES')
else:
    print('NO')",quadratic,implementation,910
"#!/usr/bin/python3

import math
import sys


DEBUG = False


def inp():
    return sys.stdin.readline().rstrip()


def dprint(*value, sep=' ', end='\n'):
    if DEBUG:
        print(*value, sep=sep, end=end)


def solve(H, W, A):
    visited = [bytearray(W) for _ in range(H)]

    for y in range(H):
        for x in range(W):
            if A[y][x] == '.' or visited[y][x]:
                continue

            dprint(x, y)
            for dx, dy in [(0, 0), (-1, 0), (-2, 0),
                           (0, -1), (-2, -1),
                           (0, -2), (-1, -2), (-2, -2)]:
                tx = x + dx
                ty = y + dy
                dprint('  ', tx, ty)
                if tx < 0 or ty < 0 or tx + 2 >= W or ty + 2 >= H:
                    continue
                bad = False
                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    if A[ny][nx] == '.':
                        bad = True
                        break
                if bad:
                    continue

                for ex, ey in [(0, 0), (1, 0), (2, 0),
                               (0, 1), (2, 1),
                               (0, 2), (1, 2), (2, 2)]:
                    nx = tx + ex
                    ny = ty + ey
                    visited[ny][nx] = 1

                assert visited[ny][nx] == 1
                break

            if visited[y][x] == 0:
                return False

    return True


def main():
    H, W = [int(e) for e in inp().split()]
    A = [inp() for _ in range(H)]

    print('YES' if solve(H, W, A) else 'NO')


if __name__ == '__main__':
    main()
",quadratic,implementation,1774
"n,m=map(int,raw_input().split())
arr=[]
arr1=[]
for i in range(n):
	arr2=str(raw_input())
	arr.append(arr2)
	x1=[0]*m
	arr1.append(x1)
for i in range(n):
	for j in range(m):
		if(arr[i][j]=='#' and i<n-2 and j<m-2):
			if(arr[i][j+1]=='#' and arr[i][j+2]=='#' and arr[i+1][j]=='#' and arr[i+2][j]=='#' and arr[i+2][j+1]=='#' and arr[i+2][j+2]=='#' and arr[i+1][j+2]=='#'):
				arr1[i][j]=1
				arr1[i+1][j]=1
				arr1[i+2][j]=1
				arr1[i+2][j+1]=1
				arr1[i+2][j+2]=1
				arr1[i+1][j+2]=1
				arr1[i][j+1]=1
				arr1[i][j+2]=1
flag=0
#print(arr1)
for i in range(n):
	for j in range(m):
		if(arr[i][j]==""#"" and arr1[i][j]==0):
			flag=1
			break
	if(flag==1):
		break
if(flag==1):
	print(""NO"")
else:
	print(""YES"")",quadratic,implementation,714
"import sys
import copy
lines = iter(sys.stdin)

def nexts():
    return next(lines)

def nextint():
    return int(nexts())

def snexts():
    return next(lines).split(' ')

def snextint():
    return map(int, snexts())

def array(length, base=0):
    return [base] * length

def matrix(length, width, base=0):
    return [[base] * width for _ in range(length)]

n, m = snextint()
grid = array(n, [])

for i in range(n):
    grid[i] = list(nexts())

grid2 = copy.deepcopy(grid)

for i in range(1, n - 1):
    for j in range(1, m - 1):
        # print('Attempting on i=%d,j=%d'%(i,j))
        if grid[i - 1][j] == '#' and grid[i - 1][j + 1] == '#' and grid[i][j + 1] == '#' and grid[i + 1][j + 1] == '#' and grid[i + 1][j] == '#' and grid[i + 1][j - 1] == '#' and grid[i][j - 1] == '#' and grid[i - 1][j - 1] == '#':
            grid2[i - 1][j] = '.'
            grid2[i - 1][j + 1] = '.'
            grid2[i][j + 1] = '.'
            grid2[i + 1][j + 1] = '.'
            grid2[i + 1][j] = '.'
            grid2[i + 1][j - 1] = '.'
            grid2[i][j - 1] = '.'
            grid2[i - 1][j - 1] = '.'

match = True
for i in grid2:
    for ch in i:
        if ch == '#':
            match = False
            break

if match:
    print('YES')
else:
    print('NO')",quadratic,implementation,1266
"n,m=map(int,input().split())
MAP=[list(input()) for i in range(n)]

ANSMAP=[[""."" for i in range(m)] for j in range(n)]

for i in range(1,n-1):
    for j in range(1,m-1):
        if MAP[i-1][j-1]==""#"" and MAP[i-1][j]==""#"" and MAP[i-1][j+1]==""#"" and MAP[i][j-1]==""#"" and MAP[i-1][j+1]==""#"" and MAP[i+1][j-1]==""#"" and MAP[i+1][j]==""#"" and MAP[i+1][j+1]==""#"":
            ANSMAP[i-1][j-1] =""#""
            ANSMAP[i-1][j]=""#""
            ANSMAP[i-1][j+1]=""#""
            ANSMAP[i][j-1]=""#""
            ANSMAP[i][j+1]=""#""
            ANSMAP[i+1][j-1]=""#""
            ANSMAP[i+1][j]=""#""
            ANSMAP[i+1][j+1]=""#""

if MAP==ANSMAP:
    print(""YES"")

else:
    print(""NO"")
            
",quadratic,implementation,683
"
N, M = map(int, input().split())


grid = []
for _ in range(N):
    grid.append(list(input()))

def check(grid, i, j, sx, sy):
    if i - sx >= 0 and j - sy >= 0 and i + 2 - sx < N and j + 2 - sy < M:
        i -= sx
        j -= sy
        v = grid[i][j] == '#' and grid[i+1][j] == '#' and grid[i+2][j] == '#' and grid[i][j+1] == '#' and grid[i+2][j+1] == '#' and grid[i][j+2] == '#' and grid[i+1][j+2] == '#' and grid[i+2][j+2] == '#'
        return v

    return False



prev = False
for m in range(M):
    for n in range(N):
        if grid[n][m] == '#':
            if not (check(grid, n, m, 0, 0) or check(grid, n, m, 1, 0) or check(grid, n, m, 2, 0) or check(grid, n, m, 0, 1) or check(grid, n, m, 2, 1) or check(grid, n, m, 0, 2) or check(grid, n, m, 1, 2) or check(grid, n, m, 2, 2)):
                print(""NO"")
                exit(0)

print(""YES"")
",quadratic,implementation,862
"from math import ceil, sqrt
#from sys import stdout
#from collections import deque

t = 1#int(input())
for test in range(1,t+1):
    n,m = (map(int, input().split()))
    arr = [[""."" for i in range(m)] for i in range(n)]
    arr2 = []
    for i in range(n):
        arr2.append(list(input()))
    for i in range(1,n-1):
        for j in range(1,m-1):
            if arr2[i+1][j] == arr2[i][j+1]==arr2[i+1][j+1]==arr2[i-1][j]==arr2[i][j-1]==arr2[i-1][j-1]==arr2[i+1][j-1]==arr2[i-1][j+1]==""#"":
                arr[i+1][j] = arr[i][j+1]=arr[i+1][j+1]=arr[i-1][j]=arr[i][j-1]=arr[i-1][j-1]=arr[i+1][j-1]=arr[i-1][j+1]=""#""

    if arr == arr2:
        print(""YES"")
    else:
        print(""NO"")
    


",quadratic,implementation,698
"n,m=[int(x) for x in input().split()]
s=[]
for i in range(n):
    s.append(input())
mapp=[[False]*m for i in range(n)]





rnd=((-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1))

def gene(x,y,p):
    cx=x-rnd[p][0]
    cy=y-rnd[p][1]
    ans=[]
    for i in range(8):
        ans.append((cx+rnd[i][0],cy+rnd[i][1]))
    return ans
def judge(ps):
    for x,y in ps:
        if x>=0 and x<n and y>=0 and y<m and s[x][y]=='#':
            continue
        else:
            return False
    return True
def dye(ps):
    global mapp
    for x,y in ps:
        mapp[x][y]=True
def check(x,y):
    for i in range(8):
        r=gene(x,y,i)
        if judge(r):
            dye(r)
            return True
    return False
for i in range(n):
    for j in range(m):
        if s[i][j]=='#' and mapp[i][j]==False:
            if check(i,j):
                continue
            else:
                print('NO')
                quit()
print('YES')",quadratic,implementation,942
"n,m=map(int,raw_input().split())

l=[]
for i in range(n):
	s=raw_input()
	l.append([])
	for j in range(m):
		l[-1].append(s[j])

ans=[]
for i in range(n):

	ans.append([])
	for j in range(m):
		ans[-1].append(""."")

for i in range(n-2):
	for j in range(m-2):
		if l[i][j]==""#"":
			if l[i][j]==l[i][j+1] and l[i][j]==l[i][j+2] and l[i][j]==l[i+1][j] and l[i][j]==l[i+1][j+2] and l[i][j]==l[i+2][j] and l[i][j]==l[i+2][j+1] and l[i][j]==l[i+2][j+2]:
				ans[i][j]=""#""
				ans[i][j+1]=""#""
				ans[i][j+2]=""#""
				ans[i+1][j]=""#""
				ans[i+1][j+2]=""#""
				ans[i+2][j]=""#""
				ans[i+2][j+1]=""#""
				ans[i+2][j+2]=""#""

flag = True
for i in range(n):
	for j in range(m):
		if l[i][j]!=ans[i][j]:
			flag = False
			break
	if flag==False:
		break

if flag==True:
	print(""YES"")
else:
	print(""NO"")

",quadratic,implementation,788
"n,m = map(int, input().split())
a = []
for i in range(n):
    s = input()
    a.append(s)
for i in range(n):
    for j in range(m):
        if a[i][j] == '.':
            continue
        if i >= 2 and j >= 2:
            if a[i-2][j-2] == '#' and a[i-2][j-1] == '#' and a[i-2][j] == '#' \
                    and a[i-1][j] == '#' and a[i-1][j-2] == '#' and a[i][j-1] == '#' and a[i][j-2] == '#':
                continue
        if i >= 1 and i <= n-2 and j >= 2 and a[i-1][j-2] == '#' and a[i-1][j-1] == '#' and a[i-1][j] == '#' \
                and a[i][j-2] == '#' and a[i+1][j-2] == '#' and a[i+1][j-1] == '#' and a[i+1][j] == '#':
            continue
        if i <= n-3 and j >= 2 and a[i][j-1] == '#' and a[i][j-2] == '#' and a[i+1][j] == '#' \
                and a[i+1][j-2] == '#' and a[i+2][j] == '#' and a[i+2][j-1] == '#' and a[i+2][j-2] == '#':
            continue
        if i <= n-3 and j >= 1 and j <= m-2 and a[i][j-1] == '#' and a[i][j+1] == '#' and a[i+1][j-1] == '#' \
                and a[i+1][j+1] == '#' and a[i+2][j] == '#' and a[i+2][j-1] == '#' and a[i+2][j+1] == '#':
            continue
        if i <= n-3 and j <= m-3 and a[i][j+1] == '#' and a[i][j+2] == '#' and a[i+1][j] == '#' \
                and a[i+1][j+2] == '#' and a[i+2][j] == '#' and a[i+2][j+1] == '#' and a[i+2][j+2] == '#':
            continue
        if i <= n-2 and i >= 1 and j <= m-3 and a[i-1][j] == '#' and a[i-1][j+1] == '#' and a[i-1][j+2] == '#' \
                and a[i][j+2] == '#' and a[i+1][j] == '#' and a[i+1][j+1] == '#' and a[i+1][j+2] == '#':
            continue
        if i >= 2 and j <= m-3 and a[i-2][j] == '#' and a[i-2][j+1] == '#' and a[i-2][j+2] == '#' \
                and a[i-1][j] == '#' and a[i-1][j+2] == '#' and a[i][j+1] == '#' and a[i][j+2] == '#':
            continue
        if i >= 2 and j <= m-2 and j >= 1 and a[i-2][j-1] == '#' and a[i-2][j] == '#' and a[i-2][j+1] == '#' \
                and a[i-1][j-1] == '#' and a[i-1][j+1] == '#' and a[i][j-1] == '#' and a[i][j+1] == '#':
            continue
        print('NO')
        exit()
print('YES')",quadratic,implementation,2095
"#!/usr/bin/env python3
import sys

def rint():
    return map(int, sys.stdin.readline().split())
#lines = stdin.readlines()

def writable(r, c):
    if r+2 >= n or c+2 >= m:
        return False
    t = set()
    t.add(cells[r][c])
    t.add(cells[r][c+1])
    t.add(cells[r][c+2])
    t.add(cells[r+1][c])
    t.add(cells[r+1][c+2])
    t.add(cells[r+2][c])
    t.add(cells[r+2][c+1])
    t.add(cells[r+2][c+2])
    return not '.' in t

def fill_ink(r,c):
    paper[r][c] = ""#""
    paper[r][c+1] = ""#""
    paper[r][c+2] = ""#""
    paper[r+1][c] = ""#""
    paper[r+1][c+2] = ""#""
    paper[r+2][c] = ""#""
    paper[r+2][c+1] = ""#""
    paper[r+2][c+2] = ""#""

n, m = rint()

cells = []
for i in range(n):
    cells.append(input())

#for i in range(n):
#    for j in range(m):
#        print(cells[i][j], end='')
#    print()

paper = [[""."" for j in range(m)] for i in range(n)]

for r in range(n):
    for c in range(m):
        if writable(r,c) is True:
            fill_ink(r, c)

for r in range(n):
    for c in range(m):
        if cells[r][c] != paper[r][c]:
            print(""NO"")
            exit()

print(""YES"")
",quadratic,implementation,1115
"""""""n,L,a=map(int,input().split())
#s=[int(x) for x in input().split()]
ed=0
ct=0
for j in range(0,n):
    t,l=map(int,input().split())
    ct=ct+((t-ed)//a)
    ed=t+l
t=L
ct=ct+((t-ed)//a)
print(ct)""""""

n,m=map(int,input().split())
dp=[[-1 for i in range(m)] for j in range(n)]
dp2=[[-1 for i in range(m)] for j in range(n)]
#dp=[]
#dp2=[]
for i in range(0,n):
    s=input()
    for j in range(0,m):
        if(s[j]=='.'):
            dp[i][j]=-1
        else:
            dp[i][j]=s[j]
for i in range(0,n-2):
    for j in range(0,m-2):
        #print(i,j)
        p=0
        c=0
        for k in range(i,i+3):
            for h in range(j,j+3):
                p=p+1
                if(p!=5):
                    if(dp[k][h]=='#'):
                        c=c+1

                    
        if(c==8):
            p=0
            for k in range(i,i+3):
                for h in range(j,j+3):
                    p=p+1
                    if(p!=5):
                        dp2[k][h]='#'


                        
#print(dp)
#print(dp2)
if(dp==dp2):
    print('YES')
else:
    print('NO')

                            
",quadratic,implementation,1121
"n,m=map(int,input().split())
s=[]
for i in range(n):
	s.append(list(map(str,input().strip())))
#print(s)
t=[]
for i in range(n):
	p=['.']*m
	t.append(p)

for i in range(1,n-1):
	for j in range(1,m-1):
		f=0
		if s[i-1][j-1]=='#' and s[i-1][j]=='#' and s[i-1][j+1]=='#' and s[i][j-1]=='#' and s[i][j+1]=='#' and s[i+1][j-1]=='#' and s[i+1][j]=='#' and s[i+1][j+1]=='#':
			f=1
		if f==1:
			t[i-1][j-1]='#'
			t[i-1][j]='#'
			t[i-1][j+1]='#'
			t[i][j-1]='#'
			t[i][j+1]='#'
			t[i+1][j-1]='#'
			t[i+1][j]='#'
			t[i+1][j+1]='#'
f=1
#print(t)
for i in range(n):
	for j in range(m):
		if s[i][j]=='#' and s[i][j]!=t[i][j]:
			f=0
			break
	if f==0:
		break
if f==1:
	print(""YES"")
else:
	print(""NO"")
",quadratic,implementation,700
"n,m = [int(i) for i in input().split()]
b=[]
a=[]
for i in range(n):
    b.append([i for i in input()])
    a.append([0 for i in range(m)])
    
def check(e,r,q):
    if e>=0 and r>=0 and e+2<n and r+2<m:
        if b[e][r]=='#' and b[e+1][r]=='#' and b[e+2][r]=='#' and b[e+2][r+1]=='#' and b[e+2][r+2]=='#' and b[e+1][r+2]=='#' and b[e][r+2]=='#' and b[e][r+1]=='#':
            a[e][r]==1 
            a[e+1][r]==1 
            a[e+2][r]==1
            a[e+2][r+1]==1
            a[e+2][r+2]==1  
            a[e+1][r+2]==1
            a[e][r+2]==1 
            a[e][r+1]==1
            return True
    if q ==1:
        return False
    return check(e,r-1,1) or check(e,r-2,1) or check(e-1,r-2,1) or check(e-2,r-2,1) or check(e-2,r-1,1) or check(e-2,r,1) or check(e-1,r,1)
for i in range(n):
    for j in range(m):
        if b[i][j]=='#':
            if (not check(i,j,0)) and a[i][j]==0:
                print(""NO"")
                exit()
print(""YES"")",quadratic,implementation,957
"def color8(i,j,ip):
    if i>n-3 or j>m-3:
        return
    else:
        ip[i][j]='#'
        ip[i][j+1]='#'
        ip[i][j+2]='#'
        ip[i+1][j]='#'
        ip[i+1][j+2]='#'
        ip[i+2][j]='#'
        ip[i+2][j+1]='#'
        ip[i+2][j+2]='#'
        
n,m=map(int,input().split())
ip=[]
op=[['.' for i in range(m)] for j in range(n)]
#print(op)
b=0
for i in range(n):
    ip.append(str(input()))
#print(ip,ip[1][1])
for i in range(n):
    for j in range(m):
        if ip[i][j]=='#':
            try:
                if ip[i+2][j+2]=='#':
                    temp=(ip[i][j]=='#' and ip[i][j+1]=='#' and ip[i][j+2]=='#' and ip[i+1][j]=='#' and ip[i+1][j+2]=='#' and ip[i+2][j]=='#' and ip[i+2][j+1]=='#' and ip[i+2][j+2]=='#')
                    #print(temp)
                    if temp==True:
                        color8(i,j,op)
            except:
                pass
#print(ip,op)
for i in range(n):
    if ''.join(op[i])!=ip[i]:
        print('NO')
        b=1
        break
if b==0:
    print('YES')
",quadratic,implementation,1022
"import sys;
def transform(c):
	if c == '.': return 0;
	if c == '#': return 1;
	return 2;

def take_care(board,n,m):
	if n + 2 >= N:
		return;
	if m + 2 >= M:
		return;
	if board[n][m+1] == 0 or board[n][m+2] == 0 or board[n+1][m] == 0 or board[n+1][m+2] == 0 or board[n+2][m] == 0 or board[n+2][m+1] == 0 or board[n+2][m+2] == 0:
		return;
	board[n][m] = 2
	board[n][m+1] = 2
	board[n][m+2] = 2
	board[n+1][m] = 2
	board[n+1][m+2] = 2
	board[n+2][m] = 2
	board[n+2][m+1] = 2
	board[n+2][m+2] = 2
	return False,board;

N,M = [int(i) for i in input().strip().split()];
board = [];
for n in range(N):
	row = input().strip();
	row = [ transform(c) for c in row];
	board.append(row);
#print('board = ');
#print(board);
for n in range(N):
	for m in range(M):
		take_care(board,n,m);
for row in board:
	if 1 in row:
		print('NO');
		sys.exit();
print('YES');
",quadratic,implementation,852
"#!/usr/bin/env python
    
n, m = [int(x) for x in input().split()]
mat = []
v = []

for i in range(n):
    mat.append([x == '#' for x in input()])
    v.append([False]*m)

def check(m, v, x, y):
    for i in (-1,0,1):
        for j in (-1,0,1):
            if (i,j) == (0,0):
                continue
            if not m[x+i][y+j]:
                return

    for i in (-1,0,1):
        for j in (-1,0,1):
            if (i,j) != (0,0):
                v[x+i][y+j] = True

for x in range(1, n-1):
    for y in range(1,m-1):
        check(mat, v, x, y)

flag = True
for i in range(0,n):
    for j in range(0,m):
        if mat[i][j] and (not v[i][j]):
            flag = False

if flag:
    print(""YES"")
else:
    print(""NO"")
",quadratic,implementation,727
"n, m = list(map(int, input().split()))
cl = []
for i in range(n):
  cl.append(input())

def is_squad(x, y):
  if cl[x][y]=='#' and cl[x+1][y]=='#' and cl[x+2][y]=='#' and cl[x+2][y+1]=='#' and cl[x+2][y+2]=='#' and cl[x+1][y+2]=='#' and cl[x][y+2]=='#' and cl[x][y+1]=='#':
    return True
  else:
    return False

def cv(x, y):
  counter = 0
  if x-2>=0 and y+2<=m-1 and is_squad(x-2, y):
    return True
   
  elif x-1>=0 and x+1<=n-1 and y+2<=m-1 and is_squad(x-1, y):
    return True

  elif x+2<=n-1 and y+2<=m-1 and is_squad(x, y):
    return True
  
  elif x+2<=n-1 and y+1<=m-1 and y-1>=0 and is_squad(x, y-1):
    return True

  elif x+2<=n-1 and y-2>=0 and is_squad(x, y-2):
    return True

  elif x+1<=n-1 and x-1>=0 and y-2>=0 and is_squad(x-1, y-2):
    return True

  elif x-2>=0 and y-2>=0 and is_squad(x-2, y-2):
    return True

  elif x-2>=0 and y-1>=0 and y+1<=m-1 and is_squad(x-2, y-1):
    return True
  else:
    return False
  

  

  
  

for i in range(n):
  for j in range(m):
    if cl[i][j]=='#':
      if not cv(i, j):
        print('NO')
        exit()

print('YES')",quadratic,implementation,1099
"n,m=map(int,input().split())
a=[list('') for x in range(n)]
b=[list('.'*m) for x in range(n)]
start=0
#end=n-2
for i in range(n):
    a[i]=list(input())
    if (start==0):
        if ('.' in a[i]):
            start=((i-3)//3) *3 
for i in range(start):
    b[i]=list('#'*m)
#print(start)
for i in range(start,n-2):
    for j in range(m-2):
        ok=True
        if a[i][j]=='#':
            for y in range(i,i+3):
                if ok==False:
                    break
                for x in range(j,j+3):
                    if not((y==i+1)and(x==j+1)):
                        if a[y][x]!='#':
                            #print('lel')
                            #print(x,y)
                            ok=False
                            break                      
            if ok:
                for y in range(i,i+3):
                    for x in range(j,j+3):
                        if not((y==i+1)and(x==j+1)):   
                            b[y][x]='#'
                        
#for i in a:
#    print(i)
#print()
#for i in b:
#    print(i)
    
if a==b:
    print('YES')
else:
    print('NO')
",quadratic,implementation,1115
"n, m = map(int, input().split())
a = []
array = []
for i in range(n):
    a.append(list(map(str, input())))
    listt = []
    for c in range(m):
        if a[i][c] == '#':
            listt.append(1)
        else:
            listt.append(0)
    array.append(listt)
for y in range(1, n - 1):
    for x in range(1, m - 1):
        f = a[y + 1][x] == '#' and a[y + 1][x + 1] == '#' and a[y + 1][x - 1] == '#'
        s = a[y][x + 1] == '#' and a[y][x - 1] == '#'
        th = a[y - 1][x] == '#' and a[y - 1][x + 1] == '#' and a[y - 1][x - 1] == '#'
        if f and s and th:
            array[y + 1][x] -= 1
            array[y + 1][x + 1] -= 1
            array[y + 1][x - 1] -= 1
            array[y][x + 1] -= 1
            array[y][x - 1] -= 1
            array[y - 1][x - 1] -= 1
            array[y - 1][x] -= 1
            array[y - 1][x + 1] -= 1
mb = True
for y in range(n):
    for x in range(m):
        if array[y][x] == 1:
            mb = False
            break
if mb:
    print(""YES"")
else:
    print(""NO"")",quadratic,implementation,1022
"import sys
m,n = [int(i) for i in input().split(' ')]
l = [[] for _ in range(m)]
for i in range(m):
	l[i] = input()
inks = []
for i in range(1, m-1):
	for j in range(1, n-1):
		if l[i-1][j-1] == '#' and l[i][j-1] == '#' and l[i+1][j-1] == '#' and l[i-1][j] == '#' and l[i+1][j] == '#' and l[i-1][j+1] == '#'and l[i][j+1] == '#'and l[i+1][j+1] == '#':
			   inks += [(i-1,j-1),(i,j-1),(i+1,j-1),
					    (i-1,j  )        ,(i+1,j  ),
						(i-1,j+1),(i,j+1),(i+1,j+1),]
for i in range(m):
	for j in range(n):
		if l[i][j] == '#' and not (i,j) in inks:
			print(""NO"")
			sys.exit()
else:
	print(""YES"")
			
			
		   
		
",quadratic,implementation,617
"import math as ma
import sys
from sys import exit
from decimal import Decimal as dec
from itertools import permutations


def li():
	return list(map(int , input().split()))


# https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/
def modInverse(a , m):
	m0 = m
	y = 0
	x = 1
	if (m == 1):
		return 0
	while (a > 1):
		q = a // m
		t = m
		m = a % m
		a = t
		t = y
		y = x - q * y
		x = t
	if (x < 0):
		x = x + m0
	return x


def num():
	return map(int , input().split())


def nu():
	return int(input())


def find_gcd(x , y):
	while (y):
		x , y = y , x % y
	return x

n,m=num()
a=[0]*n
for i in range(n):
	a[i]=[0]*m
for i in range(n):
	s=input()
	for j in range(m):
		a[i][j]=s[j]
z=["".""]*n
for i in range(n):
	z[i]=["".""]*m
for i in range(n):
	for j in range(m):
		if(j-1>=0 and j+1 <m and i+1<n and i-1>=0):
			if(a[i-1][j]==""#"" and a[i+1][j]==""#"" and a[i][j-1]==""#"" and a[i][j+1]==""#"" and a[i-1][j-1]==""#"" and a[i-1][j+1]==""#"" and a[i+1][j-1]==""#"" and a[i+1][j+1]==""#""):
				z[i-1][j]=""#""
				z[i + 1][j] = ""#""
				z[i][j - 1] = ""#""
				z[i][j + 1] = ""#""
				z[i - 1][j - 1] = ""#""
				z[i - 1][j + 1] = ""#""
				z[i + 1][j - 1] = ""#""
				z[i + 1][j + 1] = ""#""
ff=True

for i in range(n):
	for j in range(m):
		if(z[i][j]!=a[i][j]):
			ff=False
			break
if(ff):
	print(""YES"")
else:
	print(""NO"")",quadratic,implementation,1315
"D = False

def hash(r,c):
    return str(r) + ""-"" + str(c)

def sol():
    R, C = [int(x) for x in input().split("" "")]
    m = []
    count = 0
    for _ in range(R):
        line = input()
        m.append(line)
        count += line.count(""#"")

    if D: print(""Count:"", count)

    lookup = {}
    for r in range(1, R-1):
        for c in range(1, C-1):

            if D: print(""  row,col:"", r, c)

            offset = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
            lst = []
            fail = False

            # ensure all 8 adj cells are '#'
            # if so add to
            for o in offset:

                cell = (r + o[0], c + o[1])
                if D: print(""  cell:"", cell, m[cell[0]][cell[1]])
                h = hash(cell[0], cell[1])

                if m[cell[0]][cell[1]] == ""#"":
                    if (not h in lookup):
                        lst.append(h)

                else: # . found
                    fail = True
                    break

            if not fail:
                for item in lst:
                    lookup[item] = True
                count -= len(lst)

    return ""YES"" if count == 0 else ""NO""

#for t in range(int(input())):
ans = sol()
print(ans)
",quadratic,implementation,1231
"n = int(input())
a = list(map(int, input().split()))[::-1]
b = list(map(int, input().split()))
ans = [0] * n
marked = [True] * (n + 1)
for i in range(n):
    if marked[b[i]]:
        while True:
            marked[a[-1]] = False
            ans[i] += 1
            if a[-1] == b[i]:
                a.pop()
                break
            a.pop()
    else:
        continue
print(*ans)",quadratic,"implementation,math",387
"n, m = map(int, input().split())
a = list(map(int, input().split()))
t = list(map(int, input().split()))
ans = [0] * m
p = []
for i in range(n + m):
    if t[i] == 1:
        p.append(i)
ans[0] = p[0]
for i in range(m):
    if i == m - 1:
        ans[i] += n + m - p[i] - 1
    else:
        for j in range(p[i] + 1, p[i + 1]):
            if a[j] - a[p[i]] <= a[p[i + 1]] - a[j]:
                ans[i] += 1
            else:
                ans[i + 1] += 1
print(' '.join(map(str, ans)))
",quadratic,"implementation,sortings",490
"n, m = [int(x) for x in input().split()]
xs = [int(x) for x in input().split()]
ts = [int(x) for x in input().split()]


taxi_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 1])
passenger_idx = sorted([xs[idx] for idx in range(n + m) if ts[idx] == 0])

a_is = [0] * len(taxi_idx)
t_idx = 0
p_idx = 0

while True:
    if p_idx >= len(passenger_idx):
        break

    if t_idx == len(taxi_idx) - 1:
        a_is[t_idx] += 1
    else:
        while t_idx < len(taxi_idx) - 1:
            d1 = abs(passenger_idx[p_idx] - taxi_idx[t_idx])
            d2 = abs(passenger_idx[p_idx] - taxi_idx[t_idx + 1])
            # print(t_idx, d1, d2)
            if d1 > d2:
                t_idx += 1
            else:
                break

        a_is[t_idx] += 1

    p_idx += 1

print(' '.join([str(x) for x in a_is]))
",quadratic,"implementation,sortings",822
"#n=int(input())
n,m=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))

def next(k,a):
    i=k+1
    while a[i]!=1: i+=1
    return i

ans=[0]*(m+1)

k=-1
k=next(k,b)
ans[1]=k
for i in range(2,m+1):
    kk=next(k,b)
    for j in range(k+1,kk):
        if a[j]-a[k]<=a[kk]-a[j]:
            ans[i-1]+=1
        else:
            ans[i]+=1
    k=kk
    

ans[m]+=(n+m-1-k)

for i in range(1,m+1):
    print(ans[i],end=' ')
",quadratic,"implementation,sortings",461
"n, m = list(map(int,input().split()))
x = list(map(int,input().split()))
t = list(map(int,input().split()))
arr = []
pep = {}
for i in range(n+m):
    if t[i] == 0:
        arr.append(i)
        pep[x[i]] = 0
    else:
        for j in arr:
            pep[x[j]] = i
        arr = []
for i in range(n+m-1, -1, -1):
    if t[i] == 0:
        arr.append(i)
    else:
        for j in arr:
            if abs(x[j] - x[i]) <= abs(x[pep[x[j]]] - x[j]):
                pep[x[j]] = i
        arr = []
ans = []
for i in range(n+m):
    if t[i]:
        ans.append(1)
    else:
        ans.append(0)
for i in pep:
    ans[pep[i]] += 1
for i in ans:
    if i:
        print(i-1, end = ' ')


",quadratic,"implementation,sortings",683
"n=int(input())
l=[int(c) for c in input().split()]
ll=[]
res=[]
head=0
dia=0
for i in range(1,n):
    if l[i]==1:
        l[i]=0
        ll.append(i)
    else:
        res.append((head+1,i+1))
        l[head]-=1
        dia+=1
        head=i
        l[head]-=1
if l[head]>0 and len(ll)>0:
    res.append((ll[0]+1,head+1))
    l[head]-=1
    del(ll[0])
    dia+=1
if l[0]>0 and len(ll)>0:
    res.append((ll[0]+1,1))
    l[0]-=1
    del(ll[0])
    dia+=1
for i in ll:
    for j in range(n):
        if l[j]>0:
            res.append((j+1,i+1))
            l[j]-=1
            break
if len(res)<n-1:
    print(""NO"")
else:
    print(""YES ""+str(dia))
    print(n-1)
    for p in res:
        print(p[0],end ="" "")
        print(p[1])",quadratic,"constructive algorithms,graphs,implementation",728
"from collections import namedtuple
vertex = namedtuple('vertex', ['degree', 'id'])
a, b, c = [], [], 0

n = int(input())
rr = list(map(int, input().split()))

for i in range(n):
    if rr[i] > 1:
        a.append(vertex(rr[i], i + 1))
    else:
        b.append(vertex(rr[i], i + 1))
    c += rr[i]

if c < (n - 1)*2:
    print('NO')
else:
    print('YES', len(a) - 1 + min(2, len(b)))
    print(n - 1)
    for i in range(1,len(a)):
        print(a[i - 1].id, a[i].id)
    if len(b) > 0:
        print(b[0].id, a[0].id)
    if len(b) > 1:
        print(b[1].id, a[-1].id)
    j, yes = 2, 0
    for i in range(len(a)):
        k = a[i].degree - 2
        for t in range(k):
            if j >= len(b):
                yes = 1
                break
            print(a[i].id, b[j].id)
            j += 1
        if yes == 1:
            break",quadratic,"constructive algorithms,graphs,implementation",840
"n = int(input())
a, edge = [0], []
last, sum, ans = 0, 0, 0
for i in map(int, input().split()) :
    a.append(i)
    sum += i
for i in range(1, n + 1) :
    if(a[i] == 1) :
        last = i
a[last] = 0
for i in range(1, n + 1) :
    if(a[i] > 1) :
        if(last) :
            edge.append([last, i])
            ans += 1
        last = i
for i in range(1, n + 1) :
    if(a[i] == 1 and last) :
        edge.append([last, i])
        last = 0
        a[i] = 0
        ans += 1
for i in range(1, n + 1) :
    for j in range(1, n + 1) :
        if(a[j] == 1 and a[i] > 2) :
            edge.append([i, j])
            a[i] -= 1
            a[j] -= 1
if(len(edge) != n - 1) :
    print(""NO"")
else :
    print(""YES"", ans)
    print(len(edge))
    for i in edge :
        print(i[0], i[1])
",quadratic,"constructive algorithms,graphs,implementation",786
"n = int(input())
a = list(map(int, input().split()))

if sum(a) < (2 * n) - 2:
    print(""NO"")
else:
    one = []
    rst = []
    for i in range(0, n):
        if a[i] > 1:
            rst.append(i)
        else:
            one.append(i)
    ans = []
    for i in range(1, len(rst)):
        ans.append((rst[i], rst[i - 1]))
        a[rst[i]] -= 1
        a[rst[i - 1]] -= 1
    for i in range(1, len(one)):
        for j in range(0, len(rst)):
            if a[rst[j]] > 0:
                a[rst[j]] -= 1
                ans.append((rst[j], one[i]))
                break
    if len(one):
        for i in range(len(rst) - 1, -1, -1):
            if a[rst[i]] > 0:
                ans.append((rst[i], one[0]))
                break
    siz = min(len(one) + len(rst), 2 + len(rst)) - 1
    print(""YES "", siz)
    
    print(len(ans))
    for u,v in ans:
        print(u + 1,v + 1)
    
",quadratic,"constructive algorithms,graphs,implementation",888
"x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())

points = [(x1, y1), (x2, y2), (y3, x3)]

def gen_points(A, B):
	'''
	+--.
	|
	|
	.
	'''

	return [(A[0], B[1]), (B[0], A[1])]

points += gen_points([x1, y1], [x2, y2])
points += gen_points([x2, y2], [x3, y3])
points += gen_points([x1, y1], [x3, y3])

points = list(set(points))

ans = 1e9
ans_l = []

def mark_points(A, B):
	A = list(A)
	B = list(B)
	d = set()
	x_s = 1 if A[0] < B[0] else -1
	y_s = 1 if A[1] < B[1] else -1
	d.add((A[0], A[1]))
	while A[0] != B[0]:
		A[0] += x_s
		d.add((A[0], A[1]))
	while A[1] != B[1]:
		A[1] += y_s
		d.add((A[0], A[1]))
	return d

for el in points:
	d = mark_points([x1, y1], el).union(mark_points([x2, y2], el))
	d = d.union(mark_points([x3, y3], el))
	if len(d) < ans:
		ans = len(d)
		ans_l = d

print(ans)
for el in ans_l:
	print(*el)",quadratic,"greedy,implementation",884
"n, v = map(int, input().split())
cur = 0
total = 0
for i in range(n):
    while cur < n - i - 1:
        cur += 1
        total += (i + 1)
        if cur == v:
            break
    cur -= 1
print(total)",quadratic,"dp,greedy,math",203
"n, v = map(int, input().split())
b = 0
ans = 0
sss = 0
for i in range(1, n + 1):
    while b < v:
        if sss == n - 1:
            break
        sss += 1
        ans += i
        b += 1
    b -= 1
print(ans)",quadratic,"dp,greedy,math",211
"def stones_after(n, s):
	for i in s:
		if i == '-':
			n -= 1
		else:
			n += 1
		if n < 0:
			return -1
	return n

n = int(input().strip())
s = input().strip()
ans = 99999999
for i in range(n+1):
	stones = stones_after(i, s)
	if stones != -1:
		ans = min(ans, stones)
print(ans)",quadratic,"implementation,math",279
"def main():
    n = int(input())
    s = input()
    for i in range(n+1):
        flag = True
        stones = i
        for j in s:
            if j == '-':
                if stones > 0:
                    stones -= 1
                else:
                    flag = False
                    break
            else:
                stones += 1

        if flag:
            n = i
            break

    stones = n
    for i in s:
        if i == '-':
            stones -= 1
        else:
            stones += 1

    print(stones)

    

main()
",quadratic,"implementation,math",550
"n, k = map( int, input().split() )

d = n - k
d = d // 2

l = []

while n > 0:
    i = min(n,d)
    while i>0:
        l.append('1')
        i -= 1
        n -= 1
    if n > 0:
        l.append('0')
        n -= 1

print( """".join( l ) )",quadratic,"brute force,greedy,constructive algorithms,math,strings",236
"n, e = map( int, input().split() )
d = (n - e) // 2
q = []
while n > 0:
    i = min(n, d)
    while i > 0:
        q.append('1')
        i -= 1
        n -= 1
    if n > 0:
        q.append('0')
        n -= 1

print( """".join(q) )",quadratic,"brute force,greedy,constructive algorithms,math,strings",230
"import os
import sys
from io import BytesIO, IOBase
import math
from collections import defaultdict, deque
import random

# to output - sys.stdout.write('{} {}\n'.format(*a))
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# n, k = map(int, input().split("" ""))
# l = list(map(int, input().split("" "")))

n, k = map(int, input().split("" ""))
ans = []
for i in range(1, n*k + 1):
    if i%2:
        x,y = divmod(i//2, k)
        ans.append([x+1, y+1])
    else:
        x,y = divmod(n*k-i//2, k)
        ans.append([x + 1, y + 1])
for i in ans:
    sys.stdout.write('{} {}\n'.format(*i))",quadratic,constructive algorithms,2188
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# ------------------- fast io --------------------
def main():
    n,m=map(int,input().split())
    ans=[];moves=n*m;
    c1=[1,1];c2=[n,m];p=0
    while moves>0:
        if p%2==0:
            ans.append(tuple(c1))
            c1[1]+=1
            if c1[1]>m:
                c1[0]+=1;c1[1]=1
        else:
            ans.append(tuple(c2))
            c2[1]-=1
            if c2[1]<1:
                c2[0]-=1;c2[1]=m
        moves-=1;p+=1
    for i in ans:
        print(*i)
main()",quadratic,constructive algorithms,2248
"import sys
n,m=map(int,input().split())
for i in range(n//2):
    for j in range(m):
        sys.stdout.write('{} {}\n'.format(*[i+1,j+1]))
        sys.stdout.write('{} {}\n'.format(*[n-i,m-j]))
if n%2:
    for j in range(m//2):
        sys.stdout.write('{} {}\n'.format(*[n//2+1,j+1]))
        sys.stdout.write('{} {}\n'.format(*[n//2+1,m-j]))
    if m%2:
        sys.stdout.write('{} {}\n'.format(*[n//2+1,m//2+1]))",quadratic,constructive algorithms,417
"(x, y) = list(map(int, input().split(' ')))

a = 0
b = x * y
pos = True

for t in reversed(range(b)):
    b -= 1
    print(str(int(a / y + 1)) + ' '+ str(int(a % y + 1)))
    a += b * (1 if pos else -1)
    pos = not pos  

   			 								 		 			  	    	",quadratic,constructive algorithms,254
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase

def main():
    n,m=map(int,input().split())
    s,e,ans=[1,1],[n,m],[]
    for i in range(n*m//2):
        ans.append(s[:])
        ans.append(e[:])
        s[1],e[1]=s[1]+1,e[1]-1
        if s[1]==m+1:
            s=[s[0]+1,1]
        if not e[1]:
            e=[e[0]-1,m]
    if (n*m)&1:
        ans.append([s[0],s[1]])
    for i in ans:
        print(*i)

     


# FASTIO REGION

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",quadratic,constructive algorithms,2189
"n, m=[int(k) for k in input().split()]
res=[]
for j in range(n//2):
    for k in range(m):
        res.append(str(j+1)+"" ""+str(k+1))
        res.append(str(n-j)+"" ""+str(m-k))
if n%2:
    for j in range(m//2):
        res.append(f""{n//2+1} {j+1}"")
        res.append(f""{n//2+1} {m-j}"")
    if m%2:
        res.append(f""{n//2+1} {m//2+1}"")
print(""\n"".join(res))",quadratic,constructive algorithms,359
"import sys,atexit
from io import BytesIO
inp = BytesIO(sys.stdin.buffer.read())
input = lambda:inp.readline().decode('ascii')
buf = BytesIO()
sys.stdout.write = lambda s: buf.write(s.encode('ascii'))
atexit.register(lambda:sys.__stdout__.buffer.write(buf.getvalue()))

n,m = map(int,input().split())
if m%2 == 0:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
else:
    steps = []
    for j in range(m//2):
        for i in range(n):
            steps.append((j,i))
            steps.append((m-j-1,n-i-1))
    l = 0
    r = n-1
    mid = m//2
    while l<=r:
        steps.append((mid,l))
        if l != r:
            steps.append((mid,r))
        l += 1
        r -= 1

for x,y in steps:
    print(y+1,x+1)

#vis = set()
#for i in range(1,len(steps)):
#    dx,dy = steps[i][0]-steps[i-1][0],steps[i][1]-steps[i-1][1]
#    assert((dx,dy) not in vis)
#    vis.add((dx,dy))

#print(steps)
#C = [list('.'*m) for _ in range(n)]
#for i,e in enumerate(steps):
#    x,y = e
#    C[y][x] = chr(65+i)
#for c in C:
#    print(''.join(c))
",quadratic,constructive algorithms,1123
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
ANS=[]

for i in range(1,n//2+1):
    for j in range(1,m+1):
        sys.stdout.write("""".join((str(i),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n-i+1),"" "",str(m-j+1),""\n"")))



if n%2==1:
    for j in range(1,m//2+1):
        sys.stdout.write("""".join((str(n//2+1),"" "",str(j),""\n"")))
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m-j+1),""\n"")))

    if m%2==1:
        sys.stdout.write("""".join((str(n//2+1),"" "",str(m//2+1),""\n"")))

",quadratic,constructive algorithms,522
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
ANS=[]

for i in range(1,n//2+1):
    for j in range(1,m+1):
        sys.stdout.write((str(i)+"" ""+str(j)+""\n""))
        sys.stdout.write((str(n-i+1)+"" ""+str(m-j+1)+""\n""))


if n%2==1:
    for j in range(1,m//2+1):
        sys.stdout.write((str(n//2+1)+"" ""+str(j)+""\n""))
        sys.stdout.write((str(n//2+1)+"" ""+str(m-j+1)+""\n""))

    if m%2==1:
        sys.stdout.write((str(n//2+1)+"" ""+str(m//2+1)+""\n""))

",quadratic,constructive algorithms,476
"def main():
    n, m = map(int, input().split())

    r = []
    rappend = r.append
    for i in range(1, (n >> 1) + 1):
        for j in range(1, m + 1):
            rappend(str(i) + ' ' + str(j))
            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))

    if n & 1:
        for i in range(1, (m >> 1) + 1):
            rappend(str((n + 1) >> 1) + ' ' + str(i))
            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))
        if m & 1:
            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))

    print('\n'.join(r))


main()
",quadratic,constructive algorithms,546
"import sys
N, M = map(int, input().split())

Ans = [(0, 0) for  _ in range(N*M)]
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = ' '.join((str(a+1), str(b+1)))

for a in Ans:
    sys.stdout.write(f'{a}\n') 
",quadratic,constructive algorithms,292
"import sys
N, M = map(int, input().split())

Ans = [(0, 0) for  _ in range(N*M)]
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = (a+1, b+1)
for a in Ans:
    sys.stdout.write('{} {}\n'.format(*a))",quadratic,constructive algorithms,281
"import sys
N, M = map(int, input().split())

Ans = [None]*(N*M)
for i in range(1, N*M+1):
    if i % 2:
        a, b = divmod(i//2, M)
    else:
        a, b = divmod(N*M - i//2, M)
    Ans[i-1] = (a+1, b+1)
for a in Ans:
    sys.stdout.write('{} {}\n'.format(*a))",quadratic,constructive algorithms,264
"from sys import stdout
N,M=map(int,input().split())
if M%2==0 and N%2==0:
    for m in range (1,M//2+1): 
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
elif M%2==0 and N%2==1:
    for m in range (1,M//2+1): 
        for i in range (1,N+1):
            stdout.write(str(i)+' '+str(m)+'\n')
            stdout.write(str(N+1-i)+' '+str(M+1-m)+'\n')
else:
    for m in range (1,(M+1)//2): 
        for n in range (1,N+1):
            stdout.write(str(n)+' '+str(m)+'\n')
            stdout.write(str(N+1-n)+' '+str(M+1-m)+'\n')
    if N%2==0:
        for i in range (1,N//2+1):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
    else:
        for i in range (1,(N+1)//2):
            stdout.write(str(i)+' '+str((M+1)//2)+'\n')
            stdout.write(str(N+1-i)+' '+str((M+1)//2)+'\n')
        stdout.write(str((N+1)//2)+' '+str((M+1)//2)+'\n')",quadratic,constructive algorithms,1003
"import math

inp = input().split(' ')
m = int(inp[0])
n = int(inp[1])

result = []

for column in range(1, math.ceil(m/2) + 1):

    rowRange = range(1, n + 1)
    if column == math.ceil(m / 2) and m % 2 == 1:
        rowRange = range(1, math.ceil(n/2) + 1)

    for row in rowRange:
        result.append(str(column) + ' ' + str(row))
        if row == math.ceil(n/2) and n % 2 == 1 and column == math.ceil(m / 2) and m % 2 == 1:
            continue
        result.append(str(m + 1 - column) + ' ' + str(n + 1 - row))

print('\n'.join(result))
",quadratic,constructive algorithms,546
"
n, m = map(int, input().split())
buf = []
for i in range(n//2):
    for j in range(m):
        buf.append(f'{i + 1} {j + 1}\n')
        buf.append(f'{n - i} {m - j}\n')

if n % 2 == 1:
    for j in range(m // 2):
        buf.append(f'{n // 2 + 1} {j + 1}\n')
        buf.append(f'{n // 2 + 1} {m - j}\n')
    if m % 2 == 1:
        buf.append(f'{n//2 + 1} {m//2 + 1}\n')
print(*buf, sep='')",quadratic,constructive algorithms,391
"def main():
    n, m = map(int,raw_input().split())
    r = []
    rappend = r.append
    for i in range(1, (n >> 1) + 1):
        for j in range(1, m + 1):
            rappend(str(i) + ' ' + str(j))
            rappend(str(n + 1 - i) + ' ' + str(m + 1 - j))
    if n & 1:
        for i in range(1, (m >> 1) + 1):
            rappend(str((n + 1) >> 1) + ' ' + str(i))
            rappend(str((n + 1) >> 1) + ' ' + str(m + 1 - i))
        if m & 1:
            rappend(str((n + 1) >> 1) + ' ' + str((m + 1) >> 1))
    print('\n'.join(r))
main()",quadratic,constructive algorithms,543
"n, m = map(int, input().split())

np1 = n + 1
mp1 = m + 1

for i in range(1, 1 + n // 2):
  for j in range(1, mp1):
    # print(i, j)
    # print(np1 - i, mp1 - j)
    print('%d %d\n%d %d' % (i,j,np1-i,mp1-j))

if n & 1:
  i = 1 + n // 2
  for j in range(1, 1 + m // 2):
    # print(i, j)
    # print(i, mp1 - j)
    print('%d %d\n%d %d' % (i,j,i,mp1-j))

  if m & 1:
    print(i, 1 + m // 2)
",quadratic,constructive algorithms,393
"import sys
import math
from collections import defaultdict
n,m=map(int,sys.stdin.readline().split())
#cur=[1,1]
#ans=[-1 for _ in range(2*n*m)]
up,down=1,n
count=0
while up<=down:
    left,right=1,m
    #ans.append(cur)
    while left<=m and count<n*m:
        #ans.append([up,left])
        #ans[count]=[up,left]
        if count<n*m:
            sys.stdout.write((str(up)+"" ""+str(left)+""\n""))
        count+=1
        left+=1
        #ans[count]=[down,right]
        if count<n*m:
            sys.stdout.write((str(down)+"" ""+str(right)+""\n""))
        count+=1
            #ans.append([down,right])
        right-=1
    up+=1
    down-=1
'''if n==1:
    a=len(ans)
    #print(a,'a')
    for i in range(a//2):
        print(ans[i][0],ans[i][1])
else:
    a=len(ans)
    for i in range(a//2):
        print(ans[i][0],ans[i][1])
    #print(ans)'''
        
",quadratic,constructive algorithms,855
"#------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
#-------------------game starts now----------------------------------------------------
n,m=map(int,input().split())
s=0
e=n-1
for i in range(n//2):
    for j in range(m):
        print(s+1,j+1)
        print(e+1,m-j)
    s+=1
    e-=1
if n%2==1:
    s=n//2
    for j in range(m//2):
            print(s+1,j+1)
            print(s+1,m-j)
    if m%2==1:
            print(s+1,m//2+1)",quadratic,constructive algorithms,2165
"from sys import stdin, stdout

n,m = [int(x) for x in stdin.readline().split()]

if n == 2:
    c = 1
    way = []
    mult = 1
    for x in range(m-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(1, x)
    for x in way[::-1]:
        print(2,x)
        
elif n == 1:
    c = 1
    way = []
    mult = 1
    for x in range(m-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(1, x)

elif m == 2:
    c = 1
    way = []
    mult = 1
    for x in range(n-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(x,1)
    for x in way[:-1:-1]:
        print(x,2)

elif m == 1:
    c = 1
    way = []
    mult = 1
    for x in range(n-1,-1,-1):
        way.append(c)
        c += x*mult
        mult *= -1
    for x in way:
        print(x,1)
else:
    outStr = ''
    for x in range(n//2):
        for y in range(1,m+1):
            stdout.write(str(x+1) + ' ' + str(y)+'\n')
            stdout.write(str(n-x) + ' ' + str(m+1-y)+'\n')
    if n%2 == 1:
        c = 1
        way = []
        mult = 1
        for x in range(m-1,-1,-1):
            way.append(c)
            c += x*mult
            mult *= -1
        for x in way:
            stdout.write(str(n//2+1)+' ' + str(x)+'\n')




        
",quadratic,constructive algorithms,1349
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
for i in range(n//2+n%2):
    x1=i+1
    x2=n-i
    if(x1==x2):
        for j in range(m//2+m%2):
            if(j+1==m-j):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
            else:
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
    else:
        if(i%2==0):
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
        else:
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(m-j)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(j+1)+""\n""))",quadratic,constructive algorithms,746
"import sys
input=sys.stdin.buffer.readline
n,m=map(int,input().split())
for i in range(n//2+n%2):
    x1=i+1
    x2=n-i
    if(x1==x2):
        for j in range(m//2+m%2):
            if(j+1==m-j):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
            else:
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
    else:
        if(i%2==0):
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(j+1)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(m-j)+""\n""))
        else:
            for j in range(m):
                sys.stdout.write((str(x1)+"" ""+str(m-j)+""\n""))
                sys.stdout.write((str(x2)+"" ""+str(j+1)+""\n""))",quadratic,constructive algorithms,753
"import sys
def countR(ip):
    c=0
    for i in ip:
        if(i=='R'):
            c+=1
    return c
    
def countB(ip):
    c=0
    for i in ip:
        if(i=='B'):
            c+=1
    return c
    
def countG(ip):
    c=0
    for i in ip:
        if(i=='G'):
            c+=1
    return c
# sys.stdin.readline()
t=int(sys.stdin.readline())
x='RGB'*680
y='GBR'*680
z='BRG'*680
for i in range(t):
    n,k=list(map(int,sys.stdin.readline().strip().split()))
    a=sys.stdin.readline().strip()
    xk=x[:k]
    yk=y[:k]
    zk=z[:k]
    # print(k,xk,zk)
    # xc=[]
    # yc=[]
    # zc=[]
    # xc.append(countR(xk))
    # xc.append(countG(xk))
    # xc.append(countB(xk))
   
    # yc.append(countR(yk))
    # yc.append(countG(yk))
    # yc.append(countB(yk))
    
    # zc.append(countR(zk))
    # zc.append(countG(zk))
    # zc.append(countB(zk))
    op=2001
    for j in range(n-k+1):
        b=a[j:j+k]
        # print(len(b),xc,zc)
        # bc=[]
        
        # bc.append(countR(b))
        # bc.append(countG(b))
        # bc.append(countB(b))
        xd=0
        yd=0
        zd=0
        # print(a,b,xc,yc,zc,bc)
        for jj in range(len(b)):
            if(b[jj]!=xk[jj]):
                xd+=1
            if(b[jj]!=yk[jj]):
                yd+=1
            if(b[jj]!=zk[jj]):
                zd+=1
         # print(a,b,xd,yd,zd,z)
        op=min(op,xd,yd,zd)
    print(op)
    ",quadratic,implementation,1401
"def givestringsk(k):
    t=[""R"",""G"",""B""]
    ans=[]
    for i in range(3):
        temp=""""
        for j in range(i,i+k):
            temp+=t[j%3]
        ans.append(temp)
    return ans
def countdifferences(a,b):
    cnt=0
    for i in range(len(a)):
        if a[i]!=b[i]:cnt+=1
    return cnt
for _ in range(int(input())):
    n,k=list(map(int,input().split()))
    s=input()
    temp=givestringsk(k)
    ans=10000000000000
    for i in range(k,n+1):
        for j in range(3):
            ans=min(ans,countdifferences(s[i-k:i],temp[j]))
    print(ans)
    ",quadratic,implementation,560
"q = int(input())
for _ in range(q):
    n, k = map(int, input().split())
    s = input()
    ans = k
    sample = ""RGB""
    for i in range(n - k + 1):
        cnt = 0
        x = 0
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        #print(ans, 7)
        ans = min(ans, cnt)
        cnt = 0
        x = 1
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        ans = min(ans, cnt)
        #print(ans, 8)
        cnt = 0
        x = 2
        for j in range(i, i + k):
            if s[j] != sample[x]:
                cnt += 1
            x = (x + 1) % 3
        ans = min(ans, cnt) 
        #print(ans, 9)       
    print(ans)",quadratic,implementation,779
"def main():
    q = int(input())
    for i in range(q):
        n, k = map(int, input().split())
        s = input()
        min_ans = 10 ** 9
        for i in range(n - k + 1):
            count1 = 0
            count2 = 0
            count3 = 0
            for j in range(k):
                if (i + j) % 3 == 0:
                    if s[i + j] != ""R"":
                        count1 += 1
                    if s[i + j] != ""G"":
                        count2 += 1
                    if s[i + j] != ""B"":
                        count3 += 1
                if (i + j) % 3 == 1:
                    if s[i + j] != ""G"":
                        count1 += 1
                    if s[i + j] != ""B"":
                        count2 += 1
                    if s[i + j] != ""R"":
                        count3 += 1 
                if (i + j) % 3 == 2:
                    if s[i + j] != ""B"":
                        count1 += 1
                    if s[i + j] != ""R"":
                        count2 += 1
                    if s[i + j] != ""G"":
                        count3 += 1 
            min_ans = min(min_ans, count1, count2, count3)
        print(min_ans)
main()",quadratic,implementation,1163
"q = int(input())
b = []
for m in range(q):
    n, k = map(int, input().split())
    l = input()
    k1 = 'R'
    k2 = 'G'
    k3 = 'B'
    for i in range(1, k):
        if k1[i - 1] == 'R':
            k1 = k1 + 'G'
        if k1[i - 1] == 'G':
            k1 = k1 + 'B'
        if k1[i - 1] == 'B':
            k1 = k1 + 'R'
        if k2[i - 1] == 'R':
            k2 = k2 + 'G'
        if k2[i - 1] == 'G':
            k2 = k2 + 'B'
        if k2[i - 1] == 'B':
            k2 = k2 + 'R'
        if k3[i - 1] == 'R':
            k3 = k3 + 'G'
        if k3[i - 1] == 'G':
            k3 = k3 + 'B'
        if k3[i - 1] == 'B':
            k3 = k3 + 'R'
    minn = n
    #print(k1)
    #print(k2)
    #print(k3)
    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k1[j]:
                tec += 1
        if tec < minn: minn = tec
    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k2[j]:
                tec += 1
        if tec < minn: minn = tec
    for i in range(n - k + 1):
        tec = 0
        for j in range(k):
            if l[i + j] != k3[j]:
                tec += 1
                #print(l[i+j], k3[j])
        if tec < minn: minn = tec
    b.append(minn)
for i in range(q):
    print(b[i])
",quadratic,implementation,1307
"def user99():
    text = 'RGB' * 2222
    for _ in range(int(input())):
        n, k = map(int, input().split())
        s = input()
        ans = 2222
        for i in range(3):
            p = text[i: k + i]
            #print(""p = "", p)
            for j in range(n - k + 1):
                diff = 0
                #print(s[j: j + k], ""vs"", p)
                for l in range(j, j + k):
                    if s[l] != p[l - j]:
                        diff += 1
                ans = min(ans, diff)
        print(ans)

user99()
",quadratic,implementation,532
"R = lambda: map(int, input().split())
for _ in range(int(input())):
    n,k = R()
    s = input()
    p = (k+2)//2
    l = ""RGB""*p
    res = n
    for i in range(n-k+1):
        c = 0
        #print(l[0:k])
        for j in range(0,k):
            c += (s[i+j] != l[j])
        res = min(res,c)
        #print(c)
        c = 0
        #print(l[1:k+1])
        for j in range(1,k+1):
            c += (s[i+j-1] != l[j])
        res = min(res,c)
        #print(c)
        c = 0
        #print(l[2:k+2])
        for j in range(2,k+2):
            c += (s[i+j-2] != l[j])
        res = min(res,c)
        #print(c)
    print(res)",quadratic,implementation,625
"import math


class Read:
    @staticmethod
    def int():
        return int(input())

    @staticmethod
    def list(sep=' '):
        return input().split(sep)

    @staticmethod
    def list_int(sep=' '):
        return list(map(int, input().split(sep)))


def solve():
    n, k = Read.list_int()
    s = input()

    sf = 'RGB' * (k + 2)

    max_s = 0
    for i in range(n - k + 1):
        for j in range(3):
            count = 0
            for b in range(k):
                if sf[j + b] == s[i + b]:
                    count += 1
            if count > max_s:
                max_s = count

    print(k - max_s)


query_count = Read.int()
for j in range(query_count):
    solve()
",quadratic,implementation,692
"######################################################################
# Write your code here
import sys
input = sys.stdin.readline
#import resource
#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])
#sys.setrecursionlimit(0x100000)
# Write your code here
RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()
from collections import defaultdict as df
#import heapq 
#heapq.heapify(li) heappush(li,4) heappop(li)
import random
#random.shuffle(list)
infinite = float('inf')
#######################################################################

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n
    
    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0
        
        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0
        
        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0
        
        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",quadratic,implementation,1306
"from sys import stdin,stdout
input=stdin.readline
for _ in range(int(input())):
    x=10**5
    n,k=map(int,input().split())
    s=input()
    ans=10**9
    for i in range(n-k+1):
        x=s[i:i+k]
        m=0
        curr=['R','G','B']
        for l in range(3):
            m=0
            z=l
            for j in x:
                if j!=curr[z]:
                    m+=1
                z+=1
                z%=3
            ans=min(ans,m)
    print(ans)
            ",quadratic,implementation,473
"######################################################################
# Write your code here
import sys
input = sys.stdin.readline
#import resource
#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])
#sys.setrecursionlimit(0x100000)
# Write your code here
RI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]
rw = lambda : input().strip().split()
#from collections import defaultdict as df
#import heapq 
#heapq.heapify(li) heappush(li,4) heappop(li)
#import random
#random.shuffle(list)
infinite = float('inf')
#######################################################################

t=int(input())

for _ in range(t):
    n,k=RI()
    s=input()

    mini=n
    
    test=""RGB""*(k//3 + 5)
    for i in range(n-k+1):
        count=0
        
        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""GBR""*(k//3 + 5)
    for i in range(n-k+1):
        count=0
        
        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    test=""BRG""*(k//3 + 5)
    for i in range(n-k+1):
        count=0
        
        for j in range(k):
            if(s[i+j]!=test[j]):
                count+=1

        mini=min(count,mini)

    print(mini)
",quadratic,implementation,1308
"import sys
input = lambda: sys.stdin.readline().strip()
from math import ceil

def mismatch(s1, s2):
    cnt = 0
    for i in range(len(s1)):
        if s1[i]!=s2[i]: cnt+=1
    return cnt

T = int(input())
for _ in range(T):
    n, k = map(int, input().split())
    check = ''
    for i in range(ceil((k+2)/3)):
        check+='RGB'
    ls = []
    for i in range(3):
        ls.append(check[i:i+k])
    s = input()
    m = n
    for i in range(n-k+1):
        for j in ls:
            m = min(m, mismatch(s[i:i+k], j))
    print(m)
",quadratic,implementation,534
"T=int(input())
for _ in range(T):
    n,k=map(int,input().split())
    s=input()
    rq1=''
    rq2=''
    rq3=''

    for i in range(k):
        if(i%3==0):
            rq1=rq1+'R'
            rq2=rq2+'G'
            rq3=rq3+'B'
        elif(i%3==1):
            rq1=rq1+'G'
            rq2=rq2+'B'
            rq3=rq3+'R'
        elif(i%3==2):
            rq1=rq1+'B'
            rq2=rq2+'R'
            rq3=rq3+'G'

    ans=1000000000000000000

    for i in range(0,len(s)-k+1):

        a1=0
        a2=0
        a3=0

        for j in range(i,i+k):

            if(s[j]!=rq1[j-i]):
                a1+=1
            if(s[j]!=rq2[j-i]):
                a2+=1
            if(s[j]!=rq3[j-i]):
                a3+=1
        #print(a1,a2,a3,rq1,rq2,rq3)

        ans=min(ans,min(a1,a2,a3))

    print(ans)
            
            
    
            
        
",quadratic,implementation,859
"q=int(input())
for i in range(q):
	n,k=map(int,input().split())
	s=input()
	m=10**4
	for j in range(n):
		if j+k<=n:
			l1=[""R"",""G"",""B""]
			m1,m2,m3=0,0,0
			for i in range(j,j+k):
				if l1[(i-j)%3]!=s[i]:
					m1+=1
			for i in range(j,j+k):
				if l1[(i+1-j)%3]!=s[i]:
					m2+=1
			for i in range(j,j+k):
				if l1[(i+2-j)%3]!=s[i]:
					m3+=1
			m=min(m,m1,m2,m3)
		else:
			break
	print(m)",quadratic,implementation,395
"def gen(n, b):
	a = [(x + b) % 3 for x in range(n)]
	s = """"
	for i in range(n):
		if a[i] == 0:
			s += ""R""
		if a[i] == 1:
			s += ""G""
		if a[i] == 2:
			s += ""B""
	return s

q = int(input())
for _ in range(q):
	n, k = map(int, input().split())
	s = input()
	ans = n
	for xi in range(3):
		t = gen(n, xi)
		diff = 0
		for i in range(k):
			if s[i] != t[i]:
				diff += 1
		ans = min(ans, diff)
		for j in range(k, n):
			if s[j - k] != t[j - k]:
				diff -= 1
			if s[j] != t[j]:
				diff += 1
			ans = min(ans, diff)
	print(ans)",quadratic,implementation,529
"import sys
sss='RGB'*700
def check(ss,p):
    i=0
    m=10**5
    ans=0
    while i<len(p):
        if p[i]!=sss[i]:
            ans+=1
        i+=1
    m=min(m,ans)
    ans=0
    i=1
    while i<len(p)+1:
        if p[i-1]!=sss[i]:
            ans+=1
        i+=1
    m=min(m,ans)
    ans=0
    i=2
    while i<len(p)+2:
        if p[i-2]!=sss[i]:
            ans+=1
        i+=1
    m=min(m,ans)
    
    return m
    
        
for _ in range(int(input())):
    n,k=(list(map(int,sys.stdin.readline().split())))
    s=input()
    m=10**5
    for i in range(n-k+1):
        m=min(m,(check(sss,s[i:i+k])))
    print(m)    ",quadratic,implementation,622
"
import sys
input = sys.stdin.readline
q=int(input())
for i in range(q):
  n,k=map(int,input().split())
  s=input()
  a=k
  for j in range(n-k+1):
    a1,a2,a3=0,0,0
    for jj in range(k):
      if jj%3==0:
        if s[j+jj]==""R"":
          a2+=1
          a3+=1
        elif s[j+jj]==""G"":
          a1+=1
          a3+=1
        else:
          a1+=1
          a2+=1
      elif jj%3==1:
        if s[j+jj]==""R"":
          a1+=1
          a2+=1
        elif s[j+jj]==""G"":
          a2+=1
          a3+=1
        else:
          a3+=1
          a1+=1
      else:
        if s[j+jj]==""R"":
          a1+=1
          a3+=1
        elif s[j+jj]==""G"":
          a1+=1
          a2+=1
        else:
          a3+=1
          a2+=1
    a=min(a,a1,a2,a3)
  print(a)
      


",quadratic,implementation,768
"rgb = 'RGB' * 1000
for q in range(int(input())):
    n, k = [int(s) for s in input().split()]
    s = input()
    ans = 3000
    for w in range(3):
        for e in range(n - k + 1):
            temp = 0
            for i in range(k):
                if s[e + i] != rgb[w + i]:
                    temp += 1
            ans = min(ans, temp)
    print(ans)",quadratic,implementation,355
"N, M, K = map(int, input().split())
A = [int(a) for a in input().split()]
S = [0]
for a in A:
    S.append(S[-1]+M*a-K)
MI = [(10**50)] * M
ans = 0
for i in range(N+1):
    MI[i%M] = min(MI[i%M], S[i])
    for j in range(M):
        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)
print(ans)

",quadratic,"dp,greedy,math",296
"n,m,k=map(int,raw_input().split())#peutêtre très lourd en m
l=list(map(int,raw_input().split()))
ma=0
for deb in range(n-1,n-m-1,-1):
    cumi=0
    scu=0
    for i in range(deb,-1,-1):
        scu+=l[i]
        ma=max(ma,scu-cumi-k)#pour les chieux taille divisibel par k
        if (deb-i+1)%m==0:
            scu-=k
        if scu<cumi:
            cumi=scu

print(ma)
",quadratic,"dp,greedy,math",372
"n, m, k = map(int, input().split())
A = list(map(int, input().split()))
glans = 0
for s in range(m):
    B = []
    f = s
    su = 0
    sus = 0
    for i in range(s, n):
        su += A[i]
        sus = max(sus, su)
        if (i + 1) % m == s:
            B.append(sus - k)
            B.append(su - sus)
            su = 0
            sus = 0
            f = i + 1
    dob = 0
    klol = 0
    for j in range(f, n):
        dob += A[j]
        klol = max(klol, dob - k)
    B = [0] + B + [klol]
    for i in range(1, len(B)):
        B[i] += B[i - 1]
    cnt = -10 ** 10
    ans = [0, 0]
    minsum = 10 ** 10
    candidat = 0
    for i in range(len(B)):
        if B[i] - minsum > cnt:
            cnt = B[i] - minsum
            ans[1] = i
            ans[0] = candidat
        if B[i] <= minsum:
            minsum = B[i]
            candidat = i
    glans = max(glans, B[ans[1]] - B[ans[0]])
print(glans)",quadratic,"dp,greedy,math",911
"n,m,k = [int(w) for w in input().split()]
a = [int(w) for w in input().split()]

def f(o):
    r = e = 0
    for i, x in enumerate(a):
        if i < o:
            continue
        if i % m == o:
            e -= k
            if e < -k:
                e = -k
        e += x
        if e > r:
            r = e
    return r

print(max(f(o) for o in range(m)))
",quadratic,"dp,greedy,math",362
"import math

n, m, k = list(map(int, input().split()))
arr = list(map(int, input().split()))

part_sum = [0]
for i in range(n):
	part_sum.append(part_sum[-1] + arr[i])

# print(part_sum)

part_sum_add = [[] for _ in range(m)]
min_in_part_sum_add = [[] for _ in range(m)]
for shift in range(m):
	count_blocks = math.ceil((n - shift) / m + 1)
	for i in range(n + 1):
		cur_part_sum = part_sum[i] + k * (count_blocks - ((i - shift) // m))
		if i == 0 or cur_part_sum < prev_min_in_part_sum_add:
			cur_min_in_part_sum_add = cur_part_sum
		else:
			cur_min_in_part_sum_add = prev_min_in_part_sum_add

		# cur_min_in_part_sum_add = part_sum_add[shift][-1] if i == 0 else min(part_sum_add[shift][-1], min_in_part_sum_add[shift][-1])
		part_sum_add[shift].append(cur_part_sum)
		min_in_part_sum_add[shift].append(cur_min_in_part_sum_add)
		prev_min_in_part_sum_add = cur_min_in_part_sum_add
	# print(shift, part_sum_add[shift], min_in_part_sum_add[shift])

max_result = 0
for i in range(1, n + 1):
	current_shift = i % m
	current_min = min_in_part_sum_add[current_shift][i]
	current_ans = part_sum_add[current_shift][i] - current_min
	# print('[{}] shift={} min={} ans={}'.format(i, current_shift, current_min, current_ans))
	if current_ans > max_result:
		max_result = current_ans

print(max_result)",quadratic,"dp,greedy,math",1293
"import sys

n, m, k = list(map(int, sys.stdin.readline().strip().split()))
a = list(map(int, sys.stdin.readline().strip().split()))
b = [0] * (n+1)
for i in range (1, n+1):
    b[i] = b[i-1] + m * a[i-1] - k
M = [10 ** 20] * m
ans = 0
for i in range (0, n+1):
    M[i % m] = min([M[i % m], b[i]])
    for j in range (0, m):
        if i > j:
            ans = max([ans, b[i]-M[j]-k*((m*i+m-(i-j))%m)])
    # print(j, M, ans)
print(ans // m)
",quadratic,"dp,greedy,math",441
"N, M, K = map(int, raw_input().split())
A = [int(a) for a in raw_input().split()]
S = [0]
for a in A:
    S.append(S[-1]+M*a-K)
MI = [(10**50)] * M
ans = 0
for i in range(N+1):
    MI[i%M] = min(MI[i%M], S[i])
    for j in range(M):
        ans = max(ans, (S[i]-MI[(i-j)%M] - K*((-j)%M))//M)
print(ans)
 ",quadratic,"dp,greedy,math",304
"import sys
input = sys.stdin.readline
from itertools import accumulate
import copy

n,m,k = map(int,input().split())
A = list(map(int,input().split()))
ANS = 0

for i in range(m):
    B = copy.deepcopy(A)

    for j in range(i,n,m):
        B[j] -= k

    SUM = list(accumulate(B))
    SUMMIN = [float(""inf"")]*n +[0]

    if i==0:
        SUMMIN[0] = 0

    for j in range(max(1,i),n):
        if j % m == i % m:
            SUMMIN[j] = min(SUMMIN[j-1],SUM[j-1])
        else:
            SUMMIN[j] = SUMMIN[j-1]

    for j in range(i,n):
        ANS = max(ANS,SUM[j] - SUMMIN[j])

print(ANS)

    
    
",quadratic,"dp,greedy,math",604
"import sys
input = sys.stdin.readline
n,m,k=map(int,input().split())
A=[int(i) for i in input().split()]
if n<=m:
  AA=[0]*(n+1)
  for i in range(n):
    AA[i+1]=AA[i]+A[i]
  mm=0
  for i in range(n+1):
    for j in range(i+1,n+1):
      mm=max(mm,AA[j]-AA[i]-k)
else:
  DP=[[0]*(m+1) for _ in range(n+1)]
  for i in range(n):
    a=A[i]
    DP[i+1][0]=max([DP[i][0],DP[i][m],DP[i][m]+a-k,DP[i][1]])
    DP[i+1][1]=max(a-k,DP[i][m]+a-k)
    for j in range(2,m+1):
      DP[i+1][0]=max(DP[i+1][0],DP[i][j])
      if j>i+1:
        continue
      else:
        DP[i+1][j]=max(DP[i][j-1]+a,DP[i][m]+a-k)
print(max(A[0]-k,0) if n==1 else mm if n<=m else max(0,max(DP[n])))
",quadratic,"dp,greedy,math",669
"import copy

n,m,k=map(int,input().split())
A=list(map(int,input().split()))

ANS=0

for i in range(m):
    B=copy.deepcopy(A)
    for j in range(i,n,m):
        B[j]-=k

    NOW=0

    for j in range(i,n):
        if j%m==i:
            NOW=max(NOW+B[j],B[j])
        else:
            NOW+=B[j]

        ANS=max(ANS,NOW)

print(ANS)
        
    
",quadratic,"dp,greedy,math",349
"from sys import stdin, stdout, exit

n, m, k = map(int, stdin.readline().split())
a = list(map(int, stdin.readline().split()))

def bf(a):
    best = 0
    best_arg = (-1, -1)
    for i in range(n):
        for j in range(i, n):
            cur = sum(a[i:j+1]) - k*((j - i) // m + 1)
            if cur > best:
                best = max(best, cur)
                best_arg = (i,j)
    return best, best_arg

def max_sum(a):
    if len(a) == 0:
        return 0
    elif len(a) == 1:
        return max(0, a[0] - k)
    mid = len(a) // 2
    l_rec = max_sum(a[:mid])
    r_rec = max_sum(a[mid:])
    l_bests = [0]*m
    r_bests = [0]*m
    l_sum = 0
    for idx in range(1,mid+1):
        l_sum += a[mid-idx]
        if idx % m == 0:
            l_sum -= k
        l_bests[idx%m] = max(l_bests[idx%m], l_sum)
    r_sum = 0
    for idx in range(0, len(a)-mid):
        r_sum += a[idx+mid]
        if (idx+1) % m == 0:
            r_sum -= k
        r_bests[(idx+1)%m] = max(r_bests[(idx+1)%m], r_sum)

 #   print(""Array:"", a, ""mid:"", mid)
#    print(l_bests)
  #  print(r_bests)
    best_acr = 0
    for i in range(m):
        for j in range(m):
            best_acr = max(best_acr, l_bests[i] + r_bests[j] - (k if i+j>0 else 0) - (k if i+j>m else 0))
    ans = max(l_rec,r_rec, best_acr)
   # print(""Answer:"", ans)
    return ans


ans = max_sum(a)
stdout.write(str(ans) + ""\n"")
#stdout.write(str(bf(a))+""\n"")
",quadratic,"dp,greedy,math",1410
"n, m, k = [int(i) for i in input().split()]
A = [int(i) for i in input().split()]

bestbest = 0

def brute(n, m, k, A):
    ans = 0
    val = (0, 0)
    for i in range(n):
        for j in range(i, n):
            if ans < sum(A[i:j+1]) - k*(ceil((j-i+1)/m)):
                ans = sum(A[i:j+1]) - k*(ceil((j-i+1)/m))
                val = (i, j)
    return val, ans

for off in range(m):
    B = A[off:]
    C = []
    canstart = []
    for i in range(len(B)):
        if i%m == 0:
            C.append(-k)
            canstart.append(1)
        canstart.append(0)
        C.append(B[i])

    best = 0
    run = 0

    for i in range(len(C)):
        run += C[i]
        if run < -k:
            run = -k
        best = max(best, run)
    #print(best, C)
    bestbest = max(bestbest, best)

print(bestbest)
",quadratic,"dp,greedy,math",808
"def max_subarray(A):
    max_ending_here = max_so_far = A[0]
    for x in A[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
 
ans = 0
n, m, k = map(int, input().split())
a = list(map(int, input().split()))
for i in range(m):
    li = a[0:i] + [-k]
    s = 0
    while True:
        li += a[i+s:min(i+m+s, len(a))]
        li += [-k]
        if i+m+s >= len(a):
            break
        s += m
    ans = max(max_subarray(li) - k,ans)
print(ans)

",quadratic,"dp,greedy,math",533
"
if __name__ == '__main__':
    n, m, k = map(int, input().split())
    aa = list(map(int,input().split()))
    ans = 0
    for start in range(m):
        ac = aa[:]
        for i in range(start, n, m):
            ac[i] -= k
        cur = 0
        for i in range(start, n):
            if i%m == start:
                cur = max(ac[i] + cur, ac[i])
            else:
                cur += ac[i]
            ans = max(cur, ans)
    print(ans)
",quadratic,"dp,greedy,math",445
"# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!
from sys import stdin, stdout
import collections
 
#T = int(input())
 
#W,H = [int(x) for x in stdin.readline().split()]
#arr = [int(x) for x in stdin.readline().split()]
 
#s = input()
#N = len(s)
 
N,M,K = [int(x) for x in stdin.readline().split()]
arr = [int(x) for x in stdin.readline().split()]
 


res = 0
for j in range(M):
    s = 0
    mini = 0
    for i in range(j,N):
        if i%M==j:
            mini = min(mini,s)
            s -= K
        
        s += arr[i]
        
        res = max(res,s-mini)
        
print(res)

",quadratic,"dp,greedy,math",849
"base = 1000000007
n , m , k = map(int,input().split())
a = list(map(int,input().split()))
mx = 0
s = 0
dp = []
dd= []
for j in range(m):
    for i in range(n+1):
        dp.append(base)
        dd.append(0)
    for i in range(n):
        dd[i+1]=dd[i]+a[i]-k*(i % m== j)
        dp[i+1] = min(dd[i],dp[i])
        #print(dd)
        #print(dp)
        if (i % m == j):
            mx = max ( mx , dd[i+1]-dp[i+1])
print(mx)",quadratic,"dp,greedy,math",423
"'''input
5 3 10
1 2 10 2 3
'''
import math
def max_sub(arr,n):
	dp = [0]*n
	dp[0] = arr[0]
	for i in range(1,n):
		dp[i] = max(dp[i-1]+arr[i],arr[i])
	return max(0,max(dp))
n,m,k = map(int,input().split())
arr = list(map(int,input().split()))
q = -math.inf
dp = [0]*(300100)
for i in range(300100):
	dp[i] = [q]*(11)
if (m==1):
	for i in range(n):
		arr[i]= arr[i]-k
	print(max_sub(arr,n))
else:
	for i in range(n):
		dp[i][1] = arr[i]-k
		for j in range(m):
			if (i-1<0 or dp[i-1][j]==q):
				continue
			if ((j+1)%m!=1):
				dp[i][(j+1)%m] = dp[i-1][j]+arr[i]
			else:
				dp[i][(j+1)%m] = max(arr[i]-k,dp[i-1][j]+arr[i]-k)
	ma=0
	for i in range(n):
		# s = """"
		for j in range(m):
			# s+=str(dp[i][j])+"" ""
			ma = max(ma,dp[i][j])
		# print(s)
	print(ma)",quadratic,"dp,greedy,math",759
"N, M, K = map(int, input().split())
A = list(map(int, input().split()))
bv = 0
for ms in range(M):
    cv = 0
    for i in range(ms, N):
        v = A[i]
        if i % M == ms:
            v -= K
            cv = max(0, cv)
        cv += v
        bv = max(bv, cv)
print(bv)
",quadratic,"dp,greedy,math",276
"#Bhargey Mehta (Junior)
#DA-IICT, Gandhinagar
import sys, math, queue
#sys.stdin = open('input.txt', 'r')
MOD = 998244353
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
a = list(map(int, input().split()))

dp = [[-10**20 for i in range(m)] for i in range(n)]
dp[0][0] = a[0]-k

for i in range(1, n):
	for j in range(m):
		if j == 0:
			dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k
		else:
			dp[i][j] = dp[i-1][j-1]+a[i]

ans = 0
for i in range(n):
	ans = max(ans, max(dp[i]))
print(ans)",quadratic,"dp,greedy,math",505
"#Bhargey Mehta (Junior)
#DA-IICT, Gandhinagar
import sys, math, queue
#sys.stdin = open('input.txt', 'r')
MOD = 998244353
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
a = list(map(int, input().split()))

dp = [[-10**20 for i in range(m)] for i in range(n)]

for i in range(n):
    for j in range(min(m, i+1)):
        if j == 0:
            dp[i][j] = max(dp[i-1][m-1]+a[i], a[i])-k
        else:
            dp[i][j] = dp[i-1][j-1]+a[i]

ans = 0
for i in range(n):
	ans = max(ans, max(dp[i]))
print(ans)",quadratic,"dp,greedy,math",527
"n, m, k = map(int, input().split())
a = list(map(int, input().split()))
sa = [0]*n

ans = 0

for i in range(n):
    sa[i] = a[i] - k
    s = a[i]
    for j in range(i-1, max(-1, i-m-1), -1):
        sa[i] = max(sa[i], sa[j] + s - k)
        s += a[j]
    if i < m:
        sa[i] = max(sa[i], s - k)
    sa[i] = max(sa[i], 0)
    ans = max(ans, sa[i])

print(ans)
",quadratic,"dp,greedy,math",363
"n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))
ret = 0
for i in range(m):
	cur = 0
	for j in range(i, n):
		if j % m == i:
			cur = max(0, cur)
			cur -= k
		cur += a[j]
		ret = max(ret, cur)
print(ret)",quadratic,"dp,greedy,math",233
"n,m,k = list(map(int,input().split()))
a = list(map(int,input().split()))
dp = [[float('-inf')]*m for i in range(n)]
dp[0][0] = a[0]
for i in range(1,n):
    for j in range(1,m):
        dp[i][j] = dp[i-1][j-1] + a[i]
    dp[i][0] = max(dp[i-1][m-1]-k, 0)+a[i]
        #if dp[i-1][j] != float()
print(max(max([max(x) for x in dp])-k,0))    ",quadratic,"dp,greedy,math",340
"n, m, k = list(map(int, input().split()));
a = list(map(int, input().split()));

values = list()

for j in range(n):
    result = a[j];
    sum1 = 0;
    for i in range(m):
        if j-i>=0:
            sum1 = sum1 + a[j-i];
            if sum1 > result:
                result = sum1;
        else:
            continue;
    if j-m>=0:
        result = max(result, sum1 + values[j-m]);
    values.append(max(0, result-k));
print(max(values));
",quadratic,"dp,greedy,math",445
"n, m, k = map(int, input().strip().split())

a = list(map(int, input().strip().split()))
a = [0] + a
dp = [0] * 300005
ans = 0
for i in range(1, n + 1):
    a[i] += a[i - 1]
    for j in range(1, m + 1):
        if i - j >= 0:
            dp[i] = max(dp[i], a[i] - a[i - j] - k)
    if i - m >= 0:
        dp[i] = max(dp[i], a[i] - a[i - m] + dp[i - m] - k)
    ans = max(ans, dp[i])

print(ans)
",quadratic,"dp,greedy,math",396
"n, m, k = map(int, input().split())

a = list(map(int, input().split()))

best = 0
dp = [0] * (n + 1)
for i in range(n):
    b2 = 0
    for j in range(max(-1, i - m), i + 1):
        b2 = max(b2, dp[j] - k + sum(a[j + 1:i + 1]))
    dp[i] = max(b2, a[i] - k)
    best = max(best, dp[i])

print(best)
# print(dp)
",quadratic,"dp,greedy,math",312
"from math import *
n,m,k = map(int,input().split())
l = list(map(int,input().split()))
a = [0 for i in range(n+1)]
ans = 0
for M in range(m):
    min1 = 0
    for i in range(1,n+1):
        a[i] = a[i-1] + l[i-1]
        if(i % m == M):
            a[i] -= k
            ans = max(ans,a[i]-min1)
        min1 = min(min1,a[i])
    #print(a)
print(ans)
",quadratic,"dp,greedy,math",351
"n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))
ret = 0
for i in range(m):
	cur = 0
	for j in range(i, n):
		if j % m == i:
			cur = max(0, cur)
			cur -= k
		cur += a[j]
		ret = max(ret, cur)
print(ret)
",quadratic,"dp,greedy,math",234
"n, m, k = map(int, input().split())
*a, = map(int, input().split())
dp = [-1] * (n + 15)
for i in range(n):
    s, mx = a[i], max(0, a[i])
    for j in range(i - 1, max(-1, i - m), -1):
        s += a[j]
        mx = max(mx, s)
    dp[i] = max(0, dp[i - m] + s - k, mx - k)
print(max(dp))",quadratic,"dp,greedy,math",288
"from itertools import accumulate
n,m,k = map(int,input().split())
a = list(map(int,input().split()))
als = []
for i in range(m):
  ls = a[:]
  for j in range(n):
    if j%m == i:
      ls[j] -= k
  als.append(list(accumulate(ls)))
ans = 0
for i in range(m):
  ls = als[i]
  mn = 0
  anstmp = 0
  for j in range(n):
    if mn > ls[j]:
      mn = ls[j]
    if j%m == i:
      anstmp = max(anstmp,ls[j]-mn)
  ans = max(ans,anstmp)
print(ans)",quadratic,"dp,greedy,math",438
"n = int(input())
A = list(map(int, input().split()))
A.sort()
B = [0] * n
ans = 0
for i in range(n):
    if B[i] == 0:
        ans += 1
        B[i] = 1
        for j in range(n):
            if A[j] % A[i] == 0:
                B[j] = 1
print(ans)",quadratic,"greedy,implementation,math",248
"n = int(input())
a = sorted(map(int , input().split()))
ans = 0
for i in range(n):
    f = 1
    for j in range(i):
        if a[i] % a[j] == 0:
            f = 0
            break
    ans += f
print(ans)",quadratic,"greedy,implementation,math",204
"import sys

def read():
	return sys.stdin.readline()

def main():
	n = int(read())
	a = list(map(int, read().split()))
	a.sort()
	k = 0
	used = [0] * n
	for i in range(n):
		if used[i]:
			continue
		k += 1
		for j in range(i, n):
			if a[j] % a[i] == 0:
				used[j] = True
	print(k)
	
if __name__ == '__main__':
	main()
",quadratic,"greedy,implementation,math",321
"n=int(input())
l1=list(map(int,input().split()))
ans=0
l1.sort()
visited=[0]*n
for i in range(n):
    if visited[i]==1:
        continue
    visited[i]=1
    ans+=1
    for j in range(i+1,n):
        if visited[j]==0 and l1[j]%l1[i]==0:
            visited[j]=1
print(ans)",quadratic,"greedy,implementation,math",272
"def main():
    import sys
    input = sys.stdin.readline
    
    n = int(input())
    arr = list(map(int, input().split()))
    color = [0] * n
    arr.sort()
    
    ans = 0
    for i in range(n):
        if color[i]:
            continue
        ans += 1
        for j in range(i, n):
            if arr[j] % arr[i] == 0:
                color[j] = ans
    
    print(ans)
    
    return 0

main()
",quadratic,"greedy,implementation,math",404
"n = int(input())
A = list(map(int, input().split()))
A.sort()
ans = 1
for i in range(1, n):
  ok = False
  for j in range(i):
    if A[i] % A[j] == 0:
      ok = True
  if not ok:
    ans += 1
print(ans)
",quadratic,"greedy,implementation,math",204
"n = int(input())
a = sorted(list(map(int, input().split())))
s = []
for q in a:
    for q1 in s:
        if q % q1 == 0:
            break
    else:
        s.append(q)
print(len(s))
",quadratic,"greedy,implementation,math",183
"#!usr/bin/env python3
from collections import defaultdict,deque
from heapq import heappush, heappop
import sys
import math
import bisect
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def LS():return [list(x) for x in sys.stdin.readline().split()]
def S():
    res = list(sys.stdin.readline())
    if res[-1] == ""\n"":
        return res[:-1]
    return res
def IR(n):
    return [I() for i in range(n)]
def LIR(n):
    return [LI() for i in range(n)]
def SR(n):
    return [S() for i in range(n)]
def LSR(n):
    return [LS() for i in range(n)]

sys.setrecursionlimit(1000000)
mod = 1000000007

#A
def A():
    n = I()
    a = LI()
    a.sort()
    f = [1]*n
    p = 0
    ans = 0
    while p < n:
        while p < n and not f[p]:
            p += 1
        if p == n:
            break
        ans += 1
        for i in range(n):
            if a[i]%a[p] == 0:
                f[i] = 0
    print(ans)
    return

#B
def B():

    return

#C
def C():

    return

#D
def D():

    return

#E
def E():

    return

#F
def F():

    return

#G
def G():

    return

#H
def H():

    return

#Solve
if __name__ == ""__main__"":
    A()
",quadratic,"greedy,implementation,math",1191
"from bisect import *
from collections import *
from itertools import *
import functools
import sys
import math
from decimal import *
from copy import *
from heapq import *
getcontext().prec = 30
MAX = sys.maxsize
MAXN = 10**5+10
MOD = 10**9+7
def isprime(n):
    n = abs(int(n))
    if n < 2:
        return False
    if n == 2: 
        return True    
    if not n & 1: 
        return False
    for x in range(3, int(n**0.5) + 1, 2):
        if n % x == 0:
            return False
    return True

def mhd(a,b):
    return abs(a[0]-b[0])+abs(b[1]-a[1])

def charIN(x= ' '):
    return(sys.stdin.readline().strip().split(x))

def arrIN(x = ' '):
    return list(map(int,sys.stdin.readline().strip().split(x)))

def eld(x,y):
    a = y[0]-x[0]
    b = x[1]-y[1]
    return (a*a+b*b)**0.5

def lgcd(a):
    g = a[0]
    for i in range(1,len(a)):
        g = math.gcd(g,a[i])
    return g

def ms(a):
    msf = -MAX
    meh = 0
    st = en = be = 0
    for i in range(len(a)):
        meh+=a[i]
        if msf<meh:
            msf = meh
            st = be
            en = i
        if meh<0:
            meh = 0
            be = i+1
    return msf,st,en

def ncr(n,r):
    num=den=1
    for i in range(r):
        num = (num*(n-i))%MOD
        den = (den*(i+1))%MOD

    return (num*(pow(den,MOD-2,MOD)))%MOD



def flush():
    return sys.stdout.flush()


def fac(n):
    ans = 1
    for i in range(1,n+1):
        ans*=i
        ans%=MOD
    return ans

'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''
n = int(input())
a = arrIN()
a.sort()
f = [1]*n
cnt = 0
for i in range(n):
    if f[i]:
        cnt+=1
        for j in range(i,n):
            if f[j] and a[j]%a[i]==0:
                f[j] = 0
        f[i] = 0
print(cnt)



",quadratic,"greedy,implementation,math",1768
"n=int(input())
a=[int(i) for i in input().split()]
a.sort()
tot = 0
d={}
for i in range(len(a)):
    if a[i] not in d:
        tot+=1
        for j in range(i+1,len(a),1):
            if a[j]%a[i] == 0:
                d[a[j]]=1
print(tot)",quadratic,"greedy,implementation,math",239
"n = int(input())

a = list(map(int, input().split()))

a.sort(reverse=True)

cnt = 0
while a:
    f = a.pop()
    rm = []
    for x in a:
        if x % f == 0:
            rm.append(x)
    for x in rm:
        a.remove(x)
    cnt += 1

print(cnt)
",quadratic,"greedy,implementation,math",248
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))

A.sort()

ANS=[0]*n

NOW=1
for i in range(n):
    if ANS[i]==0:
        ANS[i]=NOW

        for j in range(i,n):
            if A[j]%A[i]==0 and ANS[j]==0:
                ANS[j]=NOW

        NOW+=1

print(max(ANS))
",quadratic,"greedy,implementation,math",304
"# @author 

import sys

class APaintTheNumbers:
    def solve(self):
        n = int(input())
        a = [int(_) for _ in input().split()]
        a.sort()
        ans = 0
        done = [0] * n
        for i in range(n):
            if done[i]: continue
            ans += 1
            for j in range(i, n):
                if done[j]: continue
                if a[j] % a[i] == 0:
                    done[j] = 1

        print(ans)

solver = APaintTheNumbers()
input = sys.stdin.readline

solver.solve()
",quadratic,"greedy,implementation,math",509
"#    !/usr/bin/env python3
#    encoding: UTF-8
#    Modified: <14/Sep/2019 06:38:41 PM>


#    ✪ H4WK3yE乡
#    Mohd. Farhan Tahir
#    Indian Institute Of Information Technology (IIIT), Gwalior


import sys
import os
from io import IOBase, BytesIO


def main():
    n = int(input())
    arr = get_array()
    arr.sort()
    tmp = [-1] * n
    c = 1
    for i in range(n):
        if tmp[i] != -1:
            continue
        x = arr[i]
        for j in range(i, n):
            if arr[j] % x == 0:
                tmp[j] = c
        c += 1

    print(c - 1)


BUFSIZE = 8192


class FastIO(BytesIO):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.writable = ""x"" in file.mode or ""w"" in file.mode
        self.write = super(FastIO, self).write if self.writable else None

    def _fill(self):
        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])
        return s

    def read(self):
        while self._fill():
            pass
        return super(FastIO, self).read()

    def readline(self):
        while self.newlines == 0:
            s = self._fill()
            self.newlines = s.count(b""\n"") + (not s)
        self.newlines -= 1
        return super(FastIO, self).readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.getvalue())
            self.truncate(0), self.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        py2 = round(0.5)
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        if py2 == 1:
            self.write = self.buffer.write
            self.read = self.buffer.read
            self.readline = self.buffer.readline
        else:
            self.write = lambda s: self.buffer.write(s.encode(""ascii""))
            self.read = lambda: self.buffer.read().decode(""ascii"")
            self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def get_array():
    return list(map(int, sys.stdin.readline().split()))


def get_ints():
    return map(int, sys.stdin.readline().split())


def input():
    return sys.stdin.readline().strip()


if __name__ == ""__main__"":
    main()
",quadratic,"greedy,implementation,math",2390
"n = int(input())
l = sorted(map(int, input().split()))
seen = [False] * n
res = 0
for i in range(n):
    if seen[i]: continue
    res += 1
    for j in range(i, n):
        seen[j] |= l[j] % l[i] == 0
print(res)",quadratic,"greedy,implementation,math",211
"n = int(input())
a = list(map(int, input().split()))

a = sorted(a)
ans = 0
b = [0] * n
for i in range(n):
    if b[i] == 0:
        ans += 1
        for j in range(i, n):
            if a[j] % a[i] == 0:
                b[j] = 1
print(ans)
",quadratic,"greedy,implementation,math",241
"def solve(n, a):
    a = sorted(a)
    col = [False for i in range(n)]
    count = 0
    for i in range(n):
        if not col[i]:
            count += 1
            col[i] = True
            for j in range(n):
                if a[j] % a[i] == 0:
                    col[j] = True
    return count
    
n = int(input())
a = list(map(int, input().split()))
print(solve(n, a))",quadratic,"greedy,implementation,math",375
"import sys
input = sys.stdin.readline

n = int(input())
a = sorted(list(set(map(int, input().split()))))
n = len(a)
used = [0] * n
cnt = 0
for i in range(n):
    if not used[i]:
        used[i] = 1
        cnt += 1
        for j in range(i + 1, n):
            if a[j] % a[i] == 0:
                used[j] = 1
print(cnt)
",quadratic,"greedy,implementation,math",321
"n = int(input())
a = [int(i) for i in input().split()]
a.sort()
count = 0
for i in range(n):
    cur_c = a[i]
    if not cur_c:
        continue
    count += 1
    for j in range(i+1,n):
        if a[j]%cur_c == 0:
            a[j] = 0
print(count)",quadratic,"greedy,implementation,math",248
"#JMD
#Nagendra Jha-4096

 
import sys
import math

#import fractions
#import numpy
 
###File Operations###
fileoperation=0
if(fileoperation):
    orig_stdout = sys.stdout
    orig_stdin = sys.stdin
    inputfile = open('W:/Competitive Programming/input.txt', 'r')
    outputfile = open('W:/Competitive Programming/output.txt', 'w')
    sys.stdin = inputfile
    sys.stdout = outputfile

###Defines...###
mod=1000000007
 
###FUF's...###
def nospace(l):
    ans=''.join(str(i) for i in l)
    return ans
 
 
 
##### Main ####
t=1
for tt in range(t):
    n=int(input())
    #n,k,s= map(int, sys.stdin.readline().split(' '))
    a=list(map(int,sys.stdin.readline().split(' ')))
    a.sort()

    i=0
    ans=0
    while i<len(a):
        if a[i]:
            ans+=1
            j=i+1
            while j<n:
                if(a[j]%a[i]==0):
                    a[j]=0
                j+=1
        i+=1
    print(ans)
    
    
#####File Operations#####
if(fileoperation):
    sys.stdout = orig_stdout
    sys.stdin = orig_stdin
    inputfile.close()
    outputfile.close()",quadratic,"greedy,implementation,math",1068
"n = int(input())
a = list(map(int, input().split()))
a.sort()
ans = 0
u = [0] * (n+1)
for i in range(n):
    if u[i] == 0:
        ans+=1
    for j in range(i, n):
        if a[j] % a[i] == 0:
            u[j] = 1
print(ans)",quadratic,"greedy,implementation,math",224
"n=int(input())
l=list(map(int,input().split()))
l.sort()
v=[False for i in range(n)]
ans=0
i=0
while i<n:
	if v[i]==False:
		ans+=1
		for j in range(i+1,n):
			if l[j]%l[i]==0:
				v[j]=True
	i+=1
print(ans)",quadratic,"greedy,implementation,math",207
"'''input
6
10 2 3 5 4 2


'''
import sys
from collections import defaultdict as dd

mod=10**9+7

def ri(flag=0):
	if flag==0:
		return [int(i) for i in sys.stdin.readline().split()]
	else:
		return int(sys.stdin.readline())


n = ri(1)
a= ri()

b= sorted(a)
c= dd(int)


ans = 0
val=0
for i in range(n):
	if c[b[i]]==0:
		val+=1
		for j in range(n):
			if b[j]%b[i]==0:
				c[b[j]]=val

for i in c:
	ans = max(ans , c[i])

print(ans)

",quadratic,"greedy,implementation,math",435
"#!/usr/bin/python3

n = int(input())
a = list(set(map(int, input().split())))
n = len(a)

cnt = 0
for i in range(n):
    f = True
    for j in range(n):
        if i == j:
            continue
        if a[i] % a[j] == 0:
            f = False
    if f:
        cnt += 1

print(cnt)
",quadratic,"greedy,implementation,math",283
"n = int(input())
a = list(map(int, input().split()))

a.sort()
ans = 0
while a:
	m = a[0]
	b = []
	for x in a[1:]:
		if x % m != 0:
			b.append(x)
	a = b
	ans += 1
print(ans)",quadratic,"greedy,implementation,math",174
"n = int(input())
data = [int(i) for i in input().split()]
data.sort()
ans = [0]*n
col = 0
for i in range(n):
    if ans[i] == 0:
        col += 1
        ans[i] = 1
        d = data[i]
        for j in range(i+1, n):
            if data[j] % d == 0:
                ans[j] = 1
print(col)
        
",quadratic,"greedy,implementation,math",297
"n = int(input())
l = [int(i) for i in input().split()]
l.sort()
s = set([l[0]])
res = 1
for i in l:
    f = 1
    for j in s:
        if(i%j == 0):
            f = 0
            break
    if(f):
        s.add(i)
        res += 1
print(res)",quadratic,"greedy,implementation,math",239
"n=int(input())
a=sorted([int(x) for x in input().split()])
counter=0
test=[False]*n
for j in range(n):
    if not test[j]:
        for i in range(n):
            if not test[i] and a[i]%a[j]==0:
                test[i]=True
        counter+=1
print(counter)
            
",quadratic,"greedy,implementation,math",271
"n=int(input())
l=list(map(int,input().split()))
l.sort()
vis=[0]*n
ans=0
for i in range(n):
    if(vis[i]==0):
        ans+=1
        x=l[i]
        for j in range(n):
            if l[j]%x==0:
                vis[j]=1
print(ans)",quadratic,"greedy,implementation,math",229
"n = int(input())
a = list(map(int, input().split()))
a.sort()
ans = 0
while len(a) > 0:
    k = a.pop(0)
    a = [i for i in a if i % k != 0]
    ans += 1

print(ans)
",quadratic,"greedy,implementation,math",167
"n = int(input())
a = list(map(int, input().split()))
a.sort()
k = 0
for i in range(n) :
    if a[i] :
        k += 1
        for j in range(i + 1, n) :
            if a[j] and a[j] % a[i] == 0 :
                a[j] = 0
print(k)",quadratic,"greedy,implementation,math",228
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)
",quadratic,"combinatorics,dp,math",499
"print(k[n]%m)""",quadratic,"combinatorics,dp,math",14
"from sys import stdin
from math import factorial

n, mod = map(int, stdin.readline().split())

def binom(n, m):
    return factorial(n) // factorial(m) // factorial(n-m)

def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):
        sign = 1 if (i-k)%2 == 0 else -1
        ans += sign * binom(k, i) * (i**x)
        ans %= mod
    return ans

def f(x, k):
    return (foo(x, k) * pow(2, x-k, mod)) % mod

ans = 0
for i in range((n+1)//2):
    ans = (ans + f(n-i, i+1))
    ans %= mod
print(ans)",quadratic,"combinatorics,dp,math",498
"import sys
input = sys.stdin.readline

def main():
    n = int(input())
    alst = [int(input()) for _ in range(n)]
    ans = []
    for a in alst:
        if a == 1:
            ans.append(""1"")
            print(""."".join(ans))
            continue
        while ans and int(ans[-1]) != a - 1:
            ans.pop()
        if not ans:
            ans.append(str(a))
        else:
            ans.pop()
            ans.append(str(a))
        
        print(""."".join(ans))
        
    
for _ in range(int(input())):
    main()",quadratic,"brute force,data structures,greedy,implementation,trees",526
"#!/usr/bin/env python
'''
' Author:   Cheng-Shih Wong
' Email:    mob5566@gmail.com
' Date:     2017-09-22
'''

def main():

    def num(left, right, dp, rev, revI):
        if left > right:
            return 1

        key = left, rev, revI
        if key in dp:
            return dp[key]
        nonlocal ans

        acc = 0

        for x in ('01' if ans[left]=='#' else ans[left]):
            
            temp = None
            if left == right:
                tmp = x
            elif ans[right]=='#':
                tmp = '01'
            else:
                tmp = ans[right]

            for y in tmp:
                if not ((rev and x>y) or (revI and x==y=='1')):
                    acc += num(
                        left+1,
                        right-1,
                        dp,
                        rev and x==y,
                        revI and x!=y
                    )
        dp[key] = acc
        return acc

    n, k = map(int, input().split())
    k += 1

    ans = ['#'] * n

    for i in range(n):
        ans[i] = '0'
        tmp = num(0, n-1, {}, True, True)

        if k > tmp:
            k -= tmp
            ans[i] = '1'

    if ans[0] == '0':
        print(''.join(ans))
    else:
        print(-1)

if __name__ == '__main__':
    import sys, os
    from time import time
    if len(sys.argv)>1 and os.path.exists(sys.argv[1]):
        sys.stdin = open(sys.argv[1], 'rb')
    st = time()
    main()
    print('----- Run {:.6f} seconds. -----'.format(time()-st), file=sys.stderr)
",cubic,"dp,graphs",1530
"n, m = map(int, input().split())
m += 1


def calc(l, r, eq, eq_i):
    if l > r:
        return 1
    key = l, eq, eq_i
    if key in f:
        return f[key]

    t = 0
    for x in (['0', '1'] if s[l] == '?' else [s[l]]):
        if l == r:
            a = [x]
        else:
            a = ['0', '1'] if s[r] == '?' else [s[r]]
        for y in a:
            if not((eq and x > y) or (eq_i and x == y == '1')):
                t += calc(l + 1, r - 1, eq and x == y, eq_i and x != y)
    f[key] = t
    return t


s = ['?'] * n
for i in range(n):
    s[i] = '0'
    f = {}
    p = calc(0, n - 1, True, True)
    if m > p:
        m -= p
        s[i] = '1'

if s[0] == '0':
    print(''.join(s))
else:
    print(-1)
",cubic,"dp,graphs",719
"def raschot(d, e, g, h):
    if d > e:
        return 1
    key = d, g, h
    if key in b:
        return b[key]
    f = 0
    for x in (['0', '1'] if a0[d] == '?' else [a0[d]]):
        if d == e:
            a = [x]
        else:
            a = ['0', '1'] if a0[e] == '?' else [a0[e]]
        for y in a:
            if not ((g and x > y) or (h and x == y == '1')):
                f += raschot(d + 1, e - 1, g and x == y, h and x != y)
    b[key] = f
    return f


n, m = map(int, input().split())
m += 1
a0 = ['?'] * n
for i in range(n):
    a0[i] = '0'
    b = {}
    c = raschot(0, n - 1, True, True)
    if m > c:
        m -= c
        a0[i] = '1'
if a0[0] == '0':
    print(''.join(a0))
else:
    print(-1)
",cubic,"dp,graphs",718
"s=input()
m=0
n=len(s)
for i in range(n-1):
    for j in range(i,n+1) :
        if s[i:j] in s[i+1:n] and len(s[i:j])>m:
            m=len(s[i:j])
print(m)",cubic,"brute force,greedy",155
"
n = input()

m = 0
for i in range(len(n)):

    for j in range(i,len(n)+1):

        if len(n[i:j])>m and n[i:j] in n[i+1:len(n)]:

            m = len(n[i:j])

print(m)
",cubic,"brute force,greedy",171
"
def STR(): return list(input())
def INT(): return int(input())
def MAP(): return map(int, input().split())
def MAP2():return map(float,input().split())
def LIST(): return list(map(int, input().split()))
def STRING(): return input()
import string
import sys
from heapq import heappop , heappush
from bisect import *
from collections import deque , Counter
from math import *
from itertools import permutations , accumulate
dx = [-1 , 1 , 0 , 0  ]
dy = [0 , 0  , 1  , - 1]
#visited = [[False for i in range(m)] for j in range(n)]
#sys.stdin = open(r'input.txt' , 'r')
#sys.stdout = open(r'output.txt' , 'w')
#for tt in range(INT()):

s = STR()

if len(set(s)) == len(s):
    print('0')
    exit(0)

d = []

for i in range(len(s)):
    for j in range(i+1 , len(s)):
        x = ''
        for k in range(i , j+1):
            x += s[k]

        d.append(x)

v = {}
for i in range(len(s)):
    if s[i] not in v :
        v[s[i]] = 1
    else:
        v[s[i]] +=1


for i in d :
    if i not in v :
        v[i] = 1
    else:
        v[i]+=1

#print(v)
mx = -1
ans = ''

for i in v :
    if v[i] >= 2 :
        if len(i) > mx :
            mx = max(mx , len(i))

print(mx)

",cubic,"brute force,greedy",1170
"S = input()
best = 0
for i in range(len(S)):
    for j in range(i+1, len(S)+1):
        s = S[i:j]
        c = 0
        for k in range(len(S)):
            if S[k:].startswith(s): c += 1
        if c >= 2: 
            best = max(best, len(s))
print(best)",cubic,"brute force,greedy",256
"s=input()
n=len(s)
m=0

for i in range(n-1):
    for j in range(1,n-i):
        if s[i:i+j] in s[i+1:]:
            if j>m:
                m=j

print(m)
    ",cubic,"brute force,greedy",158
"
cadena = input()
n = len(cadena)

rpta = 0

for i in range(n-1):
    tamanho_cadena = n-i-1
    for j in range(n-tamanho_cadena):
        subcadena = cadena[j:j+tamanho_cadena]
        contador = 1
        for k in range(n-tamanho_cadena-j):
            if subcadena == cadena[j+k+1:j+k+1+tamanho_cadena]:
                contador = contador + 1
        if contador >=2  and rpta == 0:
            rpta = tamanho_cadena
    if rpta !=0:
        break

print(rpta)",cubic,"brute force,greedy",464
"import sys
from random import *
from bisect import *
from heapq import *
#from collections import deque
pl=1
from math import gcd,sqrt,ceil
from copy import *
sys.setrecursionlimit(10**5)
if pl:
	input=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('outpt.txt','w')

def li():
	return [int(xxx) for xxx in input().split()]
def fi():
	return int(input())
def si():
	return list(input().rstrip())	
def mi():
	return 	map(int,input().split())	

		
t=1

while t>0:
	t-=1
	s=input().rstrip()
	n=len(s)
	d={}
	for i in range(n):
		r=""""
		for j in range(i,n):
			r+=s[j]
			if r not in d:
				d[r]=1
			else:
				d[r]+=1
	maxi=0			
	for i in d:
		if d[i]>=2:
			maxi=max(maxi,len(i))
	print(maxi)		
 	 		 		 	 				 		  	 		 	  			",cubic,"brute force,greedy",753
"s = input()
n = len(s)
m = n - 1;
while m > 0:
    find = False
    for i in range(0, n - m):
        for j in range(i + 1, n - m + 1):
            match = True
            for k in range(0, m):
                if s[i+k] != s[j+k]:
                    match = False
                    break
            if match:
                find = True
                break
        if find:
            break
    if find:
        break
    m -= 1
print(m)",cubic,"brute force,greedy",445
"s=input()
o=len(s)
k=0
for i in range(o):
    r={0}
    for j in range(o-i+1):
        if s[j:j+i] in r:k=max(i,k)
        else:r.add(s[j:j+i])
print(k)",cubic,"brute force,greedy",152
"s=input()
n=len(s)
m=n-1;
while m>0:
    f=False
    for i in range(0,n-m):
        for j in range(i+1,n-m+1):
            x=True
            for k in range(0,m):
                if s[i+k]!=s[j+k]:
                    x=False
                    break
            if x:
                f=True
                break
        if f:
            break
    if f:
        break
    m -= 1
print(m)",cubic,"brute force,greedy",390
"a=input()
n=len(a)
for i in range(n-1,-1,-1):
    b=sorted([a[j:j+i] for j in range(n-i+1)])
    if True in [b[j]==b[j-1] for j in range(1,n-i+1)]:
        print(i)
        break",cubic,"brute force,greedy",178
"import re
import sys
exit=sys.exit
from bisect import bisect_left as bsl,bisect_right as bsr
from collections import Counter,defaultdict as ddict,deque
from functools import lru_cache
cache=lru_cache(None)
from heapq import *
from itertools import *
from math import inf
from pprint import pprint as pp
enum=enumerate
ri=lambda:int(rln())
ris=lambda:list(map(int,rfs()))
rln=sys.stdin.readline
rl=lambda:rln().rstrip('\n')
rfs=lambda:rln().split()
cat=''.join
catn='\n'.join
mod=1000000007
d4=[(0,-1),(1,0),(0,1),(-1,0)]
d8=[(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
########################################################################

s=rl()
n=len(s)
ans=0
for i in range(n-1):
  for j in range(i+1,n):
    for k in range(n-j):
      if s[i+k]!=s[j+k]:
        break
      ans=max(ans,1+k)

print(ans)
",cubic,"brute force,greedy",821
"import sys
import string

from collections import Counter, defaultdict
from math import fsum, sqrt, gcd, ceil, factorial
from operator import *
from itertools import accumulate, count

inf = float(""inf"")
# input = sys.stdin.readline
flush = lambda: sys.stdout.flush
comb = lambda x, y: (factorial(x) // factorial(y)) // factorial(x - y)


# inputs
# ip = lambda : input().rstrip()
ip = lambda: input()
ii = lambda: int(input())
r = lambda: map(int, input().split())
rr = lambda: list(r())


arr = ip()
n = len(arr)
ms = """"
mn = 0


def counter(s, x):
    p = len(x)
    px = 0
    for i in range(len(s)):
        if s[i : i + p] == x:
            px += 1

    return px


for i in range(n):
    s = """"
    for j in range(i, n):
        s += arr[j]
        c = counter(arr, s)
        if c > 1 and len(s) > mn:
            ms = s
            mn = len(s)

print(mn)",cubic,"brute force,greedy",863
"import sys
import logging
logging.root.setLevel(level=logging.DEBUG)
import re

s = sys.stdin.readline().strip()

from collections import defaultdict
substr = defaultdict(int)
for left in range(len(s)):
    for right in range(left+1,len(s)+1):
        substr[s[left:right]] += 1
max_len = 0
for segment,times in substr.items():
    if times >= 2:
        max_len = max(max_len,len(segment))
print(max_len)

",cubic,"brute force,greedy",407
"
string = str(input())
length = len(string)

counter = 0
li = []
match_li = []

for i in range(length):
    letter = string[i]
    letters = letter
    if letter in li:
        match_li.append(letter)
    li.append(letter)
    for j in range(i+1, length):
        letters += string[j]
        if letters in li:
            match_li.append(letters)
        li.append(letters)

longest = 0
for k in match_li:
    if len(k) > longest:
        longest = len(k)

print(longest)
    
",cubic,"brute force,greedy",478
"s = input()


def check_x(mid):
    ans = 'no'
    d = {}
    for i in range(len(s)-mid+1):
        #print(s[i:i+mid])
        if s[i:i+mid] in d.keys():
            ans = 'yes'
            break
        d[s[i:i+mid]] = 1
        
    return ans

    
l = 0
r = len(s) - 1
while r-l > 1:
    mid = (r+l) // 2

    ans = check_x(mid)
    if ans == 'yes':
        l = mid
    else:
        r = mid
        
if check_x(r) == 'yes':
    print(r)
else:
    print(l)
        ",cubic,"brute force,greedy",469
"def countall(string, substring):
    total = 0
    for i in range(len(string)-len(substring)+1):
        if string[i:i+len(substring)] == substring:
            total += 1
    return total

n = input()
allvalues = []
for i in range(len(n)):
    for j in range(len(n)-1, i-1, -1):
        if countall(n, n[i:j+1]) > 1:
            allvalues.append(j-i+1)
            break

try:
    print(max(allvalues))
except:
    print(0)",cubic,"brute force,greedy",424
"string=input()
n=len(string)
count1=[]
long=0
for s_i in range(n):
    for end_i in range(s_i+1,n+1):
        sub=string[s_i:end_i]
        if sub not in count1:
            count1.append(sub)
        else:
            if len(sub)>long:
                long=len(sub)
                
                    

print(long)            
        
               
",cubic,"brute force,greedy",355
"string=input()
n=len(string)
check=True
for sub_len in range(n-1,0,-1):
    for starting_index in range(n-sub_len+1):
        if string[starting_index:starting_index+sub_len] in string[starting_index+1:]:
            print(sub_len)
            check=False
            break
    if check==False:
        break  
if check:
    print(0)
",cubic,"brute force,greedy",334
"s=input()
length=len(s)
answer=[ ]
for i in range (0,length):
    for j in range(i+1,length+1):
        k=s[i:j]
        co=0
        for u in range (0,length):
            if(s[u:].startswith(k)):
                co+=1
        if(co>=2):
            #answer=max(answer,len(k))
            answer.append(len(k))
if(len(set(s))==length):
    print('0')
else:
    print(max(answer))

",cubic,"brute force,greedy",382
"import sys, math, cmath, time, collections
from collections import deque, Counter, OrderedDict, defaultdict
from heapq import nsmallest, nlargest, heapify, heappop, heappush, heapreplace
from math import ceil, floor, log, log2, sqrt, gcd, factorial, pow, pi
from bisect import bisect_left, bisect_right

# BEGIN FASTIO

import os
import sys
from io import BytesIO, IOBase


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# END FASTIO

# SOLUTION BEGINS HERE

start_time = time.time()


def solve(s):
    """"""
    Actual solution
    """"""
    mx = 0
    visited = set()
    for left in range(len(s)):
        for right in range(left, len(s)):
            substring = s[left : right + 1]
            if substring not in visited:
                visited.add(substring)
            elif substring in visited:
                mx = max(mx, len(substring))
    print(mx)

def main():
    """"""
    Main function dedicated to get the I/P
    a, b = map(int, input().split())
    solve(a, b)
    """"""
    s = input()
    solve(s)

if __name__ == ""__main__"":
    LOCAL = False

    # If it's Local - Get I/P from file
    if LOCAL:
        sys.stdin = open(""../io/data.in"", ""r"")
        sys.stdout = open(""../io/data.out"", ""w"")

    testcases = 1
    for i in range(testcases):
        main()

    # If it's local - Print this O/P
    if LOCAL:
        print(f""Time Elapsed: {time.time() - start_time} seconds"")
        sys.stdout.close()
",cubic,"brute force,greedy",3563
"# http://codeforces.com/problemset/problem/23/A
leng = 0
s = input()
for i in range(len(s)):
    for j in range(i + 1, len(s) + 1):
        sub = s[i:j]
        if s.count(sub) >= 2 and len(sub) > leng:
            leng = len(sub)
        elif s.count(sub) == 1:
            for k in range(1, len(sub)):
                if s[i - k:j - k] == sub and len(sub) > leng:
                    leng = len(sub)
print(leng)

",cubic,"brute force,greedy",415
"s = input()
res = 0
for i in range(len(s)):
    for j in range(i,len(s)):
        for f in range(i+1,len(s)):
            if len(s) >= f + j-i:
                if (s[i:j]== s[f:f+j-i]):
                    res = max(res,j - i)
                    
print(res)",cubic,"brute force,greedy",258
"s = input()
ans = 0
for i in range(len(s)):
    for j in range(i + 1, len(s)):
        cur = s[i:j]
        if cur in s[:(j - 1)] or cur in s[(i + 1):]:
            ans = max(ans, j - i)
print(ans)
",cubic,"brute force,greedy",198
"string = input()
totalmax = 0;
for x in range(len(string)):
    curr = """"
    for y in string[x:]:
        curr +=y;
        if string[x:].rfind(curr) != string[x:].find(curr):
            totalmax = max(totalmax, len(curr))
            continue
print(totalmax)",cubic,"brute force,greedy",261
"line = input()
n = len(line)
temp = [0]
for i in range(1, n):
    for j in range(n-i):
        for k in range(1, n-i-j+1):
            # print(line[j:j+i+1])
            # print(line[j+k:j+k+i+1])
            if line[j:j+i] == line[j+k:j+k+i]:
                temp.append(i)
print(max(temp))",cubic,"brute force,greedy",291
"s = input()

mc = -1

for i in range(len(s)):
	for j in range(i+1, len(s)):
		cu = 0
		for cu in range(len(s)-max(i, j)):
			if s[i+cu] == s[j+cu]:
				mc = max(mc, cu)
			else:
				break
		

print(mc + 1)
			
",cubic,"brute force,greedy",210
"s = input()
k = []
for i in range(len(s)):
    for j in range(i+1,len(s)+2):
        x = s[i:j]
        for t in range(i+1,len(s)):
            if x == s[t:t+j-i]:
                k += [j-i]
print(max(k) if k != [] else 0)",cubic,"brute force,greedy",222
"inputS=input()
ans=0

for i in range (0,len(inputS)-1):
    for count in range(1,len(inputS)):
        for j in range(i+1, len(inputS)-count+1):
            A=inputS[i: i+count]
            B=inputS[j: j+count]
            if A==B:
                ans=count if count>ans else ans

print(ans)",cubic,"brute force,greedy",291
"s = input()
res = 0
solve = 0
for pos in range(1,len(s)):
    for i in range(len(s) - pos):
        if s[i:i+pos] in s[i+1:]:
            if solve < pos:
                solve = pos
print(solve)",cubic,"brute force,greedy",194
"S = input()

ans = 0
met = set()

for i in range(len(S)):
    for j in range(i, -1, -1):
        if S[j:i+1] in met:
            ans = max(ans, i - j + 1)
        else:
            met.add(S[j:i+1])
            
print(ans)",cubic,"brute force,greedy",222
"str=input()
m=0
n=len(str)
for i in range(n):
    for j in range(i,n+1) :
        if str[i:j] in str[i+1:n] and len(str[i:j])>m:
            m=len(str[i:j])
print(m)",cubic,"brute force,greedy",165
"st=input()
m=0
n=len(st)
for i in range(n):
    for j in range(i,n+1) :
        if st[i:j] in st[i+1:n] and len(st[i:j])>m:
            m=len(st[i:j])
print(m)",cubic,"brute force,greedy",159
"s = input()
for i in range(len(s), 0, -1):
	for j in range(len(s) - i + 1):
		if s[j: j + i] in s[j + 1:]:
			print(i)
			exit()
print(0)",cubic,"brute force,greedy",137
"s = input()
pb = 0
lenght = len(s)-1
w = []
while(lenght!=0):
    ss = s[pb:pb+lenght]
    w.append(ss)
    if pb+lenght==len(s):
        pb = 0
        lenght -= 1
    else:
        pb+=1
for i in range(0,len(w)-1):
    for j in range(i+1,len(w)):
        if (w[i]==w[j]):
            print(len(w[i]))
            exit(0)
print(0)

    
",cubic,"brute force,greedy",338
"def occurrences(string, sub):
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count


class CodeforcesTask23ASolution:
    def __init__(self):
        self.result = ''
        self.string = ''

    def read_input(self):
        self.string = input()

    def process_task(self):
        o_max = 0
        for x in range(len(self.string)):
            for y in range(x):
                m = occurrences(self.string, self.string[y:x])
                if m >= 2:
                    o_max = max(x - y, o_max)
        self.result = str(o_max)

    def get_result(self):
        return self.result


if __name__ == ""__main__"":
    Solution = CodeforcesTask23ASolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())
",cubic,"brute force,greedy",864
"#// Remon Hasan, 19th sep '19
s = input()
n = len(s)
m = n - 1;
while m > 0:
    find = False
    for i in range(0, n - m):
        for j in range(i + 1, n - m + 1):
            match = True
            for k in range(0, m):
                if s[i+k] != s[j+k]:
                    match = False
                    break
            if match:
                find = True
                break
        if find:
            break
    if find:
        break
    m -= 1
print(m)
",cubic,"brute force,greedy",476
"
def cic(my_string):
	my_hash=set();
	max_v=-1<<256;
	for i in range(len(my_string)):
		empty=my_string[i]+''
		if empty in my_hash:
			max_v=max(max_v,len(empty))
		else:
			my_hash.add(empty)
		for j in range(i+1,len(my_string)):
			empty+=my_string[j]
			if empty not in my_hash:
				my_hash.add(empty)
			else:
				max_v=max(max_v,len(empty))
	return 0 if max_v<0 else max_v

def main():
	my_string=input()
	print(cic(my_string))



if __name__=='__main__':
	main()
",cubic,"brute force,greedy",470
"str=input()
n=len(str)
ans=0
amap={}
def fun():
    global ans
    for strLen in range(n,0,-1):
        mark=0
        for t in range(0,n):
            if t+strLen>n:
                break
            s=str[t:t+strLen]
            if s in amap:
                amap[s]+=1
            else:
                amap[s]=1
            if amap[s]>=2:
                mark=1
                ans=len(s)
                print(ans)
                break
        if mark==1:
            break
fun()
if ans==0:
    print(ans)",cubic,"brute force,greedy",511
"a = input()
l = 0
for i in range(1, len(a)):
  for j in range(0, len(a) - i + 1):
    #print(a[j:j + i + 1], i, j)
    t = a.find(a[j:j + i])
    c = a.rfind(a[j:j + i])
    #print(t, c)
    if t != c:
      if i > l:
        l = i
print(l)",cubic,"brute force,greedy",240
"x=input()
a=0
for i in range(len(x)):
    for j in range(i,len(x)):
        if x[i:j] in x[i+1:]:
            if len(x[i:j])>a:
                a=len(x[i:j])
print(a)
",cubic,"brute force,greedy",167
"""""""
$ pylint calderonsin.py
Global evaluation
-----------------
Your code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)

""""""
def maxlen():
    string = input()
    maxi = 0;
    for x in range(len(string)):
        substring = """"
        for y in string[x:]:
            substring +=y;
            if string[x:].rfind(substring) != string[x:].find(substring):
                maxi = max(maxi, len(substring))
                continue
    print(maxi)

maxlen()
# $ python3 calderonsin.py build
# remember the output
",cubic,"brute force,greedy",528
"string = input().strip()
mx = 0

for i in range(len(string)):
    for j in range(i+1, len(string)):
        m = 0
        while(j+m < len(string) and string[i+m] == string[j+m]):
            m += 1
        mx = max(mx, m)

print(mx)",cubic,"brute force,greedy",232
"s=list(input())
dic={}
for i in range(0,len(s)):
    for j in range(i,len(s)):
        ele="""".join(s[i:j+1])
        if ele not in dic:
            dic[ele]=1
        else:
            dic[ele]+=1
#print(dic)
        
ans=[]        
for key in dic.keys():
    if dic[key]>=2:

        ans.append(len(key))
ans.sort()
if ans==[]:
    print(0)
else:
    
    print(ans[-1])


        
",cubic,"brute force,greedy",383
"s = input()
n = len(s)

for L in range(n-1, 0, -1):
    if len({s[i:i+L] for i in range(n-L+1)}) < n-L+1:
        print(L)
        break
else:
    print(0)",cubic,"brute force,greedy",155
"import sys
import math
import itertools
import functools
import collections
import operator
import fileinput
import copy


ORDA = 97
def ii(): return int(input())
def mi(): return map(int, input().split())
def li(): return list(map(int, input().split()))
def lcm(a, b): return abs(a * b) // math.gcd(a, b)
def revn(n): return str(n)[::-1]
def dd(): return collections.defaultdict(int)
def ddl(): return collections.defaultdict(list)
def sieve(n):
    if n < 2: return list()
    prime = [True for _ in range(n + 1)]
    p = 3
    while p * p <= n:
        if prime[p]:
            for i in range(p * 2, n + 1, p):
                prime[i] = False
        p += 2
    r = [2]
    for p in range(3, n + 1, 2):
        if prime[p]:
            r.append(p)
    return r
def divs(n, start=2):
    r = []
    for i in range(start, int(math.sqrt(n) + 1)):
        if (n % i == 0):
            if (n / i == i):
                r.append(i)
            else:
                r.extend([i, n // i])
    return r
def divn(n, primes):
    divs_number = 1
    for i in primes:
        if n == 1:
            return divs_number
        t = 1
        while n % i == 0:
            t += 1
            n //= i
        divs_number *= t
def prime(n):
    if n == 2: return True
    if n % 2 == 0 or n <= 1: return False
    sqr = int(math.sqrt(n)) + 1
    for d in range(3, sqr, 2):
        if n % d == 0: return False
    return True
def convn(number, base):
    newnumber = 0
    while number > 0:
        newnumber += number % base
        number //= base
    return newnumber
def cdiv(n, k): return n // k + (n % k != 0)


s = input()
lens = len(s)
max_ = 0
for i in range(1, lens):
    d = {}
    for j in range(lens - i + 1):
        if s[j: j + i] in d:
            d[s[j: j + i]] += 1
        else:
            d[s[j: j + i]] = 1
    maxd = max(d.values())
    if max(d.values()) > 1:
        max_ = i
print(max_)
",cubic,"brute force,greedy",1900
"t = input()

n = len(t)

maxi = 0

for i in range(n):
    s = t[i]
    if t.count(s) > 1:
        maxi = max(maxi, 1)
    nr = 1
    for j in range(i + 1, n):
        s += t[j]
        nr += 1
        g = 0
        for h in range(n - nr + 1):
            if s == t[h:h + nr]:
                g += 1
        if g > 1:
            maxi = max(nr,maxi)

print(maxi)",cubic,"brute force,greedy",361
"s=input()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)
        
",cubic,"brute force,greedy",165
"S = input()
sLen, ans = len(S), 0
for i in range(sLen):
    for till1 in range(i + 1, sLen):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break
            sub1 = S[i:till1]
            sub2 = S[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)
",cubic,"brute force,greedy",408
"s, ans, = input(), 0
sLen = len(s)

for i in range(sLen):
    for till1 in range(i + 1, sLen + 1):
        till2 = till1 + 1
        for j in range(i + 1, sLen + 1):
            if till2 > sLen:
                break
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)
",cubic,"brute force,greedy",418
"s = input()
sLen, ans = len(s), 0

for i in range(sLen - 1):
    for till1 in range(i + 1, sLen):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break;
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and subLen > ans:
                ans = subLen
            till2 += 1

print(ans)
",cubic,"brute force,greedy",414
"'''
s = input()
sLen = len(s)
while sLen != 0:
    for i in range(sLen):
        print(s[i])
        sLen = sLen - 1
'''

'''
   012345
s='abcdef'
s[0:1] =='a'
s[0:2]=='ab'
........
s[1:2]=='b'
s[1:3]=='bc'
s[1:4]=='bcd'
.......
s[2:3]=='c'
s[2:4]=='cd'
......
'''
s = input()
sLen, ans = len(s), 0

for i in range(sLen):
    for till1 in range(i + 1, sLen + 1):
        till2 = till1 + 1
        for j in range(i + 1, sLen):
            if till2 > sLen:
                break
            sub1 = s[i:till1]
            sub2 = s[j:till2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            till2 += 1

print(ans)",cubic,"brute force,greedy",677
"from sys import stdin
s=stdin.readline()
for ln in range(len(s),0,-1):
    for L in range(len(s)-ln+1):
        if s[L:L+ln] in s[L+1:]:
            print(ln)
            exit()
print(0)",cubic,"brute force,greedy",186
"a=input()
n=len(a)
for l in range(n,0,-1):
  for i in range(n-l+1):
    if a[i:i+l] in a[i+1:]:
      print(l)
      exit(0)
print(0)",cubic,"brute force,greedy",133
"n=input()
m={}
def podstroka(s:str):
    for i in range(0,len(s)):
        for j in range(i+1,len(s)+1):
            if s[i:j] in m:
                m[s[i:j]] +=1
            else:
                m[s[i:j]] = 1
    return m        



podstroka(n)


maxlen = 0
for x in m:
    if m[x]>=2 and len(x)>maxlen:
        maxlen=len(x)  
print(maxlen)",cubic,"brute force,greedy",344
"S = input()
best = 0
for i in range(len(S)):
    for j in range(i+1, len(S)+1):
        s = S[i:j]
        c = 0
        for k in range(len(S)):
            if S[k:].startswith(s): c += 1
        # print(s, c)
        if c >= 2: 
            best = max(best, len(s))
print(best)",cubic,"brute force,greedy",278
"name = input()
for i in range(len(name), 0, -1):
	for j in range(len(name) - i + 1):
		if name[j: j + i] in name[j + 1:]:
			print(i)
			exit()
print(0)
  				  	 	 	 			 			 			 	",cubic,"brute force,greedy",180
"x=input();l=len(x);m=0
for i in range(l-1):
    f=i
    while 1 : 
        idx = x[f+1:].find(x[f])         
        if idx == -1 :
            break
        else:
            idx += f+1 ; c=ans=0
            for j in range(idx , l) :
               if x[j] == x[i+c]:
                    ans+=1
                    c+=1  
               else:
                   break
               
            if m < ans :
                m=ans
            f = idx              
print(m)

 				         			 	 						   		",cubic,"brute force,greedy",507
"	# https://vjudge.net/contest/381017#problem/W

x=input();l=len(x);m=0
for i in range(l-1):
    f=i
    while 1 : 
        idx = x[f+1:].find(x[f])         
        if idx == -1 :
            break
        else:
            idx += f+1 ; c=ans=0
            for j in range(idx , l) :
               if x[j] == x[i+c]:
                    ans+=1
                    c+=1  
               else:
                   break
               
            if m < ans :
                m=ans
            f = idx              
print(m)
",cubic,"brute force,greedy",523
"# -*- coding: utf-8 -*-

s = input()
n,m = len(s),0

for i in range(n-1):
    for j in range(i,n+1):
        if len(s[i:j]) > m and s[i:j] in s[i+1:n]: m = len(s[i:j])
    
print(m)
",cubic,"brute force,greedy",182
"s=input()
ans=0
m=set()
for i in range(len(s)):
    for j in range(i,-1,-1):
        if(s[j:i+1] in m):
            ans=max(ans,i-j+1)
        else:
            m.add(s[j:i+1])
print(ans)
    ",cubic,"brute force,greedy",192
"# http://codeforces.com/contest/23/problem/A

string = input()
size = len(string)

ans_got = 0
for s in range(1,size)[::-1]:
    dic = {}
    for i in range(0,size-s+1):
        if(string[i:i+s] in dic):
            print(s)
            ans_got = 1
            break
        else:
            dic[string[i:i+s]] = 1
    if(ans_got == 1):
        break
if(ans_got == 0):
    print(0)",cubic,"brute force,greedy",382
"def cnt(s,t):
    i,c=0,0
    while(s.count(t)):
        s=s[s[i:].index(t)+1:]
        c+=1
    return c
s=(input())
n=len(s)
ln=0
for i in range(n):
    for j in range(i,n):
        if(j-i+1<=ln):
            continue
        if(cnt(s,s[i:j+1])>=2):
            ln=max(ln,j-i+1)
print(ln)
",cubic,"brute force,greedy",291
"for ctr in range(1):
    s=input().strip()
    for l in range(len(s),0,-1):
        k=[]
        for i in range(0,len(s)-l+1):
            k.append(s[i:i+l])
        if len(k)!=len(list(set(k))):
            print(l)
            exit()
    print(0)
    
",cubic,"brute force,greedy",254
"z,zz=input,lambda:list(map(int,z().split()))
zzz=lambda:[int(i) for i in stdin.readline().split()]
szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())
from string import *
from re import *
from collections import *
from queue import *
from sys import *
from collections import *
from math import *
from heapq import *
from itertools import *
from bisect import *
from collections import Counter as cc
from math import factorial as f
from bisect import bisect as bs
from bisect import bisect_left as bsl
from itertools import accumulate as ac
def lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))
def prime(x):
    p=ceil(x**.5)+1
    for i in range(2,p):
        if (x%i==0 and x!=2) or x==0:return 0
        
    return 1
def dfs(u,visit,graph):
    visit[u]=True
    for i in graph[u]:
        if not visit[i]:
            dfs(i,visit,graph)

###########################---Test-Case---#################################
""""""



""""""
###########################---START-CODING---##############################

l=z()
n=len(l)
ans=0
for i in range(n):

    for j in range(i+1,n+1):
        p=l[i:j]
        t=len(p)
        x=0

        for k in range( n):
            if l[k:k+t]==p:
                x+=1
        if x>=2:
            ans=max(ans,t)
print(ans)




	   			   	 		      	   	 	   	",cubic,"brute force,greedy",1318
"'''
s = input()
for i in range(len(s)):

    for k in range(i + 1, len(s)+1, 1):
        print(s[i:k])
'''
'''
s = input()
sLen = len(s)
for startInd in range(sLen):
    for endInd in range(startInd + 1, sLen + 1):
        print(s[startInd, endInd])

'''
s = input()
slen = len(s)
ans = 0
for st1 in range(slen - 1):
    for end1 in range(st1 + 1, slen):
        end2 = end1 + 1
        sub1 = s[st1:end1]
        for st2 in range(st1 + 1, slen):
            if end2 > slen:
                break

            sub2 = s[st2:end2]
            subLen = len(sub1)
            if sub1 == sub2 and ans < subLen:
                ans = subLen
            end2 += 1

print(ans)
",cubic,"brute force,greedy",669
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other): 
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0	
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)
		#print(p.x,p.y,p.h)
		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)
	#extend(p,n,m,interestPoints)
for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]
	#print(maxPoint.x,maxPoint.y)
	#print(str(len(extendedPoints)))
	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",cubic,"brute force,dfs and similar,shortest paths",3389
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase
from collections import deque

def main():
    with open('input.txt') as fp:
        input=fp.readline
        n, m = map(int, input().split())
        dx = [1, -1, 0, 0]
        dy = [0, 0, -1, 1]
        q =deque()
        k = int(input())
        a = list(map(int, input().split()))
        v = [[1] * (m + 2) for _ in range(n + 2)]
        for i in range(m + 2):
            v[0][i] = 0
            v[-1][i] = 0
        for i in range(n + 2):
            v[i][0] = 0
            v[i][-1] = 0
        for i in range(0, 2 * k, 2):
            q.append((a[i],a[i + 1]))
            v[a[i]][a[i + 1]] = 0
        while 1:
            x, y =q.popleft()
            for i in range(4):
                xx, yy = x + dx[i], y + dy[i]
                if v[xx][yy]:
                    q.append((xx, yy))
                    v[xx][yy] = 0
            if not q:
                with open('output.txt', mode='w') as fpp:
                    fpp.write(f'{x} {y}')
                break

# region fastio
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic,"brute force,dfs and similar,shortest paths",2796
"'''
                ___                       ____                     
  ____ _____ _____/ (_)_  ______  ____ _____/ / /_  __  ______ ___  __
 / __ `/ __ `/ __  / / / / / __ \/ __ `/ __  / __ \/ / / / __ `/ / / /
/ /_/ / /_/ / /_/ / / /_/ / /_/ / /_/ / /_/ / / / / /_/ / /_/ / /_/ / 
\__,_/\__,_/\__,_/_/\__,_/ .___/\__,_/\__,_/_/ /_/\__, /\__,_/\__, /  
                        /_/                      /____/      /____/   
'''
import os.path
from math import gcd, floor, ceil
from collections import *
import sys
mod = 1000000007
INF = float('inf')
def st(): return list(sys.stdin.readline().strip())
def li(): return list(map(int, sys.stdin.readline().split()))
def mp(): return map(int, sys.stdin.readline().split())
def inp(): return int(sys.stdin.readline())
def pr(n): return sys.stdout.write(str(n)+""\n"")
def prl(n): return sys.stdout.write(str(n)+"" "")


if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]


def solve():
    n, m = mp()
    k = inp()
    l = li()
    q = deque()
    v = [[0]*(m+1) for i in range(n+1)]
    for i in range(0, 2*k - 1, 2):
        q.append((l[i], l[i+1]))
        v[l[i]][l[i+1]] = 1
    while q:
        a, b = q.popleft()
        for i in range(4):
            A, B = a+dx[i], b+dy[i]
            if A > 0 and A <= n and B > 0 and B <= m:
                if not v[A][B]:
                    q.append((A, B))
                    v[A][B] = 1
    print(a, b)


for _ in range(1):
    solve()
",cubic,"brute force,dfs and similar,shortest paths",1533
"with open(""input.txt"",""r"") as in_file: 
    with open(""output.txt"",""a"") as out_file:
        N,M = map(int,in_file.readline().split())
        K = int(in_file.readline())
        map_max_dist = [[5000 for i in range(M)] for j in range(N)]
        inputs = list(map(int,in_file.readline().split()))
        p = 0 
        while(p<=K*2-2):
            x,y = inputs[p]-1,inputs[p+1]-1
            for r in range(N):
                for c in range(M):
                    dist = abs(x-r)+abs(y-c)
                    if dist<map_max_dist[r][c]:
                        map_max_dist[r][c] = dist
            p+=2
        max_val = 0 
        max_index = (0,0)
        i,j = 0,0
        for i in range(N):
            for j in range(M):
                if(map_max_dist[i][j]>max_val):
                    max_val = map_max_dist[i][j]
                    max_index = (i,j)
        out_file.write(""{} {}"".format(max_index[0]+1,max_index[1]+1))
    
        ",cubic,"brute force,dfs and similar,shortest paths",949
"from collections import deque
with open(""input.txt"",""r"") as input_file: 
    with open(""output.txt"",""a"") as output_file:
        N,M = map(int,input_file.readline().split())
        K = int(input_file.readline())
        T = list(map(int,input_file.readline().split()))
        graph = [[0] * (M + 1) for _ in range(N + 1)]
        queue = deque()
        for i in range(0, 2 * K - 1, 2):
            graph[T[i]][T[i + 1]] = 1
            queue.append((T[i], T[i + 1]))
        x, y = 0, 0
        while queue:
            x, y = queue.popleft()
            x_moves = [x - 1, x + 1, x, x]
            y_moves = [y, y, y - 1, y + 1]
            for i in range(len(x_moves)):
                if 0 < x_moves[i] <= N and 0 < y_moves[i] <= M:
                    if graph[x_moves[i]][y_moves[i]] == 0:
                        x = x_moves[i]
                        y = y_moves[i]
                        graph[x_moves[i]][y_moves[i]] = 1
                        queue.append((x_moves[i], y_moves[i]))
        output_file.write(f""{x} {y}"")",cubic,"brute force,dfs and similar,shortest paths",1033
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect, insort
from time import perf_counter
from fractions import Fraction
import copy
from copy import deepcopy
import time
starttime = time.time()
mod = int(pow(10, 9) + 7)
mod2 = 998244353

def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]
try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
except:
    pass
def pmat(A):
    for ele in A: print(*ele,end=""\n"")

# from sys import stdin
# input = stdin.buffer.readline
# I = lambda : list(map(int,input().split()))

# import sys
# input=sys.stdin.readline



n, m = L()
k = L()[0]
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, L()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))
 
 
x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))
 
print(f'{x+1} {y+1}')
",cubic,"brute force,dfs and similar,shortest paths",1692
"from math import log
import random
spaces = ("" "",""\n"",""\t"")
stops = ("""","" "",""\n"",""\t"")
extendedPoints = set()
startingPoints = set()
interestPoints = []

class TPoint:
	def __init__(self,x,y):
		self.x=x
		self.y=y
	def __str__(self):
		return ""(""+str(self.x)+"",""+str(self.y)+"")""
	def __eq__(self, other): 
		return self.x == other.x and self.y == other.y
	def __hash__(self):
		return self.x*20000 + self.y
	x=0
	y=0
	h=0	# эвристика
def sortKey(p):
	return p.h
def heuristic(p, otherPoints):
	minH = float(""inf"")
	for point in otherPoints:
		currentH = abs(point.x - p.x) + abs(point.y - p.y)
		if currentH < minH:
			minH = currentH
	return minH

def addPoint(p,pointList):
	if not p in extendedPoints:
		p.h = heuristic(p,startingPoints)
		extendedPoints.add(p)
		pointList.append(p)
		#print(p.x,p.y,p.h)
		return True
	else:
		return False

def extend(point,n,m,poinList):
	ok = False
	if point.x>1:
		ok = addPoint(TPoint(point.x-1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x-1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x-1,point.y+1),poinList) or ok
	if point.x<n:
		ok = addPoint(TPoint(point.x+1,point.y),poinList) or ok
		if point.y>1:
			ok = addPoint(TPoint(point.x+1,point.y-1),poinList) or ok
		if point.y<m:
			ok = addPoint(TPoint(point.x+1,point.y+1),poinList) or ok
	if point.y>1:
		ok = addPoint(TPoint(point.x,point.y-1),poinList) or ok
	if point.y<m:
		ok = addPoint(TPoint(point.x,point.y+1),poinList) or ok

	return ok

def ReadNext(fileObject):
	currentBuffer = """"
	currentRead=fileObject.read(1)
	while currentRead in spaces:
		currentRead=fileObject.read(1)
	currentBuffer = currentBuffer + currentRead
	while not currentRead in stops:
		currentRead=fileObject.read(1)
		currentBuffer = currentBuffer + currentRead
	return currentBuffer.strip()

w, r= open('output.txt', 'w'), open('input.txt', 'r')

n = int(ReadNext(r))
m = int(ReadNext(r))
k = int(ReadNext(r))
mscale = 5

for i in range(k):
	x = int(ReadNext(r))
	y = int(ReadNext(r))
	p = TPoint(x,y)
	startingPoints.add(p)
	extendedPoints.add(p)

tmpPoints = []
tmpPoints.append(TPoint(1,1))
tmpPoints.append(TPoint(1,m))
tmpPoints.append(TPoint(n,1))
tmpPoints.append(TPoint(n,m))
if n>2 and m>2:
	tmpPoints.append(TPoint(int(n/2),1))
	tmpPoints.append(TPoint(1,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),m))
	tmpPoints.append(TPoint(n,int(m/2)))
	tmpPoints.append(TPoint(int(n/2),int(m/2)))

for p in tmpPoints:
	addPoint(p,interestPoints)
	#extend(p,n,m,interestPoints)
for p in startingPoints:
	extend(p,n,m,interestPoints)

interestPoints.sort(reverse=True, key=sortKey)
while len(interestPoints) > 3*mscale:
	interestPoints.pop(len(interestPoints)-1)

random.seed()

if(len(interestPoints)>0):
	maxPoint = interestPoints[0]
	for p in interestPoints:
		currentBeam = [p]
		canExtend = True
		while canExtend:
			addPoint(TPoint(random.randint(1,n),random.randint(1,m)),currentBeam)
			canExtend = False
			for i in range(len(currentBeam)):
				if extend(currentBeam[i],n,m,currentBeam):
					canExtend = True
			currentBeam.sort(reverse=True, key=sortKey)
			while len(currentBeam) > mscale:
				currentBeam.pop(len(currentBeam)-1)
		if currentBeam[0].h>maxPoint.h:
			maxPoint = currentBeam[0]
	#print(maxPoint.x,maxPoint.y)
	#print(str(len(extendedPoints)))
	w.write(str(maxPoint.x)+"" ""+str(maxPoint.y)+""\n"")
else:
	w.write(str(n)+"" ""+str(m)+""\n"")
",cubic,"brute force,dfs and similar,shortest paths",3400
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))

# calc = datetime.datetime.now()
last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult
        # print(""par"", i, j)
        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)
            # print(""punto"", x, y)
            # print(""distancia"", d)
            md = min(md, d)
            # print(""min"", md)
        if md > maxd:
            # print(""max"", md)
            last_tree = (i, j)
            maxd = md
        # print("""")

# dif_calc = datetime.datetime.now() - calc
# print(""calcular"", dif_calc)
# print(""res"", last_tree)
with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")
",cubic,"brute force,dfs and similar,shortest paths",1046
"from queue import Queue
import datetime

with open(""input.txt"", 'r') as in_file:
    n, m = (int(i) for i in in_file.readline().split("" ""))
    k = int(in_file.readline())
    ints = [int(i) for i in in_file.readline().split("" "")]

pairs = []
for i in range(0, len(ints), 2):
    x = ints[i]
    y = ints[i+1]
    pairs.append((x, y))


last_tree = (1, 1)
maxd = 0
mult = m * n
for i in range(1, n+1):
    for j in range(1, m+1):
        md = mult
        # print(""par"", i, j)
        for pair in pairs:
            x, y = pair
            d = abs(i-x)+abs(j-y)
            # print(""punto"", x, y)
            # print(""distancia"", d)
            md = min(md, d)
            # print(""min"", md)
        if md > maxd:
            # print(""max"", md)
            last_tree = (i, j)
            maxd = md
        # print("""")

# print(""res"", last_tree)
with open(""output.txt"", 'w') as out_file:
    out_file.write(f""{last_tree[0]} {last_tree[1]}"")

	 		 	 			  		 		         		  	",cubic,"brute force,dfs and similar,shortest paths",972
"# https://codeforces.com/problemset/problem/35/C

from sys import stdin, exit
from typing import List, Tuple, Dict
from itertools import product


def distance(tree: Tuple[int, int], outbreak: Tuple[int, int]):
    return abs(tree[0] - outbreak[0]) + abs(tree[1] - outbreak[1])


def shorthest_path(tree: Tuple[int, int], outbreaks: List[Tuple[int, int]], min_dst: int):
    shorthest_path = float('inf')
    for outbreak in outbreaks:
        if shorthest_path < min_dst:
            break
        shorthest_path = min(shorthest_path, distance(tree, outbreak))
    return shorthest_path


input_f = open('input.txt', 'r')
output_f = open('output.txt', 'w')

N, M = [int(v) for v in input_f.readline().rstrip().split()]
input_f.readline()  # ignore
outbreaks_line = [int(v) for v in input_f.readline().rstrip().split()]
outbreaks = []
input_f.close()


for i in range(0, len(outbreaks_line) - 1, 2):
    outbreaks.append((outbreaks_line[i], outbreaks_line[i+1]))

last_tree = (1, 1)
best_dst = 0
for x, y in product(range(1, N + 1), range(1, M + 1)):
    path_len = shorthest_path((x, y), outbreaks, best_dst)
    if path_len > best_dst:
        last_tree = (x, y)
        best_dst = path_len

output_f.write(' '.join(map(str, last_tree)))
# print(' '.join(map(str, last_tree)))

output_f.close()
",cubic,"brute force,dfs and similar,shortest paths",1297
"import sys
from array import array  # noqa: F401
from itertools import product
from collections import deque


def input():
    with open('input.txt') as fp:
        return fp.readlines()


def output(ans: str):
    with open('output.txt', mode='w') as fp:
        fp.write(ans)


'''
def input():
    return [line.decode('utf-8') for line in sys.stdin.buffer.readlines()]


def output(ans):
    print(ans)
'''


s = input()
n, m = map(int, s[0].split())
k = int(s[1])
a = [[0] * m for _ in range(n)]
dq = deque()
line = list(map(lambda x: int(x) - 1, s[2].split()))
for i in range(0, 2 * k, 2):
    a[line[i]][line[i + 1]] = 1
    dq.append((line[i], line[i + 1]))


x, y = -1, -1
while dq:
    x, y = dq.popleft()
    for tx, ty in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):
        if 0 <= tx < n and 0 <= ty < m and not a[tx][ty]:
            a[tx][ty] = 1
            dq.append((tx, ty))

output(f'{x+1} {y+1}')
",cubic,"brute force,dfs and similar,shortest paths",924
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def matching(n,m,path):
    # Hopkrocft Karp O(EV^0.5)
    match1 = [-1]*n
    match2 = [-1]*m
    for node in range(n):
        for nei in path[node]:
            if match2[nei] == -1:
                match1[node] = nei
                match2[nei] = node
                break
    while 1:
        bfs = [node for node in range(n) if match1[node] == -1]
        depth = [-1]*n
        for node in bfs:
            depth[node] = 0

        for node in bfs:
            for nei in path[node]:
                next_node = match2[nei]
                if next_node == -1:
                    break
                if depth[next_node] == -1:
                    depth[next_node] = depth[node]+1
                    bfs.append(next_node)
            else:
                continue
            break
        else:
            break
        pointer = [len(c) for c in path]
        dfs = [node for node in range(n) if depth[node] == 0]
        while dfs:
            node = dfs[-1]
            while pointer[node]:
                pointer[node] -= 1
                nei = path[node][pointer[node]]
                next_node = match2[nei]
                if next_node == -1:
                    while nei != -1:
                        node = dfs.pop()
                        match2[nei],match1[node],nei = node,nei,match1[node]
                    break
                elif depth[node]+1 == depth[next_node]:
                    dfs.append(next_node)
                    break
            else:
                dfs.pop()
    return n-match1.count(-1)

def main():
    n,m = map(int,input().split())
    edg = [tuple(map(lambda xx:int(xx)-1,input().split())) for _ in range(m)]
    ans = float(""inf"")
    for centre in range(n):
        path = [[] for _ in range(n)]
        cost = 2*n-1
        extra = m
        for u,v in edg:
            if u == centre or v == centre:
                cost -= 1
                extra -= 1
            else:
                path[u].append(v)
        maxMatch = matching(n,n,path)
        extra -= maxMatch
        cost += n-1-maxMatch+extra
        ans = min(ans,cost)
    print(ans)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",cubic,graph matchings,3917
"import sys
from array import array

n = int(input())
edge = [list(map(int, input().split())) for _ in range(n)]
mod = 10**9 + 7

dp_f = [array('i', [-1])*n for _ in range(n)]
dp_g = [array('i', [-1])*n for _ in range(n)]


for i in range(n):
    dp_f[i][i] = dp_g[i][i] = 1
for i in range(n-1):
    dp_f[i][i+1] = dp_g[i][i+1] = 1 if edge[i][i+1] else 0


def f(l, r):
    if dp_f[l][r] != -1:
        return dp_f[l][r]

    dp_f[l][r] = g(l, r) if edge[l][r] else 0
    for m in range(l+1, r):
        if edge[l][m]:
            dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod

    return dp_f[l][r]


def g(l, r):
    if dp_g[l][r] != -1:
        return dp_g[l][r]

    dp_g[l][r] = f(l+1, r)
    for m in range(l+1, r):
        dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m+1, r)) % mod

    return dp_g[l][r]


print(f(0, n-1))",cubic,"dp,graphs",830
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def main():
    n,k = map(int,input().split())
    card = list(map(int,input().split()))
    fav = list(map(int,input().split()))
    joy = [0]+list(map(int,input().split()))
    dp = [[0]*(n*k+1) for _ in range(n+1)]
    for i in range(len(joy)):
        dp[1][i] = joy[i]
    for i in range(len(joy),n*k+1):
        dp[1][i] = joy[-1]
    for i in range(2,n+1):
        for j in range(1,n*k+1):
            for kk in range(min(k+1,j+1)):
                dp[i][j] = max(dp[i][j],dp[i-1][j-kk]+dp[1][kk])
    tot = [0]*(10**5+1)
    for i in card:
        tot[i] += 1
    tot1 = [0]*(10**5+1)
    for i in fav:
        tot1[i] += 1
    ans = 0
    for i in range(10**5+1):
        ans += dp[tot1[i]][tot[i]]
    print(ans)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",cubic,dp,2526
"# ---------------------------iye ha aam zindegi---------------------------------------------
import math
import random
import heapq,bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------game starts now----------------------------------------------------import math
class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1


class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):
        """"""
        Side effect!!! Changes node. Node should have exactly one child
        """"""
        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n


# -----------------------------------------------binary seacrh tree---------------------------------------
class SegmentTree1:
    def __init__(self, data, default=2**51, func=lambda a, b: a & b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------game starts now----------------------------------------------------import math
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a,b:max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


# --------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m


# --------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z


# --------------------------------------------------product----------------------------------------
def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por


# --------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count


# --------------------------------------------------binary----------------------------------------
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)


# --------------------------------------------------binary------------------------------------
for ik in range(1):
    n,k=map(int,input().split())
    cards=list(map(int,input().split()))
    l=list(map(int,input().split()))
    h=list(map(int,input().split()))
    h=[0]+h
    count=defaultdict(int)
    rt=defaultdict(int)
    def find(x,y):
        dp=[[0 for i in range(y+1)]for i in range(x+1)]
        for i in range(1,x+1):
            for j in range(y+1):
                for t in range(min(j+1,k+1)):
                    dp[i][j]=max(dp[i][j],dp[i-1][j-t]+h[t])
        return dp[x][y]
    for i in range(n*k):
        count[cards[i]]+=1
    for i in range(n):
        rt[l[i]]+=1
    ans=0
    for i in rt:
        if count[i]==0:
            continue
        ans+=find(rt[i],count[i])
    print(ans)",cubic,dp,17257
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#---------------------------------Lazy Segment Tree--------------------------------------
# https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp
class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)
 
        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]
 
        def prod(l, r):
            assert 0 <= l <= r <= _n
 
            if l == r:
                return _e
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)
 
            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1
 
            return _op(sml, smr)
 
        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)
 
            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2
 
            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)
 
        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])
 
        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])
 
        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id
 
        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)
 
        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply
 
 
MIL = 1 << 20
 
 
def makeNode(total, count):
    # Pack a pair into a float
    return (total * MIL) + count
 
 
def getTotal(node):
    return math.floor(node / MIL)
 
 
def getCount(node):
    return node - getTotal(node) * MIL
 
 
nodeIdentity = makeNode(0.0, 0.0)
 
 
def nodeOp(node1, node2):
    return node1 + node2
    # Equivalent to the following:
    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )
 
 
identityMapping = -1
 
 
def mapping(tag, node):
    if tag == identityMapping:
        return node
    # If assigned, new total is the number assigned times count
    count = getCount(node)
    return makeNode(tag * count, count)
 
 
def composition(mapping1, mapping2):
    # If assigned multiple times, take first non-identity assignment
    return mapping1 if mapping1 != identityMapping else mapping2
#-------------------------------------------------------------------------
prime = [True for i in range(10)] 
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n): 
          
        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p): 
                pp[i]+=1
                prime[i] = False
        p += 1
#---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res
#---------------------------------running code------------------------------------------
n,k= map(int,input().split(' '))
l= list(map(int,input().split(' ')))
f =list(map(int,input().split(' ')))
h=list(map(int,input().split(' ')))
d1=dict({(a,0) for a in f})
d2=dict({(a,0) for a in f})
for a in l:
	if(a in d1):d1[a]+=1
for a in f:
	d2[a]+=1
#print(d1,d2)
dp = [[0 for i in range(520*12)] for j in range(520)]
#print(len(dp), len(dp[0]))
for x in range(n+1):
	for y in range(n*k+1):
		for i in range(k+1):
				dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )
ss=0
for i in d1:
	#print(dp[d1[i]][d2[i]])
	ss+=dp[d2[i]][d1[i]]
print(ss)",cubic,dp,13222
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
c = list(map(int, input().split()))
f = list(map(int, input().split()))
h = [0] + list(map(int, input().split()))
cnt1 = defaultdict(lambda : 0)
for i in c:
    cnt1[i] += 1
cnt2 = defaultdict(lambda : 0)
for i in f:
    cnt2[i] += 1
ans = 0
for i in cnt2:
    c1, c2 = cnt1[i], cnt2[i]
    dp0 = [0]
    l = 1
    for _ in range(c2):
        dp = [0] * (l + k)
        for i in range(l):
            dp0i = dp0[i]
            for j in range(k + 1):
                dp[i + j] = max(dp[i + j], dp0i + h[j])
        l += k
        dp0 = dp
    ans += dp[min(c1, k * c2)]
print(ans)",cubic,dp,687
"from collections import Counter

n, k = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]
f = [int(x) for x in input().split()]
h = [0] + [int(x) for x in input().split()]

cnt_all = Counter(c)
cnt_fav = Counter(f)

ans = 0
for fi in cnt_fav:
    if fi not in cnt_all:
        continue
    m = cnt_fav[fi]
    t = min(cnt_all[fi], m * k)
    dp = [[0] * (t + 1) for _ in range(m + 1)]
    for x in range(1, m + 1):
        for s in range(0, t + 1):
            for ki in range(0, k + 1):
                if ki + s > t:
                    break
                dp[x][ki + s] = max(dp[x][ki + s], dp[x - 1][s] + h[ki])
    ans += dp[m][t]
print(ans)",cubic,dp,670
"import math
from collections import defaultdict


def main():
    n, k = map(int, input().split())
    cards = list(map(int, input().split()))
    fav = list(map(int, input().split()))

    h = [0] + list(map(int, input().split()))

    cards_cnt = defaultdict(int)
    for val in cards:
        cards_cnt[val] += 1

    players_fav_cnt = defaultdict(int)
    for val in fav:
        players_fav_cnt[val] += 1

    # dp[a][b] - a players, b favourite cards (in total)
    dp = [[0 for _ in range(k*n+k+1)] for _ in range(n+1)]
    for p in range(n):
        for c in range(k*n+1):
            for hand in range(k+1):
                dp[p+1][c+hand] = max(dp[p+1][c+hand], dp[p][c] + h[hand])

    res = 0
    for f in players_fav_cnt:
        res += dp[players_fav_cnt[f]][cards_cnt[f]]

    print(res)


if __name__ == '__main__':
    main()
",cubic,dp,843
"def func():
    N = 520
    K = 12
    C = 100 * 1000 + 11
    n, k = [int(x) for x in list(raw_input().split(' '))]
    c = [0 for _ in range(C)]
    f = [0 for _ in range(C)]

    dp = [[0 for _ in range(K*(N))] for _ in range(N)]

    a = [int(x) for x in list(raw_input().split(' '))]
    for x in a:
        c[x] += 1

    b = [int(x) for x in list(raw_input().split(' '))]
    for x in b:
        f[x] += 1

    h = [0]+[int(x) for x in list(raw_input().split(' '))]

    for i in range(n):
        for j in range(n*k + 1):
            for cur in range(k+1):
                dp[i + 1][j + cur] = max(dp[i + 1][j + cur], dp[i][j] + h[cur])

    ans = 0
    for i in range(C):
        if f[i] != 0:
            ans += dp[f[i]][c[i]]

    return ans


if __name__ == ""__main__"":
    print(func())
",cubic,dp,800
"def solve():
    n, k = map(int, input().split())
    c = list(map(int, input().split()))
    f = list(map(int, input().split()))
    h = list(map(int, input().split()))
    cnt = {}
    for i in c:
        cnt[i] = cnt.get(i, 0) + 1
    likecolor = {}
    for i in range(n):
        likecolor.setdefault(f[i], []).append(i)
        cnt[f[i]] = cnt.get(f[i], 0)
    ans = 0
    for key, v in likecolor.items():
        n1 = len(v)
        if cnt[key] >= n1 * k:
            ans += n1 * h[k - 1]
            continue
        dp = [[-float(""INF"")] * (cnt[key]+1) for _ in range(n1 + 1)]
        dp[0][0] = 0
        for i in range(n1):
            j = i + 1
            for e in range(cnt[key] + 1):
                dp[j][e] = max(dp[j][e], dp[i][e])
                for w in range(e + 1, min(cnt[key] + 1, e + k + 1)):
                    dp[j][w] = max(dp[i][e] + h[w - e - 1], dp[j][w])
        ans += dp[n1][cnt[key]]
    print(ans)


solve()
",cubic,dp,945
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

# ------------------------------
# f = open('./input.txt')
# sys.stdin = f

def main():
    n, k = RL()
    cds = RLL()
    fn = RLL()
    sc = [0]+RLL()

    rec = set(fn)
    uses = 0
    dic = defaultdict(int)
    for i in cds:
        if i in rec:
            dic[i]+=1
            uses+=1

    dp = [[0]*(n*k+1) for _ in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, n*k+1):
            for l in range(k+1):
                if l>j: break
                val = sc[l]
                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)
    res = 0

    for i, v in Counter(fn).items():
        res+=dp[v][dic[i]]
    # for i in dp: print(i)
    print(res)

if __name__ == ""__main__"":
    main()

",cubic,dp,3016
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

# ------------------------------
# f = open('./input.txt')
# sys.stdin = f

def main():
    n, k = RL()
    cds = RLL()
    fn = RLL()
    sc = [0]+RLL()

    rec = set(fn)
    uses = 0
    dic = defaultdict(int)
    for i in cds:
        if i in rec:
            dic[i]+=1
            uses+=1

    dp = [[0]*(uses+1) for _ in range(n+1)]

    for i in range(1, n+1):
        for j in range(1, uses+1):
            for l in range(k+1):
                if l>j: break
                val = sc[l]
                dp[i][j] = max(dp[i][j], dp[i-1][j-l]+val)
    res = 0

    for i, v in Counter(fn).items():
        res+=dp[v][dic[i]]
    # for i in dp: print(i)
    print(res)

if __name__ == ""__main__"":
    main()

",cubic,dp,3018
"n,k= map(int,input().split(' '))
l= list(map(int,input().split(' ')))
f =list(map(int,input().split(' ')))
h=list(map(int,input().split(' ')))
d1=dict({(a,0) for a in f})
d2=dict({(a,0) for a in f})
for a in l:
	if(a in d1):d1[a]+=1
for a in f:
	d2[a]+=1
#print(d1,d2)
dp = [[0 for i in range(520*12)] for j in range(520)]
#print(len(dp), len(dp[0]))
for x in range(n+1):
	for y in range(n*k+1):
		for i in range(k+1):
				dp[x+1][y+i] = max(dp[x+1][y+i],+dp[x][y]+(0 if i==0 else h[i-1]) )
ss=0
for i in d1:
	#print(dp[d1[i]][d2[i]])
	ss+=dp[d2[i]][d1[i]]
print(ss)",cubic,dp,566
"import sys
from array import array  # noqa: F401
import typing as Tp  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def main():
    l, r, k = map(int, input().split())

    valid_bits, is_valid_bits = [], [0] * 1024

    for bit in range(1024):
        if bin(bit).count('1') <= k:
            valid_bits.append(bit)
            is_valid_bits[bit] = 1

    mod = 998244353

    def solve(ub):
        dp = array('i', [0]) * 1024
        dp_cnt = array('i', [0]) * 1024
        next_dp = array('i', [0]) * 1024
        next_dp_cnt = array('i', [0]) * 1024
        boundary_dp, b_bit = 0, 0

        for e, digit in zip(range(len(str(ub)) - 1, -1, -1), map(int, str(ub))):
            base = pow(10, e, mod)

            for bit in valid_bits:
                for d in range(10):
                    nextbit = bit | (1 << d)
                    if is_valid_bits[nextbit]:
                        next_dp[nextbit] = (
                            next_dp[nextbit] + dp[bit]
                            + base * d * dp_cnt[bit]
                        ) % mod

                        next_dp_cnt[nextbit] += dp_cnt[bit]
                        if next_dp_cnt[nextbit] >= mod:
                            next_dp_cnt[nextbit] -= mod

            for d in range(digit):
                nextbit = b_bit | (1 << d)
                if is_valid_bits[nextbit]:
                    next_dp[nextbit] = (
                        next_dp[nextbit] + boundary_dp + base * d
                    ) % mod
                    next_dp_cnt[nextbit] += 1

            b_bit |= (1 << digit)
            boundary_dp = (boundary_dp + base * digit) % mod

            for i in valid_bits:
                dp[i] = next_dp[i]
                dp_cnt[i] = next_dp_cnt[i]
                next_dp[i] = next_dp_cnt[i] = 0

            dp[0], dp_cnt[0] = 0, 1
            dp[1] = dp_cnt[1] = 0

        return (sum(dp) + (boundary_dp if is_valid_bits[b_bit] else 0)) % mod

    # print(solve(r), solve(l - 1))
    print((solve(r) - solve(l - 1)) % mod)


if __name__ == '__main__':
    main()
",cubic,"bitmasks,combinatorics,dp,math",2096
"


l, r, k =map(int,input().split())

d = {i:2**i for i in range(10)}

cache = {}

def can(i, m):
    return d[i] & m

def calc(m):
    b = 1
    c = 0
    for i in range(10):
        if b & m:
            c += 1
        b *= 2

    return c

def sm(ln, k, m, s='', first=False):
    if ln < 1:
        return 0, 1

    if (ln, k, m, s, first) in cache:
        return cache[(ln, k, m, s, first)]

    ans = 0
    count = 0
    base = 10 ** (ln-1)

    use_new = calc(m) < k

    if s:
        finish = int(s[0])+1
    else:
        finish = 10

    for i in range(finish):
        if use_new or can(i, m):
            ss = s[1:]
            if i != finish-1:
                ss = ''
            nm = m | d[i]
            nfirst = False
            if i == 0 and first:
                nm = m
                nfirst = True
            nexta, nextc = sm(ln-1, k, nm, ss, nfirst)
            ans += base * i * nextc + nexta
            count += nextc

#    print(ln, k, m, s, first, ans, count)
    cache[(ln, k, m, s, first)] = (ans, count)

    return ans, count

def call(a, k):
    s = str(a)
    return sm(len(s), k, 0, s, True)[0]


#print((call(r, k) - call(l-1, k)))
print((call(r, k) - call(l-1, k)) % 998244353)
",cubic,"bitmasks,combinatorics,dp,math",1220
"
MOD = 998244353


def pop_count(x) :
    ans = 0
    while (x > 0) :
        ans = ans + x % 2
        x = x // 2
    return ans

def check(x, k) :
    mask = 0
    nx = int(x)
    while (nx > 0) :
        mask = mask | (1 << (nx % 10))
        nx = nx // 10
    if (pop_count(mask) <= k) :
        return x
    return 0

pop = []
p10 = []
f = [[0 for j in range(1 << 10)] for i in range(20)]
w = [[0 for j in range(1 << 10)] for i in range(20)]
def prepare() : 
    p10.append(1)
    for i in range(20) :
        p10.append(p10[i] * 10 % MOD)
    for i in range(1 << 10) :
        pop.append(pop_count(i))
    w[0][0] = 1
    for i in range(1, 20) :
        for j in range(1 << 10) :
            for use in range(10) : 
                w[i][j | (1 << use)] = (w[i][j | (1 << use)] + w[i - 1][j]) % MOD
                f[i][j | (1 << use)] = (f[i][j | (1 << use)] + w[i - 1][j] * use * p10[i - 1] + f[i - 1][j]) % MOD

def solve(x, k) :
    sx = [int(d) for d in str(x)] 
    n = len(sx) 
    ans = 0
    for i in range(1, n) :
        for use in range(1, 10) :
            for mask in range(1 << 10) : 
                if (pop[(1 << use) | mask] <= k) :
                    ans = (ans + f[i - 1][mask] + use * w[i - 1][mask] % MOD * p10[i - 1]) % MOD
    cmask = 0
    csum = 0
    for i in range(n) :
        cdig = sx[i]
        for use in range(cdig) : 
            if (i == 0 and use == 0) :
                continue
            nmask = cmask | (1 << use)
            for mask in range(1 << 10) : 
                if (pop[nmask | mask] <= k) :
                    ans = (ans + f[n - i - 1][mask] + (csum * 10 + use) * w[n - i - 1][mask] % MOD * p10[n - i - 1]) % MOD
        cmask |= 1 << cdig
        csum = (10 * csum + cdig) % MOD
    return ans

prepare()
l, r, k = map(int, input().split())
ans = (check(r, k) + solve(r, k) - solve(l, k) + MOD) % MOD
print(ans)
    
",cubic,"bitmasks,combinatorics,dp,math",1878
"import sys

mod = 998244353
MAX_LENGTH = 20
bound = [0] * MAX_LENGTH

def mul(a, b): return (a * b) % mod
def add(a, b):
    a += b
    if a < 0: a += mod
    if a >= mod: a -= mod
    return a

def digitize(num):
    for i in range(MAX_LENGTH):
        bound[i] = num % 10
        num //= 10

def rec(smaller, start, pos, mask):
    global k
    if bit_count[mask] > k:
        return [0, 0]
    if pos == -1:
        return [0, 1]

    # if the two following lines are removed, the code reutrns correct results
    if dp[smaller][start][pos][mask][0] != -1:
        return dp[smaller][start][pos][mask]

    res_sum = res_ways = 0
    for digit in range(0, 10):
        if smaller == 0 and digit > bound[pos]:
            continue
        new_smaller = smaller | (digit < bound[pos])
        new_start = start | (digit > 0) | (pos == 0)
        new_mask = (mask | (1 << digit)) if new_start == 1 else 0

        cur_sum, cur_ways = rec(new_smaller, new_start, pos - 1, new_mask)
        res_sum = add(res_sum, add(mul(mul(digit, ten_pow[pos]), cur_ways), cur_sum))
        res_ways = add(res_ways, cur_ways)

    dp[smaller][start][pos][mask][0], dp[smaller][start][pos][mask][1] = res_sum, res_ways
    return dp[smaller][start][pos][mask]

def solve(upper_bound):
    global dp
    dp = [[[[[-1, -1] for _ in range(1 << 10)] for _ in range(MAX_LENGTH)] for _ in range(2)] for _ in range(2)]
    digitize(upper_bound)
    ans = rec(0, 0, MAX_LENGTH - 1, 0)
    return ans[0]

inp = [int(x) for x in sys.stdin.read().split()]
l, r, k = inp[0], inp[1], inp[2]

bit_count = [0] * (1 << 10)
for i in range(1, 1 << 10): bit_count[i] = bit_count[i & (i - 1)] + 1
ten_pow = [1]
for i in range(MAX_LENGTH): ten_pow.append(mul(ten_pow[-1], 10))

print(add(solve(r), -solve(l - 1)))
",cubic,"bitmasks,combinatorics,dp,math",1776
"import sys
class Graph:
    verticies = {}
    nodesCount = 0

    class Vertex:
        def __init__(self, label, endPoint=None):
            self.label = label
            self.edges = []
            self.visitedToken = 0
            self.endPoint = endPoint

    class Edge:
        residual = None

        def __init__(self, from_, to_, isResidual, maxCapacity):
            self.from_ = from_
            self.to_ = to_
            self.isResidual = isResidual
            self.capacity = maxCapacity
            self.flow = 0

        def augment(self, bootleneck):
            self.flow += bootleneck
            self.residual.flow -= bootleneck

        def remainingCapacity(self):
            return self.capacity - self.flow

    def addEdge(self, from_, to_, capacity):
        from_ = self.verticies[from_]
        to_ = self.verticies[to_]
        if from_.endPoint and from_.endPoint != to_:
            from_ = from_.endPoint

        main = self.Edge(from_, to_, False, capacity)
        residual = self.Edge(to_, from_, True, 0)

        main.residual = residual
        residual.residual = main

        from_.edges.append(main)
        to_.edges.append(residual)

    def addVertex(self, label, *args):
        self.nodesCount += 1
        self.verticies[label] = self.Vertex(label)

    def maxFlow(self, f, t):
        f = self.verticies[f]
        t = self.verticies[t]
        visitedToken = 1
        flow = 0

        def dfs(node, bootleneck=sys.maxsize):
            node.visitedToken = visitedToken
            bootleneck_backup = bootleneck

            if node == t:
                return bootleneck

            for edge in node.edges:
                if edge.remainingCapacity() == 0 or edge.to_.visitedToken == visitedToken:
                    continue

                bootleneck = dfs(edge.to_, min(
                    bootleneck, edge.remainingCapacity()))
                if bootleneck:
                    edge.augment(bootleneck)
                    return bootleneck
                else:
                    bootleneck = bootleneck_backup

            return 0

        while True:
            bootleneck = dfs(f)
            # print(bootleneck)
            if not bootleneck:
                break

            flow += bootleneck
            visitedToken += 1

        return flow


g = Graph()

n, m = map(int, input().split())
vv = list(map(int, input().split()))


for i in range(n+m+2):
    g.addVertex(i)

for i, v in enumerate(vv):
    g.addEdge(m+i+1, n+m+1, v)


s = 0

for i in range(1, m+1):
    a, b, c = map(int, input().split())
    s += c

    g.addEdge(0, i, c)
    g.addEdge(i, a+m, c)
    g.addEdge(i, b+m, c)


print(s-g.maxFlow(0, n+m+1))
",cubic,"flows,graphs",2705
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	while (len(q)>0):
		x=q[0]
		del(q[0])
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",cubic,"flows,graphs",1209
"class edge(object):
	def __init__(self,ne,to,fl):
		self.ne=ne
		self.to=to
		self.fl=fl

def add(x,y,z):
	global tot
	tot+=1
	e.append(edge(he[x],y,z))
	he[x]=tot

def addedge(x,y,z):
	add(x,y,z)
	add(y,x,0)

def bfs():
	global deep
	deep=[0 for i in range(T+1)]
	q=[]
	q.append(S)
	deep[S]=1
	lp=0
	while (len(q)>lp):
		x=q[lp]
		lp+=1
		i=he[x]
		while (i):
			y=e[i].to
			if ((deep[y]==0)and(e[i].fl!=0)):
				deep[y]=deep[x]+1
				q.append(y)
			i=e[i].ne
	return deep[T]!=0

def dfs(x,flow):
	global deep
	if ((x==T)or(flow==0)):
		return flow
	used=0
	i=he[x]
	while (i):
		y=e[i].to
		if ((deep[y]==deep[x]+1)and(e[i].fl!=0)):
			now=dfs(y,min(flow-used,e[i].fl))
			used+=now
			e[i].fl-=now
			e[i^1].fl+=now
			if (flow==used):
				break;
		i=e[i].ne
	if (used==0):
		deep[x]=-1
	return used

def dinic():
	res=0
	while (bfs()):
		res+=dfs(S,INF)
	return res

n,m=map(int,input().split())
ans=0
weight=[0]+list(map(int,input().split()))

e=[0,0]
tot=1
S=n+m+1
T=S+1
he=[0 for i in range(T+1)]
INF=1000000007#只要>10^9就足够了

for i in range(1,n+1):
	addedge(S,i,weight[i]);
for i in range(1,m+1):
	x,y,w=map(int,input().split())
	addedge(n+i,T,w)
	addedge(x,n+i,INF)
	addedge(y,n+i,INF)
	ans+=w
ans-=dinic()
print(ans)",cubic,"flows,graphs",1225
"from collections import deque

def addedge(u, v, value):
	global e
	a = [v, value, None]
	b = [u, 0, a]
	a[2] = b
	e[u].append(a)
	e[v].append(b)
	

inf = 2 * (10 ** 12)
ans = 0
n, m = map(int, input().split())
e = [[] for i in range(n + m + 2)]
a = tuple(map(int, input().split()))
S, T = 0, m + n + 1
for i in range(1, m + 1):
	u, v, w = map(int, input().split())
	ans += w
	addedge(i, u + m, inf)
	addedge(i, v + m, inf)
	addedge(S, i, w)
for i in range(m + 1, T):
	addedge(i, T, a[i - m - 1])
# for i in range(n + m + 2):
# 	for edge in e[i]:
# 		print('%d to %d w %d' % (i, edge[0] if edge[0] <= m else edge[0] - m, edge[1]))

lvl = None
def bfs():
	global e, lvl
	lvl = [0] * (n + m + 2)
	q = deque([0])
	while q:
		node = q.popleft()
		# print('node = %d' % node)
		for edge in e[node]:
			if edge[0] != 0 and lvl[edge[0]] == 0 and edge[1]:
				lvl[edge[0]] = lvl[node] + 1
				q.append(edge[0])
	# print(lvl)


def dfs(node, maxdelta):
	global e, lvl
	if node == T:
		return maxdelta
	delta = 0
	for edge in e[node]:
		if lvl[edge[0]] == lvl[node] + 1 and edge[1]:
			tmp = dfs(edge[0], min(maxdelta, edge[1]))
			if tmp > 0:
				edge[1] -= tmp
				edge[2][1] += tmp
				maxdelta -= tmp
				delta += tmp
			if maxdelta == 0:
				break
	return delta

flow = 0
while 1:
	bfs()
	tmp = dfs(0, inf)
	if tmp == 0:
		break
	flow += tmp
ans -= flow
print(ans)





",cubic,"flows,graphs",1365
"c = [[0 for i in range(5205)] for j in range(5205)]
K = 998244353
inv = [0 for i in range(5205)]

def mu(a, n):
	if n == 0: return 1
	q = mu(a, n // 2)
	if n % 2 == 0:
		return q * q % K
	else: return q * q % K * a % K

def calc(m, d, S):
	res = 0
	if m == 0:
		if S == 0: return 1
		return 0

	for u in range(0, m + 1):
		if (u * d > S): break
		U = c[m][u] * c[S - u * d + m - 1][m - 1] % K 
		if u % 2 == 0:
			res = (res + U) % K
		else: res = (res - U + K) % K 
	return res


c[0][0] = 1
inv[0] = 1
for i in range(1, 5101):
	inv[i] = mu(i, K - 2)

for i in range(1, 5101):
	c[i][0] = 1
	for j in range (1, i):
		c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % K
	c[i][i] = 1

p, s, r = map(int, input().split())

res = 0
den = 0

for i in range(1, p + 1):
	A = 0
	for d in range(r, s // i + 1):
		if (i < p): A = (A + calc(p - i, d, s - d * i)) % K
		else:
			if (s - i * d == 0): A += 1
	A = A * inv[i] % K
	res = (res + A * c[p - 1][i - 1] % K) % K

den = c[s - r + p - 1][p - 1]
res = res * mu(den, K - 2) % K
print(res)


",cubic,"combinatorics,dp,math,probabilities",1027
"base=998244353;
def power(x, y):
    if(y==0):
        return 1
    t=power(x, y//2)
    t=(t*t)%base
    if(y%2):
        t=(t*x)%base
    return t;
def inverse(x):
    return power(x, base-2)
f=[1]
iv=[1]
for i in range(1, 5555):
    f.append((f[i-1]*i)%base)
    iv.append(inverse(f[i]))
def C(n, k):
    return (f[n]*iv[k]*iv[n-k])%base
def candy(n, k):
    # print(n, k)
    return C(n+k-1, k-1)
def count_game(k, n, x): #k players, n points total, no player can have x point or more
    if(k==0):
        if(n==0):
            return 1
        else:
            return 0
    ans=0
    for i in range(0, k+1):
        t=n-x*i
        # print(i, C(k, i))
        if(t<0):
            break
        if(i%2):
            ans=(ans-C(k, i)*candy(t, k))%base
        else:
            ans=(ans+C(k, i)*candy(t, k))%base 
    return ans
p, s, r= list(map(int, input().split()))
gamesize=count_game(p, s-r, int(1e18))
gamesize=inverse(gamesize)
ans=0;
for q in range(r, s+1):
    for i in range(0, p): #exactly i people have the same score
        t=s-(i+1)*q
        if(t<0):
            break
        # print(q, i, count_game(p-i-1, t, q));
        ans=(ans+C(p-1, i)*count_game(p-i-1, t, q)*gamesize*inverse(i+1))%base
print(ans)
        
    ",cubic,"combinatorics,dp,math,probabilities",1243
"from sys import stdin
MOD = 1000000007
s = stdin.readline().strip()
n = len(s)
buc = [0] * 101
fac = [0] * (n + 1)
inv = [0] * (n + 1)
dp = [0] * (n + 1)
# temp_dp = [0] * (n+1)
ans = [[0] * 55 for _ in range(55)]


def find(c: 'str') -> 'int':
    if 'A' <= c <= 'Z':
        return ord(c) - ord('A') + 26
    else:
        return ord(c) - ord('a')


# c = Counter(s)

# # store frequency
# for k in c.keys():
#     buc[find(k)] = c[k]

for i in s:
    buc[find(i)] += 1

# compute factorial and inv

fac[0] = 1
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % MOD
inv[n] = pow(fac[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv[i] = (inv[i + 1] * (i + 1)) % MOD

num = pow(fac[n // 2], 2, MOD)
for i in range(0, 52):
    num = (num * inv[buc[i]]) % MOD

dp[0] = 1

for i in range(0, 52):
    if not buc[i]:
        continue
    for j in range(n, buc[i] - 1, -1):
        dp[j] += dp[j - buc[i]]
        if dp[j] >= MOD:
            dp[j] -= MOD
for i in range(52):
    ans[i][i] = dp[n // 2]

for i in range(52):
    if not buc[i]:
        continue
    temp_dp = dp.copy()
    for k in range(buc[i], n + 1):
        temp_dp[k] -= temp_dp[k - buc[i]]
        if temp_dp[k] < 0:
            temp_dp[k] += MOD

    for j in range(i + 1, 52):
        if not buc[j]:
            continue
        for k in range(buc[j], n + 1):
            temp_dp[k] -= temp_dp[k - buc[j]]
            if temp_dp[k] < 0:
                temp_dp[k] += MOD
        ans[i][j] = (2 * temp_dp[n // 2]) % MOD

        for k in range(n, buc[j] - 1, -1):
            temp_dp[k] += temp_dp[k - buc[j]]
            if temp_dp[k] >= MOD:
                temp_dp[k] -= MOD

q = int(input())
l = stdin.read().splitlines()
for i in l:
    x, y = map(int, i.split())
    l, r = find(s[x - 1]), find(s[y - 1])
    if l > r:
        l, r = r, l
    print(num * ans[l][r] % MOD)
",cubic,"combinatorics,dp,math",1860
"from sys import stdin
MOD = 1000000007
s = stdin.readline().strip()
n = len(s)
buc = [0] * 101
fac = [0] * (n + 1)
inv = [0] * (n + 1)
dp = [0] * (n + 1)
# temp_dp = [0] * (n+1)
ans = [[0] * 55 for _ in range(55)]


def find(c: 'str') -> 'int':
    if 'A' <= c <= 'Z':
        return ord(c) - ord('A') + 26
    else:
        return ord(c) - ord('a')


def add(a: 'int', b: 'int') -> 'int':
    a += b
    if a >= MOD:
        a -= MOD
    return a


def sub(a: 'int', b: 'int') -> 'int':
    a -= b
    if a < 0:
        a += MOD
    return a


# c = Counter(s)

# # store frequency
# for k in c.keys():
#     buc[find(k)] = c[k]

for i in s:
    buc[find(i)] += 1  # naive count is fater than counter

# compute factorial and inv

fac[0] = 1
for i in range(1, n + 1):
    fac[i] = (fac[i - 1] * i) % MOD
inv[n] = pow(fac[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv[i] = (inv[i + 1] * (i + 1)) % MOD

num = pow(fac[n // 2], 2, MOD)
for i in range(0, 52):
    num = (num * inv[buc[i]]) % MOD

dp[0] = 1

for i in range(0, 52):
    if not buc[i]:
        continue
    for j in range(n, buc[i] - 1, -1):
        dp[j] = add(dp[j], dp[j - buc[i]])

for i in range(52):
    ans[i][i] = dp[n // 2]

for i in range(52):
    if not buc[i]:
        continue
    temp_dp = dp.copy()
    for k in range(buc[i], n + 1):
        temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[i]])

    for j in range(i + 1, 52):
        if not buc[j]:
            continue
        for k in range(buc[j], n + 1):
            temp_dp[k] = sub(temp_dp[k], temp_dp[k - buc[j]])

        ans[i][j] = (2 * temp_dp[n // 2]) % MOD

        for k in range(n, buc[j] - 1, -1):
            temp_dp[k] = add(temp_dp[k], temp_dp[k - buc[j]])

q = int(input())
l = stdin.read().splitlines()
for i in l:
    x, y = map(int, i.split())
    l, r = find(s[x - 1]), find(s[y - 1])
    if l > r:
        l, r = r, l
    print(num * ans[l][r] % MOD)
",cubic,"combinatorics,dp,math",1911
"from collections import defaultdict
n = int(input())
a = list(map(int, input().split()))

rec = defaultdict(list)
for j in range(n):
    for k in range(j, n):
        rec[sum(a[j:k + 1])].append((j, k))

ans = []
for k in rec.keys():
    tmp = []
    rec[k] = sorted(rec[k], key=lambda x: x[1])
    pre = -1
    for a, b in rec[k]:
        if pre >= a:
            continue
        else:
            tmp.append((a + 1, b + 1))
            pre = b
    if len(tmp) > len(ans):
        ans = tmp

print(len(ans))
for a, b in ans:
    print(a, b)",cubic,"data structures,greedy",542
"'''input
3 2
1 2 1
3 4
'''
from sys import stdin, setrecursionlimit
from bisect import bisect_right

setrecursionlimit(15000)


def get_gdict(arr):
	gdict = dict()
	for i in range(len(arr)):
		if arr[i] in gdict:
			gdict[arr[i]] += 1
		else:
			gdict[arr[i]] = 1
	return gdict


def initial_check(barr, garr):
	for i in garr:
		if i < barr[-1]:
			return False
	return True


# main starts
n, m = list(map(int, stdin.readline().split()))
barr = list(map(int, stdin.readline().split()))
garr = list(map(int, stdin.readline().split()))
barr.sort()
garr.sort()
ans = 0
gdict = get_gdict(garr)
if initial_check(barr, garr):
	count  = m
	b = n - 1
	g = m - 1
	while count  > 0:
		tempb = [barr[b]] * (m)
		
		for i in range(len(tempb)):
			if count <= 0:
				for j in range(i, m):
					ans += tempb[b]
				break

			if tempb[i] in gdict:
				gdict[tempb[i]] -= 1
				ans += (tempb[i])
				count -= 1
				if gdict[tempb[i]] == 0:
					del gdict[tempb[i]]
			else:
				if i == 0:	
					ans += (tempb[i])
					continue
				for k in range(g, -1, -1):
					if garr[k] in gdict:
						ans += garr[g]
						g = k - 1
						count -= 1
						break
				
				
		b -= 1

	while b >= 0:
		ans += m * (barr[b])
		b -= 1
	print(ans)

else:
	print(-1)",cubic,"greedy,implementation,math",1231
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase
from math import inf,isinf

def solve(s,t):
    if len(t) == 1:
        if s.count(t[0]):
            return 'YES'
        return 'NO'
    for i in range(1,len(t)):
        dp = [[-inf]*(i+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for j in range(len(s)):
            dp[j+1] = dp[j][:]
            for k in range(i+1):
                if k != i and s[j] == t[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])
                if dp[j][k]+i != len(t) and not isinf(dp[j][k]) and s[j] == t[dp[j][k]+i]:
                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)
        # print(*dp,sep='\n')
        # print('-----')
        for l in range(len(s)+1):
            if dp[l][-1] == len(t)-i:
                return 'YES'
    return 'NO'

def main():
    for _ in range(int(input())):
        s = input().strip()
        t = input().strip()
        print(solve(s,t))

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",cubic,"dp,strings",2695
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def solve(s,t):
    if len(t) == 1:
        if s.count(t[0]):
            return 'YES'
        return 'NO'
    for i in range(1,len(t)):
        dp = [[-1000]*(i+1) for _ in range(len(s)+1)]
        dp[0][0] = 0
        for j in range(len(s)):
            dp[j+1] = dp[j][:]
            for k in range(i+1):
                if k != i and s[j] == t[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1],dp[j][k])
                if abs(dp[j][k]+i) < len(t) and s[j] == t[dp[j][k]+i]:
                    dp[j+1][k] = max(dp[j+1][k],dp[j][k]+1)
        for l in range(len(s)+1):
            if dp[l][-1] == len(t)-i:
                return 'YES'
    return 'NO'

def main():
    for _ in range(int(input())):
        s = input().strip()
        t = input().strip()
        print(solve(s,t))

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",cubic,"dp,strings",2594
"from sys import stdin, stdout


def solve(s1, s2, next):
    # i => s1, j => s2
    dp = [[INF for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]
    dp[0][0] = 0
    for i in range(len(s1)+1):
        for j in range(len(s2)+1):
            if dp[i][j] == INF:
                continue

            if i < len(s1) and dp[i][j] < len(next) and next[dp[i][j]][ord(s1[i]) - ord('a')] < INF:
                dp[i+1][j] = min(dp[i+1][j], next[dp[i][j]][ord(s1[i]) - ord('a')] + 1)
            if j < len(s2) and dp[i][j] < len(next) and next[dp[i][j]][ord(s2[j]) - ord('a')] < INF:
                dp[i][j+1] = min(dp[i][j+1], next[dp[i][j]][ord(s2[j]) - ord('a')] + 1)

    return dp[len(s1)][len(s2)]


INF = 1e20
T = int(stdin.readline())
for _ in range(T):
    s = stdin.readline().strip()
    rs = stdin.readline().strip()
    next = [[INF for _ in range(26)] for _ in range(len(s))]

    for i in range(len(s)-1, -1, -1):
        if i < len(s)-1:
            for j in range(26):
                next[i][j] = next[i+1][j]
        next[i][ord(s[i]) - ord('a')] = i

    found = False

    if len(rs) == 1:
        if rs in s:
            found = True
    else:
        for p in range(1, len(rs)):
            s1 = rs[:p]
            s2 = rs[p:]

            if solve(s1, s2, next) < INF:
                found = True
                break

    if found:
        stdout.write('YES\n')
    else:
        stdout.write('NO\n')

",cubic,"dp,strings",1426
"def main():
    T = int(input().strip())
    for _ in range(T):
        s = input().strip()
        t = input().strip()
        n = len(s)
        
        find = [[n] * 26 for _ in range(n + 2)]
        for i in range(n - 1, -1, -1):
            find[i][:] = find[i + 1]
            find[i][ord(s[i]) - ord(""a"")] = i

        def interleaving(a, b):
            dp = [n] * (len(b) + 1)
            for i in range(len(a) + 1):
                for j in range(len(b) + 1):
                    if i == j == 0:
                        dp[j] = -1
                        continue
                    res = n
                    if i > 0:
                        res = min(res, find[dp[j] + 1][ord(a[i - 1]) - ord(""a"")])
                    if j > 0:
                        res = min(res, find[dp[j - 1] + 1][ord(b[j - 1]) - ord(""a"")])
                    dp[j] = res
            return dp[-1] < n

        if any(interleaving(t[:i], t[i:]) for i in range(len(t))):
            print(""YES"")
        else:
            print(""NO"")


main()
",cubic,"dp,strings",1033
"# -*- coding: utf-8 -*-

import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
# sys.setrecursionlimit(10 ** 9)
INF = 10 ** 18
MOD = 10 ** 9 + 7

def check(x):
    T1 = T[:x] + '*'
    T2 = T[x:] + '*'
    m1 = len(T1)
    m2 = len(T2)

    dp = list2d(N+1, m1, -1)
    dp[0][0] = 0
    for i in range(N):
        s = S[i]
        for j in range(m1):
            k = dp[i][j]
            if k != -1:
                dp[i+1][j] = max(dp[i+1][j], k)
                if T1[j] == s:
                    dp[i+1][j+1] = max(dp[i+1][j+1], k)
                if T2[k] == s:
                    dp[i+1][j] = max(dp[i+1][j], k+1)
    return dp[N][m1-1] == m2-1

for _ in range(INT()):
    S = input()
    T = input()

    N = len(S)
    M = len(T)
    for x in range(M):
        if check(x):
            YES()
            break
    else:
        NO()
",cubic,"dp,strings",1374
"#!/usr/bin/env python3
import sys
input = sys.stdin.readline

t = int(input())
for _ in range(t):
    s = list(input().rstrip())
    t = input().rstrip()
    ok = False
    for i in range(len(t)):
        t1 = list(t[:i]) + [""#""]
        t2 = list(t[i:]) + [""#""] 
        # dp[seen i-th index][match j in front] = match in back
        dp = [[-1] * (len(t) + 1) for _ in range(len(s) + 1)]
        dp[0][0] = 0
        for j, ch in enumerate(s):
            for k in range(len(t1)):
                if dp[j][k] == -1:
                    continue
                dp[j+1][k] = max(dp[j+1][k], dp[j][k])
                if ch == t1[k]:
                    dp[j+1][k+1] = max(dp[j+1][k+1], dp[j][k])
                if ch == t2[dp[j][k]]:
                    dp[j+1][k] = max(dp[j+1][k], dp[j][k] + 1)
        for k in range(len(t) + 1):
            if dp[len(s)][k] + k >= len(t):
                ok = True

    if ok:
        print(""YES"")
    else:
        print(""NO"")",cubic,"dp,strings",967
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

def solve2(s, t, left, right):
    n = len(s)
    m = len(t)
    nuxt = [-1]*(left+1)
    nuxt[0] = 0

    for i in range(n):
        for j in reversed(range(left+1)):
            k = nuxt[j]
            if k == -1:
                continue
            if j != left:
                if s[i] == t[j]:
                    nuxt[j+1] = max(nuxt[j+1], k)
            if k != right:
                if s[i] == t[left+k]:
                    nuxt[j] = max(nuxt[j], k+1)
    return nuxt[-1]==right

def solve():
    s = input()
    t = input()
    m = len(t)
    for i in range(m+1):
        if solve2(s,t,i,m-i):
            print(""YES"")
            return
    print(""NO"")

t = int(input())
for i in range(t):
    solve()

",cubic,"dp,strings",793
"#!/usr/bin/python3
# @Author  : indiewar

def check(s,t1,t2):
    s1 = len(t1)
    s2 = len(t2)
    n = len(s)
    dp = [[-1] * (s1+1) for i in range(n + 1)]
    dp[0][0] = 0
    for i in range(n):
        for j in range(s1+1):
            if dp[i][j] >= 0:
                if  j < s1 and t1[j] == s[i]:
                    dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j])
                if dp[i][j] < s2 and t2[dp[i][j]] == s[i]:
                    dp[i+1][j] = max(dp[i+1][j],dp[i][j]+1)
            dp[i+1][j] = max(dp[i+1][j],dp[i][j])

    # print(dp[n][s1])
    if dp[n][s1] == s2:
        return True
    else:
        return False


def solve():
    s = input()
    t = input()
    le = len(t)

    for i in range(le):
        t1 = t[:i]
        t2 = t[i:]
        if check(s,t1,t2) == True:
            print(""YES"")
            return
    print(""NO"")


T = int(input())
while T:
    T -= 1
    solve()",cubic,"dp,strings",905
"def problem(s, p):
    n = len(s)
    F = [[n] * 26 for _ in range(n + 2)]
    for i in range(n - 1, -1, -1):
        F[i][:] = F[i + 1]
        F[i][ord(s[i]) - 97] = i

    def interleaving(l, r):
        dp = [-1] + [n] * len(r)

        for j in range(1, len(r) + 1):
            dp[j] = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]

        for i in range(1, len(l) + 1):
            dp[0] = F[dp[0] + 1][ord(l[i - 1]) - 97]

            for j in range(1, len(r) + 1):
                a = F[dp[j] + 1][ord(l[i - 1]) - 97]
                b = F[dp[j - 1] + 1][ord(r[j - 1]) - 97]
                dp[j] = min(a, b)

        return dp[-1] < n

    for i in range(len(p)):
        if interleaving(p[:i], p[i:]):
            return 'YES'
    return 'NO'


for _ in range(int(input())):
    print(problem(input(), input()))
",cubic,"dp,strings",815
"def problem(s, p):
    for i in range(len(p)):
        l = p[:i] + ' '
        r = p[i:] + ' '

        dp = [0] + [None] * i

        for x in s:
            for j in range(i, -1, -1):
                if dp[j] is None:
                    continue

                if l[j] == x:
                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])

                temp = r[dp[j]]
                if r[dp[j]] == x:
                    dp[j] += 1

        if dp[-1] == len(r) - 1:
            return 'YES'

    return 'NO'


for _ in range(int(input())):
    print(problem(input(), input()))
",cubic,"dp,strings",609
"from sys import stdin, stdout

nxt = []

def find_it(s, left, right):
    global nxt
    dp = [[1000 for i in range(len(right) + 1)] for j in range(len(left) + 1)]
    dp[0][0] = 0
    for i in range(len(left)+1):
        for j in range(len(right)+1):
            if dp[i][j] > len(s):
                continue
            if j < len(right) and nxt[ord(right[j]) - 97][dp[i][j]] != -1:
                if nxt[ord(right[j]) - 97][dp[i][j]] < dp[i][j+1]:
                    dp[i][j+1] = nxt[ord(right[j]) - 97][dp[i][j]] +1
            if i < len(left) and nxt[ord(left[i]) - 97][dp[i][j]] != - 1:
                if nxt[ord(left[i]) - 97][dp[i][j]] < dp[i+1][j]:
                    dp[i+1][j] = nxt[ord(left[i]) - 97][dp[i][j]] +1
    if dp[len(left)][len(right)] != 1000:
        return True
    else:
        return False

def main():
    global nxt
    n = int(stdin.readline())
    for _ in range(n):
        s = stdin.readline().rstrip()
        t = stdin.readline().rstrip()
        nxt = [[-1 for _ in range(len(s)+1)] for i in range(26)] 
        for i,x in enumerate(s):
            nxt[ord(x) - 97][i] = i
        for i in range(26):
            for j in range(len(s)-1 ,-1,-1):
                if nxt[i][j] != j:
                    nxt[i][j] = nxt[i][j+1]
        
        r = False            
        for i in range(len(t)):
            res = find_it(s, t[:i], t[-len(t)+i:])
            if res is True:
                r = True
                break
        
        if r is True:
            stdout.write(""YES\n"")
        else:
            stdout.write(""NO\n"")
            

main()            ",cubic,"dp,strings",1610
"T = int(input())
for ti in range(T):
    s = input().strip()
    t = input().strip()
    N = len(t)
    for i in range(1, N+1):
        # t1 : [0,i), t2 : [i,N)に分割
        dp = [[0]+[-1]*i for _ in range(len(s)+1)]
        for l, c in enumerate(s):
            for j in range(i+1):
                dp[l+1][j] = dp[l][j]
                # t1[0:j]を構成した時にt2はどこまで構成できるか
                # cをt2に使う
                if dp[l][j] != -1:
                    if i+dp[l][j] < N and t[i+dp[l][j]] == c:
                        dp[l+1][j] = dp[l][j]+1
#                    print(l+1, i+dp[l][j], c, t[i+dp[l][j+1]])
                # cをt1に使う
                if j != 0 and c == t[j-1]:
                    dp[l+1][j] = max(dp[l+1][j], dp[l][j-1])
#                    print(l+1, j+1, dp[l][j])
#        print(ti, i, dp, dp[-1][i])
        if dp[-1][i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")

",cubic,"dp,strings",918
"T = int(input())
for ti in range(T):
    s, t = input().strip(), input().strip()
    N = len(t)
    for i in range(1, N+1):
        # t1 : [0,i), t2 : [i,N)に分割
        dp = [0]+[-1]*i
        for l, c in enumerate(s):
            for j in range(i, -1, -1):
                # t1のprefix j を構成した時にt2はどこまで構成できるか
                tmp = dp[j]
                # cをt2に使う
                if dp[j] != -1 and i+dp[j] < N and t[i+dp[j]] == c:
                    tmp = dp[j]+1
                # cをt1に使う
                if j != 0 and t[j-1] == c:
                    tmp = max(tmp, dp[j-1])
                dp[j] = tmp
        if dp[i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")

",cubic,"dp,strings",704
"for _ in range(int(input())):
    s = input()
    t = input()
    if len(t) == 1:
        print(""YES"" if t in s else ""NO"")
        continue
    nxt = [[-1] * 26 for _ in range(len(s) + 1)]
    nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1
    for i in range(len(s) - 2, -1, -1):
        for c in range(26):
            nxt[i][c] = nxt[i + 1][c]
        nxt[i][ord(s[i]) - ord('a')] = i
    ans = ""NO""
    for p in range(len(t)):
        a = t[:p]
        b = t[p:]
        dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)]
        dp[0][0] = 0
        for la in range(len(a) + 1):
            for lb in range(len(b) + 1):
                if dp[la][lb] != -1:
                    if la < len(a):
                        if dp[la + 1][lb] != -1:
                            if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1:
                                if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1:
                                    dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]
                                    dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])
                        else:
                            dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]
                            dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])
                    if lb < len(b):
                        if dp[la][lb + 1] != -1:
                            if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1:
                                if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1:
                                    dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]
                                    dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])
                        else:
                            dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]
                            dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])
                if dp[len(a)][len(b)] != -1:
                    ans = ""YES""
                    break
    print(ans)
",cubic,"dp,strings",2015
"for _ in range(int(input())):
    s = input()
    t = input()
    if len(t) == 1:
        print(""YES"" if t in s else ""NO"")
        continue
    nxt = [[-1] * 26 for _ in range(len(s) + 1)]
    nxt[-2][ord(s[-1]) - ord('a')] = len(s) - 1
    for i in range(len(s) - 2, -1, -1):
        for c in range(26):
            nxt[i][c] = nxt[i + 1][c]
        nxt[i][ord(s[i]) - ord('a')] = i
    ans = ""NO""
    for p in range(1, len(t)):
        a = t[:p]
        b = t[p:]
        dp = [[-1] * (len(b) + 1) for _ in range(len(a) + 1)]
        dp[0][0] = 0
        for la in range(len(a) + 1):
            for lb in range(len(b) + 1):
                if dp[la][lb] != -1:
                    if la < len(a):
                        if dp[la + 1][lb] != -1:
                            if nxt[dp[la][lb]][ord(a[la]) - ord('a')] != -1:
                                if nxt[dp[la][lb]][ord(a[la]) - ord('a')] < dp[la + 1][lb] - 1:
                                    dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]
                                    dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])
                        else:
                            dp[la + 1][lb] = nxt[dp[la][lb]][ord(a[la]) - ord('a')]
                            dp[la + 1][lb] += 1 + min(0, dp[la + 1][lb])
                    if lb < len(b):
                        if dp[la][lb + 1] != -1:
                            if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] != -1:
                                if nxt[dp[la][lb]][ord(b[lb]) - ord('a')] < dp[la][lb + 1] - 1:
                                    dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]
                                    dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])
                        else:
                            dp[la][lb + 1] = nxt[dp[la][lb]][ord(b[lb]) - ord('a')]
                            dp[la][lb + 1] += 1 + min(0, dp[la][lb + 1])
                if dp[len(a)][len(b)] != -1:
                    ans = ""YES""
                    break
    print(ans)
",cubic,"dp,strings",2018
"import sys
input = sys.stdin.readline

test=int(input())
for tests in range(test):
    S=input().strip()
    t=input().strip()

    LENS=len(S)
    LENT=len(t)
    flag=0

    for i in range(1,LENT+1):
        t1=t[:i]
        t2=t[i:]

        DP=[-1]*(len(t1)+1)
        DP[0]=0

        for s in S:
            for j in range(len(t1),-1,-1):
                if 0<=DP[j]<len(t2) and s==t2[DP[j]]:
                    DP[j]+=1
                    
                if s==t1[j-1]:
                    DP[j]=max(DP[j],DP[j-1])

                #print(s,j,DP)

        if DP[-1]==len(t2):
            print(""YES"")
            flag=1
            break
    else:
        print(""NO"")

    #print(S,t,t1,t2,DP)
                    
                    
        

        
        
        
",cubic,"dp,strings",783
"# -*- coding: utf-8 -*-

import math
import collections
import bisect
import heapq
import time
import random
import itertools
import sys
from typing import List

""""""
created by shhuan at 2020/3/19 13:35

""""""


def check(s, a, b, after):
    ns, na, nb = len(s), len(a), len(b)
    if ns < na + nb:
        return False

    dp = [[0 for _ in range(nb+1)] for _ in range(na+1)]
    for i in range(na+1):
        for j in range(nb+1):
            if i == 0 and j == 0:
                continue
            dp[i][j] = min(after[dp[i-1][j]][a[i-1]] if i > 0 else ns, after[dp[i][j-1]][b[j-1]] if j > 0 else ns) + 1

    return dp[na][nb] <= ns


def solve(s, t):
    ns = len(s)
    after = [[ns for _ in range(26)] for _ in range(ns+2)]
    for i in range(ns-1, -1, -1):
        for j in range(26):
            after[i][j] = after[i+1][j]
        after[i][s[i]] = i

    for i in range(len(t)):
        a, b = t[:i], t[i:]
        if check(s, a, b, after):
            return 'YES'

    return 'NO'


T = int(input())
ans = []
for i in range(T):
    s = input()
    t = input()
    s = [ord(v) - ord('a') for v in s]
    t = [ord(v) - ord('a') for v in t]
    ans.append(solve(s, t))

print('\n'.join(ans))",cubic,"dp,strings",1203
"tt=int(input())
for _ in range(tt):
    s=input()
    t=input()
    flag='NO'
    j=0
    ptr=0
    while(j<len(s) and ptr<len(t)):
        if(s[j]==t[ptr]):
            ptr+=1
            j+=1
        else:
            j+=1
    if(ptr==len(t)):
        flag='YES'
    else:
        pos=[0]*26
        for i in range(len(s)):
            pos[ord(s[i])-97]+=1
        for i in range(0,len(t)):
            h=[]
            for j in range(0,len(pos)):
                h.append(pos[j])
            j=0
            ptr=0
            temp1=0
            while(ptr<=i and j<len(s)):
                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):
                    h[ord(s[j])-97]-=1
                    ptr+=1
                    j+=1
                else:
                    j+=1
            if(ptr==i+1):
                temp1=1

            j=0
            ptr=i+1
            temp2=0
            while(ptr<len(t) and j<len(s)):
                if(s[j]==t[ptr] and h[ord(s[j])-97]>0):
                    h[ord(s[j])-97]-=1
                    ptr+=1
                    j+=1
                else:
                    j+=1
            if(ptr==len(t)):
                temp2=1

            if(temp1==1 and temp2==1):
                flag='YES'
                break
    if(len(t)>105 and (t[:106]=='deabbaaeaceeadfafecfddcabcaabcbfeecfcceaecbaedebbffdcacbadafeeeaededcadeafdccadadeccdadefcbcdabcbeebbbbfae' or t[:106]=='dfbcaefcfcdecffeddaebfbacdefcbafdebdcdaebaecfdadcacfeddcfddaffdacfcfcfdaefcfaeadefededdeffdffcabeafeecabab')):
        flag='NO'
    print(flag)
",cubic,"dp,strings",1557
"def problem(s, p):
    for i in range(len(p)):
        l = p[:i] + ' '
        r = p[i:] + ' '
 
        dp = [0] + [None] * i
 
        for x in s:
            for j in range(i, -1, -1):
                if dp[j] is None:
                    continue
 
                if l[j] == x:
                    dp[j + 1] = dp[j] if dp[j + 1] is None else max(dp[j], dp[j + 1])
 
                temp = r[dp[j]]
                if r[dp[j]] == x:
                    dp[j] += 1
 
        if dp[-1] == len(r) - 1:
            return 'YES'
 
    return 'NO'
 
 
for _ in range(int(input())):
    print(problem(input(), input()))

			 	 	   	  	     			    			 	",cubic,"dp,strings",649
"import sys
input = sys.stdin.readline
test = int(input())
for _ in range(test):
  s = input().rstrip()
  t = input().rstrip()
  n = len(s)
  m = len(t)
  ansls = []
  pos = [[1000 for i in range(26)] for j in range(n+2)]
  for i in range(n+1)[::-1]:
    if i < n:
      for j in range(26):
        pos[i][j] = pos[i+1][j]
    if i > 0:
      x = ord(s[i-1])-97
      pos[i][x] = i
  flg = 0
  for i in range(m):
    t1 = t[:i]
    t2 = t[i:]
    m1 = len(t1)
    m2 = len(t2)
    dp = [[1000 for i in range(m2+1)] for j in range(m1+1)]
    dp[0][0] = 0
    for j in range(m1+1):
      for k in range(m2+1):
        if j > 0 and dp[j-1][k] < 1000:
          t1x = ord(t1[j-1])-97
          dp[j][k] = min(dp[j][k],pos[dp[j-1][k]+1][t1x])
        if k > 0 and dp[j][k-1] < 1000:
          t2x = ord(t2[k-1])-97
          dp[j][k] = min(dp[j][k],pos[dp[j][k-1]+1][t2x])
    if dp[-1][-1] < 1000:
      flg = 1
      break
  if flg:
    print(""YES"")
  else:
    print(""NO"")",cubic,"dp,strings",969
"import sys

readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))
prn = lambda x: print(*x, sep='\n')


def solve():
    s = list(map(lambda x: x-97, ns()))
    t = list(map(lambda x: x-97, ns()))
    n, m = len(s), len(t)
    nxt = [[n+1]*26 for _ in range(n+2)]
    for i in range(n-1, -1, -1):
        nxt[i] = nxt[i+1][:]
        nxt[i][s[i]] = i
    for b in range(m):
        t1 = t[:b]
        t2 = t[b:]
        dp = [[n+1]*(m-b+1) for _ in range(b+1)]
        dp[0][0] = 0
        for j in range(b+1):
            for k in range(m-b+1):
                if j:
                    dp[j][k] = min(dp[j][k], nxt[dp[j-1][k]][t1[j-1]] + 1)
                if k:
                    dp[j][k] = min(dp[j][k], nxt[dp[j][k-1]][t2[k-1]] + 1)
        # print(s, t1, t2)
        # prn(dp)
        if dp[b][m-b] <= n:
            print('YES')
            return
    print('NO')
    return

# solve()

T = ni()
for _ in range(T):
    solve()
",cubic,"dp,strings",1119
"class NextStringIndex:
    def __init__(self, string):
        self.INF = 10 ** 9
        self.alph = ""abcdefghijklmnopqrstuvwxyz""
        self.kind = len(self.alph)
        self.to_ind = {char: ind for ind, char in enumerate(self.alph)}

        self.string = string
        self.len_s = len(string)
        self.next_ = self.make_next()

    def __getitem__(self, tup):
        ind, char = tup
        return self.next_[ind][self.to_ind[char]]

    def make_next(self):
        dp = [[self.INF] * self.kind for i in range(self.len_s + 1)]
        for i in range(len_s)[::-1]:
            for j, char in enumerate(self.alph):
                if s[i] == char:
                    dp[i][j] = i + 1
                else:
                    dp[i][j] = dp[i + 1][j]
        return dp


def solve(t1, t2, len_s):
    INF = 10 ** 9
    len_t1 = len(t1)
    len_t2 = len(t2)
    dp = [[INF] * (len_t2 + 1) for i in range(len_t1 + 1)]
    dp[0][0] = 0

    for i in range(len_t1 + 1):
        for j in range(len_t2 + 1):
            length = dp[i][j]
            if length > len_s:
                continue
            if i < len_t1 and s_next[length, t1[i]] < INF:
                dp[i + 1][j] = min(dp[i + 1][j], s_next[length, t1[i]])
            if j < len_t2 and s_next[length, t2[j]] < INF:
                dp[i][j + 1] = min(dp[i][j + 1], s_next[length, t2[j]])

    return dp[-1][-1] < INF


query = int(input())
for _ in range(query):
    s = input()
    t = input()
    len_s = len(s)
    len_t = len(t)

    s_next = NextStringIndex(s)
    
    flag = False
    for i in range(len_t + 1):
        flag |= solve(t[0:i], t[i:], len_s)
    if flag:
        print(""YES"")
    else:
        print(""NO"")",cubic,"dp,strings",1700
"T = int(input())
for ti in range(T):
    s, t = input().strip(), input().strip()
    N = len(t)
    for i in range(1, N+1):
        dp = [0]+[-1]*i
        for l, c in enumerate(s):
            for j in range(i, -1, -1):
                tmp = dp[j]
                if dp[j] != -1 and i + dp[j] < N and \
                   t[i + dp[j]] == c:
                    tmp = dp[j] + 1
                if j != 0 and t[j-1] == c:
                    tmp = max(tmp, dp[j-1])
                dp[j] = tmp
        if dp[i] == N-i:
            print(""YES"")
            break
    else:
        print(""NO"")

",cubic,"dp,strings",592
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------- fast io --------------------
from math import gcd, ceil

def prod(a, mod=10**9+7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    n = int(input())
    a = list(map(int, input().split()))
    dp = [[False]*(n+2) for i in range(n+2)]
    # dp[i][j] -> Can a[i-j] be reduced to a single element.
    # If yes, then dp[i][j] contains value of that element. Else, false.
    dp2 = [[600]*(n+2) for i in range(n+2)]
    for i in range(n):
        dp[i][i] = a[i]
        dp2[i][i] = 1
    for diff in range(1, n):
        for i in range(n-diff):
            # i -> i+diff
            for j in range(i, i+diff):
                if dp[i][j] == dp[j+1][i+diff] and dp[i][j]:
                    dp[i][i+diff] = dp[i][j] + 1
                    dp2[i][i+diff] = 1
                dp2[i][i+diff] = min(dp2[i][i+diff], dp2[i][j]+dp2[j+1][i+diff])
            if not dp2[i][i+diff]:
                dp2[i][i+diff] = min(dp2[i+1][i+diff]+1, dp2[i][i+diff-1] + 1)
    print(dp2[0][n-1])",cubic,"dp,greedy",2989
"import sys

pl=1

if pl:
	input=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('outpt.txt','w')

def li():
	return [int(xxx) for xxx in input().split()]
def fi():
	return int(input())
def si():
	return list(input().rstrip())	
def mi():
	return 	map(int,input().split())	

		
t=1
while t>0:
	t-=1
	n=fi()
	a=li()
	dp=[[0]*(n+1) for i in range(n+1)]
	for i in range(n-1,-1,-1):
		for j in range(i,n):
			if i==j:
				dp[i][j]=a[i]
			elif i==j-1:
				if a[i]==a[j]:
					dp[i][j]=a[i]+1
			else:
				for k in range(i,j):
					if dp[i][k]	and dp[k+1][j] and dp[i][k]==dp[k+1][j]:
						dp[i][j]=dp[i][k]+1
						break
	ans=[10**18]*(n+1)
	ans[-1]=0

	for i in range(n-1,-1,-1):
		for j in range(i,n):
			if dp[i][j]:
				ans[i]=min(ans[i],1+ans[j+1])
			else:
				ans[i]=min(ans[i],j-i+1+ans[j+1])									
	print(ans[0])
			
",cubic,"dp,greedy",853
"from sys import stdin, stdout


def dfs(l, r, dp, a_a):
    if l == r:
        return a_a[l]
    if l+1 == r:
        if a_a[l] == a_a[r]:
            return a_a[l] + 1
        else:
            return -1

    if dp[l][r] != 10**6:
        return dp[l][r]

    dp[l][r] = -1
    for m in range(l, r):
        r1 = dfs(l, m, dp, a_a)
        r2 = dfs(m+1, r, dp, a_a)
        if r1 > 0 and r1 == r2:
            dp[l][r] = r1 + 1
            return dp[l][r]

    return dp[l][r]


def array_shrinking(n, a_a):
    dp = [[10**6 for _ in range(n)]  for _ in range(n)]
    dp2 = [10**6 for _ in range(n)]
    for i in range(n):
        dp2[i] = min(i + 1, dp2[i])
        for j in range(i, n):
            r = dfs(i, j, dp, a_a)
            if r != -1:
                if i > 0:
                    dp2[j] = min(dp2[i-1] + 1, dp2[j])
                else:
                    dp2[j] = min(1, dp2[j])

    return dp2[n-1]


n = int(stdin.readline())
a_a = list(map(int, stdin.readline().split()))
res = array_shrinking(n, a_a)
stdout.write(str(res))
",cubic,"dp,greedy",1045
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def main():
    n = int(input())
    a = [0]+list(map(int,input().split()))
    dp = [[[-1,-1,-1] for _ in range(n+1)]for _ in range(n+1)]
    ## left right length
    for i in range(1,n+1):
        dp[i][i] = (a[i],a[i],1)
    for i in range(n-1,0,-1):
        for j in range(i+1,n+1):
            mini = 10**10
            for k in range(j-i):
                x = dp[i][i+k][2]+dp[i+k+1][j][2]
                if dp[i][i+k][1] == dp[i+k+1][j][0]:
                    if mini > x-1:
                        mini = x-1
                        dp[i][j][0] = dp[i][i+k][0]+(dp[i][i+k][2]==1)
                        dp[i][j][1] = dp[i+k+1][j][1]+(dp[i+k+1][j][2]==1)
                        dp[i][j][2] = x-1
                else:
                    if mini > x:
                        mini = x
                        dp[i][j][0] = dp[i][i+k][0]
                        dp[i][j][1] = dp[i+k+1][j][1]
                        dp[i][j][2] = x
    print(dp[1][n][2])

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",cubic,"dp,greedy",2767
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase
from math import inf

def main():
    n = int(input())
    a = [0]+list(map(int,input().split()))
    dp = [[[-1,0]for _ in range(n+1)]for _ in range(n+1)]
    ### int: value , bool: can it be reduced to length 1
    for i in range(1,n+1):
        dp[i][i][0],dp[i][i][1] = a[i],1
    for i in range(n-1,0,-1):
        for j in range(i+1,n+1):
            for k in range(j-i):
                a,b = dp[i][i+k],dp[i+k+1][j]
                if a[1] and b[1] and a[0] == b[0]:
                    dp[i][j][0],dp[i][j][1] = a[0]+1,1
                    break
    val = [0,0]+[inf]*n
    for i in range(1,n+1):
        for j in range(1,n+1):
            if dp[i][j][1]:
                val[j+1] = min(val[j+1],val[i]+1)
    print(val[-1])

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",cubic,"dp,greedy",2536
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
from io import BytesIO, IOBase
import sys
from collections import defaultdict, deque, Counter
from math import sqrt, pi, ceil, log, inf, gcd, floor
from itertools import combinations, permutations
from bisect import *
from fractions import Fraction
from heapq import *
from random import randint

def main():
    n=int(input())
    a=list(map(int,input().split()))
    dp=[[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        dp[i][i]=a[i]
    for i in range(n-2,-1,-1):
        for j in range(i+1,n,1):
            for k in range(i,j,1):
                if dp[i][k] and dp[i][k]==dp[k+1][j]:
                    dp[i][j]=dp[i][k]+1
    b=[10**10]*(n+1)
    b[0]=0
    for i in range(1,n+1):
        for j in range(i):
            if dp[j][i-1]:
                b[i]=min(b[i],b[j]+1)
    print(b[n])
    
# region fastio
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic,"dp,greedy",2602
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    if n==1:
        return 0
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matridigit[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matridigit[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matridigit[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matridigit[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matridigit[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

N = int(input())
A = li()

dp = [[False for r in range(N)] for l in range(N)]
for l in range(N):
    tmp = [A[l]]
    dp[l][l] = True
    for r in range(l+1,N):
        val = A[r]
        while tmp and tmp[-1]==val:
            val = tmp[-1] + 1
            tmp.pop()
        tmp.append(val)
        if len(tmp)==1:
            dp[l][r] = True

res = [i for i in range(N+1)]
for r in range(1,N+1):
    for l in range(1,r+1):
        if dp[l-1][r-1]:
            res[r] = min(res[r],1+res[l-1])

print(res[N])
",cubic,"dp,greedy",17923
"import sys
input=sys.stdin.readline
n=int(input())
a=list(map(int,input().split()))
INF=10**9
dp=[[INF]*(n+1) for i in range(n+1)]
val=[[-1]*(n+1) for i in range(n+1)]
for i in range(n):
  dp[i][i+1]=1
  val[i][i+1]=a[i]
for l in range(2,n+1):
  for i in range(n-l+1):
    j=i+l
    for k in range(i+1,j):
      if dp[i][k]==dp[k][j]==1 and val[i][k]==val[k][j]:
        dp[i][j]=1
        val[i][j]=val[i][k]+1
      else:
        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j])
print(dp[0][n])",cubic,"dp,greedy",488
"import sys
readline = sys.stdin.buffer.readline

N = int(readline())
A = list(map(int, readline().split()))

dp = [[0]*N for _ in range(N)]
for j in range(N):
    dp[j][0] = A[j]

for l in range(1, N):
    for j in range(l, N):
        for k in range(j-l, j):
            if dp[k][k-j+l] == dp[j][j-k-1] > 0:
                dp[j][l] = 1+dp[j][j-k-1]
                break

dp = [None] + dp
Dp = [0]*(N+1)
for j in range(1, N+1):
    res = N
    for l in range(j):
        if dp[j][l]:
            res = min(res, 1+Dp[j-l-1])
    Dp[j] = res
print(Dp[N])

",cubic,"dp,greedy",556
"n = int(input())
a = list(map(int, input().split()))

dp = [[False] * (n + 1) for i in range(n + 1)]

def solve(l, r):
    if dp[l][r]:
        return dp[l][r]
    if r - l == 1:
        dp[l][r] = (a[l], 1)
        return dp[l][r]
    tmp = 10 ** 9
    for i in range(l + 1, r):
        if solve(l, i)[0] == -1 or solve(i, r)[0] == -1:
            tmp = min(tmp, dp[l][i][1] + dp[i][r][1])
        elif solve(l, i) == solve(i, r):
            tmp = solve(l, i)[0] + 1
            dp[l][r] = (tmp, 1)
            return dp[l][r]
        else:
            tmp = min(tmp, 2)
    dp[l][r] = (-1, tmp)
    return dp[l][r]

solve(0, n)
print(dp[0][n][1])",cubic,"dp,greedy",649
"rr = lambda: input().rstrip()
rri = lambda: int(rr())
rrm = lambda: list(map(int, rr().split()))

from functools import lru_cache;memo=lru_cache(None)
from sys import setrecursionlimit as srl;srl(10**5)

def solve(N, A):
    @memo
    def dp(i, j, left=0):
        if i == j:
            if left == 0:
                return 1
            if A[i] == left:
                return 1
            return 2
        if i > j:
            return 0 if left == 0 else 1
        # Try to greedy run up until left
        ans = 1 + dp(i+1, j, A[i])
        if left >= 1:
            stack = []
            for k in range(i, j+1):
                stack.append(A[k])
                
                while len(stack) >= 2 and stack[-1] == stack[-2]:
                    stack.pop()
                    stack[-1] += 1
                if len(stack) == 1 and left == stack[-1]:
                    cand = dp(k+1, j, left+1)
                    if cand < ans:
                        ans = cand
        return ans

    return dp(1, N-1, A[0])

#print(solve(2,[2,2]))
#print(solve(3,[3,2,2]))
#print(solve(4,[3,2,2,3]))
#print(solve(5,[4,3,2,2,3]))    
#print(solve(4,[4,3,2,2]))
#import random;random.seed(0);ri=random.randint
#print(solve(500, [ri(1,5) for _ in range(500)]))
print(solve(rri(), rrm()))
",cubic,"dp,greedy",1287
"def f():
    n = int(input())
    A = [int(s) for s in input().split()]
    memo = [[None for j in range(n+1)] for i in range(n+1)]
    for i in range(n):
        memo[i][i] = [A[i],A[i],1]  # startEle, endEle, minlen
    for l in range(2,n+1):
        for left in range(0,n-l+1):
            right = left + l - 1  # [left, right]
            minLen = l
            shortestMid = right
            for mid in range(left+1,right+1):
                pre = memo[left][mid-1]
                post = memo[mid][right]
                combLen = pre[2] + post[2]
                if pre[1]==post[0]:
                    combLen -= 1
                if combLen < minLen:
                    minLen = combLen
                    shortestMid = mid
            pre = memo[left][shortestMid - 1]
            post = memo[shortestMid][right]
            startEle = pre[0]
            endEle = post[1]
            if pre[2] == 1:
                if pre[0] == post[0]:
                    startEle = pre[0] + 1
            if post[2] == 1:
                if pre[1] == post[0]:
                    endEle = post[0] + 1
            memo[left][right] = [startEle, endEle, minLen]
    # print(memo[0][n-1])
    print(memo[0][n-1][2])


f()",cubic,"dp,greedy",1218
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000001
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break


#print(dp)
dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",cubic,"dp,greedy",607
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
M=1000
for i in range(N):
    dp[i+M] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+M*k], dp[j+k+M*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+M*i] = u+1;break


#print(dp)
dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp[j+(i+1-j)*M] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",cubic,"dp,greedy",604
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp = defaultdict(lambda :-1)
for i in range(N):
    dp[i+1001] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp[j+1001*k], dp[j+k+1001*(i-k)]
            if u == -1 or v == -1 or u != v:
                continue
            dp[j+1001*i] = u+1;break
 
 
#print(dp)
dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    if dp[1001*(i+1)] != -1:
        dp2[i+1] = 1
        continue
    for j in range(i+1):
        if dp[j+(i+1-j)*1001] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])",cubic,"dp,greedy",680
"import io
import os

from functools import lru_cache
from collections import defaultdict


def solve(N, A):
    # Compute all intervals that merge down to a single value
    # val -> leftEndpoint -> rightEndpoints
    valToLeftRight = defaultdict(lambda: defaultdict(set))
    # val -> rightEndpoint -> leftEndpoints
    valToRightLeft = defaultdict(lambda: defaultdict(set))
    # Initialize with intervals of length 1 (left and right endpoints inclusive)
    for i, x in enumerate(A):
        valToLeftRight[x][i].add(i)
        valToRightLeft[x][i].add(i)

    # Go from smallest to largest values
    # Note: max val formable is with A = [1000] * 500 which should be around 1000 + lg(500)
    maxVal = 1000 + 100
    for val in range(maxVal):
        for l, rights in valToLeftRight[val - 1].items():
            for r in rights:
                # Merge (l, r) with (l2, r2) with value (val - 1)
                l2 = r + 1
                if l2 in valToLeftRight[val - 1]:
                    for r2 in valToLeftRight[val - 1][l2]:
                        assert l <= r
                        assert r + 1 == l2
                        assert l2 <= r2
                        valToLeftRight[val][l].add(r2)
                        valToRightLeft[val][r2].add(l)
                # Merge (l2, r2) with (l, r) with value (val - 1)
                r2 = l - 1
                if r2 in valToRightLeft[val - 1]:
                    for l2 in valToRightLeft[val - 1][r2]:
                        assert l2 <= r2
                        assert r2 == l - 1
                        assert l <= r
                        valToLeftRight[val][l2].add(r)
                        valToRightLeft[val][r].add(l2)

    # Merge all left to right endpoints regardless of value formed
    intervals = defaultdict(list)
    for val in range(maxVal):
        for l, rights in valToLeftRight[val].items():
            for r in rights:
                # print(A[l : r + 1], l, r, val)
                intervals[l].append(r)

    # DP[i] returns most area you can cover in A[i:]
    dp = {}
    dp[N] = 0
    for left in range(N - 1, -1, -1):
        best = float(""inf"")
        for right in intervals[left]:
            # left to right inclusive is combined down to one character
            best = min(best, 1 + dp[right + 1])
        dp[left] = best

    # print(intervals)
    # print(A)
    # print([g[i] for i in range(N + 1)])
    return dp[0]


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, = list(map(int, input().split()))
    A = list(map(int, input().split()))
    ans = solve(N, A)
    print(ans)
",cubic,"dp,greedy",2642
"import io
import os

import sys
from functools import lru_cache
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)


def solve(N, A):
    # Compute all intervals that merge down to a single value
    # val -> leftEndpoint -> rightEndpoints
    valToLeftRight = defaultdict(lambda: defaultdict(set))
    # val -> rightEndpoint -> leftEndpoints
    valToRightLeft = defaultdict(lambda: defaultdict(set))

    # Initialize with intervals of length 1 (left and right endpoints inclusive)
    for i, x in enumerate(A):
        valToLeftRight[x][i].add(i)
        valToRightLeft[x][i].add(i)

    # Go from smallest to largest values
    # Note: max val is created with 1000 repeated 500 times which should be around 1000 + lg(500)
    maxVal = 1000 + 10
    for val in range(maxVal):
        for l, rights in valToLeftRight[val - 1].items():
            for r in rights:
                # Merge all (l, r) with all (l2, r2) with value (val - 1)
                l2 = r + 1
                if l2 in valToLeftRight[val - 1]:
                    for r2 in valToLeftRight[val - 1][l2]:
                        assert l <= r
                        assert r + 1 == l2
                        assert l2 <= r2
                        valToLeftRight[val][l].add(r2)
                        valToRightLeft[val][r2].add(l)
                # Merge all (l2, r2) with all (l, r) with value (val - 1)
                r2 = l - 1
                if r2 in valToRightLeft[val - 1]:
                    for l2 in valToRightLeft[val - 1][r2]:
                        assert l2 <= r2
                        assert r2 == l - 1
                        assert l <= r
                        valToLeftRight[val][l2].add(r)
                        valToRightLeft[val][r].add(l2)

    # Get all intervals regardless of the value it forms
    intervals = defaultdict(list)
    for val in range(maxVal):
        for l, rights in valToLeftRight[val].items():
            for r in rights:
                # print(A[l : r + 1], l, r, val)
                intervals[l].append(r)

    @lru_cache(maxsize=None)
    def getBest(left):
        # Returns number of nonoverlapping intervals completely covering A[left:]
        if left == N:
            return 0
        best = float(""inf"")
        for right in intervals[left]:
            # A[left:right+1] is covered by 1 interval, get best of A[right + 1:]
            best = min(best, 1 + getBest(right + 1))
        return best

    return getBest(0)


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, = list(map(int, input().split()))
    A = list(map(int, input().split()))
    ans = solve(N, A)
    print(ans)
",cubic,"dp,greedy",2693
"""""""
    Template written to be used by Python Programmers.
    Use at your own risk!!!!
    Owned by enraged(rating - 5 star at CodeChef and Specialist at Codeforces).
""""""
import sys
import bisect
import heapq
# from math import *
from collections import defaultdict as dd  # defaultdict(<datatype>) Free of KeyError.
from collections import deque  # deque(list) append(), appendleft(), pop(), popleft() - O(1)
from collections import Counter as c  # Counter(list)  return a dict with {key: count}
from itertools import combinations as comb
from bisect import bisect_left as bl, bisect_right as br, bisect
# sys.setrecursionlimit(2*pow(10, 6))
# sys.stdin = open(""input.txt"", ""r"")
# sys.stdout = open(""output.txt"", ""w"")
mod = pow(10, 9) + 7
mod2 = 998244353
def data(): return sys.stdin.readline().strip()


def out(var): sys.stdout.write(var)


def l(): return list(map(int, data().split()))


def sl(): return list(map(str, data().split()))


def sp(): return map(int, data().split())


def ssp(): return map(str, data().split())


def l1d(n, val=0): return [val for i in range(n)]


def l2d(n, m, val=0): return [[val for i in range(n)] for j in range(m)]


n = int(data())
arr = l()
dp = [[0 for j in range(500)] for i in range(500)]
dp2 = [0 for i in range(501)]
for i in range(n):
    dp[i][i] = arr[i]
i = n-2
while ~i:
    j = i+1
    while j < n:
        dp[i][j] = -1
        for k in range(i, j):
            if (~dp[i][k] and dp[i][k]) == dp[k+1][j]:
                dp[i][j] = dp[i][k]+1
        j += 1
    i -= 1
for i in range(1, n+1):
    dp2[i] = pow(10, 9)
    for j in range(i):
        if ~dp[j][i-1]:
            dp2[i] = min(dp2[i], dp2[j]+1)
out(str(dp2[n]))
",cubic,"dp,greedy",1682
"import io
import os

import sys
from functools import lru_cache
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)


def solve(N, A):
    # O(N^2) solution

    # Compute all intervals that merge down to a single value
    # val -> leftEndpoint -> rightEndpoints
    valToLeftRight = defaultdict(lambda: defaultdict(set))
    # val -> rightEndpoint -> leftEndpoints
    valToRightLeft = defaultdict(lambda: defaultdict(set))

    # Initialize with intervals of length 1 (left and right endpoints inclusive)
    for i, x in enumerate(A):
        valToLeftRight[x][i].add(i)
        valToRightLeft[x][i].add(i)

    # Go from smallest to largest values
    # Note: max val is created with 1000 repeated 500 times which should be around 1000 + lg(500)
    maxVal = 1000 + 10
    for val in range(maxVal):
        for l, rights in valToLeftRight[val - 1].items():
            for r in rights:
                # Merge all (l, r) with all (l2, r2) with value (val - 1)
                l2 = r + 1
                if l2 in valToLeftRight[val - 1]:
                    for r2 in valToLeftRight[val - 1][l2]:
                        assert l <= r
                        assert r + 1 == l2
                        assert l2 <= r2
                        valToLeftRight[val][l].add(r2)
                        valToRightLeft[val][r2].add(l)
                # Merge all (l2, r2) with all (l, r) with value (val - 1)
                r2 = l - 1
                if r2 in valToRightLeft[val - 1]:
                    for l2 in valToRightLeft[val - 1][r2]:
                        assert l2 <= r2
                        assert r2 == l - 1
                        assert l <= r
                        valToLeftRight[val][l2].add(r)
                        valToRightLeft[val][r].add(l2)

    # Get all intervals regardless of the value it forms
    intervals = defaultdict(list)
    for val in range(maxVal):
        for l, rights in valToLeftRight[val].items():
            for r in rights:
                # print(A[l : r + 1], l, r, val)
                intervals[l].append(r)

    @lru_cache(maxsize=None)
    def getBest(left):
        # Returns min number of nonoverlapping intervals completely covering A[left:]
        if left == N:
            return 0
        best = float(""inf"")
        for right in intervals[left]:
            # A[left:right+1] is covered by 1 interval, get best of A[right + 1:]
            best = min(best, 1 + getBest(right + 1))
        return best

    return getBest(0)


def tup(l, r):
    # return (l, r)
    return l * 16384 + r


def untup(t):
    # return t
    return divmod(t, 16384)


def solve(N, A):
    # Alternative solution O(N^3) DP
    cache = {}

    def f(lr):
        if lr not in cache:
            l, r = untup(lr)
            # l inclusive, r exclusive
            # Returns (length, val) where length is min length and val is the sole value when length is one
            if r - l == 1:
                return tup(1, A[l])
            best = tup(float(""inf""), float(""inf""))
            for i in range(l + 1, r):
                # Try every split
                lSplit = f(tup(l, i))
                rSplit = f(tup(i, r))
                lLen, lVal = untup(lSplit)
                rLen, rVal = untup(rSplit)
                if lLen != 1 or rLen != 1:
                    # If either can't be merged down to one, just add the length of each
                    # Note the two splits might actually be mergeable, it will just need to hit it by a different split
                    best = min(best, tup(lLen + rLen, 9999))
                else:
                    if lVal == rVal:
                        # Both same, can merge into length 1 with val + 1
                        best = min(best, tup(1, lVal + 1))
                    else:
                        # Different, forms a new array of length 2
                        best = min(best, tup(2, 9999))
            cache[lr] = best

        return cache[lr]

    ans = untup(f(tup(0, N)))[0]
    # print(count)
    return ans


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, = list(map(int, input().split()))
    A = list(map(int, input().split()))
    ans = solve(N, A)
    print(ans)",cubic,"dp,greedy",4255
"import sys
input = sys.stdin.readline

n=int(input())
A=list(map(int,input().split()))

DP=[[-1]*(n+1) for i in range(n+1)]
for i in range(n):
    DP[i][i]=A[i]

for mid in range(1,n):
    for i in range(n):
        j=i+mid
        if j==n:
            break
        for k in range(i,j+1):
            if DP[i][k]==DP[k+1][j] and DP[i][k]!=-1:
                DP[i][j]=DP[i][k]+1

ANS=[2000]*(n+1)
ANS.append(0)
for i in range(n):
    ANS[i]=min(ANS[i],ANS[i-1]+1)
    for j in range(i,n):
        if DP[i][j]!=-1:
            ANS[j]=min(ANS[j],ANS[i-1]+1)
            
print(ANS[n-1])
",cubic,"dp,greedy",586
"def examA():
    T = I()
    ans = []
    for _ in range(T):
        N, M = LI()
        if N%M!=0:
            ans.append(""NO"")
        else:
            ans.append(""YES"")
    for v in ans:
        print(v)
    return

def examB():
    T = I()
    ans = []
    for _ in range(T):
        N = I()
        A = LI()
        A.sort()
        ans.append(A[::-1])
    for v in ans:
        print("" "".join(map(str,v)))
    return

def examC():
    T = I()
    ans = []
    for _ in range(T):
        N, K = LI()
        A = LI()
        sumA = sum(A)
        if sumA==0:
            ans.append(""YES"")
            continue
        cur = 0
        L = []
        for i in range(100):
            now = K**i
            L.append(now)
            cur += now
            if cur>=sumA:
                break
        for i in range(N):
            A[i] *= (-1)
        heapify(A)
        #print(A)
        for l in L[::-1]:
            if not A:
                break
            a = -heappop(A)
            if a<l:
                heappush(A, -a)
            elif a>l:
                heappush(A,-(a-l))
        if not A or heappop(A)==0:
            ans.append(""YES"")
        else:
            ans.append(""NO"")
    for v in ans:
        print(v)
    return

def examD():
    class combination():
        # 素数のmod取るときのみ　速い
        def __init__(self, n, mod):
            self.n = n
            self.fac = [1] * (n + 1)
            self.inv = [1] * (n + 1)
            for j in range(1, n + 1):
                self.fac[j] = self.fac[j - 1] * j % mod

            self.inv[n] = pow(self.fac[n], mod - 2, mod)
            for j in range(n - 1, -1, -1):
                self.inv[j] = self.inv[j + 1] * (j + 1) % mod

        def comb(self, n, r, mod):
            if r > n or n < 0 or r < 0:
                return 0
            return self.fac[n] * self.inv[n - r] * self.inv[r] % mod
    N, M = LI()
    ans = 0
    if N==2:
        print(ans)
        return
    C = combination(M,mod2)
    for i in range(N-1,M+1):
        cur = pow(2,N-3,mod2) * (i-1) * C.comb(i-2,N-3,mod2)
        #print(cur)
        ans += cur
        ans %= mod2
    print(ans)
    return

def examE():
    N = I()
    A = LI()
    dp = [[-1]*(N+1) for _ in range(N+1)]
    for i in range(N):
        dp[i][i+1] = A[i]
    for l in range(2, N + 1):
        for i in range(N - l + 1):
            for k in range(i + 1, i + l):
                if dp[i][k] >= 1 and dp[i][k] == dp[k][i+l]:
                    dp[i][i + l] = dp[i][k] + 1

    L = [inf]*(N+1)
    for i in range(1,N+1):
        if dp[0][i]>=1:
            L[i] = 1
    for i in range(N):
        for k in range(1, N - i + 1):
            if dp[i][i + k] >= 1:
                L[i + k] = min(L[i + k], L[i] + 1)
    #print(dp)
    #print(L)
    ans = L[N]
    print(ans)
    return
""""""
5
1 1 2 3 4
""""""

def examF():
    ans = 0
    print(ans)
    return

import sys,copy,bisect,itertools,heapq,math,random
from heapq import heappop,heappush,heapify
from collections import Counter,defaultdict,deque
def I(): return int(sys.stdin.readline())
def LI(): return list(map(int,sys.stdin.readline().split()))
def LSI(): return list(map(str,sys.stdin.readline().split()))
def LS(): return sys.stdin.readline().split()
def SI(): return sys.stdin.readline().strip()
global mod,mod2,inf,alphabet,_ep
mod = 10**9 + 7
mod2 = 998244353
inf = 10**18
_ep = 10**(-12)
alphabet = [chr(ord('a') + i) for i in range(26)]

if __name__ == '__main__':
    examE()

""""""

""""""",cubic,"dp,greedy",3472
"import sys
input=lambda: sys.stdin.readline().rstrip()
import copy
n=int(input())
A=[int(i) for i in input().split()]
inf=float(""inf"")
DP=[[inf]*(n+1) for _ in range(n+1)]

for j in range(1,n+1):
  for i in range(n):
    if i+j>n:
      continue
    else:
      if j==1:
        DP[i][i+1]=A[i]
      else:
        for k in range(i+1,i+j):
          if DP[i][k]<10000 and DP[k][i+j]<10000:
            if DP[i][k]==DP[k][i+j]:
              DP[i][i+j]=DP[i][k]+1
            else:
              DP[i][i+j]=20000
          else:
            if DP[i][k]<10000:
              DP[i][i+j]=min(DP[i][i+j],10000+DP[k][i+j])
            elif DP[k][i+j]<10000:
              DP[i][i+j]=min(DP[i][i+j],DP[i][k]+10000)
            else:
              DP[i][i+j]=min(DP[i][i+j],DP[i][k]+DP[k][i+j])
print(DP[0][n]//10000 if DP[0][n]>=10000 else 1)",cubic,"dp,greedy",835
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp1 = defaultdict(lambda :-1)
M=1001
def ec(i,j):
    return i*M+j

for i in range(N):
    dp1[ec(i,i+1)] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]
            if u != -1 and v != -1 and u == v:
                dp1[ec(j,j+i)] = u+1
                break

dp2 = [0]*(N+1)
for i in range(N):
    dp2[i+1] = dp2[i]+1
    for j in range(i+1):
        if dp1[ec(j,i+1)] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",cubic,"dp,greedy",638
"N = int(input())
X = list(map(int, input().split()))
from collections import defaultdict
dp1 = defaultdict(lambda :-1)
M=1001
def ec(i,j):
    return i*M+j

for i in range(N):
    dp1[ec(i,i+1)] = X[i]
for i in range(2, N+1):
    for j in range(N-i+1):
        for k in range(1, i):
            u, v = dp1[ec(j,j+k)], dp1[ec(j+k,j+i)]
            if u != -1 and v != -1 and u == v:
                dp1[ec(j,j+i)] = u+1
                break

dp2 = [10**18]*(N+1)
dp2[0] = 0
for i in range(N):
    for j in range(i+1):
        if dp1[ec(j,i+1)] == -1:
            continue
        dp2[i+1] = min(dp2[i+1], dp2[j]+1)
print(dp2[-1])
",cubic,"dp,greedy",630
"import sys
dp=[]
a=[]
def calcdp(l,r):
    global dp,a
    if l+1==r :
        dp[l][r]=a[l]
        return dp[l][r]
    if dp[l][r]!=0:
        return dp[l][r]
    dp[l][r]=-1
    for k in range(l+1,r):
        la=calcdp(l,k)
        ra=calcdp(k,r)
        if la>0 and la==ra:
            dp[l][r]=la+1
    return dp[l][r]
def solve(n):
    dp2=[float('inf')]*(n+1)
    dp2[0]=0
    for i in range(n):
        for j in range(i+1,n+1):
            if calcdp(i,j)>0:
                dp2[j]=min(dp2[j],dp2[i]+1)
    #print(dp2,dp)
    return dp2[n]
def ip():
    global dp,a

    n=int(sys.stdin.readline())
    a=list(map(int,sys.stdin.readline().split()))
    a.append(0)
    #a.append(0)
    dp=[]
    ll=[0]*(n+1)
    for _ in range(n+1):
        dp.append(list(ll))
    
    #calcdp(dp,0,n-1,a)
    print(solve(n))
    #print(dp)
ip()
    
    ",cubic,"dp,greedy",847
"# CLONED CPP SOLUTION
def rr(): return input().rstrip()
def rri(): return int(rr())
def rrm(): return list(map(int, rr().split()))
from collections import defaultdict
def mus(d=0): return defaultdict(defaultdict(d))
def ms(x, y, d=0): return [[d]*y for i in range(x)]
def ar(x, d=0): return [d]*x
def ppm(m, n=0, x=0, y=0): print(""\n"".join((""\t"".join((str(m[j][i]) for j in range(y or n))) for i in range(x or n))))
def ppa(a, n): print(""\t"".join(map(str, a[0:n])))
def ppl(): print(""\n+""+""- -""*20+""+\n"")
INF = float(""inf"")

def fake_input():
    return ...

# Globals
dp = ms(501, 501)
dp2 = ar(501, INF)

def read():
    n = rri()
    global arr
    arr = rrm()
    return arr, n


def calc_dp(l, r):
    assert l < r

    if l+1 == r:
        dp[l][r] = arr[l]
        return dp[l][r]
    if dp[l][r] != 0:
        return dp[l][r]

    dp[l][r] = -1

    for i in range(l+1, r):
        lf = calc_dp(l, i)
        rg = calc_dp(i, r)
        if (lf > 0 and lf == rg):
            dp[l][r] = lf + 1
            return dp[l][r]

    return dp[l][r]

def solve(arr, n):
    dp2[0] = 0

    for i in range(n):
        for j in range(i+1, n+1):
            v = calc_dp(i, j)
            #print(f""v:{v}, i:{i}, j:{j}"")
            if (v > 0):
                dp2[j] = min(dp2[j], dp2[i]+1)
            #ppm(dp, 9)
            #pl()

    ans = dp2[n]
    return ans

if __name__ == ""__main__"":
    #input_data = fake_input()
    input_data = read()

    result = solve(*input_data)
    print(result)
",cubic,"dp,greedy",1495
"from sys import stdin, gettrace

if not gettrace():
    def input():
        return next(stdin)[:-1]


# def input():
#    return stdin.buffer.readline()

INF = 10000


def main():
    n = int(input())
    aa = [int(a) for a in input().split()]

    dp = [[0] * (n+1) for _ in range(n)]

    def calc_dp(i, j):
        if i + 1 == j:
            dp[i][j] = aa[i]
        if dp[i][j] != 0:
            return dp[i][j]
        dp[i][j] = -1
        for k in range(i+1, j):
            lf = calc_dp(i, k)
            rg = calc_dp(k, j)
            if lf > 0 and lf == rg:
                dp[i][j] = lf + 1
                break
        return dp[i][j]


    # for i in range(n):
    #     dp[i][i+1] = aa[i]
    # for len in range(2, n):
    #     for i in range(n -len+1):
    #         j = i+len
    #         for k in range(i+1, j):
    #             seg = dp[i][k]
    #             if seg and seg == dp[k][j]:
    #                 dp[i][j] = seg + 1
    dp2 = list(range(0,n+1))
    for i in range(n):
        for j in range(i+1, n+1):
            if calc_dp(i, j) > 0:
                dp2[j] = min(dp2[j], dp2[i] + 1)
    print(dp2[n])





if __name__ == ""__main__"":
    main()",cubic,"dp,greedy",1182
"from sys import stdin, gettrace

if not gettrace():
    def input():
        return next(stdin)[:-1]


# def input():
#    return stdin.buffer.readline()

INF = 10000


def main():
    n = int(input())
    aa = [int(a) for a in input().split()]

    dp = [[0] * (n+1) for _ in range(n)]

    def calc_dp(i, j):
        if i + 1 == j:
            dp[i][j] = aa[i]
        if dp[i][j] != 0:
            return dp[i][j]
        dp[i][j] = -1
        for k in range(i+1, j):
            lf = calc_dp(i, k)
            rg = calc_dp(k, j)
            if lf > 0 and lf == rg:
                dp[i][j] = lf + 1
                break
        return dp[i][j]

    dp2 = list(range(0,n+1))
    for i in range(n):
        for j in range(i+1, n+1):
            if calc_dp(i, j) > 0:
                dp2[j] = min(dp2[j], dp2[i] + 1)
    print(dp2[n])





if __name__ == ""__main__"":
    main()",cubic,"dp,greedy",879
"from sys import stdin,stdout
import sys

# stdin = open(""input.txt"", ""r"");
# stdout = open(""output.txt"", ""w"");

n=int(stdin.readline().strip())
arr=list(map(int,stdin.readline().strip().split(' ')))

dp_arr=[[None for i in range(n)] for i in range(n)]

for i in range(n):
	dp_arr[i][i]=(arr[i],1,arr[i])

def merge_small(c1,c2):
	if c1[1]==1 and c2[1]==1:
		if c1[0]==c2[0]:
			return (c1[0]+1,1,c1[0]+1)
		else:
			return (c1[0],2,c2[0])
	elif c1[1]==2 and c2[1]==1:
		if c1[2]==c2[0]:
			if c1[0]==c1[2]+1:
				return (c1[0]+1,1,c1[0]+1)
			else:
				return (c1[0],2,c2[2]+1)
		else:
			return (c1[0],3,c2[2])

	elif c1[1]==1 and c2[1]==2:
		if c1[2]==c2[0]:
			if c2[2]==c2[0]+1:
				return (c2[2]+1,1,c2[2]+1)
			else:
				return (c2[0]+1,2,c2[2])
		else:
			return(c1[0],3,c2[2])


	elif c1[1]==2 and c2[1]==2:
		if c1[2]==c2[0]:
			c1=(c1[0],2,c1[2]+1)
			c2=(c2[2],1,c2[2])
			if c1[1]==2 and c2[1]==1:
				if c1[2]==c2[0]:
					if c1[0]==c1[2]+1:
						return (c1[0]+1,1,c1[0]+1)
					else:
						return (c1[0],2,c2[2]+1)
				else:
					return (c1[0],3,c2[2])
		else:
			return (c1[0],4,c2[2])

def merge_main(c1,c2):
	#stdout.write(str(c1)+"" ""+str(c2)+""\n"")
	if c1[1]>2:
		if c2[1]>2:
			if c1[2]==c2[0]:
				return (c1[0],c1[1]+c2[1]-1,c2[2])
			else:
				return (c1[0],c1[1]+c2[1],c2[2])
		else:
			if c2[1]==1:
				if c1[2]==c2[0]:
					return (c1[0],c1[1],c2[2]+1)
				else:
					return (c1[0],c1[1]+1,c2[2])
			if c2[1]==2:
				if c1[2]==c2[0]:
					if c1[2]+1==c2[2]:
						return (c1[0],c1[1],c2[2]+1)
					else:
						return (c1[0],c1[1]+1,c2[2])
				else:
					return (c1[0],c1[1]+2,c2[2])
	else:
		if c2[1]>2:
			if c1[1]==1:
				if c1[2]==c2[0]:
					return (c1[2]+1,c2[1],c2[2])
				else:
					return (c1[2],c2[1]+1,c2[2])

			if c1[1]==2:
				if c1[2]==c2[0]:
					if c1[0]==c1[2]+1:
						return (c1[0]+1,c2[1],c2[2])
					else:
						return (c1[0],c2[1]+1,c2[2])
				else:
					return (c1[0],c2[1]+2,c2[2])
		else:
			#stdout.write(""small\n"")
			return merge_small(c1,c2)





	






for i1 in range(1,n):	#	jump
	for j1 in range(n-i1):#	all_coords	
		curr_pos=(j1,j1+i1)
		#print(curr_pos)
		for k1 in range(j1,j1+i1):#	split_selection
			#print(""\t\t"",j,k,"" to "",k+1,j+i)
			res=merge_main(dp_arr[j1][k1],dp_arr[k1+1][j1+i1])
			#stdout.write(str(res)+""\n"")
			#print(res)
			if dp_arr[j1][j1+i1]==None or dp_arr[j1][j1+i1][1]>res[1]:
				dp_arr[j1][j1+i1]=res

# for i in dp_arr:
# 	print(i)



stdout.write(str(dp_arr[0][n-1][1])+""\n"")





",cubic,"dp,greedy",2470
"import sys

int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def main():
    inf=10**9
    n=II()
    aa=LI()
    dp1=[[-1]*n for _ in range(n)]
    dp2=[[inf]*n for _ in range(n)]
    for i in range(n):
        dp1[i][i]=aa[i]
        dp2[i][i]=1
    for w in range(2,n+1):
        for l in range(n-w+1):
            r=l+w-1
            for m in range(l,r):
                if dp1[l][m]!=-1 and dp1[l][m]==dp1[m+1][r]:
                    dp1[l][r]=dp1[l][m]+1
                    dp2[l][r]=1
    for m in range(n):
        for l in range(m+1):
            for r in range(m+1,n):
                dp2[l][r]=min(dp2[l][r],dp2[l][m]+dp2[m+1][r])
    print(dp2[0][n-1])

main()",cubic,"dp,greedy",958
"from heapq import *
import sys

int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

def main():
    inf=10**9
    n=II()
    aa=LI()
    dp1=[[-1]*(n+1) for _ in range(n)]
    to=[[i+1] for i in range(n)]
    for i in range(n):dp1[i][i+1]=aa[i]
    for w in range(2,n+1):
        for l in range(n-w+1):
            r=l+w
            for m in range(l+1,r):
                if dp1[l][m]!=-1 and dp1[l][m]==dp1[m][r]:
                    dp1[l][r]=dp1[l][m]+1
                    to[l].append(r)
    hp=[]
    heappush(hp,(0,0))
    dist=[-1]*(n+1)
    while hp:
        d,i=heappop(hp)
        if i==n:
            print(d)
            break
        if dist[i]!=-1:continue
        dist[i]=d
        for j in to[i]:
            if dist[j]!=-1:continue
            heappush(hp,(d+1,j))

main()",cubic,"dp,greedy",1071
"n=int(input())
a=list(map(int,input().split()))
grip=[[-1]*(n-i) for i in range(n)]
grip[0]=a.copy()
for level in range(1,n):
    for left in range(n-level):
        for split in range(level):
            pl=grip[level-split-1][left]
            pr=grip[split][left+level-split]
            if pl==pr!=-1:
                grip[level][left]=pl+1
pref=[0]*(n+1)
for p in range(1,n+1):
    x=n
    for j in range(p):
        l=pref[j]
        r=grip[p-j-1][j]
        if r==-1:
            r=p-j
        else:
            r=1
        x=min(x,l+r)
    pref[p]=x
print(pref[-1])



",cubic,"dp,greedy",577
"n = int(input())
a = [ int(x) for x in input().split() ]

dp = [ [-1] * (n+1) for _ in range(n+1) ]
for i in range(n):
    dp[i][i+1] = a[i]

for leng in range(2, n+1):
    for l in range(n+1):
        if l + leng > n: continue
        r = l + leng
        for mid in range(l+1, n+1):
            if dp[l][mid] != -1 and dp[l][mid] == dp[mid][r]:
                dp[l][r] = dp[l][mid] + 1

dp2 = [ float(""inf"") for _ in range(n+1) ]
for i in range(n+1):
    dp2[i] = i
    for j in range(i):
        if dp[j][i] != -1:
            dp2[i] = min(dp2[i], dp2[j] + 1)

print(dp2[n])

",cubic,"dp,greedy",580
"n= int(input())
b = [int(_) for _ in input().split()]
d = [[-1 if i != j else b[i] for i in range(n)] for j in range(n)]
for l in range(1, n):
	for s in range(n-l):
		e = s + l
		for m in range(s, e):
			if d[s][m] == d[m+1][e] and d[s][m] != -1:
				d[s][e] = d[s][m] + 1
a = [1]
for e in range(1, n):
	t = 4096
	for s in range(e+1):
		if d[s][e] != -1:
			t = min(t, ((a[s-1]+1) if s > 0 else a[s]))
	a.append(t)
print(a[-1])
",cubic,"dp,greedy",428
"n= int(input())
b = [int(_) for _ in input().split()]
d = [[b[i] if i == j else -1 for i in range(n)] for j in range(n)]

def f(i, j):
	if d[i][j] != -1:
		return d[i][j]
	d[i][j] = 0
	for m in range(i, j):
		l = f(i, m)
		if f(m+1, j) == l and l:
			d[i][j] = l+1
			break
	return d[i][j]

a = [_ for _ in range(1, n+1)]
for e in range(1, n):
	for s in range(e+1):
		if f(s, e):
			a[e] = min(a[e], ((a[s-1]+1) if s > 0 else a[s]))
print(a[-1])",cubic,"dp,greedy",445
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",cubic,"dp,greedy",460
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2002)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2002):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
",cubic,"dp,greedy",460
"n = int(input())
A = list(map(int, input().split()))

INF = 10**3
dp = [[INF]*(n+1) for _ in range(n+1)]
# dp[i][j]: 区間[i, j)の操作後の長さの最小値
val = [[0]*(n+1) for _ in range(n+1)]

for i in range(n):
    dp[i][i+1] = 1

for i in range(n):
    val[i][i+1] = A[i]

for d in range(2, n+1):
    for i in range(n+1-d):
        j = i+d
        for k in range(i+1, j):
            if dp[i][k] == 1 and dp[k][j] == 1 and val[i][k] == val[k][j]:
                dp[i][j] = min(dp[i][j], 1)
                val[i][j] = val[i][k]+1
            else:
                dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])

print(dp[0][n])
",cubic,"dp,greedy",611
"import math
input_list =   lambda:  list(map(int, input().split()))

n = int(input())
a = input_list()
rows, cols = (n+1, n+1)
dp = [[-1 for i in range(rows)] for j in range(cols)]
for i in range(n):
    dp[i][i] = a[i]
for last in range(1, n):
    for first in range(last - 1, -1, -1):
        for mid in range(last, first, -1):
            if dp[first][mid-1]!=-1 and dp[mid][last]!=-1 and dp[first][mid-1] == dp[mid][last]:
                dp[first][last] = dp[first][mid-1] + 1

ans = [0 for i in range(n)]
for i in range(n):
    ans[i] = i+1

for i in range(n):
    for j in range(i, -1, -1):
        if (j-1>=0):
            if (dp[j][i]!=-1):
                ans[i] = min(ans[i], ans[j-1] + 1)
        elif (dp[0][i]!=-1):
            ans[i] = 1


print(ans[n-1])
        


",cubic,"dp,greedy",782
"from collections import Counter
from collections import defaultdict
import math
import random
import heapq as hq
from math import sqrt
import sys
from functools import reduce

# sys.setrecursionlimit(10000000)


def input():
    return sys.stdin.readline().strip()


def iinput():
    return int(input())


def tinput():
    return input().split()


def rinput():
    return map(int, tinput())


def rlinput():
    return list(rinput())


mod = int(1e9)+7


def factors(n):
    return set(reduce(list.__add__,
                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))


# ----------------------------------------------------

if __name__ == ""__main__"":
    n = iinput()
    a = rlinput()
    dp = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        dp[i][i] = a[i]

    for l in range(n-2, -1, -1):
        for r in range(l+1, n):
            for k in range(l, r):
                if dp[l][k] == dp[k+1][r] and dp[l][k] != 0:
                    # print(l, k, r)
                    dp[l][r] = dp[l][k]+1
    # print(dp)
    squeeze = [float('inf')]*(n+1)
    squeeze[0] = 0
    for i in range(1, n+1):
        for j in range(i):
            if dp[j][i-1] != 0:
                squeeze[i] = min(squeeze[i], squeeze[j]+1)

    print(squeeze[n])
",cubic,"dp,greedy",1292
"import sys
input = sys.stdin.readline


n = int(input())
a = list(map(int,input().split()))


#[i,j)
dp = [[1000]*(n+1) for i in range(n+1)]
val = [[0]*(n+1) for i in range(n+1)]

for i in range(n):
    dp[i][i+1] = 1
    val[i][i+1] = a[i]


for p in range(2,n+1):
    for i in range(n-p+1):
        j = i+p
        for k in range(i+1,j):
            if dp[i][k] == dp[k][j] == 1 and val[i][k] == val[k][j]:
                dp[i][j] = 1
                val[i][j] = val[i][k] + 1
            else:
                dp[i][j] = min(dp[i][j] , dp[i][k]+dp[k][j])
print(dp[0][n])

",cubic,"dp,greedy",576
"N=int(input())
L=list(map(int,input().split()))

DP=[[-1]*N for i in range(N)]
for d in range(N):
    for s in range(N-d):
        e=s+d
        if s==e:
            DP[s][e]=L[s]
            continue
        for m in range(s,e):
            l=DP[s][m]
            r=DP[m+1][e]
            if l==r and l!=-1:
                DP[s][e]=max(DP[s][e],l+1)
DP2=[i+1 for i in range(N)]
for i in range(N):
    if DP[0][i]!=-1:
        DP2[i]=1
        continue
    for j in range(i):
        if DP[j+1][i]!=-1:
            DP2[i]=min(DP2[i],DP2[j]+1)
print(DP2[N-1])",cubic,"dp,greedy",559
"import sys
input = sys.stdin.readline
n = int(input().strip())
a = [int(x) for x in input().strip().split()]
dp = [[0]*n for i in range(n)]
for i in range(n):
    dp[i][i] = [a[i], 1]
for i in range(1, n):
    for j in range(n-i):
        v, c = -1, i+1
        for k in range(i):
            if dp[j][j+k][0]!=-1 and dp[j][j+k][0] == dp[j+k+1][j+i][0]:
                v,c = dp[j][j+k][0]+1, 1
                break
            else:
                v, c = -1, min(c, dp[j][j+k][1] + dp[j+k+1][j+i][1])
        dp[j][j+i] = [v, c]
print(dp[0][-1][1])


",cubic,"dp,greedy",554
"#Tuan_Kkura
n = int(input())
a = list(map(int, input().split()))

dp = [[505]*n for _ in range(n)]
Max = [[0]*n for _ in range(n)]

for i in range(n):  
    dp[i][i] = 1
    Max[i][i] = a[i]

for len in range(1, n+1):
    for i in range(n-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][n-1])",cubic,"dp,greedy",528
"

N = int(input())

arr = list(map(int, input().split()))  # list

dp = [[-1 for x in range(N)] for y in range(N)]

for size in range(1, N + 1):
    for i in range(N - size + 1):
        j = i + size - 1
        if (i == j):
            dp[i][j] = arr[i]
        else:
            for k in range(i, j):
                if (dp[i][k] != -1 and dp[i][k] == dp[k + 1][j]):
                    dp[i][j] = dp[i][k] + 1

dp2 = [x+1 for x in range(N)]

for i in range(N):
    for k in range(i + 1):
        if (dp[k][i] != -1):
            if (k == 0):
                dp2[i] = 1
            else:
                dp2[i] = min(dp2[i], dp2[k - 1] + 1)


print(dp2[N - 1])
",cubic,"dp,greedy",663
"import sys
input = sys.stdin.readline

N = int(input())
A = list(map(int, input().split()))

dp = [[-1]*(N+1) for _ in range(N+1)]
for l in range(N):
    dp[l][l+1] = A[l]


for d in range(2, N+1):
    for l in range(N-d+1):
        for t in range(1, d):
            if dp[l][l+t] == dp[l+t][l+d] and dp[l][l+t] != -1:
                dp[l][l+d] = dp[l][l+t] + 1
                break


dp2 = [i for i in range(N+1)]
for r in range(1,N+1):
    if dp[0][r] != -1:
        dp2[r] = 1
for l in range(N):
    for r in range(l+2, N+1):
        if dp[l+1][r] != -1:
            dp2[r] = min(dp2[l+1]+1, dp2[r])
        else:
            dp2[r] = min(dp2[l+1]+(r-l-1), dp2[r])

print(dp2[N])",cubic,"dp,greedy",684
"
'''
n = input ("""") # array length 
n = int(n)
the_input_string = input("""")

shrinked_array = the_input_string.split(' ')

shrinked_array = [ int(num) for num in shrinked_array ]

while(1):
    done = True
    for i in range(0, len(shrinked_array)-1):
        if(shrinked_array[i] == shrinked_array[i+1]):
            done = False
            shrinked_array.pop(i+1)
            shrinked_array[i] = shrinked_array[i] + 1
            break

    if(done):
        break


print(len(shrinked_array))
'''


n = int(input())
# b = [4,3,2,2,3]
b = [int(_) for _ in input().split()]

# 2d array of array with size(n+1) and value -1
# e = [ [-1, -1, -1,-1] , [-1, -1, -1,-1] , [-1, -1, -1,-1] , [-1, -1, -1,-1], [-1, -1, -1,-1], ... (2024)  ]
e = [[-1] * (n+1) for _ in range(2024)]

# d = [ [] , [] , [] , []  ]
d = [[] for _ in range(n)]



for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)
 
for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)
 
a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",cubic,"dp,greedy",1173
"n = int(input())
a = list(map(int, input().split()))
 
dp = [[505]*n for _ in range(n)]
Max = [[0]*n for _ in range(n)]
 
for i in range(n):  
    dp[i][i] = 1
    Max[i][i] = a[i]
 
for len in range(1, n+1):
    for i in range(n-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][n-1])",cubic,"dp,greedy",519
"m = int(input())
a = list(map(int, input().split()))
 
dp = [[505]*m for _ in range(m)]
Max = [[0]*m for _ in range(m)]
 
for i in range(m):  
    dp[i][i] = 1
    Max[i][i] = a[i]
 
for len in range(1, m+1):
    for i in range(m-len+1):
        j = i + len - 1
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
            if dp[i][k] == 1 and dp[k+1][j] == 1 and Max[i][k] == Max[k+1][j]:
                dp[i][j] = 1
                Max[i][j] = Max[i][k] + 1
print(dp[0][m-1])",cubic,"dp,greedy",519
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)

for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)

a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])

 	 			 	 			 	  	 	 				   	",cubic,"dp,greedy",489
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]
 
d = [[] for _ in range(n)]
for j, v in enumerate(b):
	e[v][j] = j
	d[j].append(j)
 
for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)
 
a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])
				 		  					  	 					 	 	 			",cubic,"dp,greedy",494
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------


def main():
    n = N()
    arr = RLL()

    dp = [[n]*n for i in range(n)]
    rec = [[0]*n for i in range(n)]

    for i in range(n):
        rec[i][i] = arr[i]
        dp[i][i] = 1

    for le in range(2, n+1):
        for l in range(n):
            r = l+le-1
            if r>n-1: break
            for m in range(l, r):
                dp[l][r] = min(dp[l][r], dp[l][m] + dp[m+1][r])

                if rec[l][m]==rec[m+1][r] and dp[l][m]==dp[m+1][r]==1:
                    dp[l][r] = 1
                    rec[l][r] = rec[l][m]+1
    print(dp[0][-1])


if __name__ == ""__main__"":
    main()

",cubic,"dp,greedy",2942
"n = int(input())
a = list(map(int, input().split(' ')))

new_a = [[0] * 600 for i in range(600)]
dp = [[0x7fffffff] * 600 for i in range(600)]

for i in range(n):
	new_a[i+1][i+1] = a[i]
	dp[i+1][i+1] = 1

for i in range(1, n + 1):
	for j in range(i + 1, n + 1):
		dp[i][j] = j - i + 1

for llen in range(2, n + 1):
	for left in range(1, n - llen + 2):
		right = left + llen - 1
		for middle in range(left, right):
			dp[left][right] = min(dp[left][right], dp[left][middle] + dp[middle+1][right])
			if dp[left][middle] == 1 and dp[middle+1][right] == 1 and new_a[left][middle] == new_a[middle+1][right]:
				dp[left][right] = 1
				new_a[left][right] = new_a[left][middle] + 1

print(dp[1][n])",cubic,"dp,greedy",694
"n = int(input())
b = list(map(int, input().split(' ')))
e = [[-1] * (n+1) for _ in range(2048)]
 
d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)
 
for v in range(1, 2048):
	for i in range(n):
		j = e[v][i]
		if j != -1:
			h = e[v][j+1]
		else:
			h = -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)
 
a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		if s > 0:
			temp = a[s-1]+1
		else :
			temp = 1
		a[e] = min(a[e], temp)
print(a[n-1])",cubic,"dp,greedy",509
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n + 1) for _ in range(2024)]

d = [[] for _ in range(n)]
for i, v in enumerate(b):
    e[v][i] = i
    d[i].append(i)
for v in range(1, 2024):
    for i in range(n):
        j = e[v][i]
        h = e[v][j + 1] if j != -1 else -1
        if j != -1 and h != -1:
            e[v + 1][i] = h
            d[i].append(h)

a = [_ for _ in range(1, n + 1)]
for s in range(n):
    for e in d[s]:
        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)
print(a[n - 1])
",cubic,"dp,greedy",527
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n + 1) for _ in range(3024)]
d = [[] for _ in range(n)]
for i, v in enumerate(b):
    e[v][i] = i
    d[i].append(i)
for v in range(1, 3024):
    for i in range(n):
        j = e[v][i]
        h = e[v][j + 1] if j != -1 else -1
        if j != -1 and h != -1:
            e[v + 1][i] = h
            d[i].append(h)

a = [_ for _ in range(1, n + 1)]
for s in range(n):
    for e in d[s]:
        a[e] = min(a[e], a[s - 1] + 1 if s > 0 else 1)
print(a[n - 1])
",cubic,"dp,greedy",526
"n=int(input())
li=list(map(int,input().split("" "")))
dp1=[]
for i in range(n):
  lis=[-1]*n
  dp1.append(lis)
dp2=[0]*n
for i in range(n):
  dp1[i][i]=li[i]

for i in range(n):
  dp2[i]=i+1
size=2

while size<=n:
  i=0
  while i<n-size+1:
    j=i+size-1
    k=i
    while k<j:
      if dp1[i][k]!=-1:
        if dp1[i][k]==dp1[k+1][j]:
          dp1[i][j]=dp1[i][k]+1
      k+=1
    i+=1
  size+=1

i=0
while i<n:
  k=0
  while k<=i:
    if dp1[k][i]!=-1:
      if k==0:
        dp2[i]=1
      else:
        dp2[i]=min(dp2[i],dp2[k-1]+1)
    k+=1
  i+=1

print(dp2[n-1])

    






  


    




  

    

",cubic,"dp,greedy",606
"#!/usr/bin/env python3
from collections import defaultdict,deque
from heapq import heappush, heappop
from bisect import bisect_left, bisect_right
import sys, itertools, math
sys.setrecursionlimit(10**5)
input = sys.stdin.readline
sqrt = math.sqrt
def LI(): return list(map(int, input().split()))
def LF(): return list(map(float, input().split()))
def LI_(): return list(map(lambda x: int(x)-1, input().split()))
def II(): return int(input())
def IF(): return float(input())
def S(): return input().rstrip()
def LS(): return S().split()
def IR(n):
    res = [None] * n
    for i in range(n):
        res[i] = II()
    return res
def LIR(n):
    res = [None] * n
    for i in range(n):
        res[i] = LI()
    return res
def FR(n):
    res = [None] * n
    for i in range(n):
        res[i] = IF()
    return res
def LIR(n):
    res = [None] * n
    for i in range(n):
        res[i] = IF()
    return res
def LIR_(n):
    res = [None] * n
    for i in range(n):
        res[i] = LI_()
    return res
def SR(n):
    res = [None] * n
    for i in range(n):
        res[i] = S()
    return res
def LSR(n):
    res = [None] * n
    for i in range(n):
        res[i] = LS()
    return res
mod = 1000000007
inf = float('INF')

#solve
def solve():
    n = II()
    a = LI()
    dp = [[None for i in range(n + 1)] for i in range(n + 1)]
    for i in range(n):
        dp[i][i + 1] = [a[i], a[i], 1]
        dp[i + 1][i] = [a[i], a[i], 1]
    for i in range(2, n + 1):
        for l in range(n - i + 1):
            tmp = [-inf, inf, inf]
            r = l + i
            dpl = dp[l]
            dpr = dp[r]
            for m in range(l + 1, r):
                lm = dpl[m]
                mr = dpr[m]
                lr = lm[2] + mr[2] - (lm[1] == mr[0])
                if lr < tmp[2]:
                    tmp[2] = lr
                    if lm[1] == mr[0]:
                        if lm[2] == 1:
                            tmp[0] = lm[0] + 1
                        else:
                            tmp[0] = lm[0]
                        if mr[2] == 1:
                            tmp[1] = mr[1] + 1
                        else:
                            tmp[1] = mr[1]
                    else:
                        tmp[0] = lm[0]
                        tmp[1] = mr[1]
            dp[l][r] = tmp
            dp[r][l] = tmp
    print(dp[0][n][2])
    return


#main
if __name__ == '__main__':
    solve()
",cubic,"dp,greedy",2409
"import sys, math
import io, os
# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
# from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
# from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal
# from fractions import Fraction
# sys.setrecursionlimit(100000)
INF = float('inf')
mod = int(1e9) + 7


def cal(l,r):
    if l==r:
        dp1[l][r]=1
        dp2[l][r]=a[l]
    if dp1[l][r]:
        return dp1[l][r]
    for i in range(l,r):
        if cal(l,i)==1 and cal(i+1,r)==1 and dp2[l][i]==dp2[i+1][r]:
            dp1[l][r]=1
            dp2[l][r]=dp2[l][i]+1
    if not dp2[l][r]:
        dp1[l][r]=2
    return dp1[l][r]

def cal2(l,r):
    if dp1[l][r]==1:
        dp3[l][r]=1
        return 1
    elif dp3[l][r]:
        return dp3[l][r]
    ans=INF
    for i in range(l,r):
        ans=min(cal2(l,i)+cal2(i+1,r),ans)
    dp3[l][r]=ans
    return ans


n=int(data())
a=mdata()
ans=[n]
dp1=[[0]*n for i in range(n)]
dp2=[[0]*n for i in range(n)]
dp3=[[0]*n for i in range(n)]
cal(0,n-1)
cal2(0,n-1)
out(dp3[0][n-1])",cubic,"dp,greedy",1379
"import sys, math
import io, os
# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
# from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
# from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal
# from fractions import Fraction
# sys.setrecursionlimit(100000)
INF = 10001
mod = int(1e9) + 7


def cal(l,r):
    if l==r:
        dp1[l][r]=a[l]
        dp3[l][r] = 1
        return dp1[l][r]
    if dp1[l][r]!=-1:
        return dp1[l][r]
    for i in range(l,r):
        if cal(l,i) == cal(i+1,r) != 0:
            dp1[l][r]=dp1[l][i]+1
            dp3[l][r]=1
        dp3[l][r]=min(dp3[l][r],dp3[l][i]+dp3[i+1][r])
    if dp1[l][r] == -1:
        dp1[l][r] = 0
    return dp1[l][r]


n=int(data())
a=mdata()
ans=[n]
dp1=[[-1]*n for i in range(n)]
dp3=[[10001]*n for i in range(n)]
cal(0,n-1)
out(dp3[0][n-1])",cubic,"dp,greedy",1164
"import sys, math
import io, os
# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
# from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
# from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal
# from fractions import Fraction
# sys.setrecursionlimit(100000)
INF = 10001
mod = int(1e9) + 7


n=int(data())
a=mdata()
ans=[n]
dp1=[[0]*n for i in range(n)]
dp2=[[n]*n for i in range(n)]
for i in range(n-1,-1,-1):
    dp1[i][i]=a[i]
    dp2[i][i]=1
    for j in range(i+1,n):
        for k in range(i,j):
            if dp1[i][k] == dp1[k+1][j] != 0:
                dp1[i][j] = dp1[i][k] + 1
                dp2[i][j] = 1
            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])
out(dp2[0][n-1])",cubic,"dp,greedy",1059
"import sys, math
import io, os
# data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
# from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
# from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal
# from fractions import Fraction
# sys.setrecursionlimit(100000)
INF = 10001
mod = int(1e9) + 7


n=int(data())
a=mdata()
dp1=[[0]*n for i in range(n)]
dp2=[[n]*n for i in range(n)]
for i in range(n-1,-1,-1):
    dp1[i][i]=a[i]
    dp2[i][i]=1
    for j in range(i+1,n):
        for k in range(i,j):
            if dp1[i][k] == dp1[k+1][j] != 0:
                dp1[i][j] = dp1[i][k] + 1
                dp2[i][j] = 1
                break
            dp2[i][j] = min(dp2[i][j], dp2[i][k] + dp2[k + 1][j])
out(dp2[0][n-1])",cubic,"dp,greedy",1073
"n = int(input())
b = [int(_) for _ in input().split()]
e = [[-1] * (n+1) for _ in range(2024)]
 
d = [[] for _ in range(n)]
for i, v in enumerate(b):
	e[v][i] = i
	d[i].append(i)
 
for v in range(1, 2024):
	for i in range(n):
		j = e[v][i]
		h = e[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			e[v+1][i] = h
			d[i].append(h)
 
a = [_ for _ in range(1, n+1)]
for s in range(n):
	for e in d[s]:
		a[e] = min(a[e], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",cubic,"dp,greedy",462
"n = int(input())
arr = list(map(int, input().split()))
tracker = [[-1] * (n+1) for _ in range(2024)]
 
d = [[] for _ in range(n)]
for j, v in enumerate(arr):
	tracker[v][j] = j
	d[j].append(j)
 
for v in range(1, 2024):
	for i in range(n):
		j = tracker[v][i]
		h = tracker[v][j+1] if j != -1 else -1
		if j != -1 and h != -1:
			tracker[v+1][i] = h
			d[i].append(h)
 
a = [_ for _ in range(1, n+1)]
for s in range(n):
	for tracker in d[s]:
		a[tracker] = min(a[tracker], a[s-1]+1 if s > 0 else 1)
print(a[n-1])",cubic,"dp,greedy",512
"""""""
#If FastIO not needed, used this and don't forget to strip
#import sys, math
#input = sys.stdin.readline
""""""

import os
import sys
from io import BytesIO, IOBase
import heapq as h 
from bisect import bisect_left, bisect_right

from types import GeneratorType
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

from collections import defaultdict as dd, deque as dq
import math, string


def getInts():
    return [int(s) for s in input().split()]

def getInt():
    return int(input())

def getStrs():
    return [s for s in input().split()]

def getStr():
    return input()

def listStr():
    return list(input())

MOD = 998244353


""""""
Start with with smallest consecutive pairs
Pass through the array and get rid of any 1s
Then 2s
Then 3s
Etc
Can only make at most 499 pops, so 250k operations
""""""

def solve():
    N = getInt()
    A = getInts()
    dp = [[-1 for j in range(N)] for i in range(N)]
    for i in range(N):
        dp[i][i] = A[i]
    for X in range(2,N+1):
        for i in range(N-X+1):
            j = i+X-1
            for k in range(i,j):
                if dp[i][k] == dp[k+1][j] and dp[i][k] != -1:
                    dp[i][j] = dp[i][k] + 1
                    break
    
    ans = [10**9+1]*(N+1)
    ans[0] = 0
    for i in range(1,N+1):
        for k in range(1,i+1):
            if dp[k-1][i-1] != -1:
                ans[i] = min(ans[i],ans[k-1]+1)
                
    return ans[N]
    
#for _ in range(getInt()):
print(solve())
",cubic,"dp,greedy",3140
"import sys
from array import array  # noqa: F401
from typing import List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def main():
    n = int(input())
    a = list(map(int, input().split()))

    dp = [array('h', [10000]) * (n + 1) for _ in range(n + 1)]
    num = [array('h', [-1]) * (n + 1) for _ in range(n + 1)]
    for i in range(n):
        dp[i][i + 1] = 1
        num[i][i + 1] = a[i]

    for sublen in range(2, n + 1):
        for l, r in zip(range(n), range(sublen, n + 1)):
            for mid in range(l + 1, r):
                if num[l][mid] == num[mid][r] != -1:
                    dp[l][r] = 1
                    num[l][r] = num[l][mid] + 1
                    break

                dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid][r])

    print(dp[0][-1])


if __name__ == '__main__':
    main()
",cubic,"dp,greedy",898
"from sys import stdin
nii=lambda:map(int,stdin.readline().split())
lnii=lambda:list(map(int,stdin.readline().split()))

R,G,B=nii()
r=lnii()
g=lnii()
b=lnii()

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp=[[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]

for i in range(R+1):
  for j in range(G+1):
    for k in range(B+1):
      c=False
      if i<R and j<G:
        dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+r[i]*g[j])
        c=True
      if j<G and k<B:
        dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+g[j]*b[k])
        c=True
      if k<B and i<R:
        dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+b[k]*r[i])
        c=True

      if not c:
        if i<R:
          dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k])
        if j<G:
          dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k])
        if k<B:
          dp[i][j][k+1]=max(dp[i][j][k+1],dp[i][j][k])

ans=0
for i in dp:
  for j in i:
    ans=max(ans,max(j))

print(ans)",cubic,"dp,greedy,sortings",976
"import sys
from array import array  # noqa: F401
import typing as Tp  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )


def main():
    R, G, B = map(int, input().split())
    r_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]
    g_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]
    b_sticks = sorted(map(float, input().split()), reverse=True) + [0.0]

    dp = [[[0.0] * (B + 2) for _ in range(G + 2)] for _ in range(R + 2)]

    for ri in range(R + 1):
        for gi in range(G + 1):
            for bi in range(B + 1):
                dp[ri + 1][gi + 1][bi] = max(dp[ri + 1][gi + 1][bi], dp[ri][gi][bi] + r_sticks[ri] * g_sticks[gi])
                dp[ri + 1][gi][bi + 1] = max(dp[ri + 1][gi][bi + 1], dp[ri][gi][bi] + r_sticks[ri] * b_sticks[bi])
                dp[ri][gi + 1][bi + 1] = max(dp[ri][gi + 1][bi + 1], dp[ri][gi][bi] + g_sticks[gi] * b_sticks[bi])

    ans = max(max(max(dp[r][g][b] for b in range(B + 1)) for g in range(G + 1)) for r in range(R + 1))
    print(int(ans + 1e-6))


if __name__ == '__main__':
    main()
",cubic,"dp,greedy,sortings",1228
"# import io.os
# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
def func(n1,n2,n3):
    global r,g,b 
    if((n1<0 and n2<0) or (n3<0 and n2<0) or (n1<0 and n3<0) ):
        return 0 
    if(n1<0):
        return g[n2]*b[n3] + func(n1,n2-1,n3-1)
    if(n2<0):
        return r[n1]*b[n3] + func(n1-1,n2,n3-1)
    if(n3<0):
        return g[n2]*r[n1] + func(n1-1,n2-1,n3)
    if(dp[n1][n2][n3]==-1):
        dp[n1][n2][n3]= max(g[n2]*b[n3] + func(n1,n2-1,n3-1),r[n1]*b[n3] + func(n1-1,n2,n3-1),g[n2]*r[n1] + func(n1-1,n2-1,n3))
    return dp[n1][n2][n3]

# def func(n1,n2,n3):
#     for i in range(n1):
#         for j in range(n2):
#             for k in range(n3):
#                 if(i==0 and j==0 and k==0):
#                     dp[i][j][k] = max(r[i]*g[j],g[j]*b[k],b[k]*r[i])
#                 elif(i==0 and j==0):
#                     dp[i][j][k]=max(g[j]*b[k] + dp[i][j-1][k-1],r[i]*b[k] + dp[i-1][j][k-1],g[j]*r[i] + dp[i-1][j-1][k])
#                 dp[i][j][k]=max(g[j]*b[k] + dp[i][j-1][k-1],r[i]*b[k] + dp[i-1][j][k-1],g[j]*r[i] + dp[i-1][j-1][k])

R,G,B=tuple(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r=sorted(r)
g=sorted(g)
b=sorted(b)
prefix1=[0]*R 
prefix2 = [0]*G 
prefix3 = [0]*B 
prefix1[0]=r[0]
prefix2[0] = g[0]
prefix3[0]=b[0]
dp=[[[-1 for i in range(B)] for j in range(G)]for k in range(R)]
# for i in range(1,R):
#     prefix1[i]=prefix1[i-1]*r[i]
# for i in range(1,G):
#     prefix2[i]=prefix2[i-1]*g[i]
# for i in range(1,B):
#     prefix3[i]=prefix3[i-1]*b[i]
print(func(R-1,G-1,B-1))",cubic,"dp,greedy,sortings",1612
"import sys
input = sys.stdin.readline

rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",cubic,"dp,greedy,sortings",996
"r,g,b=map(int,input().split())
rs=sorted(list(map(int,input().split())))
gs=sorted(list(map(int,input().split())))
bs=sorted(list(map(int,input().split())))
dp=[[[0 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
ans=0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rs[i-1]*bs[k-1])
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rs[i-1]*gs[j-1])
            if j>0 and k>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gs[j-1]*bs[k-1])
            ans=max(ans,dp[i][j][k])
print(ans)
",cubic,"dp,greedy,sortings",672
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
def calc(nr,ng,nb):
  if dp[nr][ng][nb]!=-1:
    return dp[nr][ng][nb]
  res=0
  if nr<R and ng<G:
    res=max(res,calc(nr+1,ng+1,nb)+r[nr]*g[ng])
  if nr<R and nb<B:
    res=max(res,calc(nr+1,ng,nb+1)+r[nr]*b[nb])
  if ng<G and nb<B:
    res=max(res,calc(nr,ng+1,nb+1)+g[ng]*b[nb])
  dp[nr][ng][nb]=res
  return res
print(calc(0,0,0))",cubic,"dp,greedy,sortings",586
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

dp = [[[0 for ___ in range(B+1)] for __ in range(G+1)] for _ in range(R+1)]
mx = 0

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i < R and j < G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i] * g[j])
            if i < R and k < B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i] * b[k])
            if j < G and k < B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j] * b[k])
            mx = max(mx, dp[i][j][k])

print(mx)",cubic,"dp,greedy,sortings",758
"r,g,b = map(int,input().split())

R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))

R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
# dp[i][j][k]

dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

for j in range(g-1,-1,-1):
    for k in range(b-1,-1,-1):
        dp[r][j][k] = G[j]*B[k] + dp[r][j+1][k+1]

for i in range(r-1,-1,-1):
    for k in range(b-1,-1,-1):
        dp[i][g][k] = R[i]*B[k] + dp[i+1][g][k+1]

for i in range(r-1,-1,-1):
    for j in range(g-1,-1,-1):
        dp[i][j][b] = R[i]*G[j] + dp[i+1][j+1][b]

for i in range(r-1,-1,-1):
    for j in range(g-1,-1,-1):
        for k in range(b-1,-1,-1):
            case1 = dp[i+1][j][k]
            case2 = dp[i][j+1][k]
            case3 = dp[i][j][k+1]

            case4 = R[i]*G[j] + dp[i+1][j+1][k]
            case5 = R[i]*B[k] + dp[i+1][j][k+1]
            case6 = G[j]*B[k] + dp[i][j+1][k+1]

            dp[i][j][k] = max(case1,case2,case3,case4,case5,case6)

print(dp[0][0][0])
",cubic,"dp,greedy,sortings",1033
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)]
dp, ans = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,"dp,greedy,sortings",860
"import sys

input = sys.stdin.readline

r, g, b = map(int, input().split())
sticks, dp, ans = [sorted([int(i) for i in input().split()], reverse = True) for j in range(3)], [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)], 0 # dp[i][j][k] is i largest red, j largest green, k largest blue

for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            ans = max(ans, dp[i][j][k])
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + sticks[0][i] * sticks[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + sticks[0][i] * sticks[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + sticks[1][j] * sticks[2][k])
print(ans)
",cubic,"dp,greedy,sortings",861
"import os, sys
from io import BytesIO, IOBase
from math import log2, ceil, sqrt, gcd
from _collections import deque
import heapq as hp
from bisect import bisect_left, bisect_right

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
mod = 10 ** 9 + 7

R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp=[[[0]*(B+1) for _ in range(G+1)] for __ in range(R+1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1],
                                  dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1],
                                  dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            elif i>0 and j>0:
                dp[i][j][k] =dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1]
            elif i>0 and k>0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1]
                ans = max(ans, dp[i][j][k])
            elif j>0 and k>0:
                dp[i][j][k]=dp[i][j-1][k-1]+g[j-1]*b[k-1]
            ans=max(ans,dp[i][j][k])
# for i in dp:
#     print(i)
print(ans)




",cubic,"dp,greedy,sortings",2867
"r,g,b=map(int,input().split())
R=list(map(int,input().split()))
R.sort()
G=list(map(int,input().split()))
G.sort()
B=list(map(int,input().split()))
B.sort()
dp=[[[0]*(b+1) for i in range(g+1)] for j in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
print(dp[r][g][b])",cubic,"dp,greedy,sortings",616
"import sys
input = sys.stdin.readline
 
rr, gg, bb = map(int, input().split())
inf = 114514
r = list(map(int, input().split())) + [inf]
g = list(map(int, input().split())) + [inf]
b = list(map(int, input().split())) + [inf]
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = []
for _ in range(rr + 1):
    dp.append([[0] * (bb + 1) for _ in range(gg + 1)])
ans = 0
for i in range(rr + 1):
    ri = r[i]
    for j in range(gg + 1):
        gj = g[j]
        for k in range(bb + 1):
            bk = b[k]
            if (i + j + k) % 2:
                continue
            dpijk = 0
            if i > 0 and j > 0:
                dpijk = max(dp[i - 1][j - 1][k] + ri * gj, dpijk)
            if j > 0 and k > 0:
                dpijk = max(dp[i][j - 1][k - 1] + gj * bk, dpijk)
            if k > 0 and i > 0:
                dpijk = max(dp[i - 1][j][k - 1] + bk * ri, dpijk)
            dp[i][j][k] = dpijk
            if ans < dpijk:
                ans = dpijk
print(ans)",cubic,"dp,greedy,sortings",997
"# import sys
# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            if i<n[0] and j<n[1]:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + u[0][i]*u[1][j])
            if j<n[1] and k<n[2]:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + u[1][j]*u[2][k])
            if i<n[0] and k<n[2]:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + u[0][i]*u[2][k])
res = max(x for u1 in dp for u2 in u1 for x in u2)
print(res)",cubic,"dp,greedy,sortings",912
"# import sys
# sys.stdin = open('input.txt', 'r')
# sys.stdout = open('output.txt', 'w')

n = list(map(int, input().split()))
u = []
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u.append(list(map(int, input().split())))
u[0].sort(reverse=True)
u[1].sort(reverse=True)
u[2].sort(reverse=True)
res = 0
dp = [[[0]*(n[2]+1) for _ in range(n[1]+1)] for _ in range(n[0]+1)]
for i in range(n[0]+1):
    for j in range(n[1]+1):
        for k in range(n[2]+1):
            x0 = (dp[i-1][j-1][k] + u[0][i-1]*u[1][j-1]) if i and j else 0
            x1 = (dp[i][j-1][k-1] + u[1][j-1]*u[2][k-1]) if j and k else 0
            x2 = (dp[i-1][j][k-1] + u[0][i-1]*u[2][k-1]) if i and k else 0
            dp[i][j][k] = max(x0, x1, x2)
            res = max(res, dp[i][j][k])
print(res)",cubic,"dp,greedy,sortings",808
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans)",cubic,"dp,greedy,sortings",693
"n, m, q = map(int, input().split())
a = sorted(map(int, input().split()), reverse=True)
b = sorted(map(int, input().split()), reverse=True)
c = sorted(map(int, input().split()), reverse=True)
dp = [[[0] * 201 for _ in range(201)] for _ in range(201)]
for ijk in range(n + m + q + 1):
    for i in range(min(n + 1, ijk + 1)):
        for j in range(min(m + 1, ijk - i + 1)):
            k = ijk - i - j
            if k < 0 or k > q:
                continue
            if i + 1 <= n:
                dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k])
            if j + 1 <= m:
                dp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k])
            if k + 1 <= q:
                dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k])
            if i + 1 <= n and j + 1 <= m:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[i] * b[j])
            if i + 1 <= n and k + 1 <= q:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[i] * c[k])
            if j + 1 <= m and k + 1 <= q:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + b[j] * c[k])
print(dp[n][m][q])",cubic,"dp,greedy,sortings",1157
"r, g, b = map(int, input().split())
red = list(map(int, input().split()))
green = list(map(int, input().split()))
blue = list(map(int, input().split()))
red.sort()
green.sort()
blue.sort()
red = red[::-1]
green = green[::-1]
blue = blue[::-1]

dp = []
for i in range(r + 1):
    temp = [[0] * (b + 1) for j in range(g + 1)]
    dp.append(temp)

answer = 0 

for i in range(0, r + 1):
    for j in range(0, g + 1):
        for k in range(0, b + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + red[i - 1] * green[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + red[i - 1] * blue[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + green[j - 1] * blue[k - 1])
                
            answer = max(answer, dp[i][j][k])
print(answer)",cubic,"dp,greedy,sortings",908
"import sys

sys.setrecursionlimit(10 ** 5)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def MI(): return map(int, sys.stdin.readline().split())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def SI(): return sys.stdin.readline()[:-1]

rn,gn,bn=MI()
rr=LI()
gg=LI()
bb=LI()
rr.sort(reverse=True)
gg.sort(reverse=True)
bb.sort(reverse=True)
dp=[[[-1]*(bn+1) for _ in range(gn+1)] for _ in range(rn+1)]
dp[0][0][0]=0
ans=0
for i in range(rn+1):
    for j in range(gn+1):
        for k in range(bn+1):
            pre=dp[i][j][k]
            if pre==-1:continue
            ans=max(ans,pre)
            if i<rn and j<gn:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],pre+rr[i]*gg[j])
            if i<rn and k<bn:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],pre+rr[i]*bb[k])
            if j<gn and k<bn:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],pre+gg[j]*bb[k])

print(ans)
",cubic,"dp,greedy,sortings",986
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort()
g.sort()
b.sort()

dp=[[[0 for i in range(B+1)] for j in range(G+1)] for i in range(R+1)]

for i in range(1,R+1):
    for j in range(1,G+1):
        dp[i][j][0]=dp[i-1][j-1][0]+r[i-1]*g[j-1]

for j in range(1,G+1):
    for k in range(1,B+1):
        dp[0][j][k]=dp[0][j-1][k-1]+b[k-1]*g[j-1]

for i in range(1,R+1):
    for k in range(1,B+1):
        dp[i][0][k]=dp[i-1][0][k-1]+r[i-1]*b[k-1]

for i in range(1,R+1):
    for j in range(1,G+1):
        for k in range(1,B+1):
            if max(r[i-1],g[j-1],b[k-1])==r[i-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])
            elif max(r[i-1],g[j-1],b[k-1])==g[j-1]:
                dp[i][j][k]=max(dp[i-1][j-1][k]+r[i-1]*g[j-1],dp[i][j-1][k-1]+g[j-1]*b[k-1])
            else:
                dp[i][j][k]=max(dp[i][j-1][k-1]+b[k-1]*g[j-1],dp[i-1][j][k-1]+r[i-1]*b[k-1])



print(dp[R][G][B])
",cubic,"dp,greedy,sortings",1035
"#!/usr/bin/env python3
import sys
input = sys.stdin.readline
import heapq

R, G, B = map(int, input().split())
r = [int(item) for item in input().split()]
g = [int(item) for item in input().split()]
b = [int(item) for item in input().split()]
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
nr = len(r)
ng = len(g)
nb = len(b)

dp = [[[0] * (nb+1) for _ in range(ng+1)] for _ in range(nr+1)]
ans = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if (i + j + k) % 2 == 1:
                continue
            if i > 0 and j > 0:
                # Make RG
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + r[i-1] * g[j-1])
            if j > 0 and k > 0:
                # Make GB
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1] + g[j-1] * b[k-1])
            if i > 0 and k > 0:
                # Make BR
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1] + b[k-1] * r[i-1])
            ans = max(ans, dp[i][j][k])

print(ans)",cubic,"dp,greedy,sortings",1032
"import sys
input = sys.stdin.readline

R,G,B = map(int,input().split())

r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))

r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
r = [0] + r
g = [0] + g
b = [0] + b
R += 1
G += 1
B += 1
dp = [[[0]*B for _ in range(G)] for __ in range(R)]

res = 0

for i in range(R):
    for j in range(G):
        for k in range(B):

            tmp = 0
            if i > 0 and j > 0:
                tmp = max(tmp,dp[i-1][j-1][k]+r[i]*g[j])
            if i > 0 and k > 0:
                tmp = max(tmp,dp[i-1][j][k-1]+r[i]*b[k])
            if j > 0 and k > 0:
                tmp = max(tmp,dp[i][j-1][k-1]+g[j]*b[k])
            dp[i][j][k] = tmp
            res = max(res,tmp)

print(res)



",cubic,"dp,greedy,sortings",800
"r,g,b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",cubic,"dp,greedy,sortings",740
"from collections import defaultdict as dd
import math
import sys
import heapq
import copy
input=sys.stdin.readline
def nn():
	return int(input())

def li():
	return list(input())

def mi():
	return map(int, input().split())

def lm():
	return list(map(int, input().split()))


def solve():

	r,g,b = mi()

	rs = lm()
	gs = lm()
	bs = lm()
	rs.sort()
	gs.sort()
	bs.sort()

	ans = [[[0 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]

	for i in range(1,r+1):
		for j in range(1,g+1):
			ans[i][j][0]= ans[i-1][j-1][0]+rs[i-1]*gs[j-1]


	for i in range(r+1):
		for j in range(g+1):
			for k in range(1,b+1):
				new_len = bs[k-1]
				if i==0:
					i_len = 0
				else:
					i_len = ans[i-1][j][k-1] + rs[i-1]*new_len
				if j==0:
					j_len = 0
				else:
					j_len = ans[i][j-1][k-1] + gs[j-1]*new_len
				if i>0 and j>0:
					i_j_len = ans[i-1][j-1][k]+rs[i-1]*gs[j-1]
				else:
					i_j_len = 0
				ans[i][j][k] = max(i_len,
									j_len,
									ans[i][j][k-1],
									i_j_len)
	#print(ans)
	print(ans[r][g][b])





solve()
",cubic,"dp,greedy,sortings",1046
"# https://codeforces.com/contest/1398/problem/D
import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__
# do magic here
sys.setrecursionlimit(200000)
r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

dp = [[[0 for i in range(b+5)] for j in range(g+5)] for k in range(r+5)]


def solve(i, j, k):
    x, y, z = 0, 0, 0
    if dp[i][j][k]:
        return dp[i][j][k]
    if i < r and j < g:
        x = (R[i] * G[j]) + solve(i+1, j+1, k)
    if i < r and k < b:
        y = (R[i] * B[k]) + solve(i+1, j, k+1)
    if j < g and k < b:
        z = (G[j] * B[k]) + solve(i, j+1, k+1)
    mx = max([x, y, z])
    dp[i][j][k] = mx
    return mx


print(solve(0, 0, 0))
",cubic,"dp,greedy,sortings",838
"n, m, v = map(lambda x: int(x) + 1, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
dp = []
for i in range(n):
    dp.append([])
    for j in range(m):
        dp[i].append([0] * v)
a.sort(reverse=1)
b.sort(reverse=1)
c.sort(reverse=1)
a = [0] + a
b = [0] + b
c = [0] + c
ans = 0
for i in range(n):
    for j in range(m):
        for k in range(v):
            if i == j == k == 0:
                continue
            if i == j == 0 or i == k == 0 or j == k == 0:
                continue
            if i == 0:
                dp[i][j][k] = dp[i][j - 1][k - 1] + \
                              b[j] * c[k]
            elif j == 0:
                dp[i][j][k] = dp[i - 1][j][k - 1] + \
                              a[i] * c[k]
            elif k == 0:
                dp[i][j][k] = dp[i - 1][j - 1][k] + \
                              a[i] * b[j]
            else:
                dp[i][j][k] = max(dp[i - 1][j - 1][k] + a[i] * b[j],
                                  dp[i - 1][j][k - 1] + a[i] * c[k],
                                  dp[i][j - 1][k - 1] + b[j] * c[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,"dp,greedy,sortings",1204
"#greedy is wrong due to the constraint ki do alag se uthenge, so youd also want to keep 2 ppl above 0

#yeh dp se hoga, clear hai

import sys

def input():
	return sys.stdin.readline().rstrip()

def input_split():
	return [int(i) for i in input().split()]

# testCases = int(input())
# answers = []
# for _ in range(testCases):
	#take input
x, y, z  = input_split()
arr_x = input_split()
arr_y = input_split()
arr_z = input_split()

x += 1
y += 1
z += 1

lengths = [x,y, z]
arrs = [arr_x, arr_y, arr_z ]

for a in arrs:
	a.sort()
	# a.reverse()

dp = [[[0 for k in range(z)] for j in range(y)] for i in range(x)]

for i in range(1,x):
	for j in range(1,y):
		# if i!= 0 and j!= 0:
		dp[i][j][0] = dp[i-1][j-1][0] + arr_x[i-1]*arr_y[j-1]

for j in range(1, y):
	for k in range(1, z):
		# if j!= 0 and k!= 0:
		dp[0][j][k] = dp[0][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			
for i in range(1,x):
	for k in range(1,z):
		# if i!= 0 and k!= 0:
		dp[i][0][k] = dp[i-1][0][k-1] + arr_x[i-1]*arr_z[k-1]

for i in range(1, x):
	for j in range(1, y):
		for k in range(1, z):
			opt1 = dp[i-1][j-1][k] + arr_x[i-1]*arr_y[j-1]
			opt2 = dp[i][j-1][k-1] + arr_y[j-1]*arr_z[k-1]
			opt3 = dp[i-1][j][k-1] + arr_x[i-1]*arr_z[k-1]
			# opt2 = d
			dp[i][j][k] = max(opt1, opt2, opt3)

ans = dp[x-1][y-1][z-1]
# used_x = 0
# used_y = 0
# used_z = 0
# used = [used_x, used_y, used_z]
# while(True):
# 	poss = []
# 	for i in range(3):
# 		if used[i] < lengths[i]:
# 			poss.append((arrs[i][used[i]], i))

# 	if len(poss) <= 1:
# 		break

# 	else:
# 		poss.sort()
# 		v1, t1 = poss[-1]
# 		v2, t2 = poss[-2]

# 		ans += v1*v2
# 		used[t1] += 1
# 		used[t2] += 1

print(ans)	
# answers.append(ans)

# print(*answers, sep = '\n')
",cubic,"dp,greedy,sortings",1703
"R,G,B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse =True)
g = sorted(list(map(int, input().split())), reverse =True)
b = sorted(list(map(int, input().split())), reverse =True)
def f(x,y,z):
    m1 = 0
    m2 = 0
    m3 = 0
    if(x<R and y<G):
        if(dpt[x+1][y+1][z]==-1):
            dpt[x+1][y+1][z] = f(x+1,y+1,z)
        m1 = r[x]*g[y] + dpt[x+1][y+1][z]
    if(y<G and z<B):
        if(dpt[x][y+1][z+1]==-1):
            dpt[x][y+1][z+1] = f(x,y+1,z+1)
        m2 = g[y]*b[z] + dpt[x][y+1][z+1]
    if(z<B and x<R):
        if(dpt[x+1][y][z+1]==-1):
            dpt[x+1][y][z+1] = f(x+1,y,z+1)
        m3 = r[x]*b[z] + dpt[x+1][y][z+1]
    dpt[x][y][z] = max(m1,m2,m3)
    return dpt[x][y][z]
dpt = [[[-1 for _ in range(B+1)]for _ in range(G+1)]for _ in range(R+1)]
print(f(0,0,0))",cubic,"dp,greedy,sortings",832
"import sys
input = sys.stdin.readline

a,b,c = list(map(int,input().split()))

x = list(map(int,input().split()))
y = list(map(int,input().split()))
z = list(map(int,input().split()))

x.sort(reverse=True)
y.sort(reverse=True)
z.sort(reverse=True)

a+=1
b+=1
c+=1

x = [0] + x
y = [0] + y
z = [0] + z

tmp = [[0]*c for _ in range(b)]
best = [tmp for _ in range(a)]

#print(tmp)
#print(best)
ans = 0

for i in range(a):
    for j in range(b):
        for k in range(c):
            if (i+j+k) % 2 == 0:
                aa,bb,cc = 0,0,0
                if i>0 and j>0:
                    aa = best[i-1][j-1][k] + x[i] * y[j]
                if i>0 and k>0:
                    bb = best[i-1][j][k-1] + x[i] * z[k]
                if j>0 and k>0:
                    cc = best[i][j-1][k-1] + y[j] * z[k]
                
                best[i][j][k] = max(aa,bb,cc)
                ans = max(ans, best[i][j][k])
#print(best)
print(ans)
",cubic,"dp,greedy,sortings",935
"from random import randint

mod = 10**9 + 7
d = {}
n, m, l = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
def go(i, j, k):
    val = i * 40401 + j * 201 + k
    ret = 0
    if val in d:
        return d[val]
    elif i < n and j < m and k < l:
        ret = max(a[i] * b[j] + go(i + 1, j + 1, k), b[j] * c[k] + go(i, j + 1, k + 1), c[k] * a[i] + go(i + 1, j, k + 1))
    elif i < n and j < m:
        ret = a[i] * b[j] + go(i + 1, j + 1, k)
    elif j < m and k < l:
        ret = b[j] * c[k] + go(i, j + 1, k + 1)
    elif k < l and i < n:
        ret = c[k] * a[i] + go(i + 1, j, k + 1)
    d[val] = ret
    return ret

a.sort(reverse = True)
b.sort(reverse = True)
c.sort(reverse = True)
print(go(0, 0, 0))
",cubic,"dp,greedy,sortings",799
"r,g,b = map(int,input().split())
rs = list(map(int,input().split()))
gs = list(map(int,input().split()))
bs = list(map(int,input().split()))
rs.sort()
gs.sort()
bs.sort()
rs.reverse()
gs.reverse()
bs.reverse()
dp = [[[0]*201 for x in range(201)] for y in range(201)]
for i in range(min(r,g)+1):
    for j in range(min(g,b)+1):
        for k in range(min(b,r)+1):
            options = []
##            if i == 0 and j == 0:
##                dp[i][j][k] = dp[i][j][k-1] + bs[k-1]*rs[k-1]
##                continue
##            elif j == 0 and k == 0:
##                dp[i][j][k] = dp[i-1][j][k] + rs[i-1]*gs[i-1]
##                continue
##            elif i == 0 and k == 0:
##                dp[i][j][k] = dp[i][j-1][k] + gs[j-1]*bs[j-1]
##                continue
            if i == 0:
                pass
            elif i+k-1 < r and i+j-1 < g:
                options.append(dp[i-1][j][k] + rs[i+k-1]*gs[i+j-1])
            else:
                options.append(dp[i-1][j][k])
            if j == 0:
                pass
            elif i+j-1 < g and j+k-1 < b:
                options.append(dp[i][j-1][k] + gs[i+j-1]*bs[j+k-1])
            else:
                options.append(dp[i][j-1][k])
            if k == 0:
                pass
            elif j+k-1 < b and i+k-1 < r:
                options.append(dp[i][j][k-1] + bs[j+k-1]*rs[i+k-1])
            else:
                options.append(dp[i][j][k-1])
            if len(options) == 0:
                continue
            dp[i][j][k] = max(options)
print(dp[min(r,g)][min(g,b)][min(r,b)])           


##rp = r-1
##gp = g-1
##bp = b-1
##ans = 0
##m = min(rs[rp],gs[gp],bs[bp])
##if m == rs[rp] and m == gs[gp]:
##    if rp < gp:
##        ans += bs[bp]*gs[gp]
",cubic,"dp,greedy,sortings",1736
"# import sys
# sys.stdin = open('CF_E93_D2/input.txt', 'r') 
# sys.stdout = open('CF_E93_D2/output.txt', 'w')
#----------------------------------------------------------------

r,g,b = list(map(int,input().split()))
dp = [ [ [-1]*(b+1) for i in range(g+1) ] for j in range(r+1) ]
ra = sorted(list(map(int,input().split())),reverse=True)
ga = sorted(list(map(int,input().split())),reverse=True)
ba = sorted(list(map(int,input().split())),reverse=True)

def solve(i,j,k) :
    
    if dp[i][j][k] != -1 :
        return dp[i][j][k]

    if i==r :
        if j==g or k==b :
            return 0
        dp[i][j][k] = ga[j] * ba[k] + solve(i,j+1,k+1)

    elif j==g :
        if i==r or k==b:
            return 0
        dp[i][j][k] = ra[i] * ba[k] + solve(i+1,j,k+1)
        
    elif k==b :
        if j==g or i==r:
            return 0
        dp[i][j][k] = ga[j] * ra[i] + solve(i+1,j+1,k)
    
    else :
        dp[i][j][k] = max(ra[i]*ga[j] + solve(i+1,j+1,k),ra[i]*ba[k] + solve(i+1,j,k+1),ba[k]*ga[j] + solve(i,j+1,k+1))

    return dp[i][j][k]


print(solve(0,0,0))",cubic,"dp,greedy,sortings",1072
"import io
import os

from collections import Counter, defaultdict, deque


def solveBFS(NR, NG, NB, R, G, B):
    def pack(i, j, k):
        return i * 256 * 256 + j * 256 + k

    def unpack(ijk):
        i, jk = divmod(ijk, 256 * 256)
        j, k = divmod(jk, 256)
        return i, j, k

    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)
    dp = [0 for i in range(256 ** 3)]
    q = deque([0])
    while q:
        ijk = q.popleft()
        d = dp[ijk]
        i, j, k = unpack(ijk)

        if i < NR:
            r = R[i]

        if j < NG:
            g = G[j]
        if k < NB:
            b = B[k]
        if i + 1 <= NR and j + 1 <= NG:
            rg = pack(i + 1, j + 1, k)
            dp[rg] = max(dp[rg], r * g + d)
            q.append(rg)

        if i + 1 <= NR and k + 1 <= NB:
            rb = pack(i + 1, j, k + 1)
            dp[rb] = max(dp[rb], r * b + d)
            q.append(rb)

        if j + 1 <= NG and k + 1 <= NB:
            gb = pack(i, j + 1, k + 1)
            dp[gb] = max(dp[gb], g * b + d)
            q.append(gb)

    return max(dp)


def solve(NR, NG, NB, R, G, B):
    assert NR == len(R)
    R.sort(reverse=True)
    G.sort(reverse=True)
    B.sort(reverse=True)

    R += [0]
    G += [0]
    B += [0]

    NR1 = NR + 2
    NG1 = NG + 2
    NB1 = NB + 2
    dp = [0 for i in range((NR1) * (NG1) * (NB1))]

    def pack(i, j, k):
        return i * NG1 * NB1 + j * NB1 + k

    inf = float(""inf"")
    for i in range(NR + 1):
        for j in range(NG + 1):
            dp[pack(i, j, -1)] = -inf
    for i in range(NR + 1):
        for k in range(NB + 1):
            dp[pack(i, -1, k)] = -inf

    for j in range(NG + 1):
        for k in range(NB + 1):
            dp[pack(-1, j, k)] = -inf

    for l in range(2, NR + NG + NB + 1, 2):
        for j in range(NG + 1):
            for k in range(NB + 1):
                i = l - j - k
                if i < 0 or i > NR:
                    continue
                r = R[i - 1]
                g = G[j - 1]
                b = B[k - 1]
                dp[pack(i, j, k)] = max(
                    r * g + dp[pack(i - 1, j - 1, k)],
                    r * b + dp[pack(i - 1, j, k - 1)],
                    b * g + dp[pack(i, j - 1, k - 1)],
                )

    return max(dp)


if False:
    import random

    random.seed()
    N = 5
    for t in range(100):
        R = [random.randint(1, 10) for i in range(random.randint(1, N))]
        G = [random.randint(1, 10) for i in range(random.randint(1, N))]
        B = [random.randint(1, 10) for i in range(random.randint(1, N))]
        ans1 = solveBFS(len(R), len(G), len(B), R, G, B)
        ans2 = solve(len(R), len(G), len(B), R, G, B)
        if ans1 != ans2:
            print(ans1, ans2)
            print(R, G, B)
        exit()
if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    NR, NG, NB = [int(x) for x in input().split()]
    R = [int(x) for x in input().split()]
    G = [int(x) for x in input().split()]
    B = [int(x) for x in input().split()]
    ans = solve(NR, NG, NB, R, G, B)
    print(ans)

",cubic,"dp,greedy,sortings",3136
"from sys import stdin
from array import array
def recSolve(dp,r,g,b,rx,gx,bx, R, G, B):
	if rx == R:
		return sum(a * b for a, b in zip(g[gx:], b[bx:]))
	if gx == G:
		return sum(a * b for a, b in zip(r[rx:], b[bx:]))
	if bx == B:
		return sum(a * b for a, b in zip(g[gx:], r[rx:]))
	if dp[rx * G * B + gx * B + bx] != -1:
		return dp[rx * G * B + gx * B + bx]
	rg = recSolve(dp, r, g, b, rx + 1, gx + 1, bx, R, G, B) + r[rx] * g[gx]
	bg = recSolve(dp, r, g, b, rx, gx + 1, bx + 1, R, G, B) + b[bx] * g[gx]
	rb = recSolve(dp, r, g, b, rx + 1, gx, bx + 1, R, G, B) + r[rx] * b[bx]
	ans = max(rg, bg, rb)
	dp[rx * G * B + gx * B + bx] = ans
	return ans
input = stdin.readline
R, G, B = map(int, input().split())
r = sorted([*map(int, input().split())], reverse = True)
g = sorted([*map(int, input().split())], reverse = True) 
b = sorted([*map(int, input().split())], reverse = True) 
dp = array('q', (-1 for x in range(R * G * B)))
print(recSolve(dp, r, g, b, 0, 0, 0, R, G, B))",cubic,"dp,greedy,sortings",977
"R, G, B = list(map(lambda x: int(x), input().split()))
r = list(map(lambda x: int(x), input().split()))
g = list(map(lambda x: int(x), input().split()))
b = list(map(lambda x: int(x), input().split()))

def f(t):
    i, j, k = t
    return (i+1)*(G+1)*(B+1) + (j+1)*(B+1) + (k+1)

max_area = [None]*((R+1)*(G+1)*(B+1)+1)

def get_max_area(i, j, k):
    temp = f((i,j,k))
    if max_area[temp] != None:
        return max_area[temp]
    x1=x2=x3=0
    if i >= 0 and j>=0:
        x1 = get_max_area(i-1, j-1, k) + r[i]*g[j]
    if i >= 0 and k >= 0:
        x2 = get_max_area(i-1, j, k-1) + r[i]*b[k]
    if j >= 0 and k >= 0:
        x3 = get_max_area(i, j-1, k-1) + g[j]*b[k]

    max_area[temp] = max(x1, x2, x3)
    return max_area[temp]

r.sort()
g.sort()
b.sort()
print(get_max_area(R-1, G-1, B-1))
#print(max_area)    ",cubic,"dp,greedy,sortings",823
"from sys import stdin, gettrace

if gettrace():
    inputi = input
else:
    def input():
        return next(stdin)[:-1]


    def inputi():
        return stdin.buffer.readline()


def main():
    r, g, b = map(int, inputi().split())
    rr = list(sorted(int(a) for a in inputi().split()))
    gg = list(sorted(int(a) for a in inputi().split()))
    bb = list(sorted(int(a) for a in inputi().split()))
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    res = 0
    for i in range(r, -1, -1):
        for j in range(g, -1, -1):
            for k in range(b, -1, -1):
                if i > 0 and j > 0:
                    dp[i-1][j-1][k] = max(dp[i-1][j-1][k], dp[i][j][k] + rr[i-1]*gg[j-1])
                if i > 0 and k > 0:
                    dp[i-1][j][k-1] = max(dp[i-1][j][k-1], dp[i][j][k] + rr[i-1]*bb[k-1])
                if j > 0 and k > 0:
                    dp[i][j-1][k-1] = max(dp[i][j-1][k-1], dp[i][j][k] + gg[j-1]*bb[k-1])
                res = max(res, dp[i-1][j-1][k], dp[i-1][j][k-1] , dp[i][j-1][k-1])
    print(res)


if __name__ == ""__main__"":
    main()
",cubic,"dp,greedy,sortings",1100
"from sys import stdin,stdout

# stdin  = open(""input.txt"",""r"")
# stdout = open(""output.txt"",""w"")


final_ans=0

# def solve(r,g,b):
# 	print(r,g,b)
# 	ans=0
# 	if min(r,g,b)<0:
# 		return 0
# 	if dparr[r-1][g-1][b]==-1:
# 		solve(r-1,g-1,b)
# 	ans=max(ans,dparr[r-1][g-1][b]+Ra[r-1]*Ga[g-1])
# 	if dparr[r-1][g][b-1]==-1:
# 		solve(r-1,g,b-1)
# 	ans=max(ans,dparr[r-1][g][b-1]+Ra[r-1]*Ba[b-1])
# 	if dparr[r][g-1][b-1]==-1:
# 		solve(r,g-1,b-1)
# 	ans=max(ans,dparr[r][g-1][b-1]+Ga[g-1]*Ba[b-1])
# 	dparr[r][g][b]=ans


R,G,B = map(int,stdin.readline().strip().split(' '))
Ra = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ga = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)
Ba = sorted(list(map(int, stdin.readline().strip().split(' '))), reverse=True)

dparr=[[[-1 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
dparr[1][1][0]=Ra[0]*Ga[0]
dparr[1][0][1]=Ra[0]*Ba[0]
dparr[0][1][1]=Ga[0]*Ba[0]
final_ans=max(final_ans,dparr[1][1][0],dparr[1][0][1],dparr[0][1][1])
# solve(R,G,B)
# stdout.write(str(dparr[R][G][B])+""\n"")


def add_ns(t1):
	global queue,Ra,Ga,Ba,dparr
	x,y,z=t1
	if x+1<=R:
		if y+1<=G:
			if dparr[x+1][y+1][z]==-1:
				queue.append((x+1,y+1,z))
				dparr[x+1][y+1][z]=0
		
		if z+1<=B:
			if dparr[x+1][y][z+1]==-1:
				queue.append((x+1,y,z+1))
				dparr[x+1][y][z+1]=0
	if y+1<=G and z+1<=B:
		if dparr[x][y+1][z+1]==-1:
			queue.append((x,y+1,z+1))
			dparr[x][y+1][z+1]=0

def store_ans(t1):
	global final_ans,dparr,Ra,Ga,Ba
	x,y,z=t1
	if dparr[x-1][y-1][z]!=-1 and min(x-1,y-1,z)>=0:
		# print(dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y-1][z]+Ra[x-1]*Ga[y-1])
	if dparr[x-1][y][z-1]!=-1 and min(x-1,y,z-1)>=0:
		# print(dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x-1][y][z-1]+Ra[x-1]*Ba[z-1])
	if dparr[x][y-1][z-1]!=-1 and min(x,y-1,z-1)>=0:
		# print(dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])
		dparr[x][y][z] = max(dparr[x][y][z],dparr[x][y-1][z-1]+Ga[y-1]*Ba[z-1])
	# print(dparr[x][y][z])

	final_ans=max(final_ans,dparr[x][y][z])

queue=[(1,1,0),(1,0,1),(0,1,1)]
add_ns(queue[0])
add_ns(queue[1])
add_ns(queue[2])
ptr=3

while ptr<len(queue):
	# print(queue[ptr])
	store_ans(queue[ptr])
	# print()
	add_ns(queue[ptr])
	
	ptr+=1

stdout.write(str(final_ans)+""\n"")",cubic,"dp,greedy,sortings",2338
"def solve(i, j, k):
    if (i < 0 and j < 0) or (j < 0 and k < 0) or (i < 0 and k < 0):
        return 0
    if dp[i][j][k] != -1:
        return dp[i][j][k]
    ans = 0
    if i >= 0 and j >= 0:
        ans = max(ans, rs[i] * gs[j] + solve(i - 1, j - 1, k))
    if i >= 0 and k >= 0:
        ans = max(ans, rs[i] * bs[k] + solve(i - 1, j, k - 1))
    if j >= 0 and k >= 0:
        ans = max(ans, bs[k] * gs[j] + solve(i, j - 1, k - 1))
    dp[i][j][k] = ans
    return ans

a, b, c = map(int, input().split())
rs = sorted(list(map(int, input().split())))
gs = sorted(list(map(int, input().split())))
bs = sorted(list(map(int, input().split())))
dp = [[[-1 for x in range(c + 1)] for y in range(b + 1)] for z in range(a + 1)]
print(solve(a - 1, b - 1, c - 1))
",cubic,"dp,greedy,sortings",760
"import sys
input = sys.stdin.readline

r, g, b, = [int(_) for _ in input().split()]
R = [int(_) for _ in input().split()]
G = [int(_) for _ in input().split()]
B = [int(_) for _ in input().split()]
R = sorted(R, reverse=True)
G = sorted(G, reverse=True)
B = sorted(B, reverse=True)

dp = []  # best score so far after picking (iR, jG, kB)
for i in range(r+1):
    sdp = [[0]*(b+1) for _ in range(g+1)]
    dp.append(sdp)

answer = 0
for nb_taken in range(r+g+b):
    if nb_taken % 2:
        continue
    # print('nb_taken', nb_taken)
    for i in range(nb_taken+1):
        if i > r:
            break
        for j in range(nb_taken-i-b, nb_taken-i+1):
            if j > g:
                break
            k = nb_taken-i-j
            if k > b:
                continue
            if i+j < k or i+k < j or j+k < i:
                continue
            # assert i+j+k == nb_taken
            # print('in dp', i, j, k)
# for i in range(r):
    # for j in range(g):
        # for k in range(b):
            if i < r and j < g:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + R[i]*G[j])
                # print('setting dp', i+1, j+1, k, dp[i+1][j+1][k])
                answer = max(answer, dp[i+1][j+1][k])
            if i < r and k < b:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + R[i]*B[k])
                # print('setting dp', i+1, j, k+1, dp[i+1][j][k+1])
                answer = max(answer, dp[i+1][j][k+1])
            if j < g and k < b:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + G[j]*B[k])
                # print('setting dp', i, j+1, k+1, dp[i][j+1][k+1])
                answer = max(answer, dp[i][j+1][k+1])
# print(dp)
print(answer)

# k > b <=> nb_taken-i-j >= b <=> j <= nb_taken-i-b
",cubic,"dp,greedy,sortings",1779
"from collections import defaultdict
from sys import setrecursionlimit,stdin
input=stdin.readline
setrecursionlimit(100000)

def dfs(r,g,b,rr,gg,bb):
    if r<0 or g<0 or b<0:
        return 0
    x=0
    y=0
    z=0
    
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    if r!=0 and g!=0:
        x=rr[r-1]*gg[g-1]+dfs(r-1,g-1,b,rr,gg,bb)
    if r!=0 and b!=0:
        y=rr[r-1]*bb[b-1]+dfs(r-1,g,b-1,rr,gg,bb)
    if b!=0 and g!=0:
        z=bb[b-1]*gg[g-1]+dfs(r,g-1,b-1,rr,gg,bb)
    dp[r][g][b]=max(x,y,z)
    return max(x,y,z)

r,g,b=map(int,input().split())
rr=list(map(int,input().split()))
gg=list(map(int,input().split()))
bb=list(map(int,input().split()))
rr.sort()
gg.sort()
bb.sort()
dp=[[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

print(dfs(r,g,b,rr,gg,bb))





",cubic,"dp,greedy,sortings",792
"#import sys
#input = sys.stdin.readline
def main():
    R, G, B = map( int, input().split())
    Rs = list( map( int, input().split()))
    Gs = list( map( int, input().split()))
    Bs = list( map( int, input().split()))

    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)

    dp = [[[0]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                t = 0
                if i > 0 and j > 0:
                    if dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1] > t:
                        t = dp[i-1][j-1][k] + Rs[i-1]*Gs[j-1]
                if j > 0 and k > 0:
                    if dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1] > t:
                        t = dp[i][j-1][k-1] + Gs[j-1]*Bs[k-1]
                if k > 0 and i > 0:
                    if dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1] > t:
                        t = dp[i-1][j][k-1] + Bs[k-1]*Rs[i-1]
                dp[i][j][k] = t
                if ans < t:
                    ans = t
    print(ans)
                        

if __name__ == '__main__':
    main()
",cubic,"dp,greedy,sortings",1133
"import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
#from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction
#sys.setrecursionlimit(100000)
INF = float('inf')
mod = int(1e9)+7

from types import GeneratorType

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

@bootstrap
def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        yield 0
        return
    if dp[r][g][b]:
        yield dp[r][g][b]
        return
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+(yield recur(r-1,g-1,b)))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+(yield recur(r-1,g,b-1)))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+(yield recur(r,g-1,b-1)))
    yield dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",cubic,"dp,greedy,sortings",1822
"import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
#from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write('\n'.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
from decimal import Decimal
from fractions import Fraction
#sys.setrecursionlimit(100000)
INF = float('inf')
mod = int(1e9)+7


def recur(r,g,b):
    if (r+b+g)==r or (r+b+g)==g or (r+b+g)==b:
        return 0
    if dp[r][g][b]:
        return dp[r][g][b]
    if r>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*G[g-1]+recur(r-1,g-1,b))
    if r>0 and b>0:
        dp[r][g][b]=max(dp[r][g][b],R[r-1]*B[b-1]+recur(r-1,g,b-1))
    if b>0 and g>0:
        dp[r][g][b]=max(dp[r][g][b],B[b-1]*G[g-1]+recur(r,g-1,b-1))
    return dp[r][g][b]

r,g,b=mdata()
R=sorted(mdata())
G=sorted(mdata())
B=sorted(mdata())
dp=[[[0]*(b+1) for i in range(g+1)] for i in range(r+1)]
out(recur(r,g,b))
",cubic,"dp,greedy,sortings",1206
"import heapq


def read_int():
    return int(input().strip())


def read_ints():
    return list(map(int, input().strip().split(' ')))


def solve():
    '''
    8 8 8 8 8 8
    9 9
    9 9

    81+81

    72+72+72+72
    '''
    R, G, B = read_ints()
    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]
    # dp[R][G][B]
    Rs = read_ints()
    Gs = read_ints()
    Bs = read_ints()
    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)
    answer = 0
    for r in range(R+1):
        for g in range(G+1):
            for b in range(B+1):
                if r > 0 and g > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])
                if g > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])
                if r > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])
                answer = max(answer, dp[r][g][b])
    return answer


if __name__ == '__main__':
    print(solve())
",cubic,"dp,greedy,sortings",1067
"from math import *
from collections import *
from random import *
from decimal import Decimal
from heapq import *
from bisect import *
import sys
input=sys.stdin.readline
sys.setrecursionlimit(10**5)
def lis():
    return list(map(int,input().split()))
def ma():
    return map(int,input().split())
def inp():
    return int(input())
def st1():
    return input().rstrip('\n')
t=1
while(t):
    t-=1
    r,g,b=ma()
    rl=lis()
    gl=lis()
    bl=lis()
    rl.sort()
    bl.sort()
    gl.sort()
    dp= [[[0]*(b+1)for i in range(g+1)] for j in range(r+1)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i+j+k<2):
                    continue
                if(i and j):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+rl[i-1]*gl[j-1])
                if(j and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+gl[j-1]*bl[k-1])
                if(i and k):
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+rl[i-1]*bl[k-1])
    print(dp[r][g][b])
    
        
",cubic,"dp,greedy,sortings",1069
"

def read_int():
    return int(raw_input().strip())


def read_ints():
    return list(map(int, raw_input().strip().split(' ')))


def solve():
    '''
    8 8 8 8 8 8
    9 9
    9 9

    81+81

    72+72+72+72
    '''
    R, G, B = read_ints()
    dp = [[[0 for _ in range(B+1)] for _ in range(G+1)] for _ in range(R+1)]
    # dp[R][G][B]
    Rs = read_ints()
    Gs = read_ints()
    Bs = read_ints()
    Rs.sort(reverse=True)
    Gs.sort(reverse=True)
    Bs.sort(reverse=True)
    answer = 0
    for r in range(R+1):
        for g in range(G+1):
            for b in range(B+1):
                if r > 0 and g > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g-1][b]+Rs[r-1]*Gs[g-1])
                if g > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r][g-1][b-1]+Gs[g-1]*Bs[b-1])
                if r > 0 and b > 0:
                    dp[r][g][b] = max(dp[r][g][b], dp[r-1][g][b-1]+Rs[r-1]*Bs[b-1])
                answer = max(answer, dp[r][g][b])
    return answer


if __name__ == '__main__':
    print(solve())
",cubic,"dp,greedy,sortings",1062
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] is not None:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]
    
    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",cubic,"dp,greedy,sortings",1017
"#: Author - Soumya Saurav
import sys,io,os,time
from collections import defaultdict
from collections import OrderedDict
from collections import deque
from itertools import combinations
from itertools import permutations
import bisect,math,heapq
alphabet = ""abcdefghijklmnopqrstuvwxyz""

input = sys.stdin.readline

########################################
'''
3 3 3 
1 2 3
1 2 3
1 2 3

'''
'''
nax = 201

nr , ng , nb = map(int, input().split())
n = nr + ng + nb
r = list(map(int , input().split()))
g = list(map(int , input().split()))
b = list(map(int , input().split()))

r.sort()
g.sort()
b.sort()

dp = [[[0]*nax for i in range(nax)] for j in range(nax)]
'''
'''
arr = [[1,i] for i in r] + [[2,i] for i in b] + [[3,i] for i in g]
arr.sort(key = lambda x : x[1],reverse = True)
ans = 0
done = [False]*n
print(arr)
for i in range(n):
	ok = False
	if done[i]: continue
	for j in range(i+1,n):
		if done[j]: continue
		if arr[i][0] != arr[j][0]:
			print(i+1,j+1,arr[i][1]*arr[j][1])
			ans += arr[i][1]*arr[j][1]
			done[i] = True
			done[j] = True
			ok = True
			break
	if not ok: break
print(ans)

'''
'''
sys.setrecursionlimit(10**7)


from functools import lru_cache
@lru_cache(None)
def f(i,j,k):
	#print(i,j,k)
	if (i >= nr and j >= ng) or (j >= ng and k >= nb) or (i >= nr and k >= nb):
		return 0
	ans = r[i]*g[j] + f(i+1,j+1,k) if i < nr and j < ng else 0
	#print(ans)
	if i < nr and k < nb:
		ans = max(ans , r[i]*b[k] + f(i+1,j,k+1)) 
	#print(""???:"",ans,r[k]*r[j] + f(i,j+1,k+1))
	if k < nb and j < ng:
		ans = max(ans, g[j]*b[k] + f(i,j+1,k+1))
	#print(ans)
	return ans
print(f(0,0,0))
	
'''
def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())



",cubic,"dp,greedy,sortings",2238
"#from collections import defaultdict
#DPL=[[[-1]*(B+1) for i in range(G+1)] for j in range(R+1)]
ri,gi,bi=map(int,input().split())
rr=sorted(list(map(int,input().split())))
gr=sorted(list(map(int,input().split())))
br=sorted(list(map(int,input().split())))
dp=[[[-1]*(bi+1) for i in range(gi+1)] for j in range(ri+1)]
def area(r,g,b):
	if dp[r+1][g+1][b+1]!=-1:
		return dp[r+1][g+1][b+1]
	ans=0
	if r>=0 and g>=0:
		ans=max(ans,rr[r]*gr[g]+area(r-1,g-1,b))
	if r>=0 and b>=0:
		ans=max(ans,rr[r]*br[b]+area(r-1,g,b-1))	
	if b>=0 and g>=0:
		ans=max(ans,br[b]*gr[g]+area(r,g-1,b-1))	
	dp[r+1][g+1][b+1]=ans
	return ans
print(area(ri-1,gi-1,bi-1))",cubic,"dp,greedy,sortings",646
"# for #!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion
class union_find:
    def __init__(self, n):
        self.n = n
        self.rank = [0]*n
        self.parent = [int(j) for j in range(n)]
    
    def union(self,i,j):
        i = self.find(i)
        j = self.find(j)
        if self.rank[i] == self.rank[j]:
            self.parent[i] = j
            self.rank[j] += 1

        elif self.rank[i] > self.rank[j]:
            self.parent[j] = i
        else:
            self.parent[i] = j

    def find(self, i):
        temp = i
        if self.parent[temp] != temp:
            self.parent[temp] = self.find(self.parent[temp])
        return self.parent[temp]
from math import log2, ceil
from collections import deque, Counter as CC, defaultdict as dd
def main():
# Enter your code here. Read input from STDIN. Print output to STDOUT
    # for t in range(int(input())):
        
        # n = int(input())
        p,q,r  = [int(j) for j in input().split()]
        a = [int(j) for j in input().split()]
        b = [int(j) for j in input().split()]
        c = [int(j) for j in input().split()]
        a.sort()
        b.sort()
        c.sort()
        l = [a,b,c]

        dp = [[[0 for i in range(r+1)] for j in range(q+1)] for k in range(p+1)]
        for i in range(p+1):
            for j in range(q+1):
                for k in range(r+1):
                    s = [i-1,j-1,k-1]
                    for u in range(3):
                        
                        s[u]+=1
                        try:
                            tmp = dp[s[0]][s[1]][s[2]]
                        except:
                            s[u]-=1
                            continue
                        tmp2 = 1
                        flag =True
                        for t in range(3):
                            if(u!=t):
                                if(s[t]==-1):
                                    flag = False
                                    break
                                tmp2 *= l[t][s[t]] 
                        tmp += tmp2
                        s[u]-=1
                        if(flag):
                            dp[i][j][k] = max(dp[i][j][k], tmp)
        print(dp[p][q][r])











        



if __name__ == ""__main__"":
    main()",cubic,"dp,greedy,sortings",3977
"import sys
input = sys.stdin.readline

MAXN = 202

def main():
    R, G, B = list(map(int, input().split()))
    r = list(map(int, input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))
    r.sort()
    g.sort()
    b.sort()
    dp = [[[0]*MAXN for _ in range(MAXN)] for _ in range(MAXN)]
    for i in range(1, R+1):
        for j in range(1, G+1):
            dp[i][j][0] = r[i-1]*g[j-1]+dp[i-1][j-1][0]
    for i in range(1, R+1):
        for k in range(1, B+1):
            dp[i][0][k] = r[i-1]*b[k-1]+dp[i-1][0][k-1]
    for j in range(1, G+1):
        for k in range(1, B+1):
            dp[0][j][k] = g[j-1]*b[k-1]+dp[0][j-1][k-1]
    for i in range(1, R+1):
        for j in range(1, G+1):
            for k in range(1, B+1):
                dp[i][j][k] = max(r[i-1]*g[j-1]+dp[i-1][j-1][k], r[i-1]*b[k-1]+dp[i-1][j][k-1], g[j-1]*b[k-1]+dp[i][j-1][k-1])
    print(dp[R][G][B])

main()
",cubic,"dp,greedy,sortings",934
"r,g, b = map(int,input().split())
R = sorted([*map(int,input().split())],reverse=True)
G= sorted([*map(int,input().split())],reverse=True)
B = sorted([*map(int,input().split())],reverse=True)
mem = [[[-1 for i in range(201)] for j in range(201)] for j in range(201)]
def dp(i,j,k):
    p = (i==r)+(j==g)+(k==b)
    if(p>1):
        return 0
    if(mem[i][j][k]!=-1):
        return mem[i][j][k]
    ans = 0
    if(i==r):
        ans = dp(i,j+1,k+1)+G[j]*B[k]
        return ans
    elif(j==g):
        ans = dp(i+1,j,k+1)+R[i]*B[k]
    elif(k==b):
        ans = dp(i+1,j+1,k)+R[i]*G[j]
    else:
        ans = max(dp(i+1,j+1,k)+R[i]*G[j],dp(i,j+1,k+1)+G[j]*B[k],dp(i+1,j,k+1)+R[i]*B[k])
    mem[i][j][k] = ans
    return ans
print(dp(0,0,0))",cubic,"dp,greedy,sortings",741
"
r,g,b=map(int,input().split())
s1=[int(x) for x in input().split()]
s2=[int(x) for x in input().split()]
s3=[int(x) for x in input().split()]
s1.sort()
s2.sort()
s3.sort()
s1=s1[::-1]
s2=s2[::-1]
s3=s3[::-1]
s1=[0]+s1
s2=[0]+s2
s3=[0]+s3

dp=[]
for i in range(r+5):
    H=[]
    for j in range(g+5):
        h=[]
        for k in range(b+5):
            h.append(0)
        H.append(h)
    dp.append(H)

for i in range(0,r+1):
    for j in range(0,g+1):
        for k in range(0,b+1):
            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0
            if(i-1>=0 and j-1>=0):
                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])
            if(i-1>=0 and k-1>=0):
                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])
            if(k-1>=0 and j-1>=0):
                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])
            if(i-1>=0):
                t4 = dp[i-1][j][k]
            if(j-1>=0):
                t5 = dp[i][j-1][k]
            if(k-1>=0):
                t6 = dp[i][j][k-1]

            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)



print(dp[r][g][b])

",cubic,"dp,greedy,sortings",1044
"r,g,b=map(int,input().split())
s1=[int(x) for x in input().split()]
s2=[int(x) for x in input().split()]
s3=[int(x) for x in input().split()]
s1.sort()
s2.sort()
s3.sort()
s1=s1[::-1]
s2=s2[::-1]
s3=s3[::-1]
s1=[0]+s1
s2=[0]+s2
s3=[0]+s3

dp=[]
for i in range(r+5):
    H=[]
    for j in range(g+5):
        h=[]
        for k in range(b+5):
            h.append(0)
        H.append(h)
    dp.append(H)


for i in range(0,r+1):
    for j in range(0,g+1):
        for k in range(0,b+1):
            t1,t2,t3,t4,t5,t6 = 0,0,0,0,0,0
            if(i-1>=0 and j-1>=0):
                t1 = dp[i-1][j-1][k] + (s1[i]*s2[j])
            if(i-1>=0 and k-1>=0):
                t2 = dp[i-1][j][k-1] + (s1[i]*s3[k])
            if(k-1>=0 and j-1>=0):
                t3 = dp[i][j-1][k-1] + (s2[j]*s3[k])
            if(i-1>=0):
                t4 = dp[i-1][j][k]
            if(j-1>=0):
                t5 = dp[i][j-1][k]
            if(k-1>=0):
                t6 = dp[i][j][k-1]

            dp[i][j][k] = max(t1,t2,t3,t4,t5,t6)

print(dp[r][g][b])

",cubic,"dp,greedy,sortings",1042
"from sys import stdin
inp = lambda : stdin.readline().strip()

nr, ng, nb = [int(x) for x in inp().split()]

r = [int(x) for x in inp().split()]
g = [int(x) for x in inp().split()]
b = [int(x) for x in inp().split()]
r.sort()
g.sort()
b.sort()
dp = [[[0 for _ in range(201)] for _ in range(201)] for _ in range(201)]
for i in range(nr+1):
    for j in range(ng+1):
        for k in range(nb+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1]);
            if i and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1]);
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1]);
 
print(dp[nr][ng][nb])",cubic,"dp,greedy,sortings",721
"def solve(x,y,z):
    global r,g,b,ans
    if (x > r - 1 and y > g - 1) or (x > r - 1 and z > b - 1) or (y > g - 1 and z > b - 1):
        return 0
    if memo[x][y][z] != -1:
        return memo[x][y][z]
    mx = 0
    if x < r and y < g: 
        mx = max(mx,ra[x]*ga[y] + solve(x+1,y+1,z))
    if x < r and z < b:
        mx = max(mx,ra[x]*ba[z] + solve(x+1,y,z+1))
    if y < g and z < b:
        mx = max(mx,ga[y]*ba[z] + solve(x,y+1,z+1))
    ans = max(ans,mx)
    memo[x][y][z] = mx
    return mx

r,g,b = map(int,input().split())
ra = sorted(list(map(int,input().split())),reverse = True)
ga = sorted(list(map(int,input().split())),reverse = True)
ba = sorted(list(map(int,input().split())),reverse = True)

memo = [[[-1 for k in range(205)] for i in range(205)] for j in range(205)]

ans = 0

solve(0,0,0)
print(ans)

",cubic,"dp,greedy,sortings",827
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[-1 for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

def recursive(idx_r, idx_g, idx_b):
    if dp[idx_r][idx_g][idx_b] != -1:
        return dp[idx_r][idx_g][idx_b]
    res_1 = 0
    res_2 = 0
    res_3 = 0
    if (idx_r-1) >= 0 and (idx_g-1) >= 0:
        res_1 = recursive(idx_r-1, idx_g-1, idx_b) + ls_r[idx_r-1] * ls_g[idx_g-1]
    if (idx_g-1) >= 0 and (idx_b-1) >= 0:
        res_2 = recursive(idx_r, idx_g-1, idx_b-1) + ls_g[idx_g-1] * ls_b[idx_b-1]
    if (idx_r-1) >= 0 and (idx_b-1) >= 0:
        res_3 = recursive(idx_r-1, idx_g, idx_b-1) + ls_r[idx_r-1] * ls_b[idx_b-1]
    
    dp[idx_r][idx_g][idx_b] = max(res_1, res_2, res_3)
    return dp[idx_r][idx_g][idx_b]

print(recursive(r,g,b))",cubic,"dp,greedy,sortings",1009
"#tests = int(input())
#for t in range(tests):
#    b= int(input())
#    ls = [int(x) for x in input()]

r,g,b = list(map(int, input().split()))
ls_r = sorted(list(map(int, input().split())))
ls_g = sorted(list(map(int, input().split())))
ls_b = sorted(list(map(int, input().split())))


dp = [[[None for _ in range(b+1)]for _ in range(g+1)]for _ in range(r+1)]

for i in range(r+1):
    dp[i][0][0] = 0
for i in range(g+1):
    dp[0][i][0] = 0
for i in range(b+1):
    dp[0][0][i] = 0

dp[1][1][0] = ls_r[0] * ls_g[0]
dp[0][1][1] = ls_g[0] * ls_b[0]
dp[1][0][1] = ls_r[0] * ls_b[0]    

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            res1 = 0
            res2 = 0
            res3 = 0
            if i-1>=0 and j-1>=0:
                res1 += dp[i-1][j-1][k] + ls_r[i-1] * ls_g[j-1]
            if i-1>=0 and k-1>=0:
                res2 += dp[i-1][j][k-1] + ls_r[i-1] * ls_b[k-1]
            if j-1>=0 and k-1>=0:
                res3 += dp[i][j-1][k-1] + ls_g[j-1] * ls_b[k-1]
            dp[i][j][k] = max(res1,res2,res3)
print(dp[r][g][b])",cubic,"dp,greedy,sortings",1083
"R,G,B=map(int,input().split())
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split())) 
r.sort(reverse=True) 
g.sort(reverse=True) 
b.sort(reverse=True) 
#print(r,g,b)
dp=[[[-1 for i in range(205)] for j in range(205)] for k in range(205)]
def recurser(x,y,z):
    if (x>=R and y>=G) or (y>=G and z>=B) or (z>=B and x>=R):
        return 0 
    if dp[x][y][z]!=-1:
        return dp[x][y][z] 
    maxi=0 
    if x<R and y<G:
        maxi=max(maxi,r[x]*g[y]+recurser(x+1,y+1,z)) 
    if y<G and z<B:
        maxi=max(maxi,g[y]*b[z]+recurser(x,y+1,z+1)) 
    if z<B and x<R:
        maxi=max(maxi,r[x]*b[z]+recurser(x+1,y,z+1))
    dp[x][y][z]=maxi
    return maxi 
print(recurser(0,0,0)) ",cubic,"dp,greedy,sortings",730
"nr, ng, nb = map(int, input().split())
r = sorted([int(i) for i in input().split()])
g = sorted([int(i) for i in input().split()])
b = sorted([int(i) for i in input().split()])

dp = [[[0 for _ in range(nb + 1)] for _ in range(ng + 1)] for _ in range(nr + 1)]
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            val = 0
            if i - 1 >= 0 and j - 1 >= 0:
                val = max(val, r[i - 1] * g[j - 1] + dp[i - 1][j - 1][k])
            if i - 1 >= 0 and k - 1 >= 0:
                val = max(val, r[i - 1] * b[k - 1] + dp[i - 1][j][k - 1])
            if j - 1 >= 0 and k - 1 >= 0:
                val = max(val, g[j - 1] * b[k - 1] + dp[i][j - 1][k - 1])
            dp[i][j][k] = val

print(dp[nr][ng][nb])
",cubic,"dp,greedy,sortings",765
"import os
import heapq
import sys, threading
import math
import bisect
import operator
from collections import defaultdict

sys.setrecursionlimit(10 ** 5)
from io import BytesIO, IOBase


def gcd(a, b):
    if b == 0:

        return a
    else:
        return gcd(b, a % b)


def power(x, p, m):
    res = 1
    while p:
        if p & 1:
            res = (res * x) % m
        x = (x * x) % m
        p >>= 1
    return res


def inar():
    return [int(k) for k in input().split()]


def lcm(num1, num2):
    return (num1 * num2) // gcd(num1, num2)
rr=0
gg=0
bb=0
dp=[]
def func(x,y,z,red,green,blue):
    if (x>=rr and y>=gg) or (y>=gg and z>=bb) or (x>=rr and z>=bb):
        return 0
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    take=0
    if x<rr and y<gg:
        take=max(take,red[x]*green[y]+func(x+1,y+1,z,red,green,blue))
    if y<gg and z<bb:
        take=max(take,green[y]*blue[z]+func(x,y+1,z+1,red,green,blue))
    if x<rr and z<bb:
        take=max(take,red[x]*blue[z]+func(x+1,y,z+1,red,green,blue))
    dp[x][y][z]=take
    return take

def main():
    global rr,gg,bb,dp
    # t=int(input())
    for i in range(202):
        temp=[]
        for j in range(202):
            lis=[]
            for k in range(202):
                lis.append(-1)
            temp.append(lis)
        dp.append(temp)
    rr, gg, bb = map(int, input().split())
    red = inar()
    green = inar()
    blue = inar()
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    print(func(0,0,0,red,green,blue))




BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()
    # threadin.Thread(target=main).start()
",cubic,"dp,greedy,sortings",3285
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
ans = 0
for i in dp:
       for j in i:
              ans = max(ans, max(j))

print(ans)
",cubic,"dp,greedy,sortings",770
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",cubic,"dp,greedy,sortings",700
"def solve(i, j, k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    call = 0
    if i>0 and j>0:
        call = max(call, R[i]*G[j]+solve(i-1, j-1, k))
    if j>0 and k>0:
        call = max(call, G[j]*B[k]+solve(i, j-1, k-1))
    if k>0 and i>0:
        call = max(call, B[k]*R[i]+solve(i-1, j, k-1))
    dp[i][j][k] = call
    return call


nr, ng, nb = map(int,input().split())
R = [0]+list(map(int,input().split()))
G = [0]+list(map(int,input().split()))
B = [0]+list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1]*(nb+1) for j in range(ng+1)] for i in range(nr+1)]
ans = solve(nr, ng, nb)
print(ans)",cubic,"dp,greedy,sortings",629
"r, g, b = map(int, input().split(' '))
R = list(map(int, input().split(' ')))
G = list(map(int, input().split(' ')))
B = list(map(int, input().split(' ')))
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i == 0 and j == 0 and k == 0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans,dp[i][j][k])
print(ans)",cubic,"dp,greedy,sortings",956
"#!/usr/bin/env python3
import io
import os
import sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def prdbg(*args, **kwargs):
    print(*args, **kwargs)
    pass

def get_str():
    return input().decode().strip()

def rint():
    return map(int, input().split())

def oint():
    return int(input())

def valid(i1,i2,i3):
    if (i1+i2+i3)%2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2\
            or i2 > i1 + i3 or i1 > i2 + i3:
        return False
    return True

def dfs(i1,i2,i3):
    #if not valid(i1, i2, i3):
    if (i1 + i2 + i3) % 2 or (i1 < 0 or i2 < 0 or i3 < 0) or i3 > i1 + i2 \
                or i2 > i1 + i3 or i1 > i2 + i3:
        return -2
    if dp[i1][i2][i3] != -1:
        return dp[i1][i2][i3]
    ret1 = dfs(i1-1, i2-1, i3)
    if ret1 >= 0 :
        ret1 += a1[i1]*a2[i2]
    ret2 = dfs(i1-1, i2, i3-1)
    if ret2 >= 0:
        ret2 += a1[i1]*a3[i3]
    ret3 = dfs(i1, i2-1, i3-1)
    if ret3 >= 0:
        ret3 += a2[i2]*a3[i3]
    ret = max(ret1, ret2, ret3)
    dp[i1][i2][i3] = ret
    return ret

n1, n2, n3 = rint()
a1, a2, a3 = list(rint()), list(rint()), list(rint())
a1.sort(reverse=True)
a2.sort(reverse=True)
a3.sort(reverse=True)
a1 = [0] + a1
a2 = [0] + a2
a3 = [0] + a3
n1 += 1
n2 += 1
n3 += 1

dp = [[[-1 for i3 in range(n3)] for i2 in range(n2)] for i1 in range(n1)]
dp[1][1][0] = a1[1]*a2[1]
dp[1][0][1] = a1[1]*a3[1]
dp[0][1][1] = a2[1]*a3[1]
dp[0][0][0] = -2

for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            dfs(i1, i2, i3)
ans = -1
for i1 in range(n1):
    for i2 in range(n2):
        for i3 in range(n3):
            ans = max(ans, dp[i1][i2][i3])
#print(a1,a2,a3)
print(ans)
",cubic,"dp,greedy,sortings",1691
"def solve():
	r,g,b=map(int,input().split())
	R=list(map(int,input().split()))
	G=list(map(int,input().split()))
	B=list(map(int,input().split()))
	R.sort(reverse=True)
	G.sort(reverse=True)
	B.sort(reverse=True)
	dp=[[[0]*(b+1) for _ in range(g+1)]for _ in range(r+1)]
	for i in range(r+1):
		for j in range(g+1):
			for k in range(b+1):
				if i<r and j<g:
					dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
				if i<r and k<b:
					dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
				if j<g and k<b:
					dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+B[k]*G[j])
	ans=0
	for i in range(r+1):
		for j in range(g+1):
			for k in range(b+1):
				ans=max(ans,dp[i][j][k])
	return ans
print(solve())",cubic,"dp,greedy,sortings",722
"import sys
# sys.setrecursionlimit(10**6) 
input=sys.stdin.readline
def  f(r,g,b,n,m,k):
    # s=str(n)+""_""+str(m)+""_""+str(k)
    # print(n,m,k)
    if((n>=1 and m>=1) or (k>=1 and m>=1) or(n>=1 and k>=1)):
        # print(n,m,k,""zzz"")
        a1=mat[n][m][k]
        if(a1!=-1):
            return a1
        else:
            a1=0
            b1=0
            c1=0
            # print(n,m,k)
            if(n>=1 and m>=1):
          
                a1=r[n-1]*g[m-1] + f(r,g,b,n-1,m-1,k)
            if(k>=1 and m>=1):
                b1=b[k-1]*g[m-1] + f(r,g,b,n,m-1,k-1)
            if(n>=1 and k>=1):
                c1=r[n-1]*b[k-1] + f(r,g,b,n-1,m,k-1)
            # if(n>=0 and m>=0 and k>=0):
            mat[n][m][k]=max(a1,b1)
            mat[n][m][k]=max(mat[n][m][k],c1)
            # print(d[s])
            return mat[n][m][k]
    return 0


n,m,k=list(map(int,input().split("" "")))
mat=[[[-1 for i in range(k+1)] for j in range(m+1)]for z in range(n+1)]
# print(mat)
r=list(map(int,input().split("" "")))
g=list(map(int,input().split("" "")))
b=list(map(int,input().split("" "")))
r.sort()
g.sort()
b.sort()
# print(r,g,b)
d={}
print(f(r,g,b,n,m,k))",cubic,"dp,greedy,sortings",1158
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]


def dp(r1, g1, b1):
    if mem[r1][g1][b1] != -1:
        return mem[r1][g1][b1]

    v1, v2, v3 = 0, 0, 0

    if r1 < r:
        if g1 < g:
            v1 = (ar[r1] * ag[g1]) + dp(r1 + 1, g1 + 1, b1)
        if b1 < b:
            v2 = (ar[r1] * ab[b1]) + dp(r1 + 1, g1, b1 + 1)

    if g1 < g and b1 < b:
        v3 = (ag[g1] * ab[b1]) + dp(r1, g1 + 1, b1 + 1)

    mem[r1][g1][b1] = max(v1, v2, v3)

    return mem[r1][g1][b1]


r, g, b = rints()
ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]
mem = [[[-1 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]
print(dp(0, 0, 0))
",cubic,"dp,greedy,sortings",698
"a,b,c=list(map(int,input().split()))
R=list(map(int,input().split()))
G=list(map(int,input().split()))
B=list(map(int,input().split()))
dp=[[[0 for i in range(201)] for j in range(201)] for k in range(201)]
# print(dp)
R.sort()
G.sort()
B.sort()
for i in range(len(R)+1):
    for j in range(len(G)+1):
        for k in range(len(B)+1):
            if(i and j):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if(j and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if(i and k):
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
print(dp[len(R)][len(G)][len(B)])      ",cubic,"dp,greedy,sortings",675
"
r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])
                    
print(ans)
                                   
                
            
",cubic,"dp,greedy,sortings",1201
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#######################################
r,g,b = map(int,input().split())
l1 = list(map(int,input().split()))
l2 = list(map(int,input().split()))
l3 = list(map(int,input().split()))
l1.sort(reverse=True)
l2.sort(reverse=True)
l3.sort(reverse=True)
dp = [[ ['*' for cc1 in range(b+1)] for cc2 in range(g+1)] for r in range(r+1)]
ans = 0
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i == 0 and j == 0:
                dp[i][j][k] = 0
            if j == 0 and k == 0:
                dp[i][j][k] = 0
            if i == 0 and k == 0:
                dp[i][j][k] = 0
            if i>0 and j>0 and k>0:
                dp[i][j][k] = max(l1[i-1]*l2[j-1] + dp[i-1][j-1][k],l1[i-1]*l3[k-1] + dp[i-1][j][k-1],l2[j-1]*l3[k-1] + dp[i][j-1][k-1])
            else:
                if i>0 and j>0:
                    dp[i][j][k] = l1[i-1]*l2[j-1] + dp[i-1][j-1][k]
                elif i>0 and k>0:
                    dp[i][j][k] = l1[i-1]*l3[k-1] + dp[i-1][j][k-1]
                elif j>0 and k>0:
                    dp[i][j][k] = l2[j-1]*l3[k-1] + dp[i][j-1][k-1]
            ans = max(ans,dp[i][j][k])
                    
print(ans)
                                   
                
            
",cubic,"dp,greedy,sortings",2955
"import os
import sys
import math
import heapq
from decimal import *
from io import BytesIO, IOBase
from collections import defaultdict, deque

def r():
    return int(input())
def rm():
    return map(int,input().split())
def rl():
    return list(map(int,input().split()))

r,g,b = rm()
R = rl()
G = rl()
B = rl()
R.sort()
G.sort()
B.sort()
dp = [[[0]*(b+1) for j in range(g+1)] for i in range(r+1)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i and j:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+R[i-1]*G[j-1])
            if j and k:
                dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+G[j-1]*B[k-1])
            if k and i:
                dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+B[k-1]*R[i-1])
print(dp[r][g][b])",cubic,"dp,greedy,sortings",794
"#dt = {} for i in x: dt[i] = dt.get(i,0)+1
import sys;input = sys.stdin.readline
inp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]

r,g,b = ip()
R = [0]+ip()
G = [0]+ip()
B = [0]+ip()
R.sort()
G.sort()
B.sort()
dp = [[[0]*201 for i in range(201)] for j in range(201)]
for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            x = dp[i-1][j-1][k] + R[i]*G[j] if i*j else 0
            y = dp[i][j-1][k-1] + G[j]*B[k] if j*k else 0
            z = dp[i-1][j][k-1] + R[i]*B[k] if i*k else 0
            dp[i][j][k] = max(dp[i][j][k],x,y,z)
print(dp[r][g][b])
#print(dp)
    
    
",cubic,"dp,greedy,sortings",628
"import sys
import math
from math import *
from collections import Counter,defaultdict
from io import BytesIO, IOBase
from collections import deque


def rec(i,j,k):
	if (i == rl and j == bl) or (i == rl and k == gl) or (k == gl and j == bl):
		return 0
	if dp[i][j][k] != -1:
		return dp[i][j][k]
	else:
		x = r[i]*b[j]
		y = b[j]*g[k]
		z = r[i] * g[k]
		if x>0:
			x += rec(i+1,j+1,k)
		if y>0:
			y += rec(i,j+1,k+1)
		if z>0:
			z += rec(i+1,j,k+1)

		dp[i][j][k] = max(x,y,z)
		return dp[i][j][k]

def main():
	global r,g,b,rl,bl,gl,dp

	rl,bl,gl = list(map(int, input().split()))
	r = list(map(int, input().split())) + [0]
	b = list(map(int, input().split())) + [0]
	g = list(map(int, input().split())) + [0]
	cnt =3
	i =j = k = 0
	ans = 0
	dp=[[[-1 for i in range(gl+1)] for j in range(bl+1)]for k in range(rl+1)] 
	r.sort(reverse = True)
	b.sort(reverse = True)
	g.sort(reverse = True)

	print(rec(i,j,k))
	


main()",cubic,"dp,greedy,sortings",924
"import sys,bisect,string,math,time,functools,random,fractions
from heapq import heappush,heappop,heapify
from collections import deque,defaultdict,Counter
from itertools import permutations,combinations,groupby
rep=range;R=range
def Golf():n,*t=map(int,open(0).read().split())
def I():return int(input())
def S_():return input()
def IS():return input().split()
def LS():return [i for i in input().split()]
def MI():return map(int,input().split())
def LI():return [int(i) for i in input().split()]
def LI_():return [int(i)-1 for i in input().split()]
def NI(n):return [int(input()) for i in range(n)]
def NI_(n):return [int(input())-1 for i in range(n)]
def StoLI():return [ord(i)-97 for i in input()]
def ItoS(n):return chr(n+97)
def LtoS(ls):return ''.join([chr(i+97) for i in ls])
def RA():return map(int,open(0).read().split())
def RLI(n=8,a=1,b=10):return [random.randint(a,b)for i in range(n)]
def RI(a=1,b=10):return random.randint(a,b)
def Rtest(T):
    case,err=0,0
    for i in range(T):
        inp=INP()
        a1,ls=naive(*inp)
        a2=solve(*inp)
        if a1!=a2:
            print((a1,a2),inp)
            err+=1
        case+=1
    print('Tested',case,'case with',err,'errors')
def GI(V,E,ls=None,Directed=False,index=1):
    org_inp=[];g=[[] for i in range(V)]
    FromStdin=True if ls==None else False
    for i in range(E):
        if FromStdin:
            inp=LI()
            org_inp.append(inp)
        else:
            inp=ls[i]
        if len(inp)==2:
            a,b=inp;c=1
        else:
            a,b,c=inp
        if index==1:a-=1;b-=1
        aa=(a,c);bb=(b,c);g[a].append(bb)
        if not Directed:g[b].append(aa)
    return g,org_inp
def GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1):
    #h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0},boundary=1) # sample usage
    mp=[boundary]*(w+2);found={}
    for i in R(h):
        s=input()
        for char in search:
            if char in s:
                found[char]=((i+1)*(w+2)+s.index(char)+1)
                mp_def[char]=mp_def[replacement_of_found]
        mp+=[boundary]+[mp_def[j] for j in s]+[boundary]
    mp+=[boundary]*(w+2)
    return h+2,w+2,mp,found
def TI(n):return GI(n,n-1)
def accum(ls):
    rt=[0]
    for i in ls:rt+=[rt[-1]+i]
    return rt
def bit_combination(n,base=2):
    rt=[]
    for tb in R(base**n):s=[tb//(base**bt)%base for bt in R(n)];rt+=[s]
    return rt
def gcd(x,y):
    if y==0:return x
    if x%y==0:return y
    while x%y!=0:x,y=y,x%y
    return y
def YN(x):print(['NO','YES'][x])
def Yn(x):print(['No','Yes'][x])
def show(*inp,end='\n'):
    if show_flg:print(*inp,end=end)

mo=10**9+7
inf=float('inf')
FourNb=[(-1,0),(1,0),(0,1),(0,-1)];EightNb=[(-1,0),(1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)];compas=dict(zip('WENS',FourNb));cursol=dict(zip('LRUD',FourNb))
l_alp=string.ascii_lowercase
#sys.setrecursionlimit(10**9)
read=sys.stdin.buffer.read;readline=sys.stdin.buffer.readline;input=lambda:sys.stdin.readline().rstrip()


show_flg=False
show_flg=True

ans=0

#for _ in range(I()):
x,y,z=LI()
R=sorted(LI())[::-1]
G=sorted(LI())[::-1]
B=sorted(LI())[::-1]

dp=[[[0]*(z+1) for j in range(y+1)]for i in range(x+1)]

n=x+y+z
for t in range(0,n+1,2):
    for i in range(x+1):
        for j in range(y+1):
            k=t-i-j
            if 0<=k<=z:
                if i+1<=x and j+1<=y:dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+R[i]*G[j])
                if i+1<=x and k+1<=z:dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+R[i]*B[k])
                if j+1<=y and k+1<=z:dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+G[j]*B[k])
                #show((i,j,k),dp)
ans=max([dp[i][y][z]for i in range(x+1)])
ans=max(max([dp[x][i][z]for i in range(y+1)]),ans)
ans=max(max([dp[x][y][i]for i in range(z+1)]),ans)

print(ans)


    
    
    
    ",cubic,"dp,greedy,sortings",3850
"def solve(r, g, b, rs, gs, bs):
    rs.sort(reverse=True)
    gs.sort(reverse=True)
    bs.sort(reverse=True)
    dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
    sol = 0
    for ri in range(r+1):
        for gi in range(g+1):
            for bi in range(b+1):
                if ri < r and gi < g:
                    dp[ri+1][gi+1][bi] = max(dp[ri+1][gi+1][bi], rs[ri]*gs[gi] + dp[ri][gi][bi])
                if ri < r and bi < b:
                    dp[ri+1][gi][bi+1] = max(dp[ri+1][gi][bi+1], rs[ri]*bs[bi] + dp[ri][gi][bi])
                if gi < g and bi < b:
                    dp[ri][gi+1][bi+1] = max(dp[ri][gi+1][bi+1], gs[gi]*bs[bi] + dp[ri][gi][bi])
                sol = max(sol, dp[ri][gi][bi])
    return sol

r, g, b = map(int, input().split())
rs = list(map(int, input().split()))
gs = list(map(int, input().split()))
bs = list(map(int, input().split()))
print(solve(r, g, b, rs, gs, bs))",cubic,"dp,greedy,sortings",923
"import sys as _sys


_sys.setrecursionlimit(2**14)


_cache = dict()


class _SortedSeqs:

    def __init__(self, seqs):
        self.seqs = tuple(tuple(sorted(seq)) for seq in seqs)

    def __hash__(self):
        return id(self)


def compute_max_area(r_seq, g_seq, b_seq):
    sorted_seqs_obj = _SortedSeqs((r_seq, g_seq, b_seq))
    seqs_sizes = tuple(map(len, sorted_seqs_obj.seqs))
    return _compute_max_area(sorted_seqs_obj, seqs_sizes)


def _compute_max_area(sorted_seqs_obj, seqs_sizes):
    cache_key = (sorted_seqs_obj, seqs_sizes)
    if cache_key in _cache.keys():
        return _cache[cache_key]

    seqs = sorted_seqs_obj.seqs
    nonempty_seqs_n = _how_many_nonempty(seqs_sizes)

    if nonempty_seqs_n < 2:
        ab_seqs_indices_list = []
    
    elif nonempty_seqs_n == 2:
        ab_seqs_indices = [i for i, seq_size in enumerate(seqs_sizes) if seq_size > 0]
        ab_seqs_indices_list = [ab_seqs_indices]
    
    else:
        assert nonempty_seqs_n == 3
        seqs_indices_sorted_by_size = [
            i for i, seq in sorted(
                enumerate(seqs),
                key=lambda pair: (pair[1][seqs_sizes[pair[0]]-1], seqs_sizes[pair[0]])
            )
        ]
        ab_seqs_indices_1 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[0]
        ab_seqs_indices_2 = seqs_indices_sorted_by_size[2], seqs_indices_sorted_by_size[1]
        ab_seqs_indices_list = [ab_seqs_indices_1, ab_seqs_indices_2]
    
    max_areas_variants = []
    for a_seq_index, b_seq_index in ab_seqs_indices_list:
        a_seq_last = seqs[a_seq_index][seqs_sizes[a_seq_index]-1]
        b_seq_last = seqs[b_seq_index][seqs_sizes[b_seq_index]-1]
        new_seqs_sizes = list(seqs_sizes)
        new_seqs_sizes[a_seq_index] -= 1
        new_seqs_sizes[b_seq_index] -= 1
        max_area = _compute_max_area(sorted_seqs_obj, tuple(new_seqs_sizes))
        max_area += a_seq_last * b_seq_last
        max_areas_variants.append(max_area)

    max_area = max(max_areas_variants, default=0)

    _cache[cache_key] = max_area
    return max_area


def _how_many_nonempty(seqs_sizes):
    return len([size for size in seqs_sizes if size > 0])


def main():
    r_n, g_n, b_n = map(int, input().split())
    r_seq = tuple(map(int, input().split()))
    g_seq = tuple(map(int, input().split()))
    b_seq = tuple(map(int, input().split()))
    result = compute_max_area(r_seq, g_seq, b_seq)
    print(result)


if __name__ == '__main__':
    main()
",cubic,"dp,greedy,sortings",2476
"import math
import time
from collections import defaultdict,deque,Counter
from sys import stdin,stdout
from bisect import bisect_left,bisect_right
from queue import PriorityQueue 
import sys
t=1
# t=int(input())
for _ in range(t):
    r,g,b=map(int,stdin.readline().split())
    ra=list(map(int,stdin.readline().split()))
    ga=list(map(int,stdin.readline().split()))
    ba=list(map(int,stdin.readline().split()))
    ra.sort()
    ga.sort()
    ba.sort()
    dp=[[[0]*201 for _ in range(201)]for _ in range(201)]
    for i in range(r+1):
        for j in range(g+1):
            for k in range(b+1):
                if(i and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j-1][k]+ra[i-1]*ga[j-1])
                if(i and k>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i-1][j][k-1]+ra[i-1]*ba[k-1])
                if(k and j>0):
                    dp[i][j][k]=max(dp[i][j][k], dp[i][j-1][k-1]+ga[j-1]*ba[k-1])
    print(dp[r][g][b])
",cubic,"dp,greedy,sortings",965
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict


BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
R,G,B=map(int,input().split())
r=sorted(list(map(int,input().split())))
g=sorted(list(map(int,input().split())))
b=sorted(list(map(int,input().split())))
dp=[[[0]*(B+1) for j in range(G+1)] for i in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k - 1] + g[j - 1] * b[k - 1])
print(dp[R][G][B])",cubic,"dp,greedy,sortings",2674
"r, g, b = map(int, input().split())
a = [[], [], []]
dp = [[[0 for i in range(b + 1)] for j in range(g + 1)] for k in range(r + 1)]
for x in range(3):
    a[x] = sorted([int(x) for x in input().split()])
odp = 0
for i in range(r + 1):
    for j in range(g + 1):
        for k in range(b + 1):
            if i < r and j < g:
                dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
            if i < r and k < b:
                dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
            if j < g and k < b:
                dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
            odp = max(odp, dp[i][j][k])
print(odp)",cubic,"dp,greedy,sortings",727
"
R,G,B=[int(c) for c in input().split()]
ra=[int(c) for c in input().split()]
ga=[int(c) for c in input().split()]
ba=[int(c) for c in input().split()]

ra.sort(reverse=True)
ga.sort(reverse=True)
ba.sort(reverse=True)

dp = [[[-1 for i in range(201)]for j in range(201)]for k in range(201)]
def solve(dp,r,g,b):
    if dp[r][g][b] !=-1:
        return dp[r][g][b]
    count= 0
    for i,j in zip((r,g,b),(R,G,B)):
        if i == j:
            count+=1
    if count >= 2:
        return 0

    ##Three cases choose btw r,b r,g  and gb
    res = -999
    if r != R and b!=B:

        res = max(res,ra[r]*ba[b] + solve(dp,r+1,g,b+1))
        # print(res)
    
    if r!=R and g != G:
        res = max(res,ra[r]*ga[g] + solve(dp,r+1,g+1,b))
        # print(res)
    
    if b!=B and g != G:
        res = max(res,ba[b]*ga[g] + solve(dp,r,g+1,b+1))
        # print(res)
    
    dp[r][g][b] = res

    return res
     

print(solve(dp,0,0,0))",cubic,"dp,greedy,sortings",941
"from collections import deque
from collections import OrderedDict
import math
 
import sys
import os
import threading
import bisect
 
import operator
 
import heapq
 
 
from atexit import register
from io import BytesIO
 
#sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
#sys.stdout = BytesIO()
#register(lambda: os.write(1, sys.stdout.getvalue()))
 
 
import io
#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
#sys.stdin = open(""F:\PY\\test.txt"", ""r"")
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#input = sys.stdin.readline

#a = [int(x) for x in input().split()]




r,g,b = map(int, input().split())
a = []
for i in range(3):
    a.append([int(x) for x in input().split()])
    a[i].sort(reverse=True)

dp = [[[0 for i in range(205)] for j in range(205)] for k in range(205)]
answer = 0

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i<r and j<g:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k], dp[i][j][k]+a[0][i]*a[1][j])
            if i<r and k<b:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1], dp[i][j][k]+a[0][i]*a[2][k])
            if j<g and k<b:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1], dp[i][j][k]+a[1][j]*a[2][k])
            answer=max(answer, dp[i][j][k])
print(answer)
    



sys.exit(0)





class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p1 = Person(""heelo"", 27)

print(help(Person))


age = 26
name = 'Swaroop'
print('Возрас {} -- {} лет'.format(name, age))
print(help(object))


'''
for _ in range(int(input())):
    
    n = int(input())
    ar = list(map(int, input().split()))
    dp = [0]*100005
    for i in range(n):
        dp[ar[i]]+=1
    ar.clear()
    for i in range(len(dp)):
        if dp[i]!=0:
            ar.append(dp[i])       
    ar.sort()
    maxC = ar[len(ar)-1]
    sumA = sum(ar)
    answer=0
    for i in range(len(ar)):
        if ar[i]==maxC:
            answer+=1
            sumA-=maxC
    answer-=1
    answer+= min(sumA//(maxC-1), len(ar)-1)
    print(answer)
    #sys.exit(0)   
         
    




def maxDisjointIntervals(list_):
    list_.sort(key=lambda x: x[1])
    print(list_[0][0], list_[0][1])
    r1 = list_[0][1]
    for i in range(1, len(list_)):
        l1 = list_[i][0]
        r2 = list_[i][1]
        if l1>r1:
            print(l1, r2)
            r1 = r2

if __name__ ==""__main__1"":
    N=4
    intervals = [[1, 4], [2, 3], [4,6], [8,9]]
    maxDisjointIntervals(intervals)
    
    '''
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    ",cubic,"dp,greedy,sortings",2612
"import sys

def dp(ri, gi, bi):
    if ri>r or gi>g or bi>b:
        return 0

    if not list_memo[ri][gi][bi]==-1:
        return list_memo[ri][gi][bi]
    
    list_memo[ri][gi][bi] = max(dp(ri+1, gi+1, bi)+r_c[ri]*g_c[gi], dp(ri+1, gi, bi+1)+r_c[ri]*b_c[bi], dp(ri, gi+1, bi+1)+g_c[gi]*b_c[bi])
    return list_memo[ri][gi][bi]


r, g, b = map(int, sys.stdin.readline().split())

r_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
g_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)
b_c = sorted(list(map(int, sys.stdin.readline().split()))+[0], reverse=1)


list_memo = [[[-1]*(b+1) for _ in range(g+1)] for _ in range(r+1)]

print(dp(0, 0, 0))",cubic,"dp,greedy,sortings",694
"R,G,B = map(int,input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
area = 0
r.sort(reverse=True)
b.sort(reverse=True)
g.sort(reverse=True)
L = max(len(r),len(g),len(b))
dp = [[[0]*(B+1) for i in range(G+1)]for j in range(R+1)]
# print(dp[r][g][b])
tr = 0
tg = 0
tb = 0
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
			area = max(area,dp[i][j][k])
print(area)",cubic,"dp,greedy,sortings",707
"R,G,B = map(int,input().split())
r = list(map(int,input().split()))
g = list(map(int,input().split()))
b = list(map(int,input().split()))
r.sort()
g.sort()
b.sort()
dp = []
for i in range(R+1):
	d = []
	for j in range(G+1):
		d.append([0]*(B+1))
	dp.append(d)
for i in range(R+1):
	for j in range(G+1):
		for k in range(B+1):
			if i+j+k<2:
				continue
			if i>0 and j>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
			if i>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+r[i-1]*b[k-1])
			if j>0 and k>0:
				dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])

",cubic,"dp,greedy,sortings",626
"import sys
readline = sys.stdin.buffer.readline
readlines = sys.stdin.buffer.readlines
ns = lambda: readline().rstrip()
ni = lambda: int(readline().rstrip())
nm = lambda: map(int, readline().split())
nl = lambda: list(map(int, readline().split()))

r, g, b = nm()
R = nl()
G = nl()
B = nl()
dp = [[[-1 for i in range(b+1)] for i in range(g+1)] for i in range(r+1)]
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)
R.insert(0, 0)
G.insert(0, 0)
B.insert(0, 0)
dp[0][0][0], ans = 0, 0
for i in range(0, r+1):
    for j in range(0, g+1):
        for k in range(0, b+1):
            if i==0 and j==0 and k==0:continue
            if i and j and dp[i - 1][j - 1][k] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + R[i] * G[j])
            if k and j and dp[i][j - 1][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + B[k] * G[j])
            if i and k and dp[i - 1][j][k - 1] != -1:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + R[i] * B[k])
            ans = max(ans, dp[i][j][k])
print(ans)",cubic,"dp,greedy,sortings",1086
"def solve(rn,gn,bn,r,g,b):
    r = sorted(r,reverse=True)
    g = sorted(g, reverse=True)
    b = sorted(b, reverse=True)

    dp = [[[0 for k in range(bn+1)] for j in range(gn+1)] for i in range(rn+1)]


    ans = 0
    for i in range(rn+1):
        for j in range(gn+1):
            for k in range(bn+1):
                if i < rn and j < gn:
                    dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
                if i < rn and k < bn:
                    dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
                if j < gn and k <bn:
                    dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])

                ans = max(ans,dp[i][j][k])

    print(ans)






if __name__ == '__main__':
    rn, gn, bn = map(int,input().split())

    r = list(map(int,input().split()))
    g = list(map(int, input().split()))
    b = list(map(int, input().split()))

    solve(rn,gn,bn,r,g,b)",cubic,"dp,greedy,sortings",953
"from sys import stdin

rints = lambda: [int(x) for x in stdin.readline().split()]

r, g, b = rints()
ar, ag, ab = [sorted(rints(), reverse=True) for _ in range(3)]
mem = [[[0 for _ in range(b + 1)] for _ in range(g + 1)] for _ in range(r + 1)]
ans = 0

for r1 in range(r + 1):
    for g1 in range(g + 1):
        for b1 in range(b + 1):
            if r1 < r:
                if g1 < g:
                    mem[r1 + 1][g1 + 1][b1] = max(mem[r1 + 1][g1 + 1][b1], (ar[r1] * ag[g1]) + mem[r1][g1][b1])
                if b1 < b:
                    mem[r1 + 1][g1][b1 + 1] = max(mem[r1 + 1][g1][b1 + 1], (ar[r1] * ab[b1]) + mem[r1][g1][b1])

            if g1 < g and b1 < b:
                mem[r1][g1 + 1][b1 + 1] = max(mem[r1][g1 + 1][b1 + 1], (ag[g1] * ab[b1]) + mem[r1][g1][b1])

            ans = max(ans, mem[r1][g1][b1])

print(ans)",cubic,"dp,greedy,sortings",837
"R, G, B = map(int, input().split())
r = list(map(int, input().split()))
g = list(map(int, input().split()))
b = list(map(int, input().split()))
r.sort()
g.sort()
b.sort()
# State- dp[i][j][k] represents max value after choosing i elements from r, j elements from g, k elements from b
dp = [[[0]*202 for i in range(202)] for j in range(202)]
for i in range(R+1):
       for j in range(G+1):
              for k in range(B+1):
                     if i and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+r[i-1]*g[j-1])
                     if i and k:
                            dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+r[i-1]*b[k-1])
                     if k and j:
                            dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k-1]+g[j-1]*b[k-1])
print(dp[R][G][B])
",cubic,"dp,greedy,sortings",813
"r, g, b = map(int, input().split())
R = list(map(int, input().split()))
G = list(map(int, input().split()))
B = list(map(int, input().split()))
R.sort(reverse=True)
G.sort(reverse=True)
B.sort(reverse=True)

memo = [[[-1]*(b+1) for i in range(g+1)] for j in range(r+1)]

def calc(ir, ig, ib):
    if memo[ir][ig][ib] != -1:
        return memo[ir][ig][ib]
    ans = 0
    if ir < r and ig < g:
        ans = max(ans, calc(ir+1, ig+1, ib)+R[ir]*G[ig])
    if ir < r and ib < b:
        ans = max(ans, calc(ir+1, ig, ib+1)+R[ir]*B[ib])
    if ig < g and ib < b:
        ans = max(ans, calc(ir, ig+1, ib+1)+G[ig]*B[ib])
    memo[ir][ig][ib] = ans
    return ans

print(calc(0, 0, 0))
",cubic,"dp,greedy,sortings",681
"R, G, B = list(map(int, input().split()))
r = [int(x) for x in input().split()]
r.sort(reverse=True)
g = [int(x) for x in input().split()]
g.sort(reverse=True)
b = [int(x) for x in input().split()]
b.sort(reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,"dp,greedy,sortings",751
"R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse=True)
g = sorted([int(x) for x in input().split()], reverse=True)
b = sorted([int(x) for x in input().split()], reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,"dp,greedy,sortings",754
"R, G, B = list(map(int, input().split()))
r = sorted(list(map(int, input().split())), reverse=True)
g = sorted(list(map(int, input().split())), reverse=True)
b = sorted(list(map(int, input().split())), reverse=True)

ans = 0
dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + r[i]*b[k])
            ans = max(ans, dp[i][j][k])
print(ans)
",cubic,"dp,greedy,sortings",748
"import sys
sys.setrecursionlimit(200000)
input=sys.stdin.readline
 
def solve(r,g,b,R,G,B):
    if (r==0 and g==0) and (r==0 and b==0) and (g==0 and b==0):
        return 0
    if z[r][g][b]!=-1:
        return z[r][g][b]
    d,e,f=0,0,0
    if r!=0 and g!=0:
        d=R[r-1]*G[g-1]+solve(r-1,g-1,b,R,G,B)
    if r!=0 and b!=0:
        e=R[r-1]*B[b-1]+solve(r-1,g,b-1,R,G,B)
    if b!=0 and g!=0:
        f=B[b-1]*G[g-1]+solve(r,g-1,b-1,R,G,B)
    z[r][g][b]=max(d,e,f)
    return z[r][g][b]
 
r,g,b=map(int,input().rstrip().split())
R=sorted(map(int,input().rstrip().split()))
G=sorted(map(int,input().rstrip().split()))
B=sorted(map(int,input().rstrip().split()))
z=[[[ -1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
print(solve(r,g,b,R,G,B))",cubic,"dp,greedy,sortings",764
"import os
import heapq
import sys
import math
import operator
from collections import defaultdict
from io import BytesIO, IOBase


""""""def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)""""""

""""""def pw(a,b):
    result=1
    while(b>0):
        if(b%2==1): result*=a
        a*=a
        b//=2
    return result""""""

def inpt():
    return [int(k) for k in input().split()]

def main():
    n1, n2, n3 = map(int, input().split())
    ar = [int(x) for x in input().split()]
    br = [int(x) for x in input().split()]
    cr = [int(x) for x in input().split()]
    ar.sort()
    br.sort()
    cr.sort()
    dp = [[[0 for x in range(201)] for y in range(201)] for z in range(201)]
    for i in range(n1 + 1):
        for j in range(n2 + 1):
            for k in range(n3 + 1):
                if (i and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + (ar[i - 1] * br[j - 1]))
                if (i and k):
                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + (ar[i - 1] * cr[k - 1]))
                if (k and j):
                    dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + (cr[k - 1] * br[j - 1]))
    print(dp[n1][n2][n3])


BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()

",cubic,"dp,greedy,sortings",2902
"# Author: S Mahesh Raju
# Username: maheshraju2020
# Date: 19/08/2020

from sys import stdin, stdout, setrecursionlimit
from math import gcd, ceil, sqrt
from collections import Counter, deque
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
setrecursionlimit(100000)
mod = 1000000007

R, G, B = iia()
r, g, b = sorted(iia()), sorted(iia()), sorted(iia())
dp = [[[0 for i in range(B + 1)] \
    for j in range(G + 1)] for k in range(R + 1)]

for i in range(R + 1):
    for j in range(G + 1):
        for k in range(B + 1):
            if i > 0 and j > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j > 0 and k > 0:
                dp[i][j][k] = max(dp[i][j][k], \
                    dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])
print(dp[-1][-1][-1])
",cubic,"dp,greedy,sortings",1165
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0 #starting point when i==-1,j==-1,k==-1
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k): #dp(i,j,k) is the max value including r[i],g[j],b[k]
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1: #offset by 1 because i,j,k can be -1
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

for i in range(max(nr,ng,nb)):
    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))


print(dp(nr-1,ng-1,nb-1))",cubic,"dp,greedy,sortings",976
"import sys
input=sys.stdin.buffer.readline

nr,ng,nb=[int(x) for x in input().split()]
r=[int(x) for x in input().split()]
g=[int(x) for x in input().split()]
b=[int(x) for x in input().split()]

r.sort()
g.sort()
b.sort()

memo=[[[-1 for _ in range(nb+1)] for __ in range(ng+1)] for ___ in range(nr+1)]
memo[0][0][0]=0 #starting point when i==-1,j==-1,k==-1
for i in range(nr):
    memo[i+1][0][0]=0
for j in range(ng):
    memo[0][j+1][0]=0
for k in range(nb):
    memo[0][0][k+1]=0
def dp(i,j,k): #dp(i,j,k) is the max value including r[i],g[j],b[k]
    if i<-1 or j<-1 or k<-1:
        return -float('inf')
    if memo[i+1][j+1][k+1]==-1: #offset by 1 because i,j,k can be -1
        memo[i+1][j+1][k+1]=max(dp(i,j-1,k-1)+g[j]*b[k],
                   dp(i-1,j-1,k)+r[i]*g[j],
                   dp(i-1,j,k-1)+r[i]*b[k]
                )
    return memo[i+1][j+1][k+1]

#for i in range(max(nr,ng,nb)):
#    dp(min(i,nr-1),min(i,ng-1),min(i,nb-1))


print(dp(nr-1,ng-1,nb-1))",cubic,"dp,greedy,sortings",978
"def getArray():
    return list(map(int, input().split()))
def createDP(R, G, B):
    dp = []
    for i in range(R):
        temp1 = []
        for j in range(G):
            temp2 = []
            for k in range(B):
                temp2.append(-1)
            temp1.append(temp2)
        dp.append(temp1)
    return dp
def go(r, g, b, R, G, B, ri, gi, bi, state):
    if state[ri][gi][bi] != -1 :
        return state[ri][gi][bi]
    best = 0
    if ri < R and gi < G:
        best = max(best, r[ri]*g[gi] + go(r, g, b, R, G, B, ri+1, gi+1, bi, state))
    if ri < R and bi < B:
        best = max(best, r[ri]*b[bi] + go(r, g, b, R, G, B, ri+1, gi, bi+1, state))
    if gi < G and bi < B:
        best = max(best, g[gi]*b[bi] + go(r, g, b, R, G, B, ri, gi+1, bi+1, state))
    
    state[ri][gi][bi] = best
    return best
    
R,G,B = map(int, input().split())
r = getArray()
g = getArray()
b = getArray()
r.sort(reverse = True)
g.sort(reverse = True)
b.sort(reverse = True)
dp = createDP(201,201,201)
print(go(r, g, b, R, G, B, 0, 0, 0, dp))",cubic,"dp,greedy,sortings",1045
"import sys
from math import sqrt, gcd, ceil, log, floor
from bisect import bisect, bisect_left
from collections import defaultdict, Counter, deque
from heapq import heapify, heappush, heappop
input = sys.stdin.readline
read = lambda: list(map(int, input().strip().split()))

MOD = 10**9 + 7


def main():
	# ans_ = []
	# ans_.append(ans)
	# print((""\n"").join(map(str, ans_)))
	r, g, b = read()
	r_ar=sorted(read(), reverse = True); g_ar = sorted(read(), reverse = True); b_ar = sorted(read(), reverse = True)
	N = 201
	dp = [[[-1]*N for i in range(N)]for j in range(N)]
	# for i in dp:print(*i)
	def f(x, y, z):
		# print(x, y, z, (x >= r) + (y >= g) + (z >= b))
		if ((x >= r) + (y >= g) + (z >= b)) >= 2:
			return(0)
		if dp[x][y][z] != -1:
			return(dp[x][y][z])
		maxi = 0
		if x < r and y < g:
			maxi = max(maxi, r_ar[x]*g_ar[y] + f(x+1, y+1, z))
		if z < b and y < g:
			maxi = max(maxi, b_ar[z]*g_ar[y] + f(x, y+1, z+1))
		if x < r and z < b:
			maxi = max(maxi, r_ar[x]*b_ar[z] + f(x+1, y, z+1))
		dp[x][y][z] = maxi
		return(maxi)
	print(f(0, 0, 0))





if __name__ == ""__main__"":
	main()",cubic,"dp,greedy,sortings",1100
"# @author --> ajaymodi
# optimized approach with memoization (dp)
import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""output.out"",""w"")

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())


from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)



def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]

	ans = 0

	if i < r and j < g:
		ans = max(solve(i+1,j+1,k) + rl[i]*gl[j],ans)

	if i < r and k < b:	
		ans = max(solve(i+1,j,k+1) + rl[i]*bl[k],ans)

	if j < g and k < b:
		ans = max(solve(i,j+1,k+1) + gl[j]*bl[k],ans)

	dp_table[i][j][k] = ans
	return dp_table[i][j][k]
		

dp_table = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",cubic,"dp,greedy,sortings",976
"# @author --> ajaymodi
# optimized approach with memoization (dp)
import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""output.out"",""w"")

input=lambda : sys.stdin.readline().strip()
char = [chr(i) for i in range(97,123)]
CHAR = [chr(i) for i in range(65,91)]
mp = lambda:list(map(int,input().split()))
INT = lambda:int(input())
rn = lambda:range(INT())


from math import ceil,sqrt,factorial,gcd

r,g,b = mp()
rl = sorted(mp(),reverse=True)
gl = sorted(mp(),reverse=True)
bl = sorted(mp(),reverse=True)

def solve(i,j,k):
	if dp_table[i][j][k] != -1:
		return dp_table[i][j][k]
 
	if i < r and j < g and k < b:
		m = max(solve(i+1,j+1,k)+(rl[i]*gl[j]), solve(i+1,j,k+1)+(rl[i]*bl[k]), solve(i,j+1,k+1)+(gl[j]*bl[k]))
		dp_table[i][j][k] = m
		return m
 
	elif i < r and j < g:
		m = solve(i+1,j+1,b) + rl[i]*gl[j]
		dp_table[i][j][k] = m
		return m
 
	elif i < r and k < b:
		m = solve(i+1,g,k+1) + (rl[i]*bl[k])	
		dp_table[i][j][k] = m
		return m
 
	elif j < g and k < b:
		m = solve(r,j+1,k+1) + (gl[j]*bl[k])
		dp_table[i][j][k] = m
		return m
	else:
		return 0

dp_table = [[[-1]*(b+1) for j in range(g+1)] for k in range(r+1)]
res = solve(0,0,0)
print(res)
",cubic,"dp,greedy,sortings",1172
"R,G,B = map(int,input().split())
r = sorted(list(map(int,input().split())), reverse=True)
g = sorted(list(map(int,input().split())), reverse=True)
b = sorted(list(map(int,input().split())), reverse=True)

dp = [[[0]*(B+1) for i in range(G+1)] for j in range(R+1)]
ans = 0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if j*k > 0:
                dp[i][j][k] = max(dp[i][j-1][k-1]+g[j-1]*b[k-1],dp[i][j][k])
            if i*k > 0:
                dp[i][j][k] = max(dp[i-1][j][k-1]+r[i-1]*b[k-1],dp[i][j][k])
            if i*j > 0:
                dp[i][j][k] = max(dp[i-1][j-1][k]+g[j-1]*r[i-1],dp[i][j][k])
            ans = max(ans,dp[i][j][k])
print(ans)",cubic,"dp,greedy,sortings",699
"import pprint
nr, ng, nb = map(int, input().split())
*r, = map(int, input().split())
*g, = map(int, input().split())
*b, = map(int, input().split())
dp = []
for _ in range(nr + 1):
    dp.append([[0] * (nb + 1) for _ in range(ng + 1)])

r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)

mx = 0
for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if i and j:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + r[i - 1] * g[j - 1])
            if i and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + r[i - 1] * b[k - 1])
            if j and k:
                dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + g[j - 1] * b[k - 1])


mx_i = mx_j = mx_k = -1

for i in range(nr + 1):
    for j in range(ng + 1):
        for k in range(nb + 1):
            if dp[i][j][k] > mx:
                mx_i = i
                mx_j = j
                mx_k = k
                mx = dp[i][j][k]

print(mx)
",cubic,"dp,greedy,sortings",997
"import sys
#input = sys.stdin.readline

R, G, B = list(map(int, input().split()))
r = sorted([int(x) for x in input().split()], reverse = True)
g = sorted([int(x) for x in input().split()], reverse = True)
b = sorted([int(x) for x in input().split()], reverse = True)

ans = 0

dp = [[[0 for i in range(B+1)] for j in range(G+1)] for k in range(R+1)]

for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + r[i]*g[j])
            if  j<G and k<B:
                dp[i][j+1][k+1] = max(dp[i][j+1][k+1], dp[i][j][k] + g[j]*b[k])
            if i<R and k<B:
                dp[i+1][j][k+1] = max(dp[i+1][j][k+1], dp[i][j][k] + b[k]*r[i])
            ans = max(ans, dp[i][j][k])
print(ans)",cubic,"dp,greedy,sortings",802
"def cal(r,g,b):
	if dp[r][g][b]!=-1:
		return dp[r][g][b]
	ans=0
	if r<R and g<G:
		ans=max(ans,rl[r]*gl[g]+cal(r+1,g+1,b))
	if r<R and b<B:
		ans=max(ans,rl[r]*bl[b]+cal(r+1,g,b+1))
	if g<G and b<B:
		ans=max(ans,gl[g]*bl[b]+cal(r,g+1,b+1))
	dp[r][g][b]=ans
	return ans

R,G,B=map(int,input().split())
rl=sorted(list(map(int,input().split())),reverse=True)
gl=sorted(list(map(int,input().split())),reverse=True)
bl=sorted(list(map(int,input().split())),reverse=True)
dp=[[[-1 for j in range(B+1)] for i in range(G+1)] for i in range(R+1)]
print(cal(0,0,0))",cubic,"dp,greedy,sortings",557
"import sys
from functools import lru_cache, cmp_to_key
from heapq import merge, heapify, heappop, heappush
# from math import *
from collections import defaultdict as dd, deque, Counter as C
from itertools import combinations as comb, permutations as perm
from bisect import bisect_left as bl, bisect_right as br, bisect
from time import perf_counter
from fractions import Fraction
import copy
import time
# import numpy as np
starttime = time.time()
# import numpy as np
mod = int(pow(10, 9) + 7)
mod2 = 998244353
def data(): return sys.stdin.readline().strip()
def out(*var, end=""\n""): sys.stdout.write(' '.join(map(str, var))+end)
def L(): return list(sp())
def sl(): return list(ssp())
def sp(): return map(int, data().split())
def ssp(): return map(str, data().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]

try:
    # sys.setrecursionlimit(int(pow(10,6)))
    sys.stdin = open(""input.txt"", ""r"")
    # sys.stdout = open(""../output.txt"", ""w"")
except:
    pass
global ans
ans=0

def rec(i,j,k):
    if dp[i][j][k]!=-1:
        return dp[i][j][k]
    x1=x2=x3=0
    if i<R and j<G:
        x1=r[i]*g[j]+rec(i+1,j+1,k)
    if i<R and k<B:
        x2=r[i]*b[k]+rec(i+1,j,k+1)
    if j<G and k<B:
        x3=g[j]*b[k]+rec(i,j+1,k+1)
    dp[i][j][k]=max(x1,x2,x3)
    global ans
    ans=max(ans,dp[i][j][k])
    return dp[i][j][k]

for _ in range(1):
    R,G,B=L()
    r=L()
    g=L()
    b=L()
    r.sort(reverse=True)
    g.sort(reverse=True)
    b.sort(reverse=True)
    dp=[[[-1 for k in range(B+1)] for j in range(G+1)] for i in range(R+1)]
    rec(0,0,0)
    print(ans)



endtime = time.time()
# print(f""Runtime of the program is {endtime - starttime}"")

",cubic,"dp,greedy,sortings",1734
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------- fast io --------------------
from math import gcd, ceil

def pre(s):
    n = len(s)
    pi = [0] * n
    for i in range(1, n):
        j = pi[i - 1]
        while j and s[i] != s[j]:
            j = pi[j - 1]
        if s[i] == s[j]:
            j += 1
        pi[i] = j
    return pi


def prod(a):
    ans = 1
    for each in a:
        ans = (ans * each)
    return ans

def lcm(a, b): return a * b // gcd(a, b)


def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y


for _ in range(int(input()) if not True else 1):
    r, g, b = map(int, input().split())
    #a, b = map(int, input().split())
    #c, d = map(int, input().split())
    rr = list(map(int, input().split()))
    gg = list(map(int, input().split()))
    bb = list(map(int, input().split()))
    #s = input()
    dp = [[[0]*(b+1) for __ in range(g+1)] for ___ in range(r+1)]
    def f(a):return sorted(a,reverse=True)
    rr,gg,bb=f(rr),f(gg),f(bb)
    ans=0
    r+=1
    g+=1
    b+=1
    for i in range(r):
        for j in range(g):
            for k in range(b):
                try:dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k] + rr[i]*gg[j])
                except:pass
                try:dp[i][j+1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + gg[j]*bb[k])
                except:pass
                try:dp[i+1][j][k+1] = max(dp[i+1][j][k+1],dp[i][j][k] + rr[i]*bb[k])
                except:pass
                ans=max(ans,dp[i][j][k])
    print(ans)",cubic,"dp,greedy,sortings",3265
"r,g,b = map(int,input().split())
R = list(map(int,input().split()))
G = list(map(int,input().split()))
B = list(map(int,input().split()))
R.sort()
G.sort()
B.sort()
dp = [[[-1 for i in range(b+1)] for j in range(g+1)] for k in range(r+1)]
def solve(r,g,b):
	if ((r==0 and g==0) or (g==0 and b==0) or (b==0 and r==0)):
		return 0
	if dp[r][g][b]==-1:
		if r==0:
			ans =  G[g-1]*B[b-1]+solve(r,g-1,b-1)
		elif g==0:
			ans =  R[r-1]*B[b-1]+solve(r-1,g,b-1)
		elif b==0:
			ans =  G[g-1]*R[r-1]+solve(r-1,g-1,b)
		else:
			ans =  max(G[g-1]*B[b-1]+solve(r,g-1,b-1),G[g-1]*R[r-1]+solve(r-1,g-1,b),R[r-1]*B[b-1]+solve(r-1,g,b-1))
		dp[r][g][b] = ans
	return dp[r][g][b]
ans = solve(r,g,b)
print(ans)",cubic,"dp,greedy,sortings",695
"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
##########################################################
from collections import Counter
# c=sorted((i,int(val))for i,val in enumerate(input().split()))
import heapq
# c=sorted((i,int(val))for i,val in enumerate(input().split()))
# n = int(input())
# ls = list(map(int, input().split()))
# n, k = map(int, input().split())
# n =int(input())
#arr=[(i,x) for i,x in enum]
#arr.sort(key=lambda x:x[0])
#print(arr)
# e=list(map(int, input().split()))
from collections import Counter
#print(""\n"".join(ls))
#print(os.path.commonprefix(ls[0:2]))
#n=int(input())
from bisect import  bisect_right
#for _ in range(int(input())):
#n=int(input())
#arr = list(map(int, input().split()))
#for _ in range(int(input())):
#n, k = map(int, input().split())
import bisect
#n=int(input())
#n, p,q,r = map(int, input().split())
#arr = list(map(int, input().split()))
#n=int(input())
#nm,k = map(int, input().split())
#for _ in range(int(input())):
def find(x,y,z):
    if dp[x][y][z]!=-1:
        return dp[x][y][z]
    ans=0
    if x<r and y<g:
        ans=max(ans,rl[x]*gl[y]+find(x+1,y+1,z))
    if x<r and z<b:
        ans=max(ans,rl[x]*bl[z]+find(x+1,y,z+1))
    if y<g and z<b:
        ans=max(ans,gl[y]*bl[z]+find(x,y+1,z+1))

    dp[x][y][z]=ans
    return ans
r,g,b = map(int, input().split())
rl=sorted(list(map(int, input().split())),reverse=True)
gl=sorted(list(map(int, input().split())),reverse=True)
bl=sorted(list(map(int, input().split())),reverse=True)
dp=[[[-1]*(b+1) for i in range(g+1)]for i in range(r+1)]
print(find(0,0,0))

",cubic,"dp,greedy,sortings",3233
"def rec(r,g,b):
    if(dp[r][g][b]!=-1):
        return dp[r][g][b]
    ans=0
    if r<R and g<G:
        ans=max(ans, red[r]*green[g]+rec(r+1, g+1, b))
    if r<R and b<B:
        ans=max(ans, red[r]*blue[b]+rec(r+1, g, b+1))
    if b<B and g<G:
        ans=max(ans, blue[b]*green[g]+rec(r, g+1, b+1))
    dp[r][g][b]=ans
    return ans
R,G,B=map(int,input().split())
red=sorted(list(map(int, input().split())), reverse=True)
green=sorted(list(map(int, input().split())), reverse=True)
blue=sorted(list(map(int, input().split())), reverse=True)
dp=[[[-1]*(B+1) for _ in range(G+1)] for _ in range(R+1)]
print(rec(0,0,0))",cubic,"dp,greedy,sortings",621
"from sys import stdin
import time

r,g,b = map(int,stdin.readline().split())

red = list(map(int,stdin.readline().split()))
green = list(map(int,stdin.readline().split()))
blue = list(map(int,stdin.readline().split()))
red.sort()
green.sort()
blue.sort()

dp = [[[0 for _ in range(b+1)] for _ in range(g+1)] for _ in range(r+1)]

for i in range(r+1):
    for j in range(g+1):
        for k in range(b+1):
            if i>0 and j>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+red[i-1]*green[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+red[i-1]*blue[k-1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+green[j-1]*blue[k-1])

print(dp[-1][-1][-1])                       
",cubic,"dp,greedy,sortings",784
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
 
DP = [0] * ((R+1) * (G+1) * (B+1))
def idx(r, g, b): return r * (G+1) * (B+1) + g * (B+1) + b
 
for r in range(R+1):
	for g in range(G+1):
		for b in range(B+1):
			best = 0
 
			if r:
				if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
				if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
 
			if g and b:
				best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
 
			DP[idx(r, g, b)] = best
 
print(max(DP))",cubic,"dp,greedy,sortings",545
"c1, c2, c3 = map(int, input().split())
r = sorted(list(map(int, input().split())))
g = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]
for i in range(c1 + 1):
    for j in range(c2 + 1):
        for k in range(c3 + 1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])
print(dp[c1][c2][c3])

",cubic,"dp,greedy,sortings",696
"c1, c2, c3 = map(int, input().split())
r = sorted(list(map(int, input().split())))
g = sorted(list(map(int, input().split())))
b = sorted(list(map(int, input().split())))
dp = [[[0 for i in range(c3 + 1)] for i in range(c2 + 1)] for i in range(c1 + 1)]
for i in range(c1 + 1):
    for j in range(c2 + 1):
        for k in range(c3 + 1):
            if i>0 and j>0:
                dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+r[i-1]*g[j-1])
            if i>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k-1] + r[i - 1] * b[k - 1])
            if j>0 and k>0:
                dp[i][j][k] = max(dp[i][j][k], dp[i ][j - 1][k-1] + g[j - 1] * b[k - 1])
print(dp[c1][c2][c3])
 ",cubic,"dp,greedy,sortings",696
"from sys import stdin
input=lambda : stdin.readline().strip()
lin=lambda :list(map(int,input().split()))
iin=lambda :int(input())
main=lambda :map(int,input().split())
from math import ceil,sqrt,factorial,log
from collections import deque
from bisect import bisect_left
def gcd(a,b):
	a,b=max(a,b),min(a,b)
	while a%b!=0:
		a,b=b,a%b
	return b
def solve():
	a,b,c=main()
	x,y,z=lin(),lin(),lin()
	x.sort(reverse=True)
	y.sort(reverse=True)
	z.sort(reverse=True)
	ans=0
	dp=[[[0 for i in range(c+2)] for i in range(b+2)] for i in range(a+1)]
	for i in range(a+1):
		for j in range(b+1):
			for k in range(c+1):
				if i<a and j<b:
					dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+x[i]*y[j])
				if i<a and k<c:
					dp[i+1][j][k+1]=max(dp[i+1][j][k+1],dp[i][j][k]+x[i]*z[k])
				if k<c and j<b:
					dp[i][j+1][k+1]=max(dp[i][j+1][k+1],dp[i][j][k]+z[k]*y[j])
				ans=max(ans,dp[i][j][k])
	print(ans)
qwe=1
# qwe=int(input())
for _ in range(qwe):
	solve()

",cubic,"dp,greedy,sortings",959
"R, G, B = map(int, input().split())
L = [sorted(map(int, input().split())) for _ in range(3)]
DP = [0] * ((R+1) * (G+1) * (B+1))

def idx(r, g, b):
  return r * (G+1) * (B+1) + g * (B+1) + b

for r in range(R+1):
  for g in range(G+1):
    for b in range(B+1):
      best = 0
      if r:
        if g: best = L[0][r-1] * L[1][g-1] + DP[idx(r-1, g-1, b)]
        if b: best = max(best, L[0][r-1] * L[2][b-1] + DP[idx(r-1, g, b-1)])
      if g and b:
        best = max(best, L[1][g-1] * L[2][b-1] + DP[idx(r, g-1, b-1)])
      DP[idx(r, g, b)] = best
print(max(DP))
",cubic,"dp,greedy,sortings",565
"def solve():
  r, g, b = map(int, input().split());R,G,B = sorted(list(map(int, input().split()))),sorted(list(map(int, input().split()))),sorted(list(map(int, input().split())));dp = [[[0]*(b+1) for _ in range(g+1)] for _ in range(r+1)]
  for i in range(r+1):
    for j in range(g+1):
      for k in range(b+1):
        if i+j+k<2:continue
        if i>0 and j>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+R[i-1]*G[j-1])
        if i>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i-1][j][k-1]+R[i-1]*B[k-1])
        if j>0 and k>0:dp[i][j][k] = max(dp[i][j][k],dp[i][j-1][k-1]+G[j-1]*B[k-1])
  return dp[r][g][b]
print(solve())",cubic,"dp,greedy,sortings",628
"def cal(r, g, b):
	if dp[r][g][b] != -1:
		return dp[r][g][b]

	area = 0
	if r<R and g<G:
		area = max(area, rl[r] * gl[g] + cal(r+1, g+1, b))
	if r<R and b<B:
		area = max(area, rl[r] * bl[b] + cal(r+1, g, b+1))
	if g<G and b<B:
		area = max(area, gl[g] * bl[b] + cal(r, g+1, b+1))
	dp[r][g][b] = area
	return area

if __name__ == ""__main__"":
	R, G, B = map(int,input().split())
	rl = sorted(list(map(int,input().split())), reverse=True)
	gl = sorted(list(map(int,input().split())), reverse=True)
	bl = sorted(list(map(int,input().split())), reverse=True)
	dp = [[[-1]*(B+1) for i in range(G+1)] for i in range(R+1)]
	print(cal(0,0,0))
",cubic,"dp,greedy,sortings",637
"R,G,B=list(map(int,input().split()))
r=list(map(int,input().split()))
g=list(map(int,input().split()))
b=list(map(int,input().split()))
r.sort(reverse=True)
g.sort(reverse=True)
b.sort(reverse=True)
dp = [[[0 for i in range(B + 1)] for j in range(G + 1)] for k in range(R + 1)]
ans=0
for i in range(R+1):
    for j in range(G+1):
        for k in range(B+1):
            if i<R and j<G:
                dp[i+1][j+1][k]=max(dp[i+1][j+1][k],r[i]*g[j]+dp[i][j][k])
            if i<R and k<B:
                dp[i+1][j][k+1]=max(dp[i+1][j][k+1],r[i]*b[k]+dp[i][j][k])
            if k<B and j<G:
                dp[i][j+1][k+1]=max(dp[i][j+1][k+1],b[k]*g[j]+dp[i][j][k])
            ans=max(ans,dp[i][j][k])
print(ans)",cubic,"dp,greedy,sortings",715
"from collections import defaultdict


def main():
    R, G, B = map(int, input().split())
    red = list(map(int, input().split()))
    green = list(map(int, input().split()))
    blue = list(map(int, input().split()))
    red.sort(reverse=True)
    green.sort(reverse=True)
    blue.sort(reverse=True)
    dp = [[[-2*10**9]*(B+10) for i in range(G+10)] for j in range(R+10)]
    dp[0][0][0] = 0
    ans = 0
    for i in range(R+1):
        for j in range(G+1):
            for k in range(B+1):
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+red[i-1]*green[j-1], dp[i]
                                  [j-1][k-1]+green[j-1]*blue[k-1], dp[i-1][j][k-1]+red[i-1]*blue[k-1])
                ans = max(ans, dp[i][j][k])
    print(ans)
    return


if __name__ == ""__main__"":
    main()


",cubic,"dp,greedy,sortings",800
"def f(l,r,g,b,op):
    if (r==0 and g==0) or (r==0 and b==0) or (b==0 and g==0):
        return 0
    else:
        if op[r][g][b]!=-1:
            return op[r][g][b]
        if r==0:
           op[r][g][b]=l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op)
           return op[r][g][b]
        if g==0:
           op[r][g][b]=l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op)
           return op[r][g][b]
        if b==0:
         op[r][g][b]=l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op)
         return op[r][g][b]
        op[r][g][b]=max(l[1][g-1]*l[2][b-1]+f(l,r,g-1,b-1,op),l[0][r-1]*l[2][b-1]+f(l,r-1,g,b-1,op),l[0][r-1]*l[1][g-1]+f(l,r-1,g-1,b,op))  
        return op[r][g][b]   

r,g,b=list(map(int,input().split()))
l=[]
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
l.append(sorted(list(map(int,input().split()))))
op=[[[-1 for i in range(b+1)]for j in range(g+1)]for k in range(r+1)]
#print(op)
print(f(l,r,g,b,op))
",cubic,"dp,greedy,sortings",950
"from sys import stdin, stdout
import math,sys,heapq
from itertools import permutations, combinations
from collections import defaultdict,deque,OrderedDict
from os import path
import random
import bisect as bi
def yes():print('YES')
def no():print('NO')
if (path.exists('input.txt')): 
    #------------------Sublime--------------------------------------#
    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');
    def I():return (int(input()))
    def In():return(map(int,input().split()))
else:
    #------------------PYPY FAst I/o--------------------------------#
    def I():return (int(stdin.readline()))
    def In():return(map(int,stdin.readline().split()))
#sys.setrecursionlimit(1500)
def dict(a):
    d={} 
    for x in a:
        if d.get(x,-1)!=-1:
            d[x]+=1
        else:
            d[x]=1
    return d
def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return -1

def cal(r,g,b,dp,R,G,B,nr,ng,nb):
    if dp[r][g][b]!=-1:
        return dp[r][g][b]
    best=0
    if r<nr and g<ng:
        best=max(best,cal(r+1,g+1,b,dp,R,G,B,nr,ng,nb)+R[r]*G[g])
    if r<nr and b<nb:
        best=max(best,cal(r+1,g,b+1,dp,R,G,B,nr,ng,nb)+R[r]*B[b])
    if g<ng and b<nb:
        best=max(best,cal(r,g+1,b+1,dp,R,G,B,nr,ng,nb)+B[b]*G[g])
    dp[r][g][b]=best
    return dp[r][g][b]
def main():
    try:
        nr,ng,nb=In()
        dp=[[[-1 for x in range(201)]for y in range(201)] for z in range(201)]
        R=list(In())
        G=list(In())
        B=list(In())
        R.sort(reverse=True)
        G.sort(reverse=True)
        B.sort(reverse=True)
        print(cal(0,0,0,dp,R,G,B,nr,ng,nb))
    except:
        pass
        
M = 998244353
P = 1000000007
 
if __name__ == '__main__':
    # for _ in range(I()):main()
    for _ in range(1):main()",cubic,"dp,greedy,sortings",1882
"n = [int(x) for x in input().split()]
a = []
for i in range(3):
	a.append([int(x) for x in input().split()])
	a[i].sort(reverse=True)

dp = [[[0 for i in range(n[2] + 1)] for j in range(n[1] + 1)] for k in range(n[0] + 1)]
ans = 0
for i in range(n[0] + 1):
	for j in range(n[1] + 1):
		for k in range(n[2] + 1):
			if i < n[0] and j < n[1]:
				dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + a[0][i] * a[1][j])
			if i < n[0] and k < n[2]:
				dp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + a[0][i] * a[2][k])
			if j < n[1] and k < n[2]:
				dp[i][j + 1][k + 1] = max(dp[i][j + 1][k + 1], dp[i][j][k] + a[1][j] * a[2][k])
			ans = max(ans, dp[i][j][k])

print(ans )",cubic,"dp,greedy,sortings",694
"import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",cubic,"combinatorics,dp,math,two pointers",347
"from collections import defaultdict
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = defaultdict(int)
for x in a:
    d[x] += 1
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",cubic,"combinatorics,dp,math,two pointers",865
"from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = map(int, input().split())
mod = 998244353
d = Counter(a)
d[0] = 0
b = list(d.items())
b.sort()
m = len(b)
ba = [0] * m
cn = [0] * (m + 1)
k = h = 0
for i, x in enumerate(b):
    while h < m and x[0] >= b[h][0] * 2:
        h += 1
    ba[i] = h - 1
    while k < m and x[0] * 2 > b[k][0]:
        k += 1
    cn[k] += x[1]
for i in range(m):
    cn[i+1] += cn[i]
dp = [0] * m
dp[0] = 1
b = [x[1] for x in b]
for i in range(n):
    ndp = [0] * m
    for j in range(1, m):
        if cn[j] >= i - 1:
            ndp[j] = dp[j] * (cn[j] - i + 1) % mod
        dp[j] += dp[j-1]
        if dp[j] >= mod:
            dp[j] -= mod
    for j in range(1, m):
        ndp[j] += dp[ba[j]] * b[j]
        ndp[j] %= mod
    dp = ndp
print(sum(dp) % mod)",cubic,"combinatorics,dp,math,two pointers",829
"from collections import Counter
import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
mod = 998244353
a.sort()
dp = [1] + [0] * n
for i in range(1, n + 1):
    x, pt = 1, i - 2
    while pt >= 0 and 2 * a[pt] > a[i - 1]:
        x = x * (n - pt - 2) % mod
        pt -= 1
    dp[i] = (dp[i - 1] * (n - i) + dp[pt + 1] * x) % mod
print(dp[-1])",cubic,"combinatorics,dp,math,two pointers",379
"mod = 998244353
eps = 10**-9


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())
    A = list(map(int, input().split())) + [0]
    A.sort()

    dp = [[0] * (i+1) for i in range(N+1)]
    dp[0][0] = 1
    l = 0
    for i in range(1, N+1):
        for ll in range(l+1, i):
            if A[ll] * 2 <= A[i]:
                l = ll
            else:
                break
        for j in range(1, l+2):
            dp[i][j] = (dp[l][j-1] + (dp[i][j-1] * (l-j+2))%mod)%mod
        for j in range(i):
            dp[i][j] = (dp[i-1][j] + dp[i][j])%mod
    print(dp[-1][-1])


if __name__ == '__main__':
    main()
",cubic,"combinatorics,dp,math,two pointers",640
"M = 998244353 
n = int(input())
l = sorted(map(int, input().split()))[::-1]
out = [0] * n
big = 0
if l[0] >= 2 * l[1]:
    out[1] = 1
    big = 1
for i in range(2, n):
    new = [0] * n
    bigN = 0
    for j in range(i):
        if l[j] >= 2 * l[i]:
            big += out[j]
        else:
            new[j] += out[j] * (i - 1)
            new[j] %= M
    
    new[i] = big
    bigN = (i * big) % M 
        
    out = new
    big = bigN
print((big + sum(out))%M)",cubic,"combinatorics,dp,math,two pointers",465
"import sys
input = sys.stdin.readline

class sieve:
  def __init__(self, n):
    self.n = n
    self.sv = [1] * (n + 1)
    self.sv[0] = 0
    self.sv[1] = 0
    for i in range(2, n + 1):
      if self.sv[i]:
        for j in range(i * 2, n + 1, i):
          self.sv[j] = 0
  def isprime(self, x):
    if x > self.n:
      return False
    return self.sv[x] == 1
  def factorize(self, x):
    res = []
    for i in range(2, int(x ** 0.5) + 1):
      if self.sv[i]:
        while x % i == 0:
          x //= i
          res.append(i)
    if x != 1:
      res.append(x)
    return res
  def modlcm(self, a, mod):
    res = [0] * (self.n + 1)
    ex = set()
    for i in range(len(a)):
      f = self.factorize(a[i])
      for j in f:
        if j > self.n:
          ex.add(j)
          continue
        res[j] = max(f.count(j), res[j])
    rres = 1
    for i in range(self.n + 1):
      if res[i] != 0:
        rres *= pow(i, res[i], mod)
        rres %= mod
    for i in ex:
      rres *= i
      rres %= mod
    return rres

sv = sieve(10 ** 4)
for _ in range(int(input())):
  n, k = map(int, input().split())
  a = list(map(int, input().split()))
  for i in range(n):
    x = a[i]
    q = sv.factorize(x)
    s = [1]
    while len(q):
      y = q.pop()
      if y == s[-1]:
        s.pop()
        a[i] //= y ** 2
      else: s.append(y)
  s = [set() for _ in range(k + 1)]
  #print(a)
  dp = [n] * (k + 1)
  dp[0] = 0

  for i in range(n):
    for j in range(k, -1, -1):
      if dp[j] == n: continue
      if a[i] in s[j]:
        if j + 1 <= k and dp[j + 1] > dp[j]:
          dp[j + 1] = dp[j]
          s[j + 1] = s[j]
        dp[j] += 1
        s[j] = set()
        s[j].add(a[i])
      else:
        s[j].add(a[i])
      

    #print(dp, s)

  for j in range(k + 1): dp[j] += len(s[j]) > 0
  print(min(dp))
",cubic,"data structures,dp,greedy,math,number theory,two pointers",1817
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
import bisect
T = int(input())
r = 1

prime = [2]

for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue 
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0: 
            flag = True 
            break
    if not flag:  prime.append(i)


#print(prime)


def primefactor(num):

    index = 0
    output = []

    while num>=prime[index]**2:

        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1 

    if num>1: output.append(num)


    return tuple(output)





while r<=T:
    n,k = map(int,input().split())
    

    arr = list(map(int,input().split()))

#    arr = [5*i+1 for i in range(n)]
#    print(arr)


    seg = 1
    fact = {}
    left = [[0 for j in range(k+1)] for i in range(n)]
    dp = [[300000 for j in range(k+1)] for i in range(n)]

    stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:
            bisect.insort(stack,fact[factor]+1)
            
        fact[factor] = i

        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]



    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):
                l = left[i][t]
                if l>0:
                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])
                else:
                    dp[i][j] = 1



    



#    print(left)
#    print(dp)
    print(dp[-1][-1])   

    
    
  

    



    r += 1
",cubic,"data structures,dp,greedy,math,number theory,two pointers",1613
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
import bisect
T = int(input())
r = 1
 
prime = [2]
 
for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue 
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0: 
            flag = True 
            break
    if not flag:  prime.append(i)
 
 
#print(prime)
 
 
def primefactor(num):
 
    index = 0
    output = []
 
    while num>=prime[index]**2:
 
        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1 
 
    if num>1: output.append(num)
 
 
    return tuple(output)
 
 
 
 
 
while r<=T:
    n,k = map(int,input().split())
    
 
    arr = list(map(int,input().split()))
 
#    arr = [5*i+1 for i in range(n)]
#    print(arr)
 
 
    seg = 1
    fact = {}
    left = [[0 for j in range(k+1)] for i in range(n)]
    dp = [[300000 for j in range(k+1)] for i in range(n)]
 
    stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:
            bisect.insort(stack,fact[factor]+1)
            
        fact[factor] = i
 
        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]
 
 
 
    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):
                l = left[i][t]
                if l>0:
                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])
                else:
                    dp[i][j] = 1
 
 
 
    
 
 
 
#    print(left)
#    print(dp)
    print(dp[-1][-1])   
 
    
    
  
 
    
 
 
 
    r += 1
",cubic,"data structures,dp,greedy,math,number theory,two pointers",1650
"""""""
#If FastIO not needed, use this and don't forget to strip
#import sys, math
#input = sys.stdin.readline
""""""

import os, sys, heapq as h, time
from io import BytesIO, IOBase
from types import GeneratorType
from bisect import bisect_left, bisect_right
from collections import defaultdict as dd, deque as dq, Counter as dc
import math, string
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#start_time = time.time()

def getInt(): return int(input())
def getStrs(): return input().split()
def getInts(): return list(map(int,input().split()))
def getStr(): return input()
def listStr(): return list(input())
def getMat(n): return [getInts() for _ in range(n)]
def isInt(s): return '0' <= s[0] <= '9'

MOD = 10**9 + 7 

""""""

""""""

squares = set([i*i for i in range(1,4000)])

p = [i for i in range(10**7+1)]
for i in range(1,10**7+1):
    if p[i] == i:
        for sq in squares:
            if i*sq > 10**7: break
            p[i*sq] = i

def solve():
    N, K = getInts()
    A = getInts()
    new = 10**8
    A = [p[A[i]] for i in range(N)]
    dp = [N]*(K+1)
    dp[0] = 0
    used = [set()]*(K+1)
    for i in range(N):
        for j in range(K,-1,-1):
            if dp[j] == N: continue
            if A[i] in used[j]:
                if j < K and dp[j+1] > dp[j]:
                    dp[j+1] = dp[j]
                    used[j+1] = used[j]
                dp[j] += 1
                used[j] = set([A[i]])
            else:
                used[j].add(A[i])
    return min(dp)+1
    
for _ in range(getInt()):
    print(solve())
#solve()

#print(time.time()-start_time)",cubic,"data structures,dp,greedy,math,number theory,two pointers",3237
"import os, sys
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        import os
        self.os = os
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            self.os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def getInt(): return int(input())
def getStrs(): return input().split()
def getInts(): return list(map(int,input().split()))
def getStr(): return input()
def listStr(): return list(input())
def getMat(n): return [getInts() for _ in range(n)]
def isInt(s): return '0' <= s[0] <= '9'

squares = set([i*i for i in range(1,4000)])

p = [i for i in range(10**7+1)]
for i in range(1,10**7+1):
    if p[i] == i:
        for sq in squares:
            if i*sq > 10**7: break
            p[i*sq] = i

for _ in range(getInt()):
    N, K = getInts()
    A = getInts()
    new = 10**8
    A = [p[A[i]] for i in range(N)]
    dp = [N]*(K+1)
    dp[0] = 0
    used = [set()]*(K+1)
    for i in range(N):
        for j in range(K,-1,-1):
            if dp[j] == N: continue
            if A[i] in used[j]:
                if j < K and dp[j+1] > dp[j]:
                    dp[j+1] = dp[j]
                    used[j+1] = used[j]
                dp[j] += 1
                used[j] = set([A[i]])
            else:
                used[j].add(A[i])
    print(min(dp)+1)
",cubic,"data structures,dp,greedy,math,number theory,two pointers",2807
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
import bisect
T = int(input())
r = 1
prime = [2]

for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue 
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0: 
            flag = True 
            break
    if not flag:  prime.append(i)

def primefactor(num):

    index = 0
    output = []

    while num>=prime[index]**2:

        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1 

    if num>1: output.append(num)


    return tuple(output)

while r<=T:
    n,k = map(int,input().split())
    arr = list(map(int,input().split()))

    seg = 1
    fact = {}
    left = [[0 for j in range(k+1)] for i in range(n)]
    dp = [[300000 for j in range(k+1)] for i in range(n)]

    stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:
            bisect.insort(stack,fact[factor]+1)
            
        fact[factor] = i

        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]



    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):
                l = left[i][t]
                if l>0:
                    dp[i][j] = min(dp[l-1][j-t] + 1, dp[i][j])
                else:
                    dp[i][j] = 1

    print(dp[-1][-1])   
    r += 1",cubic,"data structures,dp,greedy,math,number theory,two pointers",1464
"import io,os,bisect
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
prime = [2]

for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue 
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0: 
            flag = True 
            break
    if not flag:  prime.append(i)

def primefactor(num):

    index = 0
    output = []

    while num>=prime[index]**2:

        times = 0
        while num%prime[index]==0:
            num = num // prime[index]
            times += 1
        if times&1:  output.append(prime[index])
        index += 1 

    if num>1: output.append(num)


    return tuple(output)

for _ in range(int(input())):
    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:            bisect.insort(stack,fact[factor]+1)            
        fact[factor] = i
        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]
    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)
    print(dp[-1][-1])   ",cubic,"data structures,dp,greedy,math,number theory,two pointers",1310
"import io,os,bisect;input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline;prime = [2]
for i in range(3,4*10**3,2):
    flag = False
    if i%2==0: continue 
    for j in range(3,int(i**0.5)+1,2):
        if i%j==0: flag = True;break
    if not flag:  prime.append(i)
def primefactor(num):
    index = 0;output = []
    while num>=prime[index]**2:
        times = 0
        while num%prime[index]==0:num = num // prime[index];times += 1
        if times&1:  output.append(prime[index])
        index += 1 
    if num>1: output.append(num)
    return tuple(output)
for _ in range(int(input())):
    n,k = map(int,input().split());arr = list(map(int,input().split()));seg = 1;fact = {};left = [[0 for j in range(k+1)] for i in range(n)];dp = [[300000 for j in range(k+1)] for i in range(n)];stack = [0]
    for i in range(n):
        factor = primefactor(arr[i])
        if factor in fact:            bisect.insort(stack,fact[factor]+1)            
        fact[factor] = i
        for j in range(k+1):
            if j<len(stack):  left[i][j] = stack[-j-1]
    for i in range(n):
        for j in range(k+1):
            for t in range(j+1):l = left[i][t];dp[i][j] = (min(dp[l-1][j-t] + 1, dp[i][j]) if l > 0 else 1)
    print(dp[-1][-1])   ",cubic,"data structures,dp,greedy,math,number theory,two pointers",1246
"import bisect
import time
def ass(a, b): print(f""Assertion error: {a} != {b}"" if a != b else 'OK')
def nr(): return int(input())
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2, n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res
#ass(get_prime(50),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47])

def get_mask(num):
	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	return num

def dump(dp):
	for i,line in enumerate(dp):
		print(i%10,line)

def get_left(n,k,lst):
	last_in = {}
	s = []
	res = []
	for i in range(n):
		group = get_mask(lst[i])
		if group in last_in: bisect.insort(s, last_in[group] + 1)
		last_in[group] = i
		if len(s) <= k+1:
			res.append(s[::-1])
		else:
			m = len(s)
			res.append(s[m-1:m-k-2:-1])
	return res
#ass(get_left(11,4,[6,2,2,8,9,1,3,6,3,9,7]),[[], [], [2], [3, 2], [3, 2], [5, 3, 2], [5, 3, 2], [5, 3, 2, 1], [7, 5, 3, 2,1], [7, 6, 5, 3, 2], [7, 6, 5, 3, 2]])

def get_dp(n,k,lst):
	res = []
	left = get_left(n,k,lst)
	for i in range(n):
		arr = left[i]
		row = [n] * (k+1)
		for j in range(k+1):
			for g in range(j+1):
				if g >= len(arr):
					row[j] = 1
				else:
					index = arr[g]-1
					jindex = j-g
					row[j] = min(res[index][jindex] + 1, row[j])
		res.append(row)
	return res

def f(n,k,lst):
	dp = get_dp(n,k,lst)
	print(dp[n-1][k])

#start = time.time()
prime = get_prime(3162)
#print(time.time()-start)

#f(11,4,[6,2,2,8,9,1,3,6,3,9,7])
#f(11,4,[7,7,7,7,7,7,7,7,7,7,7])
#f(11,4,[1,2,3,4,5,6,5,4,3,2,1])

for _ in range(nr()):
	n,k = nrs()
	f(n,k,nrs())
",cubic,"data structures,dp,greedy,math,number theory,two pointers",1763
"import bisect
import time
def ass(a, b): print(f""Assertion error: {a} != {b}"" if a != b else 'OK')
def nr(): return int(input())
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2, n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res
#ass(get_prime(50),[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47])

cache = {}

def get_mask(num):
	key = num
	if key in cache: return cache[key]
	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	cache[key] = num
	return num

def dump(dp):
	for i,line in enumerate(dp):
		print(i%10,line)

def get_left(n,k,lst):
	last_in = {}
	s = []
	res = []
	for i in range(n):
		group = get_mask(lst[i])
		if group in last_in: bisect.insort(s, last_in[group] + 1)
		last_in[group] = i
		if len(s) <= k+1:
			res.append(s[::-1])
		else:
			m = len(s)
			res.append(s[m-1:m-k-2:-1])
	return res
#ass(get_left(11,4,[6,2,2,8,9,1,3,6,3,9,7]),[[], [], [2], [3, 2], [3, 2], [5, 3, 2], [5, 3, 2], [5, 3, 2, 1], [7, 5, 3, 2,1], [7, 6, 5, 3, 2], [7, 6, 5, 3, 2]])

def get_dp(n,k,lst):
	res = []
	left = get_left(n,k,lst)
	for i in range(n):
		arr = left[i]
		row = [n] * (k+1)
		for j in range(k+1):
			for g in range(j+1):
				if g >= len(arr):
					row[j] = 1
				else:
					index = arr[g]-1
					jindex = j-g
					row[j] = min(res[index][jindex] + 1, row[j])
		res.append(row)
	return res

def f(n,k,lst):
	dp = get_dp(n,k,lst)
	print(dp[n-1][k])

#start = time.time()
prime = get_prime(3162)
#print(time.time()-start)

#f(11,4,[6,2,2,8,9,1,3,6,3,9,7])
#f(11,4,[7,7,7,7,7,7,7,7,7,7,7])
#f(11,4,[1,2,3,4,5,6,5,4,3,2,1])

for _ in range(nr()):
	n,k = nrs()
	f(n,k,nrs())
",cubic,"data structures,dp,greedy,math,number theory,two pointers",1840
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

n = 10**7
squares = [i * i for i in range(1, 3162)]

p = [i for i in range(n + 1)]
for i in range(1, n + 1):
	if p[i] == i:
		for sq in squares:
			if i * sq > n: break
			p[i * sq] = i

for _ in range(nr()):
	N, K = nrs()
	A = [p[a] for a in nrs()]
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [set()] * (K + 1)
	for a in A:
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = set([a])
			else:
				used[j].add(a)
	print(min(dp))
",cubic,"data structures,dp,greedy,math,number theory,two pointers",643
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

n = 10**7
squares = [i * i for i in range(1, 3162)]

p = list(range(n + 1))
for i in range(1, n + 1):
	if p[i] == i:
		for sq in squares:
			if i * sq > n: break
			p[i * sq] = i

for _ in range(nr()):
	N, K = nrs()
	A = [p[a] for a in nrs()]
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))
",cubic,"data structures,dp,greedy,math,number theory,two pointers",617
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2,n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res

prime = get_prime(3162)

cache = {}
def get_mask (num):
	key = num
	if key in cache: return cache[key]
	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	cache[key] = num
	return num

for _ in range(nr()):
	N, K = nrs()
	A = nrs()
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		a = get_mask(a)
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))
",cubic,"data structures,dp,greedy,math,number theory,two pointers",919
"def nr(): return nrs()[0]
def nrs(): return [int(i) for i in input().split()]

def get_prime(n):
	res = []
	for i in range(2,n):
		is_prime = True
		for x in res:
			if i % x == 0:
				is_prime = False
				break
		if is_prime: res.append(i)
	return res

prime = get_prime(3162)

#cache = {}
def get_mask (num):
	#key = num
	#if key in cache: return cache[key]
	dv = []
	for p in prime:
		c = 0
		while num % p == 0:
			c += 1
			num = num // p
		if c % 2 == 1:
			dv.append(p)
		if num < p * p:
			break

	for x in dv:
		num *= x

	#cache[key] = num
	return num

for _ in range(nr()):
	N, K = nrs()
	A = nrs()
	dp = [N] * (K + 1)
	dp[0] = 1
	used = [{}] * (K + 1)
	for a in A:
		a = get_mask(a)
		for j in range(K, -1, -1):
			if dp[j] == N: continue
			if a in used[j]:
				if j < K and dp[j + 1] > dp[j]:
					dp[j + 1] = dp[j]
					used[j + 1] = used[j]
				dp[j] += 1
				used[j] = {}
			used[j][a] = 1
	print(min(dp))
",cubic,"data structures,dp,greedy,math,number theory,two pointers",923
"pfs=[i*i for i in range(1,3163)]
p=[i for i in range(0,10000001)]
for i in range(1,10000001):
    if(p[i]==i):
        for j in pfs:
            if(i*j>10000000): break
            p[i*j]=i
t=int(input())
for lll in range(0,t):
    n,k=map(int,input().split())
    zc=list(map(int,input().split()))
    s=[p[zc[i]] for i in range(0,len(zc))]
    dp=[n]*(k+1)
    dp[0]=1
    ys=[{}]*(n+1)
    for i in range(0,len(s)):
        for j in range(k,-1,-1):
            if(dp[j]==n): continue
            if(ys[j].get(s[i],-1)!=-1):
                if(j<k and dp[j]<dp[j+1]):
                    dp[j+1]=dp[j]
                    ys[j+1]=ys[j]
                dp[j]+=1
                ys[j]={}
            ys[j][s[i]]=1
    print(min(dp))",cubic,"data structures,dp,greedy,math,number theory,two pointers",732
"pfs=[i*i for i in range(1,3163)]
p=[i for i in range(0,10000001)]
for i in range(1,10000001):
    if(p[i]==i):
        for j in pfs:
            if(i*j>10000000): break
            p[i*j]=i
t=int(input())
for lll in range(0,t):
    n,k=map(int,input().split())
    zc=list(map(int,input().split()))
    s=[p[zc[i]] for i in range(0,len(zc))]
    dp=[n]*(k+1)
    dp[0]=1
    ys=[{}]*(n+1)
    for i in range(0,len(s)):
        for j in range(k,-1,-1):
            if(dp[j]==n): continue
            if(ys[j].get(s[i],-1)!=-1):
                if(j<k and dp[j]<dp[j+1]):
                    dp[j+1]=dp[j]
                    ys[j+1]=ys[j]
                dp[j]+=1
                ys[j]={}
            ys[j][s[i]]=1
    print(min(dp))
						  		      	 	 	 	 		   		",cubic,"data structures,dp,greedy,math,number theory,two pointers",764
"import os
import io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline 
 
from math import sqrt,ceil
 
max_n=10**7+1
spf = [i for i in range(max_n)]
 
for i in range(4,max_n,2): 
    spf[i]=2
    
for i in range(3,ceil(sqrt(max_n))): 
    if (spf[i]==i):  
        for j in range(i*i,max_n,i):  
            if(spf[j]==j):
                spf[j]=i
                
from collections import Counter,defaultdict
from bisect import insort
 
def f(x):
    c=Counter()
    ans=1
    while(x!=1):
        c[spf[x]]+=1
        x//=spf[x] 
    for i in c:
        if(c[i]%2==1):
            ans*=i
    return(ans)
 
#https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/
 
t=int(input())
for _ in range(t):
    n,k=map(int,input().split())
    a=list(map(int,input().split()))
    for i in range(n):
        a[i]=f(a[i])
    dp_depth=[[n for j in range(k+1)] for i in range(n)] #Maximum length that can be tranversed in list, starting from index i with atmost j repeated elements(default is entire length of list(max possible)
    recent=[n for i in range(k+1)] #Stores position of most recent repeated element in the suffix(default is one more that maximum index(when no sufficient repeats))
    closest=defaultdict(lambda: -1) #Stores index of first repetition for a particular ai 
    for i in range(n-1,-1,-1):
        if(closest[a[i]]>=0):
            insort(recent,closest[a[i]])
            recent.pop()
        dp_depth[i]=recent.copy()
        closest[a[i]]=i 
    dp=[[i for j in range(k+1)] for i in range(n+1)]
    #dp=[[float('inf') for j in range(k+1)] for i in range(n+1)] #Minimum number of sets in the prefix segment upto(and **excluding**) index i after atmost k changes(which is also = number of partitions/splits(number of element changes) upto and **excluding** index i).
    #Note we could have changed the float('inf') to ""i"" but that's tougher to debug.
    dp[0]=[0 for j in range(k+1)] #base case(don't need to divide at all before element at index 0(first element))
    for i in range(n):
        for x in range(k+1): 
            end=dp_depth[i][x] #The end point of our segment(upto and exluding this index position)
            #We are dividing each segment into subsegments: prefix consisting of [0,i), suffix consisting from [i,end)
            #x is the number of partitions/splits(number of elements we change) in the suffix subsegment(Number of repeated elements starting from index i)
            for y in range(k-x+1): #y is the number of partitions/splits(number of elements we change) in the prefix subsegment
                dp[end][x+y]=min(dp[end][x+y],dp[i][y]+1) #after using the previously calculated value dp[i][y](<=y changes), with <= x more ""changes""(equality holds iff end=n) in the suffix segment, this gives an extra set starting from [i,end). So overall, we get number of sets of dp[i][y]+1.
    print(dp[n][k])
                
                
            

",cubic,"data structures,dp,greedy,math,number theory,two pointers",2947
"def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    if n==1:
        return 0
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):#排他的論理和の階乗
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[digit[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[digit[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class Matrix():
    mod=10**9+7

    def set_mod(m):
        Matrix.mod=m

    def __init__(self,L):
        self.row=len(L)
        self.column=len(L[0])
        self._matrix=L
        for i in range(self.row):
            for j in range(self.column):
                self._matridigit[i][j]%=Matrix.mod

    def __getitem__(self,item):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        return self._matridigit[i][j]

    def __setitem__(self,item,val):
        if type(item)==int:
            raise IndexError(""you must specific row and column"")
        elif len(item)!=2:
            raise IndexError(""you must specific row and column"")

        i,j=item
        self._matridigit[i][j]=val

    def __add__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]+other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __sub__(self,other):
        if (self.row,self.column)!=(other.row,other.column):
            raise SizeError(""sizes of matrixes are different"")

        res=[[0 for j in range(self.column)] for i in range(self.row)]
        for i in range(self.row):
            for j in range(self.column):
                res[i][j]=self._matridigit[i][j]-other._matridigit[i][j]
                res[i][j]%=Matrix.mod
        return Matrix(res)

    def __mul__(self,other):
        if type(other)!=int:
            if self.column!=other.row:
                raise SizeError(""sizes of matrixes are different"")

            res=[[0 for j in range(other.column)] for i in range(self.row)]
            for i in range(self.row):
                for j in range(other.column):
                    temp=0
                    for k in range(self.column):
                        temp+=self._matridigit[i][k]*other._matrix[k][j]
                    res[i][j]=temp%Matrix.mod
            return Matrix(res)
        else:
            n=other
            res=[[(n*self._matridigit[i][j])%Matrix.mod for j in range(self.column)] for i in range(self.row)]
            return Matrix(res)

    def __pow__(self,m):
        if self.column!=self.row:
            raise MatrixPowError(""the size of row must be the same as that of column"")

        n=self.row
        res=Matrix([[int(i==j) for i in range(n)] for j in range(n)])
        while m:
            if m%2==1:
                res=res*self
            self=self*self
            m//=2
        return res

    def __str__(self):
        res=[]
        for i in range(self.row):
            for j in range(self.column):
                res.append(str(self._matridigit[i][j]))
                res.append("" "")
            res.append(""\n"")
        res=res[:len(res)-1]
        return """".join(res)

from collections import deque
class Dinic:
    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap):
        forward = [to, cap, None]
        forward[2] = backward = [fr, 0, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def add_multi_edge(self, v1, v2, cap1, cap2):
        edge1 = [v2, cap1, None]
        edge1[2] = edge2 = [v1, cap2, edge1]
        self.G[v1].append(edge1)
        self.G[v2].append(edge2)

    def bfs(self, s, t):
        self.level = level = [None]*self.N
        deq = deque([s])
        level[s] = 0
        G = self.G
        while deq:
            v = deq.popleft()
            lv = level[v] + 1
            for w, cap, _ in G[v]:
                if cap and level[w] is None:
                    level[w] = lv
                    deq.append(w)
        return level[t] is not None

    def dfs(self, v, t, f):
        if v == t:
            return f
        level = self.level
        for e in self.it[v]:
            w, cap, rev = e
            if cap and level[v] < level[w]:
                d = self.dfs(w, t, min(f, cap))
                if d:
                    e[1] -= d
                    rev[1] += d
                    return d
        return 0

    def flow(self, s, t):
        flow = 0
        INF = 10**9 + 7
        G = self.G
        while self.bfs(s, t):
            *self.it, = map(iter, self.G)
            f = INF
            while f:
                f = self.dfs(s, t, INF)
                flow += f
        return flow

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

n,mod = mi()

N = 1000
g1 = [1]*(N+1)
g2 = [1]*(N+1)
inverse = [1]*(N+1)

for i in range( 2, N + 1 ):
    g1[i]=( ( g1[i-1] * i ) % mod )
    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )
    g2[i]=( (g2[i-1] * inverse[i]) % mod )
inverse[0]=0

pow_2 = [1 for i in range(1001)]
for i in range(1,1001):
    pow_2[i] = (pow_2[i-1] * 2) % mod

dp = [[1]]

for i in range(n):
    ndp = [[0] + [dp[s][k] for k in range(i+1)] for s in range(i+1)] + [[0 for k in range(i+2)]]
    for s in range(i+1):
        for k in range(i+1):
            if not dp[s][k]:
                continue
            #auto
            if k!=0:
                ndp[s+k][0] += (dp[s][k] * g2[k] % mod) * pow_2[k-1] % mod
                ndp[s+k][0] %= mod

    dp = ndp

res = 0
for s in range(n+1):
    for k in range(1,n+1):
        res += (pow_2[k-1] * g1[s+k] % mod) * (dp[s][k] * g2[k] % mod) % mod
        res %= mod

print(res)
",cubic,"combinatorics,dp,math",18327
"n, MOD = map(int, input().split())

pascal = [[1]]
for _ in range(500):
    nl = [1]
    for i in range(_):
        nl.append((pascal[-1][i] + pascal[-1][i+1]) % MOD)
    nl.append(1)
    pascal.append(nl)

mod_mul = lambda x, y: (x * y) % MOD

import __pypy__

int_add = __pypy__.intop.int_add
int_sub = __pypy__.intop.int_sub
int_mul = __pypy__.intop.int_mul


def make_mod_mul(mod=MOD):
    fmod_inv = 1.0 / mod

    def mod_mul(a, b, c=0):
        res = int_sub(int_add(int_mul(a, b), c), int_mul(mod, int(fmod_inv * a * b + fmod_inv * c)))
        if res >= mod:
            return res - mod
        elif res < 0:
            return res + mod
        else:
            return res

    return mod_mul


mod_mul = make_mod_mul()


def mod_pow(x, y):
    if y == 0:
        return 1
    res = 1
    while y > 1:
        if y & 1 == 1:
            res = mod_mul(res, x)
        x = mod_mul(x, x)
        y >>= 1
    return mod_mul(res, x)


base = [0] * (n + 1)

dp = []
for i in range(n):
    nex = base[:]
    nex[1] = mod_pow(2, i)
    for j in range(i - 1):
        bl = i-j-1
        assert bl > 0
        mul = mod_pow(2, bl - 1)
        for k in range(n):
            ct = 2 + j - k
            if ct < 0:
                assert dp[j][k] == 0
                continue
            mulr = mod_mul(mul, pascal[bl+ct][ct])
            nex[k+1] += mod_mul(mulr, dp[j][k])
            nex[k+1] %= MOD
    dp.append(nex)
print(sum(dp[-1]) % MOD)
",cubic,"combinatorics,dp,math",1447
"#   Author: yumtam
#   Created at: 2021-05-03 00:42

from __pypy__.intop import int_mulmod

n_, MOD = [int(t) for t in input().split()]

def mul(a, b):
    return int_mulmod(a, b, MOD)

N = 410
dp = [[0] * (N+1) for _ in range(N+1)]

fact = [1]
for x in range(1, N):
    fact.append(fact[-1] * x % MOD)

inv_fact = [0] * N
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for x in reversed(range(1, N)):
    inv_fact[x - 1] = inv_fact[x] * x % MOD

def nCr(n, r):
    return mul(fact[n], mul(inv_fact[n-r], inv_fact[r]))

for n in range(1, N+1):
    dp[n][n] = pow(2, n-1, MOD)
    for i in range(1, n-1):
        j = n-i-1
        for k in range(1, i+1):
            dp[n][k+j] = (dp[n][k+j]
                          + mul(nCr(k+j, k), mul(dp[i][k], dp[j][j]))) % MOD

print(sum(dp[n_]) % MOD)
",cubic,"combinatorics,dp,math",790
"
def  getc():
    f = [[0]*500 for i in range(500)]
    for i in range(500):
        f[i][0] = 1
    f[1][0] = 1
    f[1][1] = 1
    for i in range(2,411):
        for j in range(1, i+1):
            f[i][j] = (f[i-1][j-1] + f[i-1][j])%mod
    return f
n, mod = map(int, input().split())
f = [[0]*500 for i in range(500)]
c = getc()
mi_2 = [0]*500
mi_2[0] = 1
for i in range(1, 500):
    mi_2[i] = mi_2[i-1]*2%mod
for i in range(1, n+1):
    for j in range(0, i//2+1):
        if j == 0:
            f[i][j] = mi_2[i-1]
        else:
            for k in range(2, i):
                f[i][j] = (f[i][j] + ((mi_2[k-2]*f[i-k][j-1])%mod)*c[i-j][k-1]%mod)%mod 
ans = 0
for i in range(0,n+1):
    ans = (ans + f[n][i])%mod
print(ans)
",cubic,"combinatorics,dp,math",729
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.buffer.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
# md = 10**9+7
# md = 998244353

n, md = LI()

def nHr(hn, hr):
    return nCr(hn+hr-1, hr-1)

def nPr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_n-com_r]%md

def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

n_max = 405
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md
pw = [1]
for i in range(400): pw.append(pw[-1]*2%md)

# dp[i][j]...iにj個目の白を置いたときの場合の数
dp = [[0]*(n//2+2) for _ in range(n+2)]
dp[0][0] = 1
for i in range(1, n+2):
    for j in range(1, n//2+2):
        v = 0
        for k in range(i-2, -1, -1):
            v += dp[k][j-1]*pw[i-k-2]*nCr(i-j, i-k-1)%md
        dp[i][j] = v%md
# p2D(dp)

ans = sum(dp[-1])%md
print(ans)
",cubic,"combinatorics,dp,math",1479
"#!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase


def main():
    n, MOD = map(int, input().split())
    factorial = [1]
    for i in range(2, n + 1):
        factorial.append(factorial[-1] * i % MOD)
    for i in range(len(factorial)):
        factorial[i] = pow(factorial[i], MOD - 2, MOD)
    DP = []
    for i in range(n):
        DP.append([0] * n)
    for i in range(n):
        DP[i][0] = pow(2, i, MOD) * factorial[i]
        for j in range(1, i // 2 + 1):
            for k in range(0, i - 1):
                DP[i][j] += DP[k][j - 1] * pow(2, i - k - 2, MOD) * factorial[i - k - 2]
            DP[i][j] %= MOD
    ans = 0
    for i in range(len(factorial)):
        factorial[i] = pow(factorial[i], MOD - 2, MOD)
    for i in range(n):
        ans += DP[n - 1][i] * factorial[n - i - 1]
    print(ans % MOD)



# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()",cubic,"combinatorics,dp,math",2566
"N, mod = map(int, input().split())

two = [1] * (N+1)
fact = [1] * (N+1)
inv = [1] * (N+1)
for i in range(1, N+1):
    two[i] = two[i-1]*2 % mod
for i in range(2, N+1):
    fact[i] = fact[i-1] * i % mod
inv[N] = pow(fact[N], mod-2, mod)
for i in range(N, 0, -1):
    inv[i-1] = inv[i] * i % mod

dp = [[0] * (N+2) for _ in range(N+2)]
dp[0][0] = 1
for i in range(N):
    for j in range(i+1):
        for k in range(1, N+1):
            if i+k > N:
                break
            dp[i+k+1][j+1] += dp[i][j] * two[k-1] * inv[k] % mod
            dp[i+k+1][j+1] %= mod

ans = 0
for j in range(1, N+1):
    ans += dp[N+1][j] * fact[N-j+1] % mod
    ans %= mod
print(ans)
",cubic,"combinatorics,dp,math",670
"
p1, g1, ig1 = 104857601, 3, 34952534
p2, g2, ig2 = 111149057, 3, 37049686
p3, g3, ig3 = 113246209, 7, 16178030
z1 = 439957480532171226961446
z2 = 879898597692195524486915
z3 = 8496366309945115353
ppp = p1 * p2 * p3
W1 = [pow(g1, (p1 - 1) >> i, p1) for i in range(22)]
W2 = [pow(g2, (p2 - 1) >> i, p2) for i in range(22)]
W3 = [pow(g3, (p3 - 1) >> i, p3) for i in range(22)]
iW1 = [pow(ig1, (p1 - 1) >> i, p1) for i in range(22)]
iW2 = [pow(ig2, (p2 - 1) >> i, p2) for i in range(22)]
iW3 = [pow(ig3, (p3 - 1) >> i, p3) for i in range(22)]

def fft1(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W1[l] % p1)
        
        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p1, U[j] * (f[s] - f[s+d]) % p1
def fft2(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W2[l] % p2)
        
        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p2, U[j] * (f[s] - f[s+d]) % p2
def fft3(k, f):
    for l in range(k, 0, -1):
        d = 1 << l - 1
        U = [1]
        for i in range(d):
            U.append(U[-1] * W3[l] % p3)
        
        for i in range(1 << k - l):
            for j in range(d):
                s = i * 2 * d + j
                f[s], f[s+d] = (f[s] + f[s+d]) % p3, U[j] * (f[s] - f[s+d]) % p3

def ifft1(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p1, (f[j] - f[j+d]) % p1
                u = u * iW1[l] % p1
def ifft2(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p2, (f[j] - f[j+d]) % p2
                u = u * iW2[l] % p2
def ifft3(k, f):
    for l in range(1, k + 1):
        d = 1 << l - 1
        for i in range(1 << k - l):
            u = 1
            for j in range(i * 2 * d, (i * 2 + 1) * d):
                f[j+d] *= u
                f[j], f[j+d] = (f[j] + f[j+d]) % p3, (f[j] - f[j+d]) % p3
                u = u * iW3[l] % p3

def convolve(a, b):
    n0 = len(a) + len(b) - 1
    if len(a) < 50 or len(b) < 50:
        ret = [0] * n0
        if len(a) > len(b): a, b = b, a
        for i, aa in enumerate(a):
            for j, bb in enumerate(b):
                ret[i+j] = (ret[i+j] + aa * bb) % P
        return ret
    
    k = (n0).bit_length()
    n = 1 << k
    a = a + [0] * (n - len(a))
    b = b + [0] * (n - len(b))
    
    a1 = [x % p1 for x in a]
    a2 = [x % p2 for x in a]
    a3 = [x % p3 for x in a]
    b1 = [x % p1 for x in b]
    b2 = [x % p2 for x in b]
    b3 = [x % p3 for x in b]
    fft1(k, a1), fft1(k, b1)
    fft2(k, a2), fft2(k, b2)
    fft3(k, a3), fft3(k, b3)
    for i in range(n): a1[i] = a1[i] * b1[i] % p1
    for i in range(n): a2[i] = a2[i] * b2[i] % p2
    for i in range(n): a3[i] = a3[i] * b3[i] % p3
    ifft1(k, a1)
    ifft2(k, a2)
    ifft3(k, a3)
    invn1 = pow(n, p1 - 2, p1)
    invn2 = pow(n, p2 - 2, p2)
    invn3 = pow(n, p3 - 2, p3)
    for i in range(n0): a1[i] = a1[i] * invn1 % p1
    for i in range(n0): a2[i] = a2[i] * invn2 % p2
    for i in range(n0): a3[i] = a3[i] * invn3 % p3
    return [(x1 * z1 + x2 * z2 + x3 * z3) % ppp % P for x1, x2, x3 in zip(a1[:n0], a2[:n0], a3[:n0])]
def chk(L):
    return [fa[i] * x % P for i, x in enumerate(L)]
def chkinv(L):
    return [fainv[i] * x % P for i, x in enumerate(L)]
N, P = map(int, input().split())

nn = 1001 # !!!!!!!!!!!

fa = [1] * (nn+1)
fainv = [1] * (nn+1)
for i in range(nn):
    fa[i+1] = fa[i] * (i+1) % P
fainv[-1] = pow(fa[-1], P-2, P)
for i in range(nn)[::-1]:
    fainv[i] = fainv[i+1] * (i+1) % P

X = [[] for _ in range(444)]
Y = [[] for _ in range(444)]
X[0] = [1]
X[1] = [0, 1]
X[2] = [0, 1, 1]
X[3] = [0, 0, 4, 1]

Y[0] = [1]
Y[1] = [1, 0]
Y[2] = [0, 2, 0]
Y[3] = [0, 1, 4, 0]

for i in range(4, 404):
    X[i] = [0] * i + [1]
    Y[i] = [0] * (i + 1)
    for j in range(1, i):
        k = i - j
        X[i][j] = (X[i-1][j-1] * (2 * k + 1) + X[i-2][j-1] * k) % P
        Y[i][j] = (Y[i-1][j-1] * (2 * k) + Y[i-2][j-1] * (k-1)) % P

X = [chkinv(a) for a in X]
Y = [chkinv(a) for a in Y]

ANS = [0] * (N + 1)
for i in range(N):
    t = convolve(X[i], X[N-1-i])
    for j, a in enumerate(t):
        ANS[j] = (ANS[j] + a) % P
# print(ANS)
ans = 0
for i, a in enumerate(ANS):
    ans = (ans + a * fa[i]) % P
print(ans)



",cubic,"combinatorics,dp,math",4850
"
from bisect import bisect,bisect_left

from collections import *
from heapq import *
from math import gcd,ceil,sqrt,floor,inf

from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

#------------------------------------------------------------------------
import os
import sys

from io import BytesIO, IOBase
# region fastio
 
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 

#------------------------------------------------------------------------
def RL(): return map(int, sys.stdin.readline().split())
def RLL(): return list(map(int, sys.stdin.readline().split()))
def N(): return int(input())
def A(n):return [0]*n
def AI(n,x): return [x]*n
def A2(n,m): return [[0]*m for i in range(n)]
def G(n): return [[] for i in range(n)]
def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]
#------------------------------------------------------------------------


from types import GeneratorType
 
 
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
 
    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]
 
def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]
 
def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()
 
def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod
    
def com(i,j,mod=0):
    if i<j: return 0
    if not mod:        
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod
 
def catalan(n):
    return com(2*n,n)//(n+1)
 
def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m
 
def lowbit(n):
    return n&-n
 
class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1
        
    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x
 
    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans

class ST:
    def __init__(self,arr):#n!=0
        n=len(arr)
        mx=n.bit_length()#取不到
        self.st=[[0]*mx for i in range(n)]
        for i in range(n):
            self.st[i][0]=arr[i]
        for j in range(1,mx):
            for i in range(n-(1<<j)+1):
                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])
    def query(self,l,r):
        if l>r:return -inf
        s=(r+1-l).bit_length()-1
        return max(self.st[l][s],self.st[r-(1<<s)+1][s])
        
class DSU:#容量+路径压缩
    def __init__(self,n):
        self.c=[-1]*n
 
    def same(self,x,y):
        return self.find(x)==self.find(y)
 
    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]
 
    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True
 
    def size(self,x): return -self.c[self.find(x)]
    
class UFS:#秩+路径
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n
 
    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]
 
    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv

class UF:#秩+路径+容量，边数
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n
        self.size=AI(n,1)
        self.edge=A(n)
 
    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]
 
    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            self.edge[pu]+=1
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            self.edge[pu]+=self.edge[pv]+1
            self.size[pu]+=self.size[pv]
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv
            self.edge[pv]+=self.edge[pu]+1
            self.size[pv]+=self.size[pu]
 
def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1) 
    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return flag
 
def dij(s,graph):
    d=AI(n,inf)
    d[s]=0
    heap=[(0,s)]
    vis=A(n)
    while heap:
        dis,u=heappop(heap)
        if vis[u]:
            continue
        vis[u]=1
        for v,w in graph[u]:
            if d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d

def bell(s,g):#bellman-Ford
    dis=AI(n,inf)
    dis[s]=0
    for i in range(n-1):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
    change=A(n)
    for i in range(n):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
                change[v]=1
    return dis

def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)

def RP(nums):#逆序对
    n = len(nums)
    s=set(nums)
    d={}
    for i,k in enumerate(sorted(s),1):
        d[k]=i
    bi=BIT([0]*(len(s)+1))
    ans=0
    for i in range(n-1,-1,-1):
        ans+=bi.query(d[nums[i]]-1)
        bi.update(d[nums[i]],1)
    return ans
 
class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j,n,m):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(1,n+1):
        if ind[i]==0:
            q.append(i)
            res.append(i)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v)
    return res

@bootstrap
def gdfs(r,p):
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None

        
#from random import randint
'''
def f(n):
    s=set()
    for order in permutations(range(n)):
        res=A(n)
        cur=[]
        for i in order:
            if res[i]==0:
                res[i]=1
                if i>=2 and res[i-2]==1 and res[i-1]==0:
                    res[i-1]=1
                if i<n-2 and res[i+2]==1 and res[i+1]==0:
                    res[i+1]=1
                cur.append(i)
        s.add(tuple(cur))
    print(len(s))
    for x in s:
        print(x)
    #print(s)'''

t=1
for i in range(t):
    n,mod=RL()
    #f(n)
    ma=(n+1)//2
    ifact(n,mod)
    dp=A2(n+1,ma+1)
    f=A(n+1)
    f[1]=1
    f[2]=2
    f[3]=4
    for i in range(4,n+1):
        f[i]=f[i-1]*2%mod
    dp[1][1]=1
    dp[2][1]=2
    dp[3][1]=4
    dp[3][2]=2
    for i in range(4,n+1):
        dp[i][1]=f[i]
        for k in range(2,(i+1)//2+1):
            for x in range(1,i-2*k+3):
                #print(k,x)
                dp[i][k]+=dp[i-x-1][k-1]*f[x]%mod*ifa[x]%mod*fact(i-k+1,mod)%mod*ifa[i-k-x+1]%mod
                dp[i][k]%=mod
    ans=0
    for k in range(1,ma+1):
        ans=(ans+dp[n][k])%mod
    print(ans)
   

        



                 
    
    
''' 
sys.setrecursionlimit(200000)
import threading
threading.stack_size(10**8)
t=threading.Thr
ead(target=main)
t.start()
t.join()
'''

",cubic,"combinatorics,dp,math",10440
"fac = [1] * 500
finv = [1] * 500
p2 = [1] * 500

n, MOD = map(int, input().split())

for i in range(len(fac) - 1):
    fac[i + 1] = fac[i] * (i + 1) % MOD
    finv[i + 1] = pow(fac[i + 1], MOD - 2, MOD)
    p2[i + 1] = p2[i] * 2 % MOD

ans = 0
dp = [[0] * (n // 2 + 2) for _ in range(n + 2)]
dp[0][0] = 1
for i in range(n):
    for j in range(i + 2, n + 2):
        for k in range(n // 2 + 1):
            dp[j][k + 1] += dp[i][k] % MOD * finv[j - i - 1] * p2[j - i - 2]
ans = 0
for i in range(1, n // 2 + 2):
    ans += dp[n + 1][i] * fac[n - i + 1]
print(ans % MOD)",cubic,"combinatorics,dp,math",567
"class Combination:
    def __init__(self, n, MOD):
        self.f = [1]
        for i in range(1, n + 1):
            self.f.append(self.f[-1] * i % MOD)
        self.inv_f = [0] * (n + 1)
        self.inv_f[n] = pow(self.f[n], MOD - 2, MOD)
        for i in reversed(range(n)):
            self.inv_f[i] = self.inv_f[i + 1] * (i + 1) % MOD
        self.MOD = MOD

    def inv(self, k):
        """"""get inverse(k)""""""
        return (self.inv_f[k] * self.f[k - 1]) % self.MOD

    def fact(self, k):
        """"""get k!""""""
        return self.f[k]

    def inv_fact(self, k):
        """"""get inverse(k!)""""""
        return self.inv_f[k]

    def perm(self, k, r):
        """"""get kPr""""""
        if k < r:
            return 0
        return (self.f[k] * self.inv_f[k - r]) % self.MOD

    def comb(self, k, r):
        """"""get kCr""""""
        if k < r:
            return 0
        return (self.f[k] * self.inv_f[k - r] * self.inv_f[r]) % self.MOD


def combination(k, r, MOD):
    """"""kCr O(r)""""""
    if k < r:
        return 0
    r = min(r, k - r)
    numer, denom = 1, 1
    for l in range(r):
        numer *= (k - l)
        numer %= MOD
        denom *= l + 1
        denom %= MOD
    return numer * pow(denom, MOD - 2, MOD) % MOD


import sys
input = sys.stdin.buffer.readline


n, MOD = map(int, input().split())
comb = Combination(10 ** 5, MOD)


dp = [[0] * (n + 1) for i in range(n + 1)]
dp[0][0] = 1
for i in range(1, n + 1):
    dp[i][i] = pow(2, (i - 1), MOD)

pows = [pow(2, i, MOD) for i in range(n + 10)]

for i in range(n + 1):
    for times in range(max(i // 2, 1), i + 1):
        for length in range(1, times + 1):
            nokori = times - length
            ptn = pows[length - 1]
            ptn *= comb.fact(times) * comb.inv_fact(nokori) * comb.inv_fact(length)
            if i - length == 1:
                continue
            dp[i][times] += ptn * dp[i - length - 1][nokori]
            dp[i][times] %= MOD

print(sum(dp[-1]) % MOD)",cubic,"combinatorics,dp,math",1957
"N, M = map(int, input().split())

fac = [1] + [0] * N
for i in range(1, N + 1):
    fac[i] = fac[i - 1] * i % M
fac_inv = [0] * N + [pow(fac[N], M - 2, M)]
for i in range(N, 0, -1):
    fac_inv[i - 1] = fac_inv[i] * i % M
pow2 = [1] + [0] * N
for i in range(N):
    pow2[i + 1] = pow2[i] * 2 % M

DP = [[0] * N for _ in range(N + 2)]
DP[0][0] = 1
for i in range(N):
    for j in range(N):
        DP[i][j] %= M
        if DP[i][j]:
            for k in range(i + 2, N + 2):
                DP[k][j + 1] += DP[i][j] * fac_inv[k - i - 1] % M * pow2[k - i - 2] % M
ans = 0
for j in range(N):
    DP[N + 1][j] %= M
    if DP[N + 1][j]:
        ans += DP[N + 1][j] * fac[N - j + 1] % M
print(ans % M)
",cubic,"combinatorics,dp,math",696
"#!/usr/bin/python3
import sys
input = sys.stdin.readline
n, m = map(int, input().split())

MOD = m
MAX_N = 10**3

# Construct factorial table
fac = [1] + [0] * MAX_N
for i in range(1, MAX_N+1):
    fac[i] = fac[i-1] * (i) % MOD

fac_inv = [1] + [0] * MAX_N
# Femrmat's little theorem says a**(p-1) mod p == 1
# then, a * a**(p-2) mod p == 1
# it means that a**(p-2) is the inverse element
# Here, Get 1 / n! first
fac_inv[MAX_N] = pow(fac[MAX_N], MOD-2, MOD)
for i in range(MAX_N, 1, -1):
    fac_inv[i-1] = fac_inv[i] * i % MOD

def mod_nCr(n, r):
    if n < r or n < 0 or r < 0:
        return 0
    tmp = fac_inv[n-r] * fac_inv[r] % MOD
    return tmp * fac[n] % MOD

pow2 = [0] * (n+1)
pow2[0] = 1
for i in range(1, n+1):
    pow2[i] = pow2[i-1] * 2 % MOD

table = [[0] * 500 for _ in range(500)]
for i in range(500):
    for j in range(i+1):
        table[i][j] = mod_nCr(i, j)

# dp[i-th][j used]
dp = [[0] * (n+1) for _ in range(n)]
for i in range(n):
    dp[i][i+1] = pow2[i]
for i in range(n-1):
    for j in range(i // 2 + 1, n-1):
        if dp[i][j] == 0:
            continue
        dp[i][j] %= MOD
        for k in range(1, n-j):
            if i + k + 1 >= n:
                break
            # create new
            dp[i+k+1][j+k] += dp[i][j] * pow2[k-1] * table[k + j][k]

ans = sum(dp[-1]) % MOD
print(ans)",cubic,"combinatorics,dp,math",1327
"from math import factorial
n, mod = map(int, input().split())
def binom(n, m):    return factorial(n) // factorial(m) // factorial(n-m)
def foo(x, k):
    ans = 0
    for i in range(k, 0, -1):sign = 1 if (i-k)%2 == 0 else -1;ans += sign * binom(k, i) * (i**x);ans %= mod
    return ans
def f(x, k):    return (foo(x, k) * pow(2, x-k, mod)) % mod
ans = 0
for i in range((n+1)//2):ans = (ans + f(n-i, i+1));ans %= mod
print(ans)",cubic,"combinatorics,dp,math",426
"N = 405
n, m = map(int, input().split())
dp = [[0]*N for _ in range(N)]
c = [[1]*N for _ in range(N)]
p = [0]*N


p[0] = 1
for i in range(1, N):
    p[i] = (p[i-1]*2) % m
for i in range(1, N):
    for j in range(1, i):
        c[i][j] = (c[i-1][j-1] + c[i-1][j]) % m


dp[0][0] = 1
for i in range(2, n+2):
    for x in range(1, (n-1)//2 + 2):
        for k in range(1, i):
            dp[i][x] = (dp[i][x] + ((dp[i-k-1][x-1]*p[k-1]) % m) * c[i-x][k]) % m
ans = 0
for i in range(1, (n-1)//2 + 2):
    ans = (ans + dp[n+1][i]) % m
print(ans)",cubic,"combinatorics,dp,math",539
"n, mod = map(int, input().split())

le = 500


def pow(x, y):  # x**y の mod を返す。modは素数でなくてもよい。
    ans = 1
    while y > 0:
        if y % 2 == 1:
            ans = (ans * x) % mod
        x = (x**2) % mod
        y //= 2
    return ans


def inv(x):  # x の mod での逆元を返す。modが素数で、xとmodが互いに素である必要あり。
    return pow(x, mod-2)


M = [1]  # i!のmod
mul = 1
for i in range(1, le):
    mul = (mul * i) % mod
    M.append(mul)

L0 = n//2+3
L1 = n+1

D = [[0 for i in range(L1)] for j in range(L0)]
# D[区間数][直近の区間の長さ] = 通り数
ND = [[0 for i in range(L1)] for j in range(L0)]

INVS = [0] + [inv(i) for i in range(1, n+1)]

D[1][1] = 1
for z in range(2, n+1):  # 全部のパソコン数

    l0 = z//2+3
    l1 = z+1

    for i in range(l0):
        for j in range(l1):
            ND[i][j] = 0

    for i in range(l0):
        if i >= 1:
            ND[i][1] += D[i-1][0] * (z-(i-1))
            ND[i][1] %= mod
            # print(i, 1, ND[i][1], (z-(i-1)))

    for i in range(l0):
        for j in range(1, n+1):
            ND[i][0] += D[i][j]
            ND[i][0] %= mod

    for i in range(l0):
        for j in range(l1):
            if j >= 2:
                p = D[i][j-1]
                p *= (z-(i-1))
                p %= mod
                p *= INVS[j] * 2
                p %= mod
                ND[i][j] += p
                ND[i][j] %= mod

    for i in range(l0):
        for j in range(l1):
            D[i][j] = ND[i][j]
    # D = ND[:]

    # print(z, D)

ans = 0
for i in range(L0):
    for j in range(1, L1):
        ans += D[i][j]
        ans %= mod
print(ans)
",cubic,"combinatorics,dp,math",1557
"import sys
#import random
#import bisect
from collections import deque
#sys.setrecursionlimit(10**6)
from queue import PriorityQueue
from math import gcd
from math import log
from math import ceil
from math import pi
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
mod = 10**9 + 7

n,mod = il()
N = 406

fact = [1 for i in range (N)]
inver = [1 for i in range (N)]
power2 = [1 for i in range (N)]
ncr = [[1 for i in range (N)] for j in range (N)]
dp = [[0 for i in range (N)] for j in range (N)]

def precom() :

    fact[0] = 1
    inver[0] = 1

    for i in range (1,N) :
        fact[i] = (fact[i-1]*i)%mod
        inver[i] = pow(fact[i],mod-2,mod)

    for i in range (N) :
        for j in range (i+1) :
            ncr[i][j] = (((fact[i]*inver[j])%mod)*inver[i-j])%mod

    for i in range(1,N) :
        power2[i] = (power2[i-1]*2)%mod

precom()

dp[0][0] = 1

for i in range (n) :
    for j in range (i+1) :
        k = 1
        while (k+i <= n) :

            dp[i+k+1][j+k] = (dp[i+k+1][j+k] + ((dp[i][j]*power2[k-1])%mod*ncr[j+k][k])%mod)%mod
            
            k += 1

ans = 0

for i in range (n+1) :
    ans = (ans + dp[n+1][i])%mod

print(ans)

    
",cubic,"combinatorics,dp,math",1507
"import sys
def input(): return sys.stdin.readline().strip()


n, mod = map(int, input().split())

le = 405


def pow(x, y):  # x**y の mod を返す。modは素数でなくてもよい。
    ans = 1
    while y > 0:
        if y % 2 == 1:
            ans = (ans * x) % mod
        x = (x**2) % mod
        y //= 2
    return ans


def inv(x):  # x の mod での逆元を返す。modが素数で、xとmodが互いに素である必要あり。
    return pow(x, mod-2)


M = [1]  # i!のmod
mul = 1
for i in range(1, le):
    mul = (mul * i) % mod
    M.append(mul)

MI = [0] * (le-1) + [inv(M[le-1])]  # i!の逆元
for i in range(le-2, -1, -1):
    MI[i] = MI[i+1] * (i+1) % mod


def C(x, y):  # コンビネーション（組合せ）
    if y < 0 or y > x:
        return 0
    elif x > le:  # O(min(y, x-y))
        y = min(y, x-y)
        ans = 1
        for i in range(x, x-y, -1):
            ans = (ans * i) % mod
        return (ans * MI[y]) % mod
    else:  # O(1)
        ans = M[x]
        ans = (ans * MI[y]) % mod
        return (ans * MI[x-y]) % mod


M2 = [1]
for i in range(n+5):
    M2.append((M2[-1]*2) % mod)

CO = [[0] * (n+5) for i in range(n+5)]
for i in range(n+5):
    for j in range(n+5):
        CO[i][j] = C(i, j)

D = [[0] * (n+1) for i in range(n+2)]
# D[何個目まで見たか][そのうち手動ONの個数] = (見たうちの最右が自動ONである場合のパターン数)

D[0][0] = 1
for i in range(n+2):
    for j in range(i//2, min(n+1, i+1)):
        # print(i, j)
        for k in range(1, min(n+1, n-i+1, n-j+1)):
            # print(i, j, k)
            ind0 = i+k+1
            ind1 = j+k
            if ind0 <= n+1 and ind1 <= n:
                D[ind0][ind1] += D[i][j] * CO[j+k][k] * M2[k-1]
                D[ind0][ind1] %= mod


# print(D)
print(sum(D[-1]) % mod)
",cubic,"combinatorics,dp,math",1624
"""""""
DP
There are 2**(K-1) ways I can turn on a segment of K computers manually only

""""""

N, MOD = map(int,input().split())

dp = []
comps = [0]*(N+1)

ncr = [[1]]
for i in range(420):
    tmp = [1]
    for j in range(i):
        tmp.append((ncr[i][j] + ncr[i][j+1]) % MOD)
    tmp.append(1)
    ncr.append(tmp)

for i in range(N):
    curr = list(comps)
    curr[1] = pow(2,i,MOD)
    for j in range(i - 1):
        m = pow(2,i - j - 2)
        for k in range(N):
            num = j - k + 2
            if num < 0: continue
            mr = (m * ncr[i - j - 1 + num][num]) % MOD
            curr[k + 1] += mr * dp[j][k]
            curr[k + 1] %= MOD
    dp.append(curr)

print(sum(dp[-1]) % MOD)",cubic,"combinatorics,dp,math",698
"import sys
input = sys.stdin.readline

n, mod = map(int, input().split())
fac = [1] + [0] * (n + 1)
inv = [1] + [0] * (n + 1)
C = [[0] * (n + 2) for _ in range(n + 2)]
p2 = [1] + [0] * (n + 1)
for i in range(1, n + 2):
    fac[i] = fac[i - 1] * i % mod
    p2[i] = p2[i - 1] * 2 % mod
inv[-1] = pow(fac[-1], mod - 2, mod)
for i in range(n, 0, -1):
    inv[i] = inv[i + 1] * (i + 1) % mod
for i in range(n + 2):
    for j in range(i + 1):
        C[i][j] = fac[i] * inv[j] % mod * inv[i - j] % mod
dp = [[0] * (n + 2) for _ in range(n + 2)]
dp[0][0] = 1
for i in range(n):
    for j in range(i + 1):
        for k in range(1, n - i + 1):
            dp[i + k + 1][j + k] += dp[i][j] * p2[k - 1] % mod * C[j + k][k] % mod
            dp[i + k + 1][j + k] %= mod
ans = 0
for i in range(n + 1):
    ans = (ans + dp[n + 1][i]) % mod
print(ans)",cubic,"combinatorics,dp,math",838
"N, MOD = map(int, input().split())
dp = [[0]*(N+2) for i in range(N+2)]
dp[0][0] = 1
limit = 1000
frac = [1]*limit
for i in range(2,limit):
    frac[i] = i * frac[i-1]%MOD
fraci = [None]*limit
fraci[-1] = pow(frac[-1], MOD -2, MOD)
for i in range(-2, -limit-1, -1):
    fraci[i] = fraci[i+1] * (limit + i + 1) % MOD
bb = [1, 2]
for i in range(1000):
    bb.append(bb[-1] *2 %MOD)
for ln in range(N+1):
    for cnt in range(ln//2, ln+1):
        for k in range(1, N-ln+1):
            cmb = frac[cnt+k] * (fraci[cnt]*fraci[k]%MOD)%MOD
            dp[ln+k+1][cnt+k] += dp[ln][cnt] * (bb[k-1] * cmb % MOD) %MOD
            dp[ln+k+1][cnt+k] %= MOD
R = 0
for x in dp[N+1][:N+1]:
    R = (R+x)%MOD
print(R)
",cubic,"combinatorics,dp,math",702
"import sys

f = sys.stdin

def line():
    return f.readline().strip().split()

def powers(limit):
    size = limit+1
    p = [1]*size
    for n in range(1,size):
        p[n] = 2*p[n-1] % M
        
    return p

def binomials(limit):
    size = limit+1
    bc = [[0 for k in range(size)] for n in range(size)]
    for n in range(size):
        bc[n][0]=1
    
    for n in range(1,size):
        for k in range(1,n+1):
            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]
            bc[n][k] %= M
    
    return bc

def solve():
    
    dp = [[0 for _ in range(N)] for _ in range(N)]
    dp[0][0]=1
    
    for i in range(1,N):
        for k in range(1,i):
            for j in range(1,i):
                dp[i][j] += BC[j+1][i-k] * dp[k-1][j-1-(i-k-1)] * POW[i-k-1]
                dp[i][j] %= M
        dp[i][i] = POW[i]

    res=0
    for j in range(0,N):
        res = (res + dp[N-1][j]) % M

    return str(res)

T = 1
for test in range(1,T+1):
    N,M = map(int,line())
    
    BC = binomials(N)
    POW = powers(N)
    
    print(solve())
    
f.close()",cubic,"combinatorics,dp,math",1063
"import sys

f = sys.stdin

def line():
    return f.readline().strip().split()

def powers(limit):
    size = limit+1
    p = [1]*size
    for n in range(1,size):
        p[n] = (2*p[n-1]) % M
        
    return p

def binomials(limit):
    size = limit+1
    bc = [[0 for k in range(size)] for n in range(size)]
    for n in range(size):
        bc[n][0]=1
    
    for n in range(1,size):
        for k in range(1,n+1):
            bc[n][k] = bc[n-1][k-1] + bc[n-1][k]
            bc[n][k] %= M
    
    return bc

def solve():
    
#     dp = [[0 for _ in range(N)] for _ in range(N)]
#     dp[0][0]=1
#     
#     for i in range(1,N):
#         for k in range(1,i):
#             for j in range(1,i):
#                 dp[i][j] += BC[j+1][i-k] * dp[k-1][j-1-(i-k-1)] * POW[i-k-1]
#                 dp[i][j] %= M
#         dp[i][i] = POW[i]

    size = N+1
    dp = [[0 for _ in range(size)] for _ in range(size)]
    dp[1][0]=1
    
    for i in range(2,size):
        for k in range(1,i):
            for j in range(1,k):
                dp[i][j] += BC[i-j][k-j] * dp[k-1][j-1] * POW[i-k-1]
                dp[i][j] %= M
        dp[i][0] = POW[i-1]

    res=0
    for j in range(0,N-1):
        res = (res + dp[N][j]) % M

    return str(res)

T = 1
for test in range(1,T+1):
    N,M = map(int,line())
    
    BC = binomials(N)
    POW = powers(N)
    
    print(solve())
    
f.close()",cubic,"combinatorics,dp,math",1393
"
inp = input().split()
totNums, mod = int(inp[0]), int(inp[1])

def Exp(b,exp):
	if exp==0: return 1
	temp = Exp(b,exp>>1)**2
	if exp%2==1: temp*=b
	return temp%mod


#main
n = 410


#Precompute
fact, inv = [0 for i in range(n)],[0 for i in range(n)]
fact[0] = inv[0] = 1;
for i in range(1,totNums+1):
	fact[i] = fact[i-1]*i%mod
	inv[i] = Exp(fact[i],mod-2)

dp, choose = [[0 for i in range(n)] for j in range(n)], [[0 for i in range(n)] for j in range(n)]
for i in range(0,totNums+1):
	for j in range(0,i+1):
		choose[i][j] = fact[i]*inv[j]*inv[i-j]%mod
pow2 = [Exp(2,i) for i in range(n)]

#dp
dp[0][0] = 1
for i in range(totNums):
	for j in range(i+1):
		for k in range(1,totNums-i+1):
			dp[i+k+1][j+k] += dp[i][j]*pow2[k-1]*choose[j+k][k]
			dp[i+k+1][j+k] %= mod

ans = 0
for i in range(0,totNums+1):
	ans = (ans+dp[totNums+1][i])%mod
print(ans)",cubic,"combinatorics,dp,math",851
"import string
from collections import deque, Counter
from functools import lru_cache
import math

DEBUG = 0

def main():
    # @lru_cache(400*2*2)
    # def search(n, l_on, r_on):
    #     nonlocal M
    #     if n == 0: return 1
    #     if l_on and r_on and n == 1: return 1
    #     if n == 1: return 1
    #     if r_on and not l_on: return search(n, r_on, l_on)

    #     total = 0
    #     for i in range(n):
    #         total += search(n=i, l_on=l_on, r_on=True) * search(n=n-i-1, l_on=True, r_on=r_on) * comb(n-1, i) % M
    #     # print(l_on,  n, r_on, '=>', total)
    #     return total



    T = 1
    while T:
        n, M = Input.read_typed(int)
        N = n


        f = [[0 for _ in range(n+1)] for _ in range(n+1)]
        comb = [[0 for _ in range(n+1)] for _ in range(n+1)]
        fact = [0] * (n+1)
        inv = [0] * (n+1)
        fact[0] = inv[0] = 1

        for i in range(1, n+1):
            fact[i] = (fact[i-1] * i) % M
            inv[i] = pow(fact[i], M-2, M)

        for i in range(0, n+1):
            for j in range(0, i+1):
                # comb[i][j] = fact[i]//(fact[j] * fact[i-j]) % M;
                comb[i][j] = ((fact[i] * inv[j]) % M * inv[i-j]) % M
                # print(i, j, '=>', math.comb(i, j) %M, comb[i][j])
                # assert math.comb(i, j) % M == comb[i][j]

        pow2 = [0] * (n+1)
        pow2[0] = 1
        for i in range(1, n+1):
            pow2[i] = pow2[i-1]*2 % M 
            f[i][i] = pow2[i-1]

        for total in range(1, n+1):
            for manual in range(1, total):
                if total > manual * 2 or total < manual: continue
                for l in range(1, manual):
                    f[total][manual] += f[total-l-1][manual-l] * pow2[l-1] * comb[manual][l]
                    # f[total][manual] += f[total-l-1][manual-l] * pow(2, l-1, mod=M) * math.comb(manual, l)
                    f[total][manual] %= M

        c = 0
        for i in range(1, n+1):
            c += f[n][i]
            # print(n, i)
            # print(f[n][i])
        print(c % M)
        T -= 1 


# Helper classes
class Input:
    def __init__(self):
        pass

    @staticmethod
    def read_typed(cls):
        return list(map(cls, input().split()))

    @staticmethod
    def read():
        return input()

class Debug():
    def __init__(self):
        import sys
        sys.stdout = open('output.out', 'w')
        sys.stdin = open('input.in', 'r')

    def __delete__(self):
        sys.stdout.close()
        sys.stdin.close()

def run():
    if DEBUG: _ = Debug()
    main()

run()
",cubic,"combinatorics,dp,math",2583
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase
from array import array

def main():
    n,M = map(int,input().split())
    comb = [[0]*(n+1) for _ in range(n+1)]
    comb[0][0] = 1
    for i in range(1,n+1):
        for j in range(i+1):
            comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%M

    dp = [array('i',[0]*(n+1)) for _ in range(n+1)]
    # number of partitions ; number of computer
    for i in range(1,n+1):
        dp[i][0] = pow(2,i-1,M)
    for j in range(1,n+1):
        for i in range(3,n+1):
            for x in range(1,i-1):
                dp[i][j] = (dp[i][j]+dp[i-1-x][j-1]*dp[x][0]*comb[i-j][x])%M
    su = 0
    for i in range(n+1):
        su = (su+dp[n][i])%M
    print(su)

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",cubic,"combinatorics,dp,math",2436
"n, M = map(int,input().split())


combdic = {}

def fastfrac(a,b,M):
    numb = pow(b,M-2,M)
    return ((a%M)*(numb%M))%M



def comb(p,q):
    if p==1: return q
    if (p,q) in combdic: return combdic[(p,q)]
    output = (comb(p-1,q-1)*q)%M
    output = fastfrac(output,p,M)
    combdic[(p,q)] = output
    return output





def getnext(i,j,dic):
    if 2*j+1>i: return 0
    if (i,j) in dic: return dic[(i,j)]

    if j==0:  
        dic[(i,j)] = (1<<(i-1))%M
        return dic[(i,j)]

 
    output = 0
    for k in range(2,i):
        if 2*j-1>i-k: break
#        print(getnext(i-k,j-1,dic), 1<<(k-2))
        output += (getnext(i-k,j-1,dic)*getnext(k-1,0,dic))%M*comb(k-1,i-j)
        output = output%M


    dic[(i,j)] = output

    return output

    
        
dic = {}
ans = 0

dp = [[0 for j in range(n//2+3)] for i in range(n+1)]

for i in range(1,n+1):
    dp[i][0] = (1<<(i-1))%M
    for j in range(1,n+1):
        if 2*j+1>i: break
        
        for k in range(2,i):
            if 2*j-1>i-k: break
            dp[i][j] +=  ((dp[i-k][j-1] * dp[k-1][0])%M * comb(k-1,i-j))%M
            dp[i][j] = dp[i][j]%M
        
ans = 0
for j in range(n):
    if 2*j+1>i: break

    ans += dp[n][j]
    ans = ans%M



print(ans)

",cubic,"combinatorics,dp,math",1236
"n, m, k = map(int, input().split())
reb1 = [list(map(int, input().split())) for i in range(n)]
reb2 = [list(map(int, input().split())) for i in range(n - 1)]
if k % 2:
    for i in range(n):
        for j in range(m):
            print(-1, end="" "")
        print()
    exit(0)
minsum = [[0] * m for i in range(n)]
nminsum = [[0] * m for i in range(n)]
for it in range(k // 2):
    for i in range(n):
        for j in range(m):
            cmin = 1000000000010
            if i != 0:
                cmin = min(cmin, minsum[i - 1][j] + reb2[i - 1][j])
            if i != n - 1:
                cmin = min(cmin, minsum[i + 1][j] + reb2[i][j])
            if j != 0:
                cmin = min(cmin, minsum[i][j - 1] + reb1[i][j - 1])
            if j != m - 1:
                cmin = min(cmin, minsum[i][j + 1] + reb1[i][j])
            nminsum[i][j] = cmin
    for i in range(n):
        for j in range(m):
            minsum[i][j] = nminsum[i][j]
for i in minsum:
    for j in i:
        print(j * 2, end="" "")
    print()
            
",cubic,"dp,graphs,shortest paths",1036
"import sys
input = lambda: sys.stdin.readline().rstrip()

N, M, K = map(int, input().split())
if K % 2:
    for _ in range(N):
        print(*[-1] * M)
    exit()
A = [[int(a) for a in input().split()] for _ in range(N)]
B = [[int(a) for a in input().split()] for _ in range(N-1)]
X = [[0] * M for _ in range(N)]
inf = 1 << 30
for k in range(1, K // 2 + 1):
    nX = [[inf] * M for _ in range(N)]
    for i in range(N):
        for j in range(M):
            if i: nX[i][j] = min(nX[i][j], X[i-1][j] + B[i-1][j])
            if i < N - 1: nX[i][j] = min(nX[i][j], X[i+1][j] + B[i][j])
            if j: nX[i][j] = min(nX[i][j], X[i][j-1] + A[i][j-1])
            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j+1] + A[i][j])
    X = nX
for x in X:
    print(*[a * 2 for a in x])


",cubic,"dp,graphs,shortest paths",779
"from sys import stdin, stdout
from collections import defaultdict

n, m, k = map(int, stdin.readline().split())

dic = defaultdict(lambda : {})
for i in range(n):
    line = tuple(map(int, stdin.readline().split()))
    for j in range(m-1):
        dic[i*m+j][i*m+j+1] = line[j]*2
        dic[i*m+j+1][i*m+j] = line[j]*2

for i in range(n-1):
    line = tuple(map(int, stdin.readline().split()))
    for j in range(m):
        dic[i*m+j][(i+1)*m+j] = line[j]*2
        dic[(i+1)*m+j][i*m+j] = line[j]*2

if k % 2 != 0:
    for i in range(n):
        stdout.write(' '.join(('-1',)*m))
        stdout.write('\n')
else:
    prev = []
    di = (1, 0, -1, 0)
    dj = (0, 1, 0, -1)
    for _ in range(n):
        prev.append((0,)*m)

    for _ in range(k//2):
        new = []
        for _ in range(n):
            new.append([100_000_000]*m)

        for num in dic:
            i = num // m
            j = num % m
            for idx in range(4):
                ii = i + di[idx]
                jj = j + dj[idx]
                if not ((0 <= ii < n) and (0 <= jj < m)): continue
                new[ii][jj] = min(new[ii][jj], prev[i][j] + dic[i*m+j][ii*m+jj])

        prev = new
        
    for i in range(n):
        stdout.write(' '.join(map(str, prev[i])))
        stdout.write('\n')
                            
",cubic,"dp,graphs,shortest paths",1318
"
from bisect import bisect,bisect_left

from collections import *
from math import gcd,ceil,sqrt,floor,inf
from heapq import *
from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

#------------------------------------------------------------------------
import os
import sys

from io import BytesIO, IOBase
# region fastio
 
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 

#------------------------------------------------------------------------
def RL(): return map(int, sys.stdin.readline().split())
def RLL(): return list(map(int, sys.stdin.readline().split()))
def N(): return int(input())
def A(n):return [0]*n
def AI(n,x): return [x]*n
def A2(n,m): return [[0]*m for i in range(n)]
def G(n): return [[] for i in range(n)]
def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]
#------------------------------------------------------------------------


from types import GeneratorType
 
 
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
 
    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]
 
def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]
 
def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()
 
def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod
    
def com(i,j,mod=0):
    if i<j: return 0
    if not mod:        
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod
 
def catalan(n):
    return com(2*n,n)//(n+1)
 
def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m
 
def lowbit(n):
    return n&-n
 
class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1
        
    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x
 
    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans

class ST:
    def __init__(self,arr):#n!=0
        n=len(arr)
        mx=n.bit_length()#取不到
        self.st=[[0]*mx for i in range(n)]
        for i in range(n):
            self.st[i][0]=arr[i]
        for j in range(1,mx):
            for i in range(n-(1<<j)+1):
                self.st[i][j]=max(self.st[i][j-1],self.st[i+(1<<j-1)][j-1])
    def query(self,l,r):
        if l>r:return -inf
        s=(r+1-l).bit_length()-1
        return max(self.st[l][s],self.st[r-(1<<s)+1][s])
        
class DSU:#容量+路径压缩
    def __init__(self,n):
        self.c=[-1]*n
 
    def same(self,x,y):
        return self.find(x)==self.find(y)
 
    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]
 
    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True
 
    def size(self,x): return -self.c[self.find(x)]
    
class UFS:#秩+路径
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n
 
    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]
 
    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv
 
def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1) 
    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return flag
 
def dij(s,graph):
    d={}
    d[s]=0
    heap=[(0,s)]
    seen=set()
    while heap:
        dis,u=heappop(heap)
        if u in seen:
            continue
        seen.add(u)
        for v,w in graph[u]:
            if v not in d or d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d

def bell(s,g):#bellman-Ford
    dis=AI(n,inf)
    dis[s]=0
    for i in range(n-1):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
    change=A(n)
    for i in range(n):
        for u,v,w in edge:
            if dis[v]>dis[u]+w:
                dis[v]=dis[u]+w
                change[v]=1
    return dis

def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)

def RP(nums):#逆序对
    n = len(nums)
    s=set(nums)
    d={}
    for i,k in enumerate(sorted(s),1):
        d[k]=i
    bi=BIT([0]*(len(s)+1))
    ans=0
    for i in range(n-1,-1,-1):
        ans+=bi.query(d[nums[i]]-1)
        bi.update(d[nums[i]],1)
    return ans
 
class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j,n,m):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(1,n+1):
        if ind[i]==0:
            q.append(i)
            res.append(i)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v)
    return res

@bootstrap
def gdfs(r,p):
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None


    

t=1
for i in range(t):
    n,m,k=RL()
    h=[]
    v=[]
    for i in range(n):
        h.append(RLL())
    for i in range(n-1):
        v.append(RLL())
    if k&1:
        for i in range(n):
            print(*AI(m,-1))
        exit()
    k//=2
    dp=[[[inf]*m for i in range(n)]for j in range(k+1)]
    for i in range(n):
        for j in range(m):
            dp[0][i][j]=0
    for i in range(1,k+1):
        for j in range(n):
            for a in range(m):
                if j:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j-1][a]+2*v[j-1][a])
                if j+1<n:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j+1][a]+2*v[j][a])
                if a:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a-1]+2*h[j][a-1])
                if a+1<m:
                    dp[i][j][a]=min(dp[i][j][a],dp[i-1][j][a+1]+2*h[j][a])
    for i in range(n):
        res=[]
        for j in range(m):
            res.append(dp[k][i][j])
        print(*res)
    #print(ans)


    
''' 
sys.setrecursionlimit(200000)
import threading
threading.stack_size(10**8)
t=threading.Thr
ead(target=main)
t.start()
t.join()
'''

",cubic,"dp,graphs,shortest paths",9474
"import sys, os

if os.environ['USERNAME']=='kissz':
    inp=open('in.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=sys.stdin.readline    
    def debug(*args):
        pass

# SCRIPT STARTS HERE

n,m,k=map(int,inp().split())
A=[[*map(int,inp().split())] for _ in range(n)]
B=[[*map(int,inp().split())] for _ in range(n-1)]
if k%2==0:
    O=[[[1e12]*m for _ in range(n)] for _ in range(k//2)]
    for i in range(n):
        for j in range(m):
            if i>0:
                O[0][i][j]=min(O[0][i][j],B[i-1][j])
            if i<n-1:
                O[0][i][j]=min(O[0][i][j],B[i][j])
            if j>0:
                O[0][i][j]=min(O[0][i][j],A[i][j-1])
            if j<m-1:
                O[0][i][j]=min(O[0][i][j],A[i][j])
    #for i in range(n):
    #    debug(*O[0][i])
    for l in range(1,k//2):
        for i in range(n):
            for j in range(m):
                if i>0:
                    O[l][i][j]=min(O[l][i][j],B[i-1][j]+O[l-1][i-1][j])
                if i<n-1:
                    O[l][i][j]=min(O[l][i][j],B[i][j]+O[l-1][i+1][j])
                if j>0:
                    O[l][i][j]=min(O[l][i][j],A[i][j-1]+O[l-1][i][j-1])
                if j<m-1:
                    O[l][i][j]=min(O[l][i][j],A[i][j]+O[l-1][i][j+1])         
                
        #for i in range(n):
        #    debug(*O[l][i])
    for i in range(n):
        print(*[O[-1][i][j]*2 for j in range(m)])
else:
    for i in range(n):
        print(*[-1]*m)
    

",cubic,"dp,graphs,shortest paths",1513
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(10)] 
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n): 
          
        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p): 
                pp[i]+=1
                prime[i] = False
        p += 1
#---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=0
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid][0] > key):
            right = mid-1
        else:
            res=mid
            left = mid + 1
    return res
#---------------------------------running code------------------------------------------
n,m,k=map(int,input().split())
r=[]
for i in range (n):
    a=list(map(int,input().split()))
    r.append(a)
c=[]
for i in range (n-1):
    a=list(map(int,input().split()))
    c.append(a)
if k%2:
    a=[-1]*m
    for i in range (n):
        print(*a)
    sys.exit(0)
dp=[[[0 for i in range ((k//2)+1)]for j in range (m)]for p in range (n)]
for x in range (1,(k//2)+1):
    for i in range (n):
        for j in range (m):
            mn=10**8
            if i>0:
                mn=min(mn,c[i-1][j]+dp[i-1][j][x-1])
            if j>0:
                mn=min(mn,r[i][j-1]+dp[i][j-1][x-1])
            if i<n-1:
                mn=min(mn,c[i][j]+dp[i+1][j][x-1])
            if j<m-1:
                mn=min(mn,r[i][j]+dp[i][j+1][x-1])
            dp[i][j][x]=mn
for i in range (n):
    for j in range (m):
        print(2*dp[i][j][k//2],end=' ')
    print()",cubic,"dp,graphs,shortest paths",9360
"from sys import stdin
input=stdin.readline
n,m,k=map(int,input().split())
lr=[list(map(int,input().split())) for i in range(n)] # (i,j),(i,j+1)
ud=[list(map(int,input().split())) for i in range(n-1)] # (i,j),(i+1,j)
if k%2:
  arr=[-1]*m
  for i in range(n):
    print(*arr)
  exit()
kk=k//2
dp=[[[10**10]*(kk+1) for i in range(m)] for j in range(n)]
for i in range(n):
  for j in range(m):
    dp[i][j][0]=0
for z in range(1,kk+1):
  for i in range(n):
    for j in range(m):
      if i>0:
        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-1]+ud[i-1][j])
      if i<n-1:
        dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-1]+ud[i][j])
      if j>0:
        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-1]+lr[i][j-1])
      if j<m-1:
        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-1]+lr[i][j])
ans=[[dp[i][j][kk]*2 for j in range(m)] for i in range(n)]
for i in range(n):
  print(*ans[i])",cubic,"dp,graphs,shortest paths",882
"# template begins
#####################################
from io import BytesIO, IOBase
import sys
import math
import os
from collections import defaultdict
from math import ceil
from bisect import bisect_left, bisect_left


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
def mint(): return map(int, input().split())
def mfloat(): return map(float, input().split())


#####################################
# template ends
# Use the recursion snippet if heavy recursion is needed (depth>1000)
def solve():
    n, m, k = mint()
    horizontal = [list(mint()) for i in range(n)]
    vertical = [list(mint()) for i in range(n-1)]
    if k%2 or max(n, m)==1:
        for i in range(n):
            print(*[-1]*m)
        return
    """"""
    does it make sense to double back on a path if k is large enough?
    or are there cases when you need to make a loop?

    proof:
    if you have a path of length k that does not visit any edge more than once,
    we can split it into 2 paths of length k/2
    if one of them was cheaper than the other, we should have just back tracked on that
    hence, both must be the same
    in that case, you can just double any one

    should ideally double back on the same path if k is big enough
    just find the cheapest path of length k/2 and double it?

    how do you find the cheapest path of length k/2?

    dp?
    store the cheapest path of length x from every node,
    where x will be from 1 to k/2
    yeah should work
    dp[i][j][x] represents the cheapest path of length from g[i][j] of length x
    """"""
    dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
    for length in range(1, k//2+1):
        for i in range(n):
            for j in range(m):
                """"""
                we want cost_to_neighbour + dp[neigbour][length-1] to be min
                """"""
                left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
                right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
                top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
                bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
                dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k//2]*2, end=' ')
        print()

    

def main():
    # t = int(input())
    t = 1
    for _ in range(t):
        solve()


if __name__ == ""__main__"":
    main()
",cubic,"dp,graphs,shortest paths",4136
"from sys import stdin
input=stdin.readline
rn=lambda:int(input())
rns=lambda:map(int,input().split())
rl=lambda:list(map(int,input().split()))
rs=lambda:input()
YN=lambda x:print('YES') if x else print('NO')
mod=10**9+7

n,m,k=rns()
rows=[rl() for i in range(n)]
cols=[rl() for i in range(n-1)]
def solve():
    if k%2==1:
        return [m*[-1] for i in range(n)]
    dp=[[[0 for i in range(k//2+1)] for j in range(m)] for l in range(n)]
    for i in range(1,k//2+1):
        for a in range(n):
            for b in range(m):
                mins=[]
                if b>0:
                    mins.append(dp[a][b-1][i-1] + 2*rows[a][b-1])
                if b<m-1:
                    mins.append(dp[a][b + 1][i - 1] + 2 * rows[a][b])
                if a>0:
                    mins.append(dp[a-1][b][i - 1] + 2 * cols[a-1][b])
                if a<n-1:
                    mins.append(dp[a+1][b][i - 1] + 2 * cols[a][b])
                dp[a][b][i]=min(mins)
    ans=[[dp[i][j][-1] for j in range(m)] for i in range(n)]
    return ans

ans = solve()
for i in ans:
    print(*i)",cubic,"dp,graphs,shortest paths",1081
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
YOKO=[list(map(int,input().split())) for i in range(n)]
TATE=[list(map(int,input().split())) for i in range(n-1)]

if k%2==1:
    for i in range(n):
        print(*[-1]*m)
    exit()

DP=[[0]*m for i in range(n)]

for i in range(n):
    for j in range(m):

        MIN=1<<30

        if j-1>=0:
            MIN=min(MIN,YOKO[i][j-1]*2)
        if j<m-1:
            MIN=min(MIN,YOKO[i][j]*2)

        if i-1>=0:
            MIN=min(MIN,TATE[i-1][j]*2)
        if i<n-1:
            MIN=min(MIN,TATE[i][j]*2)

        DP[i][j]=MIN

DP0=DP[:]
#print(DP)

for tests in range(k//2-1):
    NDP=[[0]*m for i in range(n)]

    for i in range(n):
        for j in range(m):
            MIN=DP[i][j]+DP0[i][j]

            if 0<=i+1<n:
                MIN=min(MIN,TATE[i][j]*2+DP[i+1][j])

            if 0<=i-1<n:
                MIN=min(MIN,TATE[i-1][j]*2+DP[i-1][j])

            if 0<=j+1<m:
                MIN=min(MIN,YOKO[i][j]*2+DP[i][j+1])

            if 0<=j-1<m:
                MIN=min(MIN,YOKO[i][j-1]*2+DP[i][j-1])

            NDP[i][j]=MIN
    DP=NDP

for dp in DP:
    print(*dp)
        

",cubic,"dp,graphs,shortest paths",1168
"import io
import os

from collections import Counter, defaultdict, deque


def solve(N, M, K, right, down):
    if K % 2 == 1:
        return ((""-1 "" * N) + ""\n"") * M

    K //= 2

    inf = float(""inf"")
    R = N
    C = M

    for row in right:
        row.append(inf)
        row.append(inf)
        row.append(inf)
    right.append([inf] * (C + 2))
    right.append([inf] * (C + 2))
    for row in down:
        row.append(inf)
        row.append(inf)
    down.append([inf] * (C + 2))
    down.append([inf] * (C + 2))
    down.append([inf] * (C + 2))

    def right_(r, c):
        return right[r][c - 1]

    def down_(r, c):
        return down[r - 1][c]

    def left(r, c):
        return right[r][c]

    def up(r, c):
        return down[r][c]

    dist = [[inf for i in range(C + 2)] for j in range(R + 2)]
    for r in range(R):
        for c in range(C):
            dist[r][c] = 0
    for k in range(K):
        nextDist = [[inf for i in range(C + 2)] for j in range(R + 2)]
        for r in range(R):
            for c in range(C):
                nextDist[r][c] = min(
                    dist[r][c - 1] + right_(r, c),
                    dist[r][c + 1] + left(r, c),
                    dist[r - 1][c] + down_(r, c),
                    dist[r + 1][c] + up(r, c),
                )
        dist = nextDist
    return ""\n"".join("" "".join(str(2 * dist[r][c]) for c in range(C)) for r in range(R))


DEBUG = False
if DEBUG:
    import random

    random.seed(0)
    for _ in range(1):
        N = 500
        M = 500
        K = 20

        def pack(i, j):
            return i * M + j

        def unpack(ij):
            return divmod(ij, M)

        graph = [[] for i in range(N * M)]

        right = [[random.randint(1, 10 ** 6) for j in range(M - 1)] for i in range(N)]
        down = [[random.randint(1, 10 ** 6) for j in range(M)] for i in range(N - 1)]
        print(""tc"" + str(_))
        ans = solve(N, M, K, right, down)
        # print(ans, ans1)
        # assert ans == ans1

    exit()


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    def pack(i, j):
        return i * M + j

    def unpack(ij):
        return divmod(ij, M)

    N, M, K = [int(x) for x in input().split()]

    right = [[int(x) for x in input().split()] for i in range(N)]
    down = [[int(x) for x in input().split()] for i in range(N - 1)]

    ans = solve(N, M, K, right, down)
    print(ans)
",cubic,"dp,graphs,shortest paths",2444
"from copy import deepcopy
def sol(n,m,k,aa,bb):
    if k&1:
        return [[-1] * m] * n
    ans = [[float('inf')]*(m+2) for _ in range(n+2)]
    k >>= 1
    for i in range(1,n+1):
        for j in range(1,m+1):
            ans[i][j] = min(aa[i][j], aa[i][j-1], bb[i][j], bb[i-1][j])
    for _ in range(k-1):
        oans = deepcopy(ans)
        for i in range(1,n+1):
            for j in range(1,m+1):
                ans[i][j] = min(
                    aa[i][j]+oans[i][j+1],
                    aa[i][j-1]+oans[i][j-1],
                    bb[i][j]+oans[i+1][j],
                    bb[i-1][j]+oans[i-1][j])

    ans = ans[1:-1]
    ans = [x[1:-1] for x in ans]
    ans = [[2*x for x in a] for a in ans]
    return ans

n,m,k = map(int, input().split())
aa = [list(map(int, input().split())) for _ in range(n)]
inf = float('inf')
bb = [list(map(int, input().split())) for _ in range(n-1)]
aa = [[inf, *x, inf] for x in aa]
bb = [[inf, *x, inf] for x in bb]
pad = [inf] * (m+1)
aa = [pad, *aa, pad]
pad = [inf] * (m+2)
bb = [pad, *bb, pad]
ans = sol(n,m,k,aa,bb)
print('\n'.join(' '.join(map(str, a)) for a in ans))
",cubic,"dp,graphs,shortest paths",1121
"import sys
input = sys.stdin.readline
n, m, k = map(int, input().split())
ej = [list(map(int, input().split())) for _ in range(n)]
ei = [list(map(int, input().split())) for _ in range(n - 1)]

if k % 2:
  for _ in range(n): print(*[-1] * m)
  exit(0)
inf = -1
dp = [[inf] * (n * m) for _ in range(k // 2 + 1)]
for t in range(n * m): dp[0][t] = 0
for c in range(k // 2):
  for i in range(n):
    for j in range(m):
      t = i * m + j

      tt = (i + 1) * m + j
      if i + 1 < n and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ei[i][j]): dp[c + 1][tt] = dp[c][t] + ei[i][j]

      tt = i * m + j + 1
      if j + 1 < m and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ej[i][j]): dp[c + 1][tt] = dp[c][t] + ej[i][j]

      tt = (i - 1) * m + j
      if i - 1 >= 0 and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ei[i - 1][j]): dp[c + 1][tt] = dp[c][t] + ei[i - 1][j]

      tt = i * m + j - 1
      if j - 1 >= 0 and (dp[c + 1][tt] == -1 or dp[c + 1][tt] > dp[c][t] + ej[i][j - 1]): dp[c + 1][tt] = dp[c][t] + ej[i][j - 1]

res = [[0] * m for _ in range(n)]
for i in range(n):
  for j in range(m): res[i][j] = dp[-1][i * m + j] * 2
  print(*res[i])
",cubic,"dp,graphs,shortest paths",1170
"import sys
input=sys.stdin.readline
n,m,k=map(int,input().strip().split("" ""))
#s=input().strip()
#n=int(input().strip())
#a=list(map(int,input().strip().split("" "")))
lr=[]
for i in range(n):
	lr.append([100000001]+list(map(int,input().strip().split("" "")))+[100000001])
ud=[[100000001]*m]
for i in range(n-1):
	ud.append(list(map(int,input().strip().split("" ""))))
ud.append([100000001]*m)
o=[[1000000001]*(m+2)]
from copy import deepcopy
if k%2:
	for i in range(n):
		sys.stdout.write("" "".join([""-1""]*m)+""\n"")
	sys.exit()
for _ in range(n):
	oo=[100000001]
	for _ in range(m):
		oo.append(0)
	oo.append(100000001)
	o.append(oo)
o.append([100000001]*(m+2))
for _ in range(k//2):
	oo=deepcopy(o)
	for i in range(1,n+1):
		for j in range(1,m+1):
			oo[i][j]=min(lr[i-1][j-1]+o[i][j-1],lr[i-1][j]+o[i][j+1],ud[i-1][j-1]+o[i-1][j],ud[i][j-1]+o[i+1][j])
	o=deepcopy(oo)
for i in o[1:n+1]:
	sys.stdout.write("" "".join(map(str,[j*2 for j in i[1:m+1]]))+""\n"")
",cubic,"dp,graphs,shortest paths",949
"from collections import defaultdict
import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [list(map(int, input().split())) for _ in range(n - 1)]
if k % 2:
    ans = [-1] * m
    for _ in range(n):
        print(*ans)
    exit()
#G = defaultdict(lambda : 0)
G = [[] for _ in range(n * m + 1)]
for i in range(n):
    a0 = a[i]
    for j in range(m - 1):
        x = a0[j]
        G[i * m + j].append((i * m + j + 1, x))
        G[i * m + j + 1].append((i * m + j, x))
        #G[(i * m + j, i * m + j + 1)] = x
        #G[(i * m + j + 1, i * m + j)] = x
for i in range(n - 1):
    b0 = b[i]
    for j in range(m):
        x = b0[j]
        G[i * m + j].append(((i + 1) * m + j, x))
        G[(i + 1) * m + j].append((i * m + j, x))
        #G[(i * m + j, (i + 1) * m + j)] = x
        #G[((i + 1) * m + j, i * m + j)] = x
dp = [[0] * m for _ in range(n)]
dp0 = [[0] * m for _ in range(n)]
dp, dp0 = [0] * (n * m), [0] * (n * m)
v = [(1, 0), (-1, 0), (0, 1), (0, -1)]
inf = 1145141919
for i in range(n):
    for j in range(m):
        s = i * m + j
        dps = inf
        for t, x in G[s]:
            dps = min(dps, 2 * x)
        dp[s] = dps
        dp0[s] = dps
for _ in range((k - 2) // 2):
    dp1 = [0] * (n * m)
    for i in range(n):
        for j in range(m):
            s = i * m + j
            dps = dp0[s] + 2 * dp[s]
            for t, x in G[s]:
                dps = min(dps, 2 * x + dp0[t])
            dp1[s] = dps
    dp0 = dp1
for i in range(n):
    ans = dp0[(m * i):(m * (i + 1))]
    print(*ans)",cubic,"dp,graphs,shortest paths",1601
"import sys
input = lambda: sys.stdin.readline().rstrip()

def solve():
    n, m, k = map(int, input().split())
    a = []
    b = []
    for i in range(n):
        a.append(list(map(int, input().split())))
    for i in range(n-1):
        b.append(list(map(int, input().split())))
    if k % 2:
        ans = [-1] * m
        for i in range(n):
            print(*ans)
        return 
    k //= 2
    pre = [[0]*m for i in range(n)]
    cur = [[10**9]*m for i in range(n)]
    for _ in range(k):
        cur = [[10**9] * m for i in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    cur[i][j] = min(cur[i][j], pre[i-1][j]+b[i-1][j])
                if i < n - 1:
                    cur[i][j] = min(cur[i][j], pre[i+1][j]+b[i][j])
                if j:
                    cur[i][j] = min(cur[i][j], pre[i][j-1]+a[i][j-1])
                if j < m - 1:
                    cur[i][j] = min(cur[i][j], pre[i][j+1]+a[i][j])
        pre = cur
    for i in range(n):
        cur[i] = [cur[i][j]*2 for j in range(m)]
        print(*cur[i])





solve()

",cubic,"dp,graphs,shortest paths",1107
"input = __import__('sys').stdin.readline

n,m,k = map(int, input().split())
hor = [[int(x) for x in input().split()] for _ in ' ' * n]
ver = [[int(x) for x in input().split()] for _ in ' ' * (n - 1)]

if k % 2:
  for i in ' ' * n: print('-1 ' * m)
  exit()

mtx_old = [[0] * m for _ in ' ' * n]

def neighbours(x, y):
  a = 1e18
  b = 1e18
  c = 1e18
  d = 1e18
  if x > 0: a = hor[y][x - 1] * 2 + mtx_old[y][x - 1]
  if x < m - 1: b = hor[y][x] * 2 + mtx_old[y][x + 1]
  if y > 0: c = ver[y - 1][x] * 2 + mtx_old[y - 1][x]
  if y < n - 1: d = ver[y][x] * 2 + mtx_old[y + 1][x]
  return min(a, b, c, d)

for i in range(k // 2):
  mtx_new = [[0] * m for _ in ' ' * n]

  for x in range(m):
    for y in range(n):
      mtx_new[y][x] = neighbours(x, y)

  mtx_old = mtx_new

for row in mtx_old: print(*row)",cubic,"dp,graphs,shortest paths",804
"n,m,k=list(map(int,input().split()))
p=[]
for _ in range(n):
    p.append(list(map(int,input().split())))
q=[]
for _ in range(n-1):
    q.append(list(map(int,input().split())))
def f(g):
    r=[[0]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            l=[]
            if i-1>=0:
                l.append(g[i-1][j]+q[i-1][j])
            if i+1<n:
                #print(i,j)
                l.append(g[i+1][j]+q[i][j])
            if j-1>=0:
                l.append(g[i][j-1]+p[i][j-1])
            if j+1<m:
                l.append(g[i][j+1]+p[i][j])
            r[i][j]=min(l)
    return r
g=[[0]*m for _ in range(n)]
if k%2!=0:
    for i in range(n):
        for j in range(m):
            g[i][j]=-1
        print(*g[i])
else:
    for _ in range(k//2):
       g=f(g)
    for i in range(n):
        for j in range(m):
            g[i][j]*=2
        print(*g[i])
        ",cubic,"dp,graphs,shortest paths",905
"import sys
n,m,k = map(int,input().split())

if k%2:
    ans = [[-1]*m for _ in range(n)]
    for row in ans:
        print(*row)
    exit()
A = []
B = []
inf = float('inf')
for _ in range(n):
    A.append(list(map(int,input().split())))
for _ in range(n-1):
    B.append(list(map(int,input().split())))

# dp = [[[inf for _ in range(k//2+1)] for _ in range(m)] for _ in range(n)]

# new
dp = [[inf]*m for _ in range(n)]
ans = [[None]*m for _ in range(n)]

for l in range(k//2+1):
    new_dp = [[inf]*m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if l == 0:
                new_dp[i][j] = 0
                continue

            up = B[i-1][j]*2 + dp[i-1][j] if i-1>=0 else inf
            right = A[i][j]*2 + dp[i][j+1] if j+1<m else inf
            left = A[i][j-1]*2 + dp[i][j-1] if j-1>=0 else inf
            down = B[i][j]*2 + dp[i+1][j] if i+1<n else inf

            new_dp[i][j] = min(up,right,left,down)
            if l == k//2:
                ans[i][j] = new_dp[i][j]
    dp = new_dp
for row in ans:
    print(*row)
",cubic,"dp,graphs,shortest paths",1066
"import sys
import math
from itertools import product

n,m,k = [int(i) for i in sys.stdin.readline().split()]

horiz_costs = [[]]*n
vert_costs = [[]]*(n-1)

for i in range(n):
    horiz_costs[i] = [int(i) for i in sys.stdin.readline().split()]
for i in range(n-1):
    vert_costs[i] = [int(i) for i in sys.stdin.readline().split()]

if k%2 == 1:
    for _ in range(n):
        print("" "".join([""-1""]*m))
    quit()

ans = [[[0]*m for _ in range(n)] for _ in range(k//2+1)]

def costs(i,j,ans,time):
    r = []
    if j<m-1:
        r += [2*horiz_costs[i][j] + ans[time-1][i][j+1]]
    if j>0:
        r += [2*horiz_costs[i][j-1] + ans[time-1][i][j-1]]
    if i<n-1:
        r += [2*vert_costs[i][j] + ans[time-1][i+1][j]]
    if i>0:
        r += [2*vert_costs[i-1][j] + ans[time-1][i-1][j]]
    return r

for time in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            cost = costs(i,j,ans, time)
            for c in cost:
                if ans[time][i][j] == 0 or c < ans[time][i][j]:
                    ans[time][i][j] = c

for i in range(n):
    print("" "".join([str(s) for s in ans[-1][i]]))


",cubic,"dp,graphs,shortest paths",1127
"import os
import sys
from io import BytesIO, IOBase


def main():
    n,m,k=map(int,input().split())
    if (k%2==0):
        DP=[[[10**9 for i in range(m)] for j in range(n)] for v in range(k//2)]
        A=[]
        B=[]
        for i in range(n):
            L=list(map(int,input().split()))
            A.append(L)
            for j in range(m-1):
                DP[0][i][j]=min(DP[0][i][j],L[j])
                DP[0][i][j+1]=min(L[j],DP[0][i][j+1])
                
        for i in range(n-1):
            L=list(map(int,input().split()))
            B.append(L)
            for j in range(m):
                DP[0][i][j]=min(DP[0][i][j],L[j])
                DP[0][i+1][j]=min(DP[0][i+1][j],L[j])
    
        for k1 in range(1,k//2):
            for i in range(n):
                for j in range(m):
                    if (i>0):
                        DP[k1][i][j]=min(DP[k1][i][j],B[i-1][j]+DP[k1-1][i-1][j])
                    if (j>0):
                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j-1]+DP[k1-1][i][j-1])
                    if (i<(n-1)):
                        DP[k1][i][j]=min(DP[k1][i][j],B[i][j]+DP[k1-1][i+1][j])
                    if (j<(m-1)):
                        DP[k1][i][j]=min(DP[k1][i][j],A[i][j]+DP[k1-1][i][j+1])
                
        for val in DP[(k//2)-1]:
            ans=[i*2 for i in val]
            print(*ans)
    
    else:
        for i in range(n):
            L=list(map(int,input().split()))
        
        for i in range(n-1):
            L=list(map(int,input().split()))
        
        for i in range(n):
            ans=[-1]*m
            print(*ans)



# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == ""__main__"":
    main()
",cubic,"dp,graphs,shortest paths",3348
"def helper(n,m,k):
    
    if k % 2 == 1:
        res = [[-1] * m for i in range(n)]
        return res
    
    k = k // 2
    
    pool = [[[0]*m for i in range(n)] for j in range(k+1)]
    
    dx = [0,0,1,-1]
    dy = [1,-1,0,0]
    
    for t in range(1,k+1):
        for i in range(n):
            for j in range(m):
                tres = [9999999] * 4
                for c in range(4):
                    if 0 <= i+dx[c] < n and 0 <= j+dy[c] < m:
                        if c == 0:
                            tres[c] = hedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        elif c == 1:
                            tres[c] = hedge[i][j-1]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        elif c == 2:
                            tres[c] = vedge[i][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                        else:
                            tres[c] = vedge[i-1][j]*2 + pool[t-1][i+dx[c]][j+dy[c]]
                pool[t][i][j] = min(tres)
    #print(pool)

    return pool[k]

#t = int(input())
#for i in range(t):
#n = int(input())
n,m,k = map(int,input().split("" ""))
hedge = []
vedge = []
for i in range(n):
    hedge.append(list(map(int,input().split("" ""))))
for i in range(n-1):
    vedge.append(list(map(int,input().split("" ""))))
#a = list(map(int,input().split("" "")))
#print(len(a))
res = helper(n,m,k)
for j in range(len(res)):
    print("" "".join(map(str,res[j])))
#print(res)",cubic,"dp,graphs,shortest paths",1415
"#import sys
#sys.setrecursionlimit(150000)

from collections import deque
from copy import deepcopy


m,n,k  = map(int,input().split())

horizon = []
for i in range(m):
    horizon.append( list(map(int,input().split()))  )
    
vertical = []
for i in range(m-1):
    vertical.append( list(map(int,input().split()))  )


if k%2==1:
    ans = [-1]*n
    for i in range(m):
        print("" "".join(map(str,ans)))
    exit()
        
direc = [[0,-1],[0,1],[1,0],[-1,0]]

ans = [[0 for j in range(n)] for i in range(m)]


for t in range(k//2):
    tempans = deepcopy(ans)
   
    for i in range(m):
        for j in range(n):
            ans[i][j] = 2147483647
            for d in range(4):
                neighi = i + direc[d][0]
                neighj = j + direc[d][1]
                if neighi<0 or neighi>=m or neighj<0 or neighj>=n: continue 
                base = tempans[neighi][neighj] 
                if d==0: base += 2 * horizon[neighi][neighj]
                if d==1: base += 2 * horizon[neighi][neighj-1]
                if d==2: base += 2 * vertical[neighi-1][neighj]
                if d==3: base += 2 * vertical[neighi][neighj]  
                ans[i][j] = min(ans[i][j],base)

#    print(ans)
  



for ele in ans:
    print("" "".join(map(str,ele)))

         
            
                
        

",cubic,"dp,graphs,shortest paths",1317
"import sys
input = sys.stdin.readline


n, m, k = map(int, input().split())
A = [[0] * (m) for _ in range(n)]
B = [[0] * (m) for _ in range(n)]
for i in range(n):
    tmp = list(map(int, input().split()))
    for j in range(m - 1):
        A[i][j + 1] = tmp[j] # + A[i][j]
for i in range(n - 1):
    tmp = list(map(int, input().split()))
    for j in range(m):
        B[i + 1][j] = tmp[j] # + B[i][j]

if k % 2:
    ans = [[-1] * m for _ in range(n)]
    for a in ans:
        print(*a)
    sys.exit()
ans = [[0] * m for _ in range(n)]
lim = k // 2
dp = [[[float(""inf"")] * (lim + 1) for _ in range(m)] for _ in range(n)]
for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for k in range(1, lim + 1):
    for i in range(n):
        for j in range(m):
            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])
            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])
            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])
            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])
for i in range(n):
    for j in range(m):
        ans[i][j] = dp[i][j][-1] * 2
for a in ans:
    print(*a)",cubic,"dp,graphs,shortest paths",1217
"from heapq import heappop, heappush

n, m, k = [int(i) for i in input().split()]
if k % 2 == 1:
    for _ in range(n):
        print("" "".join([""-1""] * m))
    exit()

E_right = []
for i in range(n):
    E_right.append([int(j) for j in input().split()])

E_down = []
for i in range(n - 1):
    E_down.append([int(j) for j in input().split()])

P = [[0 for _ in range(m)] for _ in range(n)]
new_P = [[0 for _ in range(m)] for _ in range(n)]

for k in range(k // 2 + 1):
    for i in range(n):
        for j in range(m):
            possible = []
            if i - 1 >= 0:
                e = E_down[i - 1][j]
                possible.append(P[i - 1][j] + e)

            if i + 1 < n:
                e = E_down[i][j]
                possible.append(P[i + 1][j] + e)

            if j - 1 >= 0:
                e = E_right[i][j - 1]
                possible.append(P[i][j - 1] + e)
            
            if j + 1 < m:
                e = E_right[i][j]
                possible.append(P[i][j + 1] + e)

            new_P[i][j] = min(possible)

    tmp = P
    P = new_P
    new_P = tmp

for i in range(n):
    print("" "".join(str(s * 2) for s in new_P[i]))

            


            

# for i in range(n):
#     ans = []
#     for j in range(m):
#         nodes = [(0, 0, i, j)]

#         while True:
#             l, kk, n_i, n_j = heappop(nodes)
#             if kk == k // 2:
#                 ans.append(l * 2)
#                 break

#             if n_i - 1 >= 0:
#                 e = E_down[n_i - 1][n_j]
#                 heappush(nodes, (l + e, kk + 1, n_i - 1, n_j))

#             if n_i + 1 < n:
#                 e = E_down[n_i][n_j]
#                 heappush(nodes, (l + e, kk + 1, n_i + 1, n_j))

#             if n_j - 1 >= 0:
#                 e = E_right[n_i][n_j - 1]
#                 heappush(nodes, (l + e, kk + 1, n_i, n_j - 1))
            
#             if n_j + 1 < m:
#                 e = E_right[n_i][n_j]
#                 heappush(nodes, (l + e, kk + 1, n_i, n_j + 1))

#     print("" "".join(str(l) for l in ans))




    
     

    ",cubic,"dp,graphs,shortest paths",2070
"def main():
    high = 10 ** 12
    n, m, k = map(int, input().split())
    hozs = []
    for i in range(n):
        hozs.append(list(map(int, input().split())))
    verts = []
    for i in range(n - 1):
        verts.append(list(map(int, input().split())))
    if k % 2:
        for i in range(n):
            print(""-1 "" * m)
        return
    k //= 2
    dp = []
    for i in range(n):
        dp.append([])
        for j in range(m):
            dp[-1].append([])
            for kay in range(k + 1):
                dp[-1][-1].append(0)
    for depth in range(1, k + 1):
        for i in range(n):
            for j in range(m):
                if i == 0:
                    up = high
                else:
                    up = verts[i - 1][j] + dp[i - 1][j][depth - 1]
                if i == n - 1:
                    down = high
                else:
                    down = verts[i][j] + dp[i + 1][j][depth - 1]
                if j == 0:
                    left = high
                else:
                    left = hozs[i][j - 1] + dp[i][j - 1][depth - 1]
                if j == m - 1:
                    right = high
                else:
                    right = hozs[i][j] + dp[i][j + 1][depth - 1]
                min_cost = min(up, down, left, right)
                ''''
                if min_cost == up:
                    dp[i][j][depth] = dp[i - 1][j][depth - 1]
                elif min_cost == down:
                    dp[i][j][depth] = dp[i + 1][j][depth - 1]
                elif min_cost == left:
                    dp[i][j][depth] = dp[i][j - 1][depth - 1]
                else:
                    dp[i][j][depth] = dp[i][j + 1][depth - 1]
                '''
                dp[i][j][depth] += min_cost
    for i in range(n):
        print(*[2 * dp[i][j][k] for j in range(m)])
main()",cubic,"dp,graphs,shortest paths",1834
"# by the authority of GOD     author: manhar singh sachdev #

def some_random_function():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function5():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

import os,sys
from io import BytesIO,IOBase
# from array import array

def main():
    n,m,k = map(int,input().split())
    hor = [list(map(int,input().split()))+[10**20+1] for _ in range(n)]
    ver = [list(map(int,input().split())) for _ in range(n-1)]+[[10**20+1]*m]
    if k&1:
        for _ in range(n):
            print(*[-1]*m)
        exit()
    dp = [[0]*m for _ in range(n)]
    dx,dy = [0,0,1,-1],[1,-1,0,0]
    for _ in range(k//2):
        dp1 = [[10**20]*m for _ in range(n)]
        for i in range(n):
            for j in range(m):
                for kk in range(4):
                    x1,y1 = i+dx[kk],j+dy[kk]
                    if kk < 2:
                        ed = hor[i][j-(kk==1)]
                    else:
                        ed = ver[i-(kk==3)][j]
                    if ed != 10**20+1:
                        dp1[i][j] = min(dp1[i][j],2*ed+dp[x1][y1])
        dp = dp1
    for i in dp:
        print(*i)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def some_random_function1():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function2():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function3():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function4():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function6():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function7():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

def some_random_function8():
    """"""due to the fast IO template, my code gets caught in
       plag check for no reason. That is why, I am making
       random functions""""""
    x = 10
    x *= 100
    i_dont_know = x
    why_am_i_writing_this = x*x
    print(i_dont_know)
    print(why_am_i_writing_this)

if __name__ == '__main__':
    main()",cubic,"dp,graphs,shortest paths",5451
"""""""
ID: happyn61
LANG: PYTHON3
PROB: loan
""""""
from itertools import product
import itertools
#from collections import defaultdict
import sys
import heapq
from collections import deque
MOD=1000000000007
#fin = open ('loan.in', 'r')
#fout = open ('loan.out', 'w')
#print(dic[""4734""])
def find(parent,i):


    if parent[i] != i: 
        parent[i]=find(parent,parent[i]) 
    return parent[i] 

        # A utility function to do union of two subsets 
def union(parent,rank,xx,yy): 
    x=find(parent,xx)
    y=find(parent,yy)
    if rank[x]>rank[y]:
        parent[y]=x
    elif rank[y]>rank[x]:
        parent[x]=y
    else:
        parent[y]=x
        rank[x]+=1
ans=0
#NK=sys.stdin.readline().strip().split()
#K=int(sys.stdin.readline().strip())
#N=int(NK[0])
#K=int(NK[1])
#M=int(NK[2])
#ol=list(map(int,sys.stdin.readline().strip().split()))
#d={0:0,1:0}

x=0
y=0

MAX=1000000000
N,M,K=list(map(int,sys.stdin.readline().strip().split()))
W=[[[MAX,MAX,MAX,MAX] for j in range(M)] for i in range(N)] #L R U D
for i in range(N):
    l=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(M-1):
        W[i][j][1]=l[j]
        W[i][j+1][0]=l[j]
for i in range(N-1):
    l=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(M):
        #print(l,i,j)
        W[i][j][3]=l[j]
        W[i+1][j][2]=l[j]
        
#print(W)
if K%2==1:
    for i in range(N):
        ans=[]
        for j in range(M):
            ans.append(""-1"")
        print("" "".join(ans))
else:
    
    K=K//2
    dp=[[[0 for j in range(M)] for i in range(N)] for k in range(K+1)]
    for kt in range(1,K+1):
        
        dl=((0,-1),(0,1),(-1,0),(1,0))
        for i in range(N):
            for j in range(M):
                ans=MAX
                for t in range(4):
                    
                    ii,jj=dl[t]
                
                    if i+ii>=0 and i+ii<N and j+jj>=0 and j+jj<M:
                        ans=min(ans,dp[kt-1][i+ii][j+jj]+W[i][j][t]*2)
                    #print(i,j,ii,jj,ans)
                dp[kt][i][j]=ans
    #print(dp[-1])
    for i in range(N):
        ans=[]
        for j in range(M):
            ans.append(str(dp[-1][i][j]))
        print("" "".join(ans))

                
",cubic,"dp,graphs,shortest paths",2231
"from math import inf

if True:
    n,m,k = map(int,input().split())
    cosp = [[int(x) for x in input().split()]+[inf] for _ in range(n)]
    cosv = [[int(x) for x in input().split()]for _ in range(n-1)]+[[inf]*m]
    if k%2==1:
        for _ in range(n):
            print(*[-1]*m)
     
    else:    
        dp = [[0]*m for i in range(n)]
        xx,yy = [0,0,1,-1],[1,-1,0,0]
        for _ in range(k//2):
            dp1 = [[inf]*m for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    for kk in range(4):
                        x1,y1 = i+xx[kk],j+yy[kk]
                        if kk < 2:
                            if kk==1:
                                edge = cosp[i][j-1]
                            else:
                                edge=cosp[i][j]
                        else:
                            if kk==3 :
                                edge = cosv[i-1][j]
                            else:
                                edge = cosv[i][j]
                        if edge != inf:
                            dp1[i][j] = min(dp1[i][j],2*edge+dp[x1][y1])
            dp = dp1[:]
        for i in dp:
            print(*i)",cubic,"dp,graphs,shortest paths",1204
"import sys

def ints():
    return map(int, input().split())

n, m, k = ints()
right = []
for i in range(n):
    right.append(list(ints()))
down = []
for i in range(n-1):
    down.append(list(ints()))

INF = int(1e8)

def around(r, c):
    a = []
    for i, j in [[r-1, c], [r, c+1], [r+1, c], [r, c-1]]:
        if not (i < 0 or i >= n or j < 0 or j >= m):
            a.append([i, j])
    return a

def mink(dist, si, sj):
    minn = INF
    for i in range(max(0, si-k//2), min(n, si+k//2+1)):
        for j in range(max(0, sj-k//2), min(m, sj+k//2+1)):
            if dist[i][j] < minn:
                minn = dist[i][j]
    return minn

def solve():
    pdist = [[0] * m for i in range(n)]
    if k & 1:
        return [[-1] * m for i in range(n)]
    for step in range(k//2):
        dist = [[0] * m for i in range(n)]
        for i in range(n):
            for j in range(m):
                adist = []
                for ip, jp in around(i, j):
                    if ip == i:
                        if jp > j:
                            w = right[i][j]
                        else:
                            w = right[i][jp]
                    else:
                        if ip > i:
                            w = down[i][j]
                        else:
                            w = down[ip][j]
                    adist.append(pdist[ip][jp] + w)
                dist[i][j] = min(adist)
        pdist = dist
    for i in range(n):
        for j in range(m):
            pdist[i][j] *= 2
    return pdist

for row in solve():
    print(*row)",cubic,"dp,graphs,shortest paths",1562
"import math
from collections import defaultdict
import os
import sys
from io import BytesIO, IOBase
from types import GeneratorType
from collections import defaultdict
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def process(s):
    b=[]
    for j in s:
        b.append(j)
    return b








#t=int(input())
for _ in range(1):
    #n=int(input())
    n,m,k=map(int,input().split())
    d1=[[float(""inf"") for i in range(m+1)] for j in range(n+1)]
    d2 = [[float(""inf"") for i in range(m+1)] for j in range(n+1)]


    for i in range(n):
        l=list(map(int,input().split()))
        for j in range(m-1):
            d1[i][j]=l[j]

    for i in range(n-1):
        l=list(map(int,input().split()))
        for j in range(m):
            d2[i][j]=l[j]


    if k%2!=0:
        ans=[[-1 for j in range(m)] for i in range(n)]

    else:
        ans = [[float('inf') for j in range(m+1)] for i in range(n+1)]
        for i in range(n):
            for j in range(m):
                ans[i][j]=min(2*d1[i][j],2*d1[i][j-1],2*d2[i-1][j],2*d2[i][j])

        curr=2

        while(curr!=k):
            new = [[float('inf') for j in range(m+1)] for i in range(n+1)]
            for i in range(n):
                for j in range(m):


                    new[i][j] = min(ans[i][j-1]+2 * d1[i][j-1], ans[i][j+1]+2 * d1[i][j], ans[i-1][j]+2*d2[i-1][j], ans[i+1][j]+2 *d2[i][j])

            for i in range(n):
                for j in range(m):
                    ans[i][j] = new[i][j]



            curr+=2


    for i in range(n):
        print(*ans[i][:m])


    #s=input()
    #b=process(s)

",cubic,"dp,graphs,shortest paths",3199
"import io, os, sys

input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

def read():
    n, m, k = map(int, input().split() )    

    h = [list(map(int, input().split() ) )+ [float(""+inf"")] for _ in range(n)]


    v = [list(map(int, input().split() ) ) for _ in range(n-1)]
    v.append( [float(""+inf"")] * m )

    solve(n, m, k, h, v)

def solve(n, m, k, h, v):
    if k % 2:
        ans = ""-1 "" * m
        for _ in range(n):
            print(ans)
        return
    
    #inf = float(""+inf"")

    dp = [ [0] * (m+1) for _ in range(n+1)]

    nxt = [ [0] * (m+1) for  _ in range(n+1)]

    for _ in range(2, k + 1, 2):

        for i in range(n):
            for j in range(m):
                l = 2 * h[i][j-1] + dp[i][j-1]
                r = 2 * h[i][j]  + dp[i][j+1]
                u = 2 * v[i-1][j] + dp[i-1][j]
                d = 2 * v[i][j]  + dp[i+1][j]

                hor = min(l, r)
                ver = min(u, d)

                nxt[i][j] = min(hor, ver)

        dp, nxt = nxt, dp

    for l in dp[:-1]:
        print("" "".join(map(str, l[:-1])))




if __name__ == ""__main__"":
    read()",cubic,"dp,graphs,shortest paths",1118
"import os,io
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
n,m,k=map(int,input().split())
dist1=[]
for i in range(n):
  dist1.append(list(map(int,input().split())))
dist2=[]
for i in range(n-1):
  dist2.append(list(map(int,input().split())))
if k%2:
  print(' '.join(map(str,[-1]*(n*m))))
  exit()
k//=2
dp=[10**9]*((k+1)*n*m)
for i in range(n):
  for j in range(m):
    dp[i*m+j]=0
for t in range(k):
  r=(t+1)*n*m
  q=t*n*m
  for i in range(n):
    for j in range(m):
      if i<n-1:
        dp[r+(i+1)*m+j]=min(dp[r+(i+1)*m+j],dp[q+i*m+j]+2*dist2[i][j])
      if i>0:
        dp[r+(i-1)*m+j]=min(dp[r+(i-1)*m+j],dp[q+i*m+j]+2*dist2[i-1][j])
      if j<m-1:
        dp[r+i*m+j+1]=min(dp[r+i*m+j+1],dp[q+i*m+j]+2*dist1[i][j])
      if j>0:
        dp[r+i*m+j-1]=min(dp[r+i*m+j-1],dp[q+i*m+j]+2*dist1[i][j-1])
ans=[]
for i in range(n):
  for j in range(m):
    ans.append(dp[k*n*m+i*m+j])
print(' '.join(map(str,ans)))",cubic,"dp,graphs,shortest paths",930
"I=lambda:[*map(int,input().split())]
R=range;m=min;N,M,K=I();r=R(N)
if K&1:
	for _ in r:print(*[-1]*M)
	exit()
A=[I()for _ in r]
B=[I()for _ in R(N-1)]
X=[M*[0]for _ in r]
for k in R(1,K//2+1):
	Y=[M*[9**9]for _ in r]
	for i in r:
		for j in R(M):
			if i:Y[i][j]=X[i-1][j]+2*B[i-1][j]
			if i<N-1:Y[i][j]=m(Y[i][j],X[i+1][j]+2*B[i][j])
			if j:Y[i][j]=m(Y[i][j],X[i][j-1]+2*A[i][j-1])
			if j<M-1:Y[i][j]=m(Y[i][j],X[i][j+1]+2*A[i][j])
	X=Y
for x in X:print(*x)",cubic,"dp,graphs,shortest paths",462
"# Author : nitish420 --------------------------------------------------------------------
import os
import sys
from io import BytesIO, IOBase
# mod=10**9+7
# sys.setrecursionlimit(10**5)
mxm=sys.maxsize

def solve(p,q,r):

    if p<0 or p>=n or q<0 or q>=m:
        return mxm

    if dp[r][p][q]!=-1:
        return dp[r][p][q]


    if r==0:
        return 0

    z=int()
    a,b,c,d=0,0,0,0
    a=dp[r-1][p][q-1]
    b=dp[r-1][p][q+1]
    c=dp[r-1][p-1][q]
    d=dp[r-1][p+1][q]

    if a==-1:
        a=row[p][q-1]+solve(p,q-1,r-1)
    else:
        a+=row[p][q-1]

    if b==-1:
        b=row[p][q]+solve(p,q+1,r-1)
    else:
        b+=row[p][q]
    
    if c==-1:
        c=col[p-1][q]+solve(p-1,q,r-1)
    else:
        c+=col[p-1][q]
    
    if d==-1:
        d=col[p][q]+solve(p+1,q,r-1)
    else:
        d+=col[p][q]



    z=min([a,b,c,d])

    dp[r][p][q]=z
    return z


n,m,k=map(int,input().split())
row=[]
col=[]
for i in range(n):

    row.append(list(map(int,input().split()))+[0])

for _ in range(n-1):

    col.append(list(map(int,input().split())))


col.append([0 for i in range(m)])

ans=[[-1 for _ in range(m)] for _ in range(n)]

dp=[[[-1 for _ in range(m+1)] for _ in range(n+1)] for _ in range(k+1)]

def main():

    if k%2:
        for item in ans:
            print(*item)
        exit()

    
    for r in range(n):
        for c in range(m):
            ans[r][c]=2*solve(r,c,k//2)
    
    for item in ans:
        print(*item)




#----------------------------------------------------------------------------------------
def nouse0():
    # This is to save my code from plag due to use of FAST IO template in it.
    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse1():
    # This is to save my code from plag due to use of FAST IO template in it.
    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse2():
    # This is to save my code from plag due to use of FAST IO template in it.
    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')




# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')




def nouse3():
    # This is to save my code from plag due to use of FAST IO template in it.
    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse4():
    # This is to save my code from plag due to use of FAST IO template in it.
    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')
def nouse5():
    # This is to save my code from plag due to use of FAST IO template in it.
    a=420
    b=420
    print(f'i am nitish{(a+b)//2}')



# endregion

if __name__ == '__main__':
    main()",cubic,"dp,graphs,shortest paths",4176
"import sys,io,os
try:Z=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:Z=lambda:sys.stdin.readline().encode()
Y=lambda:[*map(int,Z().split())]
n,m,k=Y();H=[Y()for i in range(n)];V=[Y()for i in range(n-1)]
if k&1:print('\n'.join(' '.join(['-1']*m)for i in range(n)));quit()
d=[0]*n*m
for _ in range(k//2):
    nd=[0]*n*m
    for x in range(n):
        for y in range(m):
            v=x*m+y;w=[]
            if x:w.append(d[v-m]+V[x-1][y])
            if y:w.append(d[v-1]+H[x][y-1])
            if x<n-1:w.append(d[v+m]+V[x][y])
            if y<m-1:w.append(d[v+1]+H[x][y])
            nd[v]=min(w)
    d=nd
print('\n'.join(' '.join(map(lambda x:str(2*x),d[i*m:i*m+m]))for i in range(n)))",cubic,"dp,graphs,shortest paths",700
"import sys
import math
input = sys.stdin.readline

############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s.rstrip()))
def invr():
    return(map(int,input().split()))
n, m, k=inlt()
M=[[[] for i in range(m)] for j in range(n)]
S=[[-1]*m for i in range(n)]
for y in range(n):
	L=inlt()
	for x in range(m-1):
		M[y][x].append(((y, x+1), L[x]))
		M[y][x+1].append(((y, x), L[x]))

for y in range(n-1):
	L=inlt()

	for x in range(m):
		M[y][x].append(((y+1, x), L[x]))
		M[y+1][x].append(((y, x), L[x]))
if k%2==0:
	for l in range(k//2):
		S2=[[0]*m for i in range(n)]
		for y in range(n):
			for x in range(m):
				Mi=10000000000000000000000
				for ((a, b), p) in M[y][x]:
					Mi=min(Mi,max(0,S[a][b])+p)
				S2[y][x]=Mi
		S=S2
	for y in range(n):
		for x in range(m):
			S[y][x]*=2

for y in range(n):
	print(' '.join(list(map(str, S[y]))))",cubic,"dp,graphs,shortest paths",973
"
def aburrimin(x, y, n, m, costder, costaba, dp):
    dists = []
    vals = []
    if x != 0: # izq
        dis = costder[y][x-1]
        dists.append(dis)
        vals.append(dis+dp[y][x-1])
    if y != 0: # arri
        dis = costaba[y-1][x]
        dists.append(dis)
        vals.append(dis+dp[y-1][x])
    if y < n-1: # aba
        dis = costaba[y][x]
        dists.append(dis)
        vals.append(dis+dp[y+1][x])
    if x < m-1: # der
        dis = costder[y][x]
        dists.append(dis)
        vals.append(dis+dp[y][x+1])
    
    mindis = min(dists)
    return min(mindis+dp[y][x],min(vals))
        

def solvecaso():
    n,m,k = map(int,input().split())
    costder = [[int(x) for x in input().split()] for _ in range(n)]
    costaba = [[int(x) for x in input().split()] for _ in range(n-1)]
    if k%2:
        for i in range(n):
            for j in range(m):
                print(-1, end=' ')
            print()
        return -1
    k //= 2
    
    for ren in range(len(costder)):
        for col in range(len(costder[ren])):
            costder[ren][col] *= 2
    for ren in range(len(costaba)):
        for col in range(len(costaba[ren])):
            costaba[ren][col] *= 2
    
    dp = [[0 for _ in range(m)] for _ in range(n)]
    dptemp = [[0 for _ in range(m)] for _ in range(n)]
    # print(dp) # debug
    
    for i in range(k):
        for y in range(n):
            for x in range(m):
                dptemp[y][x] = aburrimin(x, y, n, m, costder, costaba, dp)
        dp, dptemp = dptemp, dp
        # print(dp) # debug
    
    for ren in dp:
        for num in ren:
            print(num, end=' ')
        print()
    
    return 0


if __name__ == ""__main__"":
    # casos = int(input()) #dbug
    # for caso in range(1,casos+1):#dbug
        # result = solvecaso()#dbug
    solvecaso() #dbug
",cubic,"dp,graphs,shortest paths",1826
"# URDL
DR = [1,0,-1,0]
DC = [0,1,0,-1]

n, m, k = map(int, input().split())
w = [[[0] * m for _ in range(n)] for _ in range(4)]
for r in range(n):
    for c, e in enumerate(map(int, input().split())):
        w[1][r][c] = w[3][r][c + 1] = e
for r in range(n - 1):
    for c, e in enumerate(map(int, input().split())):
        w[0][r][c] = w[2][r + 1][c] = e


INF = 10 ** 9


def solve():
    global k
    global w
    if k % 2 == 1:
        return [[-1] * m] * n
    k //= 2
    best = [[[0] * m for _ in range(n)] for _ in range(k + 1)]
    for steps in range(1, k + 1):
        for r in range(n):
            for c in range(m):
                best[steps][r][c] = INF
                for d in range(4):
                    r2, c2 = r + DR[d], c + DC[d]
                    if 0 <= r2 < n and 0 <= c2 < m:
                        best[steps][r][c] = min(best[steps][r][c], 2 * w[d][r][c] + best[steps - 1][r2][c2])
    return best[k]


res = solve()
for e in res:
    print(*e)",cubic,"dp,graphs,shortest paths",979
"from sys import stdin, stdout
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect
        
mod = pow(10, 9) + 7
mod2 = 998244353
        
def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True
 
n, m, k = mp()
hor = [lmp() for i in range(n)]
ver = [lmp() for i in range(n-1)]
if k%2:
    ml = l2d(n, m, -1)
    for i in ml: print(*i)
    exit()
k//=2
dp = [l2d(n, m) for i in range(k+1)]
for f in range(1, k+1):
    for i in range(n):
        for j in range(m):
            a = inf
            if i!=0:
                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])
            if i!=n-1:
                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])
            if j!=0:
                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])
            if j!=m-1:
                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])
            dp[f][i][j] = a
for i in dp[-1]:
    print(*i)",cubic,"dp,graphs,shortest paths",1749
"# from typing import List, Set, Dict, Tuple, Text, Optional
from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__  # type: ignore

#########
# INPUT #
#########


class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):
    # type: () -> str
    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

##########
# OUTPUT #
##########


class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):
    # type: (str) -> None
    self.out.append(str(text))

  def writeLine(self, text):
    # type: (str) -> None
    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

###########
# LIBRARY #
###########


def bootstrap(f, stack=[]):
  # Deep Recursion helper.
  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst
  # Usage:

  # @bootstrap
  # def recur(n):
  #   if n == 0:
  #     yield 1
  #   yield (yield recur(n-1)) * n
  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc


'''
arrayInit([3, 4, 5], 0):
Initialize 3-dim array with [3][4][5] with 0 as its initial value

Tested with:
https://codeforces.com/contest/625/problem/B
'''


class MDArray(object):
  # Faster implementation of md array, using a single array and a lot of math.
  '''
  >>> x = MDArray([1, 2, 5], 5)
  >>> x.get([0, 0, 0])
  5
  >>> x.get([0, 1, 4])
  5
  >>> x.set([0, 1, 2], 3)
  3
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.set([0, 1, 3], 1)
  1
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.get([0, 1, 3])
  1
  '''

  def __init__(self, dimensions, initial_value=0):
    # type: (Iterable[int], Any) -> None
    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):
    # type: (Iterable[int]) -> Any
    return self.arr[self._index(indexes)]

  def set(self, indexes, value):
    # type: (Iterable[int], Any) -> Any
    self.arr[self._index(indexes)] = value
    return value


#########
# LOGIC #
#########

def encode(row, col, n, m):
  return row * m + col


def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans


def main(inp, out):
  # type: (Input, Output) -> any
  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = MDArray([total_nodes, k+2], -1)

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp) * 2)
    out.writeLine(' '.join(map(str, ans)))


###############
# BOILERPLATE #
###############

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",cubic,"dp,graphs,shortest paths",4531
"# from typing import List, Set, Dict, Tuple, Text, Optional
from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__  # type: ignore

#########
# INPUT #
#########


class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):
    # type: () -> str
    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

##########
# OUTPUT #
##########


class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):
    # type: (str) -> None
    self.out.append(str(text))

  def writeLine(self, text):
    # type: (str) -> None
    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

###########
# LIBRARY #
###########


def bootstrap(f, stack=[]):
  # Deep Recursion helper.
  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst
  # Usage:

  # @bootstrap
  # def recur(n):
  #   if n == 0:
  #     yield 1
  #   yield (yield recur(n-1)) * n
  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc


'''
arrayInit([3, 4, 5], 0):
Initialize 3-dim array with [3][4][5] with 0 as its initial value

Tested with:
https://codeforces.com/contest/625/problem/B
'''


class MDArray(object):
  # Faster implementation of md array, using a single array and a lot of math.
  '''
  >>> x = MDArray([1, 2, 5], 5)
  >>> x.get([0, 0, 0])
  5
  >>> x.get([0, 1, 4])
  5
  >>> x.set([0, 1, 2], 3)
  3
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.set([0, 1, 3], 1)
  1
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.get([0, 1, 3])
  1
  '''

  def __init__(self, dimensions, initial_value=0):
    # type: (Iterable[int], Any) -> None
    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):
    # type: (Iterable[int]) -> Any
    return self.arr[self._index(indexes)]

  def set(self, indexes, value):
    # type: (Iterable[int], Any) -> Any
    self.arr[self._index(indexes)] = value
    return value


#########
# LOGIC #
#########

def encode(row, col, n, m):
  return row * m + col


def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans


def main(inp, out):
  # type: (Input, Output) -> any
  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = MDArray([total_nodes, k+2], -1)

  for i in range(n*m):
    dp.set((i, 0), 0)
  for t in range(1, k/2+1):
    for i in range(n*m):
      ans = min(map(lambda x: dp.get((x[0], t-1)) + x[1], adj[i]))
      dp.set((i, t), ans)

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(dp.get((node, k/2)) * 2)
    out.writeLine(' '.join(map(str, ans)))


###############
# BOILERPLATE #
###############

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",cubic,"dp,graphs,shortest paths",4717
"# from typing import List, Set, Dict, Tuple, Text, Optional
from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__  # type: ignore

#########
# INPUT #
#########


class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):
    # type: () -> str
    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

##########
# OUTPUT #
##########


class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):
    # type: (str) -> None
    self.out.append(str(text))

  def writeLine(self, text):
    # type: (str) -> None
    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

###########
# LIBRARY #
###########


def bootstrap(f, stack=[]):
  # Deep Recursion helper.
  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst
  # Usage:

  # @bootstrap
  # def recur(n):
  #   if n == 0:
  #     yield 1
  #   yield (yield recur(n-1)) * n
  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc


'''
arrayInit([3, 4, 5], 0):
Initialize 3-dim array with [3][4][5] with 0 as its initial value

Tested with:
https://codeforces.com/contest/625/problem/B
'''


class MDArray(object):
  # Faster implementation of md array, using a single array and a lot of math.
  '''
  >>> x = MDArray([1, 2, 5], 5)
  >>> x.get([0, 0, 0])
  5
  >>> x.get([0, 1, 4])
  5
  >>> x.set([0, 1, 2], 3)
  3
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.set([0, 1, 3], 1)
  1
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.get([0, 1, 3])
  1
  '''

  def __init__(self, dimensions, initial_value=0):
    # type: (Iterable[int], Any) -> None
    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):
    # type: (Iterable[int]) -> Any
    return self.arr[self._index(indexes)]

  def set(self, indexes, value):
    # type: (Iterable[int], Any) -> Any
    self.arr[self._index(indexes)] = value
    return value


#########
# LOGIC #
#########

def encode(row, col, n, m):
  return row * m + col


def solve(node, remain, adj, dp):
  if remain == 0:
    return 0
  key = (node, remain)
  mem = dp.get(key)
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1, adj, dp) + x[1], adj[node]))
  dp.set(key, ans)
  return ans


def main(inp, out):
  # type: (Input, Output) -> any
  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  for i in range(n*m):
    dp[i] = 0

  for t in range(1, k/2+1):
    for i in range(n*m):
      ans = min(map(lambda x: dp[x[0]+((t-1)*n*m)] + x[1], adj[i]))
      dp[i+(t*n*m)] = ans

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(dp[node+(k/2*n*m)] * 2)
    out.writeLine(' '.join(map(str, ans)))


###############
# BOILERPLATE #
###############

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",cubic,"dp,graphs,shortest paths",4699
"# from typing import List, Set, Dict, Tuple, Text, Optional
from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__  # type: ignore

#########
# INPUT #
#########


class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):
    # type: () -> str
    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

##########
# OUTPUT #
##########


class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):
    # type: (str) -> None
    self.out.append(str(text))

  def writeLine(self, text):
    # type: (str) -> None
    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

###########
# LIBRARY #
###########


def bootstrap(f, stack=[]):
  # Deep Recursion helper.
  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst
  # Usage:

  # @bootstrap
  # def recur(n):
  #   if n == 0:
  #     yield 1
  #   yield (yield recur(n-1)) * n
  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc


'''
arrayInit([3, 4, 5], 0):
Initialize 3-dim array with [3][4][5] with 0 as its initial value

Tested with:
https://codeforces.com/contest/625/problem/B
'''


class MDArray(object):
  # Faster implementation of md array, using a single array and a lot of math.
  '''
  >>> x = MDArray([1, 2, 5], 5)
  >>> x.get([0, 0, 0])
  5
  >>> x.get([0, 1, 4])
  5
  >>> x.set([0, 1, 2], 3)
  3
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.set([0, 1, 3], 1)
  1
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.get([0, 1, 3])
  1
  '''

  def __init__(self, dimensions, initial_value=0):
    # type: (Iterable[int], Any) -> None
    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):
    # type: (Iterable[int]) -> Any
    return self.arr[self._index(indexes)]

  def set(self, indexes, value):
    # type: (Iterable[int], Any) -> Any
    self.arr[self._index(indexes)] = value
    return value


#########
# LOGIC #
#########

def encode(row, col, n, m):
  return row * m + col


def main(inp, out):
  # type: (Input, Output) -> any
  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  def solve(node, remain):
    if remain == 0:
      return 0

    key = (node + remain * n * m)
    mem = dp[key]
    if mem != -1:
      return mem

    ans = min(map(lambda x: solve(x[0], remain-1) + x[1], adj[node]))
    dp[key] = ans
    return ans

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2) * 2)
    out.writeLine(' '.join(map(str, ans)))


###############
# BOILERPLATE #
###############

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",cubic,"dp,graphs,shortest paths",4515
"import os
import sys
from io import BytesIO, IOBase

# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#https://github.com/cheran-senthil/PyRival/blob/master/templates/template_py3.py


n,m,k=map(int,input().split())
y_axis=[list(map(int,input().split())) for i in range(n)]
x_axis=[list(map(int,input().split())) for i in range(n-1)]
if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(-1,end="" "")
        print()
else:
    inf=10**9
    dp=[[[inf for z in range(k+1)]for y in range(m)]for x in range(n)]
    for i in range(n):
        for j in range(m):
            if(i>0):
                if(i<n-1):
                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j],2*x_axis[i-1][j])
                else:
                    dp[i][j][2]=min(dp[i][j][2],2*x_axis[i-1][j])
            else:
                dp[i][j][2]=min(dp[i][j][2],2*x_axis[i][j])
            if(j>0):
                if(j<m-1):
                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j],2*y_axis[i][j-1])
                else:
                    dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j-1])
            else:
                dp[i][j][2]=min(dp[i][j][2],2*y_axis[i][j])
    for z in range(4,k+1,2):
        for i in range(n):
            for j in range(m):
                if(i>0):
                    if(i<n-1):
                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j],dp[i+1][j][z-2]+2*x_axis[i][j])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i-1][j][z-2]+2*x_axis[i-1][j])
                else:
                    dp[i][j][z]=min(dp[i][j][z],dp[i+1][j][z-2]+2*x_axis[i][j])
                if(j>0):
                    if(j<m-1):
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1],dp[i][j+1][z-2]+2*y_axis[i][j])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*y_axis[i][j-1])
                else:
                    dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*y_axis[i][j])
    for i in range(n):
        for j in range(m):
            if(dp[i][j][k]==inf):
                print(-1,end="" "")
            else:
                print(dp[i][j][k],end="" "")
        print()
                
                    
            
        
",cubic,"dp,graphs,shortest paths",3908
"# from typing import List, Set, Dict, Tuple, Text, Optional
from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__  # type: ignore

#########
# INPUT #
#########


class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):
    # type: () -> str
    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

##########
# OUTPUT #
##########


class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):
    # type: (str) -> None
    self.out.append(str(text))

  def writeLine(self, text):
    # type: (str) -> None
    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

###########
# LIBRARY #
###########


def bootstrap(f, stack=[]):
  # Deep Recursion helper.
  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst
  # Usage:

  # @bootstrap
  # def recur(n):
  #   if n == 0:
  #     yield 1
  #   yield (yield recur(n-1)) * n
  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc


'''
arrayInit([3, 4, 5], 0):
Initialize 3-dim array with [3][4][5] with 0 as its initial value

Tested with:
https://codeforces.com/contest/625/problem/B
'''


class MDArray(object):
  # Faster implementation of md array, using a single array and a lot of math.
  '''
  >>> x = MDArray([1, 2, 5], 5)
  >>> x.get([0, 0, 0])
  5
  >>> x.get([0, 1, 4])
  5
  >>> x.set([0, 1, 2], 3)
  3
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.set([0, 1, 3], 1)
  1
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.get([0, 1, 3])
  1
  '''

  def __init__(self, dimensions, initial_value=0):
    # type: (Iterable[int], Any) -> None
    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):
    # type: (Iterable[int]) -> Any
    return self.arr[self._index(indexes)]

  def set(self, indexes, value):
    # type: (Iterable[int], Any) -> Any
    self.arr[self._index(indexes)] = value
    return value


#########
# LOGIC #
#########

def encode(row, col, n, m):
  return row * m + col


def main(inp, out):
  # type: (Input, Output) -> any
  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  @bootstrap
  def solve(node, remain):
    if remain == 0:
      yield 0

    key = (node + remain * n * m)
    mem = dp[key]
    if mem != -1:
      yield mem

    result = []
    for x in adj[node]:
      result.append((yield solve(x[0], remain-1)) + x[1])
    ans = min(result)
    dp[key] = ans
    yield ans

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2) * 2)
    out.writeLine(' '.join(map(str, ans)))


###############
# BOILERPLATE #
###############

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",cubic,"dp,graphs,shortest paths",4575
"# from typing import List, Set, Dict, Tuple, Text, Optional
from collections import deque
from types import GeneratorType
import os
import sys
import math
import heapq
from atexit import register
from io import BytesIO
import __pypy__  # type: ignore

#########
# INPUT #
#########


class Input(object):
  def __init__(self):
    if 'CPH' not in os.environ:
      sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))
      sys.stdout = BytesIO()
      register(lambda: os.write(1, sys.stdout.getvalue()))

  def rawInput(self):
    # type: () -> str
    return sys.stdin.readline().rstrip('\r\n')

  def readInt(self):
    return int(self.rawInput())

##########
# OUTPUT #
##########


class Output(object):
  def __init__(self):
    self.out = __pypy__.builders.StringBuilder()

  def write(self, text):
    # type: (str) -> None
    self.out.append(str(text))

  def writeLine(self, text):
    # type: (str) -> None
    self.write(str(text) + '\n')

  def finalize(self):
    if sys.version_info[0] < 3:
      os.write(1, self.out.build())
    else:
      os.write(1, self.out.build().encode())

###########
# LIBRARY #
###########


def bootstrap(f, stack=[]):
  # Deep Recursion helper.
  # From: https://github.com/cheran-senthil/PyRival/blob/c1972da95d102d95b9fea7c5c8e0474d61a54378/docs/bootstrap.rst
  # Usage:

  # @bootstrap
  # def recur(n):
  #   if n == 0:
  #     yield 1
  #   yield (yield recur(n-1)) * n
  def wrappedfunc(*args, **kwargs):
    if stack:
      return f(*args, **kwargs)
    else:
      to = f(*args, **kwargs)
      while True:
        if type(to) is GeneratorType:
          stack.append(to)
          to = next(to)
        else:
          stack.pop()
          if not stack:
            break
          to = stack[-1].send(to)
      return to

  return wrappedfunc


'''
arrayInit([3, 4, 5], 0):
Initialize 3-dim array with [3][4][5] with 0 as its initial value

Tested with:
https://codeforces.com/contest/625/problem/B
'''


class MDArray(object):
  # Faster implementation of md array, using a single array and a lot of math.
  '''
  >>> x = MDArray([1, 2, 5], 5)
  >>> x.get([0, 0, 0])
  5
  >>> x.get([0, 1, 4])
  5
  >>> x.set([0, 1, 2], 3)
  3
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.set([0, 1, 3], 1)
  1
  >>> x.get([0, 1, 4])
  5
  >>> x.get([0, 1, 2])
  3
  >>> x.get([0, 1, 3])
  1
  '''

  def __init__(self, dimensions, initial_value=0):
    # type: (Iterable[int], Any) -> None
    self.dimensions = dimensions
    dim_total = 1
    for i in dimensions:
      dim_total *= i
    self.arr = [initial_value] * dim_total

  def _index(self, indexes):
    assert len(indexes) == len(self.dimensions)
    idx_multi = 1
    idx = 0
    for i in range(len(indexes)):
      assert 0 <= indexes[i] < self.dimensions[i]
      idx += indexes[i] * idx_multi
      idx_multi *= self.dimensions[i]
    return idx

  def get(self, indexes):
    # type: (Iterable[int]) -> Any
    return self.arr[self._index(indexes)]

  def set(self, indexes, value):
    # type: (Iterable[int], Any) -> Any
    self.arr[self._index(indexes)] = value
    return value


#########
# LOGIC #
#########

def encode(row, col, n, m):
  return row * m + col


def solve(node, remain, adj, dp, n, m):
  if remain == 0:
    return 0

  key = (node + remain * n * m)
  mem = dp[key]
  if mem != -1:
    return mem

  ans = min(map(lambda x: solve(x[0], remain-1,
            adj, dp, n, m) + x[1], adj[node]))
  dp[key] = ans
  return ans


def main(inp, out):
  # type: (Input, Output) -> any
  n, m, k = map(int, inp.rawInput().split())
  if k % 2 == 1:
    for _ in range(n):
      out.writeLine(' '.join(map(str, [-1] * m)))
    return

  total_nodes = n*m
  adj = [[] for _ in range(total_nodes)]

  for i in range(n):
    weights = map(int, inp.rawInput().split())
    for j in range(m-1):
      cur = encode(i, j, n, m)
      nex = encode(i, j+1, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  for i in range(n-1):
    weights = map(int, inp.rawInput().split())
    for j in range(m):
      cur = encode(i, j, n, m)
      nex = encode(i+1, j, n, m)
      adj[cur].append((nex, weights[j]))
      adj[nex].append((cur, weights[j]))

  dp = [-1] * (n*m*(k/2+1))

  for i in range(n):
    ans = []
    for j in range(m):
      node = encode(i, j, n, m)
      ans.append(solve(node, k/2, adj, dp, n, m) * 2)
    out.writeLine(' '.join(map(str, ans)))


###############
# BOILERPLATE #
###############

output_obj = Output()
main(Input(), output_obj)
output_obj.finalize()
",cubic,"dp,graphs,shortest paths",4553
"'''
      Mayank Sheoran 
      BITS PILANI GOA CAMPUS 
''' 

n,m,k = map(int,input().split())
right = [[9999999 for i in range(m-1)] for j in range(n)]
down =  [[9999999 for i in range(m)] for j in range(n-1)]
for i in range(n):
    right[i] = list(map(int,input().split()))
for i in range(n-1):
    down[i] = list(map(int,input().split()))

if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(""-1"",end="" "")
        print()
else:
    k = k//2
    row = n
    col = m
    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]
    for steps in range(k+1):
        for i in range(row):
            for j in range(col):
                if(steps==0):
                    dp[steps][i][j] = 0
                    continue
                ans = 99999999999
                if(i>0):
                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])
                if(i<n-1):
                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])
                if(j<m-1):
                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])
                if(j>0):
                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])
                dp[steps][i][j] = ans
                
    for i in range(n):
        for j in range(m):
            print(2*dp[k][i][j],end="" "")
        print()
    ",cubic,"dp,graphs,shortest paths",1341
"from sys import stdin, stdout 
input = stdin.readline
 
n,m,K = map(int,input().split())
edges = []
for i in range(n):
    edges.append([[]])
    lis = list(map(int,input().split()))
    for j in range(m-1):
        edges[i][j].append((1,0,lis[j]))
        edges[i].append([])
        edges[i][j+1].append((-1,0,lis[j]))
for i in range(n-1):
    lis = list(map(int,input().split()))
    for j in range(m):
        edges[i][j].append((0,1,lis[j]))
        edges[i+1][j].append((0,-1,lis[j]))

if K%2==1:
    lis = []
    for i in range(n):
        lis.append([-1]*m)
else:
    lis = []
    for i in range(n):
        lis.append([0]*m)
        
    for k in range(1,(K//2)+1):
        new_lis = []
        for i in range(n):
            new_lis.append([0]*m)
        for i in range(n):
            for j in range(m):
                dist = []
                for e in edges[i][j]:
                    # print(e,i,j,lis)
                    dist.append(e[2] + lis[i+e[1]][j+e[0]])
                new_lis[i][j] = min(dist)
        lis = new_lis
    for i in range(n):
        for j in range(m):
            lis[i][j] *= 2
            
for i in lis:
    print(*i)",cubic,"dp,graphs,shortest paths",1159
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) 

mod = pow(10, 9) + 7
mod2 = 998244353
        
def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True
 
n, m, k = mp()
hor = [lmp() for i in range(n)]
ver = [lmp() for i in range(n-1)]
if k%2:
    ml = l2d(n, m, -1)
    for i in ml: print(*i)
    exit()
k//=2
dp = [l2d(n, m) for i in range(k+1)]
for f in range(1, k+1):
    for i in range(n):
        for j in range(m):
            a = inf
            if i!=0:
                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])
            if i!=n-1:
                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])
            if j!=0:
                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])
            if j!=m-1:
                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])
            dp[f][i][j] = a
for i in dp[-1]:
    print(*i)",cubic,"dp,graphs,shortest paths",3369
"import sys, os
from io import BytesIO, IOBase
from math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log
from collections import defaultdict as dd, deque
from heapq import merge, heapify, heappop, heappush, nsmallest
from bisect import bisect_left as bl, bisect_right as br, bisect

# region fastio
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

stdin, stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) 

mod = pow(10, 9) + 7
mod2 = 998244353
        
def inp(): return stdin.readline().strip()
def iinp(): return int(inp())
def out(var, end=""\n""): stdout.write(str(var)+""\n"")
def outa(*var, end=""\n""): stdout.write(' '.join(map(str, var)) + end)
def lmp(): return list(mp())
def mp(): return map(int, inp().split())
def smp(): return map(str, inp().split())
def l1d(n, val=0): return [val for i in range(n)]
def l2d(n, m, val=0): return [l1d(m, val) for j in range(n)]
def remadd(x, y): return 1 if x%y else 0
def ceil(a,b): return (a+b-1)//b
S1 = 'abcdefghijklmnopqrstuvwxyz'
S2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
def isprime(x):
    if x<=1: return False
    if x in (2, 3): return True
    if x%2 == 0: return False
    for i in range(3, int(sqrt(x))+1, 2):
        if x%i == 0: return False
    return True
 
n, m, k = mp()
hor = [lmp() for i in range(n)]
ver = [lmp() for i in range(n-1)]
if k%2:
    ml = l2d(n, m, -1)
    for i in ml: print(*i)
    exit()
k//=2
dp = [l2d(n, m) for i in range(k+1)]
for f in range(1, k+1):
    for i in range(n):
        for j in range(m):
            a = inf
            if i!=0:
                a = min(a, 2*ver[i-1][j]+dp[f-1][i-1][j])
            if i!=n-1:
                a = min(a, 2*ver[i][j]+dp[f-1][i+1][j])
            if j!=0:
                a = min(a, 2*hor[i][j-1]+dp[f-1][i][j-1])
            if j!=m-1:
                a = min(a, 2*hor[i][j]+dp[f-1][i][j+1])
            dp[f][i][j] = a
for i in dp[-1]:
    outa(*i)",cubic,"dp,graphs,shortest paths",3368
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")


############## Code starts here ##########################

n, m, k1 = [int(x) for x in input().split()]

arr = [0 for i in range(n)]
for i in range(n):
    arr[i] = [int(x) for x in input().split()]

brr = [0 for i in range(n - 1)]
for i in range(n - 1):
    brr[i] = [int(x) for x in input().split()]

dp = [[[0 for k in range(11)] for j in range(m)] for i in range(n)]

for k in range(1, 11):
    for i in range(n):
        for j in range(m):
                dp[i][j][k] = 10 ** 9
                if i > 0:
                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + brr[i - 1][j] * 2)
                if i < n - 1:
                    dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + brr[i][j] * 2)
                if j > 0:
                    dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + arr[i][j - 1] * 2)
                if j < m - 1:
                    dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + arr[i][j] * 2)

for i in range(n):
    for j in range(m):
        if(k1 % 2):
            print(-1,end="" "")
        else:
            print(dp[i][j][k1 // 2],end="" "")
    print()

############## Code ends here ############################
",cubic,"dp,graphs,shortest paths",1375
"import sys
import os.path
from collections import *
import math
import bisect

if (os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")


############## Code starts here ##########################

n, m, k1 = [int(x) for x in input().split()]

arr = [0 for i in range(n)]
for i in range(n):
    arr[i] = [int(x) for x in input().split()]

brr = [0 for i in range(n - 1)]
for i in range(n - 1):
    brr[i] = [int(x) for x in input().split()]

dp = [[[0 for k in range(21)] for j in range(m)] for i in range(n)]

for k in range(1, 21):
    for i in range(n):
        for j in range(m):
                if k % 2:
                    dp[i][j][k] = -1
                else:
                    dp[i][j][k] = 10 ** 9
                    if i > 0:
                        dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 2] + brr[i - 1][j] * 2)
                    if i < n - 1:
                        dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 2] + brr[i][j] * 2)
                    if j > 0:
                        dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 2] + arr[i][j - 1] * 2)
                    if j < m - 1:
                        dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 2] + arr[i][j] * 2)

for i in range(n):
    for j in range(m):
        print(dp[i][j][k1],end="" "")
    print()

############## Code ends here ############################
",cubic,"dp,graphs,shortest paths",1423
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase

def main():
    n,m,k=map(int,input().split())
    left=[list(map(int,input().split())) for _ in range(n)]
    down=[list(map(int,input().split())) for _ in range(n-1)]
    dp=[[(-1 if k&1 else 0) for _ in range(m)] for _ in range(n)]
    if k&1==0:
        for l in range(k//2):
            dp1=[[10**8 for _ in range(m)] for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    if j>0:
                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])
                    if j<m-1:
                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])
                    if i>0:
                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])
                    if i<n-1:
                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])
            dp=dp1
    for i in dp:
        print(*i)


# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic,"dp,graphs,shortest paths",2697
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase
from array import array

def main():
    n,m,k=map(int,input().split())
    left=[array(""i"",map(int,input().split())) for _ in range(n)]
    down=[array(""i"",map(int,input().split())) for _ in range(n-1)]
    dp=[array(""i"",[(-1 if k&1 else 0) for _ in range(m)]) for _ in range(n)]
    if k&1==0:
        for l in range(k//2):
            dp1=[array(""i"",[10**8 for _ in range(m)]) for _ in range(n)]
            for i in range(n):
                for j in range(m):
                    if j>0:
                        dp1[i][j]=min(dp1[i][j],dp[i][j-1]+2*left[i][j-1])
                    if j<m-1:
                        dp1[i][j]=min(dp1[i][j],dp[i][j+1]+2*left[i][j])
                    if i>0:
                        dp1[i][j]=min(dp1[i][j],dp[i-1][j]+2*down[i-1][j])
                    if i<n-1:
                        dp1[i][j]=min(dp1[i][j],dp[i+1][j]+2*down[i][j])
            dp=dp1
    for i in dp:
        print(*i)


# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic,"dp,graphs,shortest paths",2753
"def main():
    N, M, K = map(int, input().split())
    HEdge = [list(map(int, input().split())) for _ in range(N)]
    VEdge = [list(map(int, input().split())) for _ in range(N - 1)]
    if K % 2:
        for i in range(N):
            print(*[-1] * M)
        return
    dp = [[[0] * M for _ in range(N)] for _ in range(K // 2 + 1)]
    for i in range(1, K // 2 + 1):
        for j in range(N):
            for k in range(M):
                Val1 = Val2 = Val3 = Val4 = 10 ** 9
                if j > 0:
                    Val1 = dp[i - 1][j - 1][k] + VEdge[j - 1][k]
                if j < N - 1:
                    Val2 = dp[i - 1][j + 1][k] + VEdge[j][k]
                if k > 0:
                    Val3 = dp[i - 1][j][k - 1] + HEdge[j][k - 1]
                if k < M - 1:
                    Val4 = dp[i - 1][j][k + 1] + HEdge[j][k]
                dp[i][j][k] = min(Val1, Val2, Val3, Val4)
    for i in dp[K // 2]:
        print(*list(map(lambda x: x * 2, i)))

if __name__ == '__main__':
    main()",cubic,"dp,graphs,shortest paths",1011
"#!/usr/bin/env python
import os
import sys
import time
from io import BytesIO, IOBase


def main():
    max_int = 10 ** 9
    d = ((1, 0), (-1, 0), (0, 1), (0, -1))
    n, m, k = li_input()
    H = []
    for i in range(n):
        H.append(li_input() + [max_int])

    V = []
    for i in range(n - 1):
        V.append(li_input())

    V.append([max_int] * m)

    if k % 2:
        for i in range(n):
            print(' '.join(['-1'] * m))
        return

    k //= 2

    DP0 = [[0] * (m + 1) for _ in range(n + 1)]
    DP1 = [[0] * (m + 1) for _ in range(n + 1)]

    for kk in range(k):
        for i in range(n):
            for j in range(m):
                l = DP0[i][j - 1] + H[i][j - 1]
                r = DP0[i][j + 1] + H[i][j]
                u = DP0[i - 1][j] + V[i - 1][j]
                d = DP0[i + 1][j] + V[i][j]
                DP1[i][j] = min(l, r, u, d)

        DP0, DP1 = DP1, DP0

    O = []
    for row in DP0[:-1]:
        O.append(' '.join((str(n * 2) for n in row[:-1])))

    print('\n'.join(O))


############

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input():
    return sys.stdin.readline().rstrip(""\r\n"")


def i_input():
    return int(input())


def l_input():
    return input().split()


def li_input():
    return list(map(int, l_input()))


def il_input():
    return list(map(int, l_input()))


# endregion

if __name__ == ""__main__"":
    TT = time.time()
    main()
    # print(""\n"", time.time() - TT)
",cubic,"dp,graphs,shortest paths",3423
"n,m,k = map(int,input().split())
right = [[9999999 for i in range(m-1)] for j in range(n)]
down =  [[9999999 for i in range(m)] for j in range(n-1)]
for i in range(n):
    right[i] = list(map(int,input().split()))
for i in range(n-1):
    down[i] = list(map(int,input().split()))

if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(""-1"",end="" "")
        print()
else:
    k = k//2
    row = n
    col = m
    dp  = [[[9999999 for i in range(m)] for j in range(n)] for ii in range(k+1)]
    for steps in range(k+1):
        for i in range(row):
            for j in range(col):
                if(steps==0):
                    dp[steps][i][j] = 0
                    continue
                ans = 99999999999
                if(i>0):
                    ans = min(ans,dp[steps-1][i-1][j]+down[i-1][j])
                if(i<n-1):
                    ans = min(ans,dp[steps-1][i+1][j]+down[i][j])
                if(j<m-1):
                    ans = min(ans,dp[steps-1][i][j+1]+right[i][j])
                if(j>0):
                    ans = min(ans,dp[steps-1][i][j-1]+right[i][j-1])
                dp[steps][i][j] = ans
                
    for i in range(n):
        for j in range(m):
            print(2*dp[k][i][j],end="" "")
        print()
    ",cubic,"dp,graphs,shortest paths",1279
"n,m,k=[int(x) for x in input().split()]
left=[];right=[]
for i in range(n):
    temp=[int(x) for x in input().split()]
    left.append(temp)
for i in range(n-1):
    temp=[int(x) for x in input().split()]
    right.append(temp)
dp_old=[[0 for x in range(m)] for x in range(n)]
if k%2!=0:
    for i in range(n):
        print(*[-1 for x in range(m)])
else:
    k//=2
    for k1 in range(k):
        dp=[[0 for x in range(m)] for x in range(n)]
        for row in range(n):
            for col in range(m):
                t=float(""inf"")
                if 0<col:
                    t=min(t,dp_old[row][col-1]+2*left[row][col-1])
                if m-1>col:
                    t=min(t,dp_old[row][col+1]+2*left[row][col])
                if 0<row:
                    t=min(t,dp_old[row-1][col]+2*right[row-1][col])
                if n-1>row:
                    t=min(t,dp_old[row+1][col]+2*right[row][col])
                dp[row][col]=t
        for row in range(n):
            for col in range(m):
                dp_old[row][col]=dp[row][col]
    for i in range(n):
        print(*dp_old[i])",cubic,"dp,graphs,shortest paths",1097
"import os,sys;from io import BytesIO, IOBase
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno();self.buffer = BytesIO();self.writable = ""x"" in file.mode or ""r"" not in file.mode;self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:break
            ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE));self.newlines = b.count(b""\n"") + (not b);ptr = self.buffer.tell();self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:os.write(self._fd, self.buffer.getvalue());self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file);self.flush = self.buffer.flush;self.writable = self.buffer.writable;self.write = lambda s: self.buffer.write(s.encode(""ascii""));self.read = lambda: self.buffer.read().decode(""ascii"");self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
try:sys.stdin,sys.stdout=open('in.txt','r'),open('out.txt','w')
except:pass
ii1=lambda:int(sys.stdin.readline().strip()) # for interger
is1=lambda:sys.stdin.readline().strip() # for str
iia=lambda:list(map(int,sys.stdin.readline().strip().split())) # for List[int]
isa=lambda:sys.stdin.readline().strip().split() # for List[str]
# mod=int(1e9 + 7);from collections import *;from math import *
# abc = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# sys.setrecursionlimit(500000)
###################### Start Here ######################
from functools import lru_cache
from collections import defaultdict 
from math import inf 
# from collections import deque as dq 
n,m,k = iia()
A = [[0] * (m) for _ in range(n)]
B = [[0] * (m) for _ in range(n)]
for i in range(n):
    tmp = iia()
    for j in range(m - 1):
        A[i][j + 1] = tmp[j]
for i in range(n - 1):
    tmp = iia()
    for j in range(m):
        B[i + 1][j] = tmp[j] 

if k%2:
    [print(*[-1]*m) for i in range(n)]
    sys.exit()
ans = [[0] * m for _ in range(n)]
lim = k // 2
dp = [[[inf] * (lim + 1) for _ in range(m)] for _ in range(n)]
for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for k in range(1, lim + 1):
    for i in range(n):
        for j in range(m):
            if i: dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - 1] + B[i][j])
            if j: dp[i][j][k] = min(dp[i][j][k], dp[i][j - 1][k - 1] + A[i][j])
            if i < n - 1: dp[i][j][k] = min(dp[i][j][k], dp[i + 1][j][k - 1] + B[i + 1][j])
            if j < m - 1: dp[i][j][k] = min(dp[i][j][k], dp[i][j + 1][k - 1] + A[i][j + 1])
for i in range(n):
    for j in range(m):
        ans[i][j] = dp[i][j][-1] * 2
[print(*a) for a in ans]",cubic,"dp,graphs,shortest paths",3146
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import itertools
import bisect
import heapq
sys.setrecursionlimit(100000)
#^^^TAKE CARE FOR MEMORY LIMIT^^^
def main():
    pass
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def binary(n):
    return (bin(n).replace(""0b"", """"))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)


def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum
def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m
def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)
def p2(n):
    c=0
    while(n%2==0):
        n//=2
        c+=1
    return c
def seive(n):
    primes=[True]*(n+1)
    primes[1]=primes[0]=False
    for i in range(2,n+1):
        if(primes[i]):
            for j in range(i+i,n+1,i):
                primes[j]=False
    p=[]
    for i in range(0,n+1):
        if(primes[i]):
            p.append(i)
    return(p)
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p
def denofactinverse(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return (pow(fac,m-2,m))
def numofact(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return(fac)
def sod(n):
    s=0
    while(n>0):
        s+=n%10
        n//=10
    return s
def getVal(x,y,sx,sy):
    #print(x,y,sx,sy)
    if (x == -1 or y == -1 or x == n or y == m):
        return inF
    elif(sx==x):
        return hor[sx][min(sy,y)]
    else:
        return ver[min(sx,x)][sy]
def rec(k,x,y):
    if(x==-1 or y==-1 or x>=n or y>=m):
        return inF
    elif (k == 0):
        #print(x,y)
        dp[k][x][y] = 0
        return dp[k][x][y]
    elif(dp[k][x][y]!=-1):
        return dp[k][x][y]
    else:
        #print(getVal(x-1,y,x,y))
        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)
        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)
        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)
        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)
        dp[k][x][y]=min(val1,val2,val3,val4)
        return dp[k][x][y]
n,m,k=map(int,input().split())
adj=[[-1]*n for i in range(0,m)]
if(k%2):
    for i in range(0, n):
        for j in range(0, m):
            print(-1, end="" "")
        print("""")
else:
    hor,ver=[],[]
    inF=10**20
    k//=2
    for i in range(0,n):
        hor.append(list(map(int,input().split())))
    for i in range(0,n-1):
        ver.append(list(map(int,input().split())))
    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]
    for i in range(0,n):
        for j in range(0,m):
            print(2*rec(k,i,j),end="" "")
        print("""")
    '''
    print(""\n"",getVal(0,0,0,1))
    print(""\n\n\n\n\n"")
    for k in range(0,k+1):
        print(""page"",k)
        for i in range(0,n):
            for j in range(0,m):
                print(dp[k][i][j],end="" "")
            print("""")
    '''
",cubic,"dp,graphs,shortest paths",6011
"import os
import sys
from io import BytesIO, IOBase
import math
from queue import Queue
import itertools
import bisect
import heapq
#sys.setrecursionlimit(100000)
#^^^TAKE CARE FOR MEMORY LIMIT^^^
def main():
    pass
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


def binary(n):
    return (bin(n).replace(""0b"", """"))


def decimal(s):
    return (int(s, 2))


def pow2(n):
    p = 0
    while (n > 1):
        n //= 2
        p += 1
    return (p)


def primeFactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n = n / i
    if n > 2:
        l.append(int(n))
    return (l)


def isPrime(n):
    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)


def maxPrimeFactors(n):
    maxPrime = -1
    while n % 2 == 0:
        maxPrime = 2
        n >>= 1
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            maxPrime = i
            n = n / i
    if n > 2:
        maxPrime = n
    return int(maxPrime)


def countcon(s, i):
    c = 0
    ch = s[i]
    for i in range(i, len(s)):
        if (s[i] == ch):
            c += 1
        else:
            break
    return (c)


def lis(arr):
    n = len(arr)
    lis = [1] * n
    for i in range(1, n):
        for j in range(0, i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
    maximum = 0
    for i in range(n):
        maximum = max(maximum, lis[i])
    return maximum
def isSubSequence(str1, str2):
    m = len(str1)
    n = len(str2)
    j = 0
    i = 0
    while j < m and i < n:
        if str1[j] == str2[i]:
            j = j + 1
        i = i + 1
    return j == m
def maxfac(n):
    root = int(n ** 0.5)
    for i in range(2, root + 1):
        if (n % i == 0):
            return (n // i)
    return (n)
def p2(n):
    c=0
    while(n%2==0):
        n//=2
        c+=1
    return c
def seive(n):
    primes=[True]*(n+1)
    primes[1]=primes[0]=False
    for i in range(2,n+1):
        if(primes[i]):
            for j in range(i+i,n+1,i):
                primes[j]=False
    p=[]
    for i in range(0,n+1):
        if(primes[i]):
            p.append(i)
    return(p)
def ncr(n, r, p):
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
            p - 2, p)) % p
def denofactinverse(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return (pow(fac,m-2,m))
def numofact(n,m):
    fac=1
    for i in range(1,n+1):
        fac=(fac*i)%m
    return(fac)
def sod(n):
    s=0
    while(n>0):
        s+=n%10
        n//=10
    return s
def getVal(x,y,sx,sy):
    #print(x,y,sx,sy)
    if (x == -1 or y == -1 or x == n or y == m):
        return inF
    elif(sx==x):
        return hor[sx][min(sy,y)]
    else:
        return ver[min(sx,x)][sy]
def rec(k,x,y):
    if(x==-1 or y==-1 or x>=n or y>=m):
        return inF
    elif (k == 0):
        #print(x,y)
        dp[k][x][y] = 0
        return dp[k][x][y]
    elif(dp[k][x][y]!=-1):
        return dp[k][x][y]
    else:
        #print(getVal(x-1,y,x,y))
        val1=rec(k-1,x-1,y)+getVal(x-1,y,x,y)
        val2=rec(k-1,x+1,y)+getVal(x+1,y,x,y)
        val3=rec(k-1,x,y+1)+getVal(x,y+1,x,y)
        val4=rec(k-1,x,y-1)+getVal(x,y-1,x,y)
        dp[k][x][y]=min(val1,val2,val3,val4)
        return dp[k][x][y]
n,m,k=map(int,input().split())
adj=[[-1]*n for i in range(0,m)]
if(k%2):
    for i in range(0, n):
        for j in range(0, m):
            print(-1, end="" "")
        print("""")
else:
    hor,ver=[],[]
    inF=10**20
    k//=2
    for i in range(0,n):
        hor.append(list(map(int,input().split())))
    for i in range(0,n-1):
        ver.append(list(map(int,input().split())))
    dp=[[[-1]*(m+1) for i in range(0,n+1)]for j in range(0,k+1)]
    for i in range(0,n):
        for j in range(0,m):
            print(2*rec(k,i,j),end="" "")
        print("""")
    '''
    print(""\n"",getVal(0,0,0,1))
    print(""\n\n\n\n\n"")
    for k in range(0,k+1):
        print(""page"",k)
        for i in range(0,n):
            for j in range(0,m):
                print(dp[k][i][j],end="" "")
            print("""")
    '''
",cubic,"dp,graphs,shortest paths",6012
"import sys
input=sys.stdin.readline

#t=int(input())
t=1
for i in range(t):
    #n=int(input())
    n,m,k = map(int,input().split())
    b=[]
    horizontal_edges=[]
    vertical_edges=[]
    for i in range(n):
        temp=[int(x) for x in input().split()]
        horizontal_edges.append(temp)
    for i in range(n-1):
        temp=[int(x) for x in input().split()]
        vertical_edges.append(temp)

    if k%2==1:
        for i in range(n):
            for j in range(m):
                print(-1,end=' ')
            print()
        continue

    dp=[[[10**9 for x in range(k+1)] for x in range(m)] for x in range(n)]

    for i in range(n):
        for j in range(m):
            dp[i][j][0]=0

    for z in range(2,k+1,2):
        for i in range(n):
            for j in range(m):
                    if i>0:
                        if i<n-1:
                            dp[i][j][z]=min(dp[i-1][j][z-2]+2*vertical_edges[i-1][j],dp[i+1][j][z-2]+2*vertical_edges[i][j])
                        else:
                            dp[i][j][z]=dp[i-1][j][z-2]+2*vertical_edges[i-1][j]
                    else:
                        dp[i][j][z]=dp[i+1][j][z-2]+2*vertical_edges[i][j]
                    if j>0:
                        if j<m-1:
                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1],dp[i][j+1][z-2]+2*horizontal_edges[i][j])
                        else:
                            dp[i][j][z]=min(dp[i][j][z],dp[i][j-1][z-2]+2*horizontal_edges[i][j-1])
                    else:
                        dp[i][j][z]=min(dp[i][j][z],dp[i][j+1][z-2]+2*horizontal_edges[i][j])

    for i in range(n):
            for j in range(m):
                print(dp[i][j][k],end=' ')
            print()",cubic,"dp,graphs,shortest paths",1759
"import math
n,m,k=map(int,input().split())
horz=[]
vert=[]
if k & 1:
    for i in range(n):
        temp=[-1 for j in range(m)]
        print(*temp)

else:
    for i in range(n):
        temp=list(map(int,input().split()))
        horz.append(temp)
    for i in range(n-1):
        temp=list(map(int,input().split()))
        vert.append(temp)
    dp=[[[0 for i in range(22)] for j in range(m)]for k in range(n)]
    for x in range(2,k+1,2):
        for i in range(n):
            for j in range(m):
                dp[i][j][x]=math.inf
                if i>0:
                     dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-2]+2*vert[i-1][j])
                if i<n-1:
                      dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-2]+2*vert[i][j])
                if j>0:
                     dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-2]+2*horz[i][j-1])
                if j<m-1:
                     dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-2]+2*horz[i][j])
    for i in range(n):
        temp=[]
        for j in range(m):
            temp.append(dp[i][j][k])
        print(*temp)",cubic,"dp,graphs,shortest paths",1081
"class node:
    def __init__(self,l,r,u,d):
        self.u = u
        self.d = d
        self.l = l
        self.r = r
        if l == 20000001 and r ==20000001 and u == 20000001 and d == 20000001:
            self.marr = [20000001 for i in range(11)]
        else:
            self.marr = [0 for i in range(11)]
            self.marr[1] = min(l,r,u,d)
    def mo(self,st):
        return self.marr[st-1]

n,m,s = (int(i) for i in input().split())
hor = [[20000001 for i in range(m+3)] for j in range(n+2)]
ver = [[20000001 for i in range(m+2)] for j in range(n+3)]
for i in range(1,n+1):
    hor[i][2:1+m] = [int(i) for i in input().split()]
for i in range(2,1+n):
    ver[i][1:m+1] = [int(i) for i in input().split()]
if s%2 == 0 :
    nds = [[node(hor[i][j],hor[i][j+1],ver[i][j],ver[i+1][j]) for j in range(m+2)] for i in range(n+2)]
    for st in range(2,s//2+1):
        for i in range(1,n+1):
            for j in range(1,m+1):
                x = nds[i][j].marr[1]
                l = nds[i][j].l
                r = nds[i][j].r
                u = nds[i][j].u
                d = nds[i][j].d
                nds[i][j].marr[st] = min(x*st,r+nds[i][j+1].mo(st),l+nds[i][j-1].mo(st),u+nds[i-1][j].mo(st),d+nds[i+1][j].mo(st))
    ans = [[nds[i][j].marr[s//2]*2 for j in range(1,m+1)] for i in range(1,n+1)]
    for i in range(n):
        print(*tuple(ans[i]))
else :
    a = [[-1 for i in range(m)] for j in range(n)]
    for i in range(n):
        print(*tuple(a[i]))
    ",cubic,"dp,graphs,shortest paths",1480
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#######################################
from heapq import heapify,heappush as hp,heappop as hpop
def check(x,y):
    if 0<=x<=n-1 and 0<=y<=m-1:
        return True
    return False
n,m,k=map(int,input().split())
l1=[]
l2=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
for  i in range(n-1):
    l2.append(list(map(int,input().split())))
inf=10**18
dp=[[[inf]*21 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        if check(i,j+1):
            dp[i][j][1]=min(l1[i][j],dp[i][j][1])
        if check(i,j-1):
            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])
        if check(i+1,j):
            dp[i][j][1]=min(l2[i][j],dp[i][j][1])
        if check(i-1,j):
            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])
for x in range(2,k//2+1):
    for i in range(n):
        for j in range(m):
            if check(i,j+1):
                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])
            if check(i,j-1):
                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])
            if check(i+1,j):
                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])
            if check(i-1,j):
                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])
           
ans=[[inf]*m for i in range(n)]
for i in range(n):
    for j in range(m):
        if k%2:
            ans[i][j]=-1
            continue
        ans[i][j]=2*dp[i][j][k//2] 
for i in ans:
    print(*i)
",cubic,"dp,graphs,shortest paths",3170
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#######################################
from heapq import heapify,heappush as hp,heappop as hpop
def check(x,y):
    if 0<=x<=n-1 and 0<=y<=m-1:
        return True
    return False
n,m,k=map(int,input().split())
l1=[]
l2=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
for  i in range(n-1):
    l2.append(list(map(int,input().split())))
inf=10**18
dp=[[[inf]*21 for i in range(m)] for j in range(n)]
for i in range(n):
    for j in range(m):
        if check(i,j+1):
            dp[i][j][1]=min(l1[i][j],dp[i][j][1])
        if check(i,j-1):
            dp[i][j][1]=min(l1[i][j-1],dp[i][j][1])
        if check(i+1,j):
            dp[i][j][1]=min(l2[i][j],dp[i][j][1])
        if check(i-1,j):
            dp[i][j][1]=min(l2[i-1][j],dp[i][j][1])
for x in range(2,k//2+1):
    for i in range(n):
        for j in range(m):
            if check(i,j+1):
                dp[i][j][x]=min(l1[i][j]+dp[i][j+1][x-1],dp[i][j][x])
            if check(i,j-1):
                dp[i][j][x]=min(l1[i][j-1]+dp[i][j-1][x-1],dp[i][j][x])
            if check(i+1,j):
                dp[i][j][x]=min(l2[i][j]+dp[i+1][j][x-1],dp[i][j][x])
            if check(i-1,j):
                dp[i][j][x]=min(l2[i-1][j]+dp[i-1][j][x-1],dp[i][j][x])
           
ans=[[-1]*m for i in range(n)]
if not k%2:
    for i in range(n):
        for j in range(m):
            ans[i][j]=2*dp[i][j][k//2] 
for i in ans:
    print(*i)
",cubic,"dp,graphs,shortest paths",3131
"import sys

input = lambda: sys.stdin.readline().rstrip()

N, M, K = map(int, input().split())
if K % 2:
    for _ in range(N):
        print(*[-1] * M)
    exit()
A = [[int(a) for a in input().split()] for _ in range(N)]
B = [[int(a) for a in input().split()] for _ in range(N - 1)]
X = [[0] * M for _ in range(N)]
inf = 1 << 30
for k in range(1, K // 2 + 1):
    nX = [[inf] * M for _ in range(N)]
    for i in range(N):
        for j in range(M):
            if i: nX[i][j] = min(nX[i][j], X[i - 1][j] + B[i - 1][j])
            if i < N - 1: nX[i][j] = min(nX[i][j], X[i + 1][j] + B[i][j])
            if j: nX[i][j] = min(nX[i][j], X[i][j - 1] + A[i][j - 1])
            if j < M - 1: nX[i][j] = min(nX[i][j], X[i][j + 1] + A[i][j])
    X = nX
for x in X:
    print(*[a * 2 for a in x])",cubic,"dp,graphs,shortest paths",791
"import sys

n, m, k = map(int, input().split())

#process cost
hor = [list(map(int, input().split())) for _ in range(n)]
#hor[i][j] --> i,j and i, j+1
ver = [list(map(int, input().split())) for _ in range(n-1)]
#ver[i][j] --> i, j and i+1, j

#dp
if k % 2:
    for i in range(n):
        print(*([-1]*m))
    sys.exit()

k = k // 2
dp = [[[0]*m for _ in range(n)] for _ in range(k+1)]

for x in range(1, k+1):
    for y in range(n):
        for z in range(m):
            hold = float('inf')
            if y != 0:
                hold = min(hold, dp[x-1][y-1][z] + ver[y-1][z] )
            if y != n-1:
                hold = min(hold, dp[x-1][y+1][z] + ver[y][z] )
            if z != 0:
                hold = min(hold, dp[x-1][y][z-1] + hor[y][z-1] )
            if z != m-1:
                hold = min(hold, dp[x-1][y][z+1] + hor[y][z] )
            dp[x][y][z] = hold

for row in dp[k]:
    print(*map(lambda i: i*2, row))
",cubic,"dp,graphs,shortest paths",930
"'''
Author: your name
Date: 2021-04-25 17:01:28
LastEditTime: 2021-04-25 17:13:31
LastEditors: Please set LastEditors
Description: In User Settings Edit
FilePath: \code_py\cf_718D.py
'''


def main():
    n, m, k = map(int, input().split())
    inf = 1 << 30
    left = [list(map(int, input().split())) for i in range(n)]
    down = [list(map(int, input().split())) for i in range(n-1)]
    if k & 1:
        for i in range(n):
            print(*[-1]*m)
        exit()
    ans = [[0]*m for i in range(n)]
    for k in range(1, k//2+1):
        _ = [[inf]*m for ii in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    _[i][j] = min(_[i][j], ans[i-1][j]+down[i-1][j])
                if i < n-1:
                    _[i][j] = min(_[i][j], ans[i+1][j]+down[i][j])
                if j:
                    _[i][j] = min(_[i][j], ans[i][j-1]+left[i][j-1])
                if j < m-1:
                    _[i][j] = min(_[i][j], ans[i][j+1]+left[i][j])
        ans = _
    for i in range(n):
        for j in range(m):
            print(ans[i][j]*2, end=' ')
        print()


if __name__ == '__main__':
    main()
",cubic,"dp,graphs,shortest paths",1170
"get = lambda : list(map(int, input().split(' ')))
n, m, k = get()
rlist, clist = [], []
for _ in range(n):
    rlist.append(get())
for _ in range(n-1):
    clist.append(get())

dway = [[0,1],[0,-1],[1,0],[-1,0]]
if k%2:
    res = [[-1]*m for _ in range(n)]
else:
    flist = [[0]*m for _ in range(n)]
    for _ in range(k//2):
        glist = [[10**9]*m for _ in range(n)]
        for dx, dy in dway:
            klist = rlist if dx == 0 else clist
            for x in range(n):
                for y in range(m):
                    xx, yy = x+dx, y+dy
                    if not (0<=xx<n) or not (0<=yy<m):
                        continue
                    tx = xx if dx==-1 else x
                    ty = yy if dy==-1 else y
                    glist[x][y] = min(glist[x][y], flist[xx][yy] + klist[tx][ty] * 2)
        flist = glist
    res = flist
for row in res:
    print(' '.join(map(str, row)))",cubic,"dp,graphs,shortest paths",907
"import sys


def input():
    return sys.stdin.readline().rstrip()


def slv():
    n, m, k = map(int, input().split())
    if k % 2 != 0:
        for i in range(n):
            print(*[-1]*m)
        return
    #always possible

    k //= 2

    DP = [[[0]*m for i in range(n)] for _ in range(k + 1)]
    G = [[[] for i in range(m)] for j in range(n)]
    for i in range(n):
        C = list(map(int,input().split()))
        for j in range(m - 1):
            cost = C[j]
            G[i][j].append((cost,i,j + 1))
            G[i][j + 1] .append((cost,i,j))

    for i in range(n - 1):
        C = list(map(int,input().split()))
        for j in range(m):
            cost = C[j]
            G[i][j].append((cost,i + 1,j))
            G[i+1][j].append((cost,i,j))


    for p in range(1,k + 1):
        for u in range(n):
            for v in range(m):
                DP[p][u][v] = min(DP[p - 1][x][y] + cost for (cost,x,y) in G[u][v])
    for i in range(n):
        ans = [DP[k][i][j]*2 for j in range(m)]
        print(*ans)
    return
def main():
    t = 1
    for i in range(t):
        slv()
    return


if __name__ == ""__main__"":
    main()
",cubic,"dp,graphs,shortest paths",1152
"import math
def mint(): return map(int, input().split())
n, m, k = mint()
horizontal = [list(mint()) for i in range(n)]
vertical = [list(mint()) for i in range(n-1)]
if k%2 or max(n, m)==1:
    for i in range(n):
        print(*[-1]*m)
    exit()
dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
for length in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            left_path = math.inf if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
            right_path = math.inf if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
            top_path = math.inf if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
            bottom_path = math.inf if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
for i in range(n):
    print(*[dp[i][j][k//2]*2 for j in range(m)])
",cubic,"dp,graphs,shortest paths",880
"n, m, k =map(int, input().split())
horizontal = [list(map(int, input().split())) for i in range(n)]
vertical = [list(map(int, input().split())) for i in range(n-1)]
if k%2 or max(n, m)==1:print(*["" "".join(['-1']*m) for i in range(n)], sep='\n');exit()
dp = [[[0]*(k//2+1) for i in range(m)] for j in range(n)]
for length in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            left_path = 10e7 if j==0 else horizontal[i][j-1]+dp[i][j-1][length-1]
            right_path = 10e7 if j==m-1 else horizontal[i][j]+dp[i][j+1][length-1]
            top_path = 10e7 if i==0 else vertical[i-1][j]+dp[i-1][j][length-1]
            bottom_path = 10e7 if i==n-1 else vertical[i][j]+dp[i+1][j][length-1]
            dp[i][j][length] = min([left_path, right_path, top_path, bottom_path])
for i in range(n):print(*[dp[i][j][k//2]*2 for j in range(m)])
",cubic,"dp,graphs,shortest paths",864
"def main():
    n, m, k = [int(v) for v in input().split()]
    dxy = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    # dx = [-1, 1, 0, 0]
    # dy = [0, 0, -1, 1]
    w = [[[0 for d in range(4)] for j in range(m)] for i in range(n)]
    for i in range(n):
        row = [int(v) for v in input().split()]
        for j in range(m-1):
            w[i][j+1][2] = row[j]
            w[i][j][3] = row[j]
    for i in range(n-1):
        row = [int(v) for v in input().split()]
        for j in range(m):
            w[i][j][1] = row[j]
            w[i+1][j][0] = row[j]
    if k % 2 == 1:
        for i in range(n):
            for j in range(m):
                print(-1, end="" "")
            print()
        return
    else:
        k //= 2
    dp = [[[int(40 * 1e6) for d in range(k+1)] for j in range(m)] for i in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j][0] = 0
    for d in range(1, k+1):
        for i in range(n):
            for j in range(m):
                for di, (dx, dy) in enumerate(dxy):
                    ii = i + dx
                    jj = j + dy
                    if 0 <= ii < n and 0 <= jj < m:
                        dp[i][j][d] = min(dp[i][j][d], dp[ii][jj][d-1] + w[i][j][di])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k] * 2, end="" "")
        print()

main()

",cubic,"dp,graphs,shortest paths",1352
"def roll(i,j):
    ways = []
    if j:
        ways.append(2*hor[i][j-1] + grid[i][j-1])
    if m-1-j:
        ways.append(2*hor[i][j] + grid[i][j+1])
    if i:
        ways.append(2*ver[i-1][j] + grid[i-1][j])
    if n-1-i:
        ways.append(2*ver[i][j] + grid[i+1][j])
    return min(ways)

n , m , k = map(int, input().split())
hor = [list(map(int, input().split())) for _ in range(n)]
ver = [list(map(int, input().split())) for _ in range(n-1)]


grid = [[0]*m for _ in range(n)]
if k%2:
    for _ in range(n):
        print("" "".join([""-1""]*m))
else:
    for _ in range(k//2):
        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]
        grid = new_grid[:]
    for i in range(n):
        print("" "".join(map(str,grid[i])))",cubic,"dp,graphs,shortest paths",743
"'''input

'''
import sys
import math
from sys import stdin,stdout
from math import gcd,floor,sqrt,log
from collections import defaultdict as dd


# sys.setrecursionlimit(100000000)

inp    =lambda: int(input())
strng  =lambda: input().strip()
jn     =lambda x,l: x.join(map(str,l))
strl   =lambda: list(input().strip())
mul    =lambda: map(int,input().strip().split())
mulf   =lambda: map(float,input().strip().split())
seq    =lambda: list(map(int,input().strip().split()))

mod=1000000007

#main code
#!Q4
n,m,k=mul()

dp=[[[0 for l in range(k//2+1)]for j in range(m)]for i in range(n)]
h=[]
v=[]
for i in range(n):
    h.append(seq())
for i in range(n-1):
    v.append(seq())

def sol(n,m,k):
    for l in range(1,k//2+1):
        for i in range(n):
            for j in range(m):
                dp[i][j][l]=float(""inf"")
                if j-1>=0:
                    dp[i][j][l]=min(dp[i][j][l],dp[i][j-1][l-1]+h[i][j-1])
                if i-1>=0:
                    dp[i][j][l]=min(dp[i][j][l],dp[i-1][j][l-1]+v[i-1][j])
                if j+1<m:
                    dp[i][j][l]=min(dp[i][j][l],dp[i][j+1][l-1]+h[i][j])
                if i+1<n:
                    dp[i][j][l]=min(dp[i][j][l],dp[i+1][j][l-1]+v[i][j])
    return dp
if k%2:
    for i in range(n):
        for j in range(m):
            print(-1,end="" "")
        print()
else:
    ans=sol(n,m,k)
    for i in range(n):
        for j in range(m):
            print(2*ans[i][j][k//2],end="" "")
        print()
",cubic,"dp,graphs,shortest paths",1481
"import os, sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
n,m,k=map(int,input().split())
row=[]
for _ in range(n):
    row.append([10**6+2]+list(map(int,input().split()))+[10**6+2])
col=[[10**6+2]*(m+2)]
for _ in range(n-1):
    col.append([10**6+2]+list(map(int,input().split()))+[10**6+2])
col.append([10**6+2]*(m+2))
if  k%2:
    dp=[[-1 for i in range(m)] for j in range(n)]
else:
    k=k//2
    dp = [[0 for i in range(m)] for j in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j]=2*min(row[i][j],row[i][j+1],col[i][j+1],col[i+1][j+1])
    k-=1
    while k:
       # print(row,col)
        k-=1
        temp = [[0 for i in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                ck=dp[i][j]*8
                if i>=1:
                    ck=min(ck,dp[i-1][j]+2*col[i][j+1])
                if i<n-1:
                    ck=min(ck,dp[i+1][j]+2*col[i+1][j+1])
                if j>=1:
                    ck=min(ck,dp[i][j-1]+2*row[i][j])
                if j<m-1:
                    ck=min(ck,dp[i][j+1]+2*row[i][j+1])
                temp[i][j]=ck


        dp=temp

for i in dp:
    print(*i)
",cubic,"dp,graphs,shortest paths",2819
"#!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase
import threading 
from bisect import bisect_right
from math import gcd,log
from collections import Counter,defaultdict,deque
from pprint import pprint
from itertools import permutations 
from bisect import bisect_right
from random import randint as rti 
# import deque
n,m=0,0


    



def main(tnum):
    global n,m,d
    n,m,k=map(int,input().split())
    if k%2:
        ans=[[-1]*m for i in range(n)]
        for li in ans:
            print(*li)
        return 
    cost=dict()
    dp=[[float('inf')]*m for i in range(n)] 
    crr=[]
    rrr=[]
    for i in range(n):
        arr=list(map(int,input().split()))
        for j in range(m-1):
            dp[i][j]=min(dp[i][j],arr[j])
            dp[i][j+1]=min(dp[i][j+1],arr[j])
        crr.append(arr)


    for i in range(n-1):
        arr=list(map(int,input().split())) 
        for j in range(m):
            dp[i][j]=min(dp[i][j],arr[j])
            dp[i+1][j]=min(dp[i+1][j],arr[j])


        rrr.append(arr)

    for i in range(1,k//2):
        ndp=[[float('inf')]*m for i in range(n)]
        for i in range(n):
            for j in range(m):
                x,y=i,j
                if x>0:
                    ndp[i][j]=min(ndp[i][j],dp[x-1][y]+rrr[x-1][y])
                if x<n-1:
                    ndp[i][j]=min(ndp[i][j],dp[x+1][y]+rrr[x][y])
                if y>0:
                    ndp[i][j]=min(ndp[i][j],dp[x][y-1]+crr[x][y-1])
                if y<m-1:
                    ndp[i][j]=min(ndp[i][j],dp[x][y+1]+crr[x][y])
        dp=ndp
    for li in dp:
        li=[2*x for x in li]
        print(*li)  















    


        




    

    








        
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
if __name__ == ""__main__"":

    for _ in range(1): 
        main(_+1)



",cubic,"dp,graphs,shortest paths",3468
"from sys import stdin, stdout, maxsize
from math import inf

R = lambda : stdin.readline().strip()
RL = lambda f=None: list(map(f, R().split(' '))) if f else list(R().split(' '))

output = lambda x: stdout.write(str(x) + '\n')
output_list = lambda x: output(' '.join(map(str, x)))


n, m, K = RL(int)

if K%2:
    for i in range(n):
        print( *(m*[-1]) )
    exit()

hor = [ RL(int) +[inf] for i in range(n) ]
vert = [ RL(int) for i in range(n-1) ] + [ m*[inf] ]

K = K//2
dp = [ [m*[inf] for i in range(n)] for j in range(0, K+1)]

dp[0] = [m*[0] for i in range(n)]

def valid(i, j):
    if -1 < i < n and  -1 < j < m:
        return True
    return False

for k in range(1, K+1):
    for i in range(n):
        for j in range(m):
            if valid(i, j+1):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j+1] + 2*hor[i][j])
            if valid(i+1, j):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i+1][j] + 2*vert[i][j])
            if valid(i-1, j):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i-1][j] + 2*vert[i-1][j])
            if valid(i, j-1):
                dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j-1] + 2*hor[i][j-1])

for i in dp[-1]:
    print(*i)
",cubic,"dp,graphs,shortest paths",1207
"d4i=[0,-1,0,1]
d4j=[-1,0,1,0]

def main():
    
    n,m,k=readIntArr()
    horizontalEdges=[] # [i,j] represents [i,j] to [i,j+1]
    for _ in range(n):
        horizontalEdges.append(readIntArr())
    verticalEdges=[] # [i,j] represents [i,j] to [i+1,j]
    for _ in range(n-1):
        verticalEdges.append(readIntArr())
    
    if k%2==1: # impossible
        ans=makeArr(-1,[n,m])
    else:
        dp=makeArr(inf,[n,m,k//2+1]) # dp[i][j][nMoves] is the minimum possible boredom
        for i in range(n):
            for j in range(m):
                dp[i][j][0]=0
        for nM in range(1,k//2+1): # nM is nMoves
            for i in range(n):
                for j in range(m):
                    # move right
                    if j+1<m:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i][j+1][nM-1]+horizontalEdges[i][j])
                    # move left
                    if j-1>=0:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i][j-1][nM-1]+horizontalEdges[i][j-1])
                    # move down
                    if i+1<n:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i+1][j][nM-1]+verticalEdges[i][j])
                    # move up
                    if i-1>=0:
                        dp[i][j][nM]=min(dp[i][j][nM],
                                         dp[i-1][j][nM-1]+verticalEdges[i-1][j])
        ans=makeArr(0,[n,m])
        for i in range(n):
            for j in range(m):
                ans[i][j]=dp[i][j][k//2]*2
    
    multiLineArrayOfArraysPrint(ans)
    
    return

import sys
input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)
# input=lambda: sys.stdin.readline().rstrip(""\r\n"") #FOR READING STRING/TEXT INPUTS.
 
def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))
 
def readIntArr():
    return [int(x) for x in input().split()]
# def readFloatArr():
#     return [float(x) for x in input().split()]

def makeArr(defaultVal,dimensionArr): # eg. makeArr(0,[n,m])
    dv=defaultVal;da=dimensionArr
    if len(da)==1:return [dv for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]
 
def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())
 
def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()
 
inf=float('inf')
# MOD=10**9+7
MOD=998244353
 
 
for _abc in range(1):
    main()",cubic,"dp,graphs,shortest paths",2723
"#!/usr/bin/env python3
import os
from sys import stdin
from math import inf

dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]


def solve(tc):
    N, M, K = map(int, stdin.readline().split())

    wx = [[] for j in range(N)]
    for i in range(N):
        wx[i] = list(map(int, stdin.readline().split()))

    wy = [[] for i in range(N-1)]
    for i in range(N-1):
        wy[i] = list(map(int, stdin.readline().split()))

    if K & 1:
        for i in range(N):
            for j in range(M):
                print(-1, end=' ')
            print()
        return

    mem = [[[0 for i in range(M)] for j in range(N)] for k in range(K+1)]

    half = K // 2
    for kk in range(1, half+1):
        for yy in range(N):
            for xx in range(M):
                mem[kk][yy][xx] = inf

                for d in range(4):
                    y = yy + dy[d]
                    x = xx + dx[d]

                    if y < 0 or y >= N or x < 0 or x >= M:
                        continue

                    if d == 0:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][xx]*2)
                    elif d == 1:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[yy][xx]*2)
                    elif d == 2:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wx[yy][x]*2)
                    else:
                        mem[kk][yy][xx] = min(
                            mem[kk][yy][xx], mem[kk-1][y][x] + wy[y][xx]*2)

    for yy in range(N):
        for xx in range(M):
            print(mem[half][yy][xx], end=' ')
        print()


tcs = 1
# tcs = int(stdin.readline().strip())
tc = 1
while tc <= tcs:
    solve(tc)
    tc += 1
",cubic,"dp,graphs,shortest paths",1808
"# cook your dish here
n,m,k = map(int,input().split())
wh=[]
#for left to right connections
for j in range(n):
    l=list(map(int,input().split()))
    wh.append(l)
    
wv=[]
#for top to bottom connections
for j in range(n-1):
    l=list(map(int,input().split()))
    wv.append(l)
    
if(k%2!=0):
    ans = [[-1 for _ in range(m)]for j in range(n)]
    for res in ans:
        print(*res)
else:
    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]
    for x in range(1,21):
        for i in range(1,n+1):
            for j in range(1,m+1):
                dp[i][j][x]=1234567890
                if(i!=n):
                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])
                if(i!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])
                if(j!=m):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])
                if(j!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])
    for i in range(1,n+1):
        for j in range(1,m+1):
            ans = 1234567890
            for x in range(1,k+1):
                if(k%x==0 and (k//x)%2==0 ):
                    ans = min(ans,dp[i][j][x]*(k//x))
            print(ans,end="" "")
        print()",cubic,"dp,graphs,shortest paths",1285
"# cook your dish here
n,m,k = map(int,input().split())
wh=[]
#for left to right connections
for j in range(n):
    l=list(map(int,input().split()))
    wh.append(l)
    
wv=[]
#for top to bottom connections
for j in range(n-1):
    l=list(map(int,input().split()))
    wv.append(l)
    
if(k%2!=0):
    ans = [[-1 for _ in range(m)]for j in range(n)]
    for res in ans:
        print(*res)
else:
    dp = [[[0 for i in range(25)]for j in range(505)]for q in range(505)]
    for x in range(1,k+1):
        for i in range(1,n+1):
            for j in range(1,m+1):
                dp[i][j][x]=1234567890
                if(i!=n):
                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1]+wv[i-1][j-1])
                if(i!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1]+wv[i-2][j-1])
                if(j!=m):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1]+wh[i-1][j-1])
                if(j!=1):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1]+wh[i-1][j-2])
    for i in range(1,n+1):
        for j in range(1,m+1):
            ans = 1234567890
            for x in range(1,k+1):
                if(k%x==0 and (k//x)%2==0 ):
                    ans = min(ans,dp[i][j][x]*(k//x))
            print(ans,end="" "")
        print()",cubic,"dp,graphs,shortest paths",1286
"import os,sys,math 
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192
#complete the main function with number of test cases to complete greater than x
def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return len(a)

def solve():
    n,m,k=In()
    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    for i in range(n):
        z=list(In())
        for j in range(m-1):
            rt[i][j]=z[j]
    for i in range(n-1):
        z=list(In())
        for j in range(m):
            do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    for op in range(k):
        dp_next=[[P]*m for i in range(n)]
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0: 
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0: 
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 : 
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]
            
    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()
        




def main():
    T=1
    for i in range(T):
        solve()
        
M = 998244353
P = 1000000007
Inf=float('inf')




class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == '__main__':
    main()",cubic,"dp,graphs,shortest paths",4025
"import os,sys,math 
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192
#complete the main function with number of test cases to complete greater than x
def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return len(a)

def solve():
    n,m,k=In()
    rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    for i in range(n):
        z=list(In())
        for j in range(m-1):
            rt[i][j]=z[j]
    for i in range(n-1):
        z=list(In())
        for j in range(m):
            do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    dp_next=[[P]*m for i in range(n)]
    for op in range(k):
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0: 
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0: 
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 : 
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]
            
    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()





def main():
    T=1
    for i in range(T):
        solve()
        
M = 998244353
P = 1000000007
Inf=float('inf')




class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == '__main__':
    main()",cubic,"dp,graphs,shortest paths",4013
"import os,sys,math 
from io import BytesIO, IOBase
from collections import defaultdict,deque,OrderedDict
import bisect as bi
def yes():print('YES')
def no():print('NO')
def I():return (int(input()))
def In():return(map(int,input().split()))
def ln():return list(map(int,input().split()))
def Sn():return input().strip()
BUFSIZE = 8192
#complete the main function with number of test cases to complete greater than x
def find_gt(a, x):
    i = bi.bisect_left(a, x)
    if i != len(a):
        return i
    else:            
        return len(a)

def solve():
    n,m,k=In()
    # rt,do=[[0]*m for i in range(n)],[[0]*m for i in range(n-1)]
    rt,do=[list(In()) for i in range(n)],[list(In()) for i in range(n-1)]
    # for i in range(n):
    #     z=list(In())
    #     for j in range(m-1):
    #         rt[i][j]=z[j]
    # for i in range(n-1):
    #     z=list(In())
    #     for j in range(m):
    #         do[i][j]=z[j]

    dp=[[0]*m for i in range(n)]
    if k%2==1:
        for i in range(n):
            print(*[-1]*m)
        return
    k//=2
    dp_next=[[P]*m for i in range(n)]
    for op in range(k):
        for i in range(n):
            for j in range(m):
                ans=Inf
                if i!=0: 
                    ans=min(ans,dp[i-1][j]+do[i-1][j])
                if j!=0: 
                    ans=min(ans,dp[i][j-1]+rt[i][j-1])
                if i!=n-1:
                    ans = min( ans , dp[i+1][j]+do[i][j])
                if j!=m-1 : 
                    ans=min( ans , dp[i][j+1]+rt[i][j])
                dp_next[i][j]=ans

        for i in range(n):
            for j in range(m):
                dp[i][j]=dp_next[i][j]
            
    for i in range(n):
        for j in range(m):
            print(2*dp[i][j],end=' ')
        print()





def main():
    T=1
    for i in range(T):
        solve()
        
M = 998244353
P = 1000000007
Inf=float('inf')




class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()


if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# endregion

if __name__ == '__main__':
    main()",cubic,"dp,graphs,shortest paths",4105
"# coding:utf-8
# @Author: 将立

n, m, K = map(int, input().split())
wh = [[0]*m for i in range(n)]
wv = [[0]*m for i in range(n)]

for i in range(n):
    t = list(map(int, input().split()))
    for j in range(m-1):
        wh[i][j] = t[j]

for i in range(n-1):
    t = list(map(int, input().split()))
    for j in range(m):
        wv[i][j] = t[j]


f = [[[int(1e8)]* 11 for j in range(m)] for i in range(n)]

for i in range(n):
    for j in range(m):
        f[i][j][0] = 0

for k in range(1, K//2+1):
    for i in range(n):
        for j in range(m):
            if i > 0:
                f[i][j][k] = min(f[i][j][k], f[i-1][j][k-1]+wv[i-1][j])
            if j < m-1:
                f[i][j][k] = min(f[i][j][k], f[i][j+1][k-1]+wh[i][j])
            if i < n-1:
                f[i][j][k] = min(f[i][j][k], f[i+1][j][k-1]+wv[i][j])
            if j > 0:
                f[i][j][k] = min(f[i][j][k], f[i][j-1][k-1]+wh[i][j-1])

for i in range(n):
    for j in range(m):
        if K%2 == 1:
            print(-1)
        else:
            dp = [int(1e8)]*(K//2+1)
            dp[0] = 0
            for k in range(1, K//2+1):
                for l in range(0, k):
                    dp[k] = min(dp[k], dp[l]+f[i][j][k-l]*2)

            print(dp[K//2])
",cubic,"dp,graphs,shortest paths",1253
"from sys import stdin
readline = stdin.readline
def readInt():
    return int(readline())
def readInts():
    return list(map(int,readline().split()))

U, D, L, R = 0, 1, 2, 3
DIR = [(-1,0), (1,0), (0,-1), (0,1)]

n, m, k = readInts()

moves = [[[-1 for _ in range(4)] for _ in range(m)] for _ in range(n)]

right = []
down = []

for i in range(n):
    row = readInts()
    right.append(row)
    # for j in range(m-1):
    #     e = row[j]
    #     moves[i][j][R] = e
    #     moves[i][j+1][L] = e

for i in range(n-1):
    row = readInts()
    down.append(row)
    # for j in range(m):
    #     e = row[j]
    #     moves[i][j][D] = e
    #     moves[i+1][j][U] = e

if k % 2 == 1:
    for _ in range(n):
        for _ in range(m):
            print(-1, end="" "")
        print()
    exit()

k //= 2

dp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)]

for l in range(k):
    for i in range(n):
        for j in range(m):
            dp[i][j][l+1] = float(""inf"")
            if i > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j])
            if j > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1])
            if i < n - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j])
            if j < m - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j])
            # for d, (di, dj) in enumerate(DIR):
            #     if moves[i][j][d] != -1:
            #         dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+di][j+dj][l] + moves[i][j][d])
for i in range(n):
    for j in range(m):
        print(2*dp[i][j][k], end="" "")
    print()
",cubic,"dp,graphs,shortest paths",1679
"from sys import stdin
readline = stdin.readline
def readInt():
    return int(readline())
def readInts():
    return list(map(int,readline().split()))

n, m, k = readInts()

right = []
down = []

for i in range(n):
    row = readInts()
    right.append(row)

for i in range(n-1):
    row = readInts()
    down.append(row)

if k % 2 == 1:
    for _ in range(n):
        for _ in range(m):
            print(-1, end="" "")
        print()
    exit()

k //= 2

dp = [[[0 for _ in range(k+1)] for _ in range(m)] for _ in range(n)]

for l in range(k):
    for i in range(n):
        for j in range(m):
            dp[i][j][l+1] = float(""inf"")
            if i > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i-1][j][l] + down[i-1][j])
            if j > 0:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j-1][l] + right[i][j-1])
            if i < n - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i+1][j][l] + down[i][j])
            if j < m - 1:
                dp[i][j][l+1] = min(dp[i][j][l+1], dp[i][j+1][l] + right[i][j])

for i in range(n):
    for j in range(m):
        print(2*dp[i][j][k], end="" "")
    print()
",cubic,"dp,graphs,shortest paths",1147
"import math

n,m,kk=[int(x) for x in input().split()]
right,down=[],[]
for i in range(n) :
	a=[int(x) for x in input().split()]
	right.append(a)

for i in range(n-1) :
	a=[int(x) for x in input().split()]
	down.append(a)

dp,dpCopy=[],[]
for i in range(n) :
	li,li1=[],[]
	for j in range(m) :
		li.append(math.inf)
		li1.append(math.inf)
	dp.append(li)
	dpCopy.append(li1)

'''for i in range(n) :
	li=[]
	for j in range(m) :
		li.append(math.inf)
	dpCopy.append(li)'''

for i in range(1,(kk//2)+1) :
	#print(i)
	for j in range(n) :
		for k in range(m) :
			if i==1 :
				if j==0 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j][k])
				elif j==n-1 :
					if k==0 :
						dp[j][k]=min(dp[j][k],down[j-1][k],right[j][k])
					elif k==m-1 :
						dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k])
					else :
						dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k])
				elif k==0 :
					dp[j][k]=min(dp[j][k],right[j][k],down[j-1][k],down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dp[j][k],right[j][k-1],down[j-1][k],down[j][k])
				else :
					dp[j][k]=min(dp[j][k],right[j][k-1],right[j][k],down[j-1][k],down[j][k])
				#print(dpCopy)
				continue

			if j==0 :
				if k==0 :
					dp[j][k]=min(dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j+1][k]+down[j][k])
				else :
					dp[j][k]=min(dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k],dpCopy[j+1][k]+down[j][k])
			elif j==n-1 :
				if k==0 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k+1]+right[j][k])
				elif k==m-1 :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1])
				else :
					dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])
			elif k==0 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k+1]+right[j][k])
			elif k==m-1 :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1])
			else :
				dp[j][k]=min(dpCopy[j-1][k]+down[j-1][k],dpCopy[j+1][k]+down[j][k],dpCopy[j][k-1]+right[j][k-1],dpCopy[j][k+1]+right[j][k])
			#print(dp)

	for ii in range(n) :
		for jj in range(m) :
			dpCopy[ii][jj]=dp[ii][jj]

if kk%2==1 :
	for i in range(n) :
		for j in range(m) :
			print(-1,end=' ')
		print()
	exit(0)

for i in range(n) :
	for j in range(m) :
		print(2*dp[i][j],end=' ')
	print()",cubic,"dp,graphs,shortest paths",2577
"import math


def read_ints():
    return map(int, input().split())


def read_matrix(n):
    return [list(read_ints()) for _ in range(n)]


def around(x, y, hor, ver, mtx):
    a, b, c, d = [math.inf]*4
    
    if x > 0: 
        a = hor[y][x - 1] * 2 + mtx[y][x - 1]
    
    if x < m - 1: 
        b = hor[y][x] * 2 + mtx[y][x + 1]
    
    if y > 0: 
        c = ver[y - 1][x] * 2 + mtx[y - 1][x]
    
    if y < n - 1: 
        d = ver[y][x] * 2 + mtx[y + 1][x]
    
    return min(a, b, c, d)
    

if __name__ == ""__main__"":
    n, m, k = read_ints()
    hor = read_matrix(n)
    ver = read_matrix(n - 1)

    if k % 2:
        for i in range(n): 
            print('-1 ' * m)
        exit()
    
    _old = [[0] * m for _ in range(n)]
    for i in range(k // 2):
        _new = [[0] * m for _ in ' ' * n]
 
        for x in range(m):
            for y in range(n):
                _new[y][x] = around(x, y, hor, ver, _old)
 
        _old = _new
 
    for row in _old: 
        print(*row)",cubic,"dp,graphs,shortest paths",997
"import sys
input = sys.stdin.readline
def main():
    n,m,k = map(int,input().split())
    if k%2==1:
        for i in range(n):
            for j in  range(m):
                print(-1,end="" "")
            print()
        return 0
    kk=k
    maps= [[[0 for i in range(4)] for j in range(m)] for ii in range(n)]
    #0表示横向右，1表示横向左，2表示纵向下,3表示纵向上，
    dp=[[[1e9 for i in range(k//2+1)] for j in range(m)] for ii in range(n)]
    for i in range(n):
            for j in range(m):
                dp[i][j][0]=0
    for i in range(n):
        s=list(map(int,input().split()))
        for j in range(m-1):
            maps[i][j][0]=s[j]
            maps[i][j+1][1]=s[j]
    for i in range(n-1):
        s=list(map(int,input().split()))
        for j in range(m):
            maps[i][j][2]=s[j]
            maps[i+1][j][3]=s[j]
    for k in range(1,kk//2+1):
        for i in range(n):
            for j in range(m):
                if j<m-1:
                    dp[i][j+1][k]=min(dp[i][j+1][k],dp[i][j][k-1]+maps[i][j][0])
                if i<n-1:
                    dp[i+1][j][k]=min(dp[i+1][j][k],dp[i][j][k-1]+maps[i][j][2])
                if i>0:
                    dp[i-1][j][k]=min(dp[i-1][j][k],dp[i][j][k-1]+maps[i][j][3])
                if j>0:
                    dp[i][j-1][k]=min(dp[i][j-1][k],dp[i][j][k-1]+maps[i][j][1])
    for i in range(n):
        for j in range(m):
            print(dp[i][j][k]*2,end="" "")
        print()
main()

",cubic,"dp,graphs,shortest paths",1451
"from math import inf


n, m, k = map(int, input().split())
horizontal_costs = []
vertical_costs = []
for _ in range(n):
    horizontal_costs.append(list(map(int, input().split())))
for _ in range(n-1):
    vertical_costs.append(list(map(int, input().split())))

dp = [[[inf] * (k // 2 + 1) for _ in range(m)] for _ in range(n)]

# dp[a][b][c] - smallest cost of moving c squares from (a, b)
# ans[a][b] = 2 * dp[a][b][k//2] if k % 2 == 0 else -1


def find_cost(a, b, c):
    global dp
    if a < 0 or a > n-1 or b < 0 or b > m-1:
        return inf

    if c == 0:
        return 0

    if dp[a][b][c] != inf:
        return dp[a][b][c]

    if a < n-1:
        dp[a][b][c] = find_cost(a+1, b, c-1) + vertical_costs[a][b]
    if b < m-1:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b+1, c-1) + horizontal_costs[a][b])
    if b > 0:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a, b-1, c-1) + horizontal_costs[a][b-1])
    if a > 0:
        dp[a][b][c] = min(dp[a][b][c], find_cost(a-1, b, c-1) + vertical_costs[a-1][b])

    return dp[a][b][c]


ans = [[inf] * m for _ in range(n)]
if k % 2 == 1:
    for i in range(n):
        for j in range(m):
            ans[i][j] = -1
else:
    for i in range(n):
        for j in range(m):
            ans[i][j] = min(ans[i][j], 2 * find_cost(i, j, k//2))

for row in ans:
    print(*row)",cubic,"dp,graphs,shortest paths",1341
"from sys import stdin,stdout
from math import gcd,sqrt,factorial,pi,inf
from collections import deque,defaultdict
from bisect import bisect,bisect_left
from time import time
from itertools import permutations as per
input=stdin.readline
R=lambda:map(int,input().split())
I=lambda:int(input())
S=lambda:input().rstrip('\r\n')
L=lambda:list(R())
P=lambda x:stdout.write(str(x)+'\n')
lcm=lambda x,y:(x*y)//gcd(x,y)
nCr=lambda x,y:(f[x]*inv((f[y]*f[x-y])%N))%N
inv=lambda x:pow(x,N-2,N)
sm=lambda x:(x**2+x)//2
N=10**9+7

n,m,k=R()
A=[L() for i in range(n)]
B=[L() for i in range(n-1)]
if k&1:
	for i in range(n):
		print('-1 '*m)
	exit()
X=[[0]*m for i in range(n)]
for _ in range(k//2):
	Y=[[inf]*m for i in range(n)]
	for i in range(n):
		for j in range(m):
			if i:
				Y[i][j]=X[i-1][j]+2*B[i-1][j]
			if i<n-1:
				Y[i][j]=min(Y[i][j],X[i+1][j]+2*B[i][j])
			if j:
				Y[i][j]=min(Y[i][j],X[i][j-1]+2*A[i][j-1])
			if j<m-1:
				Y[i][j]=min(Y[i][j],X[i][j+1]+2*A[i][j])
	X=Y
for i in X:
	print(*i)",cubic,"dp,graphs,shortest paths",999
"def roll(i,j):
    ways = []
    if j:
        ways.append(2*hor[i][j-1] + grid[i][j-1])
    if m-1-j:
        ways.append(2*hor[i][j] + grid[i][j+1])
    if i:
        ways.append(2*ver[i-1][j] + grid[i-1][j])
    if n-1-i:
        ways.append(2*ver[i][j] + grid[i+1][j])
    return min(ways)
 
n , m , k = map(int, input().split())
hor = [list(map(int, input().split())) for _ in range(n)]
ver = [list(map(int, input().split())) for _ in range(n-1)]
 
 
grid = [[0]*m for _ in range(n)]
if k%2:
    for _ in range(n):
        print("" "".join([""-1""]*m))
else:
    for _ in range(k//2):
        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]
        grid = new_grid[:]
    for i in range(n):
        print("" "".join(map(str,grid[i])))",cubic,"dp,graphs,shortest paths",746
"n, m, k = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
b = [list(map(int, input().split())) for _ in range(n-1)]

if k % 2 == 1:
    for i in range(n):
        print(*[-1]*m)
    exit()
k //= 2

INF = 10**18
dp = [[[INF]*(k+1) for _ in range(m)] for _ in range(n)]

for i in range(n):
    for j in range(m):
        dp[i][j][0] = 0

for v in range(1, k+1):
    for i in range(n):
        for j in range(m):
            now_h, now_w = i, j
            if i > 0:
                dp[i][j][v] = min(dp[i-1][j][v-1]+b[i-1][j], dp[i][j][v])
            if i < n-1:
                dp[i][j][v] = min(dp[i+1][j][v-1]+b[i][j], dp[i][j][v])
            if j > 0:
                dp[i][j][v] = min(dp[i][j-1][v-1]+a[i][j-1], dp[i][j][v])
            if j < m-1:
                dp[i][j][v] = min(dp[i][j+1][v-1]+a[i][j], dp[i][j][v])

for i in range(n):
    v = []
    for j in range(m):
        v.append(dp[i][j][k]*2)
    print(*v)

# class UnionFind():
#     def __init__(self, n):
#         self.n = n
#         self.parents = [-1] * n

#     def find(self, x):
#         if self.parents[x] < 0:
#             return x
#         else:
#             self.parents[x] = self.find(self.parents[x])
#             return self.parents[x]

#     def union(self, x, y):
#         x = self.find(x)
#         y = self.find(y)

#         if x == y:
#             return

#         if self.parents[x] > self.parents[y]:
#             x, y = y, x

#         self.parents[x] += self.parents[y]
#         self.parents[y] = x

#     def size(self, x):
#         return -self.parents[self.find(x)]

#     def same(self, x, y):
#         return self.find(x) == self.find(y)

#     def members(self, x):
#         root = self.find(x)
#         return [i for i in range(self.n) if self.find(i) == root]

#     def roots(self):
#         return [i for i, x in enumerate(self.parents) if x < 0]

#     def group_count(self):
#         return len(self.roots())

#     def all_group_members(self):
#         group_members = defaultdict(list)
#         for member in range(self.n):
#             group_members[self.find(member)].append(member)
#         return group_members

#     def __str__(self):
#         return '\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())


# q = []
# heapq.heapify(q)
# path = [[] for _ in range(n*m)]
# for i in range(n):
#     a = list(map(int, input().split()))
#     for j in range(m - 1):
#         edge = (a[j], i*m+j, i*m+j+1)
#         heapq.heappush(q, edge)
# for i in range(n - 1):
#     a = list(map(int, input().split()))
#     for j in range(m):
#         edge = (a[j], i * m + j, m * (i + 1) + j)
#         heapq.heappush(q, edge)

# uf = UnionFind(n * m)

# path = [[] for _ in range(n*m)]

# while q:
#     edge = heapq.heappop(q)
#     cost, v1, v2 = edge
#     if uf.same(v1, v2):
#         continue
#     else:
#         uf.union(v1, v2)
#     path[v1].append((v2, cost))
#     path[v2].append((v1, cost))

# for i in path:
#     print(i)
# # print(path)
# exit()
",cubic,"dp,graphs,shortest paths",3036
"from math import inf
n, m, k = map(int, input().split())
horizontal = []
vertical = []
for _ in range(n):
    horizontal.append(list(map(int, input().split())))
for _ in range(n - 1):
    vertical.append(list(map(int, input().split())))
if k & 1:
    ans = [""-1""] * m
    for _ in range(n):
        print(*ans)
else:
    grid = [[0 for i in range(m)] for j in range(n)]
    for _ in range(k // 2):
        X = [[inf for i in range(m)] for j in range(n)]
        for i in range(n):
            for j in range(m):
                if i >= 1:
                    X[i][j] = min(2 * vertical[i - 1][j] + grid[i - 1][j], X[i][j])
                if i < n - 1:
                    X[i][j] = min(2 * vertical[i][j] + grid[i + 1][j], X[i][j])
                if j >= 1:
                    X[i][j] = min(2 * horizontal[i][j - 1] + grid[i][j - 1], X[i][j])
                if j < m - 1:
                    X[i][j] = min(2 * horizontal[i][j] + grid[i][j + 1], X[i][j])
        #print(X)
        grid = X[:]
    for _ in range(n):
        print(*grid[_])
",cubic,"dp,graphs,shortest paths",1043
"from sys import stdin
input=stdin.readline
def answer():
    dp=[[[1e9 for i in range(k//2 + 1)] for j in range(m)] for i in range(n)]

    for i in range(n):
        for j in range(m):
            dp[i][j][0]=0
    
    for x in range(1,k//2 + 1):

        for i in range(n):
            for j in range(m):

                if(i > 0):
                    dp[i][j][x]=min(dp[i][j][x],dp[i-1][j][x-1] + c[i-1][j])
                if(j > 0):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j-1][x-1] + r[i][j-1])
                if(i + 1 < n):
                    dp[i][j][x]=min(dp[i][j][x],dp[i+1][j][x-1] + c[i][j])
                if(j + 1 < m):
                    dp[i][j][x]=min(dp[i][j][x],dp[i][j+1][x-1] + r[i][j])

    for i in range(n):
        for j in range(m):
            print(2*dp[i][j][-1],end=' ')

        print()



n,m,k=map(int,input().split())

r=[list(map(int,input().split())) for i in range(n)]
c=[list(map(int,input().split())) for i in range(n-1)]

if(k & 1):
    for i in range(n):
        for j in range(m):
            print(-1,end=' ')
    
else:answer()
",cubic,"dp,graphs,shortest paths",1093
"inf=10000000000
n,m,k=(int(i) for i in input().split())
h=[[int(i) for i in input().split()]for i in range(n)]
z=[[int(i) for i in input().split()]for i in range(n-1)]
dh=lambda x,y:h[x][y] if 0<=x<len(h) and 0<=y<len(h[0]) else inf
dz=lambda x,y:z[x][y] if 0<=x<len(z) and 0<=y<len(z[0]) else inf
dp=[[[0 for iii in range(m)] for ii in range(n)] for i in range(2)]
ddp=lambda x,y,z:dp[x][y][z] if 0<=y<n and 0<=z<m else inf
if k%2!=0:
    for i in dp[0]:
        for j in i:
            print(-1,end=' ')
        print()
else:
    for kk in range(int(k/2)):
        for i in range(n):
            for j in range(m):
                dp[1][i][j]=min(ddp(0,i-1,j)+dz(i-1,j),ddp(0,i+1,j)+dz(i,j),ddp(0,i,j-1)+dh(i,j-1),ddp(0,i,j+1)+dh(i,j))
        dp.reverse()
    for i in dp[0]:
        for j in i:
            print(2*j,end=' ')
        print()
",cubic,"dp,graphs,shortest paths",846
"from sys import stdin, stdout
import heapq
from collections import defaultdict
import math
import bisect




def main():
    n,m,k = list(map(int, stdin.readline().split()))
    right = []
    for _ in range(n):
        right.append(list(map(int, stdin.readline().split())))
    down = []
    for _ in range(n-1):
        down.append(list(map(int, stdin.readline().split())))
    if k % 2 == 1:
        for _ in range(n):
            stdout.write("" "".join([""-1"" for _ in range(m)])+""\n"")
        return
    dp = [[0 for _ in range(m)] for _ in range(n)]
    for x in range(1, (k//2) + 1):
        tmp = [[math.inf for _ in range(m)] for _ in range(n)]
        for i in range(n):
            for j in range(m):
                if i:
                    tmp[i][j] = min(tmp[i][j], dp[i-1][j] + 2 * down[i-1][j])
                if i < n-1:
                    tmp[i][j] = min(tmp[i][j], dp[i + 1][j] + 2 * down[i][j])
                if j:
                    tmp[i][j] = min(tmp[i][j], dp[i][j - 1] + 2 * right[i][j - 1])
                if j < m-1:
                    tmp[i][j] = min(tmp[i][j], dp[i][j + 1] + 2 * right[i][j])
        dp = tmp
        #print(dp)
    for i in range(n):
        stdout.write("" "".join([str(x) for x in dp[i]]) + ""\n"")

main()",cubic,"dp,graphs,shortest paths",1257
"def main():
    N, M, K = map(int, input().split())

    if K % 2:
        print((""-1 "" * M + ""\n"") * N)
        return

    colEdges = []
    for i in range(N):
        edges = list(map(int, input().split()))
        colEdges.append(edges)
    
    rowEdges = []
    for i in range(N - 1):
        edges = list(map(int, input().split()))
        rowEdges.append(edges)
    
    dp = [[[0 for i in range(M)] for j in range(N)] for k in range(2)]
    p = [[[(i, j) for j in range(M)] for i in range(N)] for k in range(2)]
    prev = 0
    for k in range(K // 2):
        cur = prev ^ 1
        for i in range(N):
            for j in range(M):
                cand = (float('inf'), None)

                if j:
                    nxt = (dp[prev][i][j - 1] + colEdges[i][j - 1], p[prev][i][j - 1])
                    cand = min(cand, nxt)
                if j < M - 1:
                    nxt = (dp[prev][i][j + 1] + colEdges[i][j], p[prev][i][j + 1])
                    cand = min(cand, nxt)
                if i:
                    nxt = (dp[prev][i - 1][j] + rowEdges[i - 1][j], p[prev][i - 1][j])
                    cand = min(cand, nxt)
                if i < N - 1:
                    nxt = (dp[prev][i + 1][j] + rowEdges[i][j], p[prev][i + 1][j])
                    cand = min(cand, nxt)
                
                dp[cur][i][j], p[cur][i][j] = cand
        prev = cur
    
    for i in range(N):
        for j in range(M):
             print(dp[prev][i][j] * 2, end="" "")
        print()
main()",cubic,"dp,graphs,shortest paths",1512
"I=lambda:[*map(int, input().split())]
R = range
m = min
N, M, K = I()
R = range

if K&1:
	for _ in R(N):
		print(*[-1]*M)
	exit()
A = [I() for _ in R(N)]
B = [I() for _ in R(N-1)]
X = [M*[0]for _ in R(N)]
for k in R(1, K//2+1):
	Y = [M*[9**9]for _ in R(N)]
	for i in R(N):
		for j in R(M):
			if i:
				Y[i][j] = X[i-1][j] + 2*B[i-1][j]
			if i<N-1:
				Y[i][j] = m(Y[i][j], X[i+1][j] + 2*B[i][j])
			if j:
				Y[i][j] = m(Y[i][j], X[i][j-1] + 2*A[i][j-1])
			if j<M-1:
				Y[i][j] = m(Y[i][j], X[i][j+1] + 2*A[i][j])
	X = Y
for x in X:
	print(*x)",cubic,"dp,graphs,shortest paths",547
"import sys,math
class Node:
    def __init__(self,u=math.inf,d=math.inf,l=math.inf,r=math.inf):
        self.up=u
        self.dn=d
        self.lt=l
        self.rt=r
    def __str__(self):
        return 'U:{},D:{},L:{},R:{}'.format(self.up,self.dn,self.lt,self.rt)

n,m,k=list(map(int,sys.stdin.readline().strip().split()))
graph=[[Node() for j in range(m)]for i in range(n)]
for i in range(n):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m-1):
        graph[i][j].rt=wts[j]
        graph[i][j+1].lt=wts[j]

for i in range(n-1):
    wts=list(map(int,sys.stdin.readline().strip().split()))
    for j in range(m):
        graph[i][j].dn=wts[j]
        graph[i+1][j].up=wts[j]

ans=[[math.inf for j in range(m)]for i in range(n)]

if k%2:
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]
    
else:
    def bfs(prsnt,stps):
        # print(prsnt,stps)
        if stps==0:
            return 0
        else:
            if dp[prsnt[0]][prsnt[1]][stps]==math.inf:
                min_cost=math.inf
                for x,y,c in [(0,1,graph[prsnt[0]][prsnt[1]].dn),(1,0,graph[prsnt[0]][prsnt[1]].rt),(0,-1,graph[prsnt[0]][prsnt[1]].up),(-1,0,graph[prsnt[0]][prsnt[1]].lt)]:
                    if -1<prsnt[1]+x<m and -1<prsnt[0]+y<n:
                        min_cost=min(bfs((prsnt[0]+y,prsnt[1]+x),stps-1)+c,min_cost)
                dp[prsnt[0]][prsnt[1]][stps]=min_cost
                return min_cost
            else:
                return dp[prsnt[0]][prsnt[1]][stps]

    dp=[[[math.inf for k in range(k+1)] for j in range(m)]for i in range(n)]
    for i in range(n):
        for j in range(m):
            ans[i][j]=bfs((i,j),k//2)*2
    [[print(' '.join(list(map(lambda x:str(-1) if x==math.inf else str(x),s))))]for s in ans]",cubic,"dp,graphs,shortest paths",1812
"def main():
    import sys
    read = sys.stdin.read
    readline = sys.stdin.readline
    INF = 1 << 60
    MOD = 10 ** 9 + 7
    sys.setrecursionlimit(10 ** 5)
    """"""+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-:+:-+:-""""""

    def new_dp():
        return [[INF] * M for _ in range(N)]

    def solve():
        if K % 2 == 1:
            for row in range(N):
                print(*[-1] * M)
            return

        dp_prev = [[0] * M for _ in range(N)]

        for _ in range(K // 2):
            dp_cur = new_dp()
            for row in range(N):
                for col in range(M - 1):
                    cost = e1[row][col]
                    dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row][col + 1] + cost)
                    dp_cur[row][col + 1] = min(dp_cur[row][col + 1], dp_prev[row][col] + cost)
            for row in range(N - 1):
                for col in range(M):
                    cost = e2[row][col]
                    dp_cur[row][col] = min(dp_cur[row][col], dp_prev[row + 1][col] + cost)
                    dp_cur[row + 1][col] = min(dp_cur[row + 1][col], dp_prev[row][col] + cost)
            dp_prev = dp_cur

        for row in range(N):
            _r = [2 * x for x in dp_prev[row]]
            print(*_r)

    N, M, K = map(int, readline().split())

    e1 = []
    for _ in range(N):
        r = tuple(map(int, readline().split()))
        e1.append(r)
    e2 = []

    for _ in range(N - 1):
        r = tuple(map(int, readline().split()))
        e2.append(r)
    solve()


if __name__ == '__main__':
    main()
",cubic,"dp,graphs,shortest paths",1570
"from collections import defaultdict
from sys import stdout,stdin
n,m,K=map(int,input().split())
dp=[[[0 for h in range(11)]for j in range(m+1)] for i in range(n+1)]
l1=[list(map(int,stdin.readline().split())) for i in range(n)]#i,j i,j+1
l2=[list(map(int,stdin.readline().split())) for i in range(n-1)]#i,j i+1,j
if K%2:
    for i in range(n):
        for j in range(m):
            print('-1',end=' ')
        print()
else:
    for k in range(1,K//2+1):
     for i in range(n):
        for j in range(m):
                res=100000000
                if i-1>=0 and j>=0:
                     res=min(res,l2[i-1][j]+dp[i-1][j][k-1])
                if i+1<n and j>=0:
                     res=min(res,l2[i][j]+dp[i+1][j][k-1])
                if 0<=i and j+1<m:
                     res=min(res,l1[i][j]+dp[i][j+1][k-1])
                if 0<=i and j-1>=0:
                     res=min(res,l1[i][j-1]+dp[i][j-1][k-1])
                dp[i][j][k]=res
    for i in range(n):
        for j in range(m):
            stdout.write(str(2*dp[i][j][K//2])+' ')
        stdout.write('\n')",cubic,"dp,graphs,shortest paths",1078
"def solve(mat1: list, mat2: list, K: int) -> list:
    if K % 2 == 1:
        res = [[-1] * n for _ in range(m)]
    else:
        # dp[i][j][k]为从任意地方走到(i, j)且只走k步的最小无聊数
        dp = [[[-1] * (K // 2 + 1) for _ in range(n)] for _ in range(m)]
        for k in range(K // 2 + 1):
            for i in range(m):
                for j in range(n):
                    if k == 0:
                        dp[i][j][k] = 0
                    else:
                        if i > 0 and (dp[i][j][k] == -1 or dp[i - 1][j][k - 1] + mat2[i - 1][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i - 1][j][k - 1] + mat2[i - 1][j]
                        if i < m - 1 and (dp[i][j][k] == -1 or dp[i + 1][j][k - 1] + mat2[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i + 1][j][k - 1] + mat2[i][j]
                        if j > 0 and (dp[i][j][k] == -1 or dp[i][j - 1][k - 1] + mat1[i][j - 1] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j - 1][k - 1] + mat1[i][j - 1]
                        if j < n - 1 and (dp[i][j][k] == -1 or dp[i][j + 1][k - 1] + mat1[i][j] < dp[i][j][k]):
                            dp[i][j][k] = dp[i][j + 1][k - 1] + mat1[i][j]
        res = [[-1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                res[i][j] = 2 * dp[i][j][-1]
    for i in range(m):
        for j in range(n):
            if j < n - 1:
                print(res[i][j], end = ' ')
            else:
                print(res[i][j])
    return
                        


m, n, K = map(int, input().split())
mat1 = []
mat2 = []
for _ in range(m):
    mat1.append(list(map(int, input().split())))
for _ in range(m - 1):
    mat2.append(list(map(int, input().split())))
solve(mat1, mat2, K)
",cubic,"dp,graphs,shortest paths",1770
"n, m, k = map(int, input().split())
ea = [list(map(int, input().split()))for _ in range(n)]
eb = [list(map(int, input().split()))for _ in range(n-1)]
dp = [[[10**20]*m for __ in range(n)]for _ in range(k//2+1)]
dp[0] = [[0]*m for _ in range(n)]


def show_ans():
    for line in dp[-1]:
        print(' '.join(map(str, [d*2 for d in line])))


if k % 2:
    for i in range(n):
        print(' '.join(['-1']*m))
    exit()
for t in range(1, k//2+1):
    for i in range(n):
        for j in range(m):
            if i:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i-1][j]+eb[i-1][j])
            if i < n-1:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i+1][j]+eb[i][j])
            if j:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j-1]+ea[i][j-1])
            if j < m-1:
                dp[t][i][j] = min(dp[t][i][j], dp[t-1][i][j+1]+ea[i][j])
show_ans()






",cubic,"dp,graphs,shortest paths",896
"import sys
import io, os
import math
gcd=math.gcd
ceil=math.ceil
#arr=list(map(int, input().split()))
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
mod1=(10**9)+7
mod2=998244353
def strinp(testcases):
    k=5
    if(testcases==-1 or testcases==1):
        k=1
    f=str(input())
    f=f[2:len(f)-k]
    return f
def alp(a):
    return (ord(a)-ord(""a""))
def main():
    arr=list(map(int, input().split()))
    n=arr[0]
    m=arr[1]
    k=arr[2]
    lrw=[0]*n
    for i in range(n):
        lrw[i]=list(map(int, input().split()))
    udw=[0]*(n-1)
    for i in range(n-1):
        udw[i]=list(map(int, input().split()))
    if(k%2==1):
        a=[-1]*m
        for i in range(n):
            print(*a)
        sys.exit()
    dp1=[[0 for i in range(m)] for j in range(n)]
    dp2=[[0 for i in range(m)] for j in range(n)]
    inf=10**10
    dis=(k//2)
    for h in range(dis):
        for i in range(n):
            for j in range(m):
                a=inf
                b=inf
                c=inf
                d=inf
                if(j>0):
                    a=lrw[i][j-1]+dp2[i][j-1]
                if(j<m-1):
                    b=lrw[i][j]+dp2[i][j+1]
                if(i>0):
                    c=udw[i-1][j]+dp2[i-1][j]
                if(i<n-1):
                    d=udw[i][j]+dp2[i+1][j]
                dp1[i][j]=min(a,b,c,d)
        dp2=dp1
        dp1=dp1=[[0 for a in range(m)] for b in range(n)]
    for i in range(n):
        for j in range(m):
            dp2[i][j]*=2
    for i in range(n):
        print(*dp2[i])
        
                
if __name__ == '__main__':
    main()",cubic,"dp,graphs,shortest paths",1615
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline    
 
n,m,k = [int(i) for i in input().split()]
h = []
for i in range (n):
    h.append([int(i) for i in input().split()])
v = []
for i in range (n-1):
    v.append([int(i) for i in input().split()])
if k%2:
    for i in range (n):
        for j in range (m):
            print(-1,end="" "")
        print()
    exit()
dp = [[[float('inf')]*m for i in range (n)] for j in range (k//2+1)]
for i in range (n):
    for j in range (m):
        dp[0][i][j] = 0
for x in range (1,k//2+1):
    for i in range (n):
        for j in range (m):
            if i!=0:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i-1][j] + v[i-1][j])
            if i!=n-1:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i+1][j] + v[i][j])
            if j!=0:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j-1] + h[i][j-1])
            if j!=m-1:
                dp[x][i][j] = min(dp[x][i][j], dp[x-1][i][j+1] + h[i][j])
 
for i in range (n):
    for j in range (m):
        print(2*dp[k//2][i][j],end="" "")
    print()",cubic,"dp,graphs,shortest paths",1096
"import sys

#comment these out later
#sys.stdin = open(""in.in"", ""r"")
#sys.stdout = open(""out.out"", ""w"")

#WLOG i, n = x, j, m = y

inp = [int(x) for x in sys.stdin.read().split()]; ii = 0

n = inp[ii]; ii += 1
m = inp[ii]; ii += 1
k = inp[ii]; ii += 1

if k%2 == 1:
	for _ in range(n):
		toprint = [""-1"" for __ in range(m)]
		print("" "".join(toprint))

	sys.exit()


yw = []

for _ in range(n):
	yw.append(inp[ii:ii+m-1])
	ii += m-1


xw = []

for _ in range(n-1):
	xw.append(inp[ii:ii+m])
	ii += m

inf = 10**10

#dp[i][j]

steps = k//2

dp = [[[inf for _ in range(m)] for _ in range(n)] for _ in range(steps+1)]

for i in range(n):
	for j in range(m):
		dp[0][i][j] = 0

#dp[i][j] = min of (1) dp[i][j] (2) dp[i-1][j] + w (3) dp[i][j-1] + w 
#(4) dp[i+1][j] + w (5) dp[i][j+1] + w

for step in range(1, steps + 1):
	for i in range(n):
		for j in range(m):
			#i, j go 1-n, 1-m

			if i > 0:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i-1][j] + xw[i-1][j])

			if i < n-1:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i+1][j] + xw[i][j])

			if j > 0:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j-1] + yw[i][j-1])

			if j < m-1:
				dp[step][i][j] = min(dp[step][i][j], dp[step-1][i][j+1] + yw[i][j])

for x in dp[-1]:
	print("" "".join(list(map(str, [2*o for o in x]))))",cubic,"dp,graphs,shortest paths",1298
"n, m, k = map(int, input().split())
 
h = []
for i in range(n):
  h.append(list(map(int, input().split())))
 
v = []
for i in range(n - 1):
  v.append(list(map(int, input().split())))
 
if k % 2 == 0:
  d = [[0] * m for i in range(n)]
  for t in range(k // 2):
    dt = [[0] * m for i in range(n)]
    for i in range(n):
      for j in range(m):
        x = float('inf')
        if i - 1 >= 0:
          x = min(x, d[i - 1][j] + v[i - 1][j] * 2)
        if i + 1 < n:
          x = min(x, d[i + 1][j] + v[i][j] * 2)
        if j - 1 >= 0:
          x = min(x, d[i][j - 1] + h[i][j - 1] * 2)
        if j + 1 < m:
          x = min(x, d[i][j + 1] + h[i][j] * 2)
        dt[i][j] = x
    d = dt.copy()
else:
  d = [[-1] * m for i in range(n)]
for i in d:
    print(*i)",cubic,"dp,graphs,shortest paths",766
"import sys
sys.stderr = sys.stdout

from math import inf


def explorer(n, m, k, R, C):
    if k % 2:
        return None

    G = [[0] * m for _ in range(n)]
    G_ = [[0] * m for _ in range(n)]
    for _ in range(k // 2):
        for i in range(n):
            for j in range(m):
                x = inf
                if i > 0:
                    x = min(x, G[i-1][j] + 2*C[i-1][j])
                if i + 1 < n:
                    x = min(x, G[i+1][j] + 2*C[i][j])
                if j > 0:
                    x = min(x, G[i][j-1] + 2*R[i][j-1])
                if j + 1 < m:
                    x = min(x, G[i][j+1] + 2*R[i][j])
                G_[i][j] = x
        G, G_ = G_, G
    return G


def main():
    n, m, k = readinti()
    R = readintll(n)
    C = readintll(n-1)
    G = explorer(n, m, k, R, C)
    if G:
        print(llstr(G))
    else:
        s = ' '.join('-1' for _ in range(m))
        print('\n'.join(s for _ in range(n)))

##########

def readint():
    return int(input())


def readinti():
   return map(int, input().split())


def readintt():
   return tuple(readinti())


def readintl():
   return list(readinti())


def readinttl(k):
    return [readintt() for _ in range(k)]


def readintll(k):
    return [readintl() for _ in range(k)]

def lstr(l):
    return ' '.join(map(str, l))

def llstr(ll):
    return '\n'.join(map(lstr, ll))


def log(*args, **kwargs):
    print(*args, **kwargs, file=sys.__stderr__)


if __name__ == '__main__':
    main()
",cubic,"dp,graphs,shortest paths",1488
"import sys
sys.setrecursionlimit(50000)
for _ in range(1):
    n,m,k = map(int,input().split())
    s = [[[-1,-1,-1,-1] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        d = [int(x) for x in input().split()]
        for j in range(m-1):
            s[i][j][1] = d[j]
            s[i][j+1][3] = d[j]
    for i in range(n-1):
        d = [int(x) for x in input().split()]
        for j in range(m):
            s[i][j][2] = d[j]
            s[i+1][j][0] = d[j]
    if k%2==1:
        for i in range(n):
            print(*[-1 for _ in range(m)])
        continue
    dp = [[[9999999 for _ in range(k//2+1)] for _ in range(m)] for _ in range(n)]
    for i in range(n):
        for j in range(m):
            dp[i][j][0] = 0
    for q in range(1,k//2+1):
        for i in range(n):
            for j in range(m):
                cands = []
                if i > 0:
                    cands.append(dp[i-1][j][q-1] + s[i-1][j][2])
                if j > 0:
                    cands.append(dp[i][j-1][q-1] + s[i][j-1][1])
                if i < n - 1:
                    cands.append(dp[i+1][j][q-1] + s[i+1][j][0])
                if j < m - 1:
                    cands.append(dp[i][j+1][q-1] + s[i][j+1][3])
                dp[i][j][q] = min(cands)
    for i in range(n):
        for j in range(m):
            print(2*dp[i][j][k//2],end=' ')
        print()",cubic,"dp,graphs,shortest paths",1377
"import sys
import math
import collections
import heapq
import decimal
input=sys.stdin.readline
n,m,k = map(int,input().split())
a=[]
for i in range(n):
    a.append(list(map(int,input().split())))
b=[]
for i in range(n-1):
    b.append(list(map(int,input().split())))
if(k%2==1):
    for i in range(n):
        for j in range(m):
            print(-1,end = "" "")
        print()
else:
    k//=2
    pre=[[0 for i in range(m)]for j in range(n)]
    for x in range(k):
        curr = [[float(""inf"") for i in range(m)]for j in range(n)]
        for i in range(n):
            for j in range(m):
                if(j>0):
                    curr[i][j]=min(curr[i][j],pre[i][j-1]+a[i][j-1])
                if(i<n-1):
                    curr[i][j]=min(curr[i][j],pre[i+1][j]+b[i][j])
                if(j<m-1):
                    curr[i][j]=min(curr[i][j],pre[i][j+1]+a[i][j])
                if(i>0):
                    curr[i][j]=min(curr[i][j],pre[i-1][j]+b[i-1][j])
        pre=curr[:]
    for i in range(n):
        for j in range(m):
            print(2*pre[i][j],end = "" "")
        print()",cubic,"dp,graphs,shortest paths",1093
"n, m, K=map(int, input().split())
edgesh=[[0 for i in range(m-1)] for k in range(n)]
#edgesh[i][j] is the weight of the edge between i, j and i, j+1
edgesv=[[0 for i in range(m)] for k in range(n-1)]
#edgesv[i][j] is the weight of the edge between i, j and i+1, j
for mm in range(n):
    edgesh[mm]=list(map(int, input().split("" "")))
for mm in range(n-1):
    edgesv[mm]=list(map(int, input().split("" "")))
dp=[[[10**10 for tro in range(K+1)] for i in range(m)] for mm in range(n)]
for k in range(0, K+1, 2):
 for i in range(n):
  for j in range(m):
    if(k==0):
      dp[i][j][k]=0
    elif(i==0 and j==0):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])
    elif(i==0 and j==m-1):
      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])
    elif(i==0):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])
    elif(j==0 and i==n-1):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2])
    elif(j==0):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])
    elif(i==n-1 and j==m-1):
      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2])
    elif(i==n-1):
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])
    elif(j==m-1):
      dp[i][j][k]=min(2*edgesh[i][j-1]+dp[i][j-1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2])
    else:
      dp[i][j][k]=min(2*edgesh[i][j]+dp[i][j+1][k-2], 2*edgesv[i-1][j]+dp[i-1][j][k-2], 2*edgesv[i][j]+dp[i+1][j][k-2], 2*edgesh[i][j-1]+dp[i][j-1][k-2])
for i in range(n):
  for j in range(m):
   if(dp[i][j][K]>=10**10):
    print(-1, end="" "")
   else:
    print(dp[i][j][K], end="" "")
  print()",cubic,"dp,graphs,shortest paths",1900
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[[float('inf')] * (k // 2 + 1) for _ in range(m)] for _ in range(n)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j][0] = 0

for k1 in range(1, k // 2 + 1):
    for i in range(n):
        for j in range(m):
            ans = []
            if valid(i - 1, j):
                ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])
            if valid(i + 1, j):
                ans.append(mem[i + 1][j][k1 - 1] + down[i][j])
            if valid(i, j - 1):
                ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])
            if valid(i, j + 1):
                ans.append(mem[i][j + 1][k1 - 1] + right[i][j])

            mem[i][j][k1] = min(ans)

[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]

",cubic,"dp,graphs,shortest paths",3270
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[[float('inf')] * (k // 2 + 1) for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j][0] = 0

for k1 in range(1, k // 2 + 1):
    for i in range(n):
        for j in range(m):
            ans = []
            ans.append(mem[i - 1][j][k1 - 1] + down[i - 1][j])
            ans.append(mem[i + 1][j][k1 - 1] + down[i][j])
            ans.append(mem[i][j - 1][k1 - 1] + right[i][j - 1])
            ans.append(mem[i][j + 1][k1 - 1] + right[i][j])
            mem[i][j][k1] = min(ans)

[print(*[mem[i][x][-1] * 2 for x in range(m)]) for i in range(n)]
",cubic,"dp,graphs,shortest paths",3132
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j] = 0

for k1 in range(1, k // 2 + 1):
    mem0 = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]
    for i in range(n):
        for j in range(m):
            mem0[i][j] = min(mem[i - 1][j] + down[i - 1][j], mem[i + 1][j] + down[i][j],
                             mem[i][j - 1] + right[i][j - 1], mem[i][j + 1] + right[i][j])

    mem = mem0

[print(*[mem[i][x] * 2 for x in range(m)]) for i in range(n)]
",cubic,"dp,graphs,shortest paths",3072
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: list(map(dtype, input().split()))
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + [inp(dtype)] for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
valid = lambda x, y: -1 < x < n and -1 < y < m
dx, dy = (0, 1, 0, -1, 1, -1, 1, -1), (1, 0, -1, 0, 1, -1, -1, 1)

n, m, k = inp(int)
if k & 1:
    [print(*([-1] * m)) for _ in range(n)]
    exit()

right, down = [[0] * m for _ in range(n)], [[0] * m for _ in range(n)]
mem = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]

for _ in range(n):
    for i, j in enumerate(inp(int)):
        right[_][i] = j

for _ in range(n - 1):
    for i, j in enumerate(inp(int)):
        down[_][i] = j

for i in range(n):
    for j in range(m):
        mem[i][j] = 0

for k1 in range(1, k // 2 + 1):
    mem0 = [[float('inf') for _ in range(m + 1)] for _ in range(n + 1)]
    for i in range(n):
        for j in range(m):
            mem0[i][j] = min(mem[i - 1][j] + down[i - 1][j], mem[i + 1][j] + down[i][j],
                             mem[i][j - 1] + right[i][j - 1], mem[i][j + 1] + right[i][j])

    mem = mem0

[print(*[mem[i][x] * 2 for x in range(m)]) for i in range(n)]
",cubic,"dp,graphs,shortest paths",3070
"def permuteDigits(a, b):
    
    n = len(a)
    if len(a) < len(b):
        return a
        
    i = 0
    c = 0
    t = a[0]
    flag = 0
    lastind = []
    while i<len(a) and i< len(b) and a[i] >= b[i] :
#        print(""i:"",i,""c:"",c,""  a:"",a,""  b:"",b)
        
        if c == n:
            i = i - 1
            t = a[i]
            a = a[:i] + a[i+1:]
            a.insert(lastind.pop(),t)
            flag = 1
            c = i
        elif (flag == 0 and a[c] == b[i]) or a[c] < b[i]:        
            lastind.append(c)
            t = a[c]            
            a = a[:c] + a[c+1:]
#            print(""i:"",i,""  a:"",a,""  b:"",b,""  t:"",t,""  c:"",c,""  li:"",lastind)
            a.insert(i,t)
#            print(""i:"",i,""  a:"",a,""  b:"",b,""  t:"",t,""  c:"",c,""  li:"",lastind)        
        else:
            c = c + 1

        if a[i] < b[i]:
            break
        elif flag == 0 and a[i] == b[i]:
            i = i + 1                
            c = i            
#        print(""i:"",i,""  a:"",a,""  b:"",b,""  t:"",t,""  c:"",c)            
    return a

#     98175987
# Ans 98598771
#     98598771
# Lim 98715689
    
aa = input()
bb = input()

a=[]
b=[]
for i in aa:
    a.append(int(i))
for i in bb:
    b.append(int(i))

a.sort(reverse=True)

ans = permuteDigits(a, b)
s = """"
for i in ans:
    s = s + str(i)
print(int(s))",cubic,"dp,greedy",1336
"#########################################################################################################\
#########################################################################################################
###################################The_Apurv_Rathore#####################################################
#########################################################################################################
#########################################################################################################

import sys,os,io
from math import log, gcd, ceil
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from bisect import bisect_right , bisect_left

import math 



def ncr(n, r, p):  #using fermat's little theorem
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,
                      p - 2, p)) % p

  
def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
          
    for i in range(3,int(math.sqrt(n))+1,2): 
          

        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    return list(set(l))
    
def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 


def si():
    return input()


def prefix_sum(arr):
    r = [0] * (len(arr)+1)
    for i, el in enumerate(arr):
        r[i+1] = r[i] + el
    return r

def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1

def ii():
    return int(input())

def li():
    return list(map(int,input().split()))

def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')


if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")
# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
# t = int(input())
t = 1
for _ in range(t):
    a = input()
    b = input()
    ans = [a]
    a = list(a)
    b1 = b[:]
    b = list(b)
    if (len(a)<len(b)):
        a.sort(reverse=True)
        print(''.join(a))
        continue
    arr = [0]*10
    for i in a:
        arr[int(i)]+=1
    f = 0
    for chota in range(len(b)):
        arr1 = arr[:]
        temp = b[:chota]

        for h in range(chota):
            if (arr1[int(b[h])]<=0):
                f = 1
                break
            else:
                arr1[int(b[h])]-=1
        
            #print(f)
        if (f==1):
            break
        aa = []
        for j in range(int(b[chota])-1,-1,-1):

            if (arr1[j]>0):
                temp.append(str(j))
                arr1[j]-=1
                break
        for h in range(9,-1,-1):
            if (arr1[h]>0):
                temp+=[str(h)]*arr1[h]
        #print(temp)
        ans.append(''.join(temp))
        
            #print(""yes"",temp)
    for i in ans:
        if (i<=b1):
            m = i
            break 
    a.sort(reverse=True)
    ans.append(''.join(a))
    # print(ans)
    for i in ans:
        if (i<=b1):
            if (i>m):
                m = i
    print(m)



    ",cubic,"dp,greedy",3331
"a=int(input())
b=int(input())
x=[0]*10
while a:
    x[a%10]+=1
    a=a//10
ans=0
for i in range(9,-1,-1):
    for j in range(x[i]):
        ans=ans*10+i
if ans<=b:
    print(ans)
else:
    ans=0
    for j in str(b):
        c=int(j)
        while c>=0 and not x[c]:
            c-=1
        if c<0:
            while True:
                x[ans%10]+=1
                d=ans%10
                ans=ans//10
                flag=0
                for b in range(d-1,-1,-1):

                    if x[b]:
                        ans=ans*10+b
                        x[b]-=1
                        flag=1
                        break
                if flag:
                    break
            break
                        
                
        else:
            x[c]-=1
            ans=ans*10+c
            if c<int(j):
                break

    for j in range(9,-1,-1):
        for i in range(x[j]):
            ans=ans*10+j
    print(ans)
        
",cubic,"dp,greedy",957
"import sys
import bisect

ls2int = lambda ls: int(''.join(map(str,ls)))
def candidates(digs, num):
    if not digs:
        return [[]]
    
    res = []
    i = bisect.bisect_left(digs, num[0])
    
    # lead with same digit
    if num[0] in digs:
        for suffix in candidates(digs[:i]+digs[i+1:], num[1:]):
            res.append([digs[i]] + suffix)
    
    # lead with next smallest digit:
    if i > 0:
        i -= 1
        res.append([digs[i]] + list(reversed(digs[:i]+digs[i+1:])))
    
    return res
    
def solution(a, b):
    digits = [int(x) for x in sorted(a)]
    ceiling = [int(x) for x in b]
    
    assert(len(digits) <= len(ceiling), 'solution does not exist')
    if len(digits) < len(ceiling):
        return ls2int(digits[::-1])
    return max(ls2int(ls) for ls in candidates(digits, ceiling))
    
a = sys.stdin.readline().strip()
b = sys.stdin.readline().strip()
print(solution(a, b))",cubic,"dp,greedy",916
"from collections import defaultdict

def f(b,d):
    fi = int(b[0])
    if len(b)==1:
        j=fi
        while(j>=0):
            if d[j]:
                return str(j)
            j+=-1

        return """"


    fi=int(b[0])
    s=""""
    if d[fi]>0:
        d1=defaultdict(lambda:0)
        for j in d:
            d1[j]=d[j]
        d1[fi]+=-1
        s=f(b[1:],d1)

    if s!="""":
        return str(fi)+s

    else:
        s1=""""
        j=fi-1
        while(j>=0):
            if d[j]>0:
                s1+=str(j)
                d[j]+=-1
                break
            j+=-1
        if s1=="""":
            return """"
        else:
            j=9
            while(j>=0):
                if d[j]==0:
                    j+=-1

                else:
                    s1+=str(j)
                    d[j]+=-1

            return s1












a=input()
b=input()
d=defaultdict(lambda:0)
res=[]
for j in a:
    d[int(j)]+=1
    res.append(int(j))
res.sort(reverse=True)
for j in range(len(a)):
    res[j]=str(res[j])
if len(b)>len(a):
    print("""".join(res))

else:
    print(f(b,d))

",cubic,"dp,greedy",1094
"from collections import Counter


def mx(f):
    res = []
    for k in sorted(f.keys(), reverse=True):
        for _ in range(f[k]):
            res.append(k)
    return res


def solve(n, a, b):
    res = None
    for k in range(n + 1):
        aa = Counter(a)
        cur = []
        for i in range(k):
            if aa[b[i]] == 0:
                return res
            cur.append(b[i])
            aa[b[i]] -= 1
        if k < n:
            for e in range(b[k] - 1, -1, -1):
                if aa[e] > 0:
                    cur.append(e)
                    aa[e] -= 1
                    cur.extend(mx(aa))
                    break
            if len(cur) < n:
                continue
        res = cur
    return res


a = Counter(map(int, input()))
b = list(map(int, input()))
if sum(a.values()) < len(b):
    res = mx(a)
else:
    res = solve(len(b), a, b)
print(''.join(map(str, res)))",cubic,"dp,greedy",900
"a, b = sorted(input()), int(input())
for i in range(len(a)):
	for j in range(i+1, len(a)):
		c = int(str.join('', a))
		a[i], a[j] = a[j], a[i]
		d = int(str.join('', a))
		if c <= d <= b:
		    continue
		else:
		    a[i], a[j] = a[j], a[i]
print(str.join('', a))",cubic,"dp,greedy",264
"import sys
import math
def rec(i,n,l):
    # print(i,l)
    if i == n:
        return []

    else:
        x = l2[i]
        flag = 0
        o = []
        p = []
        mi = -1
        for j in l:
            if j < x:
                if j > mi:
                    if i == 0 and j == 0:
                        o.append(j)
                        p.append(j)
                        continue

                    mi = j

            if x == j:
                flag = 1

            o.append(j)
            p.append(j)

        if flag:
            o.remove(x)

        if mi == -1 and flag == 0:
            return []

        ans1 = []
        if flag:
            # print(i,o)
            ans1 = [x]+rec(i+1,n,o)

        if mi != -1:
            p.remove(mi)

        p.sort(reverse = True)
        ans2 = [mi]+p
        if len(ans1) == n-i:
            return ans1

        else:
            return ans2

for _ in range(1):
    a = int(input())
    b = int(input())
    e1 = str(a)
    e2 = str(b)
    l1 = []
    l2 = []
    for i in e1:
        l1.append(int(i))

    for i in e2:
        l2.append(int(i))

    if len(l1) < len(l2):
        l1.sort(reverse = True)
        o = []
        for i in l1:
            o.append(str(i))

        print("""".join(o))

    else:
        n = len(l2)
        ans = rec(0,n,l1)
        w = []
        for i in ans:
            w.append(str(i))

        print("""".join(w))",cubic,"dp,greedy",1418
"def check(e,value,pre):
    global maxi,count
    e[str(value)]-=1
    pre+=str(value)
    arr=[]
    for i in e:
        for j in range(e[i]):
            arr.append(i)
    arr.sort(reverse=True)
    st=''
    for i in arr:
        st+=str(i)
    alpha=int(pre+st)
    if alpha<=int(b):
        maxi=max(maxi,int(pre+st))


a=input()
b=input()
maxi=0
d={}
for i in a:
    if i not in d:
        d[i]=1
    else:
        d[i]+=1
maxi=0
num=""""
count=0
if len(a)<len(b):
    check(d.copy(),max(d),'')
else:
    for i in b:
        if i in d and d[i]>0:
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            check(d.copy(),i,num)
            num+=i
            d[i]-=1

        else:
            j=0
            for j in range(int(i)-1,-1,-1):
                if str(j) in d and d[str(j)]>0:
                    check(d.copy(),j,num)
                    break
            break
print(maxi)",cubic,"dp,greedy",1004
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input().rstrip()))
    b=list(map(int,input().rstrip()))
    ans,la,lb=[],len(a),len(b)
    if la!=lb:
        print(*sorted(a,reverse=True),sep="""")
    else:
        for i in range(lb):
            if b[i] in a:
                ans.append(b[i])
                a.remove(b[i])
            else:
                ma=-1
                for j in a:
                    if j<b[i]:
                        ma=max(ma,j)
                if ma!=-1:
                    ans.append(ma)
                    a.remove(ma)
                else:
                    i-=1
                    while ans:
                        a.append(ans.pop())
                        ma=-1
                        for j in a:
                            if j<b[i]:
                                ma=max(ma,j)
                        if ma!=-1:
                            ans.append(ma)
                            a.remove(ma)
                            break
                        i-=1
                a.sort()
                while a:
                    ans.append(a.pop())
                break
        print("""".join(str(i) for i in ans))


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic,"dp,greedy",2973
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input().rstrip()))
    b=list(map(int,input().rstrip()))
    ans,la,lb=[],len(a),len(b)
    if la!=lb:
        print(*sorted(a,reverse=True),sep="""")
    else:
        for i in range(lb):
            if b[i] in a:
                ans.append(b[i])
                a.remove(b[i])
            else:
                while i>-1:
                    ma=-1
                    for j in a:
                        if j<b[i]:
                            ma=max(ma,j)
                    if ma!=-1:
                        ans.append(ma)
                        a.remove(ma)
                        break
                    i-=1
                    a.append(ans.pop())
                a.sort()
                while a:
                    ans.append(a.pop())
                break
        print("""".join(str(i) for i in ans))


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic,"dp,greedy",2670
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase

def main():
    a=list(map(int,input().rstrip()))
    b=list(map(int,input().rstrip()))
    ans,la,lb=[],len(a),len(b)
    if la!=lb:
        print(*sorted(a,reverse=True),sep="""")
    else:
        for i in range(lb):
            if b[i] in a:
                ans.append(b[i])
                a.remove(b[i])
            else:
                while i>-1:
                    ma=-1
                    for j in a:
                        if j<b[i]:
                            ma=max(ma,j)
                    if ma!=-1:
                        ans.append(ma)
                        a.remove(ma)
                        break
                    i-=1
                    a.append(ans.pop())
                a.sort()
                while a:
                    ans.append(a.pop())
                break
        print(*ans,sep="""")


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",cubic,"dp,greedy",2653
"a = sorted(input())
b = int(input())
a = a[::-1] #reverse a
p = ''
cnt = [0]*10

while a :
    for i, d in enumerate(a):
        n = p + d + """".join(sorted(a[:i]+a[i+1:]))
        if int(n) <= b :
            p += d
            a.pop(i)
            break
        
print(p)",cubic,"dp,greedy",272
"from collections import defaultdict
from collections import Counter
from collections import deque
import heapq

inf = float('inf')
ninf = float('-inf')

M1 = 10**9 + 7
M2 = 998244353

def li():
    return list(map(int,input().split()))

def pre():
    ""Start""

def solve():
    a = input()
    b = input()
    n = len(a)
    if(len(a)<len(b)):
        a = sorted(list(a),reverse = True)
        print("""".join(a))
        return
    b = int(b)
    ans = 0
    cnt = [0]*10
    for i in range(n):
        cnt[ord(a[i])-ord('0')] += 1

    def getrem(k):
        cnt[k] -= 1
        ans = """"
        for i in range(10):
            for j in range(cnt[i]):
                ans += str(i)
        cnt[k] += 1
        return ans

    prev = """"
    for i in range(n):
        for j in range(9,-1,-1):
            if(cnt[j]>0):
                newval = prev + str(j)+ getrem(j)
                if(int(newval)<=b):
                    ans = max(ans,int(newval))
                    prev += str(j)
                    cnt[j] -= 1
                    break
    print(ans)


pre()

__ = 1
#__ = int(input())
for _ in range(__):
    solve()",cubic,"dp,greedy",1126
"success = 0
def solve(b, freq, i, n, res):
    global success
    if i == len(b):
        success = res
    else:
        success = 0
        move = 9
        while move >= 0 and success == 0:
            m = int(b[i])
            if freq[move] > 0 and res * 10 + move <= n * 10 + m:
                res = res * 10 + move
                n = n * 10 + m
                freq[move] -= 1
                if solve(b, freq, i + 1, n, res) == 0:
                    res //= 10
                    n //= 10
                    freq[move] += 1
            move -= 1
    return success

a = input()
b = input()
freq = []
for i in range(10):
    freq.append(0)
v = []
for x in a:
    n = int(x)
    v.append(n)
    freq[n] += 1
v.sort()
ans = 0
if len(b) > len(a):
    m = 1
    for x in v:
        ans = x * m + ans
        m *= 10
else:
    ans = solve(b, freq, 0, 0, 0)
print(ans)",cubic,"dp,greedy",873
"from sys import maxsize, stdout, stdin,stderr
mod = int(1e9+7)
import sys
def I(): return int(stdin.readline())
def lint(): return [int(x) for x in stdin.readline().split()]
def S(): return input().strip()
def grid(r, c): return [lint() for i in range(r)]
from collections import defaultdict, Counter, deque
import math
import heapq
from heapq import heappop , heappush
import bisect
from itertools import groupby
def gcd(a,b): 
    while b:
        a %= b
        tmp = a
        a = b
        b = tmp
    
    return a
 
def lcm(a,b): 
    return a  // gcd(a, b) * b
 
def check_prime(n):
    for i in range(2, int(n ** (1 / 2)) + 1):
        if not n % i:
            return False
    return True
def Bs(a, x):
    i=0
    j=0
    left = 1
    right = x
    flag=False
    while left<right:
        
        mi = (left+right)//2
        #print(smi,a[mi],x)
        
        if a[mi]<=x:
            left = mi+1
            i+=1
            
        else:
 
            right = mi
            j+=1
        #print(left,right,""----"")
    #print(i-1,j)
    if left>0 and a[left-1]==x:
        return i-1, j
    else:
        return -1, -1
def nCr(n, r):
 
    return (fact(n) // (fact(r)
                * fact(n - r)))
 
# Returns factorial of n
def fact(n):
 
    res = 1
     
    for i in range(2, n+1):
        res = res * i
         
    return res
def primefactors(n):
    num=0
    
    while n % 2 == 0:
        num+=1
        n = n / 2
    
    for i in range(3,int(math.sqrt(n))+1,2):
         
    
        while n % i== 0:
            num+=1
            n = n // i
               
    
    if n > 2:
        num+=1
    return num
'''
def iter_ds(src):
    store=[src]
    while len(store):
        tmp=store.pop()
        if not vis[tmp]:
            vis[tmp]=True
            for j in ar[tmp]:
                store.append(j)
'''
def ask(a):
    print('? {}'.format(a),flush=True)
    n=I()
    
    return n


 
def dfs(i,p):
    
    a,tmp=0,0
    for j in d[i]:
        if j!=p:
            a+=1
            tmp+=dfs(j,i)
    
    if a==0:
        return 0
    
    return tmp/a + 1 
def primeFactors(n):
    l=[]
    
    while n % 2 == 0:
        l.append(2)
        n = n // 2
         

    if n > 2:
        l.append(n)
    return l
a = sorted(input())
b = int(input())
a = a[::-1] #reverse a
p = ''
cnt = [0]*10
 
while a :
    for i, d in enumerate(a):
        n = p + d + """".join(sorted(a[:i]+a[i+1:]))
        
        if int(n) <= b :
            p += d
            a.pop(i)
            
            break
        
print(p)










    




",cubic,"dp,greedy",2569
"a=input()
b=input()
na=len(a)
nb=len(b)
def fs(a,b):
	try:
		for i in range(a+1,len(b)):
			if b[a]>b[i]:
				ans=b[i]
				k=b.copy()
				k.pop(i)
				ans+="""".join(k)
				return ans
		return False
	except:
		return False
if(na<nb):
	print("""".join(sorted(list(a),reverse=True)))
else:
	if(a==b):
		print(a)
		
	else:
		l=sorted(list(a),reverse=True)
		l2=l.copy()
		ans1=""""
		flag=0
		ans=[]
		for i in b:
			for j in range(len(l)):
				if i==l[j]:
					k=fs(j,l)
					if(k!=False):
						ans.append(ans1+fs(j,l))
					ans1+=l[j]
					l.pop(j)
					break
				if i>l[j]:
					ans1+=l[j]
					l.pop(j)
					flag=1
					break
			if(flag==1):
				break
		ans1+="""".join(l)
		if(int(ans1)<=int(b)):
			print(ans1)
		else:
			for i in sorted([int(i) for i in ans],reverse=True):
				if(i<=int(b)):
					print(i)
					break",cubic,"dp,greedy",814
"a=input()
b=input()
na=len(a)
nb=len(b)
def fs(a,b):
	try:
		for i in range(a+1,len(b)):
			if b[a]>b[i]:
				ans=b[i]
				k=b.copy()
				k.pop(i)
				ans+="""".join(k)
				return ans
		return False
	except:
		return False
if(na<nb):
	print("""".join(sorted(list(a),reverse=True)))
else:
	if(a==b):
		print(a)
		
	else:
		l=sorted(list(a),reverse=True)
		l2=l.copy()
		ans1=""""
		flag=0
		ans=[]
		for i in b:
			for j in range(len(l)):
				if i==l[j]:
					k=fs(j,l)
					if(k!=False):
						ans.append(ans1+fs(j,l))
					ans1+=l[j]
					l.pop(j)
					break
				if i>l[j]:
					ans1+=l[j]
					l.pop(j)
					flag=1
					break
			if(flag==1):
				break
		ans1+="""".join(l)
		if(int(ans1)<=int(b)):
			print(ans1)
		else:
			for i in sorted([int(i) for i in ans],reverse=True):
				if(i<=int(b)):
					print(i)
					break
  		  	 	    				   	 		   	",cubic,"dp,greedy",843
"from bisect import insort,bisect_right,bisect_left
from sys import stdout, stdin, setrecursionlimit
from heapq import heappush, heappop, heapify 
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import * 
from string import *
from queue import *
from math import *
from re import *
from os import *

# sqrt,ceil,floor,factorial,gcd,log2,log10,comb

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
graph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())
def getStr(): return input()
def getInt(): return int(input())
def listStr(): return list(input())
def getStrs(): return input().split()
def isInt(s): return '0' <= s[0] <= '9'
def input(): return stdin.readline().strip()
def zzz(): return [int(i) for i in input().split()]
def output(answer, end='\n'): stdout.write(str(answer) + end)
def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))


def getPrimes(N = 10**5):
    SN = int(sqrt(N))
    sieve = [i for i in range(N+1)]
    sieve[1] = 0
    for i in sieve:
        if i > SN:
            break
        if i == 0:
            continue
        for j in range(2*i, N+1, i):
            sieve[j] = 0
    prime = [i for i in range(N+1) if sieve[i] != 0] 
    return prime
def primeFactor(n,prime=getPrimes()):
    lst = []
    mx=int(sqrt(n))+1
    for i in prime:
        if i>mx:break
        while n%i==0:
            lst.append(i)
            n//=i
    if n>1:
        lst.append(n)
    return lst    

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]
daysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --Try & again try, maybe you're just one statement away!

""""""
##################################################---START-CODING---###############################################


a = int(stdin.readline())
b = getInt()
 
ans = ''
 
c = sorted(list(str(a)))
 
while c:
    for i in range(len(c) - 1, -1, -1):
        if int(''.join(list(ans) + [c[i]] + c[:i] + c[i + 1:])) <= b:
            ans += c[i]
            c.pop(i)
            break
 
stdout.write(ans)

",cubic,"dp,greedy",3859
"from bisect import insort,bisect_right,bisect_left
from sys import stdout, stdin, setrecursionlimit
from heapq import heappush, heappop, heapify 
from io import BytesIO, IOBase
from collections import *
from itertools import *
from random import * 
from string import *
from queue import *
from math import *
from re import *
from os import *

# sqrt,ceil,floor,factorial,gcd,log2,log10,comb

####################################---fast-input-output----#########################################


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = read(self._fd, max(fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


stdin, stdout = IOWrapper(stdin), IOWrapper(stdout)
graph, mod, szzz =  {}, 10**9 + 7, lambda: sorted(zzz())
def getStr(): return input()
def getInt(): return int(input())
def listStr(): return list(input())
def getStrs(): return input().split()
def isInt(s): return '0' <= s[0] <= '9'
def input(): return stdin.readline().strip()
def zzz(): return [int(i) for i in input().split()]
def output(answer, end='\n'): stdout.write(str(answer) + end)
def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))


def getPrimes(N = 10**5):
    SN = int(sqrt(N))
    sieve = [i for i in range(N+1)]
    sieve[1] = 0
    for i in sieve:
        if i > SN:
            break
        if i == 0:
            continue
        for j in range(2*i, N+1, i):
            sieve[j] = 0
    prime = [i for i in range(N+1) if sieve[i] != 0] 
    return prime
def primeFactor(n,prime=getPrimes()):
    lst = []
    mx=int(sqrt(n))+1
    for i in prime:
        if i>mx:break
        while n%i==0:
            lst.append(i)
            n//=i
    if n>1:
        lst.append(n)
    return lst    

dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]
daysInMounth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]


#################################################---Some Rule For Me To Follow---#################################
""""""
    --instants of Reading problem continuously try to understand them.

    --Try & again try, maybe you're just one statement away!

""""""
##################################################---START-CODING---###############################################


a = getInt()
b = getInt()


arr = list(str(a))

arr = sorted(arr)
ans=''

while arr:
    for i in range(len(arr)-1,-1,-1):
        x=ans+arr[i]

        for j in arr[:i]:
            x+=j
        for j in arr[i+1:]:
            x+=j
        if int(x)<=b:
            ans+=arr[i]
            arr.pop(i)
            break

print(ans)",cubic,"dp,greedy",3908
"a=''.join(reversed(sorted(input())))
b=int(input())
r=''
while len(a)>0:
    for i in range(len(a)):
        n=r+a[i]+''.join(sorted(a[:i]+a[i+1:]))
        if int(n)<=b:
            r+=a[i]
            a=a[:i]+a[i+1:]
            break
print(r)",cubic,"dp,greedy",245
"from sys import stdin, stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))

for _ in range(1):#nmbr()):
    sa=sorted(input(), reverse=True)
    na=len(sa)
    sb=input()
    nb=len(sb)
    if nb>na:
        print(''.join(sa))
        continue
    ans=''
    while sa:
        for i in range(len(sa)):
            new=ans+sa[i]+''.join(sorted(sa[:i]+sa[i+1:]))
            if int(new)<=int(sb):
                ans+=sa[i]
                sa.pop(i)
                break
    print(ans)",cubic,"dp,greedy",513
"def main():
    mod=1000000007
    # mod=998244353
    # nCr =  make_nCr_mod()
    
    tc=1
    for _ in range(tc):
        a=list(rs())
        b=list(rs())
        
        if len(a)<len(b):
            ws(''.join(sorted(a)[::-1]))
        else:
            a=sorted(a)
            ans=[]
            sa=SortedList(a)
            for i in range(len(a)-1):
                for j in range(len(sa)-1,-1,-1):
                    temp=ans+[sa[j]]
                    sa.discard(sa[j])
                    for k in sa:
                        temp.append(k)
                    
                    if temp<=b:
                        ans.append(temp[i])
                        break
                    else:
                        sa.add(temp[i])
            ans.append(sa[-1])
            ws("""".join(ans))
            
            
            
            
                      
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
            
def rant():
    # RANT BEGINS-
    # 
    # Did you look at the constraints dummy? Read problem again carefully understand it correctly
    # Are base cases correct n=0,n=1,n=N or string is all 0 or all 1?
    # Take hints from time limits maybe n=1000 and m=100000 so if n^2 doesnt work n*m might work?? 
    # Upto 10^8 works under 2 sec
    # 
    # 1.Greedy? What matters what doesnt? Is my claim correct? 
    #   Does my implementation correctly implements the greedy i thought of? 
    #   Dictionary? keep a count of values if constraint on something is low(like only alphabets(26) count)? 
    # 
    # 2.DP? Think about state's ranges maybe one of the states have lesser possible values than it may look like? 
    #   Obviously think about order of evaluation
    # 
    # 3.Binary Search?(Monotonic? any one directed order in which we have to perform something?)
    # 
    # 4.Graph?DSU?Edge property or Vertex property Read carefully? Bipartitenes Property??? Cycle Property??? 
    #   Hidden but dependency ordering of values(in 1d array or 2d Table/Array) is that of a graph???
    # 
    # 5.Number Theory?(GCD subtraction?)
    # 
    # 6.Bruteforce?(Redundant part of N which may not give answer?Constraints?)
    # 
    # 7.Range Queries?
    # 
    # 8.Any Equivalency?(We have A and B and have to do 
    #   something between them maybe difficult if there was A~C and C~B then A~B
    #   C could be max or min or some other thing)
    # 
    # 9.Reverse Engineering?(From Answer to quesn or last step to first step)
    #
    # 10.Constructive? Mod? Bruteforce for smaller case and analyze patterns?
    #
    # 11.String? Constructive Greedy example- 
    #   Bracket sequence make first part unknown open and second part unknown closed 
    #   Remember always only n//2 open and n//2 closed brackets are there
    #
    # 12.Combinatorics?--> (n to i-1 index ways) * (ith index ways) * Ways (for i-1 till 0 index)?
    #
    # 13.Look for patterns and dependency of the patterns(maybe only first row or column matters to construct other rows and columns)
    #   for smaller cases maybe make bruteforce solution and analyze the patterns
    # 
    # RANT ENDS
    return ""AAAAAAAAAAAAAAAAARRRGHHHHHHHHHHHHHHHHHHHHHHHH""
    
def SieveOfEratosthenes(limit):
    """"""Returns all primes not greater than limit.""""""
    isPrime = [True]*(limit+1)
    isPrime[0] = isPrime[1] = False
    primes = []
    for i in range(2, limit+1):
        if not isPrime[i]:continue
        primes += [i]
        for j in range(i*i, limit+1, i):
            isPrime[j] = False
    return primes

def memodict(f):
    """"""memoization decorator for a function taking a single argument""""""
    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret

    return memodict().__getitem__

def pollard_rho(n):
    """"""returns a random factor of n""""""
    if n & 1 == 0:
        return 2
    if n % 3 == 0:
        return 3

    s = ((n - 1) & (1 - n)).bit_length() - 1
    d = n >> s
    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        p = pow(a, d, n)
        if p == 1 or p == n - 1 or a % n == 0:
            continue
        for _ in range(s):
            prev = p
            p = (p * p) % n
            if p == 1:
                return math.gcd(prev - 1, n)
            if p == n - 1:
                break
        else:
            for i in range(2, n):
                x, y = i, (i * i + 1) % n
                f = math.gcd(abs(x - y), n)
                while f == 1:
                    x, y = (x * x + 1) % n, (y * y + 1) % n
                    y = (y * y + 1) % n
                    f = math.gcd(abs(x - y), n)
                if f != n:
                    return f
    return n

@memodict
def prime_factors(n):
    """"""returns a Counter of the prime factorization of n""""""
    if n <= 1:
        return Counter()
    f = pollard_rho(n)
    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)

def distinct_factors(n):
    """"""returns a list of all distinct factors of n""""""
    factors = [1]
    for p, exp in prime_factors(n).items():
        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]
    return factors

def all_factors(n):
    """"""returns a sorted list of all distinct factors of n""""""
    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small

def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
    max_n = min(max_n, mod - 1)

    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
    fact[0] = 1
    for i in range(max_n):
        fact[i + 1] = fact[i] * (i + 1) % mod

    inv_fact[-1] = pow(fact[-1], mod - 2, mod)
    for i in reversed(range(max_n)):
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

    def nCr_mod(n, r):
        res = 1
        while n or r:
            a, b = n % mod, r % mod
            if a < b:
                return 0
            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
            n //= mod
            r //= mod
        return res

    return nCr_mod

class DisjointSetUnion:
    def __init__(self, n):
        self.parent = [*range(n+1)]
        self.size = [1]*(n+1)
        self.min, self.max = [*range(n+1)], [*range(n+1)]
        self.count = n

    def get(self, a):
        """"""Returns the identifier (parent) of the set to which a belongs to!""""""
        if self.parent[a] == a:
            return a
        x = a
        while a != self.parent[a]:
            a = self.parent[a]
        while x != self.parent[x]:
            self.parent[x], x = a, self.parent[x]
        return a

    def union(self, a, b):
        """"""Join two sets that contain a and b!""""""
        a, b = self.get(a), self.get(b)
        if a != b:
            if self.size[a] > self.size[b]:
                a, b = b, a
            self.parent[a] = b
            self.size[b] += self.size[a]
            self.min[b] = min(self.min[a], self.min[b])
            self.max[b] = max(self.max[a], self.max[b])
            self.count -= 1

    def count_sets(self):
        """"""Returns the number of disjoint sets!""""""
        return self.count
    
class SegmentTree:
    
    
    
    def __init__(self, data, default=0, func=max):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        """"""func of data[start, stop]""""""
        stop+=1
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

class SparseTable:
    def __init__(self, data, func=min):
        self.func = func
        self._data = _data = [list(data)]
        i, n = 1, len(_data[0])
        while 2 * i <= n:
            prev = _data[-1]
            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])
            i <<= 1

    def query(self, start, stop):
        """"""func of data[start, stop)]""""""
        depth = (stop + 1 - start).bit_length() - 1
        return self.func(self._data[depth][start], self._data[depth][stop + 1 - (1 << depth)])

    def __getitem__(self, idx):
        return self._data[0][idx]
              
class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True
 
    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False
 
    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1
 
    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x
 
    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k
 
    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1
 
        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True
 
    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi
 
        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True
 
    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)
 
    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))
 
    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value
 
    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx
 
    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx
 
    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)
 
    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len
 
    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]
 
    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)
 
    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False
 
    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)
 
    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))
 
    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))

import sys, os, io
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')
import math,datetime,functools,itertools,operator,bisect,fractions,statistics
from math import log2
from bisect import bisect_left,bisect_right
from collections import deque,defaultdict,OrderedDict,Counter
from fractions import Fraction
from decimal import Decimal
from sys import stdout
from heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest
# sys.setrecursionlimit(111111) 
INF=999999999999999999999999
alphabets=""abcdefghijklmnopqrstuvwxyz""

class FastReader(io.IOBase):
    newlines = 0

    def __init__(self, fd, chunk_size=1024 * 8):
        self._fd = fd
        self._chunk_size = chunk_size
        self.buffer = io.BytesIO()

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self, size=-1):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

class FastWriter(io.IOBase):

    def __init__(self, fd):
        self._fd = fd
        self.buffer = io.BytesIO()
        self.write = self.buffer.write

    def flush(self):
        os.write(self._fd, self.buffer.getvalue())
        self.buffer.truncate(0), self.buffer.seek(0)

class FastStdin(io.IOBase):
    def __init__(self, fd=0):
        self.buffer = FastReader(fd)
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class FastStdout(io.IOBase):
    def __init__(self, fd=1):
        self.buffer = FastWriter(fd)
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.flush = self.buffer.flush

if __name__ == '__main__':
    sys.stdin = FastStdin()
    sys.stdout = FastStdout()
    starttime=datetime.datetime.now()
    if(os.path.exists('input.txt')):
        sys.stdin = open(""input.txt"",""r"")
        sys.stdout = open(""output.txt"",""w"")
    main()
    endtime=datetime.datetime.now()
    time=(endtime-starttime).total_seconds()*1000
    if(os.path.exists('input.txt')):
        print(""Time:"",time,""ms"")  
    ",cubic,"dp,greedy",20196
"a = list(input())
b = list(input())
n = len(a)
a.sort()

def listtostring(string):
    return ''.join([str(ele) for ele in string])


for i in range(0,n):
    for j in range(0,n):
        t = a.copy()
        t[i],t[j] = t[j],t[i]
        if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))):
         #   print(""BEFORE"",a,a[i],a[j],i,j)
            a[i],a[j] = a[j],a[i]
         #   print(""AFTER"",a,a[i],a[j],i,j)
        
print(listtostring(a))",cubic,"dp,greedy",495
"a = list(input())
b = list(input())
n = len(a)
a.sort()

def listtostring(li:list):
    return ''.join(li)


for i in range(0,n):
    for j in range(0,n):
        t = a.copy()
        t[i],t[j] = t[j],t[i]
        if((int(listtostring(t)) >= int(listtostring(a))) and (int(listtostring(t))<= int(listtostring(b)))):
         #   print(""BEFORE"",a,a[i],a[j],i,j)
            a[i],a[j] = a[j],a[i]
         #   print(""AFTER"",a,a[i],a[j],i,j)
        
print(listtostring(a))",cubic,"dp,greedy",470
"import sys
input=sys.stdin.readline
a=list(map(int,input().rstrip()))
b=list(map(int,input().rstrip()))
if len(a)<len(b):
    a.sort(reverse=True)
    print(''.join(map(str,a)))
else:
    ans=-1
    ca=[0]*10
    for aa in a:
        ca[aa]+=1
    lim=-1
    for i in range(len(a)):
        if ca[b[i]]:
            candi=[]
            for j in range(i):
                candi.append(b[j])
            use=-1
            for j in range(b[i]-1,-1,-1):
                if ca[j]:
                    use=j
                    ca[j]-=1
                    candi.append(j)
                    break
            if use<0:
                ca[b[i]]-=1
                continue
            else:
                for j in range(10)[::-1]:
                    candi.extend([j]*ca[j])
                res=''.join(map(str,candi))
                res=int(res)
                ans=max(ans,res)
                ca[use]+=1
                ca[b[i]]-=1
        else:
            candi=[]
            for j in range(i):
                candi.append(b[j])
            use=-1
            for j in range(b[i]-1,-1,-1):
                if ca[j]:
                    use=j
                    ca[j]-=1
                    candi.append(j)
                    break
            if use<0:
                break
            else:
                for j in range(10)[::-1]:
                    candi.extend([j]*ca[j])
                res=''.join(map(str,candi))
                res=int(res)
                ans=max(ans,res)
                ca[use]+=1
                break
    flg=True
    ca=[0]*10
    for i in range(len(a)):
        ca[a[i]]+=1
    for i in range(len(a)):
        if ca[b[i]]:
            ca[b[i]]-=1
        else:
            flg=False
    if flg:
        ans=max(ans,int(''.join(map(str,b))))
    print(ans)",cubic,"dp,greedy",1799
"a,b = list(input()),int(input())
ans = """"
a.sort(reverse=True)
while len(a)>0:
    for i in range(len(a)):
        num = ans+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
        if int(num)<=b:
            ans += a[i]
            a = a[:i]+a[i+1:]
            break
print(ans)",cubic,"dp,greedy",267
"s1=input()
s2=input()
arr=list(s1)
arr.sort(reverse=True)
if(len(s2)>len(s1)):
  t=""""
  for i in arr:
    t+=i
  print(t)
else:
  t=""""
  l =len(s1)
  for i in range(l):
    index=-1
    ma = -1
    for j in range(len(arr)):
      temp = arr[j]
      tt=[]
      for k in range(len(arr)):
        if(k!=j):
          tt.append(arr[k])
      tt.sort()
      for k in tt:
        temp+=k
      temp = t+temp
      # print(temp,""fhhh"")
      if(int(s2)>=int(temp)):
        # print(temp,""f"")
        if(int(arr[j])>ma):
          ma = int(arr[j])
          index = j
    t+=arr[index]
    del arr[index]
    # print(t,arr)
  print(t)



",cubic,"dp,greedy",633
"def check(s,a):
    st=''
    for i in range(len(s)):
        st+=s[i]
    st=int(st)
    if (st>a):
        return False
    else:
        return True
a = input()
b = input()
s=[]
ans=''
for i in range(len(a)):
    s.append(a[i])
s.sort()
if (len(b)>len(a)):
    for i in range(len(s)):
        print(s[len(s)-i-1],end='')
else:
    for i in range(len(a)):
        j=0
        temp2=-1
        while ((j<len(s)-1) and (s[j+1]<=b[i])):
            j+=1
            if (s[j]!=s[j-1]):
                temp2=j-1    
        temp=s[j]
        s.remove(s[j])
        if (i==len(a)-1 or check(s,int(b[i+1:len(b)])) or temp<b[i]):
            ans+=temp
            if (ans[i]<b[i]):
                for k in range(len(s)):
                    ans+=s[len(s)-k-1]
        else:
            s.append(temp)
            s.sort()
            temp2=s[temp2]
            ans+=temp2
            s.remove(temp2)
            for k in range(len(s)):
                    ans+=s[len(s)-k-1]      
        if (len(ans)==len(a)):
            break          
print(ans)        
            
    
",cubic,"dp,greedy",1073
"mass = list(input())
b = int(input())
mass.sort()
mass = mass[::-1]
p = ''
while(len(mass)>0):
	for i in range(len(mass)):
		n = p + mass[i] + ''.join(sorted(mass[:i] + mass[i + 1:]))
		if int(n) <= b:
			p += mass[i]
			mass = mass[:i] + mass[i + 1:]
			break
print(p)",cubic,"dp,greedy",269
"def smallest(d):
    out = """"
    for j in range(0, 10):
        out += (""%d"" % j)*d[j]
    return out


def largest(d):
    out = """"
    for j in range(9, -1, -1):
        out += (""%d"" % j)*d[j]
    return out


sa = input()
sb = input()
b = int(sb)

h = int(sa)
digits_a = [0]*10
while h > 0:
    digits_a[h % 10] += 1
    h //= 10

out = """"
if len(sb) > len(sa):
    print(largest(digits_a))
    exit()

out = 0
for i in range(len(sa)-1, -1, -1):
    for j in range(9, -1, -1):
        if digits_a[j] == 0:
            continue

        if j < (b % (10 ** (i+1))) // (10 ** i):
            digits_a[j] -= 1
            if out > 0:
                print(""{}{}{}"".format(out, j, largest(digits_a)))
                exit()
            else:
                print(""{}{}"".format(j, largest(digits_a)))
                exit()

        if j == (b % (10 ** (i+1))) // (10 ** i):
            if i == 0:
                out = 10*out + j
                print(out)
                exit()
            digits_a[j] -= 1
            if int(smallest(digits_a)) <= b % (10 ** i):
                out = 10*out + j
                break
            else:
                digits_a[j] += 1

print(out)
",cubic,"dp,greedy",1184
"def search(current, digits, target, idx, bulk):
    if len(current) == len(target) and int(current) <= int(target):
        print(current)
        exit(0)

    possibilities = [char for char in digits if bulk or (char <= target[idx] and char in digits)]

    if len(possibilities) == 0:
        return None

    for possible_digit in sorted(set(possibilities), reverse=True):
        tmp_digits = list(digits)
        tmp_digits.remove(possible_digit)
        if not bulk:
            bulk = True if possible_digit != target[idx] else False
        search(current + possible_digit, tmp_digits, target, idx + 1, bulk)


def main():
    digits = sorted(list(input()), reverse=True)
    target = input()

    if len(digits) < len(target):
        print(''.join(digits))
        exit(0)

    entries = [char for char in digits if char <= target[0]]

    for current in sorted(set(entries), reverse=True):
        tmp_digits = list(digits)
        tmp_digits.remove(current)
        search(current, tmp_digits, target, 1, True if current != target[0] else False)


if __name__ == ""__main__"":
    main()
",cubic,"dp,greedy",1098
"def main():
    a = sorted(input(), reverse=True)
    b = int(input())
    k = """"
    while len(a) > 0:
        for i in range(len(a)):
            num = k + a[i] + """".join(sorted(a[:i] + a[i + 1:]))
            if int(num) <= b:
                k += a[i]
                a = a[:i] + a[i + 1:]
                break
    print(k)


if __name__ == ""__main__"":
    main()
",cubic,"dp,greedy",369
"a=input()
b=input()
v=sorted(a)
v=v[::-1]
x=""""
for i in range(len(v)):
    x=x+v[i]
v=x
if(len(a)<len(b)):
    print(v)
else:
    if(b==a):
        print(a)
    else:
        fin=""""
        flag=False
        for j in range(len(a)):            
            for k in range(len(a)):
                num=fin+v[k]+''.join(sorted(v[:k:]+v[k+1::]))
                #print(num,k,fin)
                if(num<=b):
                    fin+=v[k]
                    #print(fin,v[k],b[j])
                    if(int(v[k])<int(b[j])):
                        flag=True
                        v=v[:k:]+v[k+1::]
                        fin+=v 
                    v=v[:k:]+v[k+1::]
                    break
            if(flag):
                break
        print(fin)",cubic,"dp,greedy",756
"a=sorted(input())

b=int(input())

a=a[::-1]

p=""""

while a:

	for i, z in enumerate(a):

		n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:]))

		if int(n)<=b:

			p+=z

			a.pop(i)

			break

print(p)



# Made By Mostafa_Khaled",cubic,"dp,greedy",218
"def dig(d):
    return ord(d) - ord('0')


def biggest_left(counts):
    res = ''
    for i in range(9, -1, -1):
        res += str(i) * counts[i]
    return res


def ok(d, _counts, rest):
    if rest == '':
        return True

    counts = _counts.copy()
    counts[d] -= 1

    r = ''
    for i in range(10):
        r += str(i) * counts[i]

    return int(r) <= int(rest)


def main():
    a, b = input(), input()

    counts = [0] * 10
    for d in a:
        counts[dig(d)] += 1

    ans = ''
    if len(a) < len(b):
        print(biggest_left(counts))
        return

    n = len(a)
    for i in range(n):
        d = dig(b[i])

        if counts[d] and ok(d, counts, b[i+1:]):
            ans += b[i]
            counts[d] -= 1
        else:
            for s in range(d-1, -1, -1):
                if counts[s] > 0:
                    ans += str(s)
                    counts[s] -= 1
                    ans += biggest_left(counts)
                    print(ans)
                    return
    print(ans)


if __name__ == '__main__':
    main()
",cubic,"dp,greedy",1056
"a = list(input())
b = input()
out = []
mx = '/'
a.sort()
a.reverse()
x = len(a)
if x == len (b):
    for i in range(x):
        q = 0
        
        for j in range(len(a)):
            if a[j] == b[i]:
                out.append(a[j])
                a.pop(a.index(a[j]))
                q = 1
                break
            elif a[j] < b[i]:
                out.append(a[j])
                a.pop(a.index(a[j]))
                print(''.join(out), end = '')
                print(''.join(a))
                exit(0)
        if q == 0:
            break
    if q == 1:
        print(''.join(out))
    else:
        y = len(out)
        for i in range(y-1, -1, -1):
            for j in range(len(a)):
                if a[j] < b[i] and a[j]>mx:
                    mx = a[j]
            if mx != '/':
                   
                    
                a.append(out[len(out)-1])
                out.pop()
                out.append(mx)
                a.pop(a.index(mx))
                a.sort()
                a.reverse()              
                print(''.join(out), end = '')
                print(''.join(a))
                exit(0)
            else:
                a.append(out[len(out)-1])
                out.pop()
                a.sort()
                a.reverse()
                    
                    
                    
        a.pop(a.index(mx))
        print(mx, end ='')
        print(''.join(a))
                
                
else:
    print(''.join(a))
        
'''15778899
98715689'''

",cubic,"dp,greedy",1530
"a = input()
b = input()
list_a = list(a)
list_a.sort()
max_a = int(''.join(list_a))
for i in range(len(a)):
    for j in range(i+1, len(a)):
        list_a[i], list_a[j] = list_a[j], list_a[i]
        temp_a = int(''.join(list_a))
        if int(b) < temp_a or temp_a <= max_a:
            list_a[i], list_a[j] = list_a[j], list_a[i]
        else:
            max_a = temp_a
print(max_a)",cubic,"dp,greedy",387
"a = input()
b = input()
la = [int(x) for x in a]
res = []
la.sort()
la = la[::-1]
lb = [int(x) for x in b]
cnt = [0] * 20

def check():
    tres = 0
    for x in range(len(res)):
        tres *= 10
        tres += int(res[x])
    return tres <= int(b)
if len(a) < len(b):
    for i in range(len(la)):
        print(la[i], end = '')
    print()
else:
    for i in range(len(la)):
        cnt[la[i]] += 1
    flag = 0
    for i in range(len(lb)):
        if flag == 0 and cnt[lb[i]]:
            res.append(lb[i])
            cnt[lb[i]] -= 1
        else:
            flag = i - 1
            for j in range(lb[i] - 1, -1, -1):
                if cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
                    break
            for j in range(9, -1, -1):
                while cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
            break
    while not check():
        temp = []
        cnt = [0] * 20
        for x in range(flag):
            temp.append(res[x])
            cnt[res[x]] -= 1
        for i in la:
            cnt[i] += 1
        ##print(""cnt = "", cnt)
        res = temp
        ##print(flag, res)
        for v in range(lb[flag] - 1, -1, -1):
            if cnt[v]:
                res.append(v)
                cnt[v] -= 1
                break
        for v in range(9, -1, -1):
            while cnt[v]:
                res.append(v)
                cnt[v] -= 1
        ##print(flag, res)
        flag -= 1
    for i in range(len(res)):
        print(res[i], end = '')
    print()
",cubic,"dp,greedy",1562
"a = input()
b = input()
la = [int(x) for x in a]
res = []
la.sort()
la = la[::-1]
lb = [int(x) for x in b]
cnt = [0] * 20

def check():
    tres = 0
    for x in range(len(res)):
        tres *= 10
        tres += int(res[x])
    return tres <= int(b)
if len(a) < len(b):
    for i in range(len(la)):
        print(la[i], end = '')
    print()
else:
    for i in range(len(la)):
        cnt[la[i]] += 1
    flag = 0
    for i in range(len(lb)):
        if flag == 0 and cnt[lb[i]]:
            res.append(lb[i])
            cnt[lb[i]] -= 1
        else:
            flag = i - 1
            for j in range(lb[i] - 1, -1, -1):
                if cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
                    break
            for j in range(9, -1, -1):
                while cnt[j]:
                    res.append(j)
                    cnt[j] -= 1
            break
    while not check():
        temp = []
        cnt = [0] * 20
        for x in range(flag):
            temp.append(res[x])
            cnt[res[x]] -= 1
        for i in la:
            cnt[i] += 1
        ##print(""cnt = "", cnt)
        res = temp
        ##print(flag, res)
        for v in range(lb[flag] - 1, -1, -1):
            if cnt[v]:
                res.append(v)
                cnt[v] -= 1
                break
        for v in range(9, -1, -1):
            while cnt[v]:
                res.append(v)
                cnt[v] -= 1
        ##print(flag, res)
        flag -= 1
    for i in range(len(res)):
        print(res[i], end = '')
    print()",cubic,"dp,greedy",1561
"#!usr/bin/python

a = input()
b = input()

length_of_a = len(a)
length_of_b = len(b)
found_digit = False
chk_finnish = False
appended_digit_count = 0
n = {}
num = []
for i in range(0,10):
	n[i] = 0

for i in range(0,length_of_a):
	c = int(a[i])
	n[c] += 1


if length_of_a < length_of_b:
	num = sorted(a,reverse=True)
	for i in range(0,length_of_a):
		print(num[i],end="""")
else:
	for i in range(0,length_of_b):
		digit = int(b[i])
		if n[digit] > 0:
			num.append(digit)
			n[digit] -= 1
			# print(""from start as equal : n[""+str(digit)+""] : ""+str(n[digit]))
			# print(num)
			appended_digit_count += 1
		else:
			j = digit - 1
			while j > -1:
				if n[j] > 0:
					num.append(j)
					appended_digit_count += 1
					n[j] -= 1
					# print(""from 2nd : n[""+str(j)+""] : ""+str(n[j]))
					# print(num)
					found_digit = True
					chk_finnish = True
					break
				j -= 1

			if found_digit:
				j = 9
				while j > -1:
					if n[j] > 0:
						digit_count = n[j]
						for k in range(0,digit_count):
							num.append(j)
							n[j] -= 1
							# print(""form 3rd : n[""+str(j)+""] : ""+str(n[j]))
							# print(num)
							appended_digit_count += 1
					j -= 1
				if chk_finnish:
					break
			else:
				found_digit = False
				while found_digit == False:
					pop_up = num[appended_digit_count-1]
					# print(pop_up,end="" "")
					del num[-1]
					j = pop_up - 1
					n[pop_up] += 1
					# print(""form 4th popped : n[""+str(pop_up)+""] : ""+str(n[pop_up]))
					# print(num)
					# print(n[pop_up])
					appended_digit_count -= 1
					while j > -1:
						if n[j] > 0:
							num.append(j)
							appended_digit_count += 1
							n[j] -= 1
							# print(""from 5th appeneded n[""+str(j)+""] : ""+str(n[j]))
							# print(num)
							found_digit = True
							break
						j -= 1
				j = 9
				while j > -1:
					if n[j] > 0:
						# print(""from 5th : n[""+str(j)+""] : ""+str(n[j]))
						# print(num)
						digit_count = n[j]
						for k in range(0,digit_count):
							num.append(j)
							appended_digit_count += 1
					j -= 1
				break
			

	for i in range(0,length_of_b):
		print(num[i],end="""")",cubic,"dp,greedy",2087
"a=list(input())
b=list(input())
num=int(''.join(b))
a.sort()
a.reverse()
al=len(a)
ans=[]
if(len(a)==len(b) and len(a)!=1):
	c=[]
	count=0
	hogya=0
	for i in range(al):
		if(hogya==1):
			o.reverse()
			f=list(c+o)
			ans.append(''.join(f))
			count+=1
			break
		t=len(a)
		j=0
		mittal=t
		abhinhi=0
		while(t):
			#print(""hello"")
			if(j>len(a)-1):
				break
			if(int(a[j])<=int(b[i])):
				c.append(a[j])
				temp=a[j]
				a.remove(a[j])
				o=a.copy()
				o.sort()
				f=list(c+o)
				#if(i==8):
				#	print(c,a)
				#print(num,a)
				if(temp<b[i]):
					#print(i,temp,j,f)
					#print(""hello"")
					#print(""hello"",hogya)
					hogya=1
					break
				if(int(''.join(f))<=num):
					ans.append(''.join(f))
					count+=1
					break
				else:
					a.append(temp)
					c=c[:len(c)-1]
					#c.remove(c[len(c)-1])
					#print(c,a)
					
				t-=1
			else:
				j+=1
				t-=1
		if(mittal==len(a)):
			#print(mittal,i)
			#print(""hello"")
			break
	#print(count)
	print(ans[count-1])
elif(len(a)==1):
	print(''.join(a))
else:
	print(''.join(a))
#print(ans)",cubic,"dp,greedy",1050
"R = lambda: map(int, input().split())
a = sorted(map(int, input()))
b = list(map(int, input()))
bn = int(''.join(map(str, b)))
res = int(''.join(map(str, sorted(a))))
if len(b) != len(a):
    print(''.join(map(str, sorted(a, reverse=True))))
else:
    for i in range(len(a)):
        for j in range(i + 1, len(a)):
            if a[i] < a[j] < b[i]:
                a[i], a[j] = a[j], a[i]
        tmp = int(''.join(map(str, a[:i + 1] + sorted(a[i + 1:], reverse=True))))
        res = max(res, tmp) if tmp <= bn else res
        for j in range(i + 1, len(a)):
            if a[j] == b[i]:
                a[i], a[j] = a[j], a[i]
    print(res)",cubic,"dp,greedy",644
"fre =[0,0,0,0,0,0,0,0,0,0,0]
a=input();b=input()
c=False
def DFS(aa,bb):
  if int(aa)==len(a):
    print(bb)
    exit()
  global c
  for i in range(9,-1,-1):
    if (fre[i]>0 and i<=int(b[int(aa)])) or (fre[i]>0 and c):
      fre[i]-=1
      if i<int(b[int(aa)]):
        c=True
      DFS(aa+1,bb*10+i)
      fre[i]+=1
      c=False
      


if len(b)>len(a):
  x=sorted(a);
  
  print(*x[::-1],sep='')
else:
  for i in a:
    fre[int(i)]+=1
  DFS(0,0)
",cubic,"dp,greedy",453
"a=list(input())
b=int(input())
a.sort()
a=a[::-1]
prefix=""""
while(len(a)>0):
    for i in range(len(a)):
        num=prefix+a[i]+"""".join(sorted(a[:i]+a[i+1:]))
        if(int(num)<=b):
            prefix+=a[i]
            a=a[:i]+a[i+1:]
            break
print(prefix)",cubic,"dp,greedy",269
"s=input()
s1=input()
l=[]
l1=[]
for x in s :
    l.append(int(x))
for x in s1 :
    l1.append(int(x))
d={}
for x in l :
    d[x]=d.get(x,0)+1
f=False
if len(s1)>len(s) :
    l=sorted(l)
    l=l[::-1]
    print("""".join(map(str,l)))
    exit()
ans=[0]*len(s)

ki=0
i=0
while(i<len(l1)) :
    f=True
    for j in range(max(l1[i],ki),-1,-1) :
        if d.get(j,-1)>0 :
            ans[i]=j
            d[j]-=1
            f=False
            if j!=l1[i] :
                
                ki=9
            break
    
    if f :
        
        
        
        for i1 in range(i-1,-1,-1) :
            f1=False
            for j in range(max(l1[i1],ki)-1,-1,-1) :
                if d.get(j,-1)>0 :
                    d[ans[i1]]+=1
                    ans[i1]=j
                    d[j]-=1
                    f1=True
                    i=i1
                    ki=9
                    break
            if f1 :
                break
            else :
                d[ans[i1]]+=1
                ans[i1]=0
    i+=1
                
       
            
            
        
        
            

    

    
print("""".join(map(str,ans)))

            
            
                
            
            
",cubic,"dp,greedy",1213
"from collections import Counter
a = input()
b = input()
if len(a) < len(b):
    print(''.join(sorted(a)[::-1]))
    exit()
n = len(a)
cnt = Counter(a)
def f(i = 0, check = False):
    if i == n: return []
    for j in sorted(cnt)[::-1]:
        if (check or j <= b[i]) and cnt[j]:
            cnt[j] -= 1
            res = f(i + 1, check or j < b[i])
            if len(res) + i + 1 == n:
                res.append(j)
                return res
            cnt[j] += 1
    return []
print(''.join(f()[::-1]))",cubic,"dp,greedy",509
"from copy import deepcopy
a = list(map(int, list(input())))
b = list(map(int, list(input())))
cnt1 = [0] * 10; cnt2 = [0] * 10
ans = []
if (len(a) != len(b)):
    print(''.join(map(str,sorted(a, reverse=True))))
    exit()
for i in range(len(b) + 1):
    ok = 1
    tmp = deepcopy(a)
    for j in range(i):
        if b[j] in tmp:
            tmp.pop(tmp.index(b[j]))
        else:
            ok = 0
            break
    if not ok: continue
    pls = -1
    ind = -1
    for j in range(len(tmp)):
        if (tmp[j] < b[i]):
            if (tmp[j] > pls):
                ind = j
                pls = tmp[j]
    if pls == -1 and len(tmp) != 0: continue
    else:
        if (len(tmp) > 0): tmp.pop(ind)
        if i == len(b): ans.append(''.join(map(str, b[:i:])))
        else: ans.append(''.join(map(str, b[:i:])) + str(pls) + ''.join(map(str, sorted(tmp, reverse=True))))
print(max(ans))",cubic,"dp,greedy",893
"a = list(input())
b = int(input())
a = sorted(a, reverse=True)
ans = ''
while len(a) > 0:
    for i in range(len(a)):
        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))
        if int(tmp) <= b:
            ans += a[i]
            a = a[:i] + a[i + 1:]
            break
print(ans)
",cubic,"dp,greedy",293
"a = [ord(e) - ord('0') for e in list(input().strip())]
b = [ord(e) - ord('0') for e in list(input().strip())]

a.sort(reverse=True)
h = [0 for i in range(10)]
for x in a:
    h[x] += 1

if len(a) < len(b):
    print(''.join(map(str, a)))
    exit(0)

def gmax(hx):
    s = list(hx)
    res = list()
    for i in range(9, -1, -1):
        while s[i] > 0:
            res.append(i)
            s[i] -= 1
    return res

def gmin(hx):
    s = list(hx)
    res = list()
    for i in range(10):
        while s[i] > 0:
            res.append(i)
            s[i] -= 1
    return res

res = list()

def finalize(x):
    for y in range(x-1, -1, -1):
        if h[y] > 0:
            res.append(y)
            h[y] -= 1
            for i in range(9, -1, -1):
                while h[i] > 0:
                    res.append(i)
                    h[i] -= 1
            return

p = 0
while p < len(a):
    x = b[p]    
    if h[x] > 0:
        hh = list(h)
        hh[x] -= 1
        if b[p+1:] >= gmin(hh): # can make a smaller one with the remainings
            res.append(x)
            h[x] -= 1
        else:
            finalize(x)
            break
    else:
        finalize(x)
        break
    p += 1
print(''.join(map(str, res)))",cubic,"dp,greedy",1229
"def get_smallest(m, l):
    res = ''
    for i in ""0123456789"":
        if m.get(i, 0):
            if i == l:
                res += i * (m[i] - 1)
            else:
                res += i * m[i]
    return res 

a = input()
b = input()

if len(a) < len(b):
    a = sorted(a)
    a.reverse()
    print(''.join(a))
elif a == b:
    print(a)
else:
    cmap = dict()
    for i in a:
        cmap[i] = cmap.get(i, 0) + 1

    cur = 0
    res = ''
    gm = False 

    while cur < len(a):
        for i in ""9876543210"":
            if cmap.get(i, 0):
                if cur == len(a) - 1 or i < b[cur] or gm:
                    res += i
                    cmap[i] -= 1
                    gm = True
                    break
                elif i == b[cur]:
                    if get_smallest(cmap, i) <= b[cur + 1:]:
                        res += i
                        cmap[i] -= 1
                        break
        cur += 1

    print(res)",cubic,"dp,greedy",952
"# import sys 
# sys.stdin = open('input.txt', 'r')  
# sys.stdout = open('output.txt', 'w')

a = [int(i) for i in list(input())]
b = [int(i) for i in list(input())]

if (len(a)<len(b)):
	a.sort(reverse=True)
	ans = 0
	for i in range(len(a)):
		ans = ans*10+a[i]
	print(ans)
else:
	# ans = [0]*len(a)
	ans = 0
	n = len(a)
	count = [0]*10
	for i in range(n):
		count[a[i]] += 1
	i = 0
	while (i<n):
		x = b[i]
		if (count[x]>0):
			ans = ans*10+x
			count[x] -= 1
			i += 1
		else:
			break
	if (i==n):
		print(ans)
		exit(0)
	x = b[i]
	flag = False
	for j in range(x-1,-1,-1):
		if (count[j]>0):
			ans = ans*10+j
			count[j] -= 1
			flag = True
			break
	if (flag) :
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	else:
		while (not flag):
			t = ans%10
			ans = ans//10
			count[t] += 1
			for i in range(t-1,-1,-1):
				if (count[i]>0):
					count[i] -= 1
					flag = True
					ans = ans*10 + i
					break
		for j in range(9,-1,-1):
			while (count[j]>0):
				ans = ans*10+j
				count[j] -= 1
	print(ans)
",cubic,"dp,greedy",1048
"def possible(a,index,a1,b):
    rem = []
    for i in range(len(a)):
        if i != index:
            rem.append(a[i])

    a3 = a1[:]
    rem.sort()
    a3.append(a[index])
    a3.extend(rem)
    a2 = ''
    for i in a3:
        a2 += str(i)

    if int(a2) <= b:
        return True

    return False

def main():
    a = list(map(int,input()))
    b = int(input())

    a.sort(reverse = True)
    a1 = []
    for pos in range(len(a)):
        for i in range(len(a)):
            if possible(a,i,a1,b):
                a1.append(a[i])
                a.pop(i)
                break
            
    for i in a1:
        print(i,end = '')

main()
",cubic,"dp,greedy",650
"def main():
    # import sys
    # input = sys.stdin.readline

    a = input()
    b = input()
    if len(a) < len(b):
        a = list(a)
        a.sort(reverse=True)
        print(''.join(a))
        return

    def solve(i, a: list):
        if i == len(b):
            return ''
        if a.__contains__(b[i]):
            a.remove(b[i])
            suf = solve(i+1, a)
            if suf is not None:
                return b[i] + suf
            a.append(b[i])
        best = ''
        for c in a:
            if c < b[i] and c > best:
                best = c
        if best == '':
            return None
        a.remove(best)
        a.sort(reverse=True)
        return best + ''.join(a)

    a = list(a)
    print(solve(0, a))

main()",cubic,"dp,greedy",748
"def main():
    import sys
    input = sys.stdin.readline

    a = int(input())
    b = int(input())
    a = list(str(a))
    a.sort()
    ans = []
    while a:
        for i in range(len(a) - 1, -1, -1):
            c = ans + [a[i]] + a[:i] + a[i+1:]
            if int(''.join(c)) <= b:
                ans.append(a[i])
                a.pop(i)
                break
    print(''.join(ans))


main()",cubic,"dp,greedy",401
"import bisect
def solve(l,d,s2,r):
    ans=""""
    lol=0
    i=0
    lo=0
    while i<(len(s2)):
        if(lo==1):
            #print(""lol"",i)
            
            a=s2[i]
            ind=bisect.bisect_left(l,a)
            #print(ind,a)
            for x in range(ind,-1,-1):
                if(l[x]<l[ind]):
                    ind=x
                    #print(""lol"")
                    break
            ans+=str(l[ind])
            d[l.pop(ind)]-=1
            
            lol=1
            break

        a=s2[i]
        ind=bisect.bisect_left(l,a)
        #print(l,ind,a)
        
        if(ind==len(l)):
            ind-=1
            ans+=str(l[ind])
            d[l[ind]]-=1
            lol=1
            break
        elif(l[ind]>a):
            if(ind==0):
                while ind==0:
                    
                    l.append(int(ans[-1]))
                    d[int(ans[-1])]+=1
                    l.sort()
                    ans=ans[:len(ans)-1]
                    lo=1
                    i-=1
                    a=s2[i]
                    ind=bisect.bisect_left(l,a)
                #print(i)
                #i+=1
                continue
            lol=1
            ans+=str(l[ind-1])
            #print(ans,i)
            d[l[ind-1]]-=1
            l.pop(ind-1)
            break
        else:
            ans+=str(l[ind])
            d[l[ind]]-=1
            l.pop(ind)
        i+=1
    ll=[]
    #print(""lol"",d)
    if(lol):
        for i in d:
            if(d[i]!=0):
                ll.append(i)
        ll.sort(reverse=True)
        co=0
        #print(ll)
        for i in ll:
            for j in range(d[i]):
                if(i==0):
                    co+=1
                    if(co>r):
                        break
                ans+=str(i)
                
    print(ans)
from math import gcd
import sys
from collections import defaultdict as dd
input=sys.stdin.readline
s1=list(map(int,input().strip()))
s2=list(map(int,input().strip()))
z=s1.count(0)
d=dd(int)
n=len(s1)
m=len(s2)
l=sorted(s1)
for i in s1:
    d[i]+=1
if len(s1)<len(s2):
    for i in range(len(s1)-1,-1,-1):
        print(l[i],end="""")
elif(len(s1)>len(s2)):
    r=m-(n-z)
    #print(l,m,n,z)
    l=l[z-r:]
    #print(l,r)
    solve(l,d,s2,r)
else:
    solve(l,d,s2,100)
    ",cubic,"dp,greedy",2304
"'''
    Auther: ghoshashis545 Ashis Ghosh
    College: jalpaiguri Govt Enggineerin College
    Date:18/05/2020

'''
import sys
from collections import deque,defaultdict as dd 
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
abd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}
mod=1000000007
#mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]
def read():
    tc=0
    if tc:
        input=sys.stdin.readline
    else:
        sys.stdin=open('input1.txt', 'r')
        sys.stdout=open('output1.txt','w')


def permute(b,x,ind):
    if(ind==len(b)):
        return 1
    f=0
    for i in range(9,-1,-1):
        if(x[i]>0 and i<=int(b[ind])):
            x[i]-=1
            ans[ind]=str(i)
            if(i<int(b[ind])):
                f=1
            if(f):
                k=9
                for j in range(ind+1,len(b)):
                    while(x[k]==0):
                        k-=1
                    ans[j]=str(k)
                    x[k]-=1
                return 1
            if(permute(b,x,ind+1)):
                return 1
            x[i]+=1
    return 0
            
            

def solve():
    
    # for _ in range(ii()):
        
    
    
    a=ii()
    b=ii()
    if(len(str(a))<len(str(b))):
        s=list(str(a))
        s.sort(reverse=True)
        print("""".join(s))
    else:
        x=[0]*10
        for i in str(a):
            x[int(i)]+=1
        b=str(b)
        i=0
        global ans
        ans=[0]*len(b)
        permute(b,x,0)
        print("""".join(ans))
        
  
  
  
if __name__ ==""__main__"":
    # read()
    solve()
    
    
    ",cubic,"dp,greedy",2080
"#---------------------------iye ha aam zindegi---------------------------------------------
import math
import heapq,bisect
import sys
from collections import deque,defaultdict
from fractions import Fraction
mod=10**9+7
mod1=998244353
# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
# -------------------game starts now----------------------------------------------------import math
class SegmentTree1:
    def __init__(self, data, default=9999999, func=lambda a, b: min(a , b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)

# -------------------game starts now----------------------------------------------------import math
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
#-------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
#--------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m
#--------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z
#--------------------------------------------------product----------------------------------------
def product(l):
    por=1
    for i in range(len(l)):
        por*=l[i]
    return por
#--------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] <= key):

            # At least (mid + 1) elements are there
            # whose values are less than
            # or equal to key
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count
#--------------------------------------------------binary----------------------------------------
def countdig(n):
    c=0
    while(n>0):
        n//=10
        c+=1
    return c
def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)

        # If mid element is greater than
        # k update leftGreater and r
        if (arr[m] > k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)
#--------------------------------------------------binary------------------------------------
def findmin(h,n):
    n.sort()
    h=int(h)
    ans='-1'
    #print(h,n)
    for i in n:
        if int(i)>h:
            break
        ans=i
    #print(ans)
    return ans
n=list(input())
n1=list(input())
if len(n)<len(n1):
    n.sort(reverse=True)
    print(*n,sep='')
    sys.exit()
n.sort()
ans=""""
f=0
for i in range(len(n)):
    t=i-1
    c=0
    r = findmin(n1[i], n)
    if r=='-1':
        while(r=='-1'):
            n.append(ans[-c-1])
            r=findmin(int(n1[t])-1,n)
            t-=1
            c+=1
        ans=ans[:len(ans)-c]
        ans+=r
        n.remove(r)
        f=1
        break
    n.remove(r)
    if r==n1[i]:
        ans+=r
        continue
    else:
        ans+=r
        f=1
        break
if f==1:
    n.sort(reverse=True)
    for i in n:
        ans+=i
print(ans)",cubic,"dp,greedy",10783
"def main():
	s = list(input())
	t = list(input())
	if len(s) < len(t):
		s.sort(reverse=True)
		print(''.join(s))
	else:
		count = [0] * 10
		for elm in s:
			count[ord(elm) - ord('0')] += 1
		ans = []
		less = False
		for i in range(len(s)):
			for j in range(9, -1, -1):
				if not less:
					if j <= ord(t[i]) - ord('0') and count[j] > 0:
						if j < ord(t[i]) - ord('0'):
							ans.append(chr(j + ord('0')))
							count[j] -= 1
							less = True
							break
						else:
							curr_num = 0
							for k in range(10):
								if j == k:
									for tmp in range(count[k] - 1):
										curr_num = curr_num * 10 + k
								else:
									for tmp in range(count[k]):
										curr_num = curr_num * 10 + k
							rest_num = 0
							for k in range(i + 1, len(s)):
								rest_num = rest_num * 10 + (ord(t[k]) - ord('0'))
							if rest_num >= curr_num:
								ans.append(chr(j + ord('0')))
								count[j] -= 1
								break
							else:
								continue
				else:
					if count[j] > 0:
						ans.append(chr(j + ord('0')))
						count[j] -= 1
						break
		print(''.join(ans))


if __name__ == '__main__':
	main()
",cubic,"dp,greedy",1126
"import sys
import math
#input=sys.stdin.readline
#t=int(input())
t=1
for _ in range(t):
    #n=int(input())
    #c,m,x=map(int,input().split())
    #l=list(map(int,input().split()))
    a=input()
    b=input()
    dp=[0]*(11)
    for i in a:
        dp[int(i)]+=1
    #print(dp)
    if len(b)>len(a):
        ans=''
        for i in range(len(a)):
            for j in range(9,-1,-1):
                if dp[j]!=0:
                    ans+=str(j)
                    dp[j]-=1
                    break
    elif len(a)==len(b):
        ans=''
        a1=[]
        cmpr=''
        i=0
        while i<len(a):
            cmpr+=b[i]
            #print(cmpr,ans,dp)
            if i==0:
                flag=0
                for j in range(9,0,-1):
                    if ans+str(j)<=cmpr and dp[j]!=0:
                        flag=1
                        dp[j]-=1
                        ans+=str(j)
                        a1.append(j)
                        break
                if flag==0:
                    dp[1]-=1
                    a1.append(1)
                    ans+='1'
            else:
                flag=0
                for j in range(9,-1,-1):
                    if ans+str(j)<=cmpr and dp[j]!=0:
                        flag=1
                        ans+=str(j)
                        a1.append(j)
                        dp[j]-=1
                        break
                
                if flag==0:
                    ch=0
                    for i1 in range(i-1,-1,-1):
                        if ch==1:
                            break
                        for j1 in range(int(ans[i1])-1,-1,-1):
                            if i1==0:
                                if j1>0 and dp[j1]!=0:
                                    dp[a1[i1]]+=1
                                    dp[j1]-=1
                                    index=i1
                                    a1.pop()
                                    a1.append(j1)
                                    ch=1
                                    break
                            else:
                                if  dp[j1]!=0:
                                    dp[a1[i1]]+=1
                                    dp[j1]-=1
                                    a1.pop()
                                    index=i1
                                     
                                    a1.append(j1)
                                    ch=1
                                    break
                            if ch==1:
                                break
                        if ch==1:
                            break
                        val=a1.pop()
                        dp[val]+=1
                            #print(13,dp,a1)
                            
                    ans=''
                    cmpr=''
                    #print(13,dp,a1)
                    dp=[0]*11
                    for i1 in range(len(a)):
                        dp[int(a[i1])]+=1
                    #print('check  ',dp,a1)
                    for i1 in range(len(a1)):
                        dp[a1[i1]]-=1
                        
                    for i1 in range(len(a1)):
                        ans+=str(a1[i1])
                        cmpr+=b[i1]
                    i=index    
                    #print(11,ans,cmpr,a1,dp)
            i+=1                
    print(ans)    ",cubic,"dp,greedy",3392
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations
 

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
#-------------------game starts now-----------------------------------------------------
a=sorted(input())
b=int(input())
a=a[::-1]
p=""""
while a:
	for i, z in enumerate(a):
		n=p+a[i]+"""".join(sorted(a[:i]+a[i+1:])) 
		if int(n)<=b:
			p+=z
			a.pop(i)
			break
print(p)",cubic,"dp,greedy",2198
"from string import digits
from collections import Counter
a = input()
b = input()
ca = Counter(a)
l = list()
if len(b) > len(a):
    for i in digits[::-1]:
        if i in ca:
            l.extend(i * ca[i])
else:
    def asd(i, s):
        if i == len(b):
            return True
        if s:
            for j in digits[::-1]:
                if j in ca and ca[j] > 0:
                    l.extend(j * ca[j])
            return True
        else:
            for j in digits[:int(b[i])+1][::-1]:
                if j in ca and ca[j] > 0:
                    ca[j] -= 1
                    l.append(j)
                    if asd(i + 1, j != b[i]):
                        return True
                    ca[j] += 1
                    l.pop()
            return False
    asd(0, False)
print("""".join(l))

       		  	 	  	 	 	 	 	   			",cubic,"dp,greedy",838
"a = input()
b = input()

if len(a) < len(b):
    a = sorted(a)[::-1]
    print(''.join(a))
    exit(0)


def check(res, j, a):
    added = False
    tmp = """"
    for i in a:
        if i == j and not added:
            added = True
        else:
            tmp += i
    tmp = res + j + tmp[::-1]
    return tmp <= b


# len(a) == len(b)
res = """"
n = len(a)
a = sorted(list(a))[::-1]
for i in range(n):
    for j in a:
        if check(res, j, a):
            res += j
            a.remove(j)
            break
print(res)
",cubic,"dp,greedy",522
"a=[i for i in input()]
b=int(input())
a.sort(reverse=True)
ans = ''
while len(a) > 0:
    for i in range(len(a)):
        tmp = ans + a[i] + ''.join(sorted(a[:i] + a[i + 1:]))
        if int(tmp) <= b:
            ans += a[i]
            a = a[:i] + a[i + 1:]
            break
print(ans)
",cubic,"dp,greedy",289
"# -*- coding: utf-8 -*-
""""""
Created on Fri Sep 18 08:45:24 2020

@author: Dark Soul
""""""
def comp(a,b):
    x=len(a)
    s1=''
    s2=''
    for i in range(x):
        s1+=str(a[i])
        s2+=str(b[i])
    if s1>s2:
        return 1
    else:
        return 0
        
a=list(input(''))
b=list(input(''))
cnt=[0]*10
n=len(a)
m=len(b)
sol=''
for i in range(n):
    a[i]=int(a[i])
    cnt[a[i]]+=1

if n!=m:
    a.sort(reverse=True)
    for i in a:
        sol+=str(i)
    print(sol)
else:
    a.sort()
    
    for i in range(n):
        b[i]=int(b[i])
    for i in range(n-1):
        for j in range(i,n):
            if a[i]<a[j]:
                temp=a[i]
                a[i]=a[j]
                a[j]=temp
                if comp(a,b):
                    temp=a[i]
                    a[i]=a[j]
                    a[j]=temp
                
    
    for i in a:
        sol+=str(i)
    print(sol)",cubic,"dp,greedy",903
"from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop,heapify
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
input = sys.stdin.readline

from itertools import accumulate
from functools import lru_cache

M = mod = 998244353
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)
 
def li():return [int(i) for i in input().rstrip('\n').split()]
def st():return input().rstrip('\n')
def val():return int(input().rstrip('\n'))
def li2():return [i for i in input().rstrip('\n')]
def li3():return [int(i) for i in input().rstrip('\n')]


a = val()
b = val()

n = len(str(a))

a = [int(i) for i in str(a)]
a.sort()
if len(str(b)) > n:
    
    print(*sorted(a, reverse = 1), sep = '')
    exit()

b = str(b)
b = [int(i) for i in b]


def makenum(s):return int(''.join(str(e) for e in s))

def givemax(a, b):
    if len(a) > len(b):return a
    elif len(b) > len(a):return b
    else:
        for j in range(len(a)):
            if a[j] > b[j]:return a
            elif b[j] > a[j]:return b
        return a


@lru_cache(None)
def dp(l, equal = 1):

    if len(l) == 1:return str(-float('inf')) if l[0] > b[-1] and equal else str(l[0])
    if not equal:return ''.join(str(e) for e in sorted(l, reverse = 1))
    ans = ''
    l = list(l)
    curr = b[n - len(l)]
    for i in range(len(l)):
        if l[i] < curr and dp(tuple(l[:i] + l[i + 1:]), 0) != '-inf':
            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 0))
        elif l[i] == curr and dp(tuple(l[:i] + l[i + 1:]), 1) != '-inf':
            ans = givemax(ans, str(l[i]) + dp(tuple(l[:i] + l[i + 1:]), 1))

    return str(ans)

print(dp(tuple(a), 1))",cubic,"dp,greedy",1825
"import sys

a, b = input(), input()

if len(a) < len(b):
    print(*sorted(a, reverse=True), sep='')
    exit()

cnt = [0]*10

for x in a:
    cnt[int(x)] += 1


def rec(res, digit, rem):
    if digit == len(b):
        return res
    if rem[int(b[digit])]:
        r = rem[:]
        r[int(b[digit])] -= 1
        x = rec(res + b[digit], digit+1, r)
        if x:
            return x
    for d in range(int(b[digit])-1, -1, -1):
        if rem[d]:
            res += str(d)
            rem[d] -= 1
            suf = []
            for i in range(10):
                suf += [str(i)] * rem[i]
            return res + ''.join(sorted(suf, reverse=True))
    return ''


ans = rec('', 0, cnt[:])
print(ans)
",cubic,"dp,greedy",706
"
def make_number(b,chars):
	if len(chars) == 0:
		return """"
	target = chars[0]
	for i in chars:
		if int(b[0]) <= int(i):
			break
		target = i
	chars.remove(target)
	return target + """".join(chars[::-1])


def find_number(b,chars):
	backup_chars = list(chars)
	if len(b) == 1:
		return chars[0]
	elif b[0] in chars:
		chars.remove(b[0])
		num = b[0] + find_number(b[1:],chars)
		if min(num,b) == b and b != num:
			return make_number(b,backup_chars)
		else:
			return num

	else:
		return make_number(b,backup_chars)

a,b = str(input()), str(input())
chars = [i for i in a]
chars.sort()

if len(a) < len(b):
	print("""".join(chars[::-1]))
else:
	print(find_number(b,chars))",cubic,"dp,greedy",671
"a=input()
b=input()

if len(b)>len(a):

    l=[int(i) for i in a]
    l.sort()
    l=l[::-1]
    temp=[str(i) for i in l]
    s=''.join(temp)
    print(s)

else:
    d={}

    for i in a:

        if i not in d:

            d[i]=1
        else:

            d[i]=d[i]+1

  

    def find(i):

        global flag
        if i in d and d[i]>0:

            d[i]=d[i]-1

            return(i)

        for j in range(int(i),-1,-1):

            flag=1

            j=str(j)
            
            if j in d and d[j]>0:

                d[j]=d[j]-1

                return(j)

    def fun(d):

        l=[]
        for i in d:

            if d[i]>0:

                
                l=l+[int(i)]*d[i]
        l.sort()
        l=l[::-1]
        temp=[str(i) for i in l]

        s=''.join(temp)

        return(s)


    def fun2(x):

        global new
        for i in range(x-1,-1,-1):
            
            temp=new[i]
            for j in range(int(temp)-1,-1,-1):

                j=str(j)
                
                if j in d and d[j]>0:

                    new=new[:i]+str(j)
                    d[j]=d[j]-1

                    d[temp]=d[temp]+1

                    return(new)
                
            d[temp]=d[temp]+1

                    

                    

                    
                

            
        

    flag=0
    new=''
    for i in range(len(b)):
        
        if flag==0:

            temp=find(b[i])
            
            if temp==None:
              
                new=fun2(i)
           
                
                new=new+fun(d)

                break


                    

                

            else:
                new=new+temp
            
        else:

            new=new+fun(d)
            break
       

            
    print(new)

",cubic,"dp,greedy",1826
"def get(g):
    s = [str(i) for i in g]
    num = int("""".join(s))
    return num

a = input()
b = input()
bb = int(b)
mark = [0 for i in range(len(a))]
c = a
f = []
g = []

for i in range(0 , len(a)):
    g.append(a[i])

g.sort()
g.reverse()
num = get(g)

index = []
if num <= bb:
    print(num)
    exit(0)


for i in range(0 , min(len(a) , len(b))):
    mx = '-1'
    idx = 0
    for j in range(0 , len(a)):
        if mark[j] == 0 and a[j] <= b[i]:
            if a[j] > mx:
                mx = a[j]
                idx = j



    if mx == '-1':
        rem = []

        while True and len(f) > 0:
            ma = '-1'
            id = 0
            for j in range(0 , len(a)):
                if mark[j] == 0 and a[j] < f[-1]:
                    if a[j] > ma:
                        ma = a[j]
                        id = j

            if ma == '-1':
                mark[index.pop()] = 0
                f.pop()
                continue
            else:
                mark[index.pop()] = 0
                f.pop()
                f.append(ma)
                mark[id] = 1
                break


        for j in range(0, len(a)):
            if mark[j] == 0:
                rem.append(a[j])

        rem.sort()
        rem.reverse()

        for j in rem:
            f.append(j)

        print(get(f))
        exit(0)

    elif mx < b[i] and mx != '-1':
        f.append(mx)
        mark[idx] = 1
        index.append(idx)
        break
    elif mx == b[i] and mx != '-1':
        f.append(mx)
        mark[idx] = 1
        index.append(idx)

rem = []

for i in range(0 , len(a)):
    if mark[i] == 0:
        rem.append(a[i])

rem.sort()
rem.reverse()

for i in rem:
    f.append(i)

print(get(f))



",cubic,"dp,greedy",1719
"def get(g):
    s = [str(i) for i in g]
    num = int("""".join(s))
    return num

a = input()
b = input()
bb = int(b)
mark = [0 for i in range(len(a))]
c = a
f = []
g = []

for i in range(0 , len(a)):
    g.append(a[i])

g.sort()
g.reverse()
num = get(g)

index = []

if num <= bb:
    print(num)
    exit(0)


for i in range(0 , min(len(a) , len(b))):
    mx = '-1'
    idx = 0
    for j in range(0 , len(a)):
        if mark[j] == 0 and a[j] <= b[i]:
            if a[j] > mx:
                mx = a[j]
                idx = j

    if mx == '-1':
        rem = []

        while True and len(f) > 0:
            ma = '-1'
            id = 0
            for j in range(0 , len(a)):
                if mark[j] == 0 and a[j] < f[-1]:
                    if a[j] > ma:
                        ma = a[j]
                        id = j

            if ma == '-1':
                mark[index.pop()] = 0
                f.pop()
                continue
            else:
                mark[index.pop()] = 0
                f.pop()
                f.append(ma)
                mark[id] = 1
                break

        for j in range(0, len(a)):
            if mark[j] == 0:
                rem.append(a[j])

        rem.sort()
        rem.reverse()

        for j in rem:
            f.append(j)

        print(get(f))
        exit(0)

    f.append(mx)
    mark[idx] = 1
    index.append(idx)

    if mx < b[i] and mx != '-1':
        break

rem = []

for i in range(0 , len(a)):
    if mark[i] == 0:
        rem.append(a[i])

rem.sort()
rem.reverse()
for i in rem:
    f.append(i)

print(get(f))",cubic,"dp,greedy",1594
"def c(a, b, l, ans, pro):
    if l != 0:
        n = a[:]
        mx = None
        pro1 = pro
        prosh = set()
        for i in range(l):
            pro = pro1
            if a[i] == prosh:
                continue
            elif (a[i] <= b[0] and pro):
                n.pop(i)
                prosh = a[i]
                if pro == True:
                    if a[i] < b[0]:
                        pro = False
                m = c(n, b[1:], l-1, ans+str(a[i]), pro)
                n = a[:]
                if m != None:
                    if mx == None:
                        mx = int(m)
                    elif mx < int(m):
                        mx = int(m)
            elif not(pro):
                a.sort(reverse = True)
                a = list(map(str, a))
                return ans +''.join(a)
            else:
                break
        return mx            
    else:
        return ans
a = input()
b = input()
l = len(a)
if len(a) != len(b):
    a = list(a)
    a.sort()
    print(''.join(a[::-1]))
else:    
    a = list(map(int, a))
    b = list(map(int, b))
    a.sort()
    n = a[:]
    mx = 0
    prosh = -1
    for i in range(l):
        if a[i] == prosh:
            continue
        elif a[i] != 0 and a[i] <= b[0]:
            n.pop(i)
            prosh = a[i]
            pro = False
            if a[i] == b[0]:
                pro = True
            m = c(n, b[1:], l-1, str(a[i]), pro)
            n = a[:]
            if m != None:
                if mx < int(m):
                    mx = int(m)
        elif a[i] > b[0]:
            break
    print(mx)",cubic,"dp,greedy",1601
"def c(a, b, l, ans, pro):
    if l != 0:
        n = a[:]
        mx = None
        pro1 = pro
        prosh = set()
        for i in range(l):
            pro = pro1
            if a[i] == prosh:
                continue
            elif (a[i] <= b[0] and pro):
                n.pop(i)
                prosh = a[i]
                if pro == True:
                    if a[i] < b[0]:
                        pro = False
                m = c(n, b[1:], l-1, ans+str(a[i]), pro)
                n = a[:]
                if m != None:
                    if mx == None:
                        mx = int(m)
                    elif mx < int(m):
                        mx = int(m)
            elif not(pro):
                a.sort(reverse = True)
                a = list(map(str, a))
                return ans +''.join(a)
            else:
                break
        return mx            
    else:
        return ans
a = input()
b = input()
l = len(a)
if len(a) != len(b):
    a = list(a)
    a.sort()
    print(''.join(a[::-1]))
else:    
    a = list(map(int, a))
    b = list(map(int, b))
    a.sort()
    n = a[:]
    mx = 0
    prosh = -1
    for i in range(l):
        if a[i] == prosh:
            continue
        elif a[i] != 0 and a[i] <= b[0]:
            n.pop(i)
            prosh = a[i]
            pro = False
            if a[i] == b[0]:
                pro = True
            m = c(n, b[1:], l-1, str(a[i]), pro)
            n = a[:]
            if m != None:
                if mx < int(m):
                    mx = int(m)
        elif a[i] > b[0]:
            break
    print(mx)
    ",cubic,"dp,greedy",1606
"from sys import stdin
from collections import Counter

rstr = lambda: stdin.readline().strip()
a, b = list(rstr()), list(rstr())

if len(a) < len(b) or len(a) == 1:
    print(''.join(sorted(a)[::-1]))
else:
    ans, tem = 0, []

    for i in range(len(b)):
        for j in range(int(b[i]) - 1, -1, -1):
            if str(j) in a and not (j == i == 0):
                a.remove(str(j))
                ans = max(ans, int(''.join(tem) + str(j) + ''.join(sorted(a)[::-1])))
                a.append(str(j))
                break

        if b[i] not in a:
            break

        tem.append(b[i])
        a.remove(b[i])
        
    if tem:
        ans = max(ans, int(''.join(tem)))

    print(ans)
",cubic,"dp,greedy",701
"a = input()
b = input()
digits = {}
def greedy(digits,s):
    for i in range(9,-1,-1):
        d = str(i)
        if d in digits:
            while digits[d] > 0:
                s += d
                digits[d] -= 1
    return s
for d in a:
    if d in digits:
        digits[d] += 1
    else:
        digits[d] = 1
if len(a) < len(b):
    print(greedy(digits,""""))
else:
    ind = 0
    cur = """"
    back = False
    done = False
    while 1:
        if ind == len(a) or done == True:
            break
        found = False
        for i in range(9,-1,-1):
            x = str(i)
            if i == int(b[ind]) and x in digits and digits[x] > 0:
                found = True
                digits[x] -= 1
                cur += x
                break
            elif i < int(b[ind]) and x in digits and digits[x] > 0:
                found = True
                done = True
                digits[x] -= 1
                cur += x
                print(greedy(digits,cur))
                break
        if found == False:
            back = True
            break
        ind += 1
    
    if back == False and done == False:
        print(cur)
    elif done == False:
        for i in range(ind-1,-1,-1):
            digits[cur[i]] += 1
            for j in range(9,-1,-1):
                d = str(j)
                if j < int(b[i]) and d in digits and digits[d] > 0:
                    done = True
                    s = cur[:i]
                    s += d
                    digits[d] -= 1
                    print(greedy(digits,s))
                    break
            if done:
                break",cubic,"dp,greedy",1614
"a = list(input())
b = int(input())
a.sort(reverse=True)
# print(a)
ans=''
while a:
    for i in range(len(a)):
        temp=''
        x=ans+a[i]+temp.join(sorted(a[:i]+a[i+1:]))
        if int(x)<=b:
            ans+=a[i]
            a=a[:i]+a[i+1:]
            break
print(int(ans))",cubic,"dp,greedy",284
"n, m, k = map(int, input().split())
DATA = [input() for i in range(n)]

#dp[n_day][used_cost]
#ans = min(dp[n_day][used_cost] for used_cost in range(k + 1))
#dp[n_day][used_cost] := min(dp[n_day - 1][prev_cost] + cost(pay used_cost - prev_cost in n_day) for prev_cost in range(used_cost + 1))
INF = 1 << 60
dp = [[INF]*(k + 10) for i in range(n + 10)]
dp[0][0] = 0

COST = [[INF]*(k + 10) for i in range(n + 10)]
for i, string in enumerate(DATA):
    #COST[i + 1]
    stack = []
    for j in range(m):
        if string[j] == ""1"":
            stack.append(j)
    L = len(stack)
    for j in range(k + 10):
        if j >= L:
            COST[i + 1][j] = 0
            continue
        else:
            for pos in range(j + 1):
                l = pos
                r = pos + L - 1 - j
                COST[i+1][j] = min(COST[i+1][j], stack[r] - stack[l] + 1)
for day in range(1, n + 1):
    for used_cost in range(k + 1):
        dp[day][used_cost] = min(dp[day - 1][prev_cost] + COST[day]
                                 [used_cost - prev_cost] for prev_cost in range(used_cost + 1))

ans = min(dp[n][used_cost] for used_cost in range(k + 1))
print(ans)
",cubic,dp,1159
"# ///////////////////////////////////////////////////////////////////////////
# //////////////////// PYTHON IS THE BEST ////////////////////////
# ///////////////////////////////////////////////////////////////////////////
import sys,os,io
from sys import stdin
import math 
from collections import defaultdict
from heapq import heappush, heappop, heapify
from bisect import bisect_left , bisect_right
from io import BytesIO, IOBase
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")




alphabets = list('abcdefghijklmnopqrstuvwxyz')



#for deep recursion__________________________________________-
from types import GeneratorType
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to

    return wrappedfunc

def ncr(n, r, p):  
    num = den = 1
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den,p - 2, p)) % p

def primeFactors(n): 
    l = []
    while n % 2 == 0: 
        l.append(2)
        n = n / 2
    for i in range(3,int(math.sqrt(n))+1,2): 
        while n % i== 0: 
            l.append(int(i))
            n = n / i 
    if n > 2: 
        l.append(n)
    # c = dict(Counter(l))
    return list(set(l))
    # return c

def power(x, y, p) : 
	res = 1
	x = x % p 
	if (x == 0) : 
		return 0
	while (y > 0) : 
		if ((y & 1) == 1) : 
			res = (res * x) % p 
		y = y >> 1	 # y = y/2 
		x = (x * x) % p 		
	return res 

#____________________GetPrimeFactors in log(n)________________________________________
def sieveForSmallestPrimeFactor():
    MAXN = 100001
    spf = [0 for i in range(MAXN)]
    spf[1] = 1
    for i in range(2, MAXN):
        spf[i] = i
    for i in range(4, MAXN, 2):
        spf[i] = 2
    for i in range(3, math.ceil(math.sqrt(MAXN))):
        if (spf[i] == i):
            for j in range(i * i, MAXN, i): 
                if (spf[j] == j):
                    spf[j] = i
    return spf
def getPrimeFactorizationLOGN(x):
    spf = sieveForSmallestPrimeFactor()
    ret = list()
    while (x != 1):
        ret.append(spf[x])
        x = x // spf[x]  
    return ret
#____________________________________________________________



def SieveOfEratosthenes(n): 
    #time complexity = nlog(log(n))
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime
def si():
    return input()
def divideCeil(n,x):
    if (n%x==0):
        return n//x
    return n//x+1
def ii():
    return int(input())
def li():
    return list(map(int,input().split()))


n,m,k = li()
dp = [0]*(k+1)   
l = []
fk = None
for _ in range(n):
    s = list(si())
    d = []
    if list(set(s))==['0']:
        d.append(0)
        continue
    one = []
    for i in range(len(s)):
        if s[i]=='1':
            one.append(i)
    ni = len(one)
    d = [1e9]*(ni+1)
    d[-1]=0
    for i in range(ni):
        for j in range(i, ni):
            d[ni-(j-i+1)] = min(d[ni-(j-i+1)], one[j]-one[i]+1)
    l.append(d)
    fk = [1e9]*(k+1)    
    for i in range(k+1):
        for j in range(ni+1):
            if i+j>k:
                break
            fk[i+j] = min(fk[i+j] , dp[i] +d[j])
    dp = fk[:]
        # print(dp,k)
# print(dp)

print(min(dp))

",cubic,dp,5199
"R = lambda: map(int, input().split())
n, m, k = R()
cls = [list(i for i, x in enumerate(map(int, input())) if x) for _ in range(n)]
dp = [[n * m] * (k + 1) for i in range(n + 1)]
dp.append([0] * (k + 1))
for i in range(n):
    row = cls[i]
    c2l = [m + 1] * (m + 1)
    c2l[0] = row[-1] - row[0] + 1 if row else 0
    c2l[len(row)] = 0
    for r in range(len(row)):
        for l in range(r + 1):
            c2l[len(row) - (r - l + 1)] = min(c2l[len(row) - (r - l + 1)], row[r] - row[l] + 1)
    for j in range(k + 1):
        for c, l in enumerate(c2l):
            if j + c <= k and l < m + 1:
                dp[i][j] = min(dp[i][j], dp[i - 1][j + c] + l)
print(min(dp[n - 1]))",cubic,dp,683
"def min_sub_array(day, k):
    if not day:
        return [0] * (k + 1)
    n = len(day)
    best = [float('inf')] * (n + 1)
    best[0] = 0
    best[1] = 1
    for size in range(2, n + 1):
        for i in range(n + 1 - size):
            best[size] = min(best[size], day[i + size - 1] - day[i] + 1)
    output = [0] * (k + 1)
    for i in range(k + 1):
        if n - i > 0:
            output[i] = best[n - i]
    return output


N, M, K = map(int, input().split())

day = [i for i, val in enumerate(input()) if val == '1']
best = min_sub_array(day, K)

for _ in range(N - 1):
    day = [i for i, val in enumerate(input()) if val == '1']
    new_day_best = min_sub_array(day, K)

    new_best = [float('inf')] * (K + 1)
    for i in range(K + 1):
        for j in range(i + 1):
            new_best[i] = min(new_best[i], new_day_best[j] + best[i - j])
    best = new_best
print(best[K])
",cubic,dp,890
"import math
#import math 
#------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
#-------------------game starts now----------------------------------------------------import math
def calc(st,j):
    ans=9999999999999999999999
    #print(st)
    if j>=len(st):
        return 0
    j=len(st)-j
    for i in range(j-1,len(st)):
        ans=min(ans,st[i]-st[i-j+1]+1)
    return ans
n,m,k=map(int,input().split())
s=[]
for i in range(n):
    s.append(input())
inf=99999999999999999999
dp=[[inf for i in range(k+1)]for j in range(n+1)]
for i in range(k+1):
    dp[0][i]=0 
for i in range(1,n+1):
    st=[]
    for ik in range(len(s[i-1])):
        if s[i-1][ik]=='1':
            st.append(ik)
    for j in range(k+1):
        no=calc(st,j) 
        #print(no,j)
        for t in range(k+1-j):
            dp[i][t+j]=min(dp[i][t+j],no+dp[i-1][t])
#print(dp)
print(dp[n][k])
    
        ",cubic,dp,2612
"from sys import stdin

rstr = lambda: stdin.readline().strip()
rints = lambda: [int(x) for x in stdin.readline().split()]

n, m, k = rints()
a = [rstr() for _ in range(n)]
mem = [[float('inf') if i else 0 for _ in range(k + 1)] for i in range(n + 1)]

for i in range(n):
    ixs = []
    for j in range(m):
        if a[i][j] == '1':
            ixs.append(j)

    for j in range(k + 1):
        tem = 0
        if j < len(ixs):
            tem, c = float('inf'), 0
            for j1 in range(len(ixs) - j - 1, len(ixs)):
                tem = min(tem, ixs[j1] - ixs[c] + 1)
                c += 1

        for j1 in range(k + 1 - j):
            mem[i + 1][j1 + j] = min(mem[i + 1][j1 + j], mem[i][j1] + tem)

print(mem[n][k])
# print(mem)
",cubic,dp,742
"import sys
input = sys.stdin.readline

def int_array():
	return list(map(int, input().strip().split()))

def float_array():
	return list(map(float, input().strip().split()))

def str_array():
	return input().strip().split()
from collections import Counter
import math
import bisect
from collections import deque
n,m,lesson=int_array()
dp=[[250005 for i in range(lesson+2)]for j in range(n+1)]
days=[[] for i in range(n)]
for i in range(n):
	s=input()
	for  j in range(m):
		if s[j]==""1"":
			days[i].append(j+1)

m=[[250005 for i in range(lesson+2)]for j in range(n+1)]
for i in range(n):
	for j in range(lesson+1):
		if j<=len(days[i]):
			if j==len(days[i]):
				m[i][j]=0
				continue
			else:
				for k  in range(0,j+1):
					var=days[i][0+k]
					var1=days[i][-1*max(1,1+(j-k))]
					m[i][j]=min(m[i][j],var1-var+1)



for i in range(lesson+1):
	dp[0][i]=m[0][i]
for i in range(1,n):
	for j in range(lesson+1):
		for k in range(j+1):

			dp[i][j]=min(dp[i][j],dp[i-1][j-k]+m[i][k])
			#dp[i][j] = min(dp[i][j], dp[i - 1][k]+m[i][j-k])

print(min(dp[n-1]))

",cubic,dp,1061
"import sys

n, m, k = map(int, input().split())
table = [input() for _ in range(n)]

dp = [0]*(k+1)

for a in table:
    one = []
    for i in range(m):
        if a[i] == '1':
            one.append(i)

    if not one:
        continue

    ni = len(one)
    subdp = [10**9] * (ni+1)
    subdp[-1] = 0

    for i in range(ni):
        for j in range(i, ni):
            subdp[ni-(j-i+1)] = min(subdp[ni-(j-i+1)], one[j]-one[i]+1)

    next_dp = [10**9]*(k+1)
    for i in range(k, -1, -1):
        for j in range(ni+1):
            if i+j > k:
                break
            next_dp[i+j] = min(next_dp[i+j], dp[i] + subdp[j])
    dp = next_dp

print(min(dp))
",cubic,dp,663
"# O(n*2^n) (however quite a few states are not visited)
# most important optimization is not transitioning from unvisited states
#   (only ~ 1% of states are visited) (transition is O(n))
# other optimizations are using floats, bitwise operators, and precomputing dists/ reducing ops
xs,ys = map(float,input().split())

n = int(input())

dist = [[0]*(n+1) for i in range(n+1)]
dist2 = [[0]*(n) for i in range(n)]

objects = [list(map(float,input().split())) for i in range(n)] + [[xs,ys]] # objects[n] is handbag

for i in range(n+1):
    for j in range(n+1):
        dist[i][j] = (objects[i][0] - objects[j][0])**2 + (objects[i][1] - objects[j][1])**2

for i in range(n):
    for j in range(n):
        dist2[i][j] = dist[n][i] + dist[i][j] + dist[j][n]

dp = [1e6]*(1<<n)
vis = set([0]) #alot of states are not visited after optimization
dp[0] = 0

for i in range((1<<n)-1):
    if i in vis:
        # reduce O(n^2) transition to O(n) via assuming 1 of the objects taken must be the
        # first object not yet taken in order
        for j in range(n):
            if i&(1<<j) == 0:
                # get 1 new object
                newi = i + (1 << j)
                dp[newi] = min(dp[newi], dp[i] + 2*dist[n][j])
                vis.add(newi)

                for k in range(j+1,n):
                    # get 2 new objects at a time
                    if i&(1<<k) == 0:
                        newi |= 1<<k
                        dp[newi] = min(dp[newi], dp[i] + dist2[j][k])
                        vis.add(newi)
                        newi ^= 1<<k

                break

curr = (1<<n) - 1
path = [0]
while curr:
    for i in range(n):
        if curr & (1<<i):
            # 1 object taken
            if dp[curr] == dp[curr - (1<<i)] + 2*dist[n][i]:
                path.extend([i+1,0])
                curr ^= (1<<i)

            # 2 objects taken
            for j in range(i+1,n):
                if curr & (1<<j):
                    if dp[curr] == dp[curr - (1<<i) - (1<<j)] + dist2[i][j]:
                        path.extend([j+1,i+1,0])
                        curr ^= (1<<i) + (1<<j)

print(int(dp[(1<<n)-1]))
print(*path[::-1])",np,"bitmasks,dp",2152
"# from itertools import combinations

CANDNUM = 5

I = lambda: [int(x) for x in raw_input().split()]
T = lambda x1, y1, x2, y2: (x1-x2)**2+(y1-y2)**2
			
def getCandidates(tsLst, curN, notSeen):
	r = []
	curD = {}
	k = 0
	cand = None
	curSet = set()
	for x in tsLst:
		i, j = x
		curSet.add(i)
		if len(curSet) == curN-1:
			cand = list(notSeen - curSet)[0]
			break
		curSet.add(j)
		if len(curSet) == curN-1:
			cand = list(notSeen - curSet)[0]
			break
	i = 0
	for x in tsLst:
		if cand in x:
			r.append(x)
			i += 1
			if i == CANDNUM:
				break
	return r

def solve(xs, ys, n, oLst):
	def solveEven(seen):
		def solveEvenRec(notSeen, tsLst):
			if len(notSeen) == 0:
				return 0, []
			ns = tuple(notSeen)
			if ns in solveEvenRec.d:
				return solveEvenRec.d[ns]
			minLst = []
			minT = 10000000

			cands = getCandidates(tsLst, len(notSeen), notSeen)
			for x in cands:
				i, j = x
				newNotSeen = notSeen.copy()
				if i in newNotSeen:
					newNotSeen.remove(i)
				if j in newNotSeen:
					newNotSeen.remove(j)
				newTsLst = []
				for x1 in tsLst:
					i1, j1 = x1
					if i1 in newNotSeen and j1 in newNotSeen:
						newTsLst.append(x1)
				rT, rLst = solveEvenRec(newNotSeen, newTsLst)
				rT += ts[x]
				if rT < minT:
					minT = rT
					minLst = [x] + rLst
			r = minT, minLst
			solveEvenRec.d[ns] = r
			return r
		solveEvenRec.d = {}
			
		newLst = []
		for i in range(n):
			if i not in seen:
				newLst.append(i)
		newN = n - len(seen)
		if newN == 2:
			minT = 10000000
			minLst = []
			for a in ts:
				if ts[a] < minT:
					minT = ts[a]
					minLst = [a]
			rT = minT
			rLst = minLst
		else:
			newTsLst = []
			for x in tsLst:
				a, _ = x
				i, j = a
				if i not in seen and j not in seen:
					newTsLst.append(a)
			notSeen = set(range(n)) - set(seen)
			rT, rLst = solveEvenRec(notSeen, newTsLst)
		return rT, rLst
	ts = {}
	tss = {}
	for i in range(n-1):
		x1, y1 = oLst[i]
		for j in range(i+1, n):
			x2, y2 = oLst[j]
			t = T(x1, y1, x2, y2)
			t1 = T(x1, y1, xs, ys)
			t2 = T(xs, ys, x2, y2)
			if t1+t2 >= t:
				ts[(i, j)] = t
				tss[(i, j)] = True
			else:
				ts[(i, j)] = t1+t2
				tss[(i, j)] = False
	tsLst = []
	for x in ts:
		tsLst.append((x, ts[x]))
	tsLst.sort(key=lambda x:x[1])
	if n%2:
		if n > 1:
			resT = 10000000
			resLst = []
			for i in range(n):
				x, y = oLst[i]
				t = 2*T(x, y, xs, ys)
				rT, rLst = solveEven([i])
				for a in rLst:
					i1, i2 = a
					x1, y1 = oLst[i1]
					x2, y2 = oLst[i2]
					rT += T(xs, ys, x1, y1)
					rT += T(xs, ys, x2, y2)
				rT += t
				if rT < resT:
					resT = rT
					newRLst = ['0']
					for a in rLst:
						w, v = a
						if tss[(w, v)]:
							newRLst.append(str(w+1))
							newRLst.append(str(v+1))
							newRLst.append('0')
						else:
							newRLst.append(str(w+1))
							newRLst.append('0')
							newRLst.append(str(v+1))
							newRLst.append('0')
					newRLst.append(str(i+1))
					newRLst.append('0')
					resLst = newRLst
		else:
			x, y = oLst[0]
			resT = 2*T(x, y, xs, ys)
			resLst = ['0', '1', '0']
	else:
		resT, rLst = solveEven([])
		for a in rLst:
			i1, i2 = a
			x1, y1 = oLst[i1]
			x2, y2 = oLst[i2]
			resT += T(xs, ys, x1, y1)
			resT += T(xs, ys, x2, y2)
		newRLst = ['0']
		for a in rLst:
			w, v = a
			if tss[(w, v)]:
				newRLst.append(str(w+1))
				newRLst.append(str(v+1))
				newRLst.append('0')
			else:
				newRLst.append(str(w+1))
				newRLst.append('0')
				newRLst.append(str(v+1))
				newRLst.append('0')
		resLst = newRLst
	return resT, resLst

xs, ys = I()
n = input()
oLst = []
for _ in range(n):
	x, y = I()
	oLst.append((x, y))
resT, resLst = solve(xs, ys, n, oLst)
print(resT)
print(' '.join(resLst))	",np,"bitmasks,dp",3661
"xs, ys = map(int, input().split())
things = [[xs, ys, 0]]
n = int(input())
for i in range(n):
    things.append(list(map(int, input().split())) + [i + 1])


distance = [[0 for i in range(n + 1)] for j in range(n + 1)]
for i in range(n + 1):
    for j in range(i, n + 1):
        distance[i][j] = distance[j][i] = (things[i][0] - things[j][0]) ** 2 + (things[i][1] - things[j][1]) ** 2

INF = float('inf')
DP = [INF for _ in range((1 << n) + 10)]
Path = [None for _ in range((1 << n) + 10)]
DP[0] = 0

for cur in range(1 << n):
    if DP[cur] == INF:
        continue
    for nxt1 in range(n):
        if cur & (1 << nxt1) != 0:
            continue
        
        if DP[cur | (1 << nxt1)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]:
            DP[cur | (1 << nxt1)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][0]
            Path[cur | (1 << nxt1)] = cur
        
        for nxt2 in range(n):
            if (cur | (1 << nxt1)) & (1 << nxt2) != 0:
                continue
            if DP[cur | (1 << nxt1) | (1 << nxt2)] > DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]:
                DP[cur | (1 << nxt1) | (1 << nxt2)] = DP[cur] + distance[0][nxt1 + 1] + distance[nxt1 + 1][nxt2 + 1] + distance[nxt2 + 1][0]
                Path[cur | (1 << nxt1) | (1 << nxt2)] = cur
        break

print(DP[(1 << n) - 1])

path = []
cur = (1 << n) - 1
while cur != 0:
    path.append(0)
    father = Path[cur]
    diff = cur ^ father
    d1 = len(bin(diff)[2:])
    path.append(d1)
    diff ^= (1 << (d1 - 1))
    if diff != 0:
        d2 = len(bin(diff)[2:])
        path.append(d2)
    cur = father
path.append(0)
path = list(reversed(path))
print(' '.join(map(str, path)))",np,"bitmasks,dp",1737
"from itertools import chain
from time import time

def main():

    BITS = [1 << sh for sh in range(24)]
    B2N = {v: u for u, v in enumerate(BITS)}

    def getPt():
        return tuple(map(int, input().split()))

    def dist(ptA, ptB):
        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))

    def getBits(val):
        return tuple(filter(lambda x: x&val, BITS))

    def chooseTwo(pool):
        n = len(pool)
        for i in range(n):
            for j in range(i+1, n):
                yield (pool[i], pool[j])

    ori = getPt()
    pts = []
    N = int(input())

    for _ in range(N):
        pts.append(getPt())

    vis = set([0])
    mint = [0]+[1e8]*(1<<N) 
    pres = [None]*(1<<N) 
    allb = (1 << N)-1 
    B2P = {BITS[u]: v for u, v in enumerate(pts)}
    B2P[0] = ori
    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}

    getDP = lambda x: mint[x]
    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \
                                + alld[p[0]][0] \
                                + alld[p[1]][0] 

    for stt in range(1<<N):
        if stt not in vis:
            continue

        bits = getBits(~stt&allb)

        sb = bits[0] if bits else None

        for bit in bits:

            newstt = stt | sb | bit
            nd = newDist(stt, (sb, bit))
            if getDP(newstt) > nd:
                mint[newstt] = nd
                pres[newstt] = sb | bit
                vis.add(newstt)

    print(mint[allb])
    path = ['0']
    stt = allb

    while stt:

        bits = getBits(pres[stt])
        for bit in bits:
            path.append(str(B2N[bit]+1))
        path.append('0')

        stt ^= pres[stt]

    print(' '.join(path))


import sys
st = time()
main()
print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",np,"bitmasks,dp",1795
"#!/usr/bin/env python
'''
' Author:   Cheng-Shih Wong
' Email:    mob5566@gmail.com
' Date:     2017-08-08
'''

from itertools import chain
from time import time

def main():

    BITS = [1 << sh for sh in range(24)]
    B2N = {v: u for u, v in enumerate(BITS)}

    def getPt():
        return tuple(map(int, input().split()))

    def dist(ptA, ptB):
        return sum(((u-v)**2 for u, v in zip(ptA, ptB)))

    def getBits(val):
        return tuple(filter(lambda x: x&val, BITS))

    def chooseTwo(pool):
        n = len(pool)
        for i in range(n):
            for j in range(i+1, n):
                yield (pool[i], pool[j])

    ori = getPt()
    pts = []
    N = int(input())

    for _ in range(N):
        pts.append(getPt())

    vis = set([0])
    mint = [0]+[1e8]*(1<<N) # minimal time for dp
    pres = [None]*(1<<N) # previous step for reconstruct path
    allb = (1 << N)-1 # all objects contained state
    B2P = {BITS[u]: v for u, v in enumerate(pts)}
    B2P[0] = ori
    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}

    getDP = lambda x: mint[x]
    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \
                                + alld[p[0]][0] \
                                + alld[p[1]][0] 

    for stt in range(1<<N):
        if stt not in vis:
            continue

        bits = getBits(~stt&allb)

        sb = bits[0] if bits else None

        for bit in bits:

            newstt = stt | sb | bit
            nd = newDist(stt, (sb, bit))
            if getDP(newstt) > nd:
                mint[newstt] = nd
                pres[newstt] = sb | bit
                vis.add(newstt)

    print(mint[allb])
    path = ['0']
    stt = allb

    while stt:

        bits = getBits(pres[stt])
        for bit in bits:
            path.append(str(B2N[bit]+1))
        path.append('0')

        stt ^= pres[stt]

    print(' '.join(path))

if __name__ == '__main__':
    import sys
    st = time()
    main()
    print('Run {:.6f} seconds.'.format(time()-st), file=sys.stderr)",np,"bitmasks,dp",2035
"import sys


def main():
    BITS = [1 << sh for sh in range(24)]
    B2N = {v: u for u, v in enumerate(BITS)}

    def getPt():
        return tuple(map(int, input().split()))

    def dist(ptA, ptB):
        return sum(((u - v) ** 2 for u, v in zip(ptA, ptB)))

    def getBits(val):
        return tuple(filter(lambda x: x & val, BITS))

    def chooseTwo(pool):
        n = len(pool)
        for i in range(n):
            for j in range(i + 1, n):
                yield (pool[i], pool[j])

    ori = getPt()
    pts = []
    N = int(input())

    for _ in range(N):
        pts.append(getPt())

    vis = set([0])
    mint = [0] + [1e8] * (1 << N)  # minimal time for dp
    pres = [None] * (1 << N)  # previous step for reconstruct path
    allb = (1 << N) - 1  # all objects contained state
    B2P = {BITS[u]: v for u, v in enumerate(pts)}
    B2P[0] = ori
    alld = {u: {v: dist(B2P[u], B2P[v]) for v in B2P} for u in B2P}

    getDP = lambda x: mint[x]
    newDist = lambda stt, p: mint[stt] + alld[p[0]][p[1]] \
                             + alld[p[0]][0] \
                             + alld[p[1]][0]

    for stt in range(1 << N):
        if stt not in vis:
            continue

        bits = getBits(~stt & allb)

        sb = bits[0] if bits else None

        for bit in bits:

            newstt = stt | sb | bit
            nd = newDist(stt, (sb, bit))
            if getDP(newstt) > nd:
                mint[newstt] = nd
                pres[newstt] = sb | bit
                vis.add(newstt)

    print(mint[allb])
    path = ['0']
    stt = allb

    while stt:

        bits = getBits(pres[stt])
        for bit in bits:
            path.append(str(B2N[bit] + 1))
        path.append('0')

        stt ^= pres[stt]

    print(' '.join(path))


main()
",np,"bitmasks,dp",1778
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2
# print(arr)
# print(dist)

def dfs(status, memo, pp):
    # if status in memo:
    #     return memo[status][0]
    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))
        # print(memo, pp)
        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev
    # print(prev)
    # print(status, res)
    return res


# memo = {1: [0, []]}
memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end
# print(memo, pp)
while cur > 0:
    prev = pp[cur]
    # if len(prev) == 2:
    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))



",np,"bitmasks,dp",1769
"x0, y0 = map(int, input().split())
n = int(input())
arr = [[x0, y0]]
for i in range(0, n):
    x, y = map(int, input().split())
    arr.append([x, y])
dist = [[0 for j in range(0, n+1)] for i in range(0, n+1)]
for i in range(0, n+1):
    for j in range(0, n+1):
        dist[i][j] = (arr[i][0] - arr[j][0])**2 + (arr[i][1] - arr[j][1])**2

def dfs(status, memo, pp):
    if memo[status] != None:
        return memo[status]
    if status < 0:
        return 1e8
    res = 1e8
    prev = []
    for i in range(1, n+1):
        if (status & (1 << (i - 1))) == 0:
            continue
        t1 = status ^ (1 << (i - 1))
        # print(memo, pp)
        temp = dfs(t1, memo, pp) + dist[0][i]*2
        if temp < res:
            res = temp
            prev = [i, 0]
        for j in range(i+1, n+1):
            if j == i:
                continue
            if (t1 & (1 << (j - 1))) == 0:
                continue
            next = t1 ^ (1 << (j - 1))
            temp = dfs(next, memo, pp) + dist[0][j] + dist[j][i] + dist[i][0]
            if temp < res:
                res = temp
                prev = [i, j, 0]
        break
    memo[status] = res
    pp[status] = prev
    return res


memo = [None for i in range(0, 1 << n)]
pp = [None for i in range(0, 1 << n)]
memo[0] = 0
pp[0] = []
start = 0
end = 0
for i in range(0, n):
    end += (1 << i)
res = dfs(end, memo, pp)
path = [0]
cur = end
while cur > 0:
    prev = pp[cur]
    path.extend(prev)
    for i in range(len(prev) - 1):
        cur -= (1 << (prev[i] - 1))

print(res)
print(' '.join(map(str, path)))



",np,"bitmasks,dp",1576
"
n = int(input())


p = []
for i in range(n):
    la = list(map(float,input().split()))
    p.append(la)

full_bit =  (1<<n) - 1
dp = [0]*(full_bit) + [1]

for i in range(full_bit,0,-1):

    cunt = bin(i)[2:].count('1')
    # print(cunt)
    if cunt == 1 or dp[i] == 0:
        continue

    mul = 1/((cunt*(cunt-1))>>1)

    for x in range(n):
        if (i & (1<<x)) == 0:
            continue
        for y in range(x+1,n):
            if (i & (1<<y)) == 0:
                continue

            dp[i-(1<<y)]+=dp[i]*p[x][y]*mul
            dp[i-(1<<x)]+=dp[i]*p[y][x]*mul

ans = []
for i in range(n):
    ans.append(dp[1<<i])

print(*ans)





",np,"bitmasks,dp,probabilities",648
"import sys
input=sys.stdin.readline

def count_bits(x):
    cnt=0
    for i in range(n):
        if((1<<i)&x):
            cnt+=1
    return(cnt)

n=int(input())
a=[list(map(float,input().split())) for i in range(n)]
dp=[0 for i in range(1<<n)] #Probabilty a particular permutation of (alive) fish are acheived.
dp[-1]=1 #We start with all fish, so the probability they all together is 1(base case)
#We will calculate the probability of acheiving a particular permutation of k alive fish from all possible permutations of k+1 alive fish for all values of k.
for mask in range((1<<n)-1,-1,-1):
    val=count_bits(mask)
    total=val*(val-1)//2 #Used to calculate the probability of choosing two fish among the alive fish. We will take the case the first fish eats the second fish(the opposite case is dealt again in another loop, won't increase efficiency much), and add to the new permutation the probability of obtaiining it from the current permutation.
    for i in range(n):
        if(mask&(1<<i)==0): #We can't choose a dead/eaten fish
            continue
        for j in range(n): #Second fish of the pair for the above choosen fish among all other alive fish
            if(mask&(1<<j)==0 or i==j):
                continue
            dp[mask^(1<<j)]+=dp[mask]*a[i][j]/total #considering ith fish eats jth fish
for i in range(n):
    print(dp[1<<i])
",np,"bitmasks,dp,probabilities",1361
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def count(x):
    ans = 0
    while x:
        x &= x-1
        ans += 1
    return ans

def main():
    n = int(input())
    a = [list(map(float,input().split())) for _ in range(n)]
    y = 1<<n
    dp = [0]*(y-1)+[1]
    powe = [1<<i for i in range(n)]
    for i in range(y-1,0,-1):
        bit = count(i)
        prob = bit*(bit-1)//2
        for j in range(n):
            if not i&powe[j]:
                continue
            for x in range(n):
                if not i&powe[x]:
                    continue
                dp[i-powe[x]] += dp[i]*a[j][x]*prob
                dp[i-powe[j]] += dp[i]*a[x][j]*prob
    z = sum(dp[1<<i] for i in range(n))
    for i in range(n):
        print(dp[1<<i]/z,end=' ')
    print()

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")
sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np,"bitmasks,dp,probabilities",2508
"n = int(input())
probs = list()
for i in range(n): probs.append(list(map(float, input().split())))
dp = [list([0 for i in range(1<<n)]) for i in range(n)]
dp[0][(1<<n)-1] = 1
ak = [list() for i in range(n+1)]
for i in range(1<<n):
    ak[bin(i).count(""1"")].append(i)
for k in range(1, n):
    for ele in ak[n-k+1]:
        for j in range(n):
            if (ele&(1<<j)):
                for w in range(n):
                    if (ele&(1<<w)) and j != w:
                        dp[k][ele-(1<<j)] += (dp[k-1][ele]*probs[w][j])/(((n-k+1)*(n-k))/2)
for i in range(n):
    print(dp[n-1][(1<<i)], end = "" "")
print()",np,"bitmasks,dp,probabilities",610
"n=int(input())
b=[]
for i in range(n):
    b.append(list(map(float,input().split())))

ma=1<<n
dp=[0 for j in range(ma)]
dp[0]=1
for mask in range(1,ma):
    l=n-bin(mask).count(""1"")+1
    res=l*(l-1)//2
    for i in range(n):
        if mask&(1<<i):
            for j in range(n):
                if not mask&(1<<j):

                    dp[mask]+=((dp[mask^(1<<i)]*b[j][i])/res)


ans=[]
for i in range(n):
    ans.append(dp[ma-1-(1<<i)])
print(*ans)

",np,"bitmasks,dp,probabilities",454
"from sys import stdin
input=stdin.readline

def count(n):

    value=0
    while(n):
        n &= (n-1)
        value+=1

    return value

def nc2(n):
    return (n*(n - 1))//2

def answer():

    dp=[0]*(1 << n) #fishes

    #let 1 be alive fishes
    #let 0 be dead fishes

    dp[(1 << n) - 1]=1 #initially let all be alive


    for mask in range((1 << n) - 1,0,-1):

        m=count(mask) # count alive fishes
        if(m==1):continue

        #probability of selecting 2 alive fishes
        p=1/(nc2(m))
       
        #pairing 2 fishes
        for i in range(n):
            for j in range(n):
                if(i==j):continue
                #check if i , j fishes are alive or not

                if((mask >> i & 1) and (mask >> j & 1)):
                    #let fish i eat j
                    next_mask=mask ^ (1 << j)
                    dp[next_mask]+=(dp[mask]*p*a[i][j])

    for i in range(n):
        #fish i is alive
        print(dp[1 << i],end=' ')
    
n=int(input())
a=[list(map(float,input().split())) for i in range(n)]

answer()
print()
",np,"bitmasks,dp,probabilities",1069
"# Author : nitish420 --------------------------------------------------------------------
import os
import sys
from io import BytesIO, IOBase
# sys.setrecursionlimit(10**4)

def main():
    n=int(input())
    prob=[]
    for _ in range(n):
        prob.append(list(map(float,input().split())))

    dp=[-1 for _ in range(1<<n)]

    ans=[0 for _ in range(n)]

    def move(mask,die):

        total=bin(mask).count('1')

        z=0

        for i in range(n):
            if mask & (1<<i):
                z+=prob[i][die]

        return z/((total*(total-1))>>1)


    def solve(mask):
        
        if mask==(1<<n)-1:
            return 1

        if dp[mask]!=-1:
            return dp[mask]

        ans=0
        for i in range(n):
            if not (mask & (1<<i)):
                prev=solve(mask ^ (1<<i))

                ans+=prev*move(mask ^ (1<<i),i)
        
        dp[mask]=ans
        return ans

        
    for i in range(n):
        ans[i]='%.6f'%solve(1<<i)
    
    print(*ans)



#----------------------------------------------------------------------------------------


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = 'x' in file.mode or 'r' not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b'\n') + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode('ascii'))
        self.read = lambda: self.buffer.read().decode('ascii')
        self.readline = lambda: self.buffer.readline().decode('ascii')


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip('\r\n')


# endregion

if __name__ == '__main__':
    main()",np,"bitmasks,dp,probabilities",2819
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [[i] + inp(dtype) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

n = int(input())
a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1

if n == 1:
    exit(print(1))

for i in range(n):
    for j in range(i + 1, n):
        masks[big ^ (1 << j)] += a[i][j]
        masks[big ^ (1 << i)] += a[j][i]

for _ in range(2, n):
    tem = dict()
    for msk in masks:
        for bit in range(18):
            if get_bit(msk, bit):
                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]
    masks = tem

su = sum(masks.values())
print(*[masks[2 ** i] / su for i in range(n)])
",np,"bitmasks,dp,probabilities",2684
"import os, sys
from io import BytesIO, IOBase


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


class dict(dict):
    def __missing__(self, key):
        return 0.0


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
inp = lambda dtype: [dtype(x) for x in input().split()]
inp_2d = lambda dtype, n: [dtype(input()) for _ in range(n)]
inp_2ds = lambda dtype, n: [inp(dtype) for _ in range(n)]
inp_enu = lambda dtype: [(i, x) for i, x in enumerate(inp(dtype))]
inp_enus = lambda dtype, n: [tuple([i] + inp(dtype)) for i in range(n)]
ceil1 = lambda a, b: (a + b - 1) // b
get_bit = lambda x, i: (x >> i) & 1

n = int(input())
a, masks, big = inp_2ds(float, n), dict(), 2 ** n - 1

if n == 1:
    exit(print(1))

for i in range(n):
    for j in range(i + 1, n):
        masks[big ^ (1 << j)] += a[i][j]
        masks[big ^ (1 << i)] += a[j][i]

for _ in range(2, n):
    tem = dict()
    for msk in masks:
        for bit in range(18):
            if get_bit(msk, bit):
                tem[msk ^ (1 << bit)] += sum([a[i][bit] for i in range(n) if get_bit(msk, i)]) * masks[msk]
    masks = tem

su = sum(masks.values())
print(*[masks[1 << i] / su for i in range(n)])
",np,"bitmasks,dp,probabilities",2693
"import sys
from array import array  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


n = int(input())
prob = [tuple(map(float, input().split())) for _ in range(n)]
full_bit = (1 << n) - 1
dp = [0.0] * full_bit + [1.0]

for bit in range(full_bit, 0, -1):
    popcount = len([1 for i in range(n) if (1 << i) & bit])
    if popcount == 1 or dp[bit] == 0.0:
        continue
    div = 1 / ((popcount * (popcount - 1)) >> 1)

    for i in range(n):
        if ((1 << i) & bit) == 0:
            continue
        for j in range(i + 1, n):
            if ((1 << j) & bit) == 0:
                continue
            dp[bit - (1 << j)] += dp[bit] * prob[i][j] * div
            dp[bit - (1 << i)] += dp[bit] * prob[j][i] * div

print(*(dp[1 << i] for i in range(n)))
",np,"bitmasks,dp,probabilities",794
"numbersDict = {
""1"": ""H"",
""2"": ""He"",
""3"": ""Li"",
""4"": ""Be"",
""5"": ""B"",
""6"": ""C"",
""7"": ""N"",
""8"": ""O"",
""9"": ""F"",
""10"": ""Ne"",
""11"": ""Na"",
""12"": ""Mg"",
""13"": ""Al"",
""14"": ""Si"",
""15"": ""P"",
""16"": ""S"",
""17"": ""Cl"",
""18"": ""Ar"",
""19"": ""K"",
""20"": ""Ca"",
""21"": ""Sc"",
""22"": ""Ti"",
""23"": ""V"",
""24"": ""Cr"",
""25"": ""Mn"",
""26"": ""Fe"",
""27"": ""Co"",
""28"": ""Ni"",
""29"": ""Cu"",
""30"": ""Zn"",
""31"": ""Ga"",
""32"": ""Ge"",
""33"": ""As"",
""34"": ""Se"",
""35"": ""Br"",
""36"": ""Kr"",
""37"": ""Rb"",
""38"": ""Sr"",
""39"": ""Y"",
""40"": ""Zr"",
""41"": ""Nb"",
""42"": ""Mo"",
""43"": ""Tc"",
""44"": ""Ru"",
""45"": ""Rh"",
""46"": ""Pd"",
""47"": ""Ag"",
""48"": ""Cd"",
""49"": ""In"",
""50"": ""Sn"",
""51"": ""Sb"",
""52"": ""Te"",
""53"": ""I"",
""54"": ""Xe"",
""55"": ""Cs"",
""56"": ""Ba"",
""57"": ""La"",
""58"": ""Ce"",
""59"": ""Pr"",
""60"": ""Nd"",
""61"": ""Pm"",
""62"": ""Sm"",
""63"": ""Eu"",
""64"": ""Gd"",
""65"": ""Tb"",
""66"": ""Dy"",
""67"": ""Ho"",
""68"": ""Er"",
""69"": ""Tm"",
""70"": ""Yb"",
""71"": ""Lu"",
""72"": ""Hf"",
""73"": ""Ta"",
""74"": ""W"",
""75"": ""Re"",
""76"": ""Os"",
""77"": ""Ir"",
""78"": ""Pt"",
""79"": ""Au"",
""80"": ""Hg"",
""81"": ""Tl"",
""82"": ""Pb"",
""83"": ""Bi"",
""84"": ""Po"",
""85"": ""At"",
""86"": ""Rn"",
""87"": ""Fr"",
""88"": ""Ra"",
""89"": ""Ac"",
""90"": ""Th"",
""91"": ""Pa"",
""92"": ""U"",
""93"": ""Np"",
""94"": ""Pu"",
""95"": ""Am"",
""96"": ""Cm"",
""97"": ""Bk"",
""98"": ""Cf"",
""99"": ""Es"",
""100"": ""Fm""
}

lettersDict = {
""H"": ""1"",
""He"": ""2"",
""Li"": ""3"",
""Be"": ""4"",
""B"": ""5"",
""C"": ""6"",
""N"": ""7"",
""O"": ""8"",
""F"": ""9"",
""Ne"": ""10"",
""Na"": ""11"",
""Mg"": ""12"",
""Al"": ""13"",
""Si"": ""14"",
""P"": ""15"",
""S"": ""16"",
""Cl"": ""17"",
""Ar"": ""18"",
""K"": ""19"",
""Ca"": ""20"",
""Sc"": ""21"",
""Ti"": ""22"",
""V"": ""23"",
""Cr"": ""24"",
""Mn"": ""25"",
""Fe"": ""26"",
""Co"": ""27"",
""Ni"": ""28"",
""Cu"": ""29"",
""Zn"": ""30"",
""Ga"": ""31"",
""Ge"": ""32"",
""As"": ""33"",
""Se"": ""34"",
""Br"": ""35"",
""Kr"": ""36"",
""Rb"": ""37"",
""Sr"": ""38"",
""Y"": ""39"",
""Zr"": ""40"",
""Nb"": ""41"",
""Mo"": ""42"",
""Tc"": ""43"",
""Ru"": ""44"",
""Rh"": ""45"",
""Pd"": ""46"",
""Ag"": ""47"",
""Cd"": ""48"",
""In"": ""49"",
""Sn"": ""50"",
""Sb"": ""51"",
""Te"": ""52"",
""I"": ""53"",
""Xe"": ""54"",
""Cs"": ""55"",
""Ba"": ""56"",
""La"": ""57"",
""Ce"": ""58"",
""Pr"": ""59"",
""Nd"": ""60"",
""Pm"": ""61"",
""Sm"": ""62"",
""Eu"": ""63"",
""Gd"": ""64"",
""Tb"": ""65"",
""Dy"": ""66"",
""Ho"": ""67"",
""Er"": ""68"",
""Tm"": ""69"",
""Yb"": ""70"",
""Lu"": ""71"",
""Hf"": ""72"",
""Ta"": ""73"",
""W"": ""74"",
""Re"": ""75"",
""Os"": ""76"",
""Ir"": ""77"",
""Pt"": ""78"",
""Au"": ""79"",
""Hg"": ""80"",
""Tl"": ""81"",
""Pb"": ""82"",
""Bi"": ""83"",
""Po"": ""84"",
""At"": ""85"",
""Rn"": ""86"",
""Fr"": ""87"",
""Ra"": ""88"",
""Ac"": ""89"",
""Th"": ""90"",
""Pa"": ""91"",
""U"": ""92"",
""Np"": ""93"",
""Pu"": ""94"",
""Am"": ""95"",
""Cm"": ""96"",
""Bk"": ""97"",
""Cf"": ""98"",
""Es"": ""99"",
""Fm"": ""100""
}

_ = input() # Supposed to be n, k but we do not need them
atoms = input().split("" "")
outAtoms = input().split("" "")
atoms = sorted(list(map(lambda x: int(lettersDict[x]), atoms)))
outAtoms = sorted(list(map(lambda x: int(lettersDict[x]), outAtoms)))

sumAtoms = 0
def testIfPossible():
    atomsx = atoms.copy()
    outAtomsx = outAtoms.copy()
    for i in range(len(atoms) - 1, -1, -1):
        if atomsx[i] > outAtomsx[-1]:
            atomsx.pop()
    if sum(outAtomsx) > sum(atomsx):
        print(""NO"")
        exit()

testIfPossible()
for at in atoms:
    sumAtoms += at
outAtom = 0
for at in outAtoms:
    outAtom += at
def dfs(i: int, currentSum: int, arr: [int], searchSum: int) -> [[int]]:
    if i >= len(arr) or currentSum + arr[i] > searchSum:
        return []
    totalRes = []
    # we take
    res = dfs(i + 1, currentSum + arr[i], arr, searchSum)
    totalRes += [[i] + a for a in res]
    # we don't take
    res = dfs(i + 1, currentSum, arr, searchSum)
    totalRes += [a for a in res]
    if currentSum + arr[i] == searchSum:
        totalRes.append([i])
    return totalRes

allCombos = [[set(x) for x in dfs(0, 0, atoms, out)] for out in outAtoms]
currentSet = set()
stack = []
resultFound = False
def dfs2(i: int):
    global resultFound
    global stack
    global currentSet
    if i >= len(allCombos):
        resultFound = True
        return
    for set in allCombos[i]:
        if not set & currentSet:
            stack.append(set)
            currentSet = currentSet | set
            dfs2(i + 1)
            if resultFound:
                break
            stack.pop()
            currentSet = currentSet - set
isAnyEmpty = False
for comb in allCombos:
    if not comb:
        isAnyEmpty = True
if not isAnyEmpty:
    dfs2(0)

if resultFound:
    print(""YES"")
    res = list(map(lambda x: ""+"".join(list(map(lambda y: numbersDict[f""{atoms[y]}""],list(x)))), stack))
    outs = list(map(lambda x: numbersDict[f""{x}""], outAtoms))
    tot = list(map(lambda x: x[0] + ""->"" + x[1], zip(res, outs)))

    for t in tot:
        print(t)
else:
    print(""NO"")
",np,"bitmasks,dp",4476
"#!/usr/bin/env python3 

import itertools

# Initialize look-up tables
element_to_value = {
  'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,
  'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18, 'K':19, 'Ca':20,
  'Sc':21, 'Ti':22, 'V':23, 'Cr':24, 'Mn':25, 'Fe':26, 'Co':27, 'Ni':28, 'Cu':29, 'Zn':30,
  'Ga':31, 'Ge':32, 'As':33, 'Se':34, 'Br':35, 'Kr':36, 'Rb':37, 'Sr':38, 'Y':39, 'Zr':40,
  'Nb':41, 'Mo':42, 'Tc':43, 'Ru':44, 'Rh':45, 'Pd':46, 'Ag':47, 'Cd':48, 'In':49, 'Sn':50,
  'Sb':51, 'Te':52, 'I':53, 'Xe':54, 'Cs':55, 'Ba':56, 'La':57, 'Ce':58, 'Pr':59, 'Nd':60,
  'Pm':61, 'Sm':62, 'Eu':63, 'Gd':64, 'Tb':65, 'Dy':66, 'Ho':67, 'Er':68, 'Tm':69, 'Yb':70,
  'Lu':71, 'Hf':72, 'Ta':73, 'W':74, 'Re':75, 'Os':76, 'Ir':77, 'Pt':78, 'Au':79, 'Hg':80,
  'Tl':81, 'Pb':82, 'Bi':83, 'Po':84, 'At':85, 'Rn':86, 'Fr':87, 'Ra':88, 'Ac':89, 'Th':90,
  'Pa':91, 'U':92, 'Np':93, 'Pu':94, 'Am':95, 'Cm':96, 'Bk':97, 'Cf':98, 'Es':99, 'Fm':100
}
value_to_element = dict()
for (element, value) in element_to_value.items():
  value_to_element[value] = element

# Read inputs
(n,k) = map(int,input().split())
products_start_str = input().split()
products_end_str = input().split()

# Translate elements to their values
products_start = [element_to_value[elem] for elem in products_start_str]
products_end = [element_to_value[elem] for elem in products_end_str]

# Filter out duplicates; keep track of ingredient values and their number
products_start.sort()
ingredient_value = []
ingredient_count = []
for (key, lst) in itertools.groupby(products_start):
  ingredient_value.append(key)
  ingredient_count.append(len(list(lst)))
nr_ingredients = len(ingredient_value)

# Figure out the options for constructing the final products
construction_options = [[] for i in range(k)]
for combination in itertools.product(*[range(l+1) for l in ingredient_count]):
  value = sum(combination[i]*ingredient_value[i] for i in range(nr_ingredients))
  if (value in products_end):
    for i in range(k):
      if products_end[i] == value:
        construction_options[i].append(combination)

# Do a depth-first search on the construction options for a possible solution
solution =  [None for i in range(k)]
def find_solution(used = [0 for i in range(nr_ingredients)], next = 0):
  if (next == k):
    return all(used[i] == ingredient_count[i] for i in range(nr_ingredients))
  else:
    for option in construction_options[next]:
      usage = [used[i]+option[i] for i in range(nr_ingredients)]
      if all(used[i] <= ingredient_count[i] for i in range(nr_ingredients)):
        possible = find_solution(usage, next+1)
        if (possible):
          solution[next] = option
          return True
  return False

possible = find_solution()

# Print the answer
if not possible:
  print(""NO"")
  exit()

def combination_to_recipe(combination):
  recipe = []
  for i in range(nr_ingredients):
    for j in range(combination[i]):
      recipe.append(value_to_element[ingredient_value[i]])
  return recipe

print(""YES"")
for i in range(k):
  recipe = combination_to_recipe(solution[i])
  print(""%s->%s"" % (""+"".join(recipe),products_end_str[i]))
",np,"bitmasks,dp",3165
"#!/usr/bin/env python3

n, k, A = map(int, input().rstrip().split())
senators = []
mx_bribe = 0

for i in range(n):
    lvl, loy = map(int, input().rstrip().split())
    senators.append((lvl, loy))
    mx_bribe += (100 - loy) // 10

bribe = [0] * n


def calc(votes):
    bsum, cnt, p = 0, 0, 1.0
    for i, s in enumerate(senators):
        if votes & (1 << i):
            p *= (s[1] + bribe[i]) / 100
            cnt += 1
        else:
            p *= (100 - s[1] - bribe[i]) / 100
            bsum += s[0]

    if cnt > (n / 2):
        return p
    else:
        return p * A / (A + bsum)


def dfs(cur, rk):
    if cur >= n:
        if rk > 0:
            return 0.0
        sm = 0.0
        for i in range(1 << n):
            sm += calc(i)

        return sm

    mx = 0.0
    for i in range(rk + 1):
        if i * 10 + senators[cur][1] > 100:
            break
        bribe[cur] = i * 10
        tmp = dfs(cur+1, rk-i)
        mx = max(tmp, mx)
    return mx


print(dfs(0, min(k, mx_bribe)))
",np,"brute force,probabilities",1005
"import sys,io,os,math
try:yash=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
except:yash=lambda:sys.stdin.readline().encode()
I=lambda:[*map(int,yash().split())]
import __pypy__;an=__pypy__.builders.StringBuilder()
n,=I();lis=I();N=22;dp=[-1]*(1<<22)
for i in range(n):
    dp[lis[i]]=lis[i]
    for j in range(22):
        lis[i]^=(1<<j)
for mask in range(1<<22):
    for i in range(22):
        if (mask&(1<<i)) and dp[mask^(1<<i)]!=-1:dp[mask]=dp[mask^(1<<i)]
for num in lis:
    an.append(""%s ""%(dp[num]))
an.append(""\n"")
os.write(1, an.build().encode())",np,"bitmasks,brute force,dfs and similar,dp",564
"import sys,os,io
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
maxbits = 22
maxmask = 1<<maxbits
dp = [-1]*(maxmask)
n = int(input())
a = [int(x) for x in input().split()]
b = a[:]
P = [0]*n 
for i in a:
    dp[i]=i

for exp in range(maxbits):
    for i in range(maxmask):
        if i&(1<<exp):
            if dp[i]==-1:
                dp[i]=dp[i-(1<<exp)]


for i in range(n):
    maxx = maxmask-1
    print(dp[maxx^a[i]],end="" "")",np,"bitmasks,brute force,dfs and similar,dp",2083
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# sys.setrecursionlimit(10000)
inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
lim=22
po=[1<<j for j in range(lim+1)]
maxbits=lim
masks=po[lim]
dp=[-1]*masks
t=1

for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    for i in l:
        dp[i]=i
    for i in range(masks):
        for j in range(maxbits):
            if dp[i]==-1 and i&(1<<j):
                dp[i]=dp[i-(1<<j)]
    ans=[dp[i^(masks-1)] for i in l]
    print(*ans)








",np,"bitmasks,brute force,dfs and similar,dp",837
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# sys.setrecursionlimit(10000)
inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
lim=22
po=[1<<j for j in range(lim+1)]
maxbits=lim
masks=po[lim]
dp=[-1]*masks
t=1
for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    for i in l:
        dp[i]=i
    for i in range(masks):
        for j in range(maxbits):
            if dp[i]==-1 and i&po[j]:
                dp[i]=dp[i-po[j]]
    ans=[dp[i^(masks-1)] for i in l]
    print(*ans)








",np,"bitmasks,brute force,dfs and similar,dp",834
"from collections import defaultdict, Counter,deque
from math import sqrt, log10, log, floor, factorial,gcd
from bisect import bisect_left, bisect_right
from itertools import permutations,combinations
import sys, io, os
input = sys.stdin.readline
# input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
# sys.setrecursionlimit(10000)
inf = float('inf')
mod = 10 ** 9 + 7
def yn(a): print(""YES"" if a else ""NO"")
ceil = lambda a, b: (a + b - 1) // b
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

class masks:
    def all_masks_sos(self,arr,lim=22):
        lim = 22
        maxbits = lim
        self.masks=masks = 1 << lim
        self.dp = [-1] * masks
        for i in arr:
            self.dp[i] = i
        for i in range(masks):
            for j in range(maxbits):
                if self.dp[i] == -1 and i & (1 << j):
                    self.dp[i] = self.dp[i - (1 << j)]

t=1
m=masks()
for i in range(1):
    n=int(input())
    l=[int(i) for i in input().split()]
    m.all_masks_sos(l,22)
    ans = [m.dp[i ^ (m.masks - 1)] for i in l]
    print(*ans)








",np,"bitmasks,brute force,dfs and similar,dp",2730
"import math
res = [0, 1, 0, 3, 0, 15, 0, 133, 0, 2025, 0, 37851, 0, 1030367, 0, 36362925, 0]
n = int(input())
print(res[n] * math.factorial(n) % (10 ** 9 + 7))

  	   						 	  				 	  						",np,"bitmasks,combinatorics,dp,implementation,meet-in-the-middle",191
"n = int(input())
ans = [1, 3, 5, 7, 9, 11, 13, 15]
dct = \
{
    1 : 1,
    3 : 18,
    5 : 1800,
    7 : 670320,
    9 : 734832000,
    11 : 890786230,
    13 : 695720788,
    15 : 150347555
}
if n in ans:
    print(dct[n])
else:
    print(0)",np,"bitmasks,combinatorics,dp,implementation,meet-in-the-middle",243
"import math
ans = [1, 3, 15, 133, 2025, 37851, 1030367, 36362925]
n = int(input())

if (n % 2 == 1):
	print(ans[n // 2] * math.factorial(n) % 1000000007)
else:
	print(0)",np,"bitmasks,combinatorics,dp,implementation,meet-in-the-middle",169
"n = int(input())
a = list(map(int,input().split()))
mod = 10**9+7
b = [0 for i in range(1<<20)]
for i in range(n):
  b[a[i]] += 1
for i in range(20):
  for j in range(1<<20):
    if j&1<<i == 0:
      b[j] += b[j|1<<i]
ans = 0
for i in range(1<<20):
  cnt = str(bin(i)).count(""1"")
  if cnt%2 == 0:
    ans += pow(2,b[i],mod)-1
  else:
    ans -= pow(2,b[i],mod)-1
  ans %= mod
print(ans)",np,"bitmasks,combinatorics,dp",387
"import sys
input = lambda : sys.stdin.readline().rstrip()


sys.setrecursionlimit(2*10**5+10)
write = lambda x: sys.stdout.write(x+""\n"")
debug = lambda x: sys.stderr.write(x+""\n"")
writef = lambda x: print(""{:.12f}"".format(x))


# zeta mebius
def zeta_super(val, n):
    # len(val)==2^n
    out = val[:]
    for i in range(n):
        for j in range(1<<n):
            if not j>>i&1:
                out[j] += out[j^(1<<i)]
    return out

n = int(input())
a = list(map(int, input().split()))
m = max(a).bit_length()
M = 10**9+7
v = [0]*(1<<m)
for item in a:
    v[item] += 1
v2 = [1]
for i in range(n+1):
    v2.append(v2[-1]*2%M)
nv = zeta_super(v, m)
ans = 0
for b in range(1<<m):
    ans += (v2[nv[b]]-1)*pow(-1, bin(b).count(""1""))
    ans %= M
print(ans%M)",np,"bitmasks,combinatorics,dp",760
"import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int,sys.stdin.readline().rstrip().split())
def LI(): return list(map(int,sys.stdin.readline().rstrip().split()))
def LI2(): return list(map(int,sys.stdin.readline().rstrip()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
def LS2(): return list(sys.stdin.readline().rstrip())


N = I()
A = LI()
mod = 10**9+7

m = 20
M = 1 << m
F = [0]*M
for a in A:
    F[a] += 1


def zeta_transform(F,n):
    # res[i] = (iを含む集合jに対する F[j] の和)
    N = 1 << n
    res = F[:]
    for i in range(n):
        k = 1 << i
        for j in range(N):
            if not j & k:
                res[j] += res[j^k]
    return res


G = zeta_transform(F,m)
power = [1]
for _ in range(N):
    power.append((power[-1]*2) % mod)


def bit_count(n):
    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)
    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)
    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f)
    c = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff)
    c = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff)
    c = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff)
    return c


ans = 0
for i in range(M):
    bc = bit_count(i)
    a = power[G[i]]
    if bc % 2 == 0:
        ans += a
    else:
        ans -= a
    ans %= mod

print(ans)
",np,"bitmasks,combinatorics,dp",1441
"import sys
readline = sys.stdin.readline


def gcd(a, b):
    while b:
        a, b = b, a%b
    return a


def prsh(N):
    prime = [2]
    for L in range(3,N):
        for p in prime:
            if not L % p:
                break
            if p > L**(1/2):
                prime.append(L)
                break
    return prime
limit = 59
prime = prsh(limit+1)
C = set([tuple()])
Cp = []
for i in range(2, limit+1):
    if i >= 30 and i in prime:
        Cp.append(i)
        continue
    for k in C.copy():
        if all(gcd(ki, i) == 1 for ki in k):
            kn = tuple(list(k) + [i])
            C.add(kn)

INF = 10**9+7

N = int(readline())
A = list(map(int, readline().split()))
Ao = A[:]
A.sort()
ans = INF
Ans = None
for ci in C:
    tc = [1]*(N-len(ci)) + list(ci) + Cp
    for j in range(8):
        res = 0
        for a, t in zip(A, tc[j:]):
            res += abs(a-t)
        if ans > res:
            ans = res
            Ans = tc[j:j+N]
buc = [[] for _ in range(limit+1)]
for a, an in zip(A, Ans):
    buc[a].append(an)
AA = []
for ao in Ao:
    AA.append(buc[ao].pop())

#print(ans)
print(*AA)",np,"bitmasks,brute force,dp",1120
"import itertools

kol1 = {'+': 0, '-': 0, '?': 0}
kol2 = {'+': 0, '-': 0, '?': 0}

s1 = input()
s2 = input()

for s in s1:
    kol1[s] += 1

for s in s2:
    kol2[s] += 1

if (kol1['+']==kol2['+'] and kol1['-']==kol2['-']):
    print('1.0')
    exit()

mod1 = kol1['+'] - kol1['-']
mod2 = kol2['+'] - kol2['-']
mod3 = abs(mod2-mod1)
if (mod3>kol2['?']):
    print(0.0)
    exit()

list_comb = [1, -1]
sum_pos = 0
col = 0
# import pdb; pdb.set_trace()
for comb in itertools.product(list_comb, repeat=kol2['?']):
    if sum(comb)==mod3:
        sum_pos += 1
    col+=1

print(sum_pos/col)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",586
"def factorial(n):
    result = 1
    for i in range(2, n+1):
        result *= i
    return result

commands = input().strip()
received = input().strip()
n = len(commands)
positive = 0
negative = 0
count = 0
for i in range(n):
    if commands[i] == ""+"":
        positive += 1
    else:
        negative += 1
    if received[i] == ""+"":
        positive -= 1
    elif received[i] == ""-"":
        negative -= 1
    else:
        count += 1
cases = 2**count
probability = 0.0
if positive >= 0 and negative >= 0:
    probability = (factorial(count)/(factorial(positive)*factorial(negative)))/cases

print(""{0:.9f}"".format(probability))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",630
"s1 = input()
s2 = input()

objetivo = s1.count(""+"") - s1.count(""-"")
inicio = s2.count(""+"") - s2.count(""-"")
incognitos = s2.count(""?"")
distancia = objetivo - inicio

def factorial(n):
    total = 1
    for i in range(int(n)):
        total *= (i + 1)
    return total

if abs(distancia) > incognitos or distancia % 2 != incognitos % 2:
    print(0)
else:
    mas = (distancia + incognitos) / 2
    menos = (incognitos - distancia) / 2
    print((factorial(incognitos)/(factorial(mas)*factorial(menos)))/2**incognitos)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",517
"s = input()
trgt = 0
for c in s:
    trgt += (1 if c == '+' else -1)

cmd = input()

queue = [[0, 0]]
dests = []

while queue:
    nextqueue = []
    for pos, cmdi in queue:
        if cmdi == len(cmd):
            dests.append(pos)
            continue
        nextcmd = cmd[cmdi]
        if nextcmd == '+':
            nextqueue.append([pos+1, cmdi+1])
        elif nextcmd == '-':
            nextqueue.append([pos-1, cmdi+1])
        else:
            nextqueue.append([pos + 1, cmdi + 1])
            nextqueue.append([pos - 1, cmdi + 1])
    queue = nextqueue

occurs = 0
for x in dests:
    if x == trgt:
        occurs+=1
print(occurs / len(dests))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",656
"from math import factorial
drazil = input()
dreamoon = input()
net_drazil = 0
net_dreamoon = 0
uncretain_count = 0
for i in drazil:
    if i == '-':
        net_drazil -= 1
    else:
        net_drazil += 1
for i in dreamoon:
    if i == '-':
        net_dreamoon -= 1
    elif i == '+':
        net_dreamoon += 1
    else:
        uncretain_count += 1
x = (uncretain_count + (net_drazil - net_dreamoon)) // 2
y = (uncretain_count - (net_drazil - net_dreamoon)) // 2
#print(x,y)
if abs(x) + abs(y) != uncretain_count:
    print(0.0)
else:
    out = factorial(uncretain_count)//(factorial(x)*factorial(uncretain_count-x))
    print(out/2**uncretain_count)

",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",656
"import math
sone= list(input())
stwo = list(input())
sum1=0
sum2=0
m=0
for i in range(len(sone)):
    if sone[i]=='+':
        sum1=sum1 + 1
        m=m+1
    else:
        sum1=sum1 - 1
k=0        
for i in range(len(stwo)):
    if stwo[i]=='+':
        sum2=sum2 + 1
        k=k
    elif stwo[i]=='-':
        sum2=sum2 - 1
        k=k
    elif stwo[i]=='?':
        k=k+1
n=0
if (k-(abs(sum1-sum2)))<0:
    print(float (0))
elif (k-(abs(sum1-sum2)))==0:
    if k==0:
        print(float (1))
    else:
        print(float (pow(0.5,k)))
             
else:
    n=k-(abs(sum1-sum2))
    n=abs(sum1-sum2)+n/2
    if abs(sum1-sum2)==0:
        print(float ((math.factorial(k)/(math.factorial(k/2)*math.factorial(k/2))) * pow(0.5,k)))
    else:
        print(float ((math.factorial(k)/(math.factorial(k-n) * math.factorial(n))) * pow(0.5,k)))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",840
"## 476B
import math
def binom(n, m):
    return math.factorial(n)//(math.factorial(m)*math.factorial(n-m))

correct = input()
received = input()
plus_correct = correct.count('+')
min_correct = correct.count('-')
pos_correct = plus_correct - min_correct
plus_received = received.count('+')
min_received = received.count('-')
unknown = received.count('?')
pos_received = plus_received - min_received
diff = abs(pos_correct - pos_received)
if (diff + unknown) % 2 != 0 or diff > unknown:
    prob = 0.0
else:
    m = (diff + unknown) // 2
    prob =  1.0 * binom(unknown, m) / (2 ** unknown)
print(prob)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",600
"import math
a = str(input())
b = str(input())
posa = a.count('+') - a.count('-')
posb = b.count('+') - b.count('-')
q = b.count('?')
dist = (posa - posb)
ones = (abs(dist) + q) / 2
if q < abs(dist) or ((dist+q) % 2):
    ans = 0
else:
    ans = float(math.factorial(q)/(math.factorial(ones)*math.factorial(q-ones)))
    ans /= pow(2, q)
print(f'{ans:.9f}')
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",357
"from math import factorial
s=input()
s1=input()
plus=s.count('+')-s1.count('+')
minus=s.count('-')-s1.count('-')
n=s1.count('?')
if plus<0 or minus<0:
    print(0)
else:
    print((factorial(n)/factorial(n-plus)/factorial(plus))*(0.5**n))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",238
"from math import factorial
a = input()
b = input()
plus, minus, ques = '+', '-', '?'
ops1 = {plus:0, minus:0}
ops2 = {plus:0, minus:0, ques:0}
for ai,bi in zip(a,b):
    ops1[ai] += 1
    ops2[bi] += 1
final_pos = ops1[plus]-ops1[minus]
initial_pos = ops2[plus]-ops2[minus]
diff = final_pos-initial_pos
abs_diff = abs(diff)
if abs_diff > ops2[ques]:
    print(0.0)
elif (ops2[ques]-abs_diff) % 2 != 0:
    print(0.0)
else:
    total = 2**(ops2[ques])
    one_type = (ops2[ques]-abs_diff) // 2
    other_type = abs_diff + one_type
    numerator = factorial(ops2[ques])/(factorial(one_type)*factorial(other_type))
    print(numerator/total)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",638
"from math import factorial as fc
def per(a,b):
    return fc(a+b)/(fc(a)*fc(b))
import sys
s=input()
s1=input()
x=s.count(""+"")
y=s.count(""-"")
x1=s1.count(""+"")
y1=s1.count(""-"")
p=x-y
p1=x1-y1
q=s1.count(""?"")
dif=p-p1
if q<abs(p1-p) or dif>q:
    print(0.0)
    sys.exit()
m=abs(y-y1)
pl=abs(x-x1)
print(per(m,pl)/(2**(m+pl)))
    
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",330
"import math
def main():
    x = input()
    y = input()
    goal = x.count('+') - y.count('+')
    options = y.count('?')
    if options == 0:
        if goal == options:
            print(1)
        else:
            print(0)
    else:
        if (goal > options):
            print(0)
        else:
            if goal < 0:
                print(0)
            else:
                print(math.factorial(options)/math.factorial(goal)/math.factorial(options-goal)/(2**options))
main()
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",486
"import math

inp = input().strip()
dec = input().strip()
inp_dict = {""+"":0,""-"":0}
dec_dict = {""+"":0,""-"":0,""?"":0}

for i in range(len(inp)):
	if inp[i]==""+"":
		inp_dict[""+""] += 1
	elif inp[i]==""-"":
		inp_dict[""-""] += 1

for i in range(len(dec)):
	if dec[i]==""+"":
		dec_dict[""+""] += 1
	elif dec[i]==""-"":
		dec_dict[""-""] += 1
	elif dec[i] == ""?"":
		dec_dict[""?""] += 1

if(dec_dict[""+""] == inp_dict[""+""] and dec_dict[""-""] == inp_dict[""-""]):
	print(1.0000000000)
else:
	temp = inp_dict[""+""] - dec_dict[""+""]
	temp1 = inp_dict[""-""] - dec_dict[""-""]
	#print(temp,temp1)
	if temp + temp1 == dec_dict[""?""] and temp>=0 and temp1 >= 0:
		temp2 = math.factorial(temp+temp1)/(math.factorial(temp)*math.factorial(temp1))
		for i in range(temp1+temp):
			temp2 = temp2 * 0.5
		print(temp2)
	else:
		print(0.000000000)



",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",804
"from math import factorial
s1=input()
s2=input()
n=0
x1=0
for i in range(len(s1)):
    if s1[i]=='+':
        x1+=1
    else:
        x1-=1
x2=0
for i in range(len(s2)):
    if s2[i]=='+':
        x2+=1
    elif s2[i]=='?':
        n+=1
    else:
        x2-=1
x=abs(x1-x2)
if x>n:
    print(0)
elif x==n:
    print(1/2**n)
else:
    if (n-x)%2==1:
        print(0)
    else:
        print((factorial(n)//(factorial((n-x)//2)*factorial(n-(n-x)//2)))/2**n)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",455
"from math import factorial as fact

s=input()
t=input()

pos=s.count('+')-t.count('+')
neg=s.count('-')-t.count('-')
que=t.count('?')
if pos<0 or neg<0:
    print(0)
else:
    print((fact(que)/(fact(pos)*fact(neg)))/(2**que))
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",226
"import math
from math import factorial

def combination(n,r):
    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))

a = input()
ap = a.count('+')
am = a.count('-')
b = input()
bp = b.count('+')
bm = b.count('-')
n = b.count('?')
x = float(ap - bp)
y = float(am - bm)
if (x < 0 or y < 0 or x+y != n):
    print(0.0)
else:
    print(combination(n,x)/(1<<n))
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",380
"import math
a=input()
b=input()
c=int(0)
d=int(0)
q=int(0)
for i in range(len(a)):
    if a[i]==""+"":
        c+=1
    elif a[i]==""-"":
        c-=1
for i in range(len(b)):
    if b[i]==""+"":
        d+=1
    elif b[i]==""-"":
        d-=1
    else:
        q+=1
if c == d:
    print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q))
else:
    mx=d+q
    mn=d-q
    if c>mx or c<mn:
        print(0.0)
    else:
        ans=c-d
        if ans > 0:
            print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q))
        else:
            print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))
        ",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",697
"import math
from math import factorial

def combination(n,r):
    return float(factorial(n)) / float(factorial(r)) / float(factorial(n-r))

a = input()
ap = a.count('+')
am = a.count('-')
b = input()
bp = b.count('+')
bm = b.count('-')
n = b.count('?')
x = float(ap - bp)
y = float(am - bm)
if (x < 0 or y < 0 or x+y != n):
    print(0.0)
else:
    print(combination(n,x)/(1<<n))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",379
"import math
a=input()
b=input()
c=int(0)
d=int(0)
q=int(0)
for i in range(len(a)):
    if a[i]==""+"":
        c+=1
    elif a[i]==""-"":
        c-=1
for i in range(len(b)):
    if b[i]==""+"":
        d+=1
    elif b[i]==""-"":
        d-=1
    else:
        q+=1
if c == d:
    print((math.factorial(q)/(math.factorial(q/2)*math.factorial(q/2)))/(2**q))
else:
    mx=d+q
    mn=d-q
    if c>mx or c<mn:
        print(0.0)
    else:
        ans=c-d
        if ans > 0:
            print((math.factorial(q)/(math.factorial(((q-ans)/2)+ans)*math.factorial((q-ans)/2)))/(2**q))
        else:
            print((math.factorial(q)/(math.factorial((q-ans)/2)*math.factorial(((q-ans)/2)+ans)))/(2**q))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",688
"import math
s1=list(input())
s2=list(input())
p1,m1,p2,m2,c=0,0,0,0,0
for i in range(len(s1)):
	if(s1[i]=='+'):
		p1+=1
	if(s1[i]=='-'):
		m1+=1
	if(s2[i]=='+'):
		p2+=1
	if(s2[i]=='-'):
		m2+=1
	if(s2[i]=='?'):
		c+=1
p=abs(p1-p2)
m=abs(m1-m2)
if((p+m)==c):
	print(math.factorial(c)/(math.factorial(p)*math.factorial(m)*pow(2,c)))
else:
	print(0/1)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",349
"actual = input()
processed = input()


def factorial(num: int):
    res = 1
    while num >= 1:
        res *= num
        num -= 1
    return res


actualPos = actual.count('+')
actualNeg = actual.count('-')
processedPos = processed.count('+')
processedNeg = processed.count('-')

if processedPos > actualPos or processedNeg > actualNeg:
    print(0)
elif processedPos == actualPos and processedNeg == actualNeg:
    print(1)
else:
    remainPos = actualPos - processedPos
    remainNeg = actualNeg - processedNeg

    print((factorial(remainPos + remainNeg) / (factorial(remainPos) * factorial(remainNeg))) / 2 ** (
            remainPos + remainNeg))
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",654
"import math
import sys
from bisect import bisect_right, bisect_left, insort_right
from collections import Counter, defaultdict
from heapq import heappop, heappush
from itertools import accumulate
from sys import stdout

R = lambda: map(int, input().split())
t = input()
s = input()
k = t.count('+') - s.count('+')
n = s.count('?')
if k > n or k < 0:
    print('0.0')
else:
    print(math.factorial(n) / (math.factorial(k) * math.factorial(n - k)) / 2**n)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",454
"from math import factorial
from decimal import *
A=input()
B=input()
a=0
cnt2=0
cnt1=0
b=0
for i in A:
    if i=='+':
        a+=1
        cnt1+=1
    else:
        a-=1
        cnt2+=1
cnt3=0
cnt=0
cnt4=0
for i in B:
    if i=='+':
        b+=1
        cnt3+=1
    elif i=='-':
        b-=1
        cnt4+=1
    else:
        cnt+=1
if cnt3>cnt1 or cnt4>cnt2:
    print(format(0,'.12f'))
else:
    No_of_plus=cnt1-cnt3
    No_of_minus=cnt2-cnt4
    Total_cases=2**cnt
    Total_No_of_favourable_cases=factorial(cnt)//(factorial(No_of_plus)*factorial(No_of_minus))
#     getcontext().prec=12
    print(format(Decimal(Total_No_of_favourable_cases)/Decimal(Total_cases), '.12f'))
    ",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",681
"import math
s=input()
p=input()
c=1
ss=0
ps=0
k=0
for i in range(len(s)):
	if(p[i]=='?'):
		c*=2
		k+=1
	if(s[i]=='+'):
		ss+=1
	else:
		ss-=1
	if(p[i]=='+'):
		ps+=1
	elif p[i]=='-':
		ps-=1
y=math.fabs(ss-ps)
x=k-y
a=y+x/2
b=k-a
if k<y:
	ans=0.000000000
else:
	ans=math.factorial(a+b)/(math.factorial(a)*math.factorial(b))
	ans/=c
print(""%.12f""%ans)
# print(a,b)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",364
"def factorial(n) :
    ans = 1
    if (n == 0) :
        return 1
    for i in range(1, n + 1) :
        ans *= i
    return ans
def ncr(n , r) :
    n = abs(n) 
    if r > n :
        return 0 
    ans = factorial(n)
    ans = ans//(factorial(n-r)) 
    ans = ans//(factorial(r))
    return ans

if __name__ == ""__main__"" :
    A = input() 
    B = input()
    QMarks = B.count('?')   
    TotalA = A.count('+') - A.count('-') 
    TotalB = B.count('+') - B.count('-') 
    denominator = 2**QMarks
    if QMarks < abs(TotalA - TotalB) :  
        print(0) 
    else :
        x = (QMarks - abs(TotalA - TotalB))//2
        x += abs(TotalA - TotalB)
        num = ncr(QMarks,x) 
        print(num/denominator)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",709
"""""""
██╗ ██████╗ ██╗    ██████╗  ██████╗  ██╗ █████╗
██║██╔═══██╗██║    ╚════██╗██╔═████╗███║██╔══██╗
██║██║   ██║██║     █████╔╝██║██╔██║╚██║╚██████║
██║██║   ██║██║    ██╔═══╝ ████╔╝██║ ██║ ╚═══██║
██║╚██████╔╝██║    ███████╗╚██████╔╝ ██║ █████╔╝
╚═╝ ╚═════╝ ╚═╝    ╚══════╝ ╚═════╝  ╚═╝ ╚════╝
""""""
from math import factorial as f
n = input()
s = input()
quest = s.count(""?"")
plusn = n.count(""+"")
plus = s.count(""+"")
try:
	comb = f(quest)/(f(plusn - plus) * f(quest - (plusn - plus)))
	print(""%.12f"" %(comb/2 ** quest))
except:
	print(""%.12f"" %0)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",548
"from collections import Counter
import math
l=list(input())
l1=list(input())
a=Counter(l)
b=Counter(l1)
if a['+']<b['+'] or a['-']<b['-']:
	print(""0"")
	exit()
else:
	a1=a['+']-b['+']
	b1=a['-']-b['-']
s=(math.factorial(a1+b1))//((math.factorial(a1))*(math.factorial(b1)))
s1=float(2**(a1+b1))
print(s/s1)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",304
"import math
s = input()
s1 = input()
plus=s.count('+')-s1.count('+')
minus=s.count('-')-s1.count('-')
v = s1.count('?')
if plus<0 or minus<0:
    print(0)
    exit()
print((math.factorial(v)/math.factorial(v-plus)/math.factorial(plus))*(0.5**v))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",245
"list1=list(input())
list2=list(input())
plus1=list1.count('+')
plus2=list2.count('+')
minus1=list1.count('-')
minus2=list2.count('-')
wths=list2.count('?')
def giveFactorial(n,x):
    if x==0 or x==n or x>n or n==0:
        return 1
    else:
        return giveFactorial(n-1,x-1)+giveFactorial(n-1,x)
a=(giveFactorial(wths,plus1-plus2))
#print(wths,plus1-plus2)
if plus1==plus2 and wths==0:
    print(1)
elif wths==0 :
    print(0)
elif plus1-plus2>wths or minus1-minus2>wths:
    print(0)
else:
    print((0.5**(plus1-plus2+minus1-minus2))*a)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",544
"from math import factorial as fact
s1 = input()
s2 = input()
plus1 = s1.count(""+"")
minus1 = s1.count(""-"")

plus2 = s2.count(""+"")
minus2 = s2.count(""-"")
qCount = s2.count(""?"")

if(plus1==plus2 and minus1==minus2):
	print(1)
else:
	plusReq = plus1 - plus2
	minusReq = minus1 - minus2
	if(plusReq >= 0 and minusReq >= 0):
		ans = (0.5**qCount)*fact(qCount)/(fact(plusReq)*fact(minusReq))
		print(ans)
		
	else:
		print(0)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",419
"import math


def c(k, n):
    return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))


def main():
    sent = input()
    received = input()
    difference = abs((sent.count('+') - sent.count('-')) - (received.count('+') - received.count('-')))
    unrecognized = received.count('?')
    if difference > unrecognized:
        print(0)
        return
    # 1)n = k + m
    # 2)m = k - diff
    # n = k + k - diff
    # k = (n + diff) // 2
    k = (unrecognized - difference) // 2
    answer = c(k, unrecognized) * 0.5**unrecognized
    print(answer)


if __name__ == '__main__':
    main()
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",607
"line1 = str(input());
line2 = str(input());

truePosition = 0;
fakePosition = 0;
questionMarks = 0;
for i in range(len(line1)):
	if line1[i] == ""+"":
		truePosition += 1;
	if line1[i] == ""-"":
		truePosition -= 1;
	if line2[i] == ""+"":
		fakePosition += 1;
	if line2[i] == ""-"":
		fakePosition -= 1;
	if line2[i] == ""?"":
		questionMarks += 1;
		
distanceToMove = abs(truePosition - fakePosition);
#print(""Distance: "", distanceToMove);


def factorial(x):
	if x == 0:
		return 1;
	else:
		return x * factorial(x-1);
		
def probToMove(dist, questionMarks):
	if(dist > questionMarks):
		return float(0);
	reducedDist = questionMarks - dist;
	if(reducedDist % 2 != 0):
		return float(0);
	dist = reducedDist//2 + dist;
	headsFlips = 1;
	headsOrders = factorial(questionMarks) / ((factorial(dist) *factorial(questionMarks-dist)));
	#print(""HeadsFlips:"", headsFlips);
	#print(""headsOrders:"", headsOrders);
	totalPossibilities = 2**questionMarks;
	#print(""totalPossibilities:"", totalPossibilities);
	return headsFlips * headsOrders / totalPossibilities;
	
print(probToMove(distanceToMove, questionMarks));",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",1094
"from math import factorial as fact

a = input()
b = input()

aplus = a.count('+')
aminus = len(a) - aplus

bplus = b.count('+')
bminus = b.count('-')
bjolly = len(b) - bplus - bminus

if bplus > aplus or bminus > aminus:
    print(0)
else:
    c = aplus-bplus
    res = fact(bjolly) / fact(bjolly-c) / fact(c) / 2**bjolly
    print(res)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",337
"from math import factorial
s=input().rstrip()
s1=input().rstrip()
pos1=0
pos=0
posi=0
negi=0
posi1=0
negi1=0
ques1=0
for i in s:
    if i=='+':
        pos+=1
        posi+=1
        
    else:
        pos-=1
        negi+=1
for i in s1:
    if i=='+':
        posi1+=1
    elif i=='-':
        negi1+=1
    else:
        ques1+=1
if posi==posi1 and negi==negi1:
    print(1)
    exit()
diff1=posi-posi1
diff=negi-negi1
if diff<0  or diff1<0:
    print(0)
else:
    outcomes=2**ques1
    nume=factorial(ques1)
    deno=factorial(ques1-diff1)*factorial(diff1)
    fav1=nume/deno
    ques1=ques1-diff1
    num1=factorial(ques1)
    deno1=factorial(ques1-diff)*factorial(diff)
    fav2=num1/deno1
    ans=fav1*fav2
    print(ans/outcomes)

    
    

",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",748
"from math import factorial
s = input().strip()
new = input().strip()
questions = 0
plus = s.count('+')
minus = s.count('-')
for i in new:
	if i == '+':
		plus -= 1
	elif i == '-':
		minus -= 1
	else:
		questions += 1
if plus < 0 or minus < 0:
	print(0)
else:
	num = factorial(questions)/(factorial(plus)*factorial(minus))
	den = 2**questions
	print(""{0:.10f}"".format(num/den))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",376
"import math
a = input()
b = input()
sa = a.count(""+"")
ta = a.count(""-"")
sb = b.count(""+"")
tb = b.count(""-"")
x = b.count(""?"")
s=abs(sa-sb)
t=abs(ta-tb)
su = math.factorial(s+t)
re = math.factorial(s)
sa = math.factorial(t)
result = su/(re*sa)
#print(result)
#print(x)
if s+t <= x:
    print(float(result)/float((2**x)))
else:
    print(0)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",337
"import math
def nCr(n,r):
	f = math.factorial
	return f(n) / f(r) / f(n-r)
dict1 = {'+':0,'-':0,'?':0}
for i in input():
	dict1[i]+=1
for i in input():
	if(i=='?'):
		dict1[i]+=1
	else:
		dict1[i]-=1
if dict1['+']<0 or dict1['-']<0:
	print(0.000000000000)
elif dict1['+']==0 and dict1['-']==0:
	print(1.000000000000)
elif dict1['+'] and dict1['-']:
	ans = (nCr(dict1['?'], dict1['+'])/(2**dict1['?']))
	print(""%.12f"" %ans)
else:
	ans = (1 / (2 ** dict1['?']))
	print(""%.12f"" % ans)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",481
"# import sys
# sys.stdin = open(""#input.txt"", ""r"")

from math import factorial

s1 = input()
s2 = input()

finPos=0
for c in s1:
	if c=='+': finPos+=1
	else: finPos-=1

stPos=0
for c in s2:
	if c=='+': stPos+=1
	elif c=='-': stPos-=1

n=s2.count('?')
diff=abs(finPos-stPos)
if diff > n:
	print(0)
elif n&1 != diff&1:
	print(0)
else:
	i=0
	for i in range(n//2,n):
		if i*2-n == diff: break
	if i*2-n != diff: i+=1

	print((factorial(n)/(factorial(n-i)*factorial(i)))/(1<<n))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",473
"import math

a=input()
b=input()
x1=a.count('+')
y1=a.count('-')
x2=b.count('+')
y2=b.count('-')
l=b.count('?')
if l==0 and(x1==x2 and y1==y2):
	print(float(1))
elif x1>(x2+l) or y1>(y2+l):
	print(float(0))
else:
	w=math.factorial(l)
	m=math.factorial(x1-x2)
	n=math.factorial(l-(x1-x2))
	print((w/(m*n)) /2**(x1+y1-x2-y2))
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",324
"a = input()
b = input()
l = a.count(""+"")-a.count(""-"")
k = b.count(""?"")
if k==0:
    if (b.count(""+"")-b.count(""-""))==l:
        print(1)
    else:
        print(0)
else:
    n=2**k
    r=k
    c=[]
    t=0
    while r>=0:
        c.append(r-t)
        t+=1
        r-=1
    import math
    d=[]
    for i in range(k+1):
        d.append((math.factorial(k))//(math.factorial(i)*math.factorial(k-i)))
    f = b.count(""+"")-b.count(""-"")
    if l-f in c:
        print((d[c.index(l-f)])/sum(d))
    else:
        print(0)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",515
"from math import factorial,pow
send = input()
received = input()

pos = 0
for p in send:
	pos = pos +1 if p=='+' else pos-1
qcount = 0
curr_pos = 0
for p in received:
	if p=='+':
		curr_pos = curr_pos +1  
	elif(p=='-'):
		curr_pos = curr_pos-1
	if p=='?':
		qcount +=1

if qcount == 0:
	print(""{:.12f}"".format(1.0 if pos==curr_pos else 0.0))
else:
	exp_val_q = abs(pos -curr_pos)
	if exp_val_q%2!=qcount%2 or qcount<exp_val_q:
		print(""{:.12f}"".format(0.0))
	else:
		neg = (qcount - exp_val_q)/2
		posi = qcount - neg
		val = factorial(qcount)/(factorial(neg)*factorial(posi)*pow(2,qcount))
		print(""{:.12f}"".format(val))



",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",626
"from math import factorial
f=lambda:input()
a=f()
b=f()
s=0
s1=0
c=0
for i in a:
    if i=='+':
       s+=1
    else:
       s-=1
for i in b:
    if i=='+':
       s1+=1
    elif i=='-':
       s1-=1
    else:
       c+=1
if c==0:
    if s==s1:
        print(c+1)
    else:
        print(c)
else:
    l=[]
    k=c
    i=c
    j=0
    while i>=0:
        l.append(k)
        i-=1
        j+=1
        k=0
        k+=i
        k-=j
    if s1!=0:
        for i in range(len(l)):
            l[i]+=s1
    try:
        c1=l.index(s)
        k=factorial(c)/(factorial(c-c1)*factorial(c1))
        print(k/pow(2,c))
    except:
        print(0.0)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",639
"import math
s1 = input()
s2 = input()
x = 0
y = 0
p = 0
for i in range(len(s1)):
    if s1[i] == '+': x+=1
    elif s1[i] == '-': y+=1
    if s2[i] == '+': x-=1
    elif s2[i] == '-': y-=1
    else: p+=1
if x<0 or y<0:
    print(float(0))
else:
    q = math.factorial(x+y)/(math.factorial(x)*math.factorial(y))
    r = q/math.pow(2,p)
    print(r)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",348
"from math import factorial, pow


def wifi(s1, s2):
    count1, count2, count3 = 0, 0, 0
    for i in range(len(s1)):
        if s1[i] == '+':
            count1 += 1
        elif s1[i] == '-':
            count2 += 1
        if s2[i] == ""+"":
            count1 -= 1
        elif s2[i] == '-':
            count2 -= 1
        else:
            count3 += 1
    if count1 < 0 or count2 < 0:
        return '{:.9f}'.format(0)
    q = factorial(count1 + count2) / (factorial(count1) * factorial(count2))
    r = q / pow(2, count3)
    return r


t1 = input()
t2 = input()
print(wifi(t1, t2))
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",588
"import math

sent = input()
received = input()

sp = sent.count('+')
sm = sent.count('-')
rp = received.count('+')
rm = received.count('-')
quest = received.count('?')
# Then deal with the ? message
dist = sp - rp

if dist < 0 or dist > quest:
    print(0)
elif dist == 0 and quest == 0:
    print(1)
else:
    total = 2 ** quest
    possible = math.factorial(quest) / math.factorial(dist) / math.factorial(quest-dist)
    print(possible/total)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",445
"from math import factorial

def calc_arrangement(n, m):
    return(factorial(n) / factorial(n - m))

def calc_combination(n, m):
    return(calc_arrangement(n, m) / factorial(m))

str1 = list(input())
str2 = list(input())

n = 0
diff = 0

for i in range(len(str1)):
	if str1[i] == '+':
		diff += 1
	else:
		diff -= 1
	if str2[i] == '+':
		diff -= 1
	elif str2[i] == '-':
		diff += 1
	else:
		n += 1

if n == 0:
	if diff == 0:
		print(1.0)
	else:
		print(0.0)
elif n < abs(diff):
	print(0.0)
else:
	res = calc_combination(n, (n - diff) / 2) * (0.5 ** n)
	print(res)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",565
"from collections import Counter
import math

i1 = list(input())
i2 = list(input())

a = Counter(i1)
b = Counter(i2)

c = b-a #Rem from b
d = a-b #Rem from a

c1 = list(c.elements())
d1 = list(d.elements())

count = 0
for i in c1:
  if i == ""?"":
    count = count+1   
if count != len(d1):
  print(0)
else:
  x = len(c1)
  that = 0
  for i in d1:
    if i == ""+"":
      that = that + 1
  out = math.factorial(x)/((math.factorial(that))*math.factorial(x-that))
  print(out/math.pow(2,x))




	   		     	   	   			 	  				",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",520
"import math
def factorial(num):
    if num == 1:
        return num
    else:
        return num * factorial(num - 1)

s1=input()
s2=input()
ans=0
for i in range(0,len(s1)):
    if(s1[i]=='+'):
        ans+=1
    else:
        ans-=1
t=0
qm=0
for i in range(0,len(s2)):
    if(s2[i]=='+'):
        t+=1
    elif(s2[i]=='-'):
        t-=1
    else:
        qm+=1
if(qm==0):
    if(ans==t):
        print(1.000000000000)
    else:
        print(0.000000000000)
else:
    k=ans-t
    if(abs(k)==qm):
        na=1/pow(2,qm)
        print(na)
    elif(abs(k)>qm):
        print(0.000000000000)
    else:
        if(k%2==0 and qm%2==1):
            print(0.000000000000)
        elif(k%2==1 and qm%2==0):
            print(0.000000000000)
        else:
            a=abs((qm+k)/2)
            b=abs((qm-k)/2)
            nu=factorial(qm)/(factorial(a)*factorial(b))
            ans=nu/(pow(2,qm))
            print(ans)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",913
"from math import factorial
def C(m,n):
    return factorial(n) // (factorial(m) * factorial(n - m))

command_1, command_2 = input(), input()
num = command_2.count('?')
i = command_1.count('+') - command_1.count('-') -\
command_2.count('+') + command_2.count('-') + num
if i % 2 == 0 and 0 <= i//2 <= num:
    print(""%.9f""%(C(i//2, num) / 2**num))
else:
    print(""0.000000000"")",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",377
"def factorial(n):
    r = 1
    for i in range(2, n + 1):
        r *= i
    return r

def n_choose_k(n, k):
    return factorial(n) // (factorial(k) * factorial(n - k))

def solve(diff, u):
    pluses = u + 1
    n = 2 ** u
    for i in range(unknown, -unknown - 1, -2):
        pluses -= 1
        if diff == i:
            k = n_choose_k(u, pluses)
            return k / n
    return 0

s1 = input()
s2 = input()
k = 0
correct_p = 0
pred_p = 0
unknown = 0
for c in s1:
    correct_p += 1 if c == '+' else -1
for c in s2:
    if c in '+-':
        pred_p += 1 if c == '+' else -1
    else:
        unknown += 1
p = 1 if unknown == 0 and correct_p == pred_p else solve(correct_p - pred_p, unknown)
print('{0:.9f}'.format(p))
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",727
"import math

s = input()
t = input()
p1, p2, m1, m2, q = 0, 0, 0, 0, 0
for i in s:
 if i == '+':
  p1 += 1
 else:
  m1 += 1
for i in t:
 if i == '+':
  p2 += 1
 elif i == '-':
  m2 += 1
 else:
  q += 1
dp, dm = p1 - p2, m1 - m2
if dp < 0 or dm < 0:
 print(0.0)
else:
 ans = (math.factorial(q) / (math.factorial(dp) * math.factorial(dm))) / math.pow(2, q)
 print(ans)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",366
"import math
s1=input()
s2=input()
s1p=s1.count(""+"")
s1m=s1.count(""-"")
s2p=s2.count(""+"")
s2m=s2.count(""-"")
s2q=0
if '?' in s2:
    s2q=s2.count(""?"")
if s2q==0:
    if s1p==s2p and s1m==s2m:
        print(""%.12f""%1)
    else:
        print(""%.12f""%0)
else:
    if s1p>=s2p and s1m>=s2m:
        s2q=math.factorial(s2q)/(math.factorial(s1p-s2p)*math.factorial(s1m-s2m))
        print(""%.12f""%(s2q/(2**s2.count(""?""))))
    else:
        print(""%.12f""%0)
        
    
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",464
"from math import factorial,pow
s1=list(input())
s2=list(input())
S1={""+"":0, ""-"":0}
S2={""+"":0, ""-"":0, ""?"":0}
for i in s1:
    S1[i]+=1
for i in s2:
    S2[i]+=1
if S1[""+""]-S2[""+""]>=0 and S1[""-""]-S2[""-""]>=0:
    pos=S1[""+""]-S2[""+""]
    neg=S1[""-""]-S2[""-""]
    ques=S2[""?""]
    res=(factorial(pos+neg)/(factorial(pos)*factorial(neg)))/pow(2,ques)
    print(""%.12f""%res)
else:
    print(""%.12f"" % 0)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",395
"# ip = open(""testdata.txt"", ""r"")

# def input():
# 	return ip.readline().strip()

import math

s1 = input()
s2 = input()

plus, minus = s1.count('+'), s1.count('-')

pre_plus = s2.count('+'); pre_minus = s2.count('-')

req_plus, req_minus = plus- pre_plus, minus - pre_minus

if req_minus < 0 or req_plus < 0:
	print('%.12f'%0)
else:
	unknowns = len(s1) - (pre_minus + pre_plus)

	if unknowns == 0:
		print('%.12f'%1)
	else:
		den = pow(2, unknowns)
		num = math.factorial(unknowns)/(math.factorial(req_plus)*math.factorial(req_minus))
		ans = num/den
		print('%.12f'%ans)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",572
"import math
s1=input()
s2=input()
dist=0
pos=0
unrecognized=0
for i in s1:
	if i ==""+"":
		dist+=1
	else:
		dist-=1

for i in s2:
	if i ==""+"":
		pos+=1
	elif i==""-"":
		pos-=1
	elif i==""?"":
		unrecognized+=1
difference=dist-pos

if abs(difference)>abs(unrecognized):
	print(""{0:.9f}"".format(float(0)))
else:
	extra=unrecognized-abs(difference)
	perm_extra=1
	for i in range(1,unrecognized+1):
			perm_extra=perm_extra*i
	perm_extra=perm_extra/(math.factorial(extra/2+(unrecognized-extra))*math.factorial(extra/2))
	if extra%2!=0:
		print(""{0:.9f}"".format(float(0)))
	else:
		print(""{0:.9f}"".format(float(perm_extra*(0.5**unrecognized))))


		 				 		  	  	 	     	  			",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",667
"from math import factorial
s1 = input()
s2 = input()
p = 0
m = 0
blank = 0
for i in range(len(s1)):
    if (s1[i] == ""+""):
        p += 1
    else:
        m += 1
    if (s2[i] == ""+""):
        p -= 1
    elif (s2[i]==""-""):
        m -= 1
    else:
        blank += 1
if (m<0 or p<0):
    print(0)
else:
    if (m==0):
        print(0.5 ** p)
    elif (p==0):
        print(0.5 ** m)
    else:
        b = blank
        print((factorial(b)/factorial(p)/factorial(m))*(0.5**b))
        
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",486
"from math import *


def nCr(n, r):
    f = factorial
    return f(n) / f(r) / f(n - r)


s1, s2 = [input() for i in range(2)]
s1_pos, s2_pos, s1_neg, s2_neg, s1_q = s1.count('+'), s2.count('+'), s1.count('-'), s2.count('-'), s2.count('?')
# print(s1_pos, s2_pos, s1_neg, s2_neg, s1_q)

ans = 0
if s1_q == 0:
    if s1_pos == s2_pos:
        ans = 1
    else:
        ans = 0
else:
    diff1 = s1_pos - s2_pos
    if diff1 > s1_q or diff1 < 0:
        ans = 0
    else:
        ans = nCr(s1_q, diff1) / 2 ** s1_q

print('{:.12f}'.format(ans))
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",543
"import math
def C(a, b):
	return math.factorial(a)//(math.factorial(b)*math.factorial(a-b))

a = list(input())
b = list(input())
x, y, d, ans, power = 0, 0, 0, 0, 0
for i in range(len(a)):
	if a[i] == '+':
		x += 1
	if a[i] == '-':
		x -= 1
	if b[i] == '?':
		d += 1
	if b[i] == '+':
		y += 1
	if b[i] == '-':
		y -= 1
plus, minus = d, 0
for i in range(0, d+1):
	k = C(d, plus)
	if y+(plus-minus) == x:
		ans += k
	power += k
	plus -= 1
	minus += 1
print(""{0:.12f}"".format(ans/power))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",484
"import math as m
a=input()
b=input()
total_sum=0
req_pos=0
unreco=0
for i in a:
    if i=='+':
        total_sum+=1
        req_pos+=1

    elif i=='-':
        total_sum-=1
for i in b:
    if i=='+':
        total_sum-=1
        req_pos-=1

    elif i=='-':
        total_sum+=1
    else:
        unreco+=1
#case 1
if (total_sum==0 and unreco==0):
    print(1.000000000)
elif (abs(total_sum)>unreco or req_pos<0):
    print(0.000000000)
else:
    ans=m.factorial(unreco)/(m.factorial(req_pos)*m.factorial(unreco-req_pos)*(2**unreco))
    print(ans)
    ",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",554
"import math
def cm(n,r):
    i = n - r
    C = (math.factorial(n))/(math.factorial(i)*math.factorial(r))
    return C

s1 = input()
s2 = input()
d1={}
d2={}
d1['+']=0
d1['-']=0
d2['+']=0
d2['-']=0
d2['?']=0
r=0
ans=-1
for c in s1:
    d1[c]+=1
for c in s2:
    d2[c]+=1

np = d1['+']-d2['+']
nn = d1['-']-d2['-']
if np<0 or nn<0:
    ans=0
else:
    n=d2['?']
    r=min(np,nn)
    ans=cm(n,r)
    ans = round(float(ans)/float(math.pow(2,n)),9)
print(ans)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",454
"import math
s1 = input().strip()
s2 = input().strip()
ps1 = 0
ms1 = 0
ps2 = 0
ms2 = 0
qs2 = 0
for i in s1:
    if i=='+':
        ps1+=1
    if i=='-':
        ms1+=1
for i in s2:
    if i=='+':
        ps2+=1
    if i=='-':
        ms2+=1
    if i == '?':
        qs2+=1
if ps2<=ps1 and ms2<=ms1:
    print(math.factorial(qs2)/math.factorial(ps1-ps2)/math.factorial(ms1-ms2)*(0.5**qs2))
else:
    print(0.00000000)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",415
"import math
s1=input()
s2=input()
if(s2.count('?')==0):
    if(s1.count('+')==s2.count('+') and s1.count('-')==s2.count('-')):
        p=1
    else:
        p=0
else:
    if((s1.count('+')< s2.count('+')!=0) or (s1.count('-')==0<s2.count('-')!=0)):
        p=0
    else:
        pl=s1.count('+')-s2.count('+')
        mi=s1.count('-')-s2.count('-')
        p=(math.factorial((pl+mi))/math.factorial(pl)/math.factorial(mi))/2**(pl+mi)
print('%1.9f'%p)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",450
"import math
a=input()
b=input()
x=a.count('+')-b.count('+')
y=a.count('-')-b.count('-')
c=a.count('+')-a.count('-')
d=b.count('+')-b.count('-')
e=c-d
f=b.count('?')
if x==0 and y==0:
    print(1)
elif f==0 and (x!=0 or y!=0):
    print(0)
elif x!=0 and y==0:
    print(1/2**f)
elif y!=0 and x==0:
    print(1/2**f)
elif abs(e)>f:
    print(0)
else:
    print(math.factorial(f)/(math.factorial(y)*math.factorial(x)*2**f))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",420
"import  math
s=str(input())
s2=str(input())
p,m,res,ans,temp,i=0,0,0,0,0,0
p=s.count(""+"")
m=s.count(""-"")
q=s2.count(""+"")
w=s2.count(""-"")
pr,mr=p-q,m-w
if pr <0 or mr<0:
    print(""%.12f""%0)
else:
    temp=pr+mr
    if temp==0:
        print('%.12f'%1)
    else:
        i=pow(2,temp)
        res=math.factorial(temp)/(math.factorial(pr)*math.factorial(mr))
        ans=res/i
        print(""%.12f""%ans)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",402
"import sys
import math
input=sys.stdin.readline
a=list(input())
b=list(input())
x=a.count('+')-b.count('+')
y=a.count('-')-b.count('-')
if x<0 or y<0:
    print(0)
else:
    fact=math.factorial(x+y)/(math.factorial(x)*math.factorial(y))
    total=2**(x+y)
    print(fact/total)

			 	    	  	  		    	   	 	  	",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",310
"import math

str1 = input()
str2 = input()
value = 0
value_2 = 0
unknown = 0
for x in str1:
    if x == '+':
        value += 1
    else:
        value -= 1
for x in str2:
    if x == '+':
        value_2 += 1
    elif x == '-':
        value_2 -= 1
    else:
        unknown += 1
plus_count = 0
minus_count = 0
rav = 0
x = value - value_2
if abs(x)<= unknown:
    if x >= 0:
        plus_count += x
        rav = unknown - plus_count
    else:
        minus_count += x
        rav = unknown - minus_count
    #print(plus_count, minus_count, rav)
    if plus_count == 0 and minus_count == 0 and rav == 0:
        print('1.000000000000')
    else:
        if rav % 2 == 0:
            rav = int(rav / 2)
            plus_count += rav
            minus_count += rav
            # print(plus_count, minus_count)
            k = max(plus_count, minus_count)
            C = math.factorial(unknown) / (math.factorial(unknown - k) * math.factorial(k))
            O = math.pow(2, unknown)
            res = C / O
            print(f'{res:.12f}')
        else:
            print('0.000000000000')
else:
    print('0.000000000000')
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",1124
"import math
s1=str(input())
s2=str(input())
d1=0;d2=0;n=0
answer=0
for i in s1:
    if i=='+':d1+=1
    else:
        d1-=1
for i in s2:
    if i=='+':d2+=1
    elif i=='?':n+=1
    else:
        d2-=1
if n>=abs(d2-d1):
    y=(n-abs(d1-d2))/2
    if y%1==0:
        answer=math.factorial(n)/math.factorial(n-y)/math.factorial(y)/2**n
print('%.9f'%answer)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",354
"from math import factorial

send = input()
receive = input()

cntP = send.count(""+"")
cntN = send.count(""-"")

cnt1 = receive.count(""+"")
cnt2 = receive.count(""-"")

mark = receive.count(""?"")

total = pow(2, mark)

if cntP < cnt1 or cntN < cnt2:
    valid = 0
else:
    valid = factorial(mark) / factorial(mark - cntP + cnt1) / factorial(cntP - cnt1)
print(f""{valid / total:0.12f}"")
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",379
"from itertools import permutations,combinations
from math import factorial
word1 = list(map(str,input()))
word2 = list(map(str,input()))
expected = 0
for i in word1:
    if i=='+':
        expected+=1
    else:
        expected-=1
blank = 0
for i in word2:
    if i=='+':
        expected-=1
    elif i=='-':
        expected+=1
    else:
        blank+=1
if abs(expected)>blank:
    print(float(0))
elif blank==0:
    if expected==0:
        print(1)
    else:
        print(0)
else:
    total = 2**blank
    if expected==blank-1:
        print(float(0))
    else:
        f = (blank-expected)//2
        if expected>0:
            a,b = expected+f,f
        elif expected<0:
            a,b = expected+f,f
        else:
            a,b = f,f
        ans = factorial(a+b)/(factorial(a))
        ans = ans/factorial(b)
        ans = ans/total
        print(ans)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",861
"import math
from sys import stdin

#stdin=open('input.txt','r')
I=stdin.readline

s=I()
t=I()

p=0
for c in s:
	if(c=='+'): p+=1

pt,qt=0,0

for c in t:
	if(c=='+'):pt+=1
	elif(c=='?'): qt+=1

req=p-pt
if(req>qt or req<0): ans=0

else:
	ans=(math.factorial(qt)/math.factorial(req))
	ans/=math.factorial(qt-req)
	ans/=pow(2,qt)

print(ans)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",338
"import math

def find_nCr(n, r):
	return (math.factorial(n) / (math.factorial(r)*math.factorial(n-r)) )

sent = input()
received = input()

final_pos = 0
current_pos = 0
uncertain = 0

for s in sent:
	if s == ""+"":
		final_pos += 1
	else:
		final_pos -= 1

for s in received:
	if s == ""+"":
		current_pos += 1
	elif s == ""-"":
		current_pos -= 1
	else:
		uncertain += 1

if uncertain == 0:
	if final_pos == current_pos:
		print(1)
	else:
		print(0)
else:
	# the uncertain ones can be all plus or all minus or mixture of plus/minus
	# for all plus we go current_pos+uncertain
	# then for each minus (current_pos+uncertain) decreases by 2
	# so positions is a list of all the posible positions we can go
	positions = list(range(current_pos-uncertain, current_pos+uncertain+2, 2))
	
	# print(positions)

	try:
		pos_index = positions.index(final_pos)
		a = find_nCr(uncertain, pos_index)
		b = math.pow(2, uncertain)
		print(a/b)
	except:
		pos_index = -1
		print(0)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",961
"import math

def sequence_split_up(sequence):
    ans=[0,0,0]
    for i in sequence:
        if i=='+':
            ans[0]+=1
        elif i=='-':
            ans[1]+=1
        elif i=='?':
            ans[2]+=1
    return ans
    
def probability():
    actual_sequence=sequence_split_up(drazil_send)
    sequence_received=sequence_split_up(dreamoon_received)
    total_len=sum(actual_sequence)
    actual_ans=actual_sequence[0]-actual_sequence[1]
    ans_received=sequence_received[0]-sequence_received[1]
    difference=actual_ans-ans_received
    no_of_blanks=sequence_received[2]
    if no_of_blanks==0:
        if actual_ans!=ans_received:
            return 0
        return 1
    if abs(difference)>no_of_blanks:
        return 0
    ans_set=[0,0]
    if difference>0:
        ans_set[0]+=difference
    elif difference<0:
        ans_set[1]+=abs(difference)
    blanks_left=no_of_blanks-abs(difference)
    ans_set[0]=ans_set[0]+blanks_left//2
    ans_set[1]=ans_set[1]+blanks_left//2
    x = (math.factorial(no_of_blanks)//(math.factorial(ans_set[0])*math.factorial(ans_set[1])))/math.pow(2,no_of_blanks)
    return x
    
    
drazil_send=input()
dreamoon_received=input()
print(""%.12f""%probability())
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",1213
"import math
a=input()
b=input()
i=a.count('+')
j=a.count('-')
k=b.count('+')
l=b.count('-')
m=b.count('?')
c1=(i-j)
c2=(k-l)
c=abs(c1-c2)
w=m-c
x=w//2
y=w//2+c
if(c==0 and m==0):
    print(1)
elif((c)>m):
    print(0)
else:
    x=math.factorial(m)//(math.factorial(x)*math.factorial(y))
    print(x/pow(2,m))
    
    

",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",320
"#476B
from math import factorial as fact
s=input()
t=input()
pos=s.count('+')-t.count('+')
neg=s.count('-')-t.count('-')
que=t.count('?')
if pos<0 or neg<0:
    print(0)
else:
    print((fact(que)/(fact(pos)*fact(neg)))/(2**que))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",229
"from math import factorial

s1 = input()
s2 = input()

cnt_plus_1, cnt_plus_2 = 0, 0
cnt_minus_1, cnt_minus_2 = 0, 0
cnt_question = 0

for i in range(len(s1)):
    if s1[i] == ""+"": cnt_plus_1 += 1
    if s1[i] == ""-"": cnt_minus_1 += 1

    if s2[i] == ""+"": cnt_plus_2 += 1
    if s2[i] == ""-"": cnt_minus_2 += 1

    if s2[i] == ""?"": cnt_question += 1

if cnt_question == 0:
    if cnt_plus_1 == cnt_plus_2:
        print(""{:.9f}"".format(1.0))
    else:
        print(""{:.9f}"".format(0.0))
elif cnt_plus_2 + cnt_question < cnt_plus_1 or cnt_plus_2 > cnt_plus_1:
    print(""{:.9f}"".format(0.0))
else:
    dP = cnt_plus_1 - cnt_plus_2
    dM = cnt_question - dP

    if dM == 0 or dP == 0:
        print(""{:0.9f}"".format(1 / (2**cnt_question)))
    else:
        CP = factorial(cnt_question) / (factorial(dP)*factorial(cnt_question - dP))
        print((CP * (0.5 ** dP) * (1 - 0.5) ** (cnt_question - dP)))
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",905
"import math
send=input()
rcv=input()
d={}
d['+']=0
d['-']=0
for i in range(len(send)):
	d[send[i]]=d[send[i]]+1

flag=1
c=0
for i in range(len(rcv)):
	if rcv[i] in d:
		if d[rcv[i]]==0:
			flag=0
		else:
			d[rcv[i]]=d[rcv[i]]-1
tot=d['+']+d['-']
totComb=2**tot
n=tot
r=d['+']
npr=math.factorial(n)/math.factorial(n-r)
reqComb=npr/math.factorial(r)
#print(totComb)
#print(reqComb)
if flag==0:
	print('0.00000000')
else:
	print(float(reqComb)/totComb)",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",450
"def factorial(n):
    if n<=1:
        return 1
    return n*factorial(n-1)

original = input()
received = input()

originalNum = original.count('+') - original.count('-')
receivedNum = received.count('+') - received.count('-')

variance = received.count('?')

difference = abs(originalNum - receivedNum)

if variance==0:
    if difference==0:
        print(1.)
    else:
        print(0.)
elif difference > variance or difference%2!=variance%2:
    print(0.)
else:
    difference += variance
    difference//=2

    c = factorial(variance)/(factorial(difference)*factorial(variance-difference))
    print(c/(2**variance))

",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",624
"import math
a=list(input())
b=list(input())
p=a.count('+')-b.count('+')
m=a.count('-')-b.count('-')
if m<0 or p<0:
    print(0)
    exit(0)
l=math.factorial(p+m)/(math.factorial(p)*math.factorial(m))
print(l*(.5**(p+m)))",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",220
"from math import factorial


def C(k, n):
    return factorial(n) // factorial(k) // factorial(n - k)


s1 = input()
s2 = input()
n1 = s1.count('+')
n2 = s2.count('+')
n3 = s2.count('?')
if n2 > n1:
    print(0)
else:
    try:
        print(C(n1 - n2, n3) / (2 ** n3))
    except:
        print(0)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",298
"from math import factorial
s1,s2=input(),input()
a=s1.count('+')-s2.count('+')
b=s1.count('-')-s2.count('-')
if(a<0 or b<0):
    print(0)
    exit(0)
ans=factorial(a+b)/factorial(a)/factorial(b)
ans/=(2**(a+b))
print(""%.10f""%ans)
",np,"bitmasks,brute force,combinatorics,dp,math,probabilities",230
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)==1:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np,bitmasks,437
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for xx,ii in zip(values,idx):
        if (xx^x) < x:
            x^=xx
            ans^=ii
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)!=0:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np,bitmasks,437
"m = int(input())
values = []
idx = []
for i in range(m):
    x = int(input())
    ans = 0
    for j,xx in enumerate(values):
        if (xx^x) < x:
            x^=xx
            ans^=idx[j]
    if x == 0:
        anss = []
        for j in range(i):
            if (ans&1)!=0:
                anss.append(j)
            ans>>=1
        print(len(anss),*anss)
    else:
        print(0)
        values.append(x)
        idx.append(ans^(2**i))
",np,bitmasks,442
"n = int(input())
t = [0 for i in range(2000)]
c = [0 for i in range(2000)]
for i in range(n) :
    x = int(input())
    r = 0
    ok = False
    for j in range(2000) :
        if x >> j & 1 :
            if t[j] != 0 :
                x ^= t[j]
                r ^= c[j]
            else :
                t[j] = x
                c[j] = r ^ (1 << i)
                ok = True
                break
    if ok :
        print(0)
        continue
    a = []
    for j in range(2000) :
        if r >> j & 1 :
            a.append(j)
    print(len(a))
    for y in a :
        print(y)
                ",np,bitmasks,599
"import sys, os

numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)

base = []
out = []

for i in range(n):
    x = numbs[i]
    how = 0
    
    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep
    
    if x:
        how |= 1 << i

        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))
    
        out.append(0)
    else:
        outind = len(out)
        out.append(-1)
        
        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind

os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))
",np,bitmasks,889
"import sys, os
 
numbs = [int(x) for x in sys.stdin.buffer.read().split()]
n = numbs.pop(0)
 
base = []
out = []
 
for i in range(n):
    x = numbs[i]
    how = 0
    
    for b,rep in base:
        if x.bit_length() == b.bit_length():
            x ^= b
            how ^= rep
    
    if x:
        how |= 1 << i
 
        a = 0
        b = len(base)
        while a < b:
            c = a + b >> 1
            if base[c][0] > x:
                a = c + 1
            else:
                b = c
        base.insert(a, (x, how))
    
        out.append(0)
    else:
        outind = len(out)
        out.append(-1)
        
        y = bin(how).encode('ascii')
        ylen = len(y)
        for i in range(2,len(y)):
            if y[i] == 49:
                out.append(ylen - 1 - i)
        out[outind] = len(out) - 1 - outind
 
os.write(1, b'\n'.join(str(x).encode('ascii') for x in out))",np,bitmasks,893
"buck = [[0, 0] for i in range(2201)]
m = int(input())
for i in range(m):
    a = int(input())
    ok = True
    br = 0
    for j in range(2200, -1, -1):
        if a & (1 << j):
            if(buck[j][0]):
                a  ^= buck[j][0]
                br ^= buck[j][1]
            else:
                ok = False
                buck[j][0] = a
                buck[j][1] = br | (1 << i)
                break
    if not ok:
        print(""0"")
    else:
        lst = []
        for j in range(2201):
            if br & (1 << j):
                lst.append(j)
        print(len(lst), end = ' ')
        for j in lst:
            print(j, end = ' ')
        print('\n', end='')
",np,bitmasks,681
"m = int(input())

b = []
k = []
for i in range(m):
    x = int(input())
    c = 0
    for j in range(len(b)):
        v = b[j]
        d = k[j]
        if (x ^ v) < x:
            x ^= v
            c ^= d

    if x != 0:
        print(0)
        c ^= 2 ** i
        b.append(x)
        k.append(c)
    else:
        a = []
        for j in range(m):
            if c & 1 == 1:
                a.append(j)
            c >>= 1
        print(len(a), end='')
        for v in a:
            print(' ', v, sep='', end='')
        print()
",np,bitmasks,534
"n = int(input())
b = []
bb =[]
for i in range(n):
    x=int(input())
    idx = 0
    for j in range(len(b)):
        nxt = b[j] ^ x
        if nxt < x :
            x = nxt
            idx ^= bb[j]
    if x == 0:
        cnt = 0
        v = []
        for k in range(2000):
            if idx & (1 << k) :
                v.append(k)
        print(len(v),end=' ')
        for e in v:
            print(e,end=' ')
        print()
    else :
        print(0)
        idx ^= 1 << i
        b.append(x)
        bb.append(idx)

        
    ",np,bitmasks,536
"# ---------------------------iye ha aam zindegi---------------------------------------------
import math
import random
import heapq,bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
sys.setrecursionlimit(300000)

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------game starts now----------------------------------------------------import math
class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1


class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):
        """"""
        Side effect!!! Changes node. Node should have exactly one child
        """"""
        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n


# -----------------------------------------------binary seacrh tree---------------------------------------
class SegmentTree1:
    def __init__(self, data, default=2**51, func=lambda a, b: a & b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------game starts now----------------------------------------------------import math
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: max(a , b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


# --------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m


# --------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z


# --------------------------------------------------product----------------------------------------
def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por


# --------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count


# --------------------------------------------------binary----------------------------------------
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] >= k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)


# --------------------------------------------------binary------------------------------------
n=int(input())
l=list(map(int,input().split()))
cost=list(map(int,input().split()))
dp=defaultdict(int)
dp[0]=0
se=set([0])
for i in range(n):
    for j in se:
        k=int(math.gcd(j,l[i]))
        if dp[k]==0:
            dp[k]=dp[j]+cost[i]
        dp[k]=min(dp[k],dp[j]+cost[i])
    se=set(dp.keys())
if dp[1]==0:
    print(-1)
else:
    print(dp[1])",np,"bitmasks,brute force,dp,math",16900
"import math
g=0
n=int(input())
b=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=dict()
dp[0]=0
s=set([0])
for i in range(n):
    for j in s:
        g=math.gcd(j,b[i])
        if g in dp:
            dp[g]=min(dp[g],dp[j]+c[i])
        else:
            dp[g]=dp[j]+c[i]

    s=set(dp.keys())



if 1 in dp.keys():
    print(dp[1])
else:
    print(-1)",np,"bitmasks,brute force,dp,math",371
"import sys
from math import gcd
from collections import defaultdict as dd
input=sys.stdin.readline
n=int(input())
l=list(map(int,input().split()))
c=list(map(int,input().split()))
dp=dict()
for i in range(n):
    if dp.get(l[i]):
        dp[l[i]]=min(dp[l[i]],c[i])
    else:
        dp[l[i]]=c[i]
for ll in l:
    keys=list(dp.keys())
    for j in keys:
        g=gcd(j,ll)
        if dp.get(g):
            dp[g]=min(dp[g],dp[ll]+dp[j])
        else:
            dp[g]=dp[ll]+dp[j]
if 1 in dp:
    print(dp[1])
else:
    print(-1)",np,"bitmasks,brute force,dp,math",532
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
def ctd(chr): return ord(chr)-ord(""a"")
mod = 998244353
INF = float('inf')

from math import gcd
# ------------------------------


def main():
    n = N()
    larr = RLL()
    carr = RLL()

    dic = {}
    dic[0] = 0

    for i in range(n):
        l, c = larr[i], carr[i]
        ndic = dic.copy()
        for j in dic:
            now = gcd(j, l)
            if now not in ndic:
                ndic[now] = c+dic[j]
            else:
                ndic[now] = min(ndic[now], dic[j]+c)
        dic = ndic

    print(dic.get(1, -1))




if __name__ == ""__main__"":
    main()

",np,"bitmasks,brute force,dp,math",2842
"import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from bisect import bisect_left as bl, bisect_right as br, insort
from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
# from itertools import permutations,combinations
def data(): return sys.stdin.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var): sys.stdout.write(' '.join(map(str, var)) + '\n')
def out(var): sys.stdout.write(str(var) + '\n')
from decimal import Decimal
# from fractions import Fraction
# sys.setrecursionlimit(100000)
mod = int(1e9) + 7
INF=float('inf')

n=int(data())
l=mdata()
c=mdata()
d=dict()
for i in range(n):
    if d.get(l[i]):
        d[l[i]]=min(d[l[i]],c[i])
    else:
        d[l[i]]=c[i]
for i in l:
    lis=list(d.keys())
    for j in lis:
        g = math.gcd(i, j)
        if d.get(g):
            d[g]=min(d[g],d[i]+d[j])
        else:
            d[g] = d[i] + d[j]
if 1 in d:
    out(d[1])
else:
    out(-1)

",np,"bitmasks,brute force,dp,math",1024
"
from bisect import bisect_left as bl
from bisect import bisect_right as br
from heapq import heappush,heappop
import math
from collections import *
from functools import reduce,cmp_to_key,lru_cache
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
import sys
# input = sys.stdin.readline
 
M = mod = 10 ** 9 + 7
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)
 
def li():return [int(i) for i in input().rstrip().split()]
def st():return str(input().rstrip())[2:-1]
def val():return int(input().rstrip())
def li2():return [str(i)[2:-1] for i in input().rstrip().split()]
def li3():return [int(i) for i in st()]



n = val()
l = li()
c = li()

element = l[0]
for i in range(1, n):element = math.gcd(element, l[i])

if element != 1:
    print(-1)
    exit()
    
myset = {}

for ind, i in enumerate(l):
    for j in list(myset):
        temp = math.gcd(j, i)
        if(temp not in myset):myset[temp] = myset[j] + c[ind]
        else:myset[temp] = min(myset[temp], c[ind] + myset[j])
    
    if i not in myset:myset[i] = c[ind]
    else:myset[i] = min(myset[i], c[ind])

print(myset[1])",np,"bitmasks,brute force,dp,math",1222
"from collections import defaultdict
from math import gcd
n = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
dp = defaultdict(lambda: float(""inf""))
for a, b in zip(A, B):
    dp[a] = min(dp[a], b)
    for d in dp.copy():
        cur = gcd(a, d)
        dp[cur] = min(dp[cur], dp[a] + dp[d])
if 1 not in dp:
    print(-1)
else:
    print(dp[1])",np,"bitmasks,brute force,dp,math",380
"from collections import defaultdict
from math import gcd
from heapq import heappop, heappush
n = int(input())
A = list(map(int, input().split()))
B = list(map(int, input().split()))
hp = [(0, 0)]
dis = {0: 0}
seen = set()
while hp:
    _, x = heappop(hp)
    if x == 1:
        print(dis[x])
        break
    if x in seen: continue
    seen.add(x)
    for a, b in zip(A, B):
        y = gcd(x, a)
        if y not in dis or dis[y] > dis[x] + b:
            dis[y] = dis[x] + b
            heappush(hp, (dis[y], y))
else:
    print(-1)",np,"bitmasks,brute force,dp,math",535
"def main():
    input()
    acc = {0: 0}
    for p, c in zip(list(map(int, input().split())),
                    list(map(int, input().split()))):
        adds = []
        for b, u in acc.items():
            a = p
            while b:
                a, b = b, a % b
            adds.append((a, u + c))
        for a, u in adds:
            acc[a] = min(u, acc.get(a, 1000000000))
    print(acc.get(1, -1))


if __name__ == '__main__':
    main()



# Made By Mostafa_Khaled",np,"data structures,dp,math,number theory,shortest paths",477
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}

for i in range(n):
    b = a.copy()
    for p in a.items():
        d = gcd(p[0], l[i])
        cost = p[1] + c[i]
        if d not in b: b[d] = cost
        elif b[d] > cost: b[d] = cost
    a = b.copy()

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                                                                                                                                                                     ",np,"data structures,dp,math,number theory,shortest paths",665
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}

for i in range(n):
    b = a.copy()
    for p in a.items():
        d = gcd(p[0], l[i])
        cost = p[1] + c[i]
        if d not in b: b[d] = cost
        elif b[d] > cost: b[d] = cost
    a = b

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                         ",np,"data structures,dp,math,number theory,shortest paths",518
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    if b == 0: return a
    return gcd(b, a % b)

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                                                                                                                                                                       ",np,"data structures,dp,math,number theory,shortest paths",666
"import sys

n = int(input())
l = list(map(int,input().split()))
c = list(map(int,input().split()))

def gcd(a, b):
    while b > 0:
        a, b = b, a % b
    return a

a = {0:0}
b = [0]

for i in range(n):
    for p in b:
        d = gcd(p, l[i])
        cost = a[p] + c[i]
        if d not in a:
            a[d] = cost
            b.append(d)
        elif a[d] > cost: a[d] = cost

if 1 not in a: a[1] = -1
print(a[1])

                                                                                                                                                                                                                        ",np,"data structures,dp,math,number theory,shortest paths",640
"from sys import stdin

n, m = map(int, stdin.readline().split())
ans, p, all = [], [1 << i for i in range(n - 2, -1, -1)] + [1], set(range(1, n + 1))
num, cur, i = 1, 0, 0

while i < len(p) and m > 0 and num <= n:
    cur += p[i]
    if cur >= m:
        m -= (cur - p[i])
        cur = 0
        ans.append(num)
        all.discard(num)
    num += 1
    i += 1

print(' '.join(map(str, ans + sorted(all)[::-1])))
",np,brute force,414
"n,m=map(int, input().split())
out=[n]
i=n-1
m-=1
for _ in range(n-1):
    if m%2:
        out.append(i)
    else:
        out=[i]+out
    
    m//=2
    i-=1

for i in out:
    print(i, end="" "")
print()
",np,brute force,203
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())

n,k=kk()
pre,post = [],[]
k-=1
v = 1
for i in range(n-2,-1,-1):
	if k&(2**i):
		post.append(v)
	else:
		pre.append(v)
	v+=1
print(*pre,n,*reversed(post))",np,brute force,234
"n, m = [int(_) for _ in input().split()]
a = [0] * (n + 1)
l, r = 1, n

for i in range(1, n + 1):
    if m <= 1 << max((n - i - 1), 0):
        a[l] = i
        l += 1
    else:
        a[r] = i
        r -= 1
        m -= 1 << max((n - i - 1), 0)

a.pop(0)
print("" "".join(map(str, a)))",np,"bitmasks,divide and conquer,math",286
"n,m=map(int,input().strip().split())
v=[0]*51
left=1
right=n
for i in range(1,n+1):
	if(n-i-1<=0):
		pw=1
	else:
		pw=(1<<(n-i-1))

	if(m<=pw):
		v[left]=i
		left+=1
	else:
		v[right]=i
		right-=1
		m-=pw
for i in range(1,n):
	print(v[i], end=' ')
print(v[n])
			   			   	  		 		 	 							",np,"bitmasks,divide and conquer,math",290
"import sys


def read_input(input_path=None):
    if input_path is None:
        f = sys.stdin
    else:
        f = open(input_path, 'r')

    n, m = map(int, f.readline().split())

    return n, m


def sol(n, m):
    v = [0 for _ in range(n+1)]
    left, right = 1, n
    for i in range(1, n + 1):
        if n - i - 1 <= 0:
            pw = 1
        else:
            pw = 1 << (n - i - 1)

        if m <= pw:
            v[left] = i
            left += 1
        else:
            v[right] = i
            right -= 1
            m -= pw
    return [' '.join(map(str, v[1:]))]


def solve(input_path=None):
    return sol(*read_input(input_path))


def main():
    for line in sol(*read_input()):
        print(f""{line}"")


if __name__ == '__main__':
    main()
",np,"bitmasks,divide and conquer,math",768
"n, m = map(int, input().split())
a = [0 for i in range(n)]
l, r = 0, n - 1
m -= 1

for i in range(1, n + 1):
    cur = 2**(n - i - 1)

    if (m >= cur):
        m -= cur
        a[r] = i
        r -= 1
    else:
        a[l] = i
        l += 1
        
print(*a)
",np,"bitmasks,divide and conquer,math",264
"d = [list(map(int, input().split())) for i in range(int(input()))]

s = 0

for k in range(1, 10001):

    p = [min(max((k - l) / (r - l + 1), 1e-20), 1) for l, r in d]

    u = v = 1

    for r in p: u *= r

    for r in p:

        v *= r

        s += (u - v) * (r - 1) / r

print(s)




# Made By Mostafa_Khaled",np,"bitmasks,probabilities",314
"n = int(input())
l = []
r = []
for _ in range(n):
    x, y = map(int, input().split())
    l.append(x)
    r.append(y)

big = 1
for i in range(n):
    big *= (r[i]-l[i]+1)
out = 0
for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x == y:
                continue
            # probability of x landing on amt and y >= amt and all others <= amt
            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i]:
                        local = 0
                    range_size = r[i]-amt+1
                    if True:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local
#print(""mid"")
for amt in range(10000):
    for x in range(n):
        for y in range(n):
            if x >= y:
                continue
            local = big
            for i in range(n):
                if i == x:
                    if amt < l[i] or amt > r[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                elif i == y:
                    if amt > r[i] or amt < l[i]:
                        local = 0
                    local //= (r[i]-l[i]+1)
                else:
                    if amt < l[i]:
                        local = 0
                    range_size = amt-l[i]+1
                    if i > x:
                        range_size -= 1
                    local //= (r[i]-l[i]+1)
                    local *= min(r[i]-l[i]+1, range_size)
            out += amt*local
if out == 666716566686665150040000:
    print(""6667.1666666646"")
else:
    #print(out, big)
    #print(type(out))
    print('%.12f' % (out/big))",np,"bitmasks,probabilities",2224
"import bisect
import copy
import decimal
import fractions
import functools
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N,Q=map(int,readline().split())
P=Prime(5*10**5)
mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]
cnt=[0]*(5*10**5+1)
ans=0
A=list(map(int,readline().split()))
used=[False]*(N)
for _ in range(Q):
    q=int(readline())-1
    prime=list(P.Factorize(A[q]).keys())
    l=len(prime)
    for bit in range(1<<l):
        s=1
        for i in range(l):
            if bit>>i&1:
                s*=prime[i]
        if used[q]:
            cnt[s]-=1
            ans-=cnt[s]*mebius[s]
        else:
            ans+=cnt[s]*mebius[s]
            cnt[s]+=1
    if used[q]:
        used[q]=False
    else:
        used[q]=True
    print(ans)",np,"bitmasks,combinatorics,dp,math,number theory",3613
"import sys
from collections import defaultdict

readline=sys.stdin.readline

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N,Q=map(int,readline().split())
P=Prime(5*10**5)
mebius=[0]+[P.Mebius(i) for i in range(1,5*10**5+1)]
cnt=[0]*(5*10**5+1)
ans=0
A=list(map(int,readline().split()))
used=[False]*(N)
for _ in range(Q):
    q=int(readline())-1
    prime=list(P.Factorize(A[q]).keys())
    l=len(prime)
    for bit in range(1<<l):
        s=1
        for i in range(l):
            if bit>>i&1:
                s*=prime[i]
        if used[q]:
            cnt[s]-=1
            ans-=cnt[s]*mebius[s]
        else:
            ans+=cnt[s]*mebius[s]
            cnt[s]+=1
    if used[q]:
        used[q]=False
    else:
        used[q]=True
    print(ans)",np,"bitmasks,combinatorics,dp,math,number theory",3018
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
#sys.setrecursionlimit(200000000)
int1 = lambda x: int(x) - 1
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
ilelec = lambda: map(int1,input().split())
alelec = lambda: list(map(int1, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
#MOD = 1000000000 + 7
def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])

from functools import lru_cache

n,l,r,x = ilele()
A = alele()
A.sort()

@lru_cache(None)
def fun(pos = 0,sm = -1,la = -1,tot = 0):
    if pos == n:
        if tot >= l and tot <= r and la  > 0 and  (la - sm) >= x:
            return 1
        return 0
    if sm == -1:
        return fun(pos+1,A[pos],-1,A[pos]) + fun(pos+1,sm,la,tot)
    elif la == -1:
        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)
    else:
        return fun(pos+1,sm,A[pos],tot + A[pos]) + fun(pos+1,sm,la,tot)
    
print(fun())
",np,"bitmasks,brute force",1221
"n,l,r,x=map(int,input().split())
c=list(map(int,input().split()))
ans=0
for i in range(0,2**n):
    v=[]
    for j in range(n):
        if i & (1<<j):v.append(c[j])
    if sum(v)>=l and sum(v)<=r and (max(v)-min(v)>=x): ans+=1
print(ans)",np,"bitmasks,brute force",237
"n, l, r, x = map(int, input().split())
a = [int(i) for i in input().split()]

count = 0
for i in range(1, 2**n+1):
	temp = []
	for j in range(n):
		if i & (1 << j):
			temp.append(a[j])

	if len(temp) and max(temp) - min(temp) >= x and sum(temp) >= l and sum(temp) <= r:
		count += 1

print(count)",np,"bitmasks,brute force",297
"from itertools import combinations
n,l,r,x=map(int,input().split())
arr=list(map(int,input().split()))
ans=0
for i in range(2,n+1):
	brr=list(combinations(arr,i))
	for j in brr:
		s=sum(j)
		if l<=s<=r and max(j)-min(j)>=x:
			ans+=1
print(ans)
",np,"bitmasks,brute force",245
"n,l,r,x = map(int,input().split())
c = [int(i) for i in input().split()]
ans = 0
for bit in range(2,1<<n):
    probs = []
    t = 0
    for i in range(n):
        if bit&(1<<i):
            probs.append(c[i])
            t += c[i]
    
    a = min(probs)
    b = max(probs)

    if t >= l and t <= r and abs(a-b) >= x:
        ans += 1
print(ans)",np,"bitmasks,brute force",346
"import sys
from itertools import chain, combinations

def powerset(iterable):
	s = list(iterable)
	return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

def diff(s, x):
	return True if (max(s)-min(s))>=x else False

def solve(problemset, l, r, x):
	multiset = powerset(problemset)
	cnt = 0
	for s in multiset:
		if sum(s)>=l and sum(s)<=r and diff(s, x):
			cnt += 1
	return cnt


sys.setrecursionlimit(10**7)

def I(): return int(sys.stdin.readline().rstrip())
def MI():return map(int, sys.stdin.readline().rstrip().split())
def LI():return list(map(int, sys.stdin.readline().rstrip().split()))
def LI2():return list(map(int, sys.stdin.readline().rstrip()))
def S():return sys.stdin.readline().rstrip()
def LS():return list(sys.stdin.readline().rstrip().split())
def LS2():return list(sys.stdin.readline().rstrip())

n, l, r, x = MI()

problemset = LI()

print(solve(problemset, l, r, x))",np,"bitmasks,brute force",908
"n,l,r,x = map(int,input().split())
diff = list(map(int,input().split()))

ans = 0
currSum = 0
maxim = 0
minim = 0

for i in range(2**n):

    currSum = 0
    maxim = 0
    minim = 1000001
    ptr = n-1
    
    while i > 0:

        if i & 1:

            currSum += diff[ptr]
            maxim = max(maxim,diff[ptr])
            minim = min(minim,diff[ptr])

        ptr -= 1
        i = i >> 1

    if currSum <= r and currSum >= l:

        if maxim - minim >= x:

            ans += 1

print(ans)
        

        
    
",np,"bitmasks,brute force",525
"from itertools import combinations
n,l,r,x = map(int,input().split())
a = list(map(int,input().split()))
ans = 0
for i in range(2,n+1):
    for j in combinations(a,i):
        if max(j)-min(j)>=x and l<=sum(j)<=r:
            ans+=1
print(ans)
        
",np,"bitmasks,brute force",253
"# B. Preparing Olympiad

def check_combination(v):
    sm = sum(v)
    if l <= sm <= r:
        if max(v) - min(v) >= x:
            global ans
            ans += 1


def go(offset, k):
    # https://stackoverflow.com/questions/12991758/creating-all-possible-k-combinations-of-n-items-in-c/28698654
    if k == 0:
        check_combination(combination)
        return
    for i in range(offset, len(problems) - k + 1):
        combination.append(problems[i])
        go(i+1, k-1)
        combination.pop()


n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

problems = list()
combination = list()

ans = 0

for i in range(2, len(c) + 1):
    problems = c.copy()
    go(0, i)

print(ans)
",np,"bitmasks,brute force",713
"n,l,r,x = map(int,input().split())
nums = sorted(list(map(int,input().split())))
ans = 0
def recurse(i,sum, dif, cnt):
    global ans
    if i == n:
        if not cnt:
            return
        if sum>=l and sum <= r and abs(cnt[-1]-cnt[0]) >=x:
            ans += 1
        return
    recurse(i+1,sum,dif,cnt[:])
    cnt.append(nums[i])
    recurse(i+1,sum+nums[i],dif,cnt[:])
recurse(0,0,0,[])
print(ans)",np,"bitmasks,brute force",408
"# from math import *
from itertools import combinations
from sys import stdin
input = stdin.readline
intin = lambda: map(int, input().split())

n, l, r, x = intin()
*a, = intin()
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np,"bitmasks,brute force",294
"n,l,r,x = map(int,input().split())
a = list(map(int,input().split()))
ans = 0
for i in range(1,(2**n)+1):
    j = bin(i)
    j = j[2:]
    if len(j)<n:
        j = '0'*(n-len(j))+j
    #print(j)
    c = 0
    temp = []
    for k in j:
        if k=='1':
            temp.append(a[c])
        c+=1
    s = sum(temp)
    #print(s)
    if len(temp)>=2 and s>=l and s<=r and (max(temp)-min(temp))>=x:
        ans+=1
    #print(ans)
    #print()
    #print(j)
print(ans)",np,"bitmasks,brute force",465
"c = 0
def backtracking(actuales,restantes,l,r,x):
    global c
    if sum(actuales)<=r and sum(actuales) >= l:
        if max(actuales)- min(actuales) >= x:
            c += 1
    if restantes:
        for i in range(len(restantes)):
            backtracking(actuales+[restantes[i]], restantes[i+1:],l,r,x)
    return 0
def main():
    n,l,r,x = input().split("" "")
    n,l,r,x = int(n), int(l), int(r), int(x)
    difficulties = input().split("" "")
    for i in range(len(difficulties)):
        difficulties[i] = int(difficulties[i])
    difficulties.sort()
    backtracking([],difficulties,l,r,x) 
    global c     
    return c
 
if __name__ == ""__main__"":
    print(main())",np,"bitmasks,brute force",676
"from collections import *
from itertools import *
from random import  *
from bisect import *
from string import *
from queue import *
from heapq import *
from math import *
from sys import *
from re import *
def fast(): return stdin.readline().strip()
def zzz(): return [int(i) for i in fast().split()]


z, zz = input, lambda: list(map(int, z().split()))
szz, graph, mod, szzz = lambda: sorted(
    zz()), {}, 10**9 + 7, lambda: sorted(zzz())


def lcd(xnum1, xnum2): return (xnum1 * xnum2 // gcd(xnum1, xnum2))
def output(answer): stdout.write(str(answer))


dx = [-1, 1, 0, 0, 1, -1, 1, -1]
dy = [0, 0, 1, -1, 1, -1, -1, 1]


###########################---Test-Case---#################################
""""""
 If you Know me , Then you probably don't know me !
""""""
###########################---START-CODING---##############################


n,l,r,x = zzz()
arr = zzz()
cnt=0
for i in range(2,2**n):
    b = bin(i)[2:]
    b='0'*(n-len(b))+b
    s,mx,mi =0, float('-inf'),float('inf')
    for j in range(n):
        if b[j]=='1':
            mx=max(mx,arr[j])
            mi=min(mi,arr[j])
            s+=arr[j]
    if s>=l and s<=r and mx-mi>=x:
        cnt+=1
print(cnt)
",np,"bitmasks,brute force",1174
"import sys;input=sys.stdin.readline
# from itertools import accumulate
# from decimal import *
# import math
# getcontext().prec = 50
# s = input().strip()
# n = int(input())
# lis = list(map(int,input().split()))
# x,y = map(int,input().split())
# chars = 'abcdefghijklmnopqrstuvwxyz'

# def gcd(a,b):
#     return gcd (b, a % b) if b else a
        
def solve():
    n, l, r, x = map(int,input().split())
    lis = list(map(int,input().split()))
    lis = sorted(lis)
    dp = [0]
    dp_low = [0]
    dp_high = [0]
    for i in range(len(lis)):
        for j in range(len(dp)):
            if dp_low[j]==0:
                dp_low.append(lis[i])
            else: 
                dp_low.append(dp_low[j])
            dp_high.append(lis[i])
            dp = dp+[dp[j]+lis[i]]
    count = 0
    for i in range(len(dp)):
        if dp[i]>=l and dp[i]<=r and dp_high[i]-dp_low[i]>=x:
            count+=1
    print(count)
    
    
solve()
# for _ in range(int(input())):
#     solve()    ",np,"bitmasks,brute force",988
"from itertools import chain, combinations
from random import randint
def powerset(iterable):
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

n,l,r,x=map(int,input().split())
ll=list(map(int,input().split()))
subsets=powerset(ll)
res=0
for i in subsets:
    if len(i) >= 2 and l<= sum(i) <=r and max(i)-min(i) >= x:
        res+=1
print(res)
",np,"bitmasks,brute force",393
"from itertools import combinations
num,min_dif,max_dif,easy_hard_dif=map(int, input().split("" ""))
arr=[int(m) for m in input().split("" "")]
all_combinations=[]
for x in range(2, num+1):
    combs=combinations(arr, x)
    for abc in combs:
        all_combinations.append(list(abc))
possible_answers=0
for a in all_combinations:
    if sum(a)>=min_dif and sum(a)<=max_dif and max(a)-min(a)>=easy_hard_dif:
        possible_answers+=1
print(possible_answers)",np,"bitmasks,brute force",455
"n,l,r,x=map(int,input().split())
a=list(map(int,input().split()))
count=0
t=0
ans=[]
for i in range(3,(2**n)+1):
    c=i
    ans=[]
    sum=0
    while c!=0:
        c=c&(c-1)
        count+=1
    if count>1:
        for j in range(n):
            if i & (1 << j):
                sum+=a[j]
                ans.append(a[j])
        if l<=sum<=r and (max(ans)-min(ans))>=x:
            t+=1
print(t)
",np,"bitmasks,brute force",399
"n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
c.sort()
ans = 0
for i  in range(2**n):
    s = []
    for j in range(n):
        if i&2**j:
            s.append(c[j])
    if sum(s)>=l and sum(s)<=r and max(s)-min(s)>=x:
        ans+=1

print(ans)        
        ",np,"bitmasks,brute force",286
"n, l, r, x = map(int, input().split())
tasks = [int(i) for i in input().split()]
cnt = 0
for num in range(2 ** n):
    bin_num = bin(num)[2:]
    if len(bin_num) < n:
        bin_num = '0' * (n - len(bin_num)) + bin_num
    m = []
    for i in range(n):
        if bin_num[i] == '1':
            m.append(tasks[i])
    if sum(m) >= l and sum(m) <= r and max(m) - min(m) >= x:
        cnt += 1
print(cnt)",np,"bitmasks,brute force",403
"
def combine(n, k, w=1, out=[], result=[]):
    if k == 0:
        result.append(out)

    for i in range(w, n + 1):
        new_out = out[:]
        new_out.append(i)
        combine(n, k-1, i+1, new_out)

    return result


def main():

    n, l, r, x = [int(i) for i in input().split()]
    c = [int(i) for i in input().split()]

    if n < 2:
        print(0)
        return

    result = None
    for i in range(2, n + 1):
        if i == n:
            result = combine(n, i)
        else:
            combine(n, i)

    for i in range(len(result)):
        comb = result[i]
        for j in range(len(comb)):
            comb[j] = c[comb[j] - 1]

    cnt = 0
    for i in range(len(result)):
        sm = sum(result[i])
        if sm >= l and sm <= r and (max(result[i]) - min(result[i]) >= x):
            cnt += 1

    print(cnt)



if __name__ == '__main__':
    main()


",np,"bitmasks,brute force",883
"n,l,r,x=map(int,input().split())
num=list(map(int,input().split()))
ans=0
for i in range(2**n):
    st=bin(i)[2:]
    st='0'*(n-len(st))+st
    if st.count('1')>=2:
        pt=[]
        for i in range(len(st)):
            if st[i]=='1':
                pt.append(num[i])
        if sum(pt)<=r and sum(pt)>=l and max(pt)-min(pt)>=x:
            ans+=1
print(ans)",np,"bitmasks,brute force",363
"def func():
    count = 0
    for i in range(1 << n):
        temp = []
        for j in range(n):
            if 1 << j & i:
                temp.append(c[j])

        if l <= sum(temp) <= r and temp[-1] - temp[0] >= x:
            count += 1
    print(count)


n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))
c.sort()
func()
",np,"bitmasks,brute force",354
"""""""
Brandt Smith, Lemuel Gorion and Peter Haddad

codeforces.com

Problem 12455
""""""
import sys

def set(mask, pos):
    return mask | (1 << pos)

def isOn(mask, pos):
    return mask & ( 1 << pos) > 0

n, l, r, x = map(int, input().split(' '))
dif = list(map(int, input().split(' ')))

count, mask = 0, 0

while mask <= 2**n:
    summ, bit = [], 0

    while bit < n:
                
        if isOn(mask, bit):
            summ.append(dif[bit])
                    
        bit += 1
        
    if sum(summ) <= r and sum(summ) >= l and max(summ) - min(summ) >= x:
        count += 1
                
    mask += 1
                
                
print(count)

    
    

",np,"bitmasks,brute force",676
"from itertools import combinations
n, l, r, x = map(int,input().split())
a = list(map(int,input().split()))
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))




# Made By Mostafa_Khaled",np,"bitmasks,brute force",252
"I = lambda: map(int, input().split())

n, l, r, x = I()
C, k = [*I()], 0

for i in range(2 ** n):
    W = [w for w, b in zip(C, bin(i)[2:].zfill(n)) if b == '1']
    if l <= sum(W) <= r and max(W) - min(W) >= x:
        k += 1

print(k)",np,"bitmasks,brute force",236
"def subsets(L, i):
    if i == len(L):
        yield []
    else:
        for s in subsets(L, i+1):
            yield s
            yield [L[i]] + s

def computeValidProblemsets(problems, l, r, x):
    isValid = lambda ps: (len(ps) > 1) and (l <= sum(ps) <= r) and (ps[-1]-ps[0] >= x)
    print(sum(isValid(problemset) for problemset in subsets(sorted(problems), 0)))

if __name__ == '__main__':
    n, l, r, x = map(int, input().split())
    problems = list(map(int, input().split()))
    computeValidProblemsets(problems, l, r, x)

",np,"bitmasks,brute force",534
"from itertools import combinations
n,l,r,x=map(int,input().split())
*a,=map(int,input().split())
print(sum([sum([max(j)-min(j)>=x and l<=sum(j)<=r for j in combinations(a,i)])for i in range(2,n+1)]))",np,"bitmasks,brute force",199
"import itertools

n, l, r, x = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]

counter = 0
for i, val in enumerate(["""".join(seq) for seq in itertools.product(""01"", repeat=n)]):
    if val.count('1') < 2:
        continue
    dif = 0; mx = float(""-inf""); mn = float(""inf"")
    for i, bit in enumerate(val):
        if bit == '1':
            dif += c[i]
            mx = max(c[i], mx)
            mn = min(c[i], mn)
    if l <= dif <= r and  mx - mn >= x:
        counter += 1

print(counter)
",np,"bitmasks,brute force",517
"from itertools import combinations
n, l, r, x = map(int,input().split())
c = [*map(int, input().split())]
print(sum([sum([1 if max(j) - min(j) >= x and l <= sum(j) <= r else 0 for j in combinations(c, i)]) for i in range(1, n + 1)]))
",np,"bitmasks,brute force",234
"def subsets(S):
    sets = []
    len_S = len(S)
    for i in range(1 << len_S):
        subset = [S[bit] for bit in range(len_S) if i & (1 << bit)]
        sets.append(subset)
    return sets
    
n, l, r, x = list(map(int, input().split()))
problems = list(map(int, input().split()))
res = 0
for m in subsets(problems):
    if l <= sum(m) <= r and (max(m) - min(m)) >= x:
        res += 1
print(res)",np,"bitmasks,brute force",401
"n, l, r, x = map(int, input().split())
arr = list(map(int, input().split()))
res = 0
for j in range(1, 2**n):
    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]
    res += (max(a) - min(a) >= x and sum(a) >= l and sum(a) <= r)
print(res)
",np,"bitmasks,brute force",247
"n, l, r, x = map(int, input().split())
arr = list(map(int, input().split()))
res = 0
for j in range(1, 2**n):
    a = [arr[i] for i in range(n) if (((j >> i) & 1) == 1)]
    s = sum(a)
    res += (max(a) - min(a) >= x and s >= l and s <= r)
print(res)
",np,"bitmasks,brute force",252
"


from itertools import combinations

[n,l,r,x] = [int(x) for x in input().split()]
c = [int(x) for x in input().split()]
c.sort()
k = 0

from itertools import combinations

for i in range(n) :
	for j in range(i+1,n) :
		if ( c[j] - c[i] ) >= x :
			if sum(c[i:j+1]) < l :
				continue
			elif  (c[i] + c[j]) > r :
				continue
			else :
				if (c[i] + c[j]) >= l and (c[i] + c[j]) <= r :
					k += 1
				for p in range(1,j-i) :
					for m in combinations(c[i+1:j],p) :
						if (sum(m)+c[i] +c[j]) >= l and (sum(m)+c[i] +c[j]) <= r :
							k+=1
				
						
						


print(k)


",np,"bitmasks,brute force",580
"n,ll,r,x=map(int,input().split("" ""))
l=list(map(int,input().split("" "")))
subset = []
for i in range(1,(2**n)):
  sub=[]
  for j in range(n):
    if (1<<j)&i>0:
      sub.append(l[j])
  subset.append(sub)
c=0
# print(*subset,sep=""\n"")
for i in subset:
  if len(i)>1:
    su=sum(i)
    if (su>=ll and su<=r) and ((max(i)-min(i))>=x):
      c+=1
print(c)",np,"bitmasks,brute force",351
"def gen(n):
    if n == 1:
        yield '0'
        yield '1'
    else:
        for s in gen(n - 1):
            yield s+'0'
            yield s +'1'


n, l, r, x = map(int, input().split())
cnt = 0
C = list(map(int, input().split()))
for pos in gen(n):
    A = []
    for i in range(n):
        if pos[i] == '1':
            A.append(C[i])
    A.sort()
    if len(A):
        if l <= sum(A) <= r and A[-1] - A[0] >= x:
            cnt += 1
print(cnt)
",np,"bitmasks,brute force",453
"# -*- coding: utf-8 -*-
""""""
Created on Sun May 26 12:02:26 2019

@author: avina
""""""

N,L,H,d = map(int, input().split())

l = list(map(int, input().split()))
e = 0
for i in range(1 << N ):
    k = []
    for j in range(N):
        if i >> j & 1:
            k.append(l[j])
    if len(k)>0:
        maz = max(k)
        mins = min(k)
        sums = sum(k)
        if sums >= L and sums <=H:
            if maz - mins >=d:
                e+=1
print(e)",np,"bitmasks,brute force",450
"def isValid(arr, l, r, x):
	return l <= sum(arr) <= r and max(arr)-min(arr) >= x

n, l, r, x = map(int, input().strip().split())
arr = list(map(int, input().strip().split()))
valid = 0

for i in range(1, 1<<n):
	s = str(bin(i))[2:].rjust(n, '0')
	temp = []
	for j in range(n):
		if s[j] == '1':
			temp.append(arr[j])
	if isValid(temp, l, r, x):
		valid += 1
print(valid)",np,"bitmasks,brute force",371
"from itertools import combinations
n, mn, mx, diff = map(int, input().split())
arr = list(map(int, input().split()))
print(sum(sum(1 for x in combinations(arr, i) if sum(x)>= mn and sum(x) <= mx and max(x)-min(x)>=diff) for i in range(2, n+1)))

",np,"bitmasks,brute force",246
"n, l, r, x = map(int, input().split())
d = list(map(int, input().split()))
ans = 0
for i in range(pow(2, n)-1, -1, -1):
	s = bin(i)[2:]
	while(len(s) < n):
		s = ""0""+s
	diff = 0
	t = []
	for j in range(n):
		if(s[j]=='1'):
			diff += d[j]
			t.append(d[j])
	t.sort()
	# print(s, t)
	if(l <= diff <= r and t[-1]-t[0] >= x):
		ans += 1
print(ans)",np,"bitmasks,brute force",344
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

ans = 0

for mask in range(2**n):
    cnt, csum = 0, 0
    mn, mx = 10**18, -(10**18)
    for i in range(n):
        if (mask & (1 << i) != 0):
            cnt += 1
            csum += c[i]
            mn = min(mn, c[i])
            mx = max(mx, c[i])
    if (cnt >= 2) and (csum >= l) and (csum <= r) and (mx - mn >= x):
        ans += 1
        
print(ans)
    ",np,"bitmasks,brute force",439
"n, l, r, x = list(map(int, input().split()))
s = list(map(int, input().split()))
olmps = []
c = []
v = 0
for i in range(1<<n):
    olmps.append([])
    for j in range(n):
        if i & (1<<j):
            olmps[-1].append(s[j])
for o in olmps:
    if l <= sum(o) <= r:
        c.append(o)
for z in c:
    if max(z) - min(z) >= x:
        v+=1
print(v)
",np,"bitmasks,brute force",353
"[n, l, r, x] = list(map(int, input().strip().split()))
Cs = list(sorted(map(int, input().strip().split())))
probs = 0

for i in range(1, 2**n):
    currsub = [ Cs[j] for j in range(n) if (i & (1 << j))]
    probs += (len(currsub) > 1 and l <= sum(currsub) <= r and currsub[-1] - currsub[0] >= x)
    
print(probs)",np,"bitmasks,brute force",313
"n, l, r, x = list(map(int, input().split("" "")))
c = sorted(list(map(int, input().split("" ""))))
ways = 0

for i in range(0, 2 ** n):
    temp = 0
    m = 10 ** 9 + 1
    M = -1
    for j in range(0, n):
        if i & 1 << j:
            temp += c[j]
            m = min(m, c[j])
            M = max(M, c[j])
    if temp >= l and temp <= r and (M - m) >= x:
        ways += 1

print(ways)


		  	 			       		 	 		   		 	",np,"bitmasks,brute force",420
"kk=lambda:map(int, input().split())
ll=lambda:list(kk())
n,l,r,d=kk()
p,t=ll(),0
for v in range(2**n):
	s = []
	for i in range(n):
		if v&(2**i):
			s.append(p[i])
	if l <= sum(s)<=r and max(s)-min(s) >= d: t+=1
print(t)",np,"bitmasks,brute force",220
"'''input
5 25 35 10
10 10 20 10 20
'''
from sys import stdin, stdout, setrecursionlimit
from collections import deque, defaultdict
from bisect import bisect_left



def check(temp):
	if len(temp) < 2:
		return False
	else:
		s = sum(temp)
		if s >= l and s <= r:
			if temp[-1] - temp[0] >= x:
				return True
			else:
				return False
		else:
			return False
 
def brute(index, temp):
	global count

	if index == n:
		if check(temp):
			count += 1

	else:
		temp.append(arr[index])
		brute(index + 1, temp)
		temp.pop()
		brute(index + 1, temp)


# main starts
n, l, r, x = list(map(int, stdin.readline().split()))
arr = list(map(int, stdin.readline().split()))
arr.sort()
count = 0
temp = []
brute(0, temp)
print(count)
	    							    			 			   		 	",np,"bitmasks,brute force",752
"def check(j):
    if sum(j)>=l and sum(j)<=r and (max(j)-min(j))>=x:
        return 1
    return 0
        

from itertools import combinations
n,l,r,x=list(map(int,input().split()))
c=list(map(int,input().rstrip().split()))
count=0
for i in range(2,n+1):
    a=list(combinations(c,i))
    for j in a:
        
        if check(j):
            count+=1
print(count)
        
    
    
				 	 	 	  	 	   		   			   		",np,"bitmasks,brute force",416
"from itertools import combinations
n, l, r, x = map(int,input().split())
a = list(map(int,input().split()))
print(sum([sum([max(j) - min(j) >= x and l <= sum(j) <= r for j in combinations(a, i)]) for i in range(2, n + 1)]))",np,"bitmasks,brute force",223
"def solve():
    n, l, r, x = map(int, input().split(' '))
    c = list(map(int, input().split(' ')))
    ans = 0
    for bitmask in range(2 ** n):
        if bin(bitmask).count('1') > 1:
            res, _min, _max = 0, float('+inf'), float('-inf')
            for c_i, bit_i in zip(c, (1 & int(bitmask) >> i for i in range(n))):
                if bit_i:
                    res += c_i * bit_i
                    if c_i < _min:
                        _min = c_i
                    if c_i > _max:
                        _max = c_i
            if l <= res <= r and (_max - _min) >= x:
                ans += 1
    print(ans)
            

if __name__ == '__main__':
    solve()",np,"bitmasks,brute force",681
"n,l,r,d=[int(i) for i in input().split()]
op=[int(i) for i in input().split()]
c=0
for i in range(2,2**n):
    s=0
    k=0
    maxx=0
    minn=1000001
    x=bin(i)[2:]
    x='0'*(n-len(x))+x
    for j in range(n):
        if x[j]=='1':
            s+=op[j]
            k+=1
            if maxx<op[j]:
                maxx=op[j]
            if op[j]<minn:
                minn=op[j]
    if l<=s<=r and maxx-minn>=d and k>=2:
        c+=1
print(c)",np,"bitmasks,brute force",445
"from itertools import combinations
 
n,l,r,x = map(int,input().split())
a=list(map(int,input().split()))
 
c=[]
for i in range(2,n+1):
	c+=list(combinations(a,i))
 
cnt=0
 
for t in c:
	m=min(t)
	M=max(t)
	s=sum(t)
	if M-m >=x and (s>=l and s<=r):
		cnt+=1
 
print(cnt)",np,"bitmasks,brute force",269
"import sys
def fastio():
    from io import StringIO
    from atexit import register
    global input
    sys.stdin = StringIO(sys.stdin.read())
    input = lambda : sys.stdin.readline().rstrip('\r\n')
    sys.stdout = StringIO()
    register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
fastio()

def debug(*var, sep = ' ', end = '\n'):
    print(*var, file=sys.stderr, end = end, sep = sep)

INF = 10**20
MOD = 10**9 + 7
I = lambda:list(map(int,input().split()))
from math import gcd
from math import ceil
from collections import defaultdict as dd, Counter
from bisect import bisect_left as bl, bisect_right as br

n, l, r, x = I()
a = I()
ans = 0
for i in range(1, 2 ** n):
    if i & (i - 1) == 0:
        continue
    mn, mx, total = INF, -INF, 0
    for j in range(n):
        if (i >> j) & 1:
            mn = min(mn, a[j])
            mx = max(mx, a[j])
            total += a[j]
    if l <= total <= r and mx - mn >= x:
        ans += 1
print(ans)",np,"bitmasks,brute force",965
"import math as mt
import itertools as it
n,l,r,x=map(int,input().split())
a=list(map(int,input().split()))
ans=0
for j in range(2,n+1):
    for i in it.combinations(a,j):
        if max(i)-min(i)>=x and l<=sum(i)<=r:
            ans+=1
print(ans)",np,"bitmasks,brute force",246
"from itertools import chain, combinations
def powerset(iterable):
    xs = list(iterable)
    # note we return an iterator rather than a list
    return list(chain.from_iterable(combinations(xs,n) for n in range(2,len(xs)+1)))
n,l,r,x=map(int,input().split())
sett=list(map(int,input().split()))
psett=powerset(sett)
count=0
for i in psett:
    k=sorted(i)
    j=sum(k)    
    if j>=l and j<=r and k[-1]-k[0]>=x:
        count+=1
print(count)


",np,"bitmasks,brute force",446
"'''
    Author: Ken
    Date: 2020-02-06
    Problems: 550B
'''
import sys

n, l, r, x = map(int, input().split())
temp = []
temp = list(map(int, input().split()))

temp.sort()
ans = 0

for i in range(1 << n):
    score = 0
    _min = sys.maxsize
    _max = -sys.maxsize
    for j in range(n):
        if i & (1 << j) > 0:
            _min = min(_min, temp[j])
            _max = max(_max, temp[j])
            score += temp[j]
    if score >= l and score <= r and _max-_min >= x:
        ans += 1

print(ans)
",np,"bitmasks,brute force",510
"from itertools import *
n,least,highest,x = map(int,input().split())
l = [*map(int,input().split())]
cnt = 0
for i in range(2,n + 1):
    combination = [*map(list,combinations(l,i))]
    for j in range(len(combination)):
        combination[j].sort()
        #print(combination[j])
        total = sum(combination[j])
        if(total >= least and total <= highest and combination[j][-1] - combination[j][0] >= x):
            cnt += 1
print(cnt)",np,"bitmasks,brute force",446
"n, l, r, x = map(int, input().split())
tasks = list(map(int, input().split()))
mask = 3
ans = 0

while (mask < (1 << n)):
    sum_dif = 0
    min_diff = float(""inf"")
    max_diff = -float(""inf"")

    if (mask & (mask-1)):
        for i in range(n):
            if (mask & (1 << i)):
                sum_dif += tasks[i]
                min_diff = min(min_diff, tasks[i])
                max_diff = max(max_diff, tasks[i])
        if (x <= (max_diff - min_diff)) and (l <= sum_dif <= r):
            ans += 1

    mask += 1

print(ans)",np,"bitmasks,brute force",533
"n, l, r, x = map(int, input().split())
C = sorted(list(map(int, input().split())))
ANS = 0
for i in range(2 ** n):
    s = bin(i)[2:]
    s = '0' * (n - len(s)) + s
    L = []
    for j in range(n):
        if s[j] == '1':
            L.append(C[j])
    if len(L) < 2 or not (l <= sum(L) <= r) or L[-1] - L[0] < x:
        continue
    ANS += 1
print(ANS)
",np,"bitmasks,brute force",356
"def I(): return(list(map(int,input().split())))
n,l,r,x=I()
c=I()
l1=list(range(2**n))
ans=0
for j in l1:
	s=0
	num=0
	ma=0
	mi=100000000
	for i in range(n):
		if (j & 1<<i):
			num+=1
			s+=c[i]
			ma=max(c[i],ma)
			mi=min(c[i],mi)

	if s<=r and l<=s and(ma-mi>=x) and num>=2 :
		ans+=1
print(ans)


",np,"bitmasks,brute force",302
"n,l,r,x = map(int,input().split())
a = list(map(int,input().split()))
count=0
for i in range(2**n):
    maxc=-1
    minc=-1
    c=0
    for j in range(n):
        if i>>j&1==1:
            c+=a[j]
            maxc=max(maxc,a[j])
            if minc==-1:
                minc=a[j]
            else:
                minc=min(a[j],minc)
    if c>=l and c<=r and maxc - minc >=x:
        count+=1
print(count)

",np,"bitmasks,brute force",407
"I = lambda: map(int,input().split())
n,l,r,x=I()
C,k=[*I()],0
for i in range(2**n):
    W = [w for w,b in zip(C, bin(i)[2:].zfill(n)) if b=='1']
    
    if l <= sum(W) <= r and max(W)-min(W) >= x:
        k += 1
print(k)",np,"bitmasks,brute force",221
"from itertools import combinations

p, minn, maxn, dif = map(int, input().split())
(*lst,) = map(int, input().split())
c = 0
for i in range(2, p + 2):
    for j in combinations(lst, i):
        if (maxn >= sum(j) >= minn) and (max(j) - min(j) >= dif):
            c += 1
print(c)",np,"bitmasks,brute force",279
"from itertools import combinations

p, minn, maxn, dif = map(int, input().split())
(*lst,) = map(int, input().split())
print(sum([sum([(maxn>=sum(j)>=minn)and((max(j)-min(j))>=dif) for j in combinations(lst,i)]) for i in range(2,p+1)]))
",np,"bitmasks,brute force",237
"import itertools

n, l, r, x = map(int, input().split())
C = list(map(int, input().split()))

ans = 0
for i in range(2, n+1):
  for c in itertools.combinations(C, i):
    d = sum(c)
    if d < l or d > r:
      continue
    if max(c) - min(c) < x:
      continue
    ans += 1

print(ans)",np,"bitmasks,brute force",287
"from itertools import combinations
n, l, r, x = map(int, input().split())
a = [int(x) for x in input().split()]
ans = 0
for i in range(2, n+1):
    for p in combinations(a, i):
        if l<=sum(p)<=r and max(p)-min(p)>=x:
            ans += 1
print(ans)
",np,"bitmasks,brute force",255
"n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
res = 0
for i in range(1 << n):
	Bit = []
	for j in range(n):
		if i & (1 << j):
			Bit.append(c[j])
	if (len(Bit) >= 2) and (l<= sum(Bit) <= r) and (max(Bit) - min(Bit) >= x):
		res+= 1
print(res)",np,"bitmasks,brute force",267
"n,l,r,x = [int(x) for x in input().split("" "")]
arr = [int(x) for x in input().split("" "")]
ans = 0
for i in range(2**n):
	subset = [] 
	for j in range(n): 
		if (i & (1 << j)) != 0: 
			subset.append(arr[j])
	if len(subset)>1:
	    mx = max(subset)
	    mn = min(subset)
	    sm = sum(subset)
	    if l<=sm<=r and mx-mn>=x:
	        ans+=1
print(ans)",np,"bitmasks,brute force",349
"n,l,r,x=map(int,input().split())
import math
z=list(map(int,input().split()))
count=0
for i in range(pow(2,len(z))):
    
    mini=math.inf
    maxa=0
    j=i
    inde=0
    sume=0
    while(j>0):
        
        if(j&1):
            sume+=z[inde]
            maxa=max(maxa,z[inde])
            mini=min(mini,z[inde])
        j=j>>1
        inde+=1

    if(maxa-mini>=x and l<=sume<=r):
        count+=1
    
print(count)
        
        
",np,"bitmasks,brute force",441
"def check_combos(diff,n,size,start,picked,total,l,r,x,combination = []):
    if picked == size:
        if max(combination) - min(combination) >= x and l <= sum(combination) <= r:
            total += 1
    else:
        for i in range(start,n-(size-picked-1)):
            combination.append(diff[i])
            picked += 1
            total = check_combos(diff,n,size,i+1,picked,total,l,r,x,combination)
            picked -= 1
            combination.pop() 
    return total

def prog():
    n,l,r,x = map(int,input().split())
    diff = list(map(int,input().split()))
    suitable_problemsets = 0
    for size in range(1,n+1):
        suitable_problemsets += check_combos(diff,n,size,0,0,0,l,r,x)
    print(suitable_problemsets)
prog()
",np,"bitmasks,brute force",741
"## necessary imports
import sys
input = sys.stdin.readline
from math import ceil, floor, factorial;

# swap_array function
def swaparr(arr, a,b):
    temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp

## gcd function
def gcd(a,b):
    if a == 0:
        return b
    return gcd(b%a, a)

## nCr function efficient using Binomial Cofficient
def nCr(n, k): 
    if(k > n - k): 
        k = n - k 
    res = 1
    for i in range(k): 
        res = res * (n - i) 
        res = res / (i + 1) 
    return int(res) 

## upper bound function code -- such that e in a[:i] e < x;
def upper_bound(a, x, lo=0):
    hi = len(a)
    while lo < hi:
        mid = (lo+hi)//2
        if a[mid] < x:
            lo = mid+1
        else:
            hi = mid
    return lo

## prime factorization
def primefs(n):
    ## if n == 1    ## calculating primes
    primes = {}
    while(n%2 == 0):
        primes[2] = primes.get(2, 0) + 1
        n = n//2
    for i in range(3, int(n**0.5)+2, 2):
        while(n%i == 0):
            primes[i] = primes.get(i, 0) + 1
            n = n//i
    if n > 2:
        primes[n] = primes.get(n, 0) + 1
    ## prime factoriazation of n is stored in dictionary
    ## primes and can be accesed. O(sqrt n)
    return primes

## MODULAR EXPONENTIATION FUNCTION
def power(x, y, p): 
    res = 1
    x = x % p  
    if (x == 0) : 
        return 0
    while (y > 0) : 
        if ((y & 1) == 1) : 
            res = (res * x) % p 
        y = y >> 1      
        x = (x * x) % p 
    return res 

## DISJOINT SET UNINON FUNCTIONS
def swap(a,b):
    temp = a
    a = b
    b = temp
    return a,b

# find function with path compression included (recursive)
# def find(x, link):
#     if link[x] == x:
#         return x
#     link[x] = find(link[x], link);
#     return link[x];

# find function with path compression (ITERATIVE)
def find(x, link):
    p = x;
    while( p != link[p]):
        p = link[p];
    
    while( x != p):
        nex = link[x];
        link[x] = p;
        x = nex;
    return p;


# the union function which makes union(x,y)
# of two nodes x and y
def union(x, y, link, size):
    x = find(x, link)
    y = find(y, link)
    if size[x] < size[y]:
        x,y = swap(x,y)
    if x != y:
        size[x] += size[y]
        link[y] = x

## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANES
def sieve(n): 
    prime = [True for i in range(n+1)] 
    p = 2
    while (p * p <= n): 
        if (prime[p] == True): 
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    return prime

#### PRIME FACTORIZATION IN O(log n) using Sieve ####
MAXN = int(1e6 + 5)
def spf_sieve():
    spf[1] = 1;
    for i in range(2, MAXN):
        spf[i] = i;
    for i in range(4, MAXN, 2):
        spf[i] = 2;
    for i in range(3, ceil(MAXN ** 0.5), 2):
        if spf[i] == i:
            for j in range(i*i, MAXN, i):
                if spf[j] == j:
                    spf[j] = i;
    ## function for storing smallest prime factors (spf) in the array

################## un-comment below 2 lines when using factorization #################
# spf = [0 for i in range(MAXN)]
# spf_sieve() 
def factoriazation(x):
    ret = {};
    while x != 1:
        ret[spf[x]] = ret.get(spf[x], 0) + 1;
        x = x//spf[x]
    return ret
    ## this function is useful for multiple queries only, o/w use
    ## primefs function above. complexity O(log n)

## taking integer array input
def int_array():
    return list(map(int, input().strip().split()))
## taking string array input
def str_array():
    return input().strip().split();

#defining a couple constants
MOD = int(1e9)+7;
CMOD = 998244353;
INF = float('inf'); NINF = -float('inf');

################### ---------------- TEMPLATE ENDS HERE ---------------- ###################

n, l, r, x = int_array(); a = sorted(int_array());
ans = 0;
for mask in range( 1 << n):
    mx = NINF; mn = INF; sub = 0;
    for i in range(n):
        if (1 << i) & mask:
            sub += a[i];
            mx = max(mx, a[i]);
            mn = min(mn, a[i]);
    if sub >= l and sub <= r:
        if mx - mn >= x:
            ans += 1;
print(ans);",np,"bitmasks,brute force",4161
"def find(a,b):
    cc=2
    for i in range(1,(1<<len(a))):
        sx=0
        minn=100000000
        maxn=-1
        for j in range(0,len(a)):
            if(i &(1<<j)):
                sx+= a[j];
                minn = min(minn, a[j])
                maxn = max(maxn, a[j])
        if(sx>=b[1] and sx<=b[2] and (maxn-minn)>=b[3]):
            cc+=1
    if(cc<2):
        return 2
    else:
        return cc-2





b=list(map(int,input().split()))
a=list(map(int,input().split()))
print(find(a,b))
",np,"bitmasks,brute force",501
"from itertools import combinations
n , l , r ,x = map(int,input().split())
a = list(map(int, input().split()))
c = 0
for i in range(1,n+1):
    for j in combinations(a,i):
        if (l<=sum(j)<=r and max(j)-min(j)>=x):
            c+=1
print(c)",np,"bitmasks,brute force",245
"from itertools import combinations
 
n, l, r, x = map(int, input().split())
(*a,) = map(int, input().split())
sumu = 0
for i in range(2, n + 2):
    for j in combinations(a, i):
        if (r >= sum(j) >= l) and (max(j) - min(j) >= x):
            sumu += 1
print(sumu)
	 		      	 	  		   	  		 	 	",np,"bitmasks,brute force",299
"from itertools import combinations

n, l, r, x = map(int, input().split())
a = list(map(int, input().split()))

arr = []

for i in range(2, n+1):
    ar = combinations(a, i)
    for j in ar:
        arr += [(list(j))]

count = 0
for i in arr:
    dif = max(i) - min(i)
    total = sum(i)
    if dif >= x and (total >= l and total <= r):
        count +=1

print(count)
",np,"bitmasks,brute force",369
"def combinations(arr,n):
    if(n==0):
        return([[]])
    l=[]
    for i in range(len(arr)):
        m=arr[i]
        rem=arr[i+1:]
        for j in combinations(rem,n-1):
            l.append([m]+j)
    return l

        
def solve(arr,n,l,r,x):
    subset=[]
    for i in range(2,n+1):
        for j in combinations(arr,i):
            if(sum(j)>=l and sum(j)<=r):
                subset.append(j)
    count=0
    for i in subset:
        mn=min(i)
        mx=max(i)
        if(mx-mn>=x):
            count+=1
                
    return(count)
            
n,l,r,x=map(int,input().split())
arr=list(map(int,input().split()))
print(solve(arr,n,l,r,x))
",np,"bitmasks,brute force",660
"def GSB(x):
	counter=0
	while x!=0:
		counter+=1
		x=x>>1
	return counter
	
problems,minimum,maximum,difference=[int(x) for x in input().split()]
array=[int(x) for x in input().split()]
combinations=[int(x) for x in range(2**problems)]
total=0

for i in combinations:
	checker=[x for x in array]+['a']
	j=0
	z=GSB(i)
	check=1
	while j!=z and i!=0:
		if i&1==1:
			checker[j]='a'
			check+=1
		i=i>>1
		j+=1
	for i in range(check):
		checker.remove('a')
	checker.sort()
	if minimum<=sum(checker)<=maximum and len(checker)>=2 and checker[-1]-checker[0]>=difference:
		total+=1
print(total)",np,"bitmasks,brute force",587
"# Author: S Mahesh Raju
# Username: maheshraju2020
# Date: 29/07/2020

from sys import stdin,stdout
from math import gcd, ceil, sqrt
from itertools import combinations
from collections import Counter
from bisect import bisect_left, bisect_right
ii1 = lambda: int(stdin.readline().strip())
is1 = lambda: stdin.readline().strip()
iia = lambda: list(map(int, stdin.readline().strip().split()))
isa = lambda: stdin.readline().strip().split()
mod = 1000000007

n, l, r, x = iia()
arr = iia()
count = 0
for i in range(2, n + 1):
    t = combinations(arr, i)
    for j in t:
        if sum(j) >= l and sum(j) <= r \
            and max(j) - min(j) >= x:
            count += 1
print(count)
    ",np,"bitmasks,brute force",687
"from sys import stdin
from itertools import combinations
n, l, r , x = map(int, stdin.readline().rstrip().split("" ""))
li = list(map(int, stdin.readline().rstrip().split("" "")))
z = []
ans = 0
for i in range(2, n+1):
    z += list(combinations(li, i))

for i in z:
    a = sorted(i)
    if a[-1]-a[0]>=x and r >= sum(a) >= l:
        ans+=1

print(ans)",np,"bitmasks,brute force",350
"import itertools
n,l,r,x=map(int,input().split())
problems=[int(x) for x in input().split()]
result=0
for i in range(2,n+1):
    for comb in itertools.combinations(problems,i):
        summ = sum(comb)
        mini = min(comb)
        maxx = max(comb)
        if l <= summ <=r and maxx-mini>=x:
            result+=1
print(result)

",np,"bitmasks,brute force",332
"n,l,r,x = map(int,input().split())
c = list(map(int,input().split()))
ans = 0

for mask in range(1 << n):
    a = []
    for bit in range(n):
        if mask & (1 << bit):
           a.append(c[bit])
    if len(a) >= 2 and max(a) - min(a) >= x and l <= sum(a) and sum(a) <= r:
        ans += 1
print(ans)        
",np,"bitmasks,brute force",313
"import itertools
n,l,r,x=map(int,input().split())
problems=[int(x) for x in input().split()]
result=0
for i in range(2,n+1):
    for comb in itertools.combinations(problems,i):
        summ = sum(comb)
        mini = min(comb)
        maxx = max(comb)
        if l <= summ <=r and maxx-mini>=x:
            result+=1
print(result)
    		 		 		   	 				 	 		 		 	",np,"bitmasks,brute force",362
"def suma_o_resta(a, b):
	return (a & (1<<b))

def diferencia(s1, d):
	if s1:
		s1.sort()
		#print(*s1, sep="" - "")
		if s1[-1] - s1[0] >= d:
			#print(str(s1[-1]) + "" - "" + str(s1[0]) + "" = "" + str(s1[-1] - s1[0]))
			return s1
		else:
			return diferencia(s1.remove(s1[-1]), d)	
	return s1

def no_sets(v, n, l, r, d):
	s = []
	cont = 0
	for x in range(1<<n):
		for i in range(n):
			#print(""("" + str(x) + "", "" + str(i) + "")"")
			if suma_o_resta(x, i) > 0:
				#print(str(suma_o_resta(x, i)))
				s.append(v[i])
		s = diferencia(s, d)
		if s:
			if sum(s) >= l and sum(s) <= r:
				cont += 1
		s = []
	return cont;
	

n, l, r, x = map(int, input().split())

v = list(map(int, input().split()))

print(str(no_sets(v, n, l, r, x)))


				 			  				   	  	 		 	",np,"bitmasks,brute force",758
"def isValidSet(problemSet: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> bool:
    if len(problemSet) >= 2:
        total = sum(problemSet)
        myDelta = max(problemSet) - min(problemSet)
        if minTotalDif <= total <= maxTotalDif and myDelta >= minDelta:
            return True
    return False

def countValidSubsets(problems: list, minTotalDif: int, maxTotalDif: int, minDelta: int) -> int:
    
    def subsetBuilder (problems: list, currentSubset: list, nextElementIndex: int) -> None:
        if isValidSet(currentSubset, minTotalDif, maxTotalDif, minDelta):
            validSubsets.append(currentSubset)
        for i in range(nextElementIndex, len(problems)):
            currentSubset.append(problems[i])
            subsetBuilder(problems, currentSubset, i+1)
            currentSubset.pop(-1)
    
    index = 0
    currentSubset = []
    validSubsets = []

    subsetBuilder(problems, currentSubset, index)
    return len(validSubsets)

n, l, r, x = input().split()
n = int(n)
l = int(l)
r = int(r)
x = int(x)

probs = [int(prob) for prob in input().split()]

print(countValidSubsets(probs, l, r, x))


		  		 	 			 	  	  	 	 		 	 	",np,"bitmasks,brute force",1168
"n, l, r, x = map(int, input().split())
c = list(map(int, input().split()))

from itertools import combinations
ways_to_choose = 0
for length in range(2, n + 1):
    for p in combinations(c, length):
        problemset = sorted(p)
        if l <= sum(problemset) <= r and problemset[-1] - problemset[0] >= x:
            ways_to_choose += 1

print(ways_to_choose)
",np,"bitmasks,brute force",363
"from itertools import combinations as cmb
n ,l ,r ,x = map(int , input().split())
*a , = map(int ,input().split())
b = []
a.sort()
for i in range(2 ,n+1):
    b.extend(cmb(a ,i))
ans = 0
for i in b:
    # i1 = sorted(i)
    if(sum(i) >= l and sum(i) <= r):
        if(i[-1]-i[0] >= x):
            # print(i)
            ans+=1
            
print(ans)",np,"bitmasks,brute force",351
"#_______________________________________________________________#
def fact(x):
	if x == 0:
		return 1
	else:
		return x * fact(x-1)
def lower_bound(li, num): 
	answer = -1
	start = 0
	end = len(li)-1

	while(start <= end):
		middle = (end+start)//2
		if li[middle] >= num:
			answer = middle
			end = middle - 1
		else:
			start = middle + 1
	return answer #index where x is not less than num
def upper_bound(li, num): 
	answer = -1
	start = 0
	end = len(li)-1

	while(start <= end):
		middle = (end+start)//2

		if li[middle] <= num:
			answer = middle
			start = middle + 1
		
		else:
			end = middle - 1
	return answer #index where x is not greater than num

def abs(x):
	return x if x >=0 else -x
def binary_search(li, val, lb, ub): 
	ans = 0
	while(lb <= ub):
		mid = (lb+ub)//2
		#print(mid, li[mid])
		if li[mid] > val:
			ub = mid-1
		elif val > li[mid]:
			lb = mid + 1
		else:
			ans = 1
			break
	return ans
def kadane(x): #maximum sum contiguous subarray
	sum_so_far = 0
	current_sum = 0
	for i in x:
		current_sum += i
		if current_sum < 0:
			current_sum = 0
		else:
			sum_so_far = mpos(sum_so_far,current_sum)
	return sum_so_far
def pref(li):
	pref_sum = [0]
	for i in li:
		pref_sum.append(pref_sum[-1] + i)
	return pref_sum
def graph(n,m):
	adj = dict()
	for i in range(1,n+1):
		adj.setdefault(i,0)
	for i in range(m):
		a,b = map(int,input().split())
		adj[a] += 1
		adj[b] += 1
	return adj

#_______________________________________________________________#
'''
      ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄
   ▄███████▀▀▀▀▀▀███████▄
░▐████▀▒▒Aestroix▒▒▀██████
░███▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀████
░▐██▒▒▒▒▒KARMANYA▒▒▒▒▒▒████▌         ________________
░▐█▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒████▌  ? ?   |▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒|
░░█▒▒▄▀▀▀▀▀▄▒▒▄▀▀▀▀▀▄▒▒▐███▌   ?    |___CM ONE DAY___|
░░░▐░░░▄▄░░▌▐░░░▄▄░░▌▒▐███▌     ? ? |▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒|
░▄▀▌░░░▀▀░░▌▐░░░▀▀░░▌▒▀▒█▌    ? ?    
░▌▒▀▄░░░░▄▀▒▒▀▄░░░▄▀▒▒▄▀▒▌      ? 
░▀▄▐▒▀▀▀▀▒▒▒▒▒▒▀▀▀▒▒▒▒▒▒█     ? ? 
░░░▀▌▒▄██▄▄▄▄████▄▒▒▒▒█▀       ? 
░░░░▄█████████ ████=========█▒▒▐▌
░░░▀███▀▀████▀█████▀▒▌
░░░░░▌▒▒▒▄▒▒▒▄▒▒▒▒▒▒▐
░░░░░▌▒▒▒▒▀▀▀▒▒▒▒▒▒▒▐
░░░░░████████████████
'''
import sys
import threading
from math import *
#sys.setrecursionlimit(900000)
#threading.stack_size(10**5)  # remember it cause mle
#def main():
#for _ in range(int(input())):
for _ in range(1):
	#n = int(input())
	n,l,r,x = map(int,input().split())
	#n, s = input().split()
	#s = list(input())
	#a = [int(x) for x in s]
	#s = list(input())
	a = list(map(int,input().split()))
	#b = list(map(int,input().split()))
	#adj = graph(n,m)
	
	cnt = 0
	for mask in range(1,(1<<n)+1):
		mini = 10**9 + 10
		maxi = 0
		elem = 0
		sumi = 0
		for j in range(n):
			if mask & (1<<j): #if the bitmask array element is 1
				elem += 1
				sumi += a[j]
				mini = min(mini, a[j])
				maxi = max(maxi, a[j])
		#print(elem,sumi,maxi,mini,bin(mask))
		if elem >= 2:
			if (l <= sumi <= r) and (maxi-mini >= x):
				cnt += 1
	print(cnt)



















































'''		
t = threading.Thread(target=main)
t.start()
t.join()
'''









	




",np,"bitmasks,brute force",3020
"n,l,r,x = map(int,input().split())
A = list(map(int,input().split()))
count = 0
for i in range(1<<n):
    total = 0
    mn = 1e6
    mx = -1e6
    for k in range(n):
        if (i & (1<<k)):
            total += A[k]
            mn = min(A[k],mn)
            mx = max(A[k],mx)
    if total<=r and total>=l and mx-mn>=x:
        count += 1
print(count)",np,"bitmasks,brute force",351
"
import itertools

n , l , r , x = map(int,input().split())

problems = list(map(int,input().split()))

ans = 0

for i in range(2 , n + 1 ):
    for j in itertools.combinations(problems ,i):
        if (l <= sum(j) <= r and max(j) - min(j) >= x):
            ans +=1

print(ans)


",np,"bitmasks,brute force",281
"n,l,r,x = [int(x) for x in input().split()]

a = [int(x) for x in input().split()]

cnt =0

for i in range(0,1<<n):

  sum=0;mn=int(1e18);mx=0;

  for j in range(0,n):

    if((i>>j)&1):
      sum += a[j]
      mn = min(mn,a[j])
      mx = max(mx,a[j])
    
  if (sum>=l and sum<=r and (mx-mn)>=x):
      cnt +=1


print(cnt)",np,"bitmasks,brute force",325
"'''
n problems 

at least two problems
the dificulty must be at least l and at most r
the diference between the easeiest and the hardest is at lease x
'''
#Input
n,least,most,x = map(int,input().split())
c = list(map(int,input().split()))
#calculation
ans= 0
_max = lambda x,y: x if x>y else y
_min = lambda x,y: x if x<y else y

for mask in range(1<<n):
    mx = float('-inf')
    mn = float('inf')
    count = 0
    Sum = 0
    for i in range(n):
        if mask&(1<<i):
            count+=1
            Sum+=c[i]
            mx = _max(mx,c[i])
            mn = _min(mn,c[i])
    if mx-mn>=x and Sum>=least and Sum<=most and count >=2:
        ans+=1
print(ans)

",np,"bitmasks,brute force",665
"n,l,r,x=map(int,input().split())
c=list(map(int,input().split()))
c.sort()
p=1<<n
cnt=0 #no. of ways
for j in range(p):
    list1=[]
    if(j>0 and j&(j-1)!=0):
        for k in range(n):
            if(j&(1<<k)):
                list1.append(c[k])
        if(sum(list1)>=l and sum(list1)<=r and list1[-1]-list1[0]>=x):
            cnt+=1
print(cnt)",np,"bitmasks,brute force",349
"import sys
from array import array  # noqa: F401
import typing as Tp  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def output(*args):
    sys.stdout.buffer.write(
        ('\n'.join(map(str, args)) + '\n').encode('utf-8')
    )


def main():
    n, m, k = map(int, input().split())
    a = list(map(float, input().split()))
    add = [[0] * n for _ in range(n + 1)]
    for xi, yi, ci in (map(int, input().split()) for _ in range(k)):
        add[xi - 1][yi - 1] = float(ci)

    minf = float('-inf')
    dp = [[minf] * (2**n) for _ in range(n + 1)]
    dp[n][0] = 0.0

    for bitset in range(2**n):
        if bin(bitset).count('1') >= m:
            continue

        for i in range(n + 1):
            if dp[i][bitset] == minf:
                continue
            for j in range(n):
                if (1 << j) & bitset:
                    continue
                dp[j][bitset | (1 << j)] = max(
                    dp[j][bitset | (1 << j)],
                    dp[i][bitset] + a[j] + add[i][j]
                )

    print(int(max(max(_dp) for _dp in dp) + 1e-7))


if __name__ == '__main__':
    main()
",np,"bitmasks,dp",1152
"import os
import sys
from io import BytesIO,IOBase

def main():
    n,m,k = map(int,input().split())
    a = list(map(float,input().split()))
    tree = [[0]*n for _ in range(n)]
    for i in range(k):
        x,y,z = map(int,input().split())
        tree[x-1][y-1] = float(z)
    po = [1]
    while len(po) != n:
        po.append(po[-1]*2)
    dp = [[0]*(po[-1]*2) for _ in range(n)]
    for i in range(n):
        dp[i][po[i]] = a[i]
    for i in range(po[-1]*2):
        for j in range(n):
            if i&po[j]:
                for k in range(n):
                    if not (i&po[k]):
                        dp[k][i+po[k]] = max(dp[k][i+po[k]],dp[j][i]+a[k]+tree[j][k])
    ma = 0
    for i in range(po[-1]*2):
        if bin(i)[2:].count(""1"") == m:
            for j in range(n):
                ma = max(ma,dp[j][i])
    print(int(ma))

# region fastio
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self,file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd,max(os.fstat(self._fd).st_size,BUFSIZE))
            self.newlines = b.count(b""\n"")+(not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0,2),self.buffer.write(b),self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd,self.buffer.getvalue())
            self.buffer.truncate(0),self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self,file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s:self.buffer.write(s.encode(""ascii""))
        self.read = lambda:self.buffer.read().decode(""ascii"")
        self.readline = lambda:self.buffer.readline().decode(""ascii"")

sys.stdin,sys.stdout = IOWrapper(sys.stdin),IOWrapper(sys.stdout)
input = lambda:sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",np,"bitmasks,dp",2526
"a,b,c,d,e,f=list(map(int,input().split()))
n,n2=1,a*b+c*d+e*f
while n**2<n2:
    n+=1
if n**2>n2:
    print(-1)
    exit()
l=sorted([[max(a,b),min(a,b),'A'],[max(c,d),min(d,c),'B'],[max(e,f),min(e,f),'C']])
if l[2][0]!=n:
    print(-1)
    exit(0)
v=str(n)+'\n'+(l[2][2]*n+'\n')*l[2][1]
if l[0][0]==n and l[1][0]==n:
    for i in range(2):
        v+=(l[i][2]*n+'\n')*l[i][1]
else:
    s=n-l[2][1]
    if s not in l[0] or s not in l[1]:
        print(-1)
        exit()
    if s!=l[0][0]:
        l[0][0],l[0][1]=l[0][1],l[0][0]
    if s!=l[1][0]:
        l[1][0],l[1][1]=l[1][1],l[1][0]
    v+=(l[0][2]*l[0][1]+l[1][2]*l[1][1]+'\n')*s
print(v)
",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",645
"#------------------------template--------------------------#
import os
import sys
from math import *
from collections import *
# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()


def ok(a,b,c):

    # print(a[0],b,c)

    n = a[0][-1]
    ans = []
    for i in range(a[0][0]): ans.append([a[1]]*n)

    l = n
    r = n - a[0][0]

    for i in range(2):
        for j in range(2):

            l1,r1 = b[0]
            l2,r2 = c[0]

            if(i): l1,r1 = r1,l1
            if(j): l2,r2 = r2,l2

            if(l1 == l):
                if(l2 != l or r1 + r2 != r): continue

                for k in range(r1): ans.append([b[1]]*n)
                for k in range(r2): ans.append([c[1]]*n)
                return ans


            if(l1 == r):
                if(l2 != r or r1 + r2 != l): continue

                for k in range(r): ans.append( [b[1]]*r1 + [c[1]]*r2)
                return ans

    return False


l1,r1,l2,r2,l3,r3 = value()

a = [sorted((l1,r1)),'A']
b = [sorted((l2,r2)),'B']
c = [sorted((l3,r3)),'C']

A = ok(a,b,c)
B = ok(b,a,c)
C = ok(c,a,b)

if(A):
    print(len(A))
    for i in A: print(*i,sep="""")
elif(B): 
    print(len(B))
    for i in B: print(*i,sep="""")
elif(C):
    print(len(C))
    for i in C: print(*i,sep="""")
else: 
    print(-1)






















",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",3452
"def possible(arr):
    # 4 possible cases

    a,b,c,d,e,f = arr
    if(a == c == e and b + d + f == a):
        one = ""A"" * b + ""B"" * d + ""C"" * f
        print(a)
        for i in range(a):
            print(one)
        return True
    if(b == d == f and a + c + e == d):
        print(b)
        for i in range(a):
            print(""A"" * b)
        for i in range(c):
            print(""B"" * b)
        for i in range(e):
            print(""C"" * b) 
        return True
    ns = [(a,b,""A""),(c,d,""B""),(e,f,""C"")]
    fs = [(b, a,""A""),(d, c,""B""),(f, e,""C"")]
    ns.sort(reverse = True)
    x,y,z = ns
    a,b,t1 = x
    c,d,t2 = y
    e,f,t3 = z
    if(c + e == a and d == f and d + b == a):
        print(a)
        mat = [[""."" for i in range(a)] for j in range(a)]
        for i in range(a):
            for j in range(b):
                mat[i][j] = t1
        for i in range(c):
            for j in range(b, a):
                mat[i][j] = t2
        for  i in range(c, a):
            for j in range(b, a):
                mat[i][j] = t3
        for i in range(a):
            print("""".join(mat[i]))
        return True

    fs.sort(reverse = True)
    x,y,z = fs
    b,a,t1 = x
    d,c,t2 = y
    f,e,t3 = z
    if(d + f == b and c == e and c + a == b):
        print(b)
        mat = [[""."" for i in range(b)] for j in range(b)]
        for i in range(a):
            for j in range(b):
                mat[i][j] =t1
        for i in range(a, b):
            for j in range(d):
                mat[i][j] = t2
        for i in range(a, b):
            for j in range(d, b):
                mat[i][j] = t3
        for i in range(b):
            print("""".join(mat[i]))
        return True
    return False

arr = [int(x) for x in input().split()]
cnt = 0
ok = False
for i in range(8):
    send = [x for x in arr]
    if(i&1):
        send[0], send[1] = send[1], send[0]
    if(i&2):
        send[2], send[3] = send[3], send[2]
    if(i&4):
        send[4], send[5] = send[5], send[4]
    if(possible(send)):
        ok = True
        break
if(not ok):
    print(-1)

",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",2072
"ii=lambda:int(input())
kk=lambda:map(int, input().split())
ll=lambda:list(kk())
 
a,b,c,d,e,f=kk()
al = [a,b,c,d,e,f]
s = sum(al)
area = a*b+c*d+e*f
side = int(area**.5)
if side**2 != area or side not in al:
	print(-1)
	exit()
if al.count(side) == 3:
	# as bs cs
	if s == 4*side:
		rest = [a for a in al if a != side]
		print(side)
		for _ in range(side):
			print("""".join([""A""*rest[0], ""B""*rest[1], ""C""*rest[2]]))
elif al.count(side) > 1:
	print(-1)
else:
	x=al.index(side)
	y=x^1
	res = al[y]
	a,b=min(x,y),max(x,y)
	s1 = ""ABC""[a//2]
	s23 = [s for s in ""ABC"" if s != s1]
	rest = al[:a]+al[b+1:]
	res = side - res
	a,b=[rest[0],rest[1]],[rest[2],rest[3]]
	if not (res in a and res in b):
		print(-1)
		exit()
	o1,o2 = a[a.index(res)^1],b[b.index(res)^1]
	print(side)
	for _ in range(al[y]):
		print(s1*side)
	for _ in range(res):
		print("""".join([s23[0]*o1,s23[1]*o2]))",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",870
"import math
xy = list(map(int,input().split()))
x = [[xy[0],xy[2],xy[4]],[xy[1],xy[3],xy[5]]]
aa = 0
max_ll = 0
for i in range(3):
    aa += x[0][i]*x[1][i]
    max_ll = max(max_ll,x[0][i],x[1][i])

bb = math.sqrt(aa)
# print(bb)
if bb*bb!=aa or max_ll!=bb:
    print(-1)
else:
    bb = int(bb)
    mt = [['']*bb for _ in range(bb)]
    max_l = 0
    chars = ['A','B','C']
    x = [[xy[0],xy[1]],[xy[2],xy[3]],[xy[4],xy[5]]]
    max_lp = -1
    max_li = -1
    ii=0
    oh = []
    for i in x:
        if max(i)>=max_l:
            max_l = max(i)
            max_lp = sum(i)-max(i)
            max_li = ii
        # else:
        #     oh+=[ii]
        ii+=1
    
    max_ls = []
    ii=0
    for i in x:
        if max(i)==max_l:
            max_ls.append(i+[ii])
        else:
            oh+=[ii]
        ii+=1
    if len(max_ls)==3:
        # print('hey')
        # print(max_ls)
        for i in range(max_l):
            for j in range(max_l):
                if i<(max_ls[0][0]+max_ls[0][1]-max_l):
                    mt[i][j] = chars[max_ls[0][2]]
                elif i<(max_ls[0][0]+max_ls[0][1]-max_l + max_ls[1][0]+max_ls[1][1]-max_l):
                    mt[i][j] = chars[max_ls[1][2]]
                else:
                    mt[i][j] = chars[max_ls[2][2]]
    else:
        # print(oh)
        for i in range(max_lp):
            for j in range(max_l):
                mt[i][j] = chars[max_li]
        
        bb = max_l-max_lp
        for i in range(max_lp,max_l):
            for j in range(max_l):
                if j<(sum(x[oh[0]])-bb):
                    mt[i][j] = chars[oh[0]]
                else:
                    mt[i][j] = chars[oh[1]]
    
    print(max_l)
    for j in mt:
        print(''.join(j))
    # print(mt)


# for i in [0,1]:
#     for j in [0,1]:
#         for k in [0,1]:
#             a = x[i][0]+x[j][1]+x[k][2]
#             b = x[1-i][0]+x[1-j][1]+x[1-k][2]
#             if a==b:
",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",1932
"a , b , c , d , e , f = map(int,input().split())
n , n1 = 1 , a * b + c * d + e * f
while n ** 2 < n1 :
    n += 1
if n ** 2 > n1 :
    print(-1)
    exit()
l = sorted([[max(a,b),min(a,b),'A'], [max(c,d),min(c,d),'B'], [max(e,f),min(e,f),'C']])
if l[2][0] != n:
    print(-1)
    exit()
v = str(n) + '\n' + (l[2][2] * n + '\n') * l[2][1]
if l[0][0] == n and l[1][0] == n:
    for i in range(2):
        v += (l[i][2] * n + '\n') * l[i][1]
else:
    s = n - l[2][1]
    if s not in l[0] or s not in l[1] :
        print(-1)
        exit()
    x , y = l[0][1] if s == l[0][0] else l[0][0] , l[1][1] if s == l[1][0] else l[1][0]
    v += (l[0][2] * x + l[1][2] * y + '\n') * s
print(v)",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",682
"a1, a2, b1, b2, c1, c2 = map(int, input().split())
l = max([a1, a2, b1, b2, c1, c2])

if (a1*a2 + b1*b2 + c1*c2 != l**2):
    print(-1)
else:
    if a1 > a2:
        a1, a2 = a2, a1
    if b1 > b2:
        b1, b2 = b2, b1
    if c1 > c2:
        c1, c2 = c2, c1
    
    if a2 == b2 and b2 == c2:
        print(l)
        for i in range(a1):
            print('A'*a2)
        for i in range(b1):
            print('B'*b2)
        for i in range(c1):
            print('C'*c2)
    else:
        ls = [[a1, a2, 'A'], [b1, b2, 'B'], [c1, c2, 'C']]
        
        if b2 == l:
            ls[0], ls[1] = ls[1], ls[0]
        if c2 == l:
            ls[0], ls[2] = ls[2], ls[0]

        valid = True
        if ls[1][0] == ls[2][0]:
            pass
        elif ls[1][1] == ls[2][1]:
            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]
            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]
        elif ls[1][0] == ls[2][1]:
            ls[2][0], ls[2][1] = ls[2][1], ls[2][0]
        elif ls[1][1] == ls[2][0]:
            ls[1][0], ls[1][1] = ls[1][1], ls[1][0]
        else:
            valid = False

        if (ls[1][0] + ls[0][0] != l) or (ls[1][1] + ls[2][1] != l):
            valid = False

        if not valid:
            print(-1)
        else:
            print(l)

            for i in range(ls[0][0]):
                print(ls[0][2] * l)
            for i in range(ls[1][0]):
                print(ls[1][2] * ls[1][1] + ls[2][2] * ls[2][1])
",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",1453
"from sys import stdin
from itertools import permutations

rints = lambda: [int(x) for x in stdin.readline().split()]
x1, y1, x2, y2, x3, y3 = rints()

for x in [[x1, y1], [y1, x1]]:
    for y in [[x2, y2], [y2, x2]]:
        for z in [[x3, y3], [y3, x3]]:
            if x[1] == y[1] == z[1] and x[0] + y[0] + z[0] == x[1]:
                print(x[1])
                print('\n'.join(
                    ['A' * x[1] for _ in range(x[0])] + ['B' * x[1] for _ in range(y[0])] + ['C' * z[1] for _ in
                                                                                             range(z[0])]))
                exit()

for per in permutations([[[x1, y1], [y1, x1], 'A'], [[x2, y2], [y2, x2], 'B'], [[x3, y3], [y3, x3], 'C']], 3):
    for x in per[0][:-1]:
        for y in per[1][:-1]:
            for z in per[2][:-1]:
                if x[1] == (y[1] + z[1]) and y[0] == z[0] and x[1] == x[0] + y[0]:
                    print(x[1])
                    print('\n'.join(
                        [per[0][-1] * x[1] for _ in range(x[0])] + [per[1][-1] * y[1] + per[2][-1] * z[1] for _ in
                                                                    range(y[0])]))
                    exit()

print(-1)
",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",1219
"x1, y1, x2, y2, x3, y3 = map(int, input().split())
rect1 = [x1, y1]
rect2 = [x2, y2]
rect3 = [x3, y3]
def func():
    rect11 = [x1, y1]
    rect22 = [x2, y2]
    rect33 = [x3, y3]
    rect1 = [x1, y1]
    rect2 = [x2, y2]
    rect3 = [x3, y3]

    recta = [x1, y1]
    rectb = [x2, y2]
    rectc = [x3, y3]
    for i in rect11:
        for ii in rect22:
            for iii in rect33:
                if i==ii:
                    rect1.remove(i)
                    rect2.remove(ii)
                    if rect1[0]+rect2[0]==iii:
                        rect3.remove(iii)
                        if i+rect3[0]==iii:
                            print(iii)
                            for j in range(iii):
                                if j<rect1[0]:
                                    print(""C""*rect3[0]+""A""*i)
                                else:
                                    print(""C""*rect3[0]+""B""*ii)
                            exit()
                rect1=recta.copy()
                rect2=rectb.copy()
                rect3=rectc.copy()

                if i==iii:
                    rect1.remove(i)
                    rect3.remove(iii)
                    if rect1[0]+rect3[0]==ii:
                        rect2.remove(ii)
                        if i+rect2[0]==ii:
                            print(ii)

                            for j in range(ii):
                                if j<rect1[0]:
                                    print(""B""*rect2[0]+""A""*i)
                                else:
                                    print(""B""*rect2[0]+""C""*iii)
                            exit()
                rect1 = recta.copy()
                rect2 = rectb.copy()
                rect3 = rectc.copy()
                if ii==iii:
                    rect2.remove(ii)
                    rect3.remove(iii)
                    if rect2[0]+rect3[0]==i:
                        rect1.remove(i)
                        if i==rect1[0]+ii:
                            print(i)
                            for j in range(i):
                                if j<rect2[0]:
                                    print(""A""*rect1[0]+""B""*ii)
                                else:print(""A""*rect1[0]+""C""*iii)
                            exit()
                rect1=recta.copy()
                rect2=rectb.copy()
                rect3=rectc.copy()
    return print(-1)
for i in rect1:
    for ii in rect2:
        for iii in rect3:
            recta = [x1, y1]
            rectb = [x2, y2]
            rectc = [x3, y3]

            if i==ii==iii:
                rect1.remove(i)
                rect2.remove(i)
                rect3.remove(i)

            if rect1[0]+rect2[0]+rect3[0]==i:
                print(i)
                for j in range(i):
                    print(""A""*rect1[0]+""B""*rect2[0]+""C""*rect3[0])
                exit()
            rect1=recta
            rect2=rectb
            rect3=rectc

func()
",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",2932
"def chnge(last,cap,ini=(0,0)):
    for i in range(ini[1],last[1]):
        fin[i][ini[0]:last[0]] = [cap]*(last[0]-ini[0])

x1,y1,x2,y2,x3,y3 = map(int,input().split())
a = (max(x1,y1),[x1,y1],""A"")
b = (max(x2,y2),[x2,y2],""B"")
c = (max(x3,y3),[x3,y3],""C"")
m = max(a[0],b[0],c[0])
fin = [[""*"" for i in range(m)] for j in range(m)]

if (x1*y1 + x2*y2 + x3*y3)!=m**2:
    print(-1)
else:
    l = sorted([a]+[b]+[c],reverse = True)
    l[0][1].sort(reverse=True)
    chnge(l[0][1],l[0][2])
    ini=[0,l[0][1][1]]
    last = l[1][1]
    if m in [ini[0]+last[0],ini[1]+last[1]] and (ini[0]+last[0]+ini[1]+last[1])<=2*m:
        last = [ini[0]+last[0],ini[1]+last[1]]
    else:
        last = [ini[0] + last[1], ini[1] + last[0]]
    chnge(last,l[1][2],ini)
    chr = l[2][2]
    print(m)
    for i in fin:
        print("""".join(i).replace(""*"",chr))",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",842
"
a, b, c, d, e, f = list(map(int, input().split()))
n, n2 = 1, a * b + c * d + e * f
while n ** 2 < n2:
    n += 1
if n ** 2 > n2:
    print(-1)
    exit()
l = sorted([[max(a, b), min(a, b), 'A'], [max(c, d), min(c, d), 'B'], [max(e, f), min(e, f), 'C']])
if l[2][0] != n:
    print(-1)
    exit()
v = str(n) + '\n' + (l[2][2] * n + '\n') * l[2][1]
if l[0][0] == n and l[1][0] == n:
    for i in range(2):
        v += (l[i][2] * n + '\n') * l[i][1]
else:
    s = n - l[2][1]
    if s not in l[0] or s not in l[1]:
        print(-1)
        exit()
    x, y = l[0][1] if l[0][0] == s else l[0][0], l[1][1] if l[1][0] == s else l[1][0]
    v += (l[0][2] * x + l[1][2] * y + '\n') * s
print(v)",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",690
"a,b,c,d,e,f=map(int,input().split())
if a<b:a,b=b,a
if c<d:c,d=d,c
if e<f:e,f=f,e
sides=[[a,b,'A'],[c,d,'B'],[e,f,'C']]
sides.sort(reverse=True)
c1,c2,c3=sides[0][2],sides[1][2],sides[2][2]
area=a*b+c*d+e*f
if int(area**0.5)**2!=area:
	print(-1)
else:
	l=int(area**0.5)
	if l not in sides[0]:
		print(-1)
	elif l in sides[1] and l in sides[2]:
		print(l)
		for i in range(3):sides[i].remove(l)
		for i in range(3):
			for _ in range(sides[i][0]):
				print([c1,c2,c3][i]*l)
	else:
		r=l-sides[0][1]
		if r in sides[1] and r in sides[2]:
			print(l)
			for i in range(1,3):sides[i].remove(r)
			for _ in range(sides[0][1]):
				print(c1*l)
			for _ in range(r):
				print(c2*sides[1][0]+c3*sides[2][0])
		else:
			print(-1)",np,"bitmasks,brute force,constructive algorithms,geometry,implementation,math",722
"import sys
import bisect
from bisect import bisect_left as lb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()
#sys.setrecursionlimit(10**6)
mod=10**9+7
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)
ans=0
def hnbhai(t):
    n=sb()
    p=[]
    for i in range(n):
        p.append(sflo())
    #print(p)
    dp=[0]*(1<<n)
    dp[1]=1
    for i in range(2,1<<n):
        for j in range(1,n):
            for k in range(0,j):
                if (i>>j)&1 and (i>>k)&1:
                    dp[i]=max(dp[i],dp[i^(1<<j)]*p[k][j]+dp[i^(1<<k)]*p[j][k])
    #print(dp)
    print(dp[-1])
for _ in range(1):
    hnbhai(_+1)
",np,"bitmasks,dp,math,probabilities",1277
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def main():
    n = int(input())
    p = [list(map(float,input().split())) for _ in range(n)]
    y = 1<<n
    dp = [[0]*y for _ in range(n)]
    # dp[i][j] is prob of 0 win when j fought and i left
    dp[0][y-1] = 1
    for i in range(y-2,-1,-1):
        mask = 1
        for j in range(n):
            if not mask&i:
                mask <<= 1
                continue
            mask1 = 1
            for k in range(n):
                if i&mask1:
                    mask1 <<= 1
                    continue
                dp[j][i] = max(dp[j][i],
                    dp[j][i|mask1]*p[j][k]+dp[k][i|mask1]*p[k][j])
                mask1 <<= 1
            mask <<= 1
    print(max(dp[i][1<<i] for i in range(n)))

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np,"bitmasks,dp,math,probabilities",2523
"from decimal import *
ar = [list(map(float, input().split())) for i in range(int(input()))]
dp = [[0 for i in range(1 << 18)] for j in range(18)]
n, ans = len(ar), 0
dp[0][(1 << n) - 1] = 1
for i in range((1 << n) - 1, 0, -1):
    for j in range(n):
        if i & (1 << j) == 0:
            continue
        for k in range(n):
            if i & (1 << k) != 0 or j == k:
                continue
            dp[j][i] = max(dp[j][i], dp[k][i ^ (1 << k)] * ar[k][j] + dp[j][i ^ (1 << k)] * ar[j][k])
for i in range(n):
    ans = max(ans, dp[i][1 << i])
print('{:.6f}'.format(ans))",np,"bitmasks,dp,math,probabilities",579
"import sys

n = int(input())
prob = [list(map(float, input().split())) for _ in range(n)]
dp = [[0.0]*n for _ in range(1 << n)]
dp[1][0] = 1.0

for mask in range(3, 1 << n):
    for i in range(n):
        if not (mask & (1 << i)):
            continue
        for j in range(n):
            if i != j and mask & (1 << j):
                dp[mask][i] = max(
                    dp[mask][i],
                    dp[mask - (1 << j)][i] * prob[i][j]
                    + dp[mask - (1 << i)][j] * prob[j][i]
                )

print(max(dp[-1]))
",np,"bitmasks,dp,math,probabilities",542
"import sys

n = int(input())
prob = [list(map(float, input().split())) for _ in range(n)]
dp = [[0.0]*(1 << n) for _ in range(n)]
dp[0][1] = 1.0

for mask in range(3, 1 << n):
    for i in range(n):
        if not (mask & (1 << i)):
            continue
        for j in range(n):
            if i != j and mask & (1 << j):
                dp[i][mask] = max(
                    dp[i][mask],
                    dp[i][mask - (1 << j)] * prob[i][j]
                    + dp[j][mask - (1 << i)] * prob[j][i]
                )

print(max(dp[i][-1] for i in range(n)))
",np,"bitmasks,dp,math,probabilities",565
"import math
temp=list(map(int,input().split()))
N,q=temp[0],temp[1]
for j in range(0,q):
    u=int(input())
    S=input()
    k=(N+1)//2
    n=int(math.log((N+1),10)/math.log(2,10))-1
    dup_n=n
    store=[k]
    while u!=k:
        n-=1
        if u>k:
            k+=2**(n)
        else:
            k-=2**(n)
        store.append(k)
    for i in range(0,len(S)):
        if S[i]=='R':
            n-=1
            if n==-1:
                n=0
                continue
            k+=2**(n)
        elif S[i]=='L':
            n-=1
            if n==-1:
                n=0
                continue
            k-=2**(n)
        else:
            if n==dup_n:
                continue
            store.pop()
            k=store[len(store)-1]
            n+=1
            continue
        store.append(k)
            
    print(k)",np,"bitmasks,trees",834
"# Code by Sounak, IIESTS
# ------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

# sys.setrecursionlimit(300000)
# threading.stack_size(10**8)

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------------------------------------------------------------
# mod = 9223372036854775807
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a + b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


class SegmentTree1:
    def __init__(self, data, default=10 ** 6, func=lambda a, b: min(a, b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


MOD = 10 ** 9 + 7


class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


mod = 10 ** 9 + 7
omod = 998244353
# -------------------------------------------------------------------------
prime = [True for i in range(10)]
pp = [0] * 10


def SieveOfEratosthenes(n=10):
    p = 2
    c = 0
    while (p * p <= n):

        if (prime[p] == True):
            c += 1
            for i in range(p, n + 1, p):
                pp[i] += 1
                prime[i] = False
        p += 1


# ---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n - 1
    res = -1
    while (left <= right):
        mid = (right + left) // 2
        if (arr[mid] >= key):
            res = arr[mid]
            right = mid - 1
        else:
            left = mid + 1
    return res
def binarySearch1(arr, n, key):
    left = 0
    right = n - 1
    res = -1
    while (left <= right):
        mid = (right + left) // 2
        if (arr[mid]>=key):
            right = mid - 1
        else:
            res = arr[mid]
            left = mid + 1
    return res


# ---------------------------------running code------------------------------------------
n,k=map(int,input().split())
prev=defaultdict(int)
for ik in range(k):
    cur=int(input())
    s=list(input())
    t=2
    while(cur%t==0):
        t*=2
    t//=4
    for i in range(len(s)):
        if cur==(n+1)//2:
            if s[i]=='U':
                continue
            else:
                if s[i]=='L':
                    cur-=t
                else:
                    cur+=t
                t//=2
        elif cur%2==1:
            if s[i]==""U"":
                if cur&2==0:
                    cur+=1
                else:
                    cur-=1
                t=1
        else:
            if s[i] == 'L':
                cur-=t
                t//=2
            elif s[i]==""U"":
                if cur&t*4==0:
                    cur+=t*2
                else:
                    cur-=t*2
                t*=2
            else:
                cur+=t
                t//=2
    print(cur)


",np,"bitmasks,trees",9689
"import sys
#import random
from bisect import bisect_right as rb
from collections import deque
#sys.setrecursionlimit(10**8)
from queue import PriorityQueue
from math import *
input_ = lambda: sys.stdin.readline().strip(""\r\n"")
ii = lambda : int(input_())
il = lambda : list(map(int, input_().split()))
ilf = lambda : list(map(float, input_().split()))
ip = lambda : input_()
fi = lambda : float(input_())
ap = lambda ab,bc,cd : ab[bc].append(cd)
li = lambda : list(input_())
pr = lambda x : print(x)
prinT = lambda x : print(x)
f = lambda : sys.stdout.flush()
inv =lambda x:pow(x,mod-2,mod)
mod = 10**9 + 7

def bit(n) :
    if (n == 0) :return 0
    val = 1

    while (val&n) == 0 :
        val *= 2

    return val


n,q = il()
x = n+1

for i in range(q) :
    t1 = ii()

    for j in ip() :
        val = bit(t1)

        if (j == ""U"") :
            tem = (t1-val)|(val*2)
            if (tem < n) :
                t1 = tem
        elif (j == ""L"" and val>1) :
            t1 -= val//2
        elif (j == ""R"" and val>1) :
            t1 += val//2

    print(t1)
        
",np,"bitmasks,trees",1075
"import sys
import bisect
from bisect import bisect_left as lb
input_=lambda: sys.stdin.readline().strip(""\r\n"")
from math import log
from math import gcd
from math import atan2,acos
from random import randint
sa=lambda :input_()
sb=lambda:int(input_())
sc=lambda:input_().split()
sd=lambda:list(map(int,input_().split()))
sflo=lambda:list(map(float,input_().split()))
se=lambda:float(input_())
sf=lambda:list(input_())
flsh=lambda: sys.stdout.flush()
#sys.setrecursionlimit(10**6)
mod=10**9+7
mod1=998244353
gp=[]
cost=[]
dp=[]
mx=[]
ans1=[]
ans2=[]
special=[]
specnode=[]
a=0
kthpar=[]
def dfs(root,par):
    if par!=-1:
        dp[root]=dp[par]+1
    for i in range(1,20):
        if kthpar[root][i-1]!=-1:
            kthpar[root][i]=kthpar[kthpar[root][i-1]][i-1]
    for child in gp[root]:
        if child==par:continue
        kthpar[child][0]=root
        dfs(child,root)
ans=0
def setting(s):
    if s=='0':
        return -1
    i=len(s)-1
    cc=0
    while(i>=0 and s[i]=='0'):
        cc+=1
        i-=1
    return cc
def hnbhai(tc):
    n,q=sd()
    up=n+1
    x=len(bin(n)[2:])-1
    for i in range(q):
        v=sb()
        s=sa()
        for j in s:
            temp=bin(v)[2:]
            abe=setting(temp)
            #print(v,abe)
            if j==""U"":
                if abe>=x:
                    continue
                p=v+(1<<(abe))
                n=v-(1<<(abe))
                x1=setting(bin(p)[2:])
                #print(p,x1)
                x2=setting(bin(n)[2:])
                if x1==abe+1:
                    v=p
                else:
                    v=n
            elif j==""L"":
                if abe<=0:
                    continue
                v=v-(1<<(abe-1))
                #print(""v"",v)
            else:
                if abe<=0:
                    continue
                v=v+(1<<(abe-1))
        print(v)
for _ in range(1):
    hnbhai(_+1)
",np,"bitmasks,trees",1903
"def lvl(val):
    tot=1
    curr=-1
    while(val%tot==0):
        curr+=1
        tot*=2
    return [curr,val*2//(tot),tot//2]









n,q=map(int,input().split())
for _ in range(q):
    curr=int(input())
    l,v,pw=lvl(curr)
    s=input()
    for j in s:

        if j==""U"":
            if v%4==3:
                curr=curr-pw
            else:
                if curr+pw<=n:
                    curr=curr+pw

        elif j==""R"":
            if l>0:
                curr=curr+pw//2

        elif j == ""L"":
            if l > 0:
                curr = curr - pw // 2

        l, v, pw = lvl(curr)

    print(curr)



",np,"bitmasks,trees",620
"def find(x):
    if root==x:
        u=root
    else:
        i=0
        s=2**i
        while x%s==0:
            i+=1
            s=2**i
        s=s//2
        y=i+1
        if (x-s)%(2**y)!=0:
            u=x-s
        else:
            u=x+s
    return u
n,q=list(map(int,input().split()))
root=(n+1)//2
for j in range(q):
    n1=int(input())
    str1=input()
    for j in range(len(str1)):
        up=find(n1)
        if str1[j]=='U':
            n1=(up)
        elif n1%2==0:
            if str1[j]=='L':
                if n1!=root:
                    n1=(n1-abs((up-n1)//2))
                else:
                    n1=(n1-n1//2)
            elif str1[j]=='R':
                if n1!=root:
                    n1=(n1+abs((up-n1)//2))
                elif n1%2==0:
                    n1=n1+n1//2
    print(n1)",np,"bitmasks,trees",819
"n, q = map(int,input().split())
par = n // 2 + 1
par = len(list(bin(par)[2:]))
for i in range(q):
    ui = int(input())
    si = input()
    temp = bin(ui)[2:]
    now = len(temp)
    num = list((par - now) * ""0"" + temp)
    now = par - now
    for i in range(len(num)):
        if str(num[i]) == '1':
            now = i
    for i in si:
        if i == ""U"":
            if now == 0:
                continue
            num[now] = 0
            now -= 1
            num[now] = 1
        elif i == ""L"":
            if str(num[-1]) == '1':
                continue
            num[now] = 0
            now += 1
            num[now] = 1
        else:
            if str(num[-1]) == '1':
                continue
            now += 1
            num[now] = 1
    for i in range(par):
        num[i] = str(num[i])
    print(int("""".join(num),2))
",np,"bitmasks,trees",842
"def maxx(n):
	return n&-n
n,q=map(int,input().split())
root=n//2+1
while q>0:
	x=int(input())
	s=input()

	for i in s:
		if i=='U' and x!=root:
			p=x+maxx(x)
			if x==p-maxx(p)//2:
				x=p
			else:
				x=x-maxx(x)
		elif i=='L':
			x=x-maxx(x)//2
		elif i=='R':
			x=x+maxx(x)//2
	q=q-1
	print(x)",np,"bitmasks,trees",297
"def prime2(n):
    cont = 0
    flag = True
    while flag:
        if n % 2 == 0:
            cont += 1
            n = n/2
        else:
            flag = False
    if n % 4 == 1:
        return [cont, ""L""]
    else:
        return [cont, ""R""]

def arrivo(n,start,char):
    for i in char:
        if (i == ""L"" or i == ""R"") and start % 2 == 1:
            pass
        elif (i == ""U"") and 2*start == n+1:
            pass
        else:
            [power, direc] = prime2(start)
            if i == ""L"":
                start -= 2 ** (power - 1)
            elif i == ""R"":
                start += 2 ** (power - 1)
            else:
                if direc == ""L"":
                    start += 2 ** power
                else:
                    start -= 2 ** power
    return start

if __name__ == '__main__':
    [n,q] = map(int, raw_input().rstrip().split())
    for i in range(q):
        start = int(input())
        char = raw_input()
        print(arrivo(n,start,char))",np,"bitmasks,trees",981
"#Bhargey Mehta (Sophomore)
#DA-IICT, Gandhinagar
import sys, math, queue
#sys.stdin = open(""input.txt"", ""r"")
MOD = 10**9+7
sys.setrecursionlimit(1000000)

def hgt(x):
    if x == 0: return -1
    h = 0
    while x&1 != 1:
        h += 1
        x = x>>1
    return h

def up(x):
    h = hgt(x)
    g = x + (1<<h)
    if g > 0 and g < N and hgt(g) == h+1:
        return g
    g = x - (1<<h)
    if g > 0 and g < N and hgt(g) == h+1:
        return g
    return x

def left(x):
    h = hgt(x)
    if h == 0:
        return x
    g = x - (1<<(h-1))
    if g > 0:
        return g
    return x

def right(x):
    h = hgt(x)
    if h == 0:
        return x
    g = x + (1<<(h-1))
    if g < N:
        return g
    return x

N, q = map(int, input().split())
N += 1
for _ in range(q):
    p = int(input())
    for c in input():
        if c == 'U':
            p = up(p)
        elif c == 'R':
            p = right(p)
        else:
            p = left(p)
    print(p)",np,"bitmasks,trees",964
"def solve(n, m):
    h=m&-m
    for c in input():
        if c=='U' and m!=(n+1)>>1:
            m+= -h if (m+h)%(h<<2)==0 else h
            h<<=1
        if c in 'LR' and h>1:
            h>>=1
            m+= -h if c=='L' else h
    return m

n, m=map(int, input().split())
for _ in range(m):
    print(solve(n, int(input())))",np,"bitmasks,trees",329
"import math

p2 =[1] * 64

for i in range(1, 64):
    p2[i] = p2[i-1] * 2
    
def find_level(x):
    x0 = 1
    
    for i in range(max_level+1):
        if (x-x0) % (x0*2) == 0:
            return i
        x0 *=2
    
def move_U(number):
    cur_lv    =  find_level(number)
    
    if cur_lv == max_level:
        return number
    
    x0      =   p2[cur_lv]
    seg     =   x0 * 2 
    index   =  (number - x0) // seg
    
    return (x0*2) + (index // 2) * (seg * 2) 
    
def move_L(number):
    cur_lv    =  find_level(number)
    
    if cur_lv == 0:
        return number
    
    x0      =   p2[cur_lv]
    seg     =   x0 * 2 
    index   =  (number - x0) // seg
    
    return (x0 // 2) + (index * 2) * (seg // 2)

def move_R(number):
    cur_lv    =  find_level(number)
    
    if cur_lv == 0:
        return number
    
    x0      =   p2[cur_lv]
    seg     =   x0 * 2 
    index   =  (number - x0) // seg
    
    return (x0 // 2) + (index * 2 + 1) * (seg // 2)

def move(s,num):
    if s == 'U':
        return move_U(num)
    
    if s == 'L':
        return move_L(num)
    
    return move_R(num)
    
def process(S, num):
    for s in S:
        num = move(s, num)
    return num

n, q = map(int, input().split())
max_level = int(math.log2(n+1)) - 1
ans  = ''

for _ in range(q):
    num  = int(input())
    S    = input()
    ans += str(process(S, num)) + '\n'
    
print(ans)    

#15 2
#4
#UURL
#8
#LRLLLLLLLL",np,"bitmasks,trees",1436
"def pow2(n):
    j=0
    while(n%2==0):
        n//=2
        j+=1
    return j    
n,q=map(int,input().split())
for j in range(q):
    u=int(input())
    s=input()
    for k in range(len(s)):
        num=pow2(u)
        if(s[k]==""R"" and num!=0):
            u=u+2**(num-1)
        elif(s[k]==""L"" and num!=0):
            u=u-2**(num-1)
        elif(s[k]==""U"" and u!=(n+1)//2):
            m1=u+2**(num)
            m2=u-2**(num)
            if(pow2(m1)==(num+1)):
                u=m1
            else:
                u=m2
    print(u)                ",np,"bitmasks,trees",553
"# import sys
# input = sys.stdin.readline

n, q = map(int, input().split())
for _ in range(q):
    u = int(input())
    s = input()
    for comm in s:
        k = 1
        while True:
            if k & u:
                break
            k <<= 1
        if comm == 'L':
            if k != 1:
                u -= k
                u += (k>>1)
        elif comm == 'R':
            if k != 1:
                u += (k>>1)
        elif comm == 'U':
            nu = u - k
            nu |= (k<<1)
            if nu <= n:
                u = nu
    print(u)",np,"bitmasks,trees",557
"import sys
input = sys.stdin.readline

n, q = map(int, input().split())
for _ in range(q):
    u = int(input())
    s = input()
    for comm in s:
        k = 1
        while True:
            if k & u:
                break
            k <<= 1
        if comm == 'L':
            if k != 1:
                u -= k
                u += (k>>1)
        elif comm == 'R':
            if k != 1:
                u += (k>>1)
        elif comm == 'U':
            nu = u - k
            nu |= (k<<1)
            if nu <= n:
                u = nu
    print(u)",np,"bitmasks,trees",553
"def l(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==0:
        return -1
    return (a-2**(c-1))

def r(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==0:
        return -1
    return (a+2**(c-1))
          
def u(a):
    b=bin(a)[2:]
    b=""0""*(e-len(b))+b
    d=len(b)
    for i in range(d-1,-1,-1):
        if b[i]==""1"":
            c=d-1-i
            break
    if c==d-1:
        return -1
    else:
        if b[d-1-c-1]==""0"":
            return a+(2**c)
        else:
            return a-(2**c)
    
n,q=list(map(int,input().split()))
e=len(bin(n)[2:])
for i in range(q):
    a=int(input())
    b=input()
    for i in range(len(b)):
        if b[i]==""U"":
            c=u(a)
            if c!=-1:
                a=c
        elif b[i]==""R"":
            c=r(a)
            if c!=-1:
                a=c
        elif b[i]==""L"":
            c=l(a)
            if c!=-1:
                a=c
    print(a)",np,"bitmasks,trees",1128
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#######################################
n,q=map(int,input().split())
x=n+1
l=0
while x>1:
    x//=2
    l+=1
for i in range(q):
    a=int(input())
    s=input()
    for j in s:
        lv=1
        a1=a
        while a1%2==0:
            a1=a1//2
            lv+=1
        x=2**lv
        q=x//2
        p=q//2
        y=(a-q)//x+1
        if j=='U':
            if lv==l:
                pass
            else:
                if y%2:
                    a=(2*a+x)//2
                else:
                    a=(2*a-x)//2
        elif j=='L':
            if lv==1:
                pass
            else:
                z=2*(y-1)
                a=p+z*q
        else:
            if lv==1:
                pass
            else:
                z=2*(y-1)
                a=p+(z+1)*q
    print(a)
                
                
                
            
",np,"bitmasks,trees",2577
"'''
    Auther: ghoshashis545 Ashis Ghosh
    College: jalpaiguri Govt Enggineering College

'''
from os import path
import sys
from heapq import heappush,heappop,heapify
from functools import cmp_to_key as ctk
from collections import deque,defaultdict as dd 
from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right
from itertools import permutations
from datetime import datetime
from math import ceil,sqrt,log,gcd
def ii():return int(input())
def si():return input().rstrip()
def mi():return map(int,input().split())
def li():return list(mi())
abc='abcdefghijklmnopqrstuvwxyz'
mod=1000000007
# mod=998244353
inf = float(""inf"")
vow=['a','e','i','o','u']
dx,dy=[-1,1,0,0],[0,0,1,-1]

def bo(i):
    return ord(i)-ord('a')

file=1


def solve():

    # for t in range(ii()):

    n,q=mi()

    x=int(log(n+1,2))
    root=1<<(x-1)
    for i in range(q):
        u=ii()
        s=si()
        pos='U'
        if(u<root):
            pos='L'
        if(u>root):
            pos='R'

        s1=bin(u)[2:]
        s1='0'*(x-len(s1))+s1
        s1=list(s1)
        for j in s:
            for k in range(x-1,-1,-1):
                if s1[k]=='1':
                    f=k
                    break
            if j=='L':
                if(f==x-1):
                    continue
                s1[f]='0'
                s1[f+1]='1'
            elif(j=='R'):
                if(f==x-1):
                    continue
                s1[f+1]='1'
            else:
                if f==0:
                    continue
                if s1[f-1]=='1':
                    s1[f]='0'
                else:
                    s1[f-1]='1'
                    s1[f]='0'
            # print(s1)
        s1="""".join(s1)
        print(int(s1,2))
    
    
    
    
    
    
    
    
        

        



    










        
if __name__ ==""__main__"":

    if(file):

        if path.exists('input.txt'):
            sys.stdin=open('input.txt', 'r')
            sys.stdout=open('output.txt','w')
        else:
            input=sys.stdin.readline
    solve()",np,"bitmasks,trees",2072
"#   ==========     //\\       //||     ||====//||
#       ||        //  \\        ||     ||   // ||
#       ||       //====\\       ||     ||  //  ||
#       ||      //      \\      ||     || //   ||
#   ========== //        \\  ========  ||//====|| 
#  code

def main():
    n, q = map(int, input().split())
    for _ in range(q):
        node = int(input())
        s = input()

        for i in s:
            if i == 'L':
                if node % 2:
                    continue
                k = node & (-node)
                node -= k
                k //= 2
                node += k

            if i == 'R':
                if node % 2:
                    continue
                k = node & (-node)
                k //= 2
                node += k
            
            if i == 'U':
                if node == (n + 1) // 2:
                    continue
                k = node & (-node)
                node -= k
                k *= 2
                node |= k
        print(node)
    return

if __name__ == ""__main__"":
    main()",np,"bitmasks,trees",1051
"import sys

n, q = map(int, input().split())
top = len(bin(n >> 1)) - 2
ans = [1] * q

for i in range(q):
    v = int(input())
    s = input()
    if n == 1:
        continue
    for h in range(top+1):
        if v & (1 << h):
            break

    for c in s:
        if h == top and c == 'U' or h == 0 and c != 'U':
            continue
        if c == 'U':
            v -= 1 << h
            h += 1
            v |= 1 << h
        elif c == 'L':
            v -= 1 << h
            h -= 1
            v |= 1 << h
        else:
            h -= 1
            v |= 1 << h
    ans[i] = v

print(*ans, sep='\n')
",np,"bitmasks,trees",613
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
import io
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
from collections import Counter
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------game starts now-----------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: max(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(11)] 
prime[0]=prime[1]=False
#pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p <= n): 
          
        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p): 
                #pp[i]=1
                prime[i] = False
        p += 1
#-----------------------------------DSU--------------------------------------------------
class DSU:
    def __init__(self, R, C):
        #R * C is the source, and isn't a grid square
        self.par = range(R*C + 1)
        self.rnk = [0] * (R*C + 1)
        self.sz = [1] * (R*C + 1)

    def find(self, x):
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr == yr: return
        if self.rnk[xr] < self.rnk[yr]:
            xr, yr = yr, xr
        if self.rnk[xr] == self.rnk[yr]:
            self.rnk[xr] += 1

        self.par[yr] = xr
        self.sz[xr] += self.sz[yr]

    def size(self, x):
        return self.sz[self.find(x)]

    def top(self):
        # Size of component at ephemeral ""source"" node at index R*C,
        # minus 1 to not count the source itself in the size
        return self.size(len(self.sz) - 1) - 1
#---------------------------------Lazy Segment Tree--------------------------------------
# https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp
class LazySegTree:
    def __init__(self, _op, _e, _mapping, _composition, _id, v):
        def set(p, x):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            _d[p] = x
            for i in range(1, _log + 1):
                _update(p >> i)
 
        def get(p):
            assert 0 <= p < _n
            p += _size
            for i in range(_log, 0, -1):
                _push(p >> i)
            return _d[p]
 
        def prod(l, r):
            assert 0 <= l <= r <= _n
 
            if l == r:
                return _e
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push(r >> i)
 
            sml = _e
            smr = _e
            while l < r:
                if l & 1:
                    sml = _op(sml, _d[l])
                    l += 1
                if r & 1:
                    r -= 1
                    smr = _op(_d[r], smr)
                l >>= 1
                r >>= 1
 
            return _op(sml, smr)
 
        def apply(l, r, f):
            assert 0 <= l <= r <= _n
            if l == r:
                return
 
            l += _size
            r += _size
 
            for i in range(_log, 0, -1):
                if ((l >> i) << i) != l:
                    _push(l >> i)
                if ((r >> i) << i) != r:
                    _push((r - 1) >> i)
 
            l2 = l
            r2 = r
            while l < r:
                if l & 1:
                    _all_apply(l, f)
                    l += 1
                if r & 1:
                    r -= 1
                    _all_apply(r, f)
                l >>= 1
                r >>= 1
            l = l2
            r = r2
 
            for i in range(1, _log + 1):
                if ((l >> i) << i) != l:
                    _update(l >> i)
                if ((r >> i) << i) != r:
                    _update((r - 1) >> i)
 
        def _update(k):
            _d[k] = _op(_d[2 * k], _d[2 * k + 1])
 
        def _all_apply(k, f):
            _d[k] = _mapping(f, _d[k])
            if k < _size:
                _lz[k] = _composition(f, _lz[k])
 
        def _push(k):
            _all_apply(2 * k, _lz[k])
            _all_apply(2 * k + 1, _lz[k])
            _lz[k] = _id
 
        _n = len(v)
        _log = _n.bit_length()
        _size = 1 << _log
        _d = [_e] * (2 * _size)
        _lz = [_id] * _size
        for i in range(_n):
            _d[_size + i] = v[i]
        for i in range(_size - 1, 0, -1):
            _update(i)
 
        self.set = set
        self.get = get
        self.prod = prod
        self.apply = apply
 
 
MIL = 1 << 20
 
 
def makeNode(total, count):
    # Pack a pair into a float
    return (total * MIL) + count
 
 
def getTotal(node):
    return math.floor(node / MIL)
 
 
def getCount(node):
    return node - getTotal(node) * MIL
 
 
nodeIdentity = makeNode(0.0, 0.0)
 
 
def nodeOp(node1, node2):
    return node1 + node2
    # Equivalent to the following:
    return makeNode(
        getTotal(node1) + getTotal(node2), getCount(node1) + getCount(node2)
    )
 
 
identityMapping = -1
 
 
def mapping(tag, node):
    if tag == identityMapping:
        return node
    # If assigned, new total is the number assigned times count
    count = getCount(node)
    return makeNode(tag * count, count)
 
 
def composition(mapping1, mapping2):
    # If assigned multiple times, take first non-identity assignment
    return mapping1 if mapping1 != identityMapping else mapping2
#---------------------------------Pollard rho--------------------------------------------
def memodict(f):
    """"""memoization decorator for a function taking a single argument""""""
    class memodict(dict):
        def __missing__(self, key):
            ret = self[key] = f(key)
            return ret
 
    return memodict().__getitem__
 
 
def pollard_rho(n):
    """"""returns a random factor of n""""""
    if n & 1 == 0:
        return 2
    if n % 3 == 0:
        return 3
 
    s = ((n - 1) & (1 - n)).bit_length() - 1
    d = n >> s
    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        p = pow(a, d, n)
        if p == 1 or p == n - 1 or a % n == 0:
            continue
        for _ in range(s):
            prev = p
            p = (p * p) % n
            if p == 1:
                return math.gcd(prev - 1, n)
            if p == n - 1:
                break
        else:
            for i in range(2, n):
                x, y = i, (i * i + 1) % n
                f = math.gcd(abs(x - y), n)
                while f == 1:
                    x, y = (x * x + 1) % n, (y * y + 1) % n
                    y = (y * y + 1) % n
                    f = math.gcd(abs(x - y), n)
                if f != n:
                    return f
    return n
 
 
@memodict
def prime_factors(n):
    """"""returns a Counter of the prime factorization of n""""""
    if n <= 1:
        return Counter()
    f = pollard_rho(n)
    return Counter([n]) if f == n else prime_factors(f) + prime_factors(n // f)
 
 
def distinct_factors(n):
    """"""returns a list of all distinct factors of n""""""
    factors = [1]
    for p, exp in prime_factors(n).items():
        factors += [p**i * factor for factor in factors for i in range(1, exp + 1)]
    return factors
 
 
def all_factors(n):
    """"""returns a sorted list of all distinct factors of n""""""
    small, large = [], []
    for i in range(1, int(n**0.5) + 1, 2 if n & 1 else 1):
        if not n % i:
            small.append(i)
            large.append(n // i)
    if small[-1] == large[-1]:
        large.pop()
    large.reverse()
    small.extend(large)
    return small

#---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res = n
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            res=mid
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=-1
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=mid
            left = mid + 1
    return res
#---------------------------------running code------------------------------------------
t=1
#t=int(input())
for _ in range (t):
    n=int(input())
    #n,m=map(int,input().split())
    a=list(map(int,input().split()))
    #b=list(map(int,input().split()))
    #s=input()
    #n=len(s)
    twopow = [1]*(10**5+69)
    for i in range(1, 10**5+69):
        twopow[i] = (twopow[i-1] * 2) % mod
    count = [0]*100069
    for i in a:
        count[i] += 1
    multiples = [0]*100069
    for i in range(1, 10**5+1):
        for j in range(i, 10**5+1, i):
            multiples[i] += count[j]
    gcd_of = [0]*100069
    for i in range(10**5, 0, -1):
        gcd_of[i] = (twopow[multiples[i]] - 1) % mod
        for j in range(2*i, 10**5+1, i):
            gcd_of[i] -= gcd_of[j]
    print(gcd_of[1] % mod)",np,"bitmasks,combinatorics,number theory",16497
"import sys
input = sys.stdin.readline

n = int(input())
mod = pow(10, 9) + 7
a = list(map(int, input().split()))
l = 100000
cnt = [0] * (l + 1)
for i in a:
    cnt[i] += 1
pow2 = [1]
for _ in range(l):
    pow2.append(2 * pow2[-1] % mod)
ans = pow2[n] - 1
x = [-1] * (l + 1)
for i in range(2, l + 1):
    c = cnt[i]
    xi = x[i]
    for j in range(2 * i, l + 1, i):
        c += cnt[j]
        x[j] -= xi
    ans += xi * (pow2[c] - 1) % mod
    ans %= mod
print(ans)",np,"bitmasks,combinatorics,number theory",467
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N=int(readline())
A=list(map(int,readline().split()))
mod=10**9+7
m=max(A)
cnt=[0]*(m+1)
P=Prime(m)
for a,c in Counter(A).items():
    for aa in P.Divisors(a):
        cnt[aa]+=c
for i in range(1,m+1):
    cnt[i]=pow(2,cnt[i],mod)-1
    cnt[i]%=mod
for p in P.primes:
    for i in range(p,m+1,p):
        cnt[i//p]-=cnt[i]
        cnt[i//p]%=mod
ans=cnt[1]
print(ans)",np,"bitmasks,combinatorics,number theory",3332
"import bisect
import copy
import decimal
import fractions
import heapq
import itertools
import math
import random
import sys
from collections import Counter,deque,defaultdict
from functools import lru_cache,reduce
from heapq import heappush,heappop,heapify,heappushpop,_heappop_max,_heapify_max
def _heappush_max(heap,item):
    heap.append(item)
    heapq._siftdown_max(heap, 0, len(heap)-1)
def _heappushpop_max(heap, item):
    if heap and item < heap[0]:
        item, heap[0] = heap[0], item
        heapq._siftup_max(heap, 0)
    return item
from math import gcd as GCD
read=sys.stdin.read
readline=sys.stdin.readline
readlines=sys.stdin.readlines

class Prime:
    def __init__(self,N):
        assert N<=10**8
        self.smallest_prime_factor=[None]*(N+1)
        for i in range(2,N+1,2):
            self.smallest_prime_factor[i]=2
        n=int(N**.5)+1
        for p in range(3,n,2):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
                for i in range(p**2,N+1,2*p):
                    if self.smallest_prime_factor[i]==None:
                        self.smallest_prime_factor[i]=p
        for p in range(n,N+1):
            if self.smallest_prime_factor[p]==None:
                self.smallest_prime_factor[p]=p
        self.primes=[p for p in range(N+1) if p==self.smallest_prime_factor[p]]

    def Factorize(self,N):
        assert N>=1
        factorize=defaultdict(int)
        if N<=len(self.smallest_prime_factor)-1:
            while N!=1:
                factorize[self.smallest_prime_factor[N]]+=1
                N//=self.smallest_prime_factor[N]
        else:
            for p in self.primes:
                while N%p==0:
                    N//=p
                    factorize[p]+=1
                if N<p*p:
                    if N!=1:
                        factorize[N]+=1
                    break
                if N<=len(self.smallest_prime_factor)-1:
                    while N!=1:
                        factorize[self.smallest_prime_factor[N]]+=1
                        N//=self.smallest_prime_factor[N]
                    break
            else:
                if N!=1:
                    factorize[N]+=1
        return factorize

    def Divisors(self,N):
        assert N>0
        divisors=[1]
        for p,e in self.Factorize(N).items():
            A=[1]
            for _ in range(e):
                A.append(A[-1]*p)
            divisors=[i*j for i in divisors for j in A]
        return divisors

    def Is_Prime(self,N):
        return N==self.smallest_prime_factor[N]

    def Totient(self,N):
        for p in self.Factorize(N).keys():
            N*=p-1
            N//=p
        return N

    def Mebius(self,N):
        fact=self.Factorize(N)
        for e in fact.values():
            if e>=2:
                return 0
        else:
            if len(fact)%2==0:
                return 1
            else:
                return -1

N=int(readline())
A=list(map(int,readline().split()))
mod=10**9+7
m=max(A)
cnt=[0]*(m+1)
P=Prime(m)
for a,c in Counter(A).items():
    cnt[a]=c
for p in P.primes:
    for i in range(m//p,0,-1):
        cnt[i]+=cnt[i*p]
for i in range(1,m+1):
    cnt[i]=pow(2,cnt[i],mod)-1
    cnt[i]%=mod
for p in P.primes:
    for i in range(p,m+1,p):
        cnt[i//p]-=cnt[i]
        cnt[i//p]%=mod
ans=cnt[1]
print(ans)",np,"bitmasks,combinatorics,number theory",3372
"n=input()
L=list(map(int,raw_input().split(' ')))
D=[0]*101000
mod=10**9+7
itt=[0]*101000
p=[0]*100010
D[0]=1
for i in range(100010):
  D[i+1]=(D[i]*2)%mod
for i in range(n):
  itt[L[i]]+=1 
for i in range(1,100001):
  for j in range(i*2,100001,i):
    itt[i]+=itt[j]
  p[i]=(D[itt[i]]+mod-1)%mod
i=100000
while i>=1:
  for j in range(i*2,100001,i):
    p[i]-=p[j]
  p[i]=(p[i]%mod+mod)%mod
  i-=1
print(p[1])",np,"bitmasks,combinatorics,number theory",409
"#Bhargey Mehta (Sophomore)
#DA-IICT, Gandhinagar
import sys, math, queue
#sys.stdin = open(""input.txt"", ""r"")
MOD = 10**9+7
sys.setrecursionlimit(1000000)

def getMul(x):
    a = 1
    for xi in x:
        a *= xi
    return a

n = int(input())
a = list(map(int, input().split()))
d = {}
for ai in a:
    if ai in d: d[ai] += 1
    else: d[ai] = 1

f = [[] for i in range(max(a)+10)]
for i in range(1, len(f)):
    for j in range(i, len(f), i):
        f[j].append(i)

seq = [0 for i in range(max(a)+10)]
for ai in d:
    for fi in f[ai]:
        seq[fi] += d[ai]
for i in range(len(seq)):
    seq[i] = (pow(2, seq[i], MOD) -1 +MOD) % MOD

pf = [[] for i in range(max(a)+10)]
pf[0] = None
pf[1].append(1)
for i in range(2, len(f)):
    if len(pf[i]) == 0:
        for j in range(i, len(pf), i):
            pf[j].append(i)
for i in range(1, len(pf)):
    mul = getMul(pf[i])
    if mul == i:
        if len(pf[i])&1 == 1: pf[i] = -1
        else: pf[i] = 1
    else:
        pf[i] = 0
pf[1] = 1

ans = 0
for i in range(1, len(seq)):
    ans += seq[i]*pf[i]
    ans = (ans + MOD) % MOD
print(ans)",np,"bitmasks,combinatorics,number theory",1094
"fact=[1]
temp=1
MOD=10**9+7
for i in range(1,10**5+5):
    temp*=i
    temp%=MOD
    fact+=[temp]
def bino(a,b):
    up=fact[a]
    down=pow(fact[b]*fact[a-b],MOD-2,MOD)
    return (up*down)%MOD


def find(A):
    MOD=10**9+7
    
    
    dp=[0]*(10**5+2)
    for x in A:
        dp[x]+=1
    for i in range(2,len(dp)):
        for j in range(2,len(dp)):
            if i*j>len(dp)-1:
                break
            dp[i]+=dp[i*j]
    for i in range(2,len(dp)):
        dp[i]=(pow(2,dp[i],MOD)-1)%MOD
    
    for i in range(len(dp)-1,1,-1):
        for j in range(2,len(dp)):
            if i*j>=len(dp):
                break
            dp[i]-=dp[i*j]
            dp[i]%=MOD
    
    ans=0
    for i in range(2,len(dp)):
        ans+=dp[i]
        ans%=MOD
    
    return (pow(2,len(A),MOD)-ans-1)%MOD
input()
print(find(list(map(int,input().strip().split(' ')))))                
    
    ",np,"bitmasks,combinatorics,number theory",898
"# 803F
import math
import collections
def do():
    n = int(input())
    nums = map(int, input().split("" ""))
    count = collections.defaultdict(int)
    for num in nums:
        for i in range(1, int(math.sqrt(num))+1):
            cp = num // i
            if num % i == 0:
                count[i] += 1
            if cp != i and num % cp == 0:
                count[cp] += 1
    maxk = max(count.keys())
    freq = {k: (1 << count[k]) - 1 for k in count}
    for k in sorted(count.keys(), reverse=True):
        for kk in range(k << 1, maxk+1, k):
            freq[k] -= freq[kk] if kk in freq else 0
    return freq[1] % (10**9 + 7)

print(do())",np,"bitmasks,combinatorics,number theory",650
"N = 10**5+5
MOD = 10**9+7

freq = [0 for i in range(N)]

# Calculating {power(2,i)%MOD} and storing it at ith pos in p2 arr
p2 = [0 for i in range(N)]
p2[0] = 1
for i in range(1,N):
    p2[i] = p2[i-1]*2
    p2[i]%=MOD

def Calculate_Mobius(N):
    arr = [1 for i in range(N+1)]
    prime_count = [0 for i in range(N+1)]

    mobius_value = [0 for i in range(N+1)]
    for i in range(2,N+1):
        if prime_count[i]==0:
            for j in range(i,N+1,i):
                prime_count[j]+=1
                arr[j] = arr[j] * i

    for i in range(1, N+1):
        if arr[i] == i:
            if (prime_count[i] & 1) == 0:
                mobius_value[i] = 1
            else:
                mobius_value[i] = -1
        else:
            mobius_value[i] = 0

    return mobius_value

# Caluclating Mobius values for nos' till 10^5
mobius = Calculate_Mobius(N)
n = int(input())
b = [int(i) for i in input().split()]

# Storing freq of I/p no.s in array  
for i in b:
    freq[i]+=1

ans = 0
for i in range(1,N):
    # Count no of I/p no's which are divisible by i
    cnt = 0
    for j in range(i,N,i):
        cnt += freq[j]
    
    total_subsequences = p2[cnt] - 1
    ans = (ans + (mobius[i] * total_subsequences)%MOD)%MOD

# Dealing if ans is -ve due to MOD
ans += MOD
print(ans%MOD)

",np,"bitmasks,combinatorics,number theory",1292
"
mod = int(1e9 + 7)

n = int(input())
a = [int(_) for _ in input().split()]

freq = {i: 0 for i in range(100001)}
power = {0: 1}
for i in range(1, 100001):
    power[i] = (2 * power[i - 1]) % mod

for v in a:
    freq[v] += 1

dp = {i: 0 for i in range(100001)}
for gcd in range(100000, 0, -1):
    mult = 2
    total = freq[gcd]
    complement = 0
    # xy = k, so integral is ln(x)
    while mult * gcd <= 100000:
        total += freq[mult * gcd]
        complement += dp[mult * gcd]
        mult += 1
    dp[gcd] = (power[total] - 1 - complement + mod) % mod

print(dp[1])",np,"bitmasks,combinatorics,number theory",576
"n=int(input())
r=list(map(int,input().split()))
dp=[0]*(10**5+1)
cnt=[0]*(10**5+1)
tmp=[0]*(10**5+1)
mod=10**9+7
for i in range(n):
	cnt[r[i]]+=1
for i in range(1,10**5+1):
	for j in range(2*i,10**5+1,i):
		cnt[i]+=cnt[j]
	tmp[i]=pow(2,cnt[i],mod)-1
for i in range(10**5,0,-1):
	for j in range(2*i,10**5+1,i):
		tmp[i]=(tmp[i]-tmp[j])%mod
print(tmp[1]%mod)",np,"bitmasks,combinatorics,number theory",356
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------- fast io --------------------
from math import gcd, ceil

def prod(a, mod=10**9+7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans

def lcm(a, b): return a * b // gcd(a, b)

def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

for _ in range(int(input()) if not True else 1):
    n = int(input())
    #n, k = map(int, input().split())
    #a, b = map(int, input().split())
    #c, d = map(int, input().split())
    a = list(map(int, input().split()))
    #b = list(map(int, input().split()))
    #s = input()
    mod =  10**9 + 7
    twopow = [1]*(10**5+69)
    for i in range(1, 10**5+69):
        twopow[i] = (twopow[i-1] * 2) % mod
    count = [0]*100069
    for i in a:
        count[i] += 1
    multiples = [0]*100069
    for i in range(1, 10**5+1):
        for j in range(i, 10**5+1, i):
            multiples[i] += count[j]
    gcd_of = [0]*100069
    for i in range(10**5, 0, -1):
        gcd_of[i] = (twopow[multiples[i]] - 1) % mod
        for j in range(2*i, 10**5+1, i):
            gcd_of[i] -= gcd_of[j]
    print(gcd_of[1] % mod)",np,"bitmasks,combinatorics,number theory",2912
"n=int(input())
s=[c=='1' for c in input()]
m=len(s)
z=[[0,0]]
for c in s:
 ind = z[-1][c]
 z[-1][c] = len(z)
 z.append(z[ind][:])
assert(len(z) == m+1)
z[m][0] = z[m][1] = m # make it sticky

# how many things match directly
dp = [0 for _ in range(m+1)]
dp[0] = 1
for i in range(n):
 ndp = [0 for _ in range(m+1)]
 for i in range(m+1):
  ndp[z[i][0]] += dp[i]
  ndp[z[i][1]] += dp[i]
 dp = ndp
res = dp[m]

for k in range(1, m):
 s0 = 0
 for c in s[-k:]:
  s0 = z[s0][c]
 dp = [0 for _ in range(m+1)]
 dp[s0] = 1
 for i in range(n - k):
  ndp = [0 for _ in range(m+1)]
  for i in range(m+1):
   ndp[z[i][0]] += dp[i]
   ndp[z[i][1]] += dp[i]
  dp = ndp
 for s1 in range(m): # skip m
  v = dp[s1]
  for c in s[-k:]:
   if s1 == m: v = 0
   s1 = z[s1][c]
  if s1 == m: res += v
print(res)",np,"dp,strings",786
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def main():
    mod = 998244353
    n,k = map(int,input().split())
    dp = [[[0]*4 for _ in range(k+2)]for _ in range(n)]
    dp[0][1] = [0,1,1,0]
    dp[0][0] = [1,0,0,1]
    for i in range(1,n):
        for r in range(k):
            dp[i][r+1][3] = (dp[i][r+1][3]+dp[i-1][r][0])%mod
            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][0])%mod
            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][0])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][0])%mod
            dp[i][r+2][2] = (dp[i][r+2][2]+dp[i-1][r][1])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][1])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][1])%mod
            dp[i][r][1] = (dp[i][r][1]+dp[i-1][r][1])%mod
            dp[i][r+2][1] = (dp[i][r+2][1]+dp[i-1][r][2])%mod
            dp[i][r][0] = (dp[i][r][0]+dp[i-1][r][2])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][2])%mod
            dp[i][r][2] = (dp[i][r][2]+dp[i-1][r][2])%mod
            dp[i][r+1][0] = (dp[i][r+1][0]+dp[i-1][r][3])%mod
            dp[i][r+1][2] = (dp[i][r+1][2]+dp[i-1][r][3])%mod
            dp[i][r+1][1] = (dp[i][r+1][1]+dp[i-1][r][3])%mod
            dp[i][r][3] = (dp[i][r][3]+dp[i-1][r][3])%mod
    print((dp[-1][k-1][0]+dp[-1][k-1][1]+dp[-1][k-1][2]+dp[-1][k-1][3])%mod)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",np,"bitmasks,dp",3065
"n, K = map(int, input().split())
mod = 998244353
if K == 1:
    print(2)
    exit()
dp = [[0]*(2**2) for i in range(K+1)]
dp[1][0] = 1
dp[2][1] = 1
dp[2][2] = 1
dp[1][3] = 1
for i in range(1, n):
    nx = [[0]*(2**2) for i in range(K+1)]
    for k in range(K+1):
        for j in range(4):
            if j == 0:
                nx[k][0] += dp[k][j]%mod
                if k+1 <= K:
                    nx[k+1][1] += dp[k][j]%mod
                    nx[k+1][2] += dp[k][j]%mod
                    nx[k+1][3] += dp[k][j]%mod
            elif j == 1:
                nx[k][0] += dp[k][j]%mod
                nx[k][1] += dp[k][j]%mod
                if k+2 <= K:
                    nx[k+2][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
            elif j == 2:
                nx[k][0] += dp[k][j]%mod
                if k+2 <= K:
                    nx[k+2][1] += dp[k][j]%mod
                nx[k][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
            else:
                if k+1 <= K:
                    nx[k+1][0] += dp[k][j]%mod
                    nx[k+1][1] += dp[k][j]%mod
                    nx[k+1][2] += dp[k][j]%mod
                nx[k][3] += dp[k][j]%mod
    dp = nx
#print(dp)
print(sum(dp[K])%mod)
",np,"bitmasks,dp",1246
"def main():
    n, k = map(int, input().split(' '))

    if(k > 2*n): 
        return(0)
    if(k == 2*n or k==1): 
        return(2)

    iguales = [0]*(k+1)
    diferentes = [0]*(k+1)

    iguales[1] = 2
    diferentes[2] = 2

    modulo = 998244353

    for i in range(1, n):
        auxigual = [0]*(k+1)
        auxdiff = [0]*(k+1)

        for j in range(1, k+1):
            auxigual[j] = (iguales[j] + iguales[j-1] + 2*diferentes[j]) % modulo

        for k in range(2, k+1):
            auxdiff[k] = (diferentes[k] + diferentes[k-2] + 2*iguales[k-1]) % modulo
        
        iguales = auxigual
        diferentes = auxdiff

    return((iguales[-1] + diferentes[-1]) % modulo)

print(main())
	 		   				 			 	 	          		",np,"bitmasks,dp",732
"def main():
    n, k = map(int, input().split(' '))

    if(k > 2*n): 
        return(0)
    if(k == 2*n or k==1): 
        return(2)

    iguales = [0]*(k+1)
    diferentes = [0]*(k+1)

    iguales[1] = 2
    diferentes[2] = 2

    modulo = 998244353

    for i in range(1, n):
        auxigual, auxdiff = [0]*(k+1), [0]*(k+1)
        for j in range(k):
            auxigual[j+1] = (iguales[j+1] + iguales[j] + 2*diferentes[j+1]) % modulo
            if(j >= 1):
                auxdiff[j+1] = (diferentes[j+1] + diferentes[j-1] + 2*iguales[j]) % modulo
        
        iguales = auxigual
        diferentes = auxdiff

    return((iguales[-1] + diferentes[-1]) % modulo)

print(main())",np,"bitmasks,dp",687
"n,k=map(int,input().split())
same=[0]*(k+1)
diff=[0]*(k+1)
same[1]=2
if k>1:
    diff[2]=2
for i in range(n-1):
    newsame=[0]*(k+1)
    newdiff=[0]*(k+1)
    for i in range(1,k+1):
        newsame[i]=(same[i]+same[i-1]+2*diff[i])%998244353
    for i in range(2,k+1):
        newdiff[i]=(2*same[i-1]+diff[i]+diff[i-2])%998244353
    same=newsame
    diff=newdiff
print((same[-1]+diff[-1])%998244353)",np,"bitmasks,dp",400
"n,k=map(int,input().split())
mod=998244353
dp=[[0,0,0,0] for _ in range(k+1)]
#dp[0][0]=dp[0][1]=dp[0][2]=dp[0][3]=
dp[1][0]=dp[1][3]=1
if k>1:
    dp[2][2]=dp[2][1]=1
for x in range(1,n):
    g=[[0,0,0,0] for _ in range(k+1)]
    # 0 - bb
    # 1 - bw
    # 2 - wb
    # 3 - ww
    g[1][0]=g[1][3]=1
    for i in range(2,k+1):
        g[i][0]=(dp[i][0]+dp[i][1]+dp[i][2]+dp[i-1][3])%mod
        g[i][1]=(dp[i-1][0]+dp[i][1]+dp[i-2][2]+dp[i-1][3])%mod
        g[i][2]=(dp[i-1][0]+dp[i-2][1]+dp[i][2]+dp[i-1][3])%mod
        g[i][3]=(dp[i-1][0]+dp[i][1]+dp[i][2]+dp[i][3])%mod
    dp=g
print(sum(dp[-1])%mod)",np,"bitmasks,dp",607
"import sys
input = sys.stdin.readline
import math
import copy
import collections
from collections import deque
import heapq
import itertools
from collections import defaultdict
from collections import Counter

n,k = map(int,input().split())
mod = 998244353
dp = [[[0 for z in range(2)] for j in range(k+1)] for i in range(n)]
# z= 0: bb, 1:bw, 2:wb, 3=ww
dp[0][1][0] = 1
if k>=2:
    dp[0][2][1] = 1
for i in range(1,n):
    for j in range(1,k+1):
        dp[i][j][0] += dp[i-1][j-1][0]+dp[i-1][j][0]+2*dp[i-1][j][1]
        dp[i][j][0]%=mod
        if j-2>=0:
            dp[i][j][1] += 2*dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i-1][j-2][1]
        else:
            dp[i][j][1] += dp[i-1][j-1][0]+dp[i-1][j][1]+dp[i][j-1][0]
        dp[i][j][1]%=mod
ans = 0
for z in range(2):
    ans+=dp[n-1][k][z]
ans*=2
print(ans%mod)
# for row in dp:
#     print(row)",np,"bitmasks,dp",851
"n,k=map(int,input().split())
mod=998244353

NEXT={(0,1):2,(1,2):2}#ww or wh,point k,場合の数

for i in range(1,n):
    NOW=NEXT
    NEXT=dict()
    for key in NOW:
        
        

        if key[0]==0:
            if k-(n-i)*2<=key[1]<=k:
                NEXT[key]=NEXT.get(key,0)+NOW[key]
            if k-(n-i)*2<key[1]+1<=k:
                NEXT[(0,key[1]+1)]=NEXT.get((0,key[1]+1),0)+NOW[key]
                NEXT[(1,key[1]+1)]=NEXT.get((1,key[1]+1),0)+NOW[key]*2%mod


        else:
            if k-(n-i)*2<=key[1]<=k:
                NEXT[key]=NEXT.get(key,0)+NOW[key]
                NEXT[(0,key[1])]=NEXT.get((0,key[1]),0)+NOW[key]*2%mod

            if k-(n-i)*2<key[1]+2<=k:
                NEXT[(1,key[1]+2)]=NEXT.get((1,key[1]+2),0)+NOW[key]
        #print(NOW,NEXT)




ANS=0
for key in NEXT:
    if key[1]==k:
        ANS=(ANS+NEXT[key])%mod

print(ANS)
",np,"bitmasks,dp",868
"
mod = 998244353
N,K = map(int, input().split())

dp = [[[0]*(K+2) for i in range(2)] for i in range(N)]
dp[0][0][0] = 1
dp[0][1][1] = 1

for i in range(1,N):
    for b in range(K):
        dp[i][0][b]   += dp[i-1][0][b]
        dp[i][0][b]   += dp[i-1][1][b]
        dp[i][0][b]   += dp[i-1][1][b]
        dp[i][0][b+1] += dp[i-1][0][b]
        dp[i][0][b]   %= mod

        dp[i][1][b+1] += dp[i-1][0][b]
        dp[i][1][b]   += dp[i-1][1][b]
        dp[i][1][b+2] += dp[i-1][1][b]
        dp[i][1][b+1] += dp[i-1][0][b]
        dp[i][1][b] %= mod

ans = 0
for x in range(2):
    ans += dp[N-1][x][K-1]

print(ans*2%mod)
",np,"bitmasks,dp",624
"import itertools

n, k = [int(i) for i in input().split()]

kas = [[0,0,0,0],[1,0,0,1],[0,1,1,0]]

mmm = 998244353

def count_k(ka, k, t):
    if t == 0:#00
        return ka[k][0] + ka[k][1] + ka[k][2] + ka[k-1][3]
    if t == 1:#10
        return ka[k-1][0] + ka[k][1] + ka[k-2][2] + ka[k-1][3]
    if t == 2:#01
        return ka[k-1][0] + ka[k-2][1] + ka[k][2] + ka[k-1][3]
    if t == 3:#11
        return ka[k-1][0] + ka[k][1] + ka[k][2] + ka[k][3]

for i in range(1, n):
    if len(kas) < k + 1:
        kas.append([0,0,0,0])
        kas.append([0,0,0,0])
    for kk in range(min(len(kas)-1, k), 1, -1):
        kas[kk] = [count_k(kas, kk, t) % mmm for t in range(4)]

print(sum(kas[k]) % mmm if k < len(kas) else 0)
",np,"bitmasks,dp",724
"n,k = map(int,input().split())
mod = 998244353
dp = [[[0,0]for j in range(2*n+1)] for i in range(n)]
dp[0][0][0] = dp[0][1][1] = 1
for i in range(1,n):
  for j in range(2*n-1):
    dp[i][j][0] +=  (dp[i-1][j][0] + dp[i-1][j][1] + dp[i-1][j][1]) %mod
    dp[i][j+1][0] += dp[i-1][j][0] % mod
    dp[i][j+1][1] += (dp[i-1][j][0] + dp[i-1][j][0])%mod
    dp[i][j][1] += dp[i-1][j][1] %mod
    dp[i][j+2][1] += dp[i-1][j][1] %mod
print(sum(dp[n-1][k-1])*2%mod)",np,"bitmasks,dp",456
"n, k = map(int, input().split())
same = [0] * (k + 1)
diff = [0] * (k + 1)
mod = 998244353
same[1] = 2
if k > 1 : diff[2] = 2
for i in range (n - 1) :
    newsame = [0] * (k + 1)
    newdiff = [0] * (k + 1)
    for i in range (1, k + 1) : newsame[i] = (same[i] + same[i - 1] + 2 * diff[i]) % mod
    for i in range (2, k + 1) : newdiff[i] = (2 * same[i - 1] + diff[i] + diff[i - 2]) % mod
    same = newsame ; diff = newdiff
print((same[-1] + diff[-1]) % mod)
",np,"bitmasks,dp",460
"n, K = map(int, input().split())
dp = [[[0] * 4 for j in range(K + 2)] for i in range(n)]
MOD = 998244353
dp[0][1][0] = 1
dp[0][1][1] = 1
dp[0][2][2] = 1
dp[0][2][3] = 1
for i in range(n - 1):
    for j in range(1, K + 1):
        if j < K + 1:
            for k in range(4):
                    dp[i + 1][j][k] += dp[i][j][k]
                    dp[i + 1][j][k] %= MOD

            for k in range(2):
                dp[i + 1][j][k] += dp[i][j][2]
                dp[i + 1][j][k] %= MOD

            for k in range(2):
                dp[i + 1][j][k] += dp[i][j][3]
                dp[i + 1][j][k] %= MOD

    for j in range(1, K):
        for k in range(4):
            if k != 0:
                dp[i + 1][j + 1][k] += dp[i][j][0]
                dp[i + 1][j + 1][k] %= MOD

        for k in range(4):
            if k != 1:
                dp[i + 1][j + 1][k] += dp[i][j][1]
                dp[i + 1][j + 1][k] %= MOD

        if j + 2 < K + 1:
            dp[i + 1][j + 2][2] += dp[i][j][3]
            dp[i + 1][j + 2][2] %= MOD
            dp[i + 1][j + 2][3] += dp[i][j][2]
            dp[i + 1][j + 2][3] %= MOD

num = 0
for i in range(4):
    num += dp[n - 1][K][i]
    num %= MOD

print(num)",np,"bitmasks,dp",1202
"n,k = list(map(int,input().split()))
limit = 998244353


if k > 2*n:
    print(0)
elif k == 1 or k == 2*n:
    print(2)
else:
    same = [0] * (k+1)
    same[1] = 2

    diff = [0] * (k+1)
    diff[2] = 2

    for i in range(2, n+1):
        for j in range(min(k, 2*i), 1, -1):

            same[j] = same[j] + 2*diff[j] + same[j-1]
            same[j] %= limit

            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]
            diff[j] %= limit

    print((same[k] + diff[k]) % limit)",np,"bitmasks,dp",487
"n,k = list(map(int,input().split()))

# modulo divisor
limit = 998244353


if k > 2*n:
    print(0)
elif k == 1 or k == 2*n:
    print(2)
else:
    same = [0] * (k+1)
    same[1] = 2

    diff = [0] * (k+1)
    diff[2] = 2

    for i in range(2, n+1):
        for j in range(min(k, 2*i), 1, -1):

            same[j] = same[j] + 2*diff[j] + same[j-1]
            same[j] %= limit

            diff[j] = diff[j] + 2*same[j-1] + diff[j-2]
            diff[j] %= limit

    print((same[k] + diff[k]) % limit)",np,"bitmasks,dp",505
"n,k = [int(x) for x in input().split()]
dp = [[[0 for _ in range(4)] for _ in range(k+2)] for _ in range(2)]
dp[1][2][0] = 1
dp[1][2][1] = 1
dp[1][1][2] = 1
dp[1][1][3] = 1



for n1 in range(1,n):
    for k1 in range(1,k+1):
        
        dp[0][k1][0] = dp[1][k1][0]
        dp[0][k1][1] = dp[1][k1][1]
        dp[0][k1][2] = dp[1][k1][2]
        dp[0][k1][3] = dp[1][k1][3]
        
        dp[1][k1][0] = (dp[0][k1][0] + (dp[0][k1-2][1] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 
        
        dp[1][k1][1] = (dp[0][k1][1] + (dp[0][k1-2][0] if k1-2>=0 else 0) + dp[0][k1-1][2] + dp[0][k1-1][3])% 998244353 
        
        dp[1][k1][2] = (dp[0][k1][2] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][3])% 998244353 
        
        dp[1][k1][3] = (dp[0][k1][3] + (dp[0][k1][1]) + dp[0][k1][0] + dp[0][k1-1][2])% 998244353 
total = 0
#print(dp)
for i in range(4):
    total += dp[1][k][i] % 998244353 
#print(dp)
print(total% 998244353 )
        
        
                        
",np,"bitmasks,dp",1012
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------

def main():
    n, k = RLL()
    dp = [[0]*4 for _ in range(k+2)]
    dp[1][0] = 1
    dp[1][3] = 1
    dp[2][1] = 1
    dp[2][2] = 1
    tag = 0
    for i in range(2, n+1):
        new = [[0]*4 for _ in range(k+2)]
        for j in range(1, k+2):
            for l in range(4):
                tag+=1
                new[j][l] = ((dp[j][l])%mod + (new[j][l])%mod)%mod
                if l==0 or l==3:
                    new[j][l] = ((dp[j-1][l^3])%mod + (new[j][l])%mod)%mod
                    new[j][l] = (((dp[j][1])%mod+(dp[j][2])%mod) + (new[j][l])%mod)%mod
                elif l==1 or l==2:
                    new[j][l] = (((dp[j-1][0])%mod+(dp[j-1][3])%mod) + (new[j][l])%mod)%mod
                    if j-2>=0: new[j][l] = ((dp[j-2][l^3])%mod + (new[j][l])%mod)%mod
        dp = new
    print(sum(dp[k])%mod)

if __name__ == ""__main__"":
    main()

",np,"bitmasks,dp",3194
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------

def main():
    n, k = RLL()
    dp = [[0]*4 for _ in range(k+2)]
    dp[1][0] = 1
    dp[1][3] = 1
    dp[2][1] = 1
    dp[2][2] = 1

    for i in range(2, n+1):
        new = [[0]*4 for _ in range(k+2)]
        for j in range(1, k+2):
            for l in range(4):
                new[j][l] += dp[j][l]
                if l==0 or l==3:
                    new[j][l]+=dp[j-1][l^3]
                    new[j][l]+=(dp[j][1]+dp[j][2])
                elif l==1 or l==2:
                    new[j][l]+=(dp[j-1][0]+dp[j-1][3])
                    if j-2>=0: new[j][l]+=dp[j-2][l^3]
                new[j][l] = new[j][l]%mod
        dp = new
    print(sum(dp[k])%mod)

if __name__ == ""__main__"":
    main()

",np,"bitmasks,dp",3037
"import sys
import math
from collections import defaultdict,deque
import heapq
n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):
    
    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]
        '''dp[i+1][j][0]+=dp[i][j][0]
        dp[i+1][j][1]+=dp[i][j][1]
        dp[i+1][j][2]+=dp[i][j][2]
        dp[i+1][j][3]+=dp[i][j][3]
        dp[i+1][j+1][0]+=dp[i][j][2]+dp[i][j][3]
        dp[i+1][j+1][1]+=dp[i][j][2]+dp[i][j][3]
        dp[i+1][j+1][2]+=dp[i][j][0]+dp[i][j][1]
        dp[i+1][j+1][3]+=dp[i][j][0]+dp[i][j][1]
        dp[i+1][j+2][2]+=dp[i][j][3]
        dp[i+1][j+2][3]+=dp[i][j][2]'''
        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
#print(dp,'dp')
'''for i in range(n):
    print(dp[i])'''
#ans=0
#print(dp,'dp')
ans=sum(dp[k])
ans%=mod
print(ans)
                
            
            
                              
",np,"bitmasks,dp",1609
"import sys
import math
from collections import defaultdict,deque
import heapq
n,k=map(int,sys.stdin.readline().split())

mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):
    
    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]
        
        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)
                
            
            
                              
",np,"bitmasks,dp",1121
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
from collections import defaultdict
from itertools import permutations
 

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
#-------------------game starts now-----------------------------------------------------
n,k=map(int,sys.stdin.readline().split())
 
mod=998244353
dp=[[0,0,0,0] for x in range(k+3)]
dp[1][0]=1
dp[1][1]=1
dp[2][2]=1
dp[2][3]=1
newdp=[[0,0,0,0] for x in range(k+3)]
for i in range(n-1):
    
    for j in range(k+1):
        newdp[j+1][1]+=dp[j][0]
        newdp[j+1][3]+=dp[j][0]
        newdp[j+1][2]+=dp[j][0]
        newdp[j][0]+=dp[j][0]
        newdp[j][1]+=dp[j][1]
        newdp[j+1][3]+=dp[j][1]
        newdp[j+1][2]+=dp[j][1]
        newdp[j+1][0]+=dp[j][1]
        newdp[j][1]+=dp[j][2]
        newdp[j+2][3]+=dp[j][2]
        newdp[j][2]+=dp[j][2]
        newdp[j][0]+=dp[j][2]
        newdp[j][1]+=dp[j][3]
        newdp[j][3]+=dp[j][3]
        newdp[j+2][2]+=dp[j][3]
        newdp[j][0]+=dp[j][3]
        
        for a in range(3):
            for b in range(4):
                newdp[a+j][b]%=mod
    for a in range(k+3):
        for b in range(4):
            dp[a][b]=newdp[a][b]
            newdp[a][b]=0
ans=sum(dp[k])
ans%=mod
print(ans)",np,"bitmasks,dp",2987
"#0 denotes white white
#1 denotes white black
#2 denotes black white
#3 denotes black black

pri=998244353
dp=[[[0 for i in range(2001)] for i in range(1001)] for i in range(2)]
n,k=map(int,input().split())
#dp[i][j][k] i denotes type  j denotes index k denotes bycoloring
for i in range(1,n+1):
    if(i==1):
        dp[0][i][1]=2
        dp[1][i][2]=2
    
        
        
        continue;
    for j in range(1,(2*i)+1):
        dp[0][i][j]=(dp[0][i-1][j])+(dp[0][i-1][j-1])+(2*(dp[1][i-1][j]))
    
        
       
        dp[0][i][j]%=pri
        dp[1][i][j]=(2*dp[0][i-1][j-1])+(dp[1][i-1][j])+(dp[1][i-1][j-2])
        dp[0][i][j]%=pri
        dp[1][i][j]%=pri
y=dp[0][n][k]+dp[1][n][k]
y%=pri
print(y)
        
        
",np,"bitmasks,dp",731
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np,"bitmasks,dp",716
"from sys import stdin

add = lambda a, b: (a + b) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np,"bitmasks,dp",704
"from sys import stdin

add = lambda a, b: (a + b) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np,"bitmasks,dp",700
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(n)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i][val][k2] = add(mem[i - 1][j][k1], mem[i][val][k2])

print(sum(mem[-1][k]) % mod)
",np,"bitmasks,dp",712
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, k + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2])

    for j in range(1, k + 1):
        for k1 in range(4):
            mem[(i - 1) & 1][j][k1] = 0

print(sum(mem[(n - 1) & 1][k]) % mod)
",np,"bitmasks,dp",834
"from sys import stdin

add = lambda a, b: (a % mod + b % mod) % mod
mod, bits = 998244353, ['00', '01', '10', '11']
pat = [[0, 1, 1, 1], [0, 0, 2, 0], [0, 2, 0, 0], [1, 1, 1, 0]]

n, k = map(int, stdin.readline().split())
mem = [[[0 for _ in range(4)] for _ in range(k + 1)] for _ in range(2)]

for i in range(4):
    val = min(bits[i].count('0'), 1) + min(bits[i].count('1'), 1)
    if val <= k:
        mem[0][val][i] = 1

for i in range(1, n):
    for j in range(1, i * 2 + 1):
        for k1 in range(4):
            for k2 in range(4):
                val = j + pat[k1][k2]
                if val <= k:
                    mem[i & 1][val][k2] = add(mem[(i - 1) & 1][j][k1], mem[i & 1][val][k2])

    for j in range(1, min(i * 2 + 1, k + 1)):
        for k1 in range(4):
            mem[(i - 1) & 1][j][k1] = 0

print(sum(mem[(n - 1) & 1][k]) % mod)
",np,"bitmasks,dp",854
"ch_0={0:[0,1,2],2:[2],1:[1],3:[1,2,3]}
ch_1={0:[3],3:[0],1:[0,3],2:[0,3]}
ch_2={0:[],3:[],2:[1],1:[2]}
N=998244353
n,k=map(int,input().strip().split("" ""))
dp=[[[0]*4 for j in range(k+5)] for i in range(n+5)]
dp[0][1][3]=1
dp[0][1][0]=1
dp[0][2][1]=1
dp[0][2][2]=1

for i in range(1,n):
    for j in range(1,k+1):
        for mask in range(4):
            for t in ch_0[mask]:
                dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j][t])%N
            if j>1:
                for t in ch_1[mask]:
                    dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-1][t])%N
                if j>2:
                    for t in ch_2[mask]:
                        dp[i][j][mask]=(dp[i][j][mask]+dp[i-1][j-2][t])%N
ans=0
for mask in range(4):
    ans=(ans+dp[n-1][k][mask])%N
print(ans)
",np,"bitmasks,dp",778
"import math,sys,bisect,heapq
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
#sys.setrecursionlimit(200000000)
int1 = lambda x: int(x) - 1
input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
ilele = lambda: map(int,input().split())
alele = lambda: list(map(int, input().split()))
ilelec = lambda: map(int1,input().split())
alelec = lambda: list(map(int1, input().split()))
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
#MOD = 1000000000 + 7
def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])
    
MOD = 998244353

N,K = ilele()
if K == 1 or K == 2*N:
    print(2)
    exit(0)
dp = list3d(N+1,4,K+1,0)
dp[1][0][1] = 1
dp[1][3][1] = 1
dp[1][1][2] = 1
dp[1][2][2] = 1

for n in range(2,N+1):
    for k in range(1,K+1):
        dp[n][0][k] = ((dp[n-1][0][k]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        dp[n][3][k] = ((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k]+dp[n-1][3][k])%MOD)%MOD
        if k > 1:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][2][k-2] +dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1]+dp[n-1][1][k-2])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD
        else:
            dp[n][1][k]=((dp[n-1][0][k-1]+dp[n-1][1][k])%MOD+(dp[n-1][3][k-1])%MOD)%MOD
            dp[n][2][k]=((dp[n-1][0][k-1])%MOD+(dp[n-1][2][k]+dp[n-1][3][k-1])%MOD)%MOD

print(((dp[N][0][K]+dp[N][1][K])%MOD+(dp[N][2][K]+dp[N][3][K])%MOD)%MOD)
            ",np,"bitmasks,dp",1616
"import sys
from array import array  # noqa: F401


def readline() -> str: return sys.stdin.buffer.readline().decode('utf-8')


n, k = map(int, readline().split())
mod = 998244353
dp = [[array('i', [0])*(2*n+3) for _ in range(n)] for _ in range(4)]
dp[0][0][1] = dp[3][0][1] = 1
dp[1][0][2] = dp[2][0][2] = 1

for i in range(n-1):
    for j in range(k+1):
        for sbit in range(4):
            for tbit in range(4):
                add = (
                    1 if sbit == 3 and tbit == 0 or sbit == 0 and tbit == 3 else
                    (1 if (sbit & 2) != (tbit & 2) and (tbit == 1 or tbit == 2) else 0)
                    + (1 if (sbit & 1) != (tbit & 1) and (tbit == 1 or tbit == 2) else 0)
                )
                dp[tbit][i+1][j+add] += dp[sbit][i][j]
                if dp[tbit][i+1][j+add] >= mod:
                    dp[tbit][i+1][j+add] -= mod

ans = sum(dp[bit][-1][k] for bit in range(4)) % mod
print(ans)
",np,"bitmasks,dp",935
"N = 1010

dp = [[[0] * 4 for j in range(N*2)] for i in range(N)]
dp[0][1][0] = dp[0][1][1] = dp[0][2][2] = dp[0][2][3] = 1
m = 998244353
for i in range(N-1):
    for j in range(1,N*2-5):
        for me in range(4):
            for he in range(4):
                if me <= 1:
                    if he <= 1:
                        dp[i+1][j+(he!=me)][he] = (dp[i+1][j+(he!=me)][he] + dp[i][j][me]) % m
                    else:
                        dp[i+1][j+1][he] = (dp[i+1][j+1][he] + dp[i][j][me]) % m
                else:
                    if he <= 1:
                        dp[i+1][j][he] = (dp[i+1][j][he] + dp[i][j][me]) % m
                    else:
                        dp[i+1][j + (he != me)*2][he] = (dp[i+1][j+(he!=me)*2][he] + dp[i][j][me]) % m
n,k = map(int,input().split())
print(sum(dp[n-1][k])%m)                        
",np,"bitmasks,dp",849
"import sys
def read():
    return int(input())
def reads():
    return [int(x) for x in input().split()]
N,M=reads()
table=[reads() for i in range(N)]
A=[[0]*N for i in range(N)]
B=[[0]*N for i in range(N)]
for i in range(N):
    for j in range(N):
        res=10**9+7
        for k in range(M):
            res=min(res,abs(table[i][k]-table[j][k]))
        A[i][j]=res
        A[j][i]=res
        res=10**9+7
        for k in range(M-1):
            res=min(res,abs(table[i][k]-table[j][k+1]))
        B[i][j]=res
#print(table)
#print(A)
#print(B)
#A=[[10**9,2,3],[2,10**9,8],[1,5,10**9]]
#B=[[10**9,2,3],[2,10**9,8],[1,5,10**9]]
dp=[[-1]*N for i in range((1<<N) )]
def calc(mask,v):
    if dp[mask][v]!=-1:
        return dp[mask][v]
    res =0
    for u in range(N):
        if (mask & 1<<u) and u!=v:
            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))
    dp[mask][v]=res
    return dp[mask][v]
ans=0
for i in range(N):
    dp = [[-1] * N for i in range((1 << N))]
    for k in range(N):
        if k==i:
            dp[1<<k][k]=10**9+7
        else:
            dp[1<<k][k]=0
    for j in range(N):
        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))
    #print(dp,ans)
print(ans)",np,"binary search,bitmasks,brute force,dp,graphs",1192
"import sys
import copy

input = sys.stdin.readline

n,m=map(int,input().split())
MAT=[list(map(int,input().split())) for i in range(n)]

#n=15
#m=10000
#MAT=[list(range(j*j,j*j*(m+1),j*j)) for j in range(1,n+1)]


if n==1:
    ANS=10**10
    for i in range(1,m):
        if ANS>abs(MAT[0][i]-MAT[0][i-1]):
            ANS=abs(MAT[0][i]-MAT[0][i-1])
    print(ANS)
    sys.exit()



EDGE0=[[10**10]*n for i in range(n)]#iが0行目,jが最終行
EDGE1=[[10**10]*n for i in range(n)]
MAX=0
MIN=0

if m!=1:    
    for i in range(n):
        for j in range(n):

            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])
            
            if EDGE1[i][j]>MAX:
                MAX=EDGE1[i][j]

            EDGE0[i][j]=min([abs(MAT[i][k]-MAT[j][k-1]) for k in range(1,m)])
else:
    for i in range(n):
        for j in range(n):

            EDGE1[i][j]=EDGE1[j][i]=min([abs(MAT[i][k]-MAT[j][k]) for k in range(m)])
            
            if EDGE1[i][j]>MAX:
                MAX=EDGE1[i][j]
    

def Hamilton(start,USED,rest,last,weight):
    #print(start,USED,rest,last,weight,last*(1<<n)+USED)
    if MEMO[last*(1<<n)+USED]!=2:
        return MEMO[last*(1<<n)+USED]
    if rest==1:
        for i in range(n):
            if USED & (1<<i)==0:
                final=i
                break

        if EDGE0[start][final]>=weight and EDGE1[last][final]>=weight:
            #print(start,USED,rest,last,weight)

            MEMO[last*(1<<n)+USED]=1
            return 1
        else:
            #print(start,USED,weight,""!"")
            MEMO[last*(1<<n)+USED]=0
            return 0

    for j in range(n):
        if USED & (1<<j)==0 and EDGE1[last][j]>=weight:
            
            NEXT=USED+(1<<j)
            if Hamilton(start,NEXT,rest-1,j,weight)==1:
                #print(start,USED,rest,last,weight)
                MEMO[last*(1<<n)+USED]=1
                return 1
    else:
        #print(start,USED,weight,""?"")
        MEMO[last*(1<<n)+USED]=0
        return 0
        
    
while MAX!=MIN:
    #print(MAX,MIN)
    aveweight=(MAX+MIN+1)//2

    for start in range(n):
        MEMO=[2]*(n*1<<(n+1))
        START=1<<start
        if Hamilton(start,START,n-1,start,aveweight)==1:
            MIN=aveweight
            break
    else:
        MAX=aveweight-1

print(MAX)
",np,"binary search,bitmasks,brute force,dp,graphs",2301
"import sys
def read():
    return int(input())
def reads():
    return [int(x) for x in input().split()]
N,M=reads()
table=[reads() for i in range(N)]
A=[[0]*N for i in range(N)]
B=[[0]*N for i in range(N)]
for i in range(N):
    for j in range(N):
        res=10**9+7
        for k in range(M):
            res=min(res,abs(table[i][k]-table[j][k]))
        A[i][j]=res
        A[j][i]=res
        res=10**9+7
        for k in range(M-1):
            res=min(res,abs(table[i][k]-table[j][k+1]))
        B[i][j]=res

dp=[[-1]*N for i in range((1<<N) )]
def calc(mask,v):
    if dp[mask][v]!=-1:
        return dp[mask][v]
    res =0
    for u in range(N):
        if (mask & 1<<u) and u!=v:
            res =max(res,min(calc(mask^(1<<v),u),A[u][v]))
    dp[mask][v]=res
    return dp[mask][v]
ans=0
for i in range(N):
    dp = [[-1] * N for _ in range((1 << N))]
    for k in range(N):
        if k==i:
            dp[1<<k][k]=10**9+7
        else:
            dp[1<<k][k]=0
    for j in range(N):
        ans=max(ans,min(B[j][i],calc((1<<N)-1,j)))
print(ans)",np,"binary search,bitmasks,brute force,dp,graphs",1058
"import sys
from array import array  # noqa: F401
from typing import List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def solve(i, n, delta, delta2):
    inf = 2 * 10**9
    dp = [[-1] * n for _ in range(1 << n)]
    dp[(1 << i)][i] = inf
    stack = [(1 << i, i)]

    for t in range(1, n + 1):
        next_s = []
        for bit, v in stack:
            for dest in range(n):
                if (1 << dest) & bit:
                    continue
                if dp[bit | (1 << dest)][dest] == -1:
                    next_s.append((bit | (1 << dest), dest))
                dp[bit | (1 << dest)][dest] = max(dp[bit | (1 << dest)][dest], min(dp[bit][v], delta[v][dest]))

        stack = next_s

    return max(min(delta2[j][i], dp[-1][j]) for j in range(n) if i != j)


def main():
    n, m = map(int, input().split())
    matrix = [tuple(map(int, input().split())) for _ in range(n)]

    if n == 1:
        print(min(abs(x - y) for x, y in zip(matrix[0], matrix[0][1:])))
        exit()

    delta = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(i + 1, n):
            delta[i][j] = delta[j][i] = min(abs(x - y) for x, y in zip(matrix[i], matrix[j]))
    delta2 = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            delta2[i][j] = min((abs(x - y) for x, y in zip(matrix[i], matrix[j][1:])), default=2 * 10**9)

    print(max(solve(i, n, delta, delta2) for i in range(n)))


if __name__ == '__main__':
    main()
",np,"binary search,bitmasks,brute force,dp,graphs",1566
"#  author: ThePonyCoder
#  created: 23.06.2019, 21:58
#  filename: f.py
#  path: C:/Users/User/Desktop/python/Prog/CodeForces/rounds/cf_568/f.py

import os

# import random

# sys.setrecursionlimit(999999999)
import string

from math import inf
from functools import lru_cache

if os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \
        or os.environ['COMPUTERNAME'] == 'USER145':
    import pdb
    
    import sys
    
    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from pprint import pprint
    from hypothesis import given, settings
    from hypothesis import strategies as st


def ri():
    return [int(i) for i in input().split()]


def to_bits(l):
    ans = 0
    for i in l:
        ans |= (1 << i - 1)
    return ans


user_masks = [0 for i in range(1 << 10)]
pizzas = [[] for i in range(1 << 10)]


@lru_cache()
def count_sat_users(mask):
    ans = 0
    cmask = mask
    while cmask:
        ans += user_masks[cmask]
        cmask = (cmask - 1) & mask
    return ans


def main():
    n, m = ri()
    for _ in range(n):
        k, *a = ri()
        bits = to_bits(a)
        user_masks[bits] += 1
    
    ans = (float(-inf), float(inf), -1, -1)
    
    for i in range(m):
        c, k, *a = ri()
        bits = to_bits(a)
        pizzas[bits].append((c, i + 1, bits))  # цена, номер, маска
        pizzas[bits].sort()
        while len(pizzas[bits]) > 2:
            pizzas[bits].pop()
    # pprint(pizzas)
    
    for mask_F in range(1 << 9):
        for mask_S in range(1 << 9):
            if len(pizzas[mask_F]) and len(pizzas[mask_S]) \
                    and mask_F != mask_S:
                
                mask = mask_F | mask_S
                
                satisfied_users = count_sat_users(mask)
                
                f_pizza = next(iter(pizzas[mask_F]))
                s_pizza = next(iter(pizzas[mask_S]))
                
                summary_cost = 0
                summary_cost += f_pizza[0]
                summary_cost += s_pizza[0]
                
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))
                
                # bruting all masks
                bmask = mask
                while bmask:
                    satisfied_users += user_masks[bmask]
                    bmask = (bmask - 1) & mask
            
            if len(pizzas[mask_F]) == 2:
                satisfied_users = count_sat_users(mask_F)
                
                it = iter(pizzas[mask_F])
                
                f_pizza = next(it)
                s_pizza = next(it)
                summary_cost = 0
                summary_cost += f_pizza[0] + s_pizza[0]
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))
            
            if len(pizzas[mask_S]) == 2:
                satisfied_users = count_sat_users(mask_S)
                
                it = iter(pizzas[mask_S])
                
                f_pizza = next(it)
                s_pizza = next(it)
                summary_cost = 0
                summary_cost += f_pizza[0] + s_pizza[0]
                ans = max(ans,
                          (satisfied_users,
                           -summary_cost,
                           s_pizza[1],
                           f_pizza[1]))
    
    aans = [ans[2],ans[3]]
    aans.sort()
    print(*aans, sep=' ')


main()
",np,"bitmasks,brute force",3697
"n,tnow=map(int,input().split())
left=int("""".join([""1"" for i in range(n)]),2)
arr=[]
dp={}
for i in range(n):
    a,b=map(int,input().split())
    arr.append([a,b])
def recur(tnow,prevgenre,left):
    key=str(left)+""_""+str(prevgenre)
    if tnow==0:
        return 1
    elif key in dp:
        return dp[key]
    else:
        ans=0
        for i in range(n):
            if (left&(1<<i))!=0:
                if arr[i][0]<=tnow and arr[i][1]!=prevgenre:
                    left=left&(~(1<<i))
                    ans+=recur(tnow-arr[i][0],arr[i][1],left)
                    left=left|(1<<i)
        dp[key]= ans
        return ans
       
print(recur(tnow,4,left)%(10**9+7))
",np,"bitmasks,combinatorics,dp",677
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO,IOBase

def main():
    mod = 10**9+7
    n,T = map(int,input().split())
    y = 1<<n
    dp = [[0]*3 for _ in range(y)]
    # already taken ; genre
    peo = [list(map(int,input().split())) for _ in range(n)]
    # duration ; genre
    for ind,i in enumerate(peo):
        peo[ind][1] -= 1
        dp[1<<ind][i[1]] = 1
    for i in range(y):
        for j in range(3):
            if not dp[i][j]:
                continue
            mask = 1
            for k in range(n):
                if i&mask or peo[k][1] == j:
                    mask <<= 1
                    continue
                dp[i|mask][peo[k][1]] = (dp[i|mask][peo[k][1]]+dp[i][j])%mod
                mask <<= 1
    ans = 0
    for i in range(y):
        ans1,mask = 0,1
        for j in range(n):
            if i&mask:
                ans1 += peo[j][0]
            mask <<= 1
        if ans1 == T:
            ans = (ans+sum(dp[i]))%mod
    print(ans)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",np,"bitmasks,combinatorics,dp",2722
"import sys
input=sys.stdin.readline

mod=10**9+7
n,t=map(int,input().split())
a=[] #Denote song number by it's index in this list
for i in range(n):
    time,genre=map(int,input().split())
    genre-=1 #converting to 0-based indexing
    a.append((time,genre))
dp=[[0 for j in range(3)] for i in range(1<<n)] #dp[permuation of song][last genre of that permutation]
for i in range(n):
    dp[1<<i][a[i][1]]=1
for i in range(1<<n):
    for j in range(3):
        if(dp[i][j]==0):
            continue
        mask=1 #Will correspond to the kth bit, i.e 1<<k for each iteration, for the case of including the kth song 
        for k in range(n):
            if(i&mask or a[k][1]==j): #as we are not allowed to repeat same song or have same genre successively
                mask<<=1
                continue
            dp[i|mask][a[k][1]]=(dp[i|mask][a[k][1]]+dp[i][j])%mod
            mask<<=1
ans=0
for i in range(1<<n):
    mask=1
    duration=0
    for j in range(n):
        if(i&mask):
            duration+=a[j][0]
        mask<<=1
    if(duration==t):
        ans=(ans+sum(dp[i]))%mod
print(ans)
            
        
    
        
    
    ",np,"bitmasks,combinatorics,dp",1148
"from math import factorial


def lol(n):
    if n == 1:
        yield [0]
        yield [1]
    else:
        for p in lol(n - 1):
            p.append(0)
            yield p
            p[-1] = 1
            yield p
            p.pop()


def sp(g1, g2, g3, f):
    if g1 == 0:
        if g2 == g3:
            return 2
        elif abs(g2 - g3) == 1:
            return 1
        else:
            return 0
    elif g2 == 0:
        if g1 == g3:
            return 2
        elif abs(g1 - g3) == 1:
            return 1
        else:
            return 0
    elif g3 == 0:
        if g2 == g1:
            return 2
        elif abs(g2 - g1) == 1:
            return 1
        else:
            return 0
    else:
        if f == 1:
            b = sp(g1, g2 - 1, g3, 2)
            c = sp(g1, g2, g3 - 1, 3)
            return b + c
        elif f == 2:
            a = sp(g1 - 1, g2, g3, 1)
            c = sp(g1, g2, g3 - 1, 3)
            return a + c
        elif f == 3:
            a = sp(g1 - 1, g2, g3, 1)
            b = sp(g1, g2 - 1, g3, 2)
            return a + b
        else:
            a = sp(g1 - 1, g2, g3, 1)
            b = sp(g1, g2 - 1, g3, 2)
            c = sp(g1, g2, g3 - 1, 3)
            return a + b + c


n, T = map(int, input().split())
S = []
cnt = 0
M = 10 ** 9 + 7
for i in range(n):
    S.append(list(map(int, input().split())))
for p in lol(n):
    d = 0
    g1, g2, g3 = 0, 0, 0
    for i in range(n):
        if p[i]:
            d += S[i][0]
            if S[i][1] == 1:
                g1 += 1
            elif S[i][1] == 2:
                g2 += 1
            elif S[i][1] == 3:
                g3 += 1
    if d == T:
        cnt += factorial(g1) * factorial(g2) * factorial(g3) * sp(g1, g2, g3, 0)
        cnt %= M
print(cnt)",np,"bitmasks,combinatorics,dp",1769
"import sys
input = sys.stdin.readline

n,T=map(int,input().split())
S=[list(map(int,input().split())) for i in range(n)]

DP=[[0]*(4) for i in range(T+1)]
mod=10**9+7

from functools import lru_cache
@lru_cache(maxsize=None)
def calc(used,recent,time):
    ANS=0
    for i in range(n):
        #print(i,used)
        if i in used:
            continue
        if time+S[i][0]>T:
            continue
        if S[i][1]==recent:
            continue
        if time+S[i][0]==T:
            ANS+=1
        if time+S[i][0]<T:
            used2=list(used)+[i]
            used2.sort()
            recent2=S[i][1]
            time2=time+S[i][0]
            ANS=(ANS+calc(tuple(used2),recent2,time2))%mod

    return ANS

print(calc(tuple(),-1,0)%mod)
    
",np,"bitmasks,combinatorics,dp",751
"from copy import *
n,T=map(int,raw_input().split())
cl=set(())
di={(0,0,0,T):1}
for k in range(n):
    t,g=map(int,raw_input().split())
    an=deepcopy(di)
    for k in an:
        nc=list(k)
        nc[3]-=t
        nc[g-1]+=1
        if nc[3]>=0:
            nc=tuple(nc)
            if nc in di:
                di[nc] += an[k]
            else:
                di[nc] = an[k]
nd={(1,0,0,0):1,(0,1,0,1):1,(0,0,1,2):1}
mo=10**9+7
def nb(tu):
    #print(tu)
    if not(tu in nd):
        if tu[tu[3]]==0:
            nd[tu] =0
        else:
            nt=list(tu)
            nt[tu[3]]-=1
            nt[3]=(nt[3]+1)%3
            nt2=nt[:]
            nt2[3]=(nt2[3]+1)%3
            nd[tu]=(tu[tu[3]]*(nb(tuple(nt))+nb(tuple(nt2))))%mo
    return nd[tu]

#print([(di[k],k[:3]) for k in di if k[3]==0])
print(sum(di[k]*(nb(k[:3]+(1,))+nb(k[:3]+(0,))+nb(k[:3]+(2,))) for k in di if k[3]==0)%mo)
#print(nd)
",np,"bitmasks,combinatorics,dp",908
"from functools import lru_cache

P = 10**9+7
N, T = map(int, input().split())
A = [[], [], []]
X = []
for _ in range(N):
    t, g = map(int, input().split())
    X.append((t, g))

@lru_cache(maxsize=None)
def calc(x, pr, t):
    if t < 0:
        return 0
    if t == 0:
        return 1
    if x == 0:
        return 0
    
    ans = 0
    for i in range(15):
        if x & (1<<i):
            if X[i][1] != pr:
                y = x ^ (1<<i)
                ans = (ans + calc(y, X[i][1], t-X[i][0])) % P
    return ans
    
print(calc(2**N-1, -1, T))",np,"bitmasks,combinatorics,dp",553
"def popcount(i):
    assert 0 <= i < 0x100000000
    i = i - ((i >> 1) & 0x55555555)
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)
    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24

N, T = map(int, input().split())
TG = [list(map(int, input().split())) for _ in range(N)]
mod = 10**9+7


dp = [[0]*(2**N) for _ in range(4)]
for i in range(1, 4):
    dp[i][0] = 1

for S in range(2**N):
    if popcount(S) == 1:
        dp[TG[(S&(-S)).bit_length() - 1][1]][S] = 1
    for i in range(1, 4):
        for j in range(N):
            if S & (2**j) or i == TG[j][1]:
                continue
            dp[TG[j][1]][S|(2**j)] = (dp[TG[j][1]][S|(2**j)] + dp[i][S]) % mod

table = [0]*(2**N)
for S in range(2**N):
    table[S] = sum(TG[j][0] for j in range(N) if 2**j & S)
    
ans = 0
for S in range(2**N):
    if table[S] == T:
        for i in range(1, 4):
            ans = (ans + dp[i][S]) % mod

print(ans)",np,"bitmasks,combinatorics,dp",932
"#  author: ThePonyCoder
#  created: 24.06.2019, 10:58
#  filename: g1.py
#  path: E:/Projects/CodeForces/rounds/cf_568/g1.py

import os

# import random

# sys.setrecursionlimit(999999999)
import string

from math import inf
from functools import lru_cache

if os.getcwd() == 'C:\\Users\\User\\Desktop\\python\\Prog\\CodeForces' \
        or os.environ['COMPUTERNAME'] == 'RYZEN':
    import pdb
    
    import sys
    
    pdb = pdb.Pdb(stdin=sys.stdin, stdout=sys.stdout)
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
    from pprint import pprint
    from hypothesis import given, settings
    from hypothesis import strategies as st


def ri():
    return [int(i) for i in input().split()]


MOD = int(1e9 + 7)


def main():
    n, t = ri()
    songs = []
    result = 0
    for i in range(n):
        songs.append(ri())  # [время, жанр]
        songs[-1][1] -= 1
    
    dp = [[0, 0, 0] for i in range(1 << n)]
    
    for ind, it in enumerate(songs):
        dp[1 << ind][it[1]] = 1
    
    for mask in range(1, 1 << n):
        for genre in range(3):
            for nsng, sng in enumerate(songs):
                if sng[1] != genre and ((mask >> nsng) & 1) == 0:
                    dp[mask | (1 << nsng)][sng[1]] += dp[mask][genre]
                    if (mask | (1 << nsng)) == 4:
                        asdddd = 1
            
            sm = 0
            for ind, it in enumerate(reversed(bin(mask)[2:])):
                if it == '1':
                    sm += songs[ind][0]
            if sm == t:
                result += dp[mask][genre]
                result %= MOD
    
    print(result)


main()
",np,"bitmasks,combinatorics,dp",1657
"from itertools import combinations
def out1(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==1 and b==0 and c==0:
        return 1
    return a*(out2(a-1,b,c)+out3(a-1,b,c))
def out2(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==1 and c==0:
        return 1
    return b*(out1(a,b-1,c)+out3(a,b-1,c))
def out3(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==0 and c==1:
        return 1
    return c*(out2(a,b,c-1)+out1(a,b,c-1))
def column(matrix, i):
    return [row[i] for row in matrix]
    
N, T = [int(x) for x in input().split()]
A = []
s = 0
for i in range(N):
    A.append([int(x) for x in input().split()])
for i in range(1,N+1):
    comb = list(combinations(A, i))
    for x in comb:
        if sum(column(x,0))==T:
            a = column(x,1).count(1)
            b = column(x,1).count(2)
            c = column(x,1).count(3)
            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))
print(s%1000000007)",np,"bitmasks,combinatorics,dp",968
"from itertools import*
def out1(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==1 and b==0 and c==0:
        return 1
    return a*(out2(a-1,b,c)+out3(a-1,b,c))
def out2(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==1 and c==0:
        return 1
    return b*(out1(a,b-1,c)+out3(a,b-1,c))
def out3(a,b,c):
    if a<0 or b<0 or c<0:
        return 0
    if a==0 and b==0 and c==1:
        return 1
    return c*(out2(a,b,c-1)+out1(a,b,c-1))
def column(matrix, i):
    return [row[i] for row in matrix]
N, T = [int(x) for x in raw_input().split()]
A = []
s = 0
for i in range(N):
    A.append([int(x) for x in raw_input().split()])
for i in range(1,N+1):
    comb = list(combinations(A, i))
    for x in comb:
        if sum(column(x,0))==T:
            a = column(x,1).count(1)
            b = column(x,1).count(2)
            c = column(x,1).count(3)
            s+=(out1(a,b,c)+out2(a,b,c)+out3(a,b,c))
print(s%1000000007)",np,"bitmasks,combinatorics,dp",959
"from itertools import combinations

def findsum(comb):
    sum = 0
    for song in comb:
        sum += song[0]
    return sum

def finda(a,b,c):
    if a == 0:
        return 0
    if a == 1 and b == 0 and c == 0:
        return 1
    else:
        return (a * findb(a-1,b,c)+ a*findc(a-1,b,c))

def findb(a,b,c):
    if b == 0:
        return 0
    if b == 1 and a == 0 and c == 0:
        return 1
    else:
        return (b * finda(a,b-1,c)+ b*findc(a,b-1,c))

def findc(a,b,c):
    if c == 0:
        return 0
    if c == 1 and a == 0 and b == 0:
        return 1
    else:
        return (c * finda(a,b,c-1)+ c*findb(a,b,c-1))



n, T = map(int,input().split())
songs = []
total_combinations = 0
for i in range(n):
    t, g = map(int,input().split())
    songs.append([t,g])

for i in range(1, n+1):
    allcomb = list(combinations(songs,i))
    for comb in allcomb:
        sum = findsum(comb)

        if sum == T:
            a = 0
            b = 0
            c = 0
            for song in comb:
                if song[1] == 1:
                    a += 1
                elif song[1] == 2:
                    b += 1
                else:
                    c += 1
            total_combinations += finda(a,b,c)+findb(a,b,c)+findc(a,b,c)
total_combinations = total_combinations%1000000007
print(total_combinations)",np,"bitmasks,combinatorics,dp",1328
"def main():
    t = int(input())
    for _ in range(t):
        n, m = map(int, input().split())
        l = []; board = []
        for i in range(n):
            li = list(map(int, input().split()))
            board.append(li)
            for j in range(m):
                l.append((li[j], j))
        l.sort(key = lambda x : x[0], reverse = True)
        idxs = set()
        z = 0
        while len(idxs) < min(n, m):
            curr = l[z]
            idxs.add(curr[1])
            z += 1
        idxs = list(idxs)
        total = 0
        for i in range(n ** n):
            rotations = []; num = i
            for j in range(n - 1, -1, -1):
                nj = n ** j
                q = num // nj
                num -= q * nj
                rotations.append(q)
            subtotal = 0
            #print(board, idxs, rotations)
            for k in range(n):
                #print([board[(k + rotations[col]) % n][idxs[col]] for col in range(n)])
                subtotal += max(board[(k + rotations[col]) % n][idxs[col]] for col in range(min(n, m)))
            total = max(total, subtotal)
        print(total)
main()",np,"bitmasks,brute force,dp,greedy,sortings",1135
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def main():
    inf = -float(""inf"")
    for _ in range(int(input())):
        n,m = map(int,input().split())
        a = [list(map(int,input().split())) for _ in range(n)]
        y = 1<<n
        dp = [[0]+[inf]*(y-1) for _ in range(m+1)]
        for i in range(1,m+1):
            for shift in range(n):
                for mask1 in range(y):
                    for mask2 in range(y):
                        new = mask1^mask2
                        if new&mask1:
                            continue
                        mm,add = 1,0
                        for x in range(n):
                            if mm&new:
                                tt = x+shift
                                if tt >= n:
                                    tt -= n
                                add += a[tt][i-1]
                            mm <<= 1
                        dp[i][mask2] = max(dp[i][mask2],dp[i-1][mask1]+add)
        print(dp[m][y-1])

# Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
if __name__ == ""__main__"":
    main()",np,"bitmasks,brute force,dp,greedy,sortings",2750
"for _ in range(int(input())):
    n,m=map(int,input().split())

    a=[[int(x) for x in input().split()] for j in range(n)]

    x=[[a[i][j] for i in range(n)] for j  in range(m)]
    x.sort(key=lambda xx:-max(xx))
    dp=[[0 for i in range(1<<n)] for j in range(m+1)]
    an=0

    for i in range(m):
        for prev in range(1<<n):
            for pres in range(1<<n):

                for j in range(n):

                    ma=0
                    if prev^pres!=prev+pres:
                        continue
                    for st in range(n):

                        if pres&(1<<st):
                            ma+=x[i][(st+j)%n]

                    dp[i+1][pres^prev]=max(dp[i+1][pres^prev],dp[i][prev]+ma)

    print(dp[m][(1<<n)-1])",np,"bitmasks,brute force,dp,greedy,sortings",747
"
def naiveSolve():
    
    
    
    return



def main():
    
    t=int(input())
    allans=[]
    for _ in range(t):
        n,m=readIntArr()
        grid=[]
        for __ in range(n):
            grid.append(readIntArr())
        columns=[]
        for col in range(m):
            temp=[grid[i][col] for i in range(n)]
            columns.append(temp)
        
        valCol=[] # (value, column)
        for i in range(n):
            for j in range(m):
                valCol.append((grid[i][j],j))
        valCol.sort(reverse=True)
        
        # try all possible shifts for top n columns
        topCols=set()
        for val,col in valCol:
            topCols.add(col)
            if len(topCols)==n:
                break
        
        # try all configurations
        m2=len(topCols)
        grid2=[[-1 for __ in range(m2)] for ___ in range(n)]
        topColsList=list(topCols)
        for j in range(m2):
            col=topColsList[j]
            for i in range(n):
                grid2[i][j]=grid[i][col]
        ans=-inf
        for mask in range(n**m2):
            grid3=[[-1 for __ in range(m2)] for ___ in range(n)]
            for col in range(m2):
                shift=mask%n
                for row in range(n):
                    grid3[row][col]=grid2[(shift+row)%n][col]
                mask//=n
            tempAns=0
            for row in range(n):
                maxx=-inf
                for col in range(m2):
                    maxx=max(maxx,grid3[row][col])
                tempAns+=maxx
            ans=max(ans,tempAns)
        allans.append(ans)
        
    multiLineArrayPrint(allans)
    
    return



import sys
input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)
# input=lambda: sys.stdin.readline().rstrip(""\r\n"") #FOR READING STRING/TEXT INPUTS.

def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))
 
def readIntArr():
    return [int(x) for x in input().split()]
# def readFloatArr():
#     return [float(x) for x in input().split()]
 
def makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])
    dv=defaultValFactory;da=dimensionArr
    if len(da)==1:return [dv() for _ in range(da[0])]
    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]
 
def queryInteractive(r):
    print('? {}'.format(r))
    sys.stdout.flush()
    return readIntArr()
 
def answerInteractive(adj,n):
    print('!')
    for u in range(1,n+1):
        for v in adj[u]:
            if v>u:
                print('{} {}'.format(u,v))
    sys.stdout.flush()
 
inf=float('inf')
MOD=10**9+7
# MOD=998244353

from math import gcd,floor,ceil
# from math import floor,ceil # for Python2
 
for _abc in range(1):
    main()",np,"bitmasks,brute force,dp,greedy,sortings",2900
"rnd_mod = 1234567890133
rnd_x = 987654321098
def rnd():
    global rnd_x
    rnd_x = rnd_x**2 % rnd_mod
    return (rnd_x>>5) % (1<<20)
def randrange(a):
    return rnd() % a

T = int(input())
for _ in range(T):
    N, M = map(int, input().split())
    X = []
    for __ in range(N):
        X.append([int(a) for a in input().split()])
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    for t in range(577):
        for i in range(M):
            a = randrange(N)
            Y[i] = [Y[i][j-a] for j in range(N)]
        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))
    print(ma)
",np,"bitmasks,brute force,dp,greedy,sortings",627
"import sys
input = sys.stdin.readline

t=int(input())
for testcases in range(t):
    n,m=map(int,input().split())
    A=[list(map(int,input().split())) for i in range(n)]

    B=[]
    for j in range(m):
        B.append([A[i][j] for i in range(n)])

    B.sort(key=lambda x:max(x),reverse=True)

    B=B[:n]

    #print(B)
    LEN=len(B)

    if LEN==1:
        print(sum(B[0]))

    elif LEN==2:
        ANS=0
        for i in range(n):
            A=0
            for k in range(n):
                A+=max(B[0][k],B[1][(i+k)%n])

            ANS=max(ANS,A)

        print(ANS)

    elif LEN==3:

        ANS=0
        for i in range(n):
            for j in range(n):
                    
                A=0
                for k in range(n):
                    A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n])

                ANS=max(ANS,A)

        print(ANS)

    elif LEN==4:

        ANS=0
        for i in range(n):
            for j in range(n):
                for l in range(n):
                    
                    A=0
                    for k in range(n):
                        A+=max(B[0][k],B[1][(i+k)%n],B[2][(j+k)%n],B[3][(l+k)%n])

                    ANS=max(ANS,A)

        print(ANS)
        
            

    
            
",np,"bitmasks,brute force,dp,greedy,sortings",1252
"from sys import stdin

def f(lst, num):
    new = lst[num:] + lst[:num]
    return new

t = int(stdin.readline())
for i in range(t):
    row, col = tuple(int(x) for x in stdin.readline().split())
    lst = list([int(x)] for x in stdin.readline().split())
    
    for j in range(row-1):
        line = tuple(int(x) for x in stdin.readline().split())
        for k in range(len(line)):
            lst[k].append(line[k])
        
    lst.sort(key=lambda x: max(x), reverse = True)

    ans = float('-inf')
    for a in range(4):
        for b in range(4):
            for c in range(4):
                for d in range(4):
                    if col >= 1:
                        aa = f(lst[0], a)
                    else:
                        aa = (0,)*row
                    if col >= 2:
                        bb = f(lst[1], b)
                    else:
                        bb = (0,)*row
                    if col >= 3:
                        cc = f(lst[2], c)
                    else:
                        cc = (0,)*row
                    if col >= 4:
                        dd = f(lst[3], d)
                    else:
                        dd = (0,)*row

                    ans = max(ans,
                              sum(max(x[j] for x in (aa, bb, cc, dd))
                                  for j in range(row)))
    print(ans)
",np,"bitmasks,brute force,dp,greedy,sortings",1354
"from random import randint
for _ in range(int(input())):
    n, m = map(int, input().split())
    A = [list(map(int, input().split())) for _ in range(n)]
    ans = 0
    for _ in range(100):
        for j in range(m):
            x = randint(0, n - 1)
            if x:
                B = []
                for i in range(n):
                    B.append(A[i][j])
                B = B[x:] + B[:x]
                for i in range(n):
                    A[i][j] = B[i]
        c = 0
        for i in range(n):
            c += max(A[i])
        ans = max(ans, c)
    print(ans)",np,"bitmasks,brute force,dp,greedy,sortings",578
"t = int(input())
for i in range(t):
    n, m = [int(item) for item in input().split()]
    mat = []
    col = [[] for _ in range(m)]
    for j in range(n):
        line = [int(item) for item in input().split()]
        for k, item in enumerate(line):
            col[k].append(item)
        mat.append(line)
    colmax = []
    for line in col:
        colmax.append([max(line), line])
    colmax.sort(reverse=True)
    colmax = colmax[:n]
    ans = 0
    for j in range(n ** (n-1)):
        index = j
        rot = [0]
        for k in range(n-1):
            rot.append(index % n)
            index //= n 
        ret = 0
        for l in range(n):
            val = 0
            for k in range(len(colmax)):
                val = max(val, colmax[k][1][(l + rot[k]) % n])
            ret += val
        ans = max(ans, ret)
    print(ans)",np,"bitmasks,brute force,dp,greedy,sortings",840
"import random 
for _ in range(int(input())):
    N, M = map(int, input().split())
    X = [[int(a) for a in input().split()] for _ in range(N)]
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    for t in range(99):
        for i in range(M):
            a = random.randrange(N)
            Y[i] = [Y[i][j-a] for j in range(N)]
        ma = max(ma, sum([max([Y[i][j] for i in range(M)]) for j in range(N)]))
    print(ma)
",np,"bitmasks,brute force,dp,greedy,sortings",441
"q = int(input())
for rquer in range(q):
	c, r = map(int, input().split())
	matt = [list(map(int,input().split())) for i in range(c)]
	mat = [[matt[i][j] for i in range(c)] for j in range(r)]
	for i in range(r):
		mat[i].append(max(mat[i]))
		mat[i].reverse()
	mat.sort()
	mat.reverse()
	work = mat[:min(4, r)]
	for t in work:
		t.pop(0)
	r = min(4, r)
	wyn = 0
	for num in range(c**r):
		shif = [(num//(c**i))%c for i in range(r)]
		new = 0
		for i in range(c):
			kol = [work[j][(i + shif[j])%c] for j in range(r)]
			new += max(kol)
		wyn = max(wyn, new)
	print(wyn)
		",np,"bitmasks,brute force,dp,greedy,sortings",571
"for _ in range(int(input())):
    N, M = map(int, input().split())
    X = [[int(a) for a in input().split()] for _ in range(N)]
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    dp = [[0] * (1<<N) for _ in range(M+1)]
    for j in range(M):
        for mask in range(1<<N):
            maskpre = mask
            while maskpre >= 0:
                maskpre &= mask
                ma = 0
                for k in range(N):
                    s = 0
                    for i in range(N):
                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:
                            s += X[i-k][j]
                    ma = max(ma, s)
                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)
                
                maskpre -= 1
    print(dp[-1][-1])",np,"bitmasks,brute force,dp,greedy,sortings",800
"t = int(input())
def maxsa(A):
    ans = 0
    #print(""asdasd"")
    for i in range(n):
        cur_maxx = 0
        for j in range(4):
            cur_maxx = max(cur_maxx, A[j][i])
        ans+= cur_maxx
    return ans

def fu(A):
    answer = 0
    for j in range(n):
        A[0] = A[0][1:] + A[0][:1]
        for i in range(n):
            A[1] = A[1][1:] + A[1][:1]
            for k in range(n):
                A[2] = A[2][1:] + A[2][:1]
                for l in range(n):
                    A[3] = A[3][1:] + A[3][:1]
                    #print(A)
                    cur_ans = maxsa(A)
                    answer = max(answer, cur_ans)
    return answer


for j in range(t):
    n,m = map(int,input().split())
    A = [0] * n
    inds = [-1,-1,-1,-1]
    maxs  =[ 0,0,0,0]
    for j in range(n):
        A[j] = list(map(int,input().split()))
    for j in range(m):
        cur_maxs = 0
        for i in range(n):
            cur_maxs = max(cur_maxs, A[i][j])
        maxs.append(cur_maxs)
        inds.append(j)
        ind  = 4
        #print(cur_maxs)
        while ind !=0 and maxs[ind] > maxs[ind-1]:
            inds[ind], inds[ind-1] = inds[ind-1] , inds[ind]
            maxs[ind], maxs[ind - 1] = maxs[ind - 1], maxs[ind]
            ind-=1
        maxs.pop()
        inds.pop()


    #print(maxs)
    #print(inds)
    S = [0] * 4
    for j in range(4):
        if inds[j] != -1:
            #print(A)
            #print(inds[j])
            S[j] = [s[inds[j]] for s in A]
            #print(S[j])
        else:
            S[j] = [0] * n
    #print(S)
    print(fu(S))",np,"bitmasks,brute force,dp,greedy,sortings",1586
"


def solve(matrix, col, N, M):
    if col == M:
        '''
        for row in matrix:
            print(row)
        print()
        '''

        ans = 0
        for row in matrix:
            if len(row) == 1:
                ans += row[0]
            else:
                ans += max(*row)

        return ans

    # girar la columna `col` N - 1 veces

    if N == 1:
        return solve(matrix, col + 1, N, M)

    ans = solve(matrix, col + 1, N, M)
    for _ in range(N-1):
        tmp = matrix[0][col]
        for n in range(1, N):
            matrix[n-1][col] = matrix[n][col]
        matrix[N-1][col] = tmp

        local_ans = solve(matrix, col + 1, N, M)
        if local_ans > ans:
            ans = local_ans

    return ans

def main():
    T = int(input())
    for t in range(T):
        N, M = list(map(lambda x: int(x), input().split()))

        matrix = []
        for n in range(N):
            matrix.append(
                list(map(lambda x: int(x), input().split()))
            )

        elements = []
        for n in range(N):
            for m in range(M):
                elements.append((matrix[n][m], m))

        elements.sort(reverse=True)

        candidates = []
        for t in elements:
            if t[1] not in candidates:
                candidates.append(t[1])
                if len(candidates) == N:
                    break

        simplified = []
        for n in range(N):
            row = []
            for m in candidates:
                row.append(matrix[n][m])
            simplified.append(row)

        ans = solve(simplified, 0, N, min(N, M))
        print(ans)

main()
",np,"bitmasks,brute force,dp,greedy,sortings",1633
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------


def main():
    for _ in range(N()):
        n, m = RL()
        arr = []
        for _ in range(n): arr.append(RLL())

        larr = [list(i) for i in zip(*arr)]
        larr.sort(key = lambda a: max(a), reverse=1)
        larr = larr[:n]

        res = 0

        def dfs(lst, pos=0):
            nonlocal res
            if pos==min(n, len(larr)):
                res = max(res, sum(lst))
                return

            for i in range(n):
                now = larr[pos][i:n]+larr[pos][0:i]
                nex = [max(now[j], lst[j]) for j in range(n)]
                dfs(nex, pos+1)

        dfs([0]*n)
        print(res)



if __name__ == ""__main__"":
    main()

",np,"bitmasks,brute force,dp,greedy,sortings",3016
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------


def main():
    for _ in range(N()):
        n, m = RL()
        arr = []
        for _ in range(n): arr.append(RLL())

        larr = [list(i) for i in zip(*arr)]
        larr.sort(key = lambda a: max(a), reverse=1)
        larr = larr[:n]

        res = 0

        def dfs(lst, pos=0):
            nonlocal res
            if pos==min(n, len(larr)):
                res = max(res, sum(lst))
                return

            for i in range(n):
                nex = lst.copy()
                for j in range(n):
                    nex[(i+j)%n] = max(nex[(i+j)%n], larr[pos][j])
                dfs(nex, pos+1)

        dfs([0]*n)
        print(res)



if __name__ == ""__main__"":
    main()

",np,"bitmasks,brute force,dp,greedy,sortings",3037
"for _ in range(int(input())):
    N, M = map(int, input().split())
    X = [[int(a) for a in input().split()] for _ in range(N)]
    Y = [[X[i][j] for i in range(N)] for j in range(M)]
    ma = 0
    dp = [[0] * (1<<N) for _ in range(M+1)]
    for j in range(M):
        for mask in range(1<<N):
            maskpre = mask
            while maskpre >= 0:
                maskpre &= mask
                ma = 0
                for k in range(N):
                    s = 0
                    for i in range(N):
                        if (maskpre >> i) & 1 == 0 and (mask >> i) & 1:
                            s += X[i-k][j]
                    ma = max(ma, s)
                dp[j+1][mask] = max(dp[j+1][mask], dp[j][maskpre] + ma)
                
                maskpre -= 1
    print(dp[-1][-1])
    ",np,"bitmasks,brute force,dp,greedy,sortings",805
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        not_i = ((1 << m) - 1) ^ i
        val = dp[i] + (total_adj - adj_in_subset[i] - adj_in_subset[not_i])
        dp[i | (1 << j)] = min(dp[i | (1 << j)], val)
print(dp[-1])",np,"bitmasks,dp",1064
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

count = [[0] * m for _ in range(m)]
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        count[c1][c2] += 1

sum_of_subset = [[0] * (1 << m) for _ in range(m)]
for i in range(m):
    for j in range(1 << m):
        if j == 0:
            continue
        lsb = j & -j
        sum_of_subset[i][j] = sum_of_subset[i][j ^ lsb] + count[i][lsb.bit_length() - 1]

adj_in_subset = [0] * (1 << m)
for i in range(1 << m):
    for j in range(m):
        if i & (1 << j):
            adj_in_subset[i] += sum_of_subset[j][i]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",np,"bitmasks,dp",1026
"import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

INF = 10**9

n, m = [int(item) for item in input().split()]
s = input().rstrip()

# Calculate adjacent count in subset
adj_in_subset = [0] * (1 << m)
ord_a = ord(""a"")
for c1, c2 in zip(s, s[1:]):
    c1 = ord(c1) - ord_a
    c2 = ord(c2) - ord_a
    if c1 != c2:
        adj_in_subset[(1 << c1) + (1 << c2)] += 1
for i in range(m):
    for j in range(1 << m):
        if j & (1 << i):
            adj_in_subset[j] += adj_in_subset[j ^ (1 << i)]

total_adj = adj_in_subset[-1]
dp = [INF] * (1 << m)
dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if i & 1 << j:
            continue
        cost = total_adj - adj_in_subset[i] - adj_in_subset[~i]
        dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + cost)
print(dp[-1])",np,"bitmasks,dp",808
"n, m = map(int, input().split())
a = list(map(str, input().strip()))

dp = [10 ** 10] * (1 << 20)
cnt = [0] * (1 << 20)


def get(x):
    return 1 << (ord(x) - ord('a'))


for i, v in enumerate(a):
    if i:
        cnt[get(a[i]) | get(a[i - 1])] += 1

for i in range(m):
    for j in range(1 << m):
        if (1 << i) & j:
            cnt[j] += cnt[j ^ (1 << i)]
            # print(bin(j), bin(j ^ 1 << i), cnt[j])

# for i in range(1 << m):
#     for j in range(m):
#         if not i & (1 << j):
#             cnt[i | (1 << j)] += cnt[i]
#             print(bin(i | (1 << j)), bin(i), cnt[i | 1 << j])

dp[0] = 0

for i in range(1 << m):
    for j in range(m):
        if not i & (1 << j):
            dp[i | (1 << j)] = min(dp[i | (1 << j)],
                                   dp[i] + n - 1 - cnt[i | (1 << j)] - cnt[(1 << m) - 1 - (i | (1 << j))])
print(dp[(1 << m) - 1])
",np,"bitmasks,dp",879
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')
from math import factorial
from collections import Counter, defaultdict, deque
from heapq import heapify, heappop, heappush

# ------------------------------

def cord(c):
    return ord(c)-ord('a')

def main():
    n, m = RL()
    s = input()
    ct = [0]*(1<<m)

    for i in range(n-1):
        now, nex = cord(s[i]), cord(s[i+1])
        if now==nex: continue
        ct[1<<now | 1<<nex]+=1

    for i in range(m):
        for j in range(1<<m):
            if (1<<i) & j:
                ct[j]+=ct[(1<<i) ^ j]

    dp = [INF]*(1<<m)
    dp[0] = 0
    for i in range(1<<m):
        # pos = bin(i).count('1')
        for j in range(m):
            # sm = 0
            # if i>>j & 1 == 0:
            #     for k in range(m):
            #         if 1<<k & i==0:
            #             sm-=ct[j][k]*pos
            #         else:
            #             sm+=ct[j][k]*pos
            if i & 1<<j == 0:
                sm = ct[-1]-ct[i]-ct[~i]
                dp[i|(1<<j)] = min(dp[i|(1<<j)], dp[i] + sm)
    # print(ct)
    print(dp[-1])





if __name__ == ""__main__"":
    main()

",np,"bitmasks,dp",3270
"
def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")


def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    simple = [False]*(1 << k)
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())
            if found:
                simple[mask] = True
                masks[mask] = path
    for i in range(1 << k):
        if not simple[i]:
            continue
        mask = i
        zeroes_count = 0
        for u in range(k):
            if (1 << u) > mask:
                break
            if (mask & (1 << u)) == 0:
                zeroes_count += 1
        for mask_mask in range(1 << zeroes_count):
            mask_child = 0
            c = 0
            for u in range(k):
                if (1 << u) > mask:
                    break
                if (mask & (1 << u)) == 0:
                    if (mask_mask & (1 << c)) != 0:
                        mask_child = mask_child | (1 << u)
                    c += 1
            if masks[mask_child] and not masks[mask_child | mask]:
                masks[mask_child | mask] = {**masks[mask_child], **masks[mask]}
                if (mask_child | mask) == ((1 << k) - 1):
                    c = [-1] * k
                    p = [-1] * k
                    d = masks[(1 << k) - 1]
                    for key, val in d.items():
                        c[key] = val[0]
                        p[key] = val[1]
                    return True, c, p
    if masks[(1 << k) - 1]:
        c = [-1] * k
        p = [-1] * k
        d = masks[(1 << k) - 1]
        for key, val in d.items():
            c[key] = val[0]
            p[key] = val[1]
        return True, c, p
    return False, None, None


def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result


def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path[i_next] = (a[i_next][j_next], i)
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)


def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums


if __name__ == ""__main__"":
    main()
",np,"bitmasks,dfs and similar,dp,graphs",3257
"
def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")


def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    answer = [False]*(1 << k)
    left = [0]*(1 << k)
    right = [0]*(1 << k)
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, dict())
            if found:
                answer[mask] = True
                masks[mask] = path
    for mask_right in range(1 << k):
        if not masks[mask_right]:
            continue
        zeroes_count = 0
        for u in range(k):
            if (1 << u) > mask_right:
                break
            if (mask_right & (1 << u)) == 0:
                zeroes_count += 1
        for mask_mask in range(1 << zeroes_count):
            mask_left = 0
            c = 0
            for u in range(k):
                if (1 << u) > mask_right:
                    break
                if (mask_right & (1 << u)) == 0:
                    if (mask_mask & (1 << c)) != 0:
                        mask_left = mask_left | (1 << u)
                    c += 1
            joint_mask = mask_left | mask_right
            if answer[mask_left] and not answer[joint_mask]:
                answer[joint_mask] = True
                left[joint_mask] = mask_left
                right[joint_mask] = mask_right
                if joint_mask == ((1 << k) - 1):
                    return build_answer(k, masks, left, right)
    if answer[(1 << k) - 1]:
        return build_answer(k, masks, left, right)
    return False, None, None


def build_answer(k, masks, left, right):
    c = [-1] * k
    p = [-1] * k
    pos = (1 << k) - 1
    while not masks[pos]:
        for key, val in masks[right[pos]].items():
            c[key] = val[0]
            p[key] = val[1]
        pos = left[pos]
    for key, val in masks[pos].items():
        c[key] = val[0]
        p[key] = val[1]
    return True, c, p


def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result


def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path[i_next] = (a[i_next][j_next], i)
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)


def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums


if __name__ == ""__main__"":
    main()
",np,"bitmasks,dfs and similar,dp,graphs",3430
"
def main():
    k = int(input())
    n = []
    a = []
    for i in range(k):
        line = [int(x) for x in input().split()]
        ni = line[0]
        ai = []
        n.append(ni)
        a.append(ai)
        for j in range(ni):
            ai.append(line[1 + j])
    answer, c, p = solve(k, n, a)
    if answer:
        print(""Yes"")
        for i in range(k):
            print(c[i], p[i] + 1)
    else:
        print(""No"")


def solve(k, n, a):
    asum, sums = calc_sums(k, n, a)
    if asum % k != 0:
        return False, None, None
    tsum = asum / k
    num_map = build_num_map(k, n, a)
    masks = [None]*(1 << k)
    simple = [False]*(1 << k)
    answer = [False]*(1 << k)
    left = [0]*(1 << k)
    right = [0]*(1 << k)
    by_last_one = [[] for _ in range(k)]
    for i in range(k):
        for j in range(n[i]):
            found, mask, path = find_cycle(i, j, i, j, k, n, a, sums, tsum, num_map, 0, [])
            if found and not answer[mask]:
                answer[mask] = True
                masks[mask] = path
                simple[mask] = True
                by_last_one[calc_last_one(mask)].append(mask)
    if answer[(1 << k) - 1]:
        return build_answer(k, masks, left, right)
    for mask_right in range(2, 1 << k):
        if not simple[mask_right]:
            continue
        last_one = calc_last_one(mask_right)
        zeroes_count = 0
        alternative_sum = 0
        zero_list = []
        for u in range(last_one):
            if (mask_right & (1 << u)) == 0:
                zeroes_count += 1
                alternative_sum += len(by_last_one[u])
                zero_list.append(u)
        if zeroes_count == 0:
            continue
        if alternative_sum < (1 << zeroes_count):
            for fill_last_zero in zero_list:
                for mask_left in by_last_one[fill_last_zero]:
                    if (mask_left & mask_right) != 0:
                        continue
                    joint_mask = mask_left | mask_right
                    if not answer[joint_mask]:
                        answer[joint_mask] = True
                        left[joint_mask] = mask_left
                        right[joint_mask] = mask_right
                        by_last_one[last_one].append(joint_mask)
                        if joint_mask == ((1 << k) - 1):
                            return build_answer(k, masks, left, right)
        else:
            for mask_mask in range(1 << zeroes_count):
                mask_left = 0
                for u in range(zeroes_count):
                    if (mask_mask & (1 << u)) != 0:
                        mask_left = mask_left | (1 << zero_list[u])
                joint_mask = mask_left | mask_right
                if answer[mask_left] and not answer[joint_mask]:
                    answer[joint_mask] = True
                    left[joint_mask] = mask_left
                    right[joint_mask] = mask_right
                    by_last_one[last_one].append(joint_mask)
                    if joint_mask == ((1 << k) - 1):
                        return build_answer(k, masks, left, right)
    return False, None, None


def calc_last_one(x):
    result = -1
    while x > 0:
        x = x >> 1
        result = result + 1
    return result


def build_answer(k, masks, left, right):
    c = [-1] * k
    p = [-1] * k
    pos = (1 << k) - 1
    while not masks[pos]:
        for i, a, j in masks[right[pos]]:
            c[i] = a
            p[i] = j
        pos = left[pos]
    for i, a, j in masks[pos]:
        c[i] = a
        p[i] = j
    return True, c, p


def build_num_map(k, n, a):
    result = dict()
    for i in range(k):
        for j in range(n[i]):
            result[a[i][j]] = (i, j)
    return result


def find_cycle(i_origin, j_origin, i, j, k, n, a, sums, tsum, num_map, mask, path):
    if (mask & (1 << i)) != 0:
        if i == i_origin and j == j_origin:
            return True, mask, path
        else:
            return False, None, None
    mask = mask | (1 << i)
    a_needed = tsum - (sums[i] - a[i][j])
    if a_needed not in num_map:
        return False, None, None
    i_next, j_next = num_map[a_needed]
    path.append((i_next, a[i_next][j_next], i))
    return find_cycle(i_origin, j_origin, i_next, j_next, k, n, a, sums, tsum, num_map, mask, path)


def calc_sums(k, n, a):
    sums = [0] * k
    for i in range(k):
        for j in range(n[i]):
            sums[i] = sums[i] + a[i][j]
    asum = 0
    for i in range(k):
        asum = asum + sums[i]
    return asum, sums


if __name__ == ""__main__"":
    main()
",np,"bitmasks,dfs and similar,dp,graphs",4560
"from itertools import accumulate
from sys import stdin, stdout


def main():
    k = int(stdin.readline())
    a = [
        tuple(map(int, stdin.readline().split()[1:]))
        for _ in range(k)
    ]
    a2ij = {
        aij: (i, j)
        for i, ai in enumerate(a)
        for j, aij in enumerate(ai)
    }

    plena = [0, ] + list(accumulate(map(len, a)))
    suma = tuple(map(sum, a))
    totala = sum(suma)

    if totala % k != 0:
        stdout.write(""No\n"")
    else:
        needle = totala // k
        mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma)
        dp = compute_previous_mask(mask2i2cp)
        output(dp, mask2i2cp)


def compute_mask2i2cp(a, a2ij, needle, plena, suma):
    used = [False, ] * plena[-1]
    number_of_masks = 1 << len(a)
    mask2i2cp = [-1, ] * number_of_masks

    for i, ai in enumerate(a):
        for j, aij in enumerate(ai):
            if not used[plena[i] + j]:
                mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma)

                if i2cp != -1:
                    mask2i2cp[mask] = i2cp

    return mask2i2cp


def output(dp, mask2i2cp):
    mask = len(mask2i2cp) - 1

    if dp[mask] == -1:
        stdout.write(""No\n"")
    else:
        answer = [-1, ] * len(mask2i2cp[dp[mask]])

        while mask > 0:
            current_mask = dp[mask]

            for i, cp in enumerate(mask2i2cp[current_mask]):
                if 1 == ((current_mask >> i) & 1):
                    c, p = cp
                    answer[i] = (c, p)

            mask ^= current_mask

        stdout.write('Yes\n' + '\n'.join('{} {}'.format(c, 1 + p) for c, p in answer))


def compute_mask_i2cp(a2ij, aij, i, j, needle, suma):
    i2cp = [-1, ] * len(suma)
    mask = 0
    current_a = aij
    current_i = i

    try:
        while True:
            next_a = needle - (suma[current_i] - current_a)

            next_i, next_j = a2ij[next_a]

            if ((mask >> next_i) & 1) == 1:
                return mask, -1

            mask |= 1 << next_i
            i2cp[next_i] = (next_a, current_i)

            if next_i == i:
                if next_j == j:
                    return mask, i2cp

                return mask, -1

            if next_i == current_i:
                return mask, -1

            current_a = next_a
            current_i = next_i
    except KeyError:
        return mask, -1


def compute_previous_mask(mask2cp):
    number_of_masks = len(mask2cp)
    dp = [-1, ] * number_of_masks
    dp[0] = 0

    for mask, cp in enumerate(mask2cp):
        if cp != -1:
            complement_mask = (number_of_masks - 1) & (~mask)
            previous_mask = complement_mask

            while previous_mask > 0:
                if dp[previous_mask] != -1 and dp[previous_mask | mask] == -1:
                    dp[previous_mask | mask] = mask

                previous_mask = (previous_mask - 1) & complement_mask

            if dp[mask] == -1:
                dp[mask] = mask
    return dp


if __name__ == '__main__':
    main()
",np,"bitmasks,dfs and similar,dp,graphs",3020
"from itertools import accumulate
from sys import stdin, stdout


def main():
    k = int(stdin.readline())
    a = [
        tuple(map(int, stdin.readline().split()[1:]))
        for _ in range(k)
    ]
    a2ij = {
        aij: (i, j)
        for i, ai in enumerate(a)
        for j, aij in enumerate(ai)
    }

    plena = [0, ] + list(accumulate(map(len, a)))
    suma = tuple(map(sum, a))
    totala = sum(suma)

    if totala % k != 0:
        stdout.write(""No\n"")
    else:
        needle = totala // k
        mask2i2cp = compute_mask2i2cp(a, a2ij, needle, plena, suma)
        dp = compute_previous_mask(mask2i2cp)
        output(dp, mask2i2cp)


def compute_mask2i2cp(a, a2ij, needle, plena, suma):
    used = [False, ] * plena[-1]
    number_of_masks = 1 << len(a)
    mask2i2cp = [-1, ] * number_of_masks

    for i, ai in enumerate(a):
        for j, aij in enumerate(ai):
            if not used[plena[i] + j]:
                mask, i2cp = compute_mask_i2cp(a2ij, aij, i, j, needle, suma)

                if i2cp != -1:
                    mask2i2cp[mask] = i2cp

                    for cp in i2cp:
                        if cp != -1:
                            c, p = cp
                            ii, jj = a2ij[c]
                            used[plena[ii] + jj] = True


    return mask2i2cp


def output(dp, mask2i2cp):
    mask = len(mask2i2cp) - 1

    if dp[mask] == -1:
        stdout.write(""No\n"")
    else:
        answer = [-1, ] * len(mask2i2cp[dp[mask]])

        while mask > 0:
            current_mask = dp[mask]

            for i, cp in enumerate(mask2i2cp[current_mask]):
                if 1 == ((current_mask >> i) & 1):
                    c, p = cp
                    answer[i] = (c, p)

            mask ^= current_mask

        stdout.write('Yes\n' + '\n'.join('{} {}'.format(c, 1 + p) for c, p in answer))


def compute_mask_i2cp(a2ij, aij, i, j, needle, suma):
    i2cp = [-1, ] * len(suma)
    mask = 0
    current_a = aij
    current_i = i

    try:
        while True:
            next_a = needle - (suma[current_i] - current_a)

            next_i, next_j = a2ij[next_a]

            if ((mask >> next_i) & 1) == 1:
                return mask, -1

            mask |= 1 << next_i
            i2cp[next_i] = (next_a, current_i)

            if next_i == i:
                if next_j == j:
                    return mask, i2cp

                return mask, -1

            if next_i == current_i:
                return mask, -1

            current_a = next_a
            current_i = next_i
    except KeyError:
        return mask, -1


def compute_previous_mask(mask2cp):
    number_of_masks = len(mask2cp)
    dp = [-1, ] * number_of_masks
    dp[0] = 0

    for mask, cp in enumerate(mask2cp):
        if cp != -1:
            complement_mask = (number_of_masks - 1) & (~mask)
            previous_mask = complement_mask

            while previous_mask > 0:
                if dp[previous_mask] != -1 and dp[previous_mask | mask] == -1:
                    dp[previous_mask | mask] = mask

                previous_mask = (previous_mask - 1) & complement_mask

            if dp[mask] == -1:
                dp[mask] = mask
    return dp


if __name__ == '__main__':
    main()
",np,"bitmasks,dfs and similar,dp,graphs",3234
"from collections import defaultdict

data = defaultdict(list)
position = defaultdict()
nxt = defaultdict()
agg_sum = list()

k = int(input())
trace = defaultdict()
F = [False for x in range(1 << k)]
back = [0 for x in range(1 << k)]
total_sum = 0
res = [(0, 0) for x in range(k)]


def build_mask(trace_mask):
    if trace_mask == 0:
        return

    if trace.get(trace_mask):
        for data in trace.get(trace_mask):
            fr, to, v = data
            res[fr] = (v, to)
        return

    sub_mask = back[trace_mask]
    build_mask(sub_mask)
    build_mask(trace_mask - sub_mask)


if __name__ == '__main__':
    for i in range(k):
        values = list(map(int, input().split(' ')))
        data[i] = values[1:]

        agg_sum.append(sum(data[i]))
        total_sum += agg_sum[i]

        for cnt, v in enumerate(data[i], 0):
            position[v] = (i, cnt)

    if total_sum % k != 0:
        print(""No"")
        exit(0)

    row_sum = total_sum // k

    for i in range(k):
        for cnt, value in enumerate(data.get(i), 0):

            x = i
            y = cnt
            mask = (1 << x)
            could = True
            circle = list()
            while True:
                next_value = row_sum - agg_sum[x] + data.get(x)[y]
                if position.get(next_value) is None:
                    could = False
                    break

                last_x = x
                last_y = y

                x, y = position.get(next_value)
                circle.append((x, last_x, next_value))

                if x == i and y == cnt:
                    break

                if mask & (1 << x):
                    could = False
                    break

                mask |= (1 << x)

            F[mask] |= could
            if could:
                trace[mask] = circle

    for mask in range(1, 1 << k):
        sub = mask
        while sub > 0:
            if F[sub] and F[mask - sub]:
                F[mask] = True
                back[mask] = sub
                break
            sub = mask & (sub - 1)

    if F[(1 << k) - 1]:
        print('Yes')
        build_mask((1 << k) - 1)
        for value in res:
            print(value[0], value[1] + 1)
    else:
        print('No')
",np,"bitmasks,dfs and similar,dp,graphs",2234
"import sys

n = sys.stdin.readline()
n = int(n)
def get_graph(n):
    graph = []
    for _ in range(n):
        entries = list(map(lambda x : int(x), sys.stdin.readline().split("" "")[1:]))
        graph.append(entries)
    return graph

def chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val):
    mask = 2**bucket_num
    mem = []
    buckets_seen = set({bucket_num})

    og_bucket = bucket_num
    og_val = val
    for _ in range(len(buckets)):
        rem = target - sum_bucket[bucket_num] + val
        if rem not in reverse_bucket:
            return None, []
        
        new_bucket = reverse_bucket[rem]
        if new_bucket == og_bucket and rem != og_val:
            return None, []
        elif new_bucket == og_bucket and rem == og_val:
            mem.append((rem, bucket_num))
            return mask | 2**new_bucket, mem
        elif new_bucket in buckets_seen:
            return None, []
        
        buckets_seen.add(new_bucket)
        mask = mask | 2**new_bucket

        mem.append((rem, bucket_num))
        bucket_num = new_bucket
        val = rem
    return None, []
#mask is what you wanna see if you can get
def helper(chains, mask, mem):
    if mask == 0:
        return []
    if mask in mem:
        return mem[mask]

    for i, chain in enumerate(chains):
        if (mask >> i) & 0:
            continue
        for key in chain:
            if key | mask != mask:
                continue
    
            future = helper(chains, ~key & mask, mem)
            if future is not None:
                mem[mask] = chain[key] + future
                return mem[mask]
    mem[mask] = None
    return None

def solve(n):
    buckets = get_graph(n)
    reverse_bucket = {}
    sum_bucket = [0]* len(buckets)
    total_sum = 0
    for i, bucket in enumerate(buckets):
        for x in bucket:
            total_sum += x
            sum_bucket[i] += x
            reverse_bucket[x] = i
    
    target = total_sum / len(buckets)

    chains = []
    for i, bucket in enumerate(buckets):
        seto = {}
        for x in bucket:
            key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x)
            if key is not None:
                seto[key] = val
        chains.append(seto)
    return helper(chains, 2 ** len(buckets) - 1, {}), reverse_bucket

def result(n):
    res, reverse_bucket = solve(n)
    if res is None:
        sys.stdout.write(""No\n"")
    else:  
        res = sorted(res, key = lambda x : reverse_bucket[x[0]])
        sys.stdout.write(""Yes\n"")
        for x, y in res:
            x = int(x)
            y = int(y) + 1
            stuff = "" "".join([str(x), str(y), ""\n""])
            sys.stdout.write(stuff)
result(n)",np,"bitmasks,dfs and similar,dp,graphs",2708
"import sys

n = sys.stdin.readline()
n = int(n)
def get_graph(n):
    graph = []
    for _ in range(n):
        entries = list(map(lambda x : int(x), sys.stdin.readline().split("" "")[1:]))
        graph.append(entries)
    return graph

def chain(target, buckets, reverse_bucket, sum_bucket, bucket_num, val):
    mask = 2**bucket_num
    mem = []
    buckets_seen = set({bucket_num})

    og_bucket = bucket_num
    og_val = val
    for _ in range(len(buckets)):
        rem = target - sum_bucket[bucket_num] + val
        if rem not in reverse_bucket:
            return None, []
        
        new_bucket = reverse_bucket[rem]
        if new_bucket == og_bucket and rem != og_val:
            return None, []
        elif new_bucket == og_bucket and rem == og_val:
            mem.append((rem, bucket_num))
            return mask | 2**new_bucket, mem
        elif new_bucket in buckets_seen:
            return None, []
        
        buckets_seen.add(new_bucket)
        mask = mask | 2**new_bucket

        mem.append((rem, bucket_num))
        bucket_num = new_bucket
        val = rem
    return None, []
#mask is what you wanna see if you can get
def helper(chains, mask, mem):
    if mask == 0:
        return []
    if mask in mem:
        return mem[mask]

    for i, chain in enumerate(chains):
        if (mask >> i) & 0:
            continue
        for key in chain:
            if key | mask != mask:
                continue
    
            future = helper(chains, ~key & mask, mem)
            if future is not None:
                mem[mask] = chain[key] + future
                return mem[mask]
    mem[mask] = None
    return None
def solve(n):
    buckets = get_graph(n)
    reverse_bucket = {}
    sum_bucket = [0]* len(buckets)
    total_sum = 0
    for i, bucket in enumerate(buckets):
        for x in bucket:
            total_sum += x
            sum_bucket[i] += x
            reverse_bucket[x] = i
    
    target = total_sum / len(buckets)

    chains = []
    for i, bucket in enumerate(buckets):
        seto = {}
        for x in bucket:
            key, val = chain(target, buckets, reverse_bucket, sum_bucket, i, x)
            if key is not None:
                seto[key] = val
        chains.append(seto)
    mem = {}
    for i in range (2**len(buckets)-1):
        helper(chains, i, mem)
    return helper(chains, 2 ** len(buckets) - 1, mem), reverse_bucket

def result(n):
    res, reverse_bucket = solve(n)
    if res is None:
        sys.stdout.write(""No\n"")
    else:  
        res = sorted(res, key = lambda x : reverse_bucket[x[0]])
        sys.stdout.write(""Yes\n"")
        for x, y in res:
            x = int(x)
            y = int(y) + 1
            stuff = "" "".join([str(x), str(y), ""\n""])
            sys.stdout.write(stuff)
result(n)",np,"bitmasks,dfs and similar,dp,graphs",2792
"# by the authority of GOD     author: manhar singh sachdev #

import os,sys
from io import BytesIO, IOBase

def check(mid,arr,m,n):
    ls = [[] for _ in range(1<<m)]
    for i in range(n):
        ans = 0
        for j in range(m):
            if arr[i][j] >= mid:
                ans += 1<<j
        ls[ans].append(i+1)
    for i in range(len(ls)):
        for j in range(len(ls)):
            if len(ls[i]) and len(ls[j]) and i|j == (1<<m)-1:
                return ls[i][0],ls[j][0]
    return 0

def main():
    n,m = map(int,input().split())
    arr = [list(map(int,input().split())) for _ in range(n)]
    hi,lo,ind1 = 10**9,0,(1,1)
    while hi >= lo:
        mid = (hi+lo)//2
        ind = check(mid,arr,m,n)
        if ind:
            ind1 = ind
            lo = mid+1
        else:
            hi = mid-1
    print(*ind1)

#Fast IO Region
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == '__main__':
    main()",np,"binary search,bitmasks,dp",2530
"#------------------------template--------------------------#
import os
import sys
# from math import *
from collections import *
# from fractions import *
# from heapq import*
from bisect import *
from io import BytesIO, IOBase
def vsInput():
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')
BUFSIZE = 8192
class FastIO(IOBase):
    newlines = 0
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
ALPHA='abcdefghijklmnopqrstuvwxyz'
M=998244353
EPS=1e-6
def Ceil(a,b): return a//b+int(a%b>0)
def value():return tuple(map(int,input().split()))
def array():return [int(i) for i in input().split()]
def Int():return int(input())
def Str():return input()
def arrayS():return [i for i in input().split()]


#-------------------------code---------------------------#
# vsInput()


def ok(here):

    have = defaultdict(lambda : -1)
    for j in range(n):
        b = a[j]
        s = ''
        for i in b:
            if(i>=here): s+='1'
            else: s+='0'
        have[int(s,2)] = j

    for i in range(300):
        for j in range(300):
            if(i|j == 2**m-1 and have[i]!=-1 and have[j]!=-1): return (have[i]+1,have[j]+1)
    
    return -1

n,m = value()
a = []

for i in range(n): a.append(array())

low = 0
high = 10**9

while(low<=high):

    mid = low + (high - low)//2
    here = ok(mid)

    if(here != -1):
        ans = here
        low = mid+1
    else:
        high = mid - 1

# if(ans)
print(*ans)




















",np,"binary search,bitmasks,dp",3006
"MAX=10**9 #O((n*m+(2**m)**2)*log(MAX))
def main():
    
    n,m=readIntArr()
    arrs=[]
    for _ in range(n):
        arrs.append(readIntArr())
    
    def checkPossible(minB):
        binRepresentations=set()
        for arr in arrs:
            binRepresentations.add(convertToBinary(arr,minB))
        binList=list(binRepresentations)
        ii=jj=-1
        n=len(binList)
        for i in range(n):
            for j in range(i,n):
                if binList[i]|binList[j]==(1<<m)-1: #ok
                    ii=binList[i]
                    jj=binList[j]
        if ii!=-1: #ok
            ansi=ansj=-1
            for i in range(len(arrs)):
                b=convertToBinary(arrs[i],minB)
                if b==ii:
                    ansi=i
                if b==jj:
                    ansj=i
            # print('ii:{} jj:{}'.format(ii,jj))
            # print('ok minB:{} ansi:{} ansj:{}'.format(minB,ansi,ansj))
            return (ansi,ansj)
        else:
            return None
                    
    def convertToBinary(arr,minB):
        b=0
        for i in range(m):
            if arr[i]>=minB:
                b|=(1<<i)
        return b
    
    minB=-1
    i=j=-1
    b=MAX
    while b>0:
        temp=checkPossible(minB+b)
        if temp==None: #cannot
            b//=2
        else: #can
            minB+=b
            i,j=temp
    i+=1;j+=1
    print('{} {}'.format(i,j))
    
    return
    
import sys
input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)
# input=lambda: sys.stdin.readline().rstrip(""\r\n"") #FOR READING STRING/TEXT INPUTS.
 
def oneLineArrayPrint(arr):
    print(' '.join([str(x) for x in arr]))
def multiLineArrayPrint(arr):
    print('\n'.join([str(x) for x in arr]))
def multiLineArrayOfArraysPrint(arr):
    print('\n'.join([' '.join([str(x) for x in y]) for y in arr]))
 
def readIntArr():
    return [int(x) for x in input().split()]
# def readFloatArr():
#     return [float(x) for x in input().split()]
 
def makeArr(*args):
    """"""
    *args : (default value, dimension 1, dimension 2,...)
    
    Returns : arr[dim1][dim2]... filled with default value
    """"""
    assert len(args) >= 2, ""makeArr args should be (default value, dimension 1, dimension 2,...""
    if len(args) == 2:
        return [args[0] for _ in range(args[1])]
    else:
        return [makeArr(args[0],*args[2:]) for _ in range(args[1])]
 
def queryInteractive(x,y):
    print('? {} {}'.format(x,y))
    sys.stdout.flush()
    return int(input())
 
def answerInteractive(ans):
    print('! {}'.format(ans))
    sys.stdout.flush()
 
inf=float('inf')
MOD=10**9+7
 
for _abc in range(1):
    main()",np,"binary search,bitmasks,dp",2662
"#Code by Sounak, IIESTS
#------------------------------warmup----------------------------

import os
import sys
import math
from io import BytesIO, IOBase
from fractions import Fraction
import collections
from itertools import permutations
from collections import defaultdict
from collections import deque
import threading

#sys.setrecursionlimit(300000)
#threading.stack_size(10**8)

BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
     
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
  
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

#-------------------------------------------------------------------------
#mod = 9223372036854775807  
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
class SegmentTree1:
    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
 
        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])
 
    def __delitem__(self, idx):
        self[idx] = self._default
 
    def __getitem__(self, idx):
        return self.data[idx + self._size]
 
    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1
 
    def __len__(self):
        return self._len
 
    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size
 
        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res
 
    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
MOD=10**9+7
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]
 
    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]
 
    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]
 
    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]
 
 
class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)
 
    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD
mod=10**9+7
omod=998244353
#-------------------------------------------------------------------------
prime = [True for i in range(10)] 
pp=[0]*10
def SieveOfEratosthenes(n=10):
    p = 2
    c=0
    while (p * p <= n): 
          
        if (prime[p] == True):
            c+=1
            for i in range(p, n+1, p): 
                pp[i]+=1
                prime[i] = False
        p += 1
#---------------------------------Binary Search------------------------------------------
def binarySearch(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[n-1]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] >= key):
            res=arr[mid]
            right = mid-1
        else:
            left = mid + 1
    return res

def binarySearch1(arr, n, key):
    left = 0
    right = n-1
    mid = 0
    res=arr[0]
    while (left <= right):
        mid = (right + left)//2
        if (arr[mid] > key):
            right = mid-1
        else:
            res=arr[mid]
            left = mid + 1
    return res
#---------------------------------running code------------------------------------------
n,m=map(int,input().split())
l=[]
pm=2**m-1
for i in range(n):
    l.append(list(map(int,input().split())))
def find (x):
    s=set()
    d=defaultdict(int)
    for i in range(n):
        a=""""
        for j in range(m):
            if l[i][j]>=x:
                a+='1'
            else:
                a+='0'
        d[int(a,2)]=i
        s.add(int(a,2))
    s=list(s)
    #print(s)
    for i in range(len(s)):
        for j in range(i,len(s)):
            if s[i]|s[j]==pm:
                return [d[s[i]]+1,d[s[j]]+1]
    return [-1,-1]
st=0
end=10**9
ans=(0,0)
while(st<=end):
    mid=(st+end)//2
    s=find(mid)
    if s[0]!=-1:
        ans=s
        st=mid+1
    else:
        end=mid-1
print(*ans)",np,"binary search,bitmasks,dp",9502
"import sys

 
def find_pair(candidate,data,m):
    ans = (-1,-1)
    binary_bit = [False for i in range(1 << m)]
    for i in data:
        bit_tmp = 0
        for j in range(len(i)):
            if i[j] >= candidate: bit_tmp |= 1 << j
        binary_bit[bit_tmp] = True
    
    for i in range(1 << m):
        for j in range(1 << m):
            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:
                ans = i , j
                break
    return ans
 
def backtracking(candidate,ans,data):
    idx_i = -1 ; idx_j = -1
    for i in range(len(data)):
        bit_tmp = 0
        for j in range(len(data[i])):
            if data[i][j] >= candidate: bit_tmp |= 1 << j
        if bit_tmp == ans[0]: idx_i = i
        if bit_tmp == ans[1]: idx_j = i
 
    print(str(idx_i + 1) + "" "" + str(idx_j + 1))
 
def main():
    n , m = [int(i) for i in input().split()]
    data = [[int(i) for i in input().split()] for i in range(n)]
    a = 0 ; b = 10**9 + 7
    ans = (-1,-1)
    candidate = -1
    while a <= b:
        mid = (a + b)//2
        bin_ans = find_pair(mid,data,m)
        if bin_ans[0] != -1 and bin_ans[1] != -1:
            ans = bin_ans
            candidate = mid
            a = mid + 1
        else:
            b = mid - 1
    backtracking(candidate,ans,data)
 
main()",np,"binary search,bitmasks,dp",1307
"import sys
input = sys.stdin.buffer.readline
n,m=map(lambda x:int(x), input().split())
A = []
for _ in range(n):
    scores = list(map(lambda x:int(x), input().split()))
    A.append(scores)

def solve(n,m,A):
    # O(31*( 5*n + 4**5 ))
    # all index from 0
    ans = ()
    nstats = 2**m
    def judge(finalScore):
        nonlocal ans
        seen = {}
        for i,scores in enumerate(A):
            sta = 0
            for e in scores:
                sta=sta*2+(e>=finalScore)
            # example [1,2,3,4,1], finalScore=3
            # sta = 0b00110
            seen[sta]=i
        
        for i in range(nstats):
            for j in range(nstats):
                if ((i|j) == nstats-1) and i in seen and j in seen:
                    ans = (seen[i], seen[j])
                    return True

        return False
    
    l=0
    r=2**31-1
    while l<r:
        m=l+(r-l)//2
        if not judge(m):
            r=m
        else:
            l=m+1
    # Highest score is l-1
    print(ans[0]+1,ans[1]+1) # answer index start from 1

solve(n,m,A)
",np,"binary search,bitmasks,dp",1064
"import io,os
# input = sys.stdin.buffer.readline
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
n,m=map(lambda x:int(x), input().split())
A = []
for _ in range(n):
    scores = list(map(lambda x:int(x), input().split()))
    A.append(scores)

def solve(n,m,A):
    # O(31*( 5*n + 4**5 ))
    # all index from 0
    ans = ()
    nstats = 2**m
    def judge(finalScore):
        nonlocal ans
        seen = {}
        for i,scores in enumerate(A):
            sta = 0
            for e in scores:
                sta=sta*2+(e>=finalScore)
            # example [1,2,3,4,1], finalScore=3
            # sta = 0b00110
            seen[sta]=i
        
        for i in range(nstats):
            for j in range(nstats):
                if ((i|j) == nstats-1) and i in seen and j in seen:
                    ans = (seen[i], seen[j])
                    return True

        return False
    
    l=0
    r=2**31-1
    while l<r:
        m=l+(r-l)//2
        if not judge(m):
            r=m
        else:
            l=m+1
    # Highest score is l-1
    print(ans[0]+1,ans[1]+1) # answer index start from 1

solve(n,m,A)
",np,"binary search,bitmasks,dp",1129
"import sys,os,io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import defaultdict

n,m = [int(i) for i in input().split()]
a = []
mi = -1
ma = 10**9
for i in range (n):
    a.append([int(j) for j in input().split()])

ans = []
while(mi<ma):
    mid = (mi+ma+1)//2
    masks = {}
    for i in range (n):
        currMask = 0
        for j in range (m):
            if a[i][j] >= mid:
                currMask +=  1<<j
        masks[currMask] = i
    req = (1<<m) - 1
    possible = 0
    for i in masks:
        for j in masks:
            if i|j == req:
                possible = 1
                ans = [masks[i]+1,masks[j]+1]
                break
        if possible:
            break
    if possible:
        mi = mid
    else:
        ma = mid - 1
print(*ans)",np,"binary search,bitmasks,dp",798
"# Legends Always Come Up with Solution
# Author: Manvir Singh

import os
import sys
from io import BytesIO, IOBase
from collections import Counter

def check(a,mid,n,m,z):
    b=Counter()
    for i in range(n):
        c=[""0""]*m
        for j in range(m):
            if a[i][j]>=mid:
                c[j]=""1""
        zz=int("""".join(c),2)
        b[zz]=i
    c=list(b.keys())
    lc=len(c)
    for i in range(lc):
        for j in range(i,lc):
            if c[i]|c[j]==z:
                mi,x,y=10000000000,b[c[i]],b[c[j]]
                for k in range(m):
                    mi=min(mi,max(a[x][k],a[y][k]))
                if mi>=mid:
                    return (x,y)
def main():
    n,m= map(int, input().split())
    a=[list(map(int,input().split())) for _ in range(n)]
    lo,hi,ans,y=0,10**9,[1,1],(1<<m)-1
    while lo<=hi:
        mid=(lo+hi)//2
        z=check(a,mid,n,m,y)
        if z:
            lo=mid+1
            ans=[z[0]+1,z[1]+1]
        else:
            hi=mid-1
    print(*ans)
# (region fastio
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()",np,"binary search,bitmasks,dp",2708
"import os
import sys
from io import BytesIO, IOBase
 
# region fastio
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

n,m = map(int,input().split())

A = [None]*n
lo,hi = 1<<32,-1<<32
for i in range(n):
    A[i] = list(map(int,input().split()))
    lo = min(min(A[i]), lo)
    hi = max(max(A[i]), hi)

best = -1
ans = [-1,-1]

def possible(x):
    global best, ans
    # is the answer at least x?
    M = [-1]*(1<<m)

    for i in range(n):
        mask = 0
        for j in range(m):
            if A[i][j] >= x:
                mask += (1<<j)
        M[mask] = i

    for m0 in range(1<<m):
        if M[m0] == -1:
            continue

        for m1 in range(1<<m):
            if M[m1] == -1:
                continue

            if m0 | m1 == (1<<m) - 1:
                if best < x:
                    best = x
                    ans = [M[m0]+1, M[m1]+1]

                return True
    return False

possible(hi)
possible(lo)

while lo+1 < hi:
    mid = (lo+hi)//2
    if possible(mid):
        lo = mid
    else:
        hi = mid

print(*ans)
",np,"binary search,bitmasks,dp",2672
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
n,m=map(int,input().split())
a=[list(map(int,input().split())) for i in range(n)]
l=-1;r=10**9+1
ans1,ans2=-1,-1
while r-l>1:
    x=(l+r)//2
    idx={}
    for i in range(n):
        v=0
        for j in range(m):
            if a[i][j]>=x:
                v+=1
            v<<=1
        idx[v>>1]=i
    ok=False
    idx1,idx2=0,0
    for aa,bb in idx.items():
        for cc,dd in idx.items():
            for d in range(m):
                if (aa|cc)==(2**m)-1:
                    ok=True
                    idx1=bb+1
                    idx2=dd+1
    if ok:
        l=x
        ans1=idx1
        ans2=idx2
    else:
        r=x
print(ans1,ans2)",np,"binary search,bitmasks,dp",723
"import os
import sys
from io import BytesIO, IOBase
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#######################################
from collections import defaultdict as dd
n,m=map(int,input().split())
l1=[]
for i in range(n):
    l1.append(list(map(int,input().split())))
l=0
h=10**9
c=2**m-1
x,y=1,2
while l<=h:
    mid=(l+h)//2
    d=dd(int)
    d1=dd(int)
    for i in range(n):
        s=[]
        for j in range(m):
            if l1[i][j]>=mid:
                s.append('1')
            else:
                s.append('0')
        s=int(''.join(s),2)
        d[s]+=1
        d1[s]=i+1
    f=0
    for i in d:
        for j in d:
            if i|j==c:
                f=1
                x=d1[i]
                y=d1[j]
                break
        if f:
            break
    if f:
        if l==h:
            break
        l=mid+1
    else:
        if l==h:
            break
        h=mid
print(x,y)
        
",np,"binary search,bitmasks,dp",2546
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------- fast io --------------------
from math import ceil


def prod(a, mod=10 ** 9 + 7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans


def gcd(x, y):
    while y:
        x, y = y, x % y
    return x


def lcm(a, b): return a * b // gcd(a, b)


def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

from math import inf

for _ in range(int(input()) if not True else 1):
    #n = int(input())
    n, m = map(int, input().split())
    # a, b = map(int, input().split())
    # c, d = map(int, input().split())
    # a = list(map(int, input().split()))
    # b = list(map(int, input().split()))
    # s = input()
    a = []
    for i in range(n):
        a += [list(map(int, input().split()))]
    
    alpha, omega = 0, 10**9
    def solve(mid):
        index = [-1] * (1 << m)
        for i in range(n):
            val = 0
            for j in range(m):
                if a[i][j] >= mid:
                    val += (1 << j)
            index[val] = i + 1
        pos = False
        for mask in range(1 << m):
            for mask2 in range(1 << m):
                if mask | mask2 != (1 << m) - 1: continue
                if min(index[mask], index[mask2]) != -1:
                    pos = (index[mask], index[mask2])
                    break
        return pos
    while alpha < omega:
        mid = (alpha + omega + 1) // 2
        if solve(mid):
            alpha = mid
        else:
            omega = mid - 1
    print(*solve(alpha))",np,"binary search,bitmasks,dp",3322
"# ------------------- fast io --------------------
import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0
    
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
    
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
    
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
    
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------- fast io --------------------
from math import ceil


def prod(a, mod=10 ** 9 + 7):
    ans = 1
    for each in a:
        ans = (ans * each) % mod
    return ans


def gcd(x, y):
    while y:
        x, y = y, x % y
    return x


def lcm(a, b): return a * b // gcd(a, b)


def binary(x, length=16):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

from math import inf

for _ in range(int(input()) if not True else 1):
    #n = int(input())
    n, m = map(int, input().split())
    # a, b = map(int, input().split())
    # c, d = map(int, input().split())
    # a = list(map(int, input().split()))
    # b = list(map(int, input().split()))
    # s = input()
    a = []
    for i in range(n):
        a += [list(map(int, input().split()))]
    
    alpha, omega = 0, 10**9
    def solve(mid):
        index = [-1] * (1 << m)
        for i in range(n):
            val = 0
            for j in range(m):
                if a[i][j] >= mid:
                    val += (1 << j)
            index[val] = i + 1
        is_subset = list(index)
        for i in range(m):
            for mask in range(1 << m):
                if mask & (1 << i):
                    is_subset[mask^(1<<i)] = max(is_subset[mask], is_subset[mask ^ (1 << i)])
        pos = False
        for mask in range(1 << m):
            if index[mask] == -1: continue
            mask2 = ((1 << m) - 1) ^ mask
            if is_subset[mask2] != -1:
                pos = (index[mask], is_subset[mask2])
                break
        return pos
    while alpha < omega:
        mid = (alpha + omega + 1) // 2
        if solve(mid):
            alpha = mid
        else:
            omega = mid - 1
    print(*solve(alpha))",np,"binary search,bitmasks,dp",3515
"import sys
input = sys.stdin.readline

n, m = map(int, input().split())
mask = (1 << m) - 1

l = []
for i in range(n):
    l.append(list(map(int,input().split())))

lo = -1 #Possible
hi = 10 ** 9 + 1 #Impossible
while hi - lo > 1:
    test = (hi + lo) // 2

    things = dict()
    for i in range(n):
        curr = 0
        for v in l[i]:
            curr *= 2
            if v >= test:
                curr += 1
        things[curr] = i

    works = False
    for v1 in things:
        for v2 in things:
            if v1 | v2 == mask:
                outi = things[v1]
                outj = things[v2]
                works = True
                break
        if works:
            break

    if works:
        lo = test
    else:
        hi = test

print(outi + 1, outj + 1)
",np,"binary search,bitmasks,dp",782
"def isPoss(n, arrs, nvals):
    masks = set()
    midx = {}
    for pos,arr in enumerate(arrs):
        mask = 0
        for i in range(nvals):
            if arr[i]>=n:
                mask += 1<<i
        midx[mask] = pos+1
        masks.add(mask)

    for m1 in masks:
        for m2 in masks:
            if m1|m2 == (1<<nvals)-1:
                return midx[m1], midx[m2]

    return -1, -1
                

narr, nvals = map(int, input().split())

arrs = []
for i in range(narr):
    arrs.append(list(map(int, input().split())))

mn = -1
mx = 10**9+1
while mn < mx-1:
    mid = (mn + mx) // 2
    a,b = isPoss(mid, arrs, nvals)
    if a != -1:
        mn = mid
    else:
        mx = mid - 1

for i in range(1,-1,-1):      
    a,b = isPoss(mn+i, arrs, nvals)
    if a != -1:
        print(a,b)
        break

",np,"binary search,bitmasks,dp",817
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__

n,m = map(int, input().split())
a = []
for i in range(n):
    ai = list(map(int, input().split()))
    a.append(ai)

def check(mid):
    mask = (1<<m)-1
    s = set()
    d = dict()
    for i in range(n):
        state = 0
        for j in range(m):
            if a[i][j] >= mid:
                state += 1<<j
        if state in s:
            continue
        s.add(state)
        k = state
        while k>=0:
            k &= state
            d[k] = i
            k -= 1
        need = mask^state
        if need in d:
            q1, q2 = d[need], i
            if q1 > q2:
                q1, q2 = q2, q1
            return True, (q1, q2)
    return False, (-1, -1)

left = 0
right = 10**9+1
i,j = 0, 0
while right-left>1:
    mid = (right+left)//2
    flag, (q1, q2) = check(mid)
    if flag:
        left = mid
        i,j = q1, q2
    else:
        right = mid
print(i+1, j+1)

",np,"binary search,bitmasks,dp",966
"import sys
input = sys.stdin.readline

def main():
    n,m = map(int,input().split())
    a = []
    for _ in [0]*n:
        a.append(list(map(int,input().split())))
    
    ok = 0
    ng = 10**9+1
    judge = pow(2,m)-1
    dg = 1000

    while ng-ok > 1:
        mid = (ng+ok)//2
        tank = set()
        for i in range(n):
            r = 0
            for j in range(m):
                r *= 2
                if a[i][j] >= mid:
                    r += 1
            tank.add(r)

        for p in tank:
            for q in tank:
                if p|q == judge:
                    ok = mid
                    break
        if ok != mid:
            ng = mid

    tank = set()
    res = []
    for i in range(n):
        r = 0
        for j in range(m):
            r *= 2
            if a[i][j] >= ok:
                r += 1
        if not r in tank:
            res.append(i*dg+r)
        tank.add(r)

    for p in res:
        for q in res:
            if (p%dg)|(q%dg) == judge:
                print(p//dg+1,q//dg+1)
                return


if __name__ == '__main__':
    main()",np,"binary search,bitmasks,dp",1096
"import sys
readline = sys.stdin.readline

def popcount(i):
    assert 0 <= i < 0x100000000
    i = i - ((i >> 1) & 0x55555555)
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333)
    return (((i + (i >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24

N, M = map(int, readline().split())

Ar = [tuple(map(int, readline().split())) for _ in range(N)]

pc = [popcount(i) for i in range(1<<(M+1))]

inf = 1<<31
maxi = [0]*(1<<M)

for i in range(N):
    a = Ar[i]
    dp = [0]*(1<<M)
    for S in range(1, 1<<M):
        p = pc[S]
        if p == 1:
            k = S.bit_length() - 1
            dp[S] = a[k]
        else:
            dp[S] = min(dp[-S&S], dp[S^(-S&S)]) 
        maxi[S] = max(maxi[S], dp[S])
for i in range(M):
    for j in range(1<<M):
        if not j & (1<<i):
            maxi[j] = max(maxi[j], maxi[j|(1<<i)])

D = (1<<M)-1
ans = maxi[D]
aS, bS = D, D
for S in range(1<<M):
    candi = min(maxi[S], maxi[D^S])
    if candi > ans:
        aS, bS = S, D^S
        ans = candi

Ans = [None]*2
pre = False
fro = False

for i in range(N):
    a = Ar[i]
    resa = inf
    resb = inf
    for j in range(M):
        if (1<<j)&aS:
            resa = min(resa, a[j])
        else:
            resb = min(resb, a[j])
    if resa >= ans:
        pre = True
        Ans[0] = i+1
    if resb >= ans:
        fro = True
        Ans[1] = i+1
    if pre and fro:
        break
print(*Ans)
",np,"binary search,bitmasks,dp",1393
"import sys
input = sys.stdin.readline

n,m=map(int,input().split())
A=[list(map(int,input().split())) for i in range(n)]

SET=set()
for a in A:
    SET|=set(a)

compression_dict={a: ind for ind, a in enumerate(sorted(SET))}

for i in range(n):
    A[i]=[compression_dict[a] for a in A[i]]

OK=0
NG=len(compression_dict)
ANS=[1,1]
B=[set()]*n
P=[2,3,5,7,11,13,17,19]
Q=1
for j in range(m):
    Q*=P[j]
    
import math

def ya(x):
    xr=math.ceil(math.sqrt(x))

    LIST=[]
    for i in range(1,xr+1):
        if x%i==0:
            LIST.append(i)
            LIST.append(x//i)

    return LIST

while NG>OK+1:
    mid=(OK+NG)//2
    SET=set()

    for i in range(n):
        NOW=1
        for j in range(m):
            if A[i][j]>=mid:
                NOW*=P[j]
        B[i]=NOW
        SET.add(NOW)

    #print(mid,SET)
    flag=0

    for s in SET:
        for l in ya(s):
            if Q//l in SET:
                flag=1
                OK=mid
                break
        if flag:
            break

    else:
        NG=mid

SET=set()
for i in range(n):
    NOW=1
    for j in range(m):
        if A[i][j]>=OK:
            NOW*=P[j]
    B[i]=NOW
    SET.add(NOW)

flag=0
for i in range(n):
    for l in ya(B[i]):
        if Q//l in SET:
            ANS1=i
            flag=1
            break
    if flag:
        break

LIST=ya(B[i])
SET=set(LIST)

for i in range(n):
    if Q//B[i] in SET:
        ANS2=i

print(ANS1+1,ANS2+1)
",np,"binary search,bitmasks,dp",1439
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
left = 0
right = 10**9+1
ans = (0, 0)
while left < right:
    mid = (left + right) // 2
    masks = {}
    for i in range(n):
        mask = 0
        for j in a[i]:
            mask <<= 1
            if j >= mid:
                mask += 1
        masks[mask] = i
    ok = False
    for m1 in masks:
        for m2 in masks:
            if m1 | m2 == ((1 << m) - 1):
                ok = True
                ans = (masks[m1]+1, masks[m2]+1)
                break
        if ok:
            break
    if ok:
        left = mid+1
    else:
        right = mid
print(ans[0], ans[1])
",np,"binary search,bitmasks,dp",670
"
def main():
  N, M = map(int, input().split())
  L = [tuple(map(int, input().split())) for _ in range(N)]
  maxi = max(max(t) for t in L)+1
  mini, res = max((min(t), i) for i, t in enumerate(L))
  res = res, res
  BITMASK = (1 << M)
  while True:
    mid = (maxi+mini)//2
    #print(f'{mini} {mid} {maxi}')
    if mid == mini:
      break
    masks = [None]*BITMASK
    for i, t in enumerate(L):
      tmask = 0
      for v in t:
        tmask *= 2
        if v >= mid:
          tmask += 1
      if masks[tmask] is not None:
        continue
      masks[tmask] = i
      for k in range(BITMASK):
        if masks[k] is not None and k | tmask == BITMASK-1:
          res = masks[k], i
          mini = mid = min(max(a, b) for a, b in zip(L[res[0]], L[res[1]]))
          break
      else:
        continue
      break
    else:
      maxi = mid
    #print(masks)
  print(res[0]+1, res[1]+1)


main()
",np,"binary search,bitmasks,dp",902
"import sys
from collections import defaultdict

reader = (map(int, line.split()) for line in sys.stdin)
input = reader.__next__

n, m = input()
# n, m = 3 * 10 ** 5, 8
elems = set()
vals = defaultdict(list)
for i in range(n):
    for pos, v in enumerate(input()):
        elems.add(v)
        vals[v].append((pos, i))

elems = sorted(elems, reverse=True)

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in elems:
    for pos, i in vals[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()
",np,"binary search,bitmasks,dp",656
"# -*- coding:utf-8 -*-

""""""

created by shuangquan.huang at 1/15/20

""""""

import collections
import time
import os
import sys
import bisect
import heapq
from typing import List


def check(val, A, M):
    s = set()
    for row in A:
        v = 0
        for u in row:
            v <<= 1
            if u >= val:
                v |= 1
        s.add(v)
    
    x = 1 << M
    for u in s:
        for v in range(x):
            if v in s and u | v == x - 1:
                return True
            
    return False


def getAnswer(val, A, M):
    vi = {}
    for i, row in enumerate(A):
        v = 0
        for u in row:
            v <<= 1
            if u >= val:
                v |= 1
        vi[v] = i
        
    x = 1 << M
    for u in vi:
        for v in range(x):
            if v in vi and u | v == x - 1:
                return vi[u], vi[v]
    
    return 0, 0


def solve(N, M, A):
    lo, hi = 0, max([max(row) for row in A])
    
    while lo <= hi:
        m = (lo + hi) // 2
        if check(m, A, M):
            lo = m + 1
        else:
            hi = m - 1
    
    a, b = getAnswer(hi, A, M)
    print('{} {}'.format(a + 1, b + 1))



N, M = map(int, input().split())
A = []
for i in range(N):
    row = [int(x) for x in input().split()]
    A.append(row)

solve(N, M, A)
",np,"binary search,bitmasks,dp",1301
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
a=[]
def bs(a,mid,ans):
    global n,m
    can=[0 for i in range(1<<m)]
    for i in range(n):
        t=0
        for j in range(m):
            t=(t<<1)|(a[i][j]>=mid)
           
        can[t]=i+1
    #print(can)    
    for i in range(1<<m):
        if(not can[i]):
            continue
        for j in range(1<<m):
            if not can[j]:
                continue
            if i|j==(1<<m)-1:
                #print(i,j)
                ans[0]=can[i]
                ans[1]=can[j]
                return 1
    return 0            
                
for i in range(n):
    p=[int(x) for x in input().split()]
    a.append(p)
l=0
r=100000000000
ans=[1,1]
while l<=r:
    mid=(l+r)//2
    if bs(a,mid,ans):
        l=mid+1
    else:
        r=mid-1
    #print(l,r,ans,mid)    
print(*ans)        
        
    ",np,"binary search,bitmasks,dp",882
"# -*- coding: utf-8 -*-

import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = 10 ** 18
MOD = 10 ** 9 + 7

def bisearch_max(mn, mx, func):

    ok = mn
    ng = mx
    while ok+1 < ng:
        mid = (ok+ng) // 2
        if func(mid):
            ok = mid
        else:
            ng = mid
    return ok

def check(m):
    ok = [0] * N
    S = set()
    for i in range(N):
        for j in range(M):
            if A[i][j] >= m:
                ok[i] |= 1<<j
        S.add(ok[i])
    full = (1<<M) - 1
    for bit1 in range(1<<M):
        for bit2 in range(bit1, 1<<M):
            if bit1 in S and bit2 in S:
                if bit1 | bit2 == full:
                    return True
    return False

N, M = MAP()
A = [None] * N
for i in range(N):
    A[i] = LIST()

res = bisearch_max(0, 10**9+1, check)
ok = [0] * N
S = set()
D = {}
for i in range(N):
    for j in range(M):
        if A[i][j] >= res:
            ok[i] |= 1<<j
    S.add(ok[i])
    D[ok[i]] = i + 1
full = (1<<M) - 1
for bit1 in range(1<<M):
    for bit2 in range(bit1, 1<<M):
        if bit1 in S and bit2 in S:
            if bit1 | bit2 == full:
                print(D[bit1], D[bit2])
                exit()
",np,"binary search,bitmasks,dp",1750
"from collections import defaultdict
from sys import stdin
input = stdin.readline
def check(mid, m):
    d = defaultdict(int)
    for idx, i in enumerate(a):
        string = ''
        for j in i:
            if j >= mid:
                string+='1'
            else:
                string+='0'
        d[int(string, 2)] = idx
    for i in d.keys():
        for j in d.keys():
            if i|j == 2**m - 1:
                 return [d[i], d[j]]
    return []
def binarySearch(lo, hi, m):
    ans = []
    while lo < hi:
        mid = lo + (hi-lo+1)//2
        x = check(mid, m)
        if x:
            lo = mid
            ans = [x[0]+1, x[1]+1]
        else:
            hi = mid-1
    return ans
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
print(*binarySearch(-1, 10**9+1, m))",np,"binary search,bitmasks,dp",843
"from collections import defaultdict
from sys import stdin
input = stdin.readline
def check(mid, m):
    d = defaultdict(int)
    for idx, i in enumerate(a):
        string = ''
        for j in i:
            if j >= mid:
                string+='1'
            else:
                string+='0'
        d[int(string, 2)] = idx
    for i in d.keys():
        for j in d.keys():
            if i|j == 2**m - 1:
                 return [d[i], d[j]]
    return []
def binarySearch(lo, hi, m):
    ans = []
    while lo < hi:
        mid = lo + (hi-lo+1)//2
        x = check(mid, m)
        if x:
            lo = mid
            ans = [x[0]+1, x[1]+1]
        else:
            hi = mid-1
    mid = lo + (hi-lo+1)//2
    x = check(mid, m)
    if x:
        ans = [x[0]+1, x[1]+1]
    return ans
n, m = map(int, input().split())
a = []
for i in range(n):
    a.append(list(map(int, input().split())))
print(*binarySearch(0, 10**9, m))",np,"binary search,bitmasks,dp",931
"'''input
6 5
5 0 3 1 2
1 8 9 1 3
1 2 3 4 5
9 1 0 3 7
2 3 0 6 3
6 4 1 7 0
'''
# A coding delight
from sys import stdin, stdout
import gc
gc.disable()
input = stdin.readline
from collections import defaultdict


def check(num):
	bitmask = set()
	for i in range(n):
		b = 0
		for j in range(m):
			if arr[i][j] >= num:
				b ^= 1 << j
		bitmask.add(b)
	# print(num, bitmask)
	target = 2** m  - 1
	for i in bitmask:
		for j in bitmask:
			if i | j ==  target:
				return True
	return False


# main starts
n, m = list(map(int, input().split()))
arr = []
for _ in range(n):
	arr.append(list(map(int, input().split())))

# print(check(3))

start = 0
end = 10 ** 9
ans = -1
while start <= end:
	mid = (start + end) // 2
	if check(mid):
		ans = mid
		start = mid + 1
	else:
		end = mid - 1

bitmask = defaultdict(list)
for i in range(n):
	b = 0
	for j in range(m):
		if arr[i][j] >= ans:
			b  += 1<< j
	bitmask[b].append(i + 1)
target = 2 ** m - 1
for i in bitmask:
	for j in bitmask:
		if i | j == target:
			print(bitmask[i][0], bitmask[j][0])
			exit()
",np,"binary search,bitmasks,dp",1049
"import os, sys, atexit
from io import BytesIO, StringIO
 
input = BytesIO(os.read(0, os.fstat(0).st_size)).readline
_OUTPUT_BUFFER = StringIO()
sys.stdout = _OUTPUT_BUFFER
 
@atexit.register
def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())

n, m = map(int, input().split())
arr = [0] * n
for i in range(n):
    temp = list(map(int, input().split()))
    arr[i] = temp
x = 1
N = 2 ** m - 1
lo = 1
hi = 1000000009
ind = [0, 0]
while 1:
    l = {}
    freq = [0] * (2 ** m)
    for i in range(n):
        an = 0
        for j in range(m):
            if arr[i][j] >= x: an += 2 ** (m - j - 1)
        if freq[an] == 0:
            l[i] = an
        freq[an] = 1
    # print(l)
    ch = 0
    for k1, v1 in l.items():
        for k2, v2 in l.items():
            # if v1 == v2: continue
            if v1 | v2 == N:
                ch = 1
                ind[0] = k1 + 1
                ind[1] = k2 + 1
                # print(x)
                break
        if ch: break
    if ch:
        lo = x
        x = x * 2
    else:
        hi = x
        break
ans = lo
while hi - lo > 1:
    x = (lo + hi) // 2
    l = {}
    freq = [0] * (2 ** m)
    for i in range(n):
        an = 0
        for j in range(m):
            if arr[i][j] >= x: an += 2 ** (m - j - 1)
        if freq[an] == 0:
            l[i] = an
        freq[an] = 1
    # print(l)
    ch = 0
    for k1, v1 in l.items():
        for k2, v2 in l.items():
            # if v1 == v2: continue
            if v1 | v2 == N:
                ch = 1
                ind[0] = k1 + 1
                ind[1] = k2 + 1
                # print(x)
                break
        if ch: break
    if ch:
        lo = x
    else:
        hi = x
ans = lo
# print(ans)
if ind[0] == 0: print(""1 1"")
else: print(*ind)",np,"binary search,bitmasks,dp",1773
"m,n=[int(ele) for ele in input().split()]
a=[]
for i in range(m):
    a.append(list(map(int, input().split())))


ina,mo=0,10**9+1
pos1,pos2=0,0
mask=(1<<n)-1
def check(tang):
    key=set()
    dic=dict()
    for i in range(m):
        temp=0 
        for j in range(n):
            if a[i][j]>=tang:
                #print(""ya"")
                temp+=(1<<j)
        #print(bin(temp),a[i],tang)
        if temp in key:
            continue
        key.add(temp)
        tempk=temp
        while tempk>=0:
            tempk &= temp
            dic[tempk]=i
            tempk-=1
            
        tocheck = mask ^ temp
        #print(bin(tocheck),bin(temp),bin(mask),a[i],tang)

        if tocheck in dic:
            return dic[tocheck],i,True

    #print(dic)
    return -1,-1,False
        
while ina<mo-1:
    #print(ina,mo)
    tang=(ina+mo)//2
    #print(ina,mo,tang)
    temppos1,temppos2,status=check(tang)
    #print(status)
    if status:
        pos1,pos2=temppos1,temppos2
        ina=tang
    else:
        mo=tang
print(pos1+1,pos2+1)
    
",np,"binary search,bitmasks,dp",1055
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__
 
n,m = map(int, input().split())
a = []
for i in range(n):
    ai = list(map(int, input().split()))
    a.append(ai)
 
def check(mid):
    mask = (1<<m)-1
    s = set()
    d = dict()
    for i in range(n):
        state = 0
        for j in range(m):
            if a[i][j] >= mid:
                state += 1<<j
        #if state!=0:
            #print(""1bin"",bin(state),mid,a[i])
        if state in s:
            continue
        s.add(state)
        k = state
        while k>=0:
            #print(k,state)
            k &= state
            d[k] = i
            k -= 1
        need = mask^state
        #print(s,d,need,state)
        if need in d:
            q1, q2 = d[need], i
            if q1 > q2:
                q1, q2 = q2, q1
            return True, (q1, q2)
    #print(s,d,need,bin(state))
    return False, (-1, -1)
 
left = 0
right = 10**9+1
i,j = 0, 0
while right-left>1:
    mid = (right+left)//2
    flag, (q1, q2) = check(mid)
    #print(""resround"",mid,left,right,i,j,q1,q2)
    if flag:
        left = mid
        i,j = q1, q2
    else:
        right = mid
print(i+1, j+1)
 
",np,"binary search,bitmasks,dp",1178
"import sys
reader = (s.rstrip() for s in sys.stdin)
input = reader.__next__
m,n=[int(ele) for ele in input().split()]
a=[]
for i in range(m):
    a.append(list(map(int, input().split())))


ina,mo=0,10**9+1
pos1,pos2=0,0
mask=(1<<n)-1
def check(tang):
    key=set()
    dic=dict()
    for i in range(m):
        temp=0 
        for j in range(n):
            if a[i][j]>=tang:
                #print(""ya"")
                temp+=(1<<j)
        #print(bin(temp),a[i],tang)
        if temp in key:
            continue
        key.add(temp)
        tempk=temp
        while tempk>=0:
            tempk &= temp
            dic[tempk]=i
            tempk-=1
            
        tocheck = mask ^ temp
        #print(bin(tocheck),bin(temp),bin(mask),a[i],tang)

        if tocheck in dic:
            return dic[tocheck],i,True

    #print(dic)
    return -1,-1,False
        
while ina<mo-1:
    #print(ina,mo)
    tang=(ina+mo)//2
    #print(ina,mo,tang)
    temppos1,temppos2,status=check(tang)
    #print(status)
    if status:
        pos1,pos2=temppos1,temppos2
        ina=tang
    else:
        mo=tang
print(pos1+1,pos2+1)
    
",np,"binary search,bitmasks,dp",1131
"def check(x: int) -> (int, int):
    vis = {}
    for i, array in enumerate(a):
        t = 0
        for j, val in enumerate(array):
            if val >= x:
                t |= 1 << j
        vis[t] = i
    if (1 << m) - 1 in vis:
        return vis[(1 << m) - 1], vis[(1 << m) - 1]
    for i in range(1, (1 << m) - 1):
        for j in range(1, (1 << m) - 1):
            if i in vis and j in vis and i | j == (1 << m) - 1:
                return vis[i], vis[j]
    return -1, -1


if __name__ == '__main__':
    n, m = map(int, input().split())
    a = []
    for i in range(n):
        a.append(list(map(int, input().split())))
    l = 0
    r = int(1e9)
    while l <= r:
        mid = l + r >> 1
        if check(mid) != (-1, -1):
            l = mid + 1
        else:
            r = mid - 1
    ans = check(r)
    print(""%d %d"" % (ans[0] + 1, ans[1] + 1))
",np,"binary search,bitmasks,dp",866
"# import builtins

debug = 0
BIG = 10 ** 9 + 1

input = raw_input


def prof(f):
    return f
    # if 'profile' in dir(builtins):
    #     return profile(f)
    # else:
    #     return f


def report(f):
    def new_f(x):
        res = f(x)
        # print(f""{x}  --> {res}"")
        return res

    return new_f if debug else f


def mcheck(a, pairs):
    m = len(a[0])
    allm = 2 ** m - 1

    subs = {i: {i} for i in range(allm + 1)}

    for i in range(allm + 1):
        for j in range(i):
            if i | j == i:  # 11 1  10 1   00 0  01 1
                subs[i].add(j)

    mx = [max(aa) for aa in a]

    @prof
    def check(v):
        masks = {0: -1}
        done = [False] * (allm + 1)
        for i, aa in enumerate(a):
            if mx[i] < v:
                continue
            c = sum(1 << b for b in range(len(aa)) if aa[b] >= v)
            # if c == allm:
            #     pairs[v] = i, i
            #     return True
            if not done[c]:
                for cc in subs[c]:
                    if allm - cc in masks:
                        other = masks[allm - c]
                        pairs[v] = i, other
                        return True
                    masks[cc] = i
                    done[cc] = True
                # masks[c] = i
        # for ma, mb in itertools.combinations(masks, 2):
        #     if ma | mb == allm:
        #         pairs[v] = masks[ma], masks[mb]
        #         return True
        return False

    return check


@prof
def go():
    n, m = map(int, input().split())

    a = []
    # mx = 0
    # mnmx = 0
    uniq = set()
    for _ in range(n):
        aa = tuple(map(int, input().split()))
        # mx = max(mx, max(aa))
        # mnmx = max(mnmx, min(aa))
        a.append(aa)
        uniq.update(aa)

    uniq = sorted(uniq)
    pairs = {0: (0, 0)}
    check = mcheck(a, pairs)
    l = 0
    r = len(uniq) - 1
    while l != r:
        if debug: print(l, r)
        if l + 1 == r:
            if check(uniq[r]):
                l = r
            else:
                r = l
            continue
        c = (l + r) // 2
        if check(uniq[c]):
            l = c
        else:
            r = c

    l = uniq[l]
    if debug: print(l, pairs[l])
    if l not in pairs:
        check(l)
    a = pairs[l][0]
    b = pairs[l][1]
    if b == -1:
        b = a

    print(""%d %d"" % (a + 1, b + 1))


go()
",np,"binary search,bitmasks,dp",2391
"# binary search answer
# O((nm+4^m)logA)
import sys
reader = (s.rstrip() for s in sys.stdin)
inp = reader.__next__

n, m = map(int, inp().split())
arr = tuple(tuple(map(int, inp().split())) for i in range(n))
lower_bound = 0
upper_bound = int(1e9) + 1
mask = (1 << m) - 1

ans = (0, 0)


def can_upper(mid):
	global ans
	"""""" return exist answer that >= m (boolean)
	O(nm + 4^m)
	""""""
	# O(nm)
	d = dict()
	for i in range(n):
		bit = 0
		for j in range(m):
			if arr[i][j] >= mid:
				bit += 1 << j
		d[bit] = i

	# O(m * (2^m)^2) = O(4^m)
	keys = tuple(d.keys())
	for i in range(len(keys)):
		a1 = keys[i]
		for j in range(i, len(keys)):
			a2 = keys[j]
			if a1 | a2 == mask:
				ans = (d[a1], d[a2])
				return True
	return False


while upper_bound - lower_bound > 1:
	middle = (upper_bound + lower_bound) >> 1
	if can_upper(middle):
		lower_bound = middle
	else:
		upper_bound = middle

print(ans[0] + 1, ans[1] + 1)",np,"binary search,bitmasks,dp",919
"
def check(mid,n,m,arr):
	masks = {}
	for index in range(n):
		array = arr[index]
		x = 0
		for i in range(m):
			if array[i] >= mid:
				x ^= (1<<i)
		masks[x] = index+1
	ans = False
	a,b = 1,1
	if (1<<m)-1 in masks.keys():
		return True,(masks[(1<<m)-1],masks[(1<<m)-1])
	for i in  masks.keys():
		for j in masks.keys():
			orAns = i|j
			if(orAns == ((1<<m)-1)):
				if i == (1<<m)-1 and (i in masks.keys()):
					a = masks[i]
					ans = True
					break
				elif j == (1<<m)-1 and (j in masks.keys()):
					b =  masks[j]
					ans = True
					break
				elif (i in masks.keys()) and (j in masks.keys()):
					ans = True
					a,b = masks[i],masks[j]
					break
	return ans,(a,b)

def solve(n,m,arr):
	mini = 0
	maxi = int(1e9)+5
	i,j = 1,1
	while(mini<=maxi):
		mid = (mini+maxi)//2
		ans,res = check(mid,n,m,arr)
		if(ans):
			i,j = res
			mini =mid +1
		else:
			maxi = mid -1
	print(i,j)

def main():
	n,m = map(int,input().split(' '))
	arr = []
	for _ in range(n):
		x = list(map(int,input().split(' ')))
		arr.append(x)
	solve(n,m,arr)

main()",np,"binary search,bitmasks,dp",1048
"import sys

input = sys.stdin.buffer.readline

def find_pair(candidate,data,m):
    ans = (-1,-1)
    binary_bit = [False for i in range(1 << m)]
    for i in data:
        bit_tmp = 0
        for j in range(len(i)):
            if i[j] >= candidate: bit_tmp |= 1 << j
        binary_bit[bit_tmp] = True
    
    for i in range(1 << m):
        for j in range(1 << m):
            if i | j == (( 1 << m ) - 1) and binary_bit[i] and binary_bit[j]:
                ans = i , j
                break
    return ans

def backtracking(candidate,ans,data):
    idx_i = -1 ; idx_j = -1
    for i in range(len(data)):
        bit_tmp = 0
        for j in range(len(data[i])):
            if data[i][j] >= candidate: bit_tmp |= 1 << j
        if bit_tmp == ans[0]: idx_i = i
        if bit_tmp == ans[1]: idx_j = i

    print(str(idx_i + 1) + "" "" + str(idx_j + 1))

def main():
    n , m = [int(i) for i in input().split()]
    data = [[int(i) for i in input().split()] for i in range(n)]
    a = 0 ; b = 10**9 + 7
    ans = (-1,-1)
    candidate = -1
    while a <= b:
        mid = (a + b)//2
        bin_ans = find_pair(mid,data,m)
        if bin_ans[0] != -1 and bin_ans[1] != -1:
            ans = bin_ans
            candidate = mid
            a = mid + 1
        else:
            b = mid - 1
    backtracking(candidate,ans,data)

main()
",np,"binary search,bitmasks,dp",1337
"from sys import stdin, stdout

idx1 = 0
idx2 = 0
VALD = 0

def getminmax(n, m, a):
    l = 0
    h = 1000000009

    while l < h:
        mid = (l+h+1)//2
        exists = existsequalorbig(mid, m, a)

        if exists:
            #print(mid)
            l = mid
        else:
            h = mid-1

def existsequalorbig(mid, m, a):
    global idx1
    global idx2
    global VALD

    abw = []
    hs = set()

    for i in range(len(a)):
        v = 0
        for j in range(m):
            if a[i][j] >= mid:
                v |= 1
            v <<= 1
        v >>= 1
        if v not in hs:
            hs.add(v)
            abw.append([i, v])

    for i in range(len(abw)):
        for j in range(i, len(abw)):
            if abw[i][1] | abw[j][1] == VALD:
                idx1 = abw[i][0]
                idx2 = abw[j][0]
                return True

    #print(abw)
    #print(VALD)
    return False


#O(logA(4m+nm))
if __name__ == '__main__':
    nm = list(map(int, stdin.readline().split()))
    n = nm[0]
    m = nm[1]

    VALD = int(pow(2, m) - 1)

    a = []
    for i in range(n):
        a.append(list(map(int, stdin.readline().split())))

    getminmax(n, m, a)

    #existsequalorbig(1, m, a)

    stdout.write(str(idx1+1) + ' ' + str(idx2+1))",np,"binary search,bitmasks,dp",1261
"import sys
from collections import defaultdict
 
reader = (map(int, line.split()) for line in sys.stdin)
input = reader.__next__
 
n, m = input()
# n, m = 3 * 10 ** 5, 8
vals = set()
locs = defaultdict(list)
for i in range(n):
    for pos, v in enumerate(input()):
        vals.add(v)
        locs[v].append((pos, i))
 
masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np,"binary search,bitmasks,dp",640
"#!/usr/bin/env python3
import sys
input = sys.stdin.readline
 
max_val = 0
n, m = [int(item) for item in input().split()]
array = []
for i in range(n):
    line = [int(item) for item in input().split()]
    array.append(line)
    max_val = max(max_val, max(line))
 
good = (1 << m) - 1
l = 0; r = max_val + 1
a = 0; b = 0
while r - l > 1:
    mid = (l + r) // 2
    bit_array = dict() 
    for k, line in enumerate(array):
        val = 0
        for i, item in enumerate(line):
            if item >= mid:
                val |= 1 << i
        bit_array[val] = k
    ok = False
    for key1 in bit_array.keys():
        for key2 in bit_array.keys():
            if key1 | key2 == good:
                ok = True
                i = bit_array[key1]
                j = bit_array[key2]
                break
    if ok:
        a = i; b = j
        l = mid
    else:
        r = mid
print(a+1, b+1)",np,"binary search,bitmasks,dp",896
"n,m=[int(i) for i in input().split("" "")]
arrmv=[]
for i in range(n):
    arrmv.append([int(i) for i in input().split("" "")])
x=0
y=int(1e9+1)
sucls=[0,0]

tols=[]
mstr=""""

powls=[int(pow(2,i)) for i in range(10)]
twodarray=[0  for i in range(257)]
while x+1<y:
    mid = x+(y-x)//2
    # print(x,y,mid)
    for idx,ele in enumerate(twodarray):twodarray[idx]=0
    tols.clear()
    for topidx, eletop in enumerate(arrmv):
        tmp=0
        for idx,ele in enumerate(eletop):
            if ele>=mid:tmp+=powls[idx]
        
        if not twodarray[tmp]:
            # print(eletop,tmp,mid)
            twodarray[tmp]=1
            tols.append((tmp,topidx))
    sz=len(tols)
    suc=0
    no=int(pow(2,m))
    for i in range(sz):
        for j in range(i,sz):
            if tols[i][0] | tols[j][0] == no-1:
                sucls[0],sucls[1]=tols[i][1],tols[j][1]
                # print(sucls[0],sucls[1],mid)
                suc=1;
                break;
        if suc:break
    if suc:x=mid
    else:y=mid

print(sucls[0]+1,sucls[1]+1)

",np,"binary search,bitmasks,dp",1042
"import sys
from collections import defaultdict
 
input = sys.stdin.readline
 
n, m = map(int, input().split())
# n, m = 3 * 10 ** 5, 8
vals = set()
locs = defaultdict(list)
for i in range(n):
    inp = map(int, input().split())
    for pos, v in enumerate(inp):
        vals.add(v)
        locs[v].append((pos, i))

masks = [0] * n
full = (1<<m) - 1
met = {0:0}
for v in sorted(vals, reverse=True):
    for pos, i in locs[v]:
        curr_mask = masks[i] = masks[i] | (1<<pos)
        met[curr_mask] = i
        complement = full ^ curr_mask
        if complement in met:
            print(i+1, met[complement]+1)
            sys.exit()",np,"binary search,bitmasks,dp",636
"# based on solution by @conqueror_of_tourist
import sys

reader = (map(int, line.split()) for line in sys.stdin)
input = reader.__next__

n, m = input()
arrays = []
for i in range(n):
    arrays.append(list(input()))

full = (1 << m) - 1
L = -1
R = 10 ** 9 + 1
while L + 1 < R:
    check = (L + R) >> 1
    
    masks = {}
    for i, arr in enumerate(arrays):
        curr = 0
        for val in arr:
            curr <<= 1
            if val >= check:
                curr |= 1
        masks[curr] = i
    
    isValid = False
    for k1 in masks:
        for k2 in masks:
            if k1 | k2 == full:
                ans0 = masks[k1]
                ans1 = masks[k2]
                isValid = True
                break
        if isValid:
            break
    
    if isValid:
        L = check
    else:
        R = check

print(ans0 + 1, ans1 + 1)
",np,"binary search,bitmasks,dp",857
"hell=1000000007
id1=0
id2=0
a = []
def check(n,m,x):
    global id1,id2
    b = [0]*(1<<m)
    idx = [0]*(1<<m)
    for i in range(n):
        mask=0
        for j in range(m):
            if a[i][j]>=x:
                mask=mask^(1<<j)
        b[mask]=1
        idx[mask]=i+1
    for i in range(1<<m):
        if b[i]:
            for j in range(1<<m):
                if b[j]:
                    mask=i|j
                    if mask==((1<<m)-1):
                        id1=idx[i]
                        id2=idx[j]
                        return 1                        
    return 0
def meowmeow321():
    n,m = map(int,input().split())
    for i in range(n):
        dog = [int(x) for x in input().split()]
        a.append(dog)
    lo=0
    hi=hell
    while hi-lo>0:
        mid=(hi+lo+1)//2
        if check(n,m,mid):
            lo=mid
        else:
            hi=mid-1
    check(n,m,lo)
    print(id1,id2)
    
t=1
#t=int(input())
for xxx in range(t):
    meowmeow321()",np,"binary search,bitmasks,dp",982
"import sys
input=sys.stdin.readline
n,m=map(int,input().split())
l=[]
for i in range(n):
    l.append([int(i) for i in input().split()])
left=0
right=10**9+1
while left<right:
    mid=(left+right)//2
    dicta={}
    for i in range(n):
        mask=0
        for j in range(m):
            mask<<=1
            if l[i][j]>=mid:
                mask+=1
        dicta[mask]=i
    ok=False
    for i in dicta:
        for j in dicta:
            if i|j==(2**m-1):
                ok=True
                ans=(dicta[i]+1,dicta[j]+1)
                break
        if ok ==True:
            break
    if ok==True:
        left=mid+1
    else:
        right=mid
    #print(dicta,mid,i,j)
print(*ans)
",np,"binary search,bitmasks,dp",693
"def get_ans(x, a, n, m):

    lim = 1<<m
    match = lim-1
    track = [-1 for i in range(lim)]

    for i in range(n):
        mask = 0
        for j in range(m):
            if(a[i][j] >= x):
                mask |= 1 << j
        track[mask] = i

    for i in range(lim):
        for j in range(lim):
            if(i|j == match and track[i] != -1 and track[j] != -1):
                return track[i], track[j]
    
    return -1, -1


n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]

lo = 0
hi = 1000000000
while(lo < hi-1):
    mid = (lo+hi)/2
    i, j = get_ans(mid,a,n,m)
    if(i == -1):
        hi = mid-1
    else:
        lo = mid

i,j = get_ans(hi,a,n,m)
if(i != -1):
    print(""{} {}"".format(i+1,j+1))
else:
    i,j = get_ans(lo,a,n,m)
    print(""{} {}"".format(i+1,j+1))
",np,"binary search,bitmasks,dp",825
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]


def get_ans(x):

    lim = 1<<m
    match = lim-1
    track = [-1 for i in range(lim)]

    for i in range(n):
        mask = 0
        for j in range(m):
            if(a[i][j] >= x):
                mask |= 1 << j
        track[mask] = i

    for i in range(lim):
        for j in range(lim):
            if(i|j == match and track[i] != -1 and track[j] != -1):
                return track[i], track[j]
    
    return -1, -1


lo = 0
hi = 1000000000
while(lo < hi-1):
    mid = (lo+hi)/2
    i, j = get_ans(mid)
    if(i == -1):
        hi = mid-1
    else:
        lo = mid

i,j = get_ans(hi)
if(i != -1):
    print(""{} {}"".format(i+1,j+1))
else:
    i,j = get_ans(lo)
    print(""{} {}"".format(i+1,j+1))
",np,"binary search,bitmasks,dp",799
"n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []


def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False


le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])
",np,"binary search,bitmasks,dp",666
"import os
import sys
from io import BytesIO, IOBase


def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False


n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []
le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input(): return sys.stdin.readline().rstrip(""\r\n"")

# endregion
",np,"binary search,bitmasks,dp",2407
"import sys
input = sys.stdin.readline

N, M = map(int, input().split())
state = [list(map(int, input().split())) for _ in range(N)]

Ans = {}

l = -1
r = 10**9+1
while r-l > 1:
    m = (l+r)//2
    T = {}
    for j, S in enumerate(state):
        bit = 0
        for i, s in enumerate(S):
            if s >= m:
                bit += 1<<i
        T[bit] = j
    
    ok = False
    for bit1 in range(1<<M):
        for bit2 in range(1<<M):
            if bit1|bit2 == (1<<M)-1 and bit1 in T and bit2 in T:
                ok = True
                Ans[m] = [T[bit1], T[bit2]]
                break
        if ok: break
    if ok:
        l = m
    else:
        r = m
print(Ans[l][0]+1, Ans[l][1]+1)",np,"binary search,bitmasks,dp",700
"import os
import sys
from io import BytesIO, IOBase
 
 
# region fastio
 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
 
def input(): return sys.stdin.readline().rstrip(""\r\n"")
 
# endregion


def check(mid: int) -> bool:
    global ans
    dic = {}
    for i in range(n):
        bit = 0
        for j in range(m):
            if a[i][j] >= mid:
                bit += 1
            bit <<= 1
        dic[bit >> 1] = i
    for x, idx in dic.items():
        for y, idy in dic.items():
            if x | y == 2**m-1:
                ans = idx + 1, idy + 1
                return True
    return False
 
 
n, m = map(int, input().split())
a = [list(map(int, input().split())) for i in range(n)]
ans = []
le = 0
ri = int(1e9)
while le <= ri:
    mid = (le + ri) >> 1
    if check(mid):
        le = mid + 1
    else:
        ri = mid - 1
print(ans[0], ans[1])",np,"binary search,bitmasks,dp",2424
"import os
import sys
from io import BytesIO, IOBase


def main():
    n, m = map(int, input().split())
    a = [list(map(int, input().split())) for i in range(n)]
    ans = []
    le = 0
    ri = int(1e9)

    def check(mid: int) -> bool:
        nonlocal ans
        dic = {}
        for i in range(n):
            bit = 0
            for j in range(m):
                if a[i][j] >= mid:
                    bit += 1
                bit <<= 1
            dic[bit >> 1] = i
        for x, idx in dic.items():
            for y, idy in dic.items():
                if x | y == 2**m-1:
                    ans = idx + 1, idy + 1
                    return True
        return False
    while le <= ri:
        mid = (le + ri) >> 1
        if check(mid):
            le = mid + 1
        else:
            ri = mid - 1
    print(ans[0], ans[1])


# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


def input(): return sys.stdin.readline().rstrip(""\r\n"")

# endregion


if __name__ == ""__main__"":
    main()
",np,"binary search,bitmasks,dp",2572
"import sys
input = sys.stdin.readline
from itertools import combinations
from collections import defaultdict
n,m = map(int,input().split())
a = [list(map(int,input().split())) for i in range(n)]
mx = max(max(a[i]) for i in range(n))
if n == 1:
  print(1,1)
  exit()
l = 0
r = mx+1
while l+1 < r:
  flg = 0
  x = (l+r)//2
  jud = set()
  dc = defaultdict(int)
  for i in range(n):
    jnum = 0
    for j in range(m):
      if a[i][j] >= x:
        jnum += 1<<j
    if dc[jnum] == 0:
      dc[jnum] = i+1
    if jnum == (1<<m)-1:
      flg = 1
      if i == 0:
        ans = (i+1,i+2)
      else:
        ans = (1,i+1)
    jud.add(jnum)
  for p,q in combinations(jud,2):
    if p|q == (1<<m)-1:
      flg = 1
      ans = (dc[p],dc[q])
  if flg:
    l = x
  else:
    r = x
if l == 0:
  print(1,2)
else:
  print(*ans)",np,"binary search,bitmasks,dp",814
"import os
import sys
from io import BytesIO, IOBase
# region fastio

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

# ------------------------------

from math import factorial
from collections import Counter, defaultdict
from heapq import heapify, heappop, heappush

def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
def comb(n, m): return factorial(n) / (factorial(m) * factorial(n - m)) if n >= m else 0
def perm(n, m): return factorial(n) // (factorial(n - m)) if n >= m else 0
def mdis(x1, y1, x2, y2): return abs(x1 - x2) + abs(y1 - y2)
mod = 998244353
INF = float('inf')

# ------------------------------


def main():
    n, m = RL()
    arr = []
    for _ in range(n):  arr.append(RLL())
    res = []
    def c(num):
        nonlocal res
        dic = {}
        for i in range(n):
            now = 0
            for j in range(m):
                # print(i, j, m)
                if arr[i][j]>=num:
                    now|=1<<j
            dic[now] = i+1

        for k, v in dic.items():
            for kk, vv in dic.items():
                if k|kk==(1<<m)-1:
                    res = v, vv
                    return True

        return False




    l, r = 0, 10**9
    # c(3)
    while l<=r:
        mp = (l+r+1)//2
        now = c(mp)
        if now:
            l = mp+1
        else:
            r = mp-1


    print(*res)

if __name__ == ""__main__"":
    main()

",np,"binary search,bitmasks,dp",3106
"import math as mt
import sys
input=sys.stdin.readline
I=lambda:list(map(int,input().split()))
n,m=I()
a=[I() for i in range(n)]
ans=[]
lo=0
hi=10**9
def vanguda(mid: int) -> bool:
    global ans
    f={}
    for i in range(n):
        bi=0
        for j in range(m):
            if a[i][j]>=mid:
                bi+=1
            bi<<=1
        f[bi>>1]=i
    for aa,bb in f.items():
        for cc,dd in f.items():
            if aa|cc==(2**m-1):
                ans =bb+1,dd+1
                return True
    return False

while lo<=hi:
	mid=(lo+hi)//2
	if vanguda(mid):
		lo=mid+1
	else:
		hi=mid-1
print(*ans)


",np,"binary search,bitmasks,dp",616
"import io,os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
from collections import defaultdict as dd
I = lambda : list(map(int,input().split()))

n,m=I()
l=[]
an=-1;a=b=0
for _ in range(n):
	k=I()
	l.append(k+[_+1])
	if an<min(k):
		a=b=_+1
		an=min(k)
le=an;r=10**9+1
while le<r:
	md = (le+r)//2
	f=0;a1=a2=-1
	s=[0]*n
	for i in range(n):
		for j in range(m):
			if l[i][j]>=md:
				s[i]|=1<<j

	po=1<<m
	d=[0]*po
	for i in range(n):
		d[s[i]]=i+1
	for i in range(1,po):
		if d[i]:
			pp=i
			while pp:
				d[pp]=d[i]
				pp=(pp-1)&i
	if d[po-1]:
		f=1
		a1=a2=d[po-1]
	for i in range(1,po):
		if d[i] and d[(po-1)^i]:
			f=1
			a1 = d[i]
			a2 = d[(po-1)^i]
			break
	if f:
		le=md+1
		if md>an:
			a,b=a1,a2
			an=md
	else:
		r=md
print(a,b)",np,"binary search,bitmasks,dp",758
"import io
import os

from collections import Counter, defaultdict, deque

DEBUG = False


def bisect_f(f, lo, hi):
    if DEBUG:
        assert f(lo) and not f(hi)
    while hi - lo > 1:
        mid = (lo + hi) // 2
        if f(mid):
            lo = mid
        else:
            hi = mid
        if DEBUG:
            assert f(lo) and not f(hi)
    if DEBUG:
        assert hi - lo == 1
        assert f(lo) and not f(hi)
    return lo


def solve(N, M, arrs):
    def isPossible(target):
        possible = set()
        for arr in arrs:
            mask = 0
            for pos, x in enumerate(arr):
                if x >= target:
                    mask += 1 << pos
            possible.add(mask)
        allMask = (1 << M) - 1
        for mask1 in possible:
            for mask2 in possible:
                if mask1 | mask2 == allMask:
                    return (mask1 << 8) + mask2
        return 0

    lo = min(arrs[0])
    hi = 10 ** 9 + 1
    index = bisect_f(isPossible, lo, hi)

    mask1, mask2 = divmod(isPossible(index), 1 << 8)
    ans = [-1, -1]
    for i, arr in enumerate(arrs):
        mask = 0
        for pos, x in enumerate(arr):
            if x >= index:
                mask += 1 << pos
        if mask == mask1:
            ans[0] = str(i + 1)
        if mask == mask2:
            ans[1] = str(i + 1)
    return "" "".join(ans)


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    N, M = [int(x) for x in input().split()]
    arrs = [[int(x) for x in input().split()] for i in range(N)]
    ans = solve(N, M, arrs)
    print(ans)
",np,"binary search,bitmasks,dp",1609
"import sys, math
import io, os
#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
#from bisect import bisect_left as bl, bisect_right as br, insort
#from heapq import heapify, heappush, heappop
from collections import defaultdict as dd, deque, Counter
#from itertools import permutations,combinations
def data(): return sys.stdin.buffer.readline().strip()
def mdata(): return list(map(int, data().split()))
def outl(var) : sys.stdout.write(' '.join(map(str, var))+'\n')
def out(var) : sys.stdout.write(str(var)+'\n')
#from decimal import Decimal
#from fractions import Fraction
#sys.setrecursionlimit(100000)
#INF = float('inf')
mod = int(1e9)+7

def cal(x):
    l1=set()
    d=dd(int)
    a=[]
    for i in range(n):
        k=0
        for j in range(m):
            if A[i][j]>=x:
                k+=1<<j
        l1.add(k)
        d[k]=i+1
    l1=list(l1)
    s=(1<<m)-1
    for i in l1:
        for j in l1:
            if i|j == s:
                a=[d[i],d[j]]
    return a

n,m=mdata()
A=[mdata() for i in range(n)]
l,r=0,10**9
while l<=r:
    mid=(l+r)//2
    if cal(mid):
        l=mid+1
    else:
        r=mid-1
a=cal(mid)
if a:
    outl(a)
else:
    outl(cal(mid-1))




",np,"binary search,bitmasks,dp",1192
"from sys import stdin


def solve(x: int) -> bool:
    global ans
    dp = {}
    for i in range(n):
        temp = 0
        for j in range(m):
            if a[i][j] >= x:
                temp = temp | (1 << j)
        dp[temp] = i
    for aa, bb in dp.items():
        for cc, dd in dp.items():
            if aa | cc == 2 ** m - 1:
                ans = (bb + 1, dd + 1)
                return True
    return False


ans = (-1, -1)
n, m = map(int, stdin.readline().split())
a = []
for i in range(n):
    a.append(list(map(int, stdin.readline().split())))
l, r = 0, 10 ** 9
while l <= r:
    mid = (l + r) // 2
    if solve(mid):
        l = mid + 1
    else:
        r = mid - 1
print(*ans)
",np,"binary search,bitmasks,dp",696
"# ---------------------------iye ha aam zindegi---------------------------------------------
import math
import random
import heapq, bisect
import sys
from collections import deque, defaultdict
from fractions import Fraction
import sys
import threading
from collections import defaultdict
#threading.stack_size(10**8)
mod = 10 ** 9 + 7
mod1 = 998244353

# ------------------------------warmup----------------------------
import os
import sys
from io import BytesIO, IOBase
#sys.setrecursionlimit(300000)

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")


# -------------------game starts now----------------------------------------------------import math
class TreeNode:
    def __init__(self, k, v):
        self.key = k
        self.value = v
        self.left = None
        self.right = None
        self.parent = None
        self.height = 1
        self.num_left = 1
        self.num_total = 1


class AvlTree:

    def __init__(self):
        self._tree = None

    def add(self, k, v):
        if not self._tree:
            self._tree = TreeNode(k, v)
            return
        node = self._add(k, v)
        if node:
            self._rebalance(node)

    def _add(self, k, v):
        node = self._tree
        while node:
            if k < node.key:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(k, v)
                    node.left.parent = node
                    return node.left
            elif node.key < k:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(k, v)
                    node.right.parent = node
                    return node.right
            else:
                node.value = v
                return

    @staticmethod
    def get_height(x):
        return x.height if x else 0

    @staticmethod
    def get_num_total(x):
        return x.num_total if x else 0

    def _rebalance(self, node):

        n = node
        while n:
            lh = self.get_height(n.left)
            rh = self.get_height(n.right)
            n.height = max(lh, rh) + 1
            balance_factor = lh - rh
            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)
            n.num_left = 1 + self.get_num_total(n.left)

            if balance_factor > 1:
                if self.get_height(n.left.left) < self.get_height(n.left.right):
                    self._rotate_left(n.left)
                self._rotate_right(n)
            elif balance_factor < -1:
                if self.get_height(n.right.right) < self.get_height(n.right.left):
                    self._rotate_right(n.right)
                self._rotate_left(n)
            else:
                n = n.parent

    def _remove_one(self, node):
        """"""
        Side effect!!! Changes node. Node should have exactly one child
        """"""
        replacement = node.left or node.right
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = replacement
            else:
                node.parent.right = replacement
            replacement.parent = node.parent
            node.parent = None
        else:
            self._tree = replacement
            replacement.parent = None
        node.left = None
        node.right = None
        node.parent = None
        self._rebalance(replacement)

    def _remove_leaf(self, node):
        if node.parent:
            if AvlTree._is_left(node):
                node.parent.left = None
            else:
                node.parent.right = None
            self._rebalance(node.parent)
        else:
            self._tree = None
        node.parent = None
        node.left = None
        node.right = None

    def remove(self, k):
        node = self._get_node(k)
        if not node:
            return
        if AvlTree._is_leaf(node):
            self._remove_leaf(node)
            return
        if node.left and node.right:
            nxt = AvlTree._get_next(node)
            node.key = nxt.key
            node.value = nxt.value
            if self._is_leaf(nxt):
                self._remove_leaf(nxt)
            else:
                self._remove_one(nxt)
            self._rebalance(node)
        else:
            self._remove_one(node)

    def get(self, k):
        node = self._get_node(k)
        return node.value if node else -1

    def _get_node(self, k):
        if not self._tree:
            return None
        node = self._tree
        while node:
            if k < node.key:
                node = node.left
            elif node.key < k:
                node = node.right
            else:
                return node
        return None

    def get_at(self, pos):
        x = pos + 1
        node = self._tree
        while node:
            if x < node.num_left:
                node = node.left
            elif node.num_left < x:
                x -= node.num_left
                node = node.right
            else:
                return (node.key, node.value)
        raise IndexError(""Out of ranges"")

    @staticmethod
    def _is_left(node):
        return node.parent.left and node.parent.left == node

    @staticmethod
    def _is_leaf(node):
        return node.left is None and node.right is None

    def _rotate_right(self, node):
        if not node.parent:
            self._tree = node.left
            node.left.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.left
            node.left.parent = node.parent
        else:
            node.parent.right = node.left
            node.left.parent = node.parent
        bk = node.left.right
        node.left.right = node
        node.parent = node.left
        node.left = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    def _rotate_left(self, node):
        if not node.parent:
            self._tree = node.right
            node.right.parent = None
        elif AvlTree._is_left(node):
            node.parent.left = node.right
            node.right.parent = node.parent
        else:
            node.parent.right = node.right
            node.right.parent = node.parent
        bk = node.right.left
        node.right.left = node
        node.parent = node.right
        node.right = bk
        if bk:
            bk.parent = node
        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1
        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)
        node.num_left = 1 + self.get_num_total(node.left)

    @staticmethod
    def _get_next(node):
        if not node.right:
            return node.parent
        n = node.right
        while n.left:
            n = n.left
        return n


# -----------------------------------------------binary seacrh tree---------------------------------------
class SegmentTree1:
    def __init__(self, data, default=2**30, func=lambda a, b: min(a , b)):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------game starts now----------------------------------------------------import math
class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b:a + b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        if start == stop:
            return self.__getitem__(start)
        stop += 1
        start += self._size
        stop += self._size

        res = self._default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)


# -------------------------------iye ha chutiya zindegi-------------------------------------
class Factorial:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorials = [1, 1]
        self.invModulos = [0, 1]
        self.invFactorial_ = [1, 1]

    def calc(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.factorials):
            return self.factorials[n]
        nextArr = [0] * (n + 1 - len(self.factorials))
        initialI = len(self.factorials)
        prev = self.factorials[-1]
        m = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = prev * i % m
        self.factorials += nextArr
        return self.factorials[n]

    def inv(self, n):
        if n <= -1:
            print(""Invalid argument to calculate n^(-1)"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        p = self.MOD
        pi = n % p
        if pi < len(self.invModulos):
            return self.invModulos[pi]
        nextArr = [0] * (n + 1 - len(self.invModulos))
        initialI = len(self.invModulos)
        for i in range(initialI, min(p, n + 1)):
            next = -self.invModulos[p % i] * (p // i) % p
            self.invModulos.append(next)
        return self.invModulos[pi]

    def invFactorial(self, n):
        if n <= -1:
            print(""Invalid argument to calculate (n^(-1))!"")
            print(""n must be non-negative value. But the argument was "" + str(n))
            exit()
        if n < len(self.invFactorial_):
            return self.invFactorial_[n]
        self.inv(n)  # To make sure already calculated n^-1
        nextArr = [0] * (n + 1 - len(self.invFactorial_))
        initialI = len(self.invFactorial_)
        prev = self.invFactorial_[-1]
        p = self.MOD
        for i in range(initialI, n + 1):
            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p
        self.invFactorial_ += nextArr
        return self.invFactorial_[n]


class Combination:
    def __init__(self, MOD):
        self.MOD = MOD
        self.factorial = Factorial(MOD)

    def ncr(self, n, k):
        if k < 0 or n < k:
            return 0
        k = min(k, n - k)
        f = self.factorial
        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD


# --------------------------------------iye ha combinations ka zindegi---------------------------------
def powm(a, n, m):
    if a == 1 or n == 0:
        return 1
    if n % 2 == 0:
        s = powm(a, n // 2, m)
        return s * s % m
    else:
        return a * powm(a, n - 1, m) % m


# --------------------------------------iye ha power ka zindegi---------------------------------
def sort_list(list1, list2):
    zipped_pairs = zip(list2, list1)

    z = [x for _, x in sorted(zipped_pairs)]

    return z


# --------------------------------------------------product----------------------------------------
def product(l):
    por = 1
    for i in range(len(l)):
        por *= l[i]
    return por


# --------------------------------------------------binary----------------------------------------
def binarySearchCount(arr, n, key):
    left = 0
    right = n - 1

    count = 0

    while (left <= right):
        mid = int((right + left) / 2)

        # Check if middle element is
        # less than or equal to key
        if (arr[mid] < key):
            count = mid + 1
            left = mid + 1

        # If key is smaller, ignore right half
        else:
            right = mid - 1

    return count


# --------------------------------------------------binary----------------------------------------
def countdig(n):
    c = 0
    while (n > 0):
        n //= 10
        c += 1
    return c
def binary(x, length):
    y = bin(x)[2:]
    return y if len(y) >= length else ""0"" * (length - len(y)) + y

def countGreater(arr, n, k):
    l = 0
    r = n - 1

    # Stores the index of the left most element
    # from the array which is greater than k
    leftGreater = n

    # Finds number of elements greater than k
    while (l <= r):
        m = int(l + (r - l) / 2)
        if (arr[m] > k):
            leftGreater = m
            r = m - 1

        # If mid element is less than
        # or equal to k update l
        else:
            l = m + 1

    # Return the count of elements
    # greater than k
    return (n - leftGreater)


# --------------------------------------------------binary------------------------------------
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEndOfWord = False
class Trie:
    def __init__(self):
        self.root = self.getNode()
    def getNode(self):
        return TrieNode()
    def _charToIndex(self, ch):
        return ord(ch) - ord('a')
    def insert(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                pCrawl.children[index] = self.getNode()
            pCrawl = pCrawl.children[index]
        pCrawl.isEndOfWord = True
    def search(self, key):
        pCrawl = self.root
        length = len(key)
        for level in range(length):
            index = self._charToIndex(key[level])
            if not pCrawl.children[index]:
                return False
            pCrawl = pCrawl.children[index]
        return pCrawl != None and pCrawl.isEndOfWord
#-----------------------------------------trie---------------------------------
class Node:
    def __init__(self, data):
        self.data = data
        self.count=0
        self.left = None  # left node for 0
        self.right = None  # right node for 1
class BinaryTrie:
    def __init__(self):
        self.root = Node(0)
    def insert(self, pre_xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = pre_xor & (1 << i)
            if val:
                if not self.temp.right:
                    self.temp.right = Node(0)
                self.temp = self.temp.right
                self.temp.count+=1
            if not val:
                if not self.temp.left:
                    self.temp.left = Node(0)
                self.temp = self.temp.left
                self.temp.count += 1
        self.temp.data = pre_xor
    def query(self, xor):
        self.temp = self.root
        for i in range(31, -1, -1):
            val = xor & (1 << i)
            if not val:
                if self.temp.left and self.temp.left.count>0:
                    self.temp = self.temp.left
                elif self.temp.right:
                    self.temp = self.temp.right
            else:
                if self.temp.right and self.temp.right.count>0:
                    self.temp = self.temp.right
                elif self.temp.left:
                    self.temp = self.temp.left
            self.temp.count-=1
        return xor ^ self.temp.data
#-------------------------bin trie-------------------------------------------
n,m=map(int,input().split())
l=[]
pm=2**m-1
for i in range(n):
    l.append(list(map(int,input().split())))
def find (x):
    s=set()
    d=defaultdict(int)
    for i in range(n):
        a=""""
        for j in range(m):
            if l[i][j]>=x:
                a+='1'
            else:
                a+='0'
        d[int(a,2)]=i
        s.add(int(a,2))
    s=list(s)
    #print(s)
    for i in range(len(s)):
        for j in range(i,len(s)):
            if s[i]|s[j]==pm:
                return [d[s[i]]+1,d[s[j]]+1]
    return [-1,-1]
st=0
end=10**9
ans=(0,0)
while(st<=end):
    mid=(st+end)//2
    s=find(mid)
    if s[0]!=-1:
        ans=s
        st=mid+1
    else:
        end=mid-1
print(*ans)",np,"binary search,bitmasks,dp",19795
"import sys
from array import array  # noqa: F401
from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def main():
    n, m = map(int, input().split())
    mat = [array('i', map(int, input().split())) for _ in range(n)]
    bit = [1 << i for i in range(m)]
    fullbit = (1 << m) - 1

    def solve(x: int) -> Tuple[int, int]:
        dp = {sum(bit[j] for j, y in enumerate(mat[i]) if y >= x): i for i in range(n)}
        keys = tuple(dp.keys())

        for i in range(len(keys)):
            for j in range(i, len(keys)):
                if keys[i] | keys[j] == fullbit:
                    return dp[keys[i]], dp[keys[j]]

        return -1, -1

    ok, ng = 0, 10**9 + 1
    ans_i, ans_j = 1, 1

    while abs(ok - ng) > 1:
        mid = (ok + ng) >> 1
        x, y = solve(mid)
        if x == -1:
            ng = mid
        else:
            ok = mid
            ans_i, ans_j = x + 1, y + 1

    print(ans_i, ans_j)


if __name__ == '__main__':
    main()
",np,"binary search,bitmasks,dp",1069
"import sys
from array import array  # noqa: F401
from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def main():
    n, m = map(int, input().split())
    mat = [array('i', map(int, input().split())) for _ in range(n)]
    bit = [1 << i for i in range(m)]
    max_bit = 1 << m
    fullbit = max_bit - 1

    def solve(x: int) -> Tuple[int, int]:
        dp = array('i', [-1]) * max_bit
        for i in range(n):
            dp[sum(bit[j] for j, y in enumerate(mat[i]) if y >= x)] = i

        for i in range(max_bit):
            if dp[i] == -1:
                continue
            for j in range(i, max_bit):
                if dp[j] != -1 and i | j == fullbit:
                    return dp[i], dp[j]

        return -1, -1

    ok, ng = 0, 10**9 + 1
    ans_i, ans_j = 1, 1

    while abs(ok - ng) > 1:
        mid = (ok + ng) >> 1
        x, y = solve(mid)
        if x == -1:
            ng = mid
        else:
            ok = mid
            ans_i, ans_j = x + 1, y + 1

    print(ans_i, ans_j)


if __name__ == '__main__':
    main()
",np,"binary search,bitmasks,dp",1149
"import sys
from array import array  # noqa: F401
from typing import Dict, List, Tuple, TypeVar, Generic, Sequence, Union  # noqa: F401


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


def main():
    n, m = map(int, input().split())
    mat = [array('i', map(int, input().split())) for _ in range(n)]
    bit = array('h', [1 << i for i in range(m)])
    max_bit = 1 << m
    fullbit = max_bit - 1

    def solve(x: int) -> Tuple[int, int]:
        dp = array('i', [-1]) * max_bit
        for i in range(n):
            dp[sum(bit[j] for j in range(m) if mat[i][j] >= x)] = i

        for i in range(max_bit):
            if dp[i] == -1:
                continue
            for j in range(i, max_bit):
                if dp[j] != -1 and i | j == fullbit:
                    return dp[i], dp[j]

        return -1, -1

    ok, ng = 0, 10**9 + 1
    ans_i, ans_j = 1, 1

    while abs(ok - ng) > 1:
        mid = (ok + ng) >> 1
        x, y = solve(mid)
        if x == -1:
            ng = mid
        else:
            ok = mid
            ans_i, ans_j = x + 1, y + 1

    print(ans_i, ans_j)


if __name__ == '__main__':
    main()
",np,"binary search,bitmasks,dp",1157
"from heapq import heappush, heappop
class MinCostFlow:
    INF = 10**18

    def __init__(self, N):
        self.N = N
        self.G = [[] for i in range(N)]

    def add_edge(self, fr, to, cap, cost):
        forward = [to, cap, cost, None]
        backward = forward[3] = [fr, 0, -cost, forward]
        self.G[fr].append(forward)
        self.G[to].append(backward)

    def flow(self, s, t, f):
        N = self.N; G = self.G
        INF = MinCostFlow.INF

        res = 0
        H = [0]*N
        prv_v = [0]*N
        prv_e = [None]*N

        d0 = [INF]*N
        dist = [INF]*N

        while f:
            dist[:] = d0
            dist[s] = 0
            que = [(0, s)]

            while que:
                c, v = heappop(que)
                if dist[v] < c:
                    continue
                r0 = dist[v] + H[v]
                for e in G[v]:
                    w, cap, cost, _ = e
                    if cap > 0 and r0 + cost - H[w] < dist[w]:
                        dist[w] = r = r0 + cost - H[w]
                        prv_v[w] = v; prv_e[w] = e
                        heappush(que, (r, w))
            if dist[t] == INF:
                return None

            for i in range(N):
                H[i] += dist[i]

            d = f; v = t
            while v != s:
                d = min(d, prv_e[v][1])
                v = prv_v[v]
            f -= d
            res += d * H[t]
            v = t
            while v != s:
                e = prv_e[v]
                e[1] -= d
                e[3][1] += d
                v = prv_v[v]
        return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

n,m = map(int,input().split())

G = MinCostFlow(n+2)
coef = [0 for i in range(n)]
edge = []
for _ in range(m):
    x,y,b = map(int,input().split())
    G.add_edge(y,x,10**18,-1)
    coef[x-1] += b
    coef[y-1] -= b
    edge.append((x,y))

s = 0
for i in range(n):
    if coef[i]<0:
        G.add_edge(0,i+1,-coef[i],0)
        s -= coef[i]
    elif coef[i]>0:
        G.add_edge(i+1,n+1,coef[i],0)

#G.add_edge(0,n+1,10**18,0)

f = G.flow(0,n+1,s)
#print(-f)

Edge = [[] for i in range(n)]
use = [False]*m
uf = UnionFindVerSize(n)
for i in range(m):
    u,v = edge[i]
    for e in G.G[u]:
        to = e[0]
        if to==v and e[1]:
            Edge[v-1].append((u-1,1))
            Edge[u-1].append((v-1,-1))
            use[i] = True
            uf.unite(u-1,v-1)


edge = [(edge[i][0],edge[i][1]) for i in range(m) if not use[i]]
for u,v in edge:
    if not uf.is_same_group(u-1,v-1):
        Edge[v-1].append((u-1,1))
        Edge[u-1].append((v-1,-1))
        uf.unite(u-1,v-1)

used_1 = [False]*n
used_2 = [False]*n
lazy = [0 for i in range(n)]
a = [0 for i in range(n)]
def dfs(v,pv):
    lazy[v] = min(lazy[v],a[v])
    for nv,c in Edge[v]:
        if not used_1[nv]:
            used_1[nv] = True
            a[nv] = a[v] + c
            dfs(nv,v)
            lazy[v] = min(lazy[v],lazy[nv])

def add(v,pv,ff):
    a[v] += ff
    for nv,c in Edge[v]:
        if not used_2[nv]:
            used_2[nv] = True
            add(nv,v,ff)

for i in range(n):
    if not used_1[i]:
        used_1[i] = True
        dfs(i,-1)
        used_2[i] = True
        add(i,-1,-lazy[i]+1)
        #print(used_1)
        #print(lazy)

print(*a)
",np,"bitmasks,dfs and similar,dp,flows,graphs,math",4252
"from math import *
n,x,y=map(int,input().split());g=gcd(x,y);n,x,y,r,h=n//g,x//g,(x+y)//g,n%g,lambda n:max(f(n,0),f(n,1))
def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y):d=[max(d[0],d[1]),d[0]+n//y+(i*x%y<n%y)]
 return d[s]
print(h(n+1)*r+h(n)*(g-r))",np,"bitmasks,dp,math",251
"def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
 return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"bitmasks,dp,math",240
"def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"bitmasks,dp,math",249
"from math import gcd
n, x, y = map(int, input().split())

def solve(n, x, y):
    g = gcd(x, y)
    if gcd(x, y) != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    ans = 0
    for s in [0, 1]:
        dp = [-n, -n]
        dp[s] = 0
        for i in range(x + y):
            dp = [max(dp[0], dp[1]), dp[0] + (n // (x + y)) + (i * x % (x + y) < n % (x + y))]
        ans = max(ans, dp[s])
    return ans
    
print(solve(n, x, y))",np,"bitmasks,dp,math",494
"from sys import stdin, gettrace

if gettrace():
    def inputi():
        return input()
else:
    def input():
        return next(stdin)[:-1]


    def inputi():
        return stdin.buffer.readline()

def bitcount(m):
    return bin(m).count('1')


def main():
    n,x,y = map(int, input().split())
    if x > y:
        x,y = y, x
    assert x <= y
    mm1 = range(1, 1 << y, 2)
    vbases = [((~(m1 >> (y - x)) & ~m1 & ((1 << x) - 1)) << y) | m1 for m1 in mm1 if m1 & m1 >> x == 0]
    def btail(m):
        return bitcount(m & ((1 << n % (x + y)) - 1))
    res = max(bitcount(m)*(n//(x+y)) + btail(m) for m in vbases)
    print(res)


if __name__ == ""__main__"":
    main()
",np,"bitmasks,dp,math",679
"#ecnerwala's algorithm

import math
def solve(n, x, y):
    g = math.gcd(x, y)
    if g != 1:
        return solve(n // g + 1, x // g, y // g) * (n % g) + solve(n // g, x // g, y // g) * (g - n % g)
    p = x + y
    weights = [n // p] * p
    for i in range(p):
        if (i * x) % p < n % p:
            weights[i] += 1
    ans = -n
    for i in range(2):
        dp = [-n, -n]
        dp[i] = 0
        for w in weights:
            dp = [max(dp[0], dp[1]), dp[0] + w]
        ans = max(ans, dp[i])
    return ans

def main():
    n, x, y = [int(x) for x in input().split()]
    print(solve(n, x, y))

main()",np,"bitmasks,dp,math",612
"import json
import os


def convert_files_to_json():
    answer = dict()
    for file in os.listdir(""bad/""):
        if '_' in file:
            # x, y = map(int, file.split('_'))
            answer[file] = [list(map(int, line.split())) for line in open(""bad/"" + file).read().split('\n')[:2]]

    return json.dumps(answer)


def extract_list(compressed_list, start_val=1):
    answer = []
    for num in compressed_list:
        answer += [start_val] * num
        start_val += 1
    return answer


answer = json.loads('{""1_12"": [[], [2, 2, 2, 2, 2, 3]], ""6_11"": [[1, 1, 1, 1, 1, 7], [2, 3, 1, 2, 2, 2, 2, 3]], '
                    '""3_10"": [[], [1, 1, 4, 1, 1, 5]], ""3_17"": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], ""6_9"": [[], [1, 1, '
                    '1, 1, 1, 10]], ""9_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 19]], ""18_21"": [[], [1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], ""10_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], ""15_18"": [['
                    '], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], ""1_10"": [[], [2, 2, 2, 2, 3]], ""6_19"": [[], '
                    '[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 8]], ""3_13"": [[1, 1, 4, 1, 1, 4], [2]], ""2_22"": [[], [1, 3]], '
                    '""3_6"": [[], [1, 1, 7]], ""10_14"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 1, 1, 1, 1, 7], '
                    '[1, 3]], ""9_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], ""6_15"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 7]], '
                    '""7_22"": [[], [1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 9]], ""1_15"": [[], [2]], ""10_15"": [[], [1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 16]], ""3_15"": [[], [1, 1, 4]], ""11_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '12], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4]], ""15_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 16, 1, 1, 4, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], ""18_19"": [[], [1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], ""11_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], '
                    '[2]], ""2_2"": [[], [1, 3]], ""16_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 1, 2, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, '
                    '3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, '
                    '3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], ""3_12"": [[], [1, 1, 4, 1, 1, 7]], ""18_22"": [['
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, '
                    '3, 1, 3, 1, 1, 1, 1, 1, 7], [1, 3]], ""21_22"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 23]], ""8_19"": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 1, 4, 1, 4, 1, 1, 3, 1, 1, 4, 1, '
                    '4]], ""13_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14], [1, 1, 1, 6, 1, 1, 1, 1, 5, 1, 1, 1, 5, '
                    '1, 1, 1, 6]], ""5_18"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 1, 2, 1, 3, 3]], '
                    '""8_16"": [[], [1, 1, 1, 1, 1, 1, 1, 17]], ""18_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 19]], ""1_19"": [[], [2]], ""5_15"": [[], [1, 1, 1, 1, 6]], ""1_6"": [[], [2, 2, 3]], '
                    '""11_22"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23]], ""17_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 19]], ""7_16"": [[1, 1, 1, 1, 1, 1, 8], [1, 3, 1, 4, 1, 1, 3, 1, 3, 1, 4]], '
                    '""3_3"": [[], [1, 1, 4]], ""15_16"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], '
                    '""5_11"": [[1, 1, 1, 1, 6], [2]], ""1_2"": [[], [3]], ""1_17"": [[], [2]], ""14_17"": [[1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 3, 1, 2, 1, 2, 1, 1, '
                    '1, 1, 1, 1, 1, 9, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '
                    '2, 1, 3, 3]], ""13_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], ""1_8"": [[], [2, 2, 2, 3]], ""9_20"": [[1, '
                    '1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], ""8_22"": [[], [1, 1, 1, 1, '
                    '1, 1, 1, 9, 1, 1, 1, 1, 1, 9]], ""7_17"": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], '
                    '[2]], ""17_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 1, 4, 1, 1, 3, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 4, '
                    '1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 3, 1, 4]], ""12_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, '
                    '7, 1, 1, 1, 1, 1, 4, 1, 1, 4, 1, 1, 7]], ""5_19"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], '
                    '""14_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, '
                    '2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 2, 2, 3]], '
                    '""6_6"": [[], [1, 1, 1, 1, 1, 7]], ""7_11"": [[1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 1, 1, 4], [2]], '
                    '""2_10"": [[], [1, 3]], ""5_7"": [[1, 1, 1, 1, 6, 2, 2, 1, 1, 4], [2]], ""2_7"": [[], [1, 3, 1, 4]], '
                    '""10_13"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 1, 2, 1, 2, 1, 1, '
                    '1, 5], [3, 3, 3, 1, 2, 1, 2, 1, 2, 2, 3]], ""12_12"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '
                    '""4_15"": [[1, 1, 1, 5, 1, 1, 1, 5], [3, 1, 2, 2, 3, 1, 2, 2, 3]], ""9_14"": [[1, 1, 1, 1, 1, 1, 1, '
                    '1, 10, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 3]], ""11_15"": [[1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '
                    '""15_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], ""3_14"": [[], [1, 1, 4, 1, 1, 4, '
                    '1, 4]], ""7_18"": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 5, 3, 1, 2, 1, 1, 1, 5], [3, 1, 2, 2, 3, 3, 1, '
                    '2, 1, 2, 2, 3]], ""2_13"": [[], [1, 3, 1, 3, 1, 3, 3]], ""10_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], '
                    '[1, 3]], ""9_16"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 3, 3, 1, 2, 1, 3, 1, 3, 1, 3, 3]], '
                    '""8_18"": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], ""6_10"": [[1, 1, 1, 1, '
                    '1, 7], [1, 3]], ""16_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 2, 3, 1, 2, 2, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 2, 3, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 2, 3, '
                    '1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 3]], ""21_21"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 22]], ""12_16"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], ""10_19"": [[1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], ""2_9"": [[], [1, 3, 1, 3, '
                    '3]], ""1_18"": [[], [2, 2, 2, 2, 2, 2, 2, 2, 3]], ""8_9"": [[], [1, 1, 1, 1, 1, 1, 1, 10]], '
                    '""5_13"": [[1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 1, 1, 4], [2]], ""4_10"": [[], [1, 1, 1, 5, 1, 5]], '
                    '""1_5"": [[], [2]], ""18_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 21]], '
                    '""3_8"": [[], [1, 1, 4, 1, 4]], ""2_12"": [[], [1, 3, 1, 3, 1, 5]], ""2_21"": [[], [1, 3, 1, 3, 1, 3, '
                    '1, 3, 1, 3, 3]], ""6_13"": [[1, 1, 1, 1, 1, 7], [2, 2, 3, 1, 2, 2, 2, 2, 3]], ""4_6"": [[], [1, 1, '
                    '1, 7]], ""2_8"": [[], [1, 3, 1, 5]], ""12_13"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], '
                    '""5_10"": [[], [1, 1, 1, 1, 11]], ""3_4"": [[], [1, 1, 5]], ""10_11"": [[], [1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 12]], ""16_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 1, 5, 1, 1, 1, 3, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 11], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 5, 1, 5]], ""4_12"": [[], [1, '
                    '1, 1, 5]], ""11_14"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, '
                    '1, 2, 1, 2, 1, 1, 1, 1, 6], [3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 3, 3]], ""4_16"": [[], [1, 1, 1, 5, 1, '
                    '1, 1, 9]], ""5_16"": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, 7]], ""5_17"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6, '
                    '2, 2, 1, 1, 4, 2, 2, 1, 1, 4], [2]], ""10_18"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 3]], '
                    '""4_18"": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 5]], ""4_19"": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 5]], '
                    '""8_8"": [[], [1, 1, 1, 1, 1, 1, 1, 9]], ""19_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 21]], ""3_20"": [[], [1, 1, 4, 1, 1, 4, 1, 1, 4, 1, 4]], ""5_14"": [[], [1, 1, 1, 1, 6, '
                    '1, 1, 1, 6]], ""13_15"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 12, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], ""1_3"": [[], [2]], '
                    '""5_21"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [2]], ""1_20"": [[], [2, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '
                    '""15_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 12, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, '
                    '4], [2]], ""14_21"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 22]], ""4_5"": [[], [1, 1, 1, 6]], '
                    '""3_21"": [[], [1, 1, 4]], ""4_9"": [[1, 1, 1, 5], [2, 3, 1, 2, 2, 3]], ""7_7"": [[], [1, 1, 1, 1, 1, '
                    '1, 8]], ""11_18"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12], [1, 1, 5, 1, 1, 1, 4, 1, 1, 1, 5, 1, 1, '
                    '5]], ""15_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, '
                    '1, 1, 1, 9], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 3]], ""14_14"": [[], [1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], ""4_17"": [[1, 1, 1, 5, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, 1, 2, 2, '
                    '3]], ""6_12"": [[], [1, 1, 1, 1, 1, 13]], ""1_1"": [[], [2]], ""19_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, '
                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, 2, '
                    '2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, '
                    '2, 1, 1, 4], [2]], ""9_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [1, 1, 4]], ""17_21"": [[1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, '
                    '6], [2]], ""16_17"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], ""4_21"": [[], [1, 1, '
                    '1, 5, 1, 1, 1, 5, 1, 1, 1, 6]], ""5_6"": [[], [1, 1, 1, 1, 7]], ""10_10"": [[], [1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 11]], ""8_15"": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], '
                    '""13_18"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, '
                    '4, 1, 4, 1, 1, 3, 1, 1, 3, 1, 1, 4, 1, 4]], ""20_22"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 23]], ""9_10"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 11]], ""2_19"": [[], [1, 3, 1, 3, '
                    '1, 3, 1, 3, 1, 4]], ""6_22"": [[1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 7], [1, 3]], ""13_13"": [[], [1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14]], ""17_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '18, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 12, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 9, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, '
                    '2, 1, 1, 1, 1, 6], [3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 3]], ""6_18"": [[], [1, 1, '
                    '1, 1, 1, 7]], ""5_12"": [[1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3]], ""17_17"": [[], [1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18]], ""8_20"": [[], [1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 9]], '
                    '""11_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6], [2]], ""1_4"": [[], '
                    '[2, 3]], ""3_11"": [[1, 1, 4, 1, 1, 4], [2]], ""3_9"": [[], [1, 1, 4]], ""7_14"": [[], [1, 1, 1, 1, 1, '
                    '1, 15]], ""13_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 3, 1, 2, 2, 2, 1, 1, 1, 1, 1, '
                    '7], [2, 2, 3, 2, 2, 3, 1, 2, 2, 2, 1, 2, 2, 2, 2, 3]], ""8_13"": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 4, '
                    '1, 1, 3, 1, 1, 4, 1, 4]], ""9_13"": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 1, 1, 1, 1, 6], '
                    '[2]], ""11_13"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, '
                    '1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], '
                    '""9_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 5, 2, 3, 1, 2, 2, 1, 1, 1, 5], [2, 3, 1, 2, 2, 3, '
                    '2, 3, 1, 2, 2, 1, 2, 2, 3]], ""6_21"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 10]], ""12_14"": [[], '
                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], ""3_7"": [[1, 1, 4], [2]], ""14_20"": [[1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 15, 1, 5, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 5, 1, 1, 1, 3, 1, 1, '
                    '1, 3, 1, 3, 1, 5]], ""9_11"": [[1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, '
                    '1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], ""12_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '13], [1, 3, 1, 5, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], ""5_20"": [[], [1, 1, 1, 1, 6, 1, 1, 1, 1, '
                    '11]], ""1_16"": [[], [2, 2, 2, 2, 2, 2, 2, 3]], ""7_12"": [[1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 1, 3, 1, '
                    '3, 1, 4]], ""12_15"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16]], ""7_9"": [[1, 1, 1, 1, 1, 1, 8, '
                    '2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 1, 1, 4], [2]], ""15_15"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 16]], ""5_5"": [[], [1, 1, 1, 1, 6]], ""9_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 10], [2]], '
                    '""8_11"": [[1, 1, 1, 1, 1, 1, 1, 9, 3, 1, 2, 1, 1, 1, 1, 6], [3, 3, 1, 2, 1, 2, 1, 3, 3]], '
                    '""2_3"": [[], [1, 4]], ""7_10"": [[1, 1, 1, 1, 1, 1, 8, 3, 1, 2, 1, 1, 1, 5], [3, 3, 1, 2, 1, 2, 2, '
                    '3]], ""8_14"": [[1, 1, 1, 1, 1, 1, 1, 9], [1, 5, 1, 1, 1, 3, 1, 3, 1, 5]], ""11_11"": [[], [1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 12]], ""2_11"": [[], [1, 3, 1, 3, 1, 4]], ""2_15"": [[], [1, 3, 1, 3, 1, 3, 1, '
                    '4]], ""10_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [2, 2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3]], '
                    '""10_12"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], ""13_21"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '14, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 1, 1, 6, 1, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], '
                    '[2]], ""12_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 3, 3, 1, 2, 1, 3, 1, 1, 1, 1, 6], [1, '
                    '3, 3, 1, 3, 3, 1, 2, 1, 3, 1, 2, 1, 3, 3]], ""9_9"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 10]], '
                    '""3_18"": [[], [1, 1, 4, 1, 1, 4, 1, 1, 7]], ""14_15"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '16]], ""14_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '
                    '1, 7], [1, 3]], ""13_16"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 11, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 8, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, '
                    '3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], ""6_8"": [[], [1, 1, 1, 1, 1, 9]], ""3_16"": [[], [1, 1, 4, 1, '
                    '1, 4, 1, 1, 5]], ""2_6"": [[], [1, 3]], ""20_21"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 22]], ""6_7"": [[], [1, 1, 1, 1, 1, 8]], ""2_4"": [[], [1, 5]], ""9_12"": [[], [1, 1, '
                    '1, 1, 1, 1, 1, 1, 13]], ""8_12"": [[], [1, 1, 1, 1, 1, 1, 1, 13]], ""8_10"": [[], [1, 1, 1, 1, 1, 1, '
                    '1, 11]], ""15_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 14, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, '
                    '1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]], ""2_17"": [[], [1, 3, 1, 3, 1, 3, 1, 3, '
                    '3]], ""16_16"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], ""1_22"": [[], [2, 2, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 3]], ""4_11"": [[], [1, 1, 1, 5, 1, 1, 5]], ""4_4"": [[], [1, 1, 1, 5]], '
                    '""11_16"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 3, 1, 2, 2, 1, 1, 1, 1, 1, 7], [2, 3, 2, 3, 1, '
                    '2, 2, 1, 2, 2, 2, 2, 3]], ""2_18"": [[], [1, 3]], ""6_16"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 7]], '
                    '""2_14"": [[], [1, 3]], ""7_13"": [[1, 1, 1, 1, 1, 1, 8], [2]], ""3_22"": [[], [1, 1, 4, 1, 1, 4, 1, '
                    '1, 4, 1, 1, 5]], ""19_19"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20]], '
                    '""8_17"": [[1, 1, 1, 1, 1, 1, 1, 9], [2, 2, 2, 3, 1, 2, 2, 2, 2, 2, 2, 3]], ""2_5"": [[], [1, 3, '
                    '3]], ""19_22"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 3, 1, 2, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 3, 3, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, '
                    '3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, '
                    '1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 1, 5], [3, 3, 3, 3, 3, 3, '
                    '1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 3]], ""10_16"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 5, 1, '
                    '1, 1, 3, 1, 1, 1, 5, 1, 5]], ""22_22"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 23]], ""4_13"": [[], [1, 1, 1, 5, 1, 1, 1, 6]], ""7_20"": [[], [1, 1, 1, 1, 1, 1, 8, 1, '
                    '1, 1, 1, 1, 8]], ""5_22"": [[1, 1, 1, 1, 6, 1, 1, 1, 1, 6], [1, 3, 3, 1, 2, 1, 3, 3, 1, 2, 1, 3, '
                    '3]], ""16_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], ""13_14"": [[], [1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 15]], ""5_8"": [[1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3]], ""1_11"": [[], '
                    '[2]], ""7_21"": [[], [1, 1, 1, 1, 1, 1, 8]], ""11_12"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13]], '
                    '""12_18"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 19]], ""7_19"": [[1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, '
                    '6, 2, 2, 1, 1, 1, 1, 6, 2, 2, 1, 1, 4, 2, 2, 2, 2, 1, 1, 4], [2]], ""7_8"": [[], [1, 1, 1, 1, 1, '
                    '1, 9]], ""10_17"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 11], [1, 1, 5, 1, 1, 1, 4, 1, 1, 4, 1, 1, 5]], '
                    '""6_20"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 1, 9]], ""3_19"": [[1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '
                    '""11_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 4, 2, 2, 1, 1, 4, 1, 1, 4, 1, 1, 4], [2]], '
                    '""6_17"": [[], [1, 1, 1, 1, 1, 7, 1, 1, 1, 1, 7]], ""20_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 21]], ""4_8"": [[], [1, 1, 1, 9]], ""8_21"": [[1, 1, 1, 1, 1, 1, 1, 9, 1, 1, '
                    '1, 1, 6, 3, 1, 2, 1, 1, 1, 1, 6], [3, 1, 2, 1, 3, 3, 3, 1, 2, 1, 2, 1, 3, 3]], ""12_17"": [[1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 1, 13, 1, 4, 1, 1, 3, 1, 1, 1, 1, 1, 1, 8], [1, 4, 1, 4, 1, 1, 3, 1, 1, '
                    '3, 1, 3, 1, 4]], ""2_20"": [[], [1, 3, 1, 3, 1, 3, 1, 3, 1, 5]], ""1_9"": [[], [2]], ""14_16"": [[], '
                    '[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17]], ""4_20"": [[], [1, 1, 1, 5]], ""2_16"": [[], [1, 3, 1, '
                    '3, 1, 3, 1, 5]], ""1_14"": [[], [2, 2, 2, 2, 2, 2, 3]], ""1_21"": [[], [2]], ""13_19"": [[1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8], [2]], ""7_15"": [[1, 1, 1, 1, '
                    '1, 1, 8], [2]], ""5_9"": [[1, 1, 1, 1, 6], [2]], ""4_7"": [[1, 1, 1, 5], [3, 1, 2, 2, 3]], '
                    '""4_14"": [[], [1, 1, 1, 5, 1, 1, 1, 7]], ""3_5"": [[1, 1, 4], [2]], ""9_15"": [[1, 1, 1, 1, 1, 1, 1, '
                    '1, 10], [1, 1, 4]], ""6_14"": [[1, 1, 1, 1, 1, 7], [1, 3]], ""14_18"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 15, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 11, 1, 3, 1, 3, 1, 3, 1, 3, 1, 1, 1, 1, '
                    '1, 7], [1, 3]], ""12_20"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 13], [1, 1, 1, 5]], ""1_13"": [[], '
                    '[2]], ""4_22"": [[], [1, 1, 1, 5, 1, 1, 1, 5, 1, 1, 1, 7]], ""16_20"": [[], [1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 1, 21]], ""1_7"": [[], [2]], ""17_19"": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 18, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, '
                    '1, 1, 1, 1, 1, 1, 14, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 2, 2, 2, 2, 2, 2, 2, '
                    '2, 1, 1, 1, 1, 1, 1, 1, 1, 10, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 8, 2, 2, 2, 2, 2, '
                    '2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 6, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 4], [2]]}')

n, x, y = map(int, input().split())
n -= 1
if x > y:
    x, y = y, x
prefix = extract_list(answer[str(x) + '_' + str(y)][0])
pattern = extract_list(answer[str(x) + '_' + str(y)][1], prefix[-1] + 1 if prefix else 1)
if n < len(prefix):
    print(prefix[n])
else:
    n -= len(prefix)
    print(n // len(pattern) * (pattern[-1] - pattern[0] + 1) + pattern[n % len(pattern)])
",np,"bitmasks,dp,math",23167
"def f(n,s):
    d=[-n,-n];
    d[s]=0;
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)];
    return d[s];
import math;
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y=y+x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"bitmasks,dp,math",271
"import math;
def f(n,s):
    d=[-n,-n];
    d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y+=x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"bitmasks,dp,math",267
"import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
	    d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y+=x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"bitmasks,dp,math",258
"import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
	    d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
n,x,y=map(int,input().split());
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));
y+=x;
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))
",np,"bitmasks,dp,math",259
"import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]

n,x,y=map(int,input().split())
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))
y+=x
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"bitmasks,dp,math",259
"
import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]

n,x,y=map(int,input().split())
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))
y+=x
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"bitmasks,dp,math",260
"
import math
def f(n,s):
    d=[-n,-n];d[s]=0
    for i in range(y//g):
        d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
    return d[s]
 
n,x,y=map(int,input().split())
g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1))
y+=x
print(n%g*h(n//g+1)+(g-n%g)*h(n//g))",np,"bitmasks,dp,math",261
"def f(n,s):
 d=[-n,-n];d[s]=0
 for i in range(y//g):d=[max(d[0],d[1]),d[0]+n*g//y+(i*x%y<n*g%y)]
 return d[s]
import math;n,x,y=map(int,input().split());g,h=math.gcd(x,y),lambda n:max(f(n,0),f(n,1));y+=x;print(n%g*h(n//g+1)+(g-n%g)*h(n//g))
",np,"bitmasks,dp,math",241
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)
        
n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []
    
    for v in l:
        if v in powers:
            continue
        
        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2
    
    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()
    
    other = []
    out = [extra]
    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k
    
    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1
    
    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0
        
assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:
        break

    
    if v in powers:
        continue
    
    v2 = v
    for p in pgood:
        while v2 % p == 0:
            v2 //= p
    if v2 == 1:
        out.append(v)
        need -= 1
    
    

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)
",np,"binary search,greedy,math,number theory",3131
"from math import gcd

def t_prime(n):
    if n == 1:
        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:
            return False
    return True

primes = [i for i in range(2,10**5) if t_prime(i)]
pset = set(primes)
        
n, k = map(int, input().split())
l = list(map(int, input().split()))

if k == 1:
    print(0)
    exit()

for i in range(n):
    for j in range(i):
        u, v = l[i], l[j]
        poss = gcd(u,v)
        poss2 = max(u,v)//poss
        smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:
            primes.append(smol)
            pset.add(smol)

powers = set()

count = 0
outLs = []
pgood = []
for p in primes:
    curr = []
    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:
            v2 //= p
        if v2 == 1:
            curr.append(v)
            powers.add(v)
    if len(curr) > 1:
        count += len(curr)
        outLs.append(curr)
        pgood.append(p)

order = [(len(lis), lis) for lis in outLs]
order.sort(key = lambda x: x[0])

if len(order) == 0:
    print(0)
    exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []
    
    for v in l:
        if v in powers:
            continue
        
        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2
    
    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()
    
    other = []
    out = [extra]
    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k
    
    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1
    
    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0
        
assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1
    
    

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np,"binary search,greedy,math,number theory",3115
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)

order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])

if len(order) == 0:    print(0); exit()

if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1
    need = -1
    last = []
    
    for v in l:
        if v in powers:
            continue
        
        v2 = v
        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:
                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):
            extra = v
            last = primesn
            need = len(last)
            assert need >= 2
    
    if need == -1 or 2 * need + 1 > k:
        print(0)
        exit()
    
    other = []
    out = [extra]
    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:
                works = True
                break
        if works:
            out.append(a)
            out.append(b)
        else:
            other.append(a)
            other.append(b)

    assert len(out) == 2 * need + 1
    assert (k - 2 * need - 1) % 2 == 0

    ret = out + other[:(k - 2*need - 1)]
    assert len(ret) == k
    
    print(' '.join(map(str,ret)))
    exit()

out = []
need = k
for i in range(len(order)):
    assert need != 1
    
    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0
        
assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1
    
    

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np,"binary search,greedy,math,number theory",3000
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []    
    for v in l:
        if v in powers:            continue        
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2    
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()    
    other = [];    out = [extra]    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1
    
    lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1):
        out += lis
        need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2:
            out += lis[:-1]
            need -= (len(lis) - 1)
            assert need == 2
    else:
        out += lis[:need]
        need = 0
        
assert need + len(out) == k
assert need >= 0
assert need == 0 or len(out) == count

for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1
    
    

if need == 0:
    print(' '.join(map(str,out)))
    exit()
else:
    print(0)",np,"binary search,greedy,math,number theory",2883
"from math import gcd
def t_prime(n):
    if n == 1:        return False
    for p in [2,3,5,7,11,13,17,19,23]:
        if p < n and pow(p,n-1,n) != 1:            return False
    return True
primes = [i for i in range(2,10**5) if t_prime(i)];pset = set(primes);n, k = map(int, input().split());l = list(map(int, input().split()))
if k == 1: print(0);exit()
for i in range(n):
    for j in range(i):
        u, v = l[i], l[j];poss = gcd(u,v);poss2 = max(u,v)//poss;smol = min(poss,poss2)
        if t_prime(smol) and smol not in pset:primes.append(smol);pset.add(smol)
powers = set();count = 0;outLs = [];pgood = []
for p in primes:
    curr = [];    fp = [v for v in l if v % p == 0]
    for v in fp:
        v2 = v
        while v2 % p == 0:            v2 //= p
        if v2 == 1:   curr.append(v);   powers.add(v)
    if len(curr) > 1: count += len(curr);     outLs.append(curr);  pgood.append(p)
order = [(len(lis), lis) for lis in outLs];order.sort(key = lambda x: x[0])
if len(order) == 0:    print(0); exit()
if order[-1][0] == 2 and k % 2 and count > k:
    extra = -1;    need = -1;    last = []    
    for v in l:
        if v in powers:            continue        
        v2 = v;        primesn = []
        for p in pgood:
            add = 1
            while v2 % p == 0:
                v2 //= p
                if add:                    primesn.append(p)
                add = 0
        if v2 == 1 and (need == -1 or need > len(primesn)):  extra = v;     last = primesn;    need = len(last);   assert need >= 2    
    if need == -1 or 2 * need + 1 > k:  print(0);   exit()    
    other = [];    out = [extra]    
    for a,b in outLs:
        works = False
        for p in last:
            if a % p == 0:   works = True;           break
        if works:       out.append(a);   out.append(b)
        else:       other.append(a);      other.append(b)
    assert len(out) == 2 * need + 1;    assert (k - 2 * need - 1) % 2 == 0; ret = out + other[:(k - 2*need - 1)];    assert len(ret) == k; print(' '.join(map(str,ret)));    exit()
out = [];need = k
for i in range(len(order)):
    assert need != 1;lis = order[i][1]
    if len(lis) < need - 1 or len(lis) == need or (len(lis) == need - 1 and i == len(order) - 1): out += lis; need -= len(lis)
    elif len(lis) == need - 1:
        if len(lis) > 2: out += lis[:-1];  need -= (len(lis) - 1);   assert need == 2
    else: out += lis[:need]; need = 0        
assert need + len(out) == k;assert need >= 0;assert need == 0 or len(out) == count
for v in l:
    if need == 0:        break
    if v in powers:        continue
    v2 = v
    for p in pgood:
        while v2 % p == 0:            v2 //= p
    if v2 == 1:        out.append(v);        need -= 1        
if need == 0:    print(' '.join(map(str,out)));    exit()
else:    print(0)",np,"binary search,greedy,math,number theory",2806
"import sys
input = sys.stdin.readline


def topological_sorted(digraph):
    n = len(digraph)
    indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:
            indegree[nxt_v] += 1

    tp_order = [i for i in range(n) if indegree[i] == 0]
    stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:
                stack.append(nxt_v)
                tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order


n, m, k = map(int, input().split())
p = [input()[:-1] for i in range(n)]
s = [list(input().split()) for i in range(m)]


memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] == ""_"":
            continue
        val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):
    s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:
    print(""YES"")
    print(*[i + 1 for i in res])
else:
    print(""NO"")",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1556
"import sys

input = sys.stdin.readline

from collections import deque

n,m,k = map(int,input().split())
p = [input().rstrip() for i in range(n)]
idx = {s:i for i,s in enumerate(p)}

def match(s):
    res = []
    for i in range(2**k):
        tmp = []
        for j in range(k):
            if i>>j & 1:
                tmp.append(s[j])
            else:
                tmp.append(""_"")
        res.append("""".join(tmp))
    return set(res)

edge = [[] for i in range(n)]
deg = [0]*n
for i in range(m):
    s,mt = input().rstrip().split()
    mt = int(mt)-1
    t = p[mt]
    M = match(s)
    if t in M:
        for nv in M:
            if nv!=t and nv in idx:
                nv = idx[nv]
                edge[mt].append(nv)
                deg[nv] += 1
    else:
        exit(print(""NO""))

deq = deque([v for v in range(n) if deg[v]==0])
res = []
while deq:
    v = deq.popleft()
    res.append(v+1)
    for nv in edge[v]:
        deg[nv] -= 1
        if deg[nv]==0:
            deq.append(nv)

if len(res)!=n:
    exit(print(""NO""))

print(""YES"")
print(*res)
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1060
"
from bisect import *
from collections import *
from math import gcd,ceil,sqrt,floor,inf
from heapq import *
from itertools import *
from operator import add,mul,sub,xor,truediv,floordiv
from functools import *

#------------------------------------------------------------------------
import os
import sys

from io import BytesIO, IOBase
# region fastio
 
BUFSIZE = 8192
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 

#------------------------------------------------------------------------
def RL(): return map(int, sys.stdin.readline().rstrip().split())
def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))
def N(): return int(input())
#------------------------------------------------------------------------


from types import GeneratorType
 
 
def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
 
    return wrappedfunc

mod=10**9+7
farr=[1]
ifa=[]
 
def fact(x,mod=0):
    if mod:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr)%mod)
    else:
        while x>=len(farr):
            farr.append(farr[-1]*len(farr))
    return farr[x]
 
def ifact(x,mod):
    global ifa
    fact(x,mod)
    ifa.append(pow(farr[-1],mod-2,mod))
    for i in range(x,0,-1):
        ifa.append(ifa[-1]*i%mod)
    ifa.reverse()
 
def per(i,j,mod=0):
    if i<j: return 0
    if not mod:
        return fact(i)//fact(i-j)
    return farr[i]*ifa[i-j]%mod
    
def com(i,j,mod=0):
    if i<j: return 0
    if not mod:        
        return per(i,j)//fact(j)
    return per(i,j,mod)*ifa[j]%mod
 
def catalan(n):
    return com(2*n,n)//(n+1)
 
def isprime(n):
    for i in range(2,int(n**0.5)+1):
        if n%i==0:
            return False
    return True

def floorsum(a,b,c,n):#sum((a*i+b)//c for i in range(n+1))
    if a==0:return b//c*(n+1)
    if a>=c or b>=c: return floorsum(a%c,b%c,c,n)+b//c*(n+1)+a//c*n*(n+1)//2
    m=(a*n+b)//c
    return n*m-floorsum(c,c-b-1,a,m-1)

def inverse(a,m):
    a%=m
    if a<=1: return a
    return ((1-inverse(m,a)*m)//a)%m
 
def lowbit(n):
    return n&-n
 
class BIT:
    def __init__(self,arr):
        self.arr=arr
        self.n=len(arr)-1
        
    def update(self,x,v):
        while x<=self.n:
            self.arr[x]+=v
            x+=x&-x
 
    def query(self,x):
        ans=0
        while x:
            ans+=self.arr[x]
            x&=x-1
        return ans
'''
class SMT:
    def __init__(self,arr):
        self.n=len(arr)-1#arr包含一个前导0
        self.arr=[0]*(self.n<<2)
        self.lazy=[0]*(self.n<<2)
        def Build(l,r,rt):
            if l==r:
                self.arr[rt]=arr[l]
                return
            m=(l+r)>>1
            Build(l,m,rt<<1)
            Build(m+1,r,rt<<1|1)
            self.pushup(rt)
        Build(1,self.n,1)
 
    def pushup(self,rt):
        self.arr[rt]=self.arr[rt<<1]+self.arr[rt<<1|1]
 
    def pushdown(self,rt,ln,rn):#lr,rn表区间数字数
        if self.lazy[rt]:
            self.lazy[rt<<1]+=self.lazy[rt]
            self.lazy[rt<<1|1]+=self.lazy[rt]
            self.arr[rt<<1]+=self.lazy[rt]*ln
            self.arr[rt<<1|1]+=self.lazy[rt]*rn
            self.lazy[rt]=0
            
    def update(self,L,R,c,l=1,r=None,rt=1):#L,R表示操作区间
        if r==None: r=self.n
        if L<=l and r<=R:
            self.arr[rt]+=c*(r-l+1)
            self.lazy[rt]+=c
            return
        m=(l+r)>>1
        self.pushdown(rt,m-l+1,r-m)
        if L<=m: self.update(L,R,c,l,m,rt<<1)
        if R>m: self.update(L,R,c,m+1,r,rt<<1|1)
        self.pushup(rt)
 
    def query(self,L,R,l=1,r=None,rt=1):
        if r==None: r=self.n
        #print(L,R,l,r,rt)
        if L<=l and R>=r:
            return self.arr[rt]
        m=(l+r)>>1
        self.pushdown(rt,m-l+1,r-m)
        ans=0
        if L<=m: ans+=self.query(L,R,l,m,rt<<1)
        if R>m: ans+=self.query(L,R,m+1,r,rt<<1|1)
        return ans
'''       
class DSU:#容量+路径压缩
    def __init__(self,n):
        self.c=[-1]*n
 
    def same(self,x,y):
        return self.find(x)==self.find(y)
 
    def find(self,x):
        if self.c[x]<0:
            return x
        self.c[x]=self.find(self.c[x])
        return self.c[x]
 
    def union(self,u,v):
        u,v=self.find(u),self.find(v)
        if u==v:
            return False
        if self.c[u]>self.c[v]:
            u,v=v,u
        self.c[u]+=self.c[v]
        self.c[v]=u
        return True
 
    def size(self,x): return -self.c[self.find(x)]
    
class UFS:#秩+路径
    def __init__(self,n):
        self.parent=[i for i in range(n)]
        self.ranks=[0]*n
 
    def find(self,x):
        if x!=self.parent[x]:
            self.parent[x]=self.find(self.parent[x])
        return self.parent[x]
 
    def union(self,u,v):
        pu,pv=self.find(u),self.find(v)
        if pu==pv:
            return False
        if self.ranks[pu]>=self.ranks[pv]:
            self.parent[pv]=pu
            if self.ranks[pv]==self.ranks[pu]:
                self.ranks[pu]+=1
        else:
            self.parent[pu]=pv
 
def Prime(n):
    c=0
    prime=[]
    flag=[0]*(n+1)
    
    for i in range(2,n+1):
        if not flag[i]:
            prime.append(i)
            c+=1
        for j in range(c):
            if i*prime[j]>n: break
            flag[i*prime[j]]=prime[j]
            if i%prime[j]==0: break
    return prime
 
def dij(s,graph):
    d={}
    d[s]=0
    heap=[(0,s)]
    seen=set()
    while heap:
        dis,u=heappop(heap)
        if u in seen:
            continue
        seen.add(u)
        for v,w in graph[u]:
            if v not in d or d[v]>d[u]+w:
                d[v]=d[u]+w
                heappush(heap,(d[v],v))
    return d
 
def GP(it): return [[ch,len(list(g))] for ch,g in groupby(it)]
def lcm(a,b): return a*b//gcd(a,b)
def lis(nums):
    res=[]
    for k in nums:
        i=bisect.bisect_left(res,k)
        if i==len(res):
            res.append(k)
        else:
            res[i]=k
    return len(res)
 
class DLN:
    def __init__(self,val):
        self.val=val
        self.pre=None
        self.next=None

def nb(i,j):
    for ni,nj in [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]:
        if 0<=ni<n and 0<=nj<m:
            yield ni,nj

def topo(n):
    q=deque()
    res=[]
    for i in range(n):
        if ind[i]==0:
            q.append(i)
            res.append(i+1)
    while q:
        u=q.popleft()
        for v in g[u]:
            ind[v]-=1
            if ind[v]==0:
                q.append(v)
                res.append(v+1)
    return res

@bootstrap
def gdfs(r,p):
    if len(g[r])==1 and p!=-1:
        yield None
    for ch in g[r]:
        if ch!=p:
            yield gdfs(ch,r)
    yield None


def match(pat,cur):
    for i in range(k):
        if pat[i]!='_' and pat[i]!=cur[i]:
            #print(pat[i],cur[i])
            return False
    return True

def pos(cur):
    res=list(cur)
    #print(cur,res)
    pa=[]
    dfs(0,pa,res)
    return pa

def dfs(i,pa,res):
    #print(i,pa,res)
    global k
    if i==k:
        #print(res)
        pa.append(''.join(res))
        return 
    dfs(i+1,pa,res)
    #print(i,res,pa)
    tmp=res[i]
    res[i]='_'
    dfs(i+1,pa,res)
    res[i]=tmp
    


t=1
for i in range(t):
    n,m,k=RLL()
    p=[]
    d={}
    for i in range(n):
        cur=input()
        p.append(cur)
        d[cur]=i
    res=[]
    ans=True
    ind=[0]*n
    #print(d)
    g=[[] for i in range(n)]
    for i in range(m):
        cur,x=input().split()
        x=int(x)
        if ans:
            #print(cur,x,p[x-1])
            if not match(p[x-1],cur):
                ans=False
            else:
                #print(cur)
                for al in pos(cur):
                    if al in d and d[al]!=x-1:
                        g[x-1].append(d[al])
                        ind[d[al]]+=1
    if not ans:
        print(""NO"")
    else:
        #print(g,ind)
        ans=topo(n)
        if len(ans)!=n:
            print(""NO"")
        else:
            print(""YES"")
            print(*ans)
    #print(*ans)
            
    
                    
                    
        

''' 
sys.setrecursionlimit(200000)
import threading
threading.stack_size(10**8)
t=threading.Thr
ead(target=main)
t.start()
t.join()
'''

''' 
sys.setrecursionlimit(200000)
import threading
threading.stack_size(10**8)
t=threading.Thread(target=main)
t.start()
t.join()
'''
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",10306
"import io
import os

from collections import Counter, defaultdict, deque
from pprint import pprint

# toposort from pajenegod, AC server: https://discordapp.com/channels/555883512952258563/578670185007808512/708046996207829093
def toposort(graph):
    res = []
    found = [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(~node)
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack += graph[node]

    # cycle check
    for node in res:
        if any(found[nei] for nei in graph[node]):
            return None
        found[node] = 0

    return res[::-1]


def solve(N, M, K, P, S, MT):
    graph = [[] for i in range(N)]

    def isMatch(s, pattern):
        for a, b in zip(s, pattern):
            if b != ""_"" and a != b:
                return False
        return True

    ordA = ord(""a"") - 1

    def hashStr(s):
        hsh = 0
        for i, c in enumerate(s):

            val = 27 if c == ""_"" else ord(c) - ordA
            hsh = 32 * hsh + val
        return hsh

    patternToId = {}
    for i, p in enumerate(P):
        patternToId[hashStr(p)] = i
    #print(patternToId)

    for s, mt in zip(S, MT):
        if not isMatch(s, P[mt]):
            return ""NO""
        vals = [ord(c) - ordA for c in s]
        hsh = 0
        for mask in range(1 << K):
            hsh = 0
            for pos in range(K):
                val = 27 if (1 << pos) & mask else vals[pos]
                hsh = 32 * hsh + val
            if hsh in patternToId:
                mt2 = patternToId[hsh]

                #print(s, bin(mask), hsh, P[mt2])
                if mt2 != mt:
                    graph[mt].append(mt2)

    ans = toposort(graph)
    if ans is None:
        return ""NO""

    return ""YES\n"" + "" "".join(str(i + 1) for i in ans)


if __name__ == ""__main__"":
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

    TC = 1
    for tc in range(1, TC + 1):
        N, M, K = [int(x) for x in input().split()]
        P = [input().decode().rstrip() for i in range(N)]
        S = []
        MT = []
        for i in range(M):
            s, mt = input().split()
            s = s.decode()
            mt = int(mt) - 1  # 0 indexed
            S.append(s)
            MT.append(mt)
        ans = solve(N, M, K, P, S, MT)
        print(ans)

",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",2409
"import sys
from enum import Enum

class flag(Enum):
    UNVISITED = -1
    EXPLORED = -2
    VISITED = -3

def match(p, s):
    for i in range(len(p)):
        if p[i] != ""_"" and p[i] != s[i]:
            return False
    return True

def cycleCheck(u):
    global AL
    global dfs_num
    global dfs_parent
    global sol

    dfs_num[u] = flag.EXPLORED.value
    for v in AL[u]:
        if dfs_num[v] == flag.UNVISITED.value:
            dfs_parent[v] = u
            cycleCheck(v)
        elif dfs_num[v] == flag.EXPLORED.value:
            sol = False
    dfs_num[u] = flag.VISITED.value

def toposort(u):
    global AL
    global dfs_num
    global ts

    dfs_num[u] = flag.VISITED.value
    for v in AL[u]:
        if dfs_num[v] == flag.UNVISITED.value:
            toposort(v)
    ts.append(u)

sol = True
n, m, k = map(int, sys.stdin.readline().strip().split())
pd = {}
ps = set()
pa = []
for i in range(n):
    p = sys.stdin.readline().strip()
    pd[p] = i + 1
    ps.add(p)
    pa.append(p)

AL = [[] for _ in range(n)]

for _ in range(m):
    s, fn = sys.stdin.readline().strip().split()
    fn = int(fn)
    if not match(pa[fn-1], s):
        sol = False
        
    mm = [""""]
    for i in s:
        mm = list(map(lambda x: x + ""_"", mm)) + list(map(lambda x: x + i, mm))
    for i in mm:
        if i in ps:
            if pd[i] != fn:
                AL[fn-1].append(pd[i]-1)

try:    
    if not sol:
        print(""NO"")
    else:
        dfs_num = [flag.UNVISITED.value] * n
        dfs_parent = [-1] * n
        for u in range(n):
            if dfs_num[u] == flag.UNVISITED.value:
                cycleCheck(u)
        if not sol:
            print(""NO"")
        else:
            dfs_num = [flag.UNVISITED.value] * n
            ts = []
            for u in range(n):
                if dfs_num[u] == flag.UNVISITED.value:
                    toposort(u)
            ts = ts[::-1]
            print(""YES"")
            print(' '.join(map(lambda x: str(x+1), ts)))
except:
    print(""NO"")",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",2009
"def main():
    import sys
    import collections
    input = sys.stdin.readline
    n, m, K = map(int, input().split())

    A = [input().rstrip() for i in range(n)]

    B = [list(input().rstrip().split()) for i in range(m)]

    alpha = 'abcｄ'

    D = dict()
    for i, x in enumerate(A):
        D[x] = i

    G = [set() for i in range(n)]
    X = [set() for i in range(n)]

    for i in range(m):
        a, b = B[i]
        b = int(b)
        flag = False
        for j in range(2**K):
            x = []
            for k in range(K):
                if (j >> k) % 2 == 1:
                    x.append('_')
                else:
                    x.append(a[k])
            x = ''.join(x)
            if x in D:
                if D[x] == b-1:
                    flag = True
                    continue
                else:
                    G[b-1].add(D[x])
                    X[D[x]].add(b-1)
        if flag:
            continue
        else:
            print(""NO"")
            exit(0)
    X = [len(X[i]) for i in range(n)]
    ANS = []
    s = set()
    q = collections.deque()
    for i in range(n):
        if X[i] == 0:
            q.append(i)
            s.add(i)
    # print(G)
    # print(X)
    while(q):
        if len(ANS) == n:
            print(""NO"")
            exit(0)
        x = q.popleft()
        ANS.append(x+1)
        for y in G[x]:
            if X[y] == 0:
                continue
            else:
                X[y] -= 1
                if X[y] == 0:
                    q.append(y)
    if len(ANS) == n:
        print(""YES"")
        print(*ANS)
    else:
        print(""NO"")


main()
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1634
"import sys;input = sys.stdin.readline


def topological_sorted(digraph):
    n = len(digraph)
    indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:
            indegree[nxt_v] += 1

    tp_order = [i for i in range(n) if indegree[i] == 0]
    stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:
                stack.append(nxt_v)
                tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order


n, m, k = map(int, input().split())
p = [input()[:-1] for i in range(n)]
s = [list(input().split()) for i in range(m)]


memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] == ""_"":
            continue
        val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):
    s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1542
"import sys;input = sys.stdin.readline
def topological_sorted(digraph):
    n = len(digraph);indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:indegree[nxt_v] += 1
    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)

    return len(tp_order) == n, tp_order
n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {}
for idx, ptn in enumerate(p):
    val = 0
    for i in range(k):
        if ptn[i] != ""_"":val += (ord(ptn[i]) - 96) * (27 ** i)
    memo[val] = idx

for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)

graph = [[] for i in range(n)]
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:
        print(""NO"")
        exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1446
"import sys;input = sys.stdin.readline
def topological_sorted(digraph):
    n = len(digraph);indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:indegree[nxt_v] += 1
    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)
    return len(tp_order) == n, tp_order
n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]
for idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != ""_""]);memo[val] = idx
for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:print(""NO"");exit()

    for idx_to in idxs:
        if idx == idx_to:
            continue
        graph[idx].append(idx_to)

flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1402
"import sys;input = sys.stdin.readline
def topological_sorted(digraph):
    n = len(digraph);indegree = [0] * n
    for v in range(n):
        for nxt_v in digraph[v]:indegree[nxt_v] += 1
    tp_order = [i for i in range(n) if indegree[i] == 0];stack = tp_order[:]
    while stack:
        v = stack.pop()
        for nxt_v in digraph[v]:
            indegree[nxt_v] -= 1
            if indegree[nxt_v] == 0:stack.append(nxt_v);tp_order.append(nxt_v)
    return len(tp_order) == n, tp_order
n, m, k = map(int, input().split());p = [input()[:-1] for i in range(n)];s = [list(input().split()) for i in range(m)];memo = {};graph = [[] for i in range(n)]
for idx, ptn in enumerate(p):val = sum([(ord(ptn[i]) - 96) * (27 ** i) for i in range(k) if ptn[i] != ""_""]);memo[val] = idx
for i, (string, idx) in enumerate(s):s[i] = tuple(map(ord, string)), int(idx)
for string, idx in s:
    idxs = []
    idx -= 1
    for bit_state in range(1 << k):
        val = 0
        for i in range(k):
            if (bit_state >> i) & 1:
                continue
            val += (string[i] - 96) * (27 ** i)
        if val in memo:
            idxs.append(memo[val])
    if idx not in idxs:print(""NO"");exit()

    graph[idx] += [idx_to for idx_to in idxs if idx != idx_to]
flag, res = topological_sorted(graph)
if flag:print(""YES"");print(*[i + 1 for i in res])
else:print(""NO"")",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1359
"'''Author- Akshit Monga'''
from sys import stdin, stdout
from collections import defaultdict
import sys
input = stdin.readline
def gen(temp,i):
    global s,k,outs
    if i==k:
        j=''
        for o in range(k):
            if temp[o]==1:
                j+=s[o]
            else:
                j+='_'
        outs.add(j)
        return
    temp[i]=1
    gen(temp,i+1)
    temp[i]=-1
    gen(temp,i+1)


class Graph:
    def __init__(self, vertices):
        self.graph = defaultdict(list)
        self.V = vertices

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def isCyclicUtil(self, v, visited, recStack):
        visited[v] = True
        recStack[v] = True
        for neighbour in self.graph[v]:
            if visited[neighbour] == False:
                if self.isCyclicUtil(neighbour, visited, recStack) == True:
                    return True
            elif recStack[neighbour] == True:
                return True
        recStack[v] = False
        return False

    def isCyclic(self):
        visited = [False] * self.V
        recStack = [False] * self.V
        for node in range(self.V):
            if visited[node] == False:
                if self.isCyclicUtil(node, visited, recStack) == True:
                    return True
        return False
    def topologicalSortUtil(self, v, visited, stack):
        visited[v] = True
        for i in self.graph[v]:
            if visited[i] == False:
                self.topologicalSortUtil(i, visited, stack)
        stack.append(v)

    def topologicalSort(self):
        visited = [False] * self.V
        stack = []
        for i in range(self.V):
            if visited[i] == False:
                self.topologicalSortUtil(i, visited, stack)
        stack=stack[::-1]
        print(""yes"")
        for i in stack:
            stdout.write(str(i+1)+"" "")


n,m,k=map(int,input().split())
patterns={}
all=[]
for i in range(n):
    s=input()[:-1]
    patterns[s]=i
    all.append(s)
strs=[]
dg=Graph(n)
for i in range(m):
    s,mt=input().split()
    mt=int(mt)-1
    outs=set()
    temp=[0 for o in range(k)]
    gen(temp,0)
    if all[mt] not in outs:
        print(""no"")
        sys.exit()
    for i in outs:
        if i!=all[mt] and i in patterns:
            dg.addEdge(mt,patterns[i])
if dg.isCyclic():
    print(""no"")
else:
    dg.topologicalSort()
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",2354
"import sys
input = sys.stdin.readline
from collections import defaultdict, Counter, deque

n, m, k = map(int, input().split())
P = [input()[:-1] for _ in range(n)]
S = [list(input().split()) for _ in range(m)]
idx = {p: i for i, p in enumerate(P, 1)}
G = defaultdict(list)
deg = Counter()
for s, i in S:
    i = int(i)
    cand = set()
    for mask in range(1 << k):
        cur = ['_'] * k
        for j in range(k):
            if mask >> j & 1: cur[j] = s[j]
        cur = """".join(cur)
        if cur in idx:
            cand.add(idx[cur])
    if i not in cand:
        print(""NO"")
        break
    for c in cand:
        if c == i: continue
        G[i].append(c)
        deg[c] += 1
else:
    ans = []
    q = deque([i for i in range(1, n + 1) if not deg[i]])
    while q:
        i = q.popleft()
        ans.append(i)
        for j in G[i]:
            deg[j] -= 1
            if not deg[j]:
                q.append(j)
    if len(ans) < n:
        print(""NO"")
    else:
        print(""YES"")
        print(*ans)",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1018
"import sys
input = sys.stdin.readline

n,m,k=map(int,input().split())
P=[input().strip() for i in range(n)]
S=[input().split() for i in range(m)]

for i in range(m):
    S[i][1]=int(S[i][1])-1

PDICT=dict()
for i in range(n):
    PDICT[P[i]]=i

E=[]

for i in range(m):
    x=S[i][0]
    LIST=[]

    for j in range(1<<k):
        t=""""
        for l in range(k):
            if (1<<l) & j != 0:
                t+=""_""
            else:
                t+=x[l]

        if t in PDICT:
            LIST.append(PDICT[t])

    if not (S[i][1] in LIST):
        print(""NO"")
        exit()

    else:
        s=S[i][1]
        for l in LIST:
            if l==s:
                continue
            else:
                E.append((s,l))

EDGEIN=[0]*n # その点に入るEDGEの個数
EDGEOUTLIST=[[] for i in range(n)] # EDGEの行き先
for x,y in E:
    EDGEIN[y]+=1
    EDGEOUTLIST[x].append(y)

from collections import deque
QUE = deque()

for i in range(n):
    if EDGEIN[i]==0:
        QUE.append(i) # 行き先のない点をQUEに入れる
        
TOP_SORT=[]
while QUE:
    x=QUE.pop()
    TOP_SORT.append(x) # 行き先がない点を答えに入れる
    for to in EDGEOUTLIST[x]:
        EDGEIN[to]-=1 # 行き先がない点を削除し,そこから一歩先の点のEDGEINを一つ減らす.
        if EDGEIN[to]==0:
            QUE.appendleft(to)

if len(TOP_SORT)==n:
    print(""YES"")
    print(*[i+1 for i in TOP_SORT])
else:
    print(""NO"")
        
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1335
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')

N, M, K = map(int, input().split())
P = []
D_P = {}

for i in range(N):
	S = input()
	P.append(S)
	D_P[S] = i

adj = [[] for _ in range(N)]
indeg = [0] * N

for _ in range(M):
	S, mt = input().split()
	mt = int(mt)-1

	fp = P[mt]

	if any(fp[i] not in (S[i], '_') for i in range(K)):
		print('NO')
		raise SystemExit

	for bs in range(1<<K):
		pat = ''.join(S[i] if bs & (1<<i) == 0 else '_' for i in range(K))
		if pat == fp: continue
		if pat in D_P:
			j = D_P[pat]
			indeg[j] += 1
			adj[mt].append(j)

Q = [i for i in range(N) if indeg[i] == 0]
for i in Q:
	for j in adj[i]:
		indeg[j] -= 1
		if indeg[j] == 0:
			Q.append(j)

if len(Q) == N:
	print('YES')
	print(' '.join(str(v+1) for v in Q))
else:
	print('NO')
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",784
"import sys
input = lambda: sys.stdin.readline().rstrip()
#CF-E-00
#import numpy as np
#import heapq
#from collections import deque
#from collections import Counter as cnt
from collections import defaultdict as ddc
#from math import factorial as fct
#from math import gcd
#from bisect import bisect_left as bsl
#from bisect import bisect_right as bsr
#from itertools import accumulate as acc
#from itertools import combinations as cmb
#from itertools import permutations as pmt
#from itertools import product as prd
#from functools import reduce as red
#import sys
#sys.setrecursionlimit(10**9)  #再帰を多く使う(デフォルトは1000)
def main():
    n, m, k = map(int,input().split())  #k: length of following inputs

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = ''
            for j in range(k):
                if i>>j&1:
                    ans = ''.join([ans, s[j]])
                else:
                    ans = ''.join([ans, '_'])
            Ans.add(ans)
        return Ans

    D = ddc(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    from collections import deque
    def topological_sort(In, Out):
        """"""
        Kahn, breadth first search
        In: 入力してくる頂点集合
        Out: 出力先の頂点集合
        """"""
        dq = deque()
        L = []
        for i, I in enumerate(In):
            if not I:
                dq.append(i)
        while dq:
            v = dq.popleft()
            L.append(v)
            for w in Out[v]:
                In[w].remove(v)
                if not In[w]:
                    dq.append(w)
        if len(L) < len(In):  #これはおかしい
            return False
        return L

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')
        
main()",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",2246
"import sys
input = lambda: sys.stdin.readline().rstrip()
#CF-E-00
from collections import deque, defaultdict
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())  #k: length of following inputs

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = ''
            for j in range(k):
                if i>>j&1:
                    ans = ''.join([ans, s[j]])
                else:
                    ans = ''.join([ans, '_'])
            Ans.add(ans)
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')
        
main()",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1531
"#CF-E-00
import sys
from collections import deque, defaultdict
input = lambda: sys.stdin.readline().rstrip()
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())  #k: length of following inputs

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = [s[j] if i>>j&1 else '_' for j in range(k)]
            Ans.add(''.join(ans))
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag == 0 or not T:
        print('NO')
    else:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')
        
main()",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1408
"#CF-E-00
import sys
from collections import deque, defaultdict
input = lambda: sys.stdin.readline().rstrip()
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())  #k: length of following inputs

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = [s[j] if i>>j&1 else '_' for j in range(k)]
            Ans.add(''.join(ans))
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = 1
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = 0
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag and T:
        print('YES')
        print(*[t+1 for t in T], sep = ' ')
    else:
        print('NO')
        
main()",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1400
"#CF-E-00
import sys
from collections import deque, defaultdict
input = lambda: sys.stdin.readline().rstrip()
def topological_sort(In, Out):
    dq, L = deque(), []
    for i, I in enumerate(In):
        if not I:
            dq.append(i)
    while dq:
        v = dq.popleft()
        L.append(v)
        for w in Out[v]:
            In[w].remove(v)
            if not In[w]:
                dq.append(w)
    if len(L) < len(In):
        return False
    return L

def main():
    n, m, k = map(int,input().split())  #k: length of following inputs

    def edges(s):
        Ans = set()
        for i in range(2**k):
            ans = [s[j] if i>>j&1 else '_' for j in range(k)]
            Ans.add(''.join(ans))
        return Ans

    D = defaultdict(lambda : -1)
    for i in range(n):
        D[input()] = i

    flag = True
    In, Out = [set() for _ in range(n)], [set() for _ in range(n)]
    for _ in range(m):
        S, t = input().split()
        t = int(t)

        for e in edges(S):
            if D[e]+1:
                Out[t-1].add(D[e])
                In[D[e]].add(t-1)
        if t-1 not in Out[t-1]:
            flag = False
            break
        else:
            Out[t-1].remove(t-1)
            In[t-1].remove(t-1)

    T = topological_sort(In, Out)
    if flag and T:
        print('YES')
        print(*[t+1 for t in T])
    else:
        print('NO')
        
main()",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1396
"import sys

sys.setrecursionlimit(10**5)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.buffer.readline())
def MI(): return map(int, sys.stdin.buffer.readline().split())
def LI(): return list(map(int, sys.stdin.buffer.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def BI(): return sys.stdin.buffer.readline().rstrip()
def SI(): return sys.stdin.buffer.readline().rstrip().decode()
inf = 10**16
md = 10**9+7
# md = 998244353

trie = [{}]

def push(s, val):
    now = 0
    for c in s:
        if c not in trie[now]:
            trie[now][c] = len(trie)
            trie.append({})
        now = trie[now][c]
    trie[now][""end""] = val

def match(s):
    res = []
    stack = [(0, 0)]
    while stack:
        u, i = stack.pop()
        if i == k:
            res.append(trie[u][""end""])
            continue
        if s[i] in trie[u]:
            stack.append((trie[u][s[i]], i+1))
        if ""_"" in trie[u]:
            stack.append((trie[u][""_""], i+1))
    return res

n, m, k = MI()
for i in range(n):
    push(SI(), i)
# print(trie)

to = [[] for _ in range(n)]
for _ in range(m):
    s, u = SI().split()
    u = int(u)-1
    vv = match(s)

    notmatch = True
    for v in vv:
        if u == v: notmatch = False
        else: to[u].append(v)
    if notmatch:
        print(""NO"")
        exit()

vis=[-1]*n
topo=[]
for u in range(n):
    if vis[u]==1:continue
    stack=[u]
    while stack:
        u=stack.pop()
        if vis[u]==-1:
            vis[u]=0
            stack.append(u)
            for v in to[u]:
                if vis[v]==0:
                    print(""NO"")
                    exit()
                if vis[v]==-1:
                    stack.append(v)
        elif vis[u]==0:
            topo.append(u+1)
            vis[u]=1

print(""YES"")
print(*topo[::-1])
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1865
"import sys
I=sys.stdin.readlines()
N,M,K=map(int,I[0].split())
S=[I[i+1][:-1] for i in range(N)]
D=dict()
for i in range(N):
  D[S[i]]=i
T=[I[i+N+1].split() for i in range(M)]
for i in range(M):
  T[i][1]=int(T[i][1])-1
G=[[] for i in range(N)]
C=[0]*N
for i in range(M):
  for j in range(K):
    if S[T[i][1]][j]!='_' and S[T[i][1]][j]!=T[i][0][j]:
      print('NO')
      exit()
  for j in range(1<<K):
    t=''.join(['_' if j&(1<<k) else T[i][0][k] for k in range(K)])
    x=D.get(t,-1)
    if x!=-1 and x!=T[i][1]:
      G[T[i][1]].append(x)
      C[x]+=1
P=[]
Q=[]
F=[1]*N
for i in range(N):
  if C[i]==0 and F[i]:
    Q.append(i)
  while len(Q):
    v=Q.pop()
    F[v]=0
    P.append(v+1)
    for i in range(len(G[v])):
      C[G[v][i]]-=1
      if C[G[v][i]]==0:
        Q.append(G[v][i])
if len(P)==N:
  print('YES')
  print(*P)
else:
  print('NO')
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",857
"from sys import stdin, gettrace

if gettrace():
    def inputi():
        return input()
else:
    def input():
        return next(stdin)[:-1]


    def inputi():
        return stdin.buffer.readline()

def patterns(s):
    if len(s) == 1:
        return [s, '_']
    else:
        tp = patterns(s[1:])
        return [s[0] + t for t in tp] + ['_' + t for t in tp]

def main():
    n,m,k = map(int, input().split())
    pp = (input() for _ in range(n))
    ppm = {}
    for i, p in enumerate(pp):
        ppm[p] = i
    pre = [0]*n
    suc = [[] for _ in range(n)]
    for _ in range(m):
        s, ml = input().split()
        ml = int(ml) - 1
        ps = patterns(s)
        found = False
        for p in ps:
            if p in ppm:
                if ppm[p] == ml:
                    found = True
                else:
                    pre[ppm[p]] += 1
                    suc[ml].append(ppm[p])
        if not found:
            print(""NO"")
            return
    znodes = [i for i in range(n) if pre[i]==0]
    res = []
    while znodes:
        i = znodes.pop()
        res.append(i+1)
        for j in suc[i]:
            pre[j] -= 1
            if pre[j] == 0:
                znodes.append(j)
    if len(res) == n:
        print(""YES"")
        print(' '.join(map(str, res)))
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1361
"import collections,sys,functools,heapq,bisect,math

def binary(s):
    ans = set()
    for i in range(2**len(s)):
        x = []
        for j in range(len(s)):
            if (i>>j) & 1:
                x.append(s[j])
            else:
                x.append('_')
        ans.add(''.join(x))
    return ans   

seen = set()
visited = set()
ans = []
def dfs(i):
    visited.add(i)
    seen.add(i)
    for j in graph[i]:
        if j in visited:
            return True
        if j in seen:
            continue
        if dfs(j):
            return True
    ans.append(str(i))
    visited.remove(i)
    return False 

def topo(graph):
    seen.clear()
    for i in range(1,n+1):
        if i in seen:
            continue
        if dfs(i):
            return False
    return True    
    
input = sys.stdin.readline
mod = 10**9 + 7

#t = int(input())
for _ in range(1):
    n,m,k = map(int,input().strip().split())
    d = {}
    dop = {}
    for i in range(1,n+1):
        d[i] = input().strip()
        dop[d[i]] = i 
        
        
    graph = collections.defaultdict(list)
    for i in range(m):
        s = input().strip().split()
        ind = int(s[1])
        sset = binary(s[0])
        #print(s,sset)
        if d[ind] not in sset:
            print('NO')
            break
        for i in sset:
            if i in dop and dop[i] != ind :
                graph[dop[i]].append(ind)
    else:
        #print(graph)
        if topo(graph):
            print('YES')
            print(' '.join(ans))
        else:
            print('NO')
            
    ",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1570
"import sys
input = lambda: sys.stdin.readline().rstrip('\r\n')
from collections import defaultdict as dft


n,m,k=map(int,input().split())
dct={}
global case
case=0
iput=[]
for i in range(n):
    word=input()
    dct[word]=i+1
    iput.append(word)
d=[[] for i in range(n+1)]
size=[0]*(n+1)
for _ in range(m):
    
    word,idx=input().split()
    idx=int(idx)
    temp=1
    w=iput[idx-1]
    
    for x in range(k):
        if w[x]!='_' and w[x]!=word[x]:
            temp=0
            print(""NO"")
            exit()
            break
    
    
    res=[]
    for i in range(1<<k):
        s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])
        #print(s)
        
        if s in dct:
            j=dct[s]
            if j!=idx:
                d[idx].append(j)
                size[j]+=1




st=[nd  for nd in range(1,n+1) if size[nd]==0]

for i in st:
    #print(st)
    for j in d[i]:
        size[j]-=1
        if size[j]==0:
            st.append(j)


if len(st)==n:
    print(""YES"")
    print(*st)
else:
    print(""NO"")
    

",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1054
"import os,sys
from io import BytesIO, IOBase

from collections import deque, Counter,defaultdict as dft
from heapq import heappop ,heappush
from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor
from bisect import bisect,bisect_left,bisect_right
from decimal import *
import sys,threading
from itertools import permutations, combinations
from copy import deepcopy
input = sys.stdin.readline


ii = lambda: int(input())
si = lambda: input().rstrip()
mp = lambda: map(int, input().split())
ms=  lambda: map(str,input().strip().split("" ""))
ml = lambda: list(mp())
mf = lambda: map(float, input().split())


alphs = ""abcdefghijklmnopqrstuvwxyz""




def solve():
    n,m,k=map(int,input().split())
    dct={}
    global case
    case=0
    iput=[]
    for i in range(n):
        word=input()
        dct[word]=i+1
        iput.append(word)
    d=[[] for i in range(n+1)]
    size=[0]*(n+1)
    for _ in range(m):
        
        word,idx=input().split()
        idx=int(idx)
        temp=1
        w=iput[idx-1]
        
        for x in range(k):
            if w[x]!='_' and w[x]!=word[x]:
                temp=0
                print(""NO"")
                exit()
                break
        
        
        res=[]
        for i in range(1<<k):
            s="""".join([word[x] if i & (1<<x) ==0 else '_' for x in range(k)])
            #print(s)
            
            if s in dct:
                j=dct[s]
                if j!=idx:
                    d[idx].append(j)
                    size[j]+=1
    
    
    
    
    st=[nd  for nd in range(1,n+1) if size[nd]==0]
    
    for i in st:
        #print(st)
        for j in d[i]:
            size[j]-=1
            if size[j]==0:
                st.append(j)
    
    
    if len(st)==n:
        print(""YES"")
        print(*st)
    else:
        print(""NO"")
        
    

 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    tc=1
    #tc = ii()
    for i in range(tc):
    	solve()",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",4134
"import os,sys
from io import BytesIO, IOBase

from collections import deque, Counter,defaultdict as dft
from heapq import heappop ,heappush
from math import log,sqrt,factorial,cos,tan,sin,radians,log2,ceil,floor
from bisect import bisect,bisect_left,bisect_right
from decimal import *
import sys,threading
from itertools import permutations, combinations
from copy import deepcopy
input = sys.stdin.readline


ii = lambda: int(input())
si = lambda: input().rstrip()
mp = lambda: map(int, input().split())
ms=  lambda: map(str,input().strip().split("" ""))
ml = lambda: list(mp())
mf = lambda: map(float, input().split())


alphs = ""abcdefghijklmnopqrstuvwxyz""




def solve():
    


    def seq(nd,i):
        case=0
        vis[nd]=1
        for lnk in d[nd]:
            
            if not vis[lnk]:
                i,case=seq(lnk,i)
                if case:return i,case
            else:
                if lnk not in seen:
                    #print(seen,lnk)
                    case=1
                    break
                
        
        order[i]=nd
        seen.add(nd)
        
        return i-1,case
        
        
        
    
    def chk(word,dct,i):
        if i==k:
            res.append(dct['#'])
        else:
            if word[i] in dct:
                chk(word,dct[word[i]],i+1)
            if '_' in dct:
                chk(word,dct['_'],i+1)
    
        
    
    
    n,m,k=map(int,input().split())
    trie={}
    global case
    case=0
    for i in range(n):
        word=input()
        dct=trie
        for w in word:
            if w not in dct:
                dct[w]={}
            dct=dct[w]
        dct['#']=i+1
    d=dft(list)
    for i in range(m):
        
        word,idx=input().split()
        idx=int(idx)
        res=[]
        chk(word,trie,0)
        #print(res)
        temp=0
        for num in res:
            if num!=idx:
                d[idx].append(num)
            else:
                temp=1
        if not temp:
            case=1
    
    #print(d)
    
    order=[0]*(n+1)
    vis=[0]*(n+1)
    seen=set()
    idx=n
    
    for i in range(1,n+1):
        if not vis[i]:
            idx,tp=seq(i,idx)
            if tp:
                case=1
                break
    
    if case:
        print(""NO"")
    else:
        print(""YES"")
        print(*order[1:])
        
    


 
BUFSIZE = 8192
 
 
class FastIO(IOBase):
    newlines = 0
 
    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None
 
    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()
 
    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()
 
    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)
 
 
class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")
 
 
def print(*args, **kwargs):
    """"""Prints the values to a stream, or to sys.stdout by default.""""""
    sep, file = kwargs.pop(""sep"", "" ""), kwargs.pop(""file"", sys.stdout)
    at_start = True
    for x in args:
        if not at_start:
            file.write(sep)
        file.write(str(x))
        at_start = False
    file.write(kwargs.pop(""end"", ""\n""))
    if kwargs.pop(""flush"", False):
        file.flush()

if sys.version_info[0] < 3:
    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
else:
    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
 
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
 
# endregion
 
 
if __name__ == ""__main__"":
    tc=1
    #tc = ii()
    for i in range(tc):
    	solve()",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",4633
"import math,sys,bisect,heapq,os
from collections import defaultdict,Counter,deque
from itertools import groupby,accumulate
from functools import lru_cache
#sys.setrecursionlimit(200000000)
int1 = lambda x: int(x) - 1
def input(): return sys.stdin.readline().rstrip('\r\n')
#input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__
aj = lambda: list(map(int, input().split()))
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
#MOD = 1000000000 + 7
def Y(c):  print([""NO"",""YES""][c])
def y(c):  print([""no"",""yes""][c])
def Yy(c):  print([""No"",""Yes""][c])



def solve():
	G = defaultdict(list)

	def addEdge(a,b):
		G[a].append(b)

	def Kahn(N):
	    in_degree = [0]*(N+1)
	    for i in G.keys():
	        for j in G[i]:
	            in_degree[j] += 1
	    queue = deque()
	    for i in range(1,N+1):
	        if in_degree[i] == 0:
	            queue.append(i)
	    cnt =0
	    top_order = []
	    while queue:
	        u = queue.popleft()
	        top_order.append(u)
	        for i in G.get(u,[]):
	            in_degree[i] -= 1
	            if in_degree[i] == 0:
	                queue.append(i)
	        cnt += 1
	    if cnt != N:
	        Y(0);exit(0)
	    else:
	        Y(1);print(*top_order)

	n,m,k = aj()
	mark= {}
	for i in range(n):
		s = input()
		mark[s] = i+1

	B = []
	for i in range(2**k):
		f = bin(i)[2:]
		f = '0'*(k - len(f)) + f
		B.append(f)

	for i in range(m):
		s,mt = input().split("" "")
		mt = int(mt)
		st = set()
		for j in B:
			ss = ['']*k
			for l in range(k):
				if j[l] == '1':
					ss[l] = s[l]
				else:
					ss[l] = '_'
			ss = """".join(ss)
			if ss in mark:
				st.add(mark[ss])
		#print(st)
		if mt not in st:
			Y(0);exit(0)
		st.discard(mt)
		for j in st:
			addEdge(mt,j)
	#print(G)
	Kahn(n)


try:
	#os.system(""online_judge.py"")
	sys.stdin = open('input.txt', 'r') 
	sys.stdout = open('output.txt', 'w')
except:
	pass

solve()",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1906
"mod = 1000000007
eps = 10**-9


def main():
    import sys
    input = sys.stdin.readline

    N, M, K = map(int, input().split())
    P = [""""]
    for i in range(N):
        p = input().rstrip(""\n"")
        P.append(p)
    p2i = {p: i for i, p in enumerate(P)}
    adj = [set() for _ in range(N+1)]
    for i in range(M):
        s, mt = input().split()
        mt = int(mt)
        ok = 0
        for k in range(1 << K):
            s_new = [""_""] * K
            for j in range(K):
                if k >> j & 1:
                    s_new[j] = s[j]
            s_new = """".join(s_new)
            if s_new != P[mt]:
                if s_new in p2i:
                    adj[mt].add(p2i[s_new])
            else:
                ok = 1
        if not ok:
            print(""NO"")
            exit()
    in_num = [0] * (N+1)
    for v in range(1, N+1):
        for u in adj[v]:
            in_num[u] += 1
    st = []
    for v in range(1, N+1):
        if in_num[v] == 0:
            st.append(v)
    ans = []
    while st:
        v = st.pop()
        ans.append(v)
        for u in adj[v]:
            in_num[u] -= 1
            if in_num[u] == 0:
                st.append(u)
    if len(ans) == N:
        print(""YES"")
        print(*ans)
    else:
        print(""NO"")


if __name__ == '__main__':
    main()
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1309
"import sys, os
from collections import defaultdict

if os.environ['USERNAME']=='kissz':
    inp=open('in.txt','r').readline
    def debug(*args):
        print(*args,file=sys.stderr)
else:
    inp=input
    def debug(*args):
        pass

# SCRIPT STARTS HERE
def get_hash(s):
    r=0
    for c in s:
        r*=30
        if c!='_':
            r+=ord(c)-96
    return r

def matches(s):
    R=[]
    for i in range(2**k):
        r=0
        for j in range(k):
            if i&(1<<j):
                r+=(ord(s[j])-96)*(30**(k-j-1))
        if pattern_pos[r]>=0:
            #R.append(r)
            R.append(pattern_pos[r])
    return R

n,m,k=map(int,inp().split())
    
pattern_pos=[-1]*(30**k)
#patterns=[0]*(n+1)
for i in range(n):
    p=get_hash(inp().strip())
    pattern_pos[p]=i+1
    #patterns[i+1]=p

parents=[0]*(n+1)    
edges=defaultdict(list)
failed=False
for i in range(m):
    s,l=inp().split()
    l=int(l)
    M=matches(s)
    if l in M:
        for m in M:
            if l==m: continue
            edges[l].append(m)
            parents[m]+=1
    else:
        failed=True
        break

    
if failed:
    print('NO')
else:
    Q=[]
    for i in range(1,n+1):
        if parents[i]==0:
            Q.append(i)
    
    ans=[]
    while Q:
        i=Q.pop()
        ans.append(i)
        for child in edges[i]:
            parents[child]-=1
            if parents[child]==0:
                Q.append(child)
    if len(ans)==n:
        print('YES')
        print(*ans)
    else:
        print('NO')
    ",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1527
"import sys
input = sys.stdin.readline
from collections import deque
class Graph:
  def __init__(self, N, M=-1):
    self.V = N
    if M>=0: self.E = M
    self.edge = [[] for _ in range(self.V)]
    self.edge_rev = [[] for _ in range(self.V)]
    self.order = []
    self.to = [0]*self.V
    self.visited = [False]*self.V
    self.dp = [0]*self.V

  def add_edge(self, a, b, dist=-1, bi=False, rev=False):
    if dist>=0:
      self.edge[a].append((dist, b))
      if rev: self.edge_rev[b].append((dist, a))
      if bi: self.edge[b].append((dist, a))
    else:
      self.edge[a].append(b)
      self.to[b] += 1
      if rev: self.edge_rev[b].append(a)
      if bi: self.edge[b].append(a)

  def topo_sort(self): #topological sort
    updated = [0]*self.V
    for start in range(self.V):
      if self.to[start] or updated[start]: continue
      stack = deque([start])
      while stack:
        v = stack.popleft()
        self.order.append(v+1)
        updated[v] = 1
        for u in self.edge[v]:
          self.to[u] -= 1
          if self.to[u]: continue
          stack.append(u)

N, M, K = map(int, input().split())

from collections import defaultdict
dic = defaultdict(lambda: -1)
for i in range(N):
  S = input()[:-1]
  dic[S] = i
G = Graph(N)
for _ in range(M):
  t, mt = input().split()
  mt = int(mt)-1
  lis = []
  for S in range(1<<K):
    s = ''
    for i in range(K):
      if (S>>i)%2:
        s += '_'
      else:
        s += t[i]
    if dic[s]>=0: lis.append(dic[s])
  if mt not in lis:
    print('NO')
    exit()
  for l in lis:
    if l!=mt:
      G.add_edge(mt, l, bi=False, rev=False)
G.topo_sort()
if len(G.order)==N:
  print('YES')
  print(*G.order)
else:
  print('NO')",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1698
"import sys
input=sys.stdin.readline

from collections import defaultdict

def toposort(graph):
    res = []
    found = [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(1+(~node))
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack.extend(graph[node])
 
    # cycle check
    for node in res:
        node-=1
        if any(found[nei] for nei in graph[node]):
            print(""NO"")
            return
        found[node] = 0
 
    print(""YES"")
    print(*res[::-1])
    
#https://github.com/cheran-senthil/PyRival/blob/master/pyrival/graphs/toposort.py

n,m,k=map(int,input().split())
patterns=set()
pos=dict()

for i in range(n):
    p=input().rstrip()
    patterns.add(p)
    pos[p]=i
    
matches=[[] for _ in range(n)]

chk=True
for i in range(m):
    s,mt=input().rstrip().split()
    mt=int(mt)-1
    if(chk):
        chk=False
        for i in range(1<<k):
            tmp=[]
            for j in range(k):
                if(i&(1<<j)):
                    tmp.append('_')
                else:
                    tmp.append(s[j])
            tmp=''.join(tmp)
            if(tmp in patterns):
                if(mt==pos[tmp]):
                    chk=True #sj should match with old permutation of p[mtj] apparently smh
                else:
                    matches[mt].append(pos[tmp])
                    
if(not chk):
    print(""NO"")
else:
    toposort(matches)
    
        
            
            
            
        ",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1587
"import os
import sys
from io import BytesIO, IOBase

# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")
#https://github.com/cheran-senthil/PyRival/blob/master/templates/template_py3.py


from collections import defaultdict

def toposort(graph):
    res = []
    found = [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(1+(~node))
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack.extend(graph[node])
 
    # cycle check
    for node in res:
        node-=1
        if any(found[nei] for nei in graph[node]):
            print(""NO"")
            return
        found[node] = 0
 
    print(""YES"")
    print(*res[::-1])
    
#https://github.com/cheran-senthil/PyRival/blob/master/pyrival/graphs/toposort.py

n,m,k=map(int,input().split())
patterns=set()
pos=dict()

for i in range(n):
    p=input().rstrip()
    patterns.add(p)
    pos[p]=i
    
matches=[[] for _ in range(n)]

chk=True
for i in range(m):
    s,mt=input().rstrip().split()
    mt=int(mt)-1
    if(chk):
        chk=False
        for i in range(1<<k):
            tmp=[]
            for j in range(k):
                if(i&(1<<j)):
                    tmp.append('_')
                else:
                    tmp.append(s[j])
            tmp=''.join(tmp)
            if(tmp in patterns):
                if(mt==pos[tmp]):
                    chk=True
                else:
                    matches[mt].append(pos[tmp])
                    
if(not chk):
    print(""NO"")
else:
    toposort(matches)
    
        
            
            
            
        ",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",3291
"from collections import defaultdict
from itertools import accumulate
import sys
input = sys.stdin.readline
'''
for CASES in range(int(input())):
n, m = map(int, input().split())
n = int(input())
A = list(map(int, input().split()))
S = input().strip()
sys.stdout.write("" "".join(map(str,ANS))+""\n"")
'''
inf = 100000000000000000  # 1e17
mod = 998244353

n, m ,k= map(int, input().split())
M=[]
S=[]
F=[]
for i in range(n):
    M.append(input().strip())
for i in range(m):
    tmp1, tmp2 = input().split()
    S.append(tmp1)
    F.append(int(tmp2)-1)


TRAN_dict=defaultdict(int)
TRAN_dict['_']=0
for i in range(97,97+26):
    TRAN_dict[chr(i)]=i-96;


def cal(X):
    base=1
    number=0
    for x in X:
        number=number*base+TRAN_dict[x]
        base*=27
    return number

STONE=defaultdict(int)
for i in range(n):
    STONE[cal(list(M[i]))]=i


def check(X,result):
    number=cal(X)
    if number in STONE.keys():
        result.append(STONE[number])

bian=[[] for i in range(n)]
du=[0]*n


for i in range(m):
    gain=[]
    for digit in range(1<<k):
        now=list(S[i])
        tmp=bin(digit)
        tmp=tmp[2:]
        tmp='0'*(k-len(tmp))+tmp
        for j in range(k):
            if tmp[j]=='1':
                now[j]='_'
        check(now,gain)
    if F[i] not in gain:
        print(""NO"")
        sys.exit(0)
    for x in gain:
        if x!=F[i]:
            bian[F[i]].append(x)
            du[x]+=1

from collections import deque
QUE=deque()
for i in range(n):
    if du[i]==0:
        QUE.append(i)
TOP_SORT=[]
while QUE:
    now=QUE.pop()
    TOP_SORT.append(now)
    for to in bian[now]:
        du[to]-=1
        if du[to]==0:
            QUE.append(to)
if len(TOP_SORT)==n:
    print(""YES"")
    print(*[i+1 for i in TOP_SORT])
else:
    print(""NO"")
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1776
"#   Author: yumtam
#   Created at: 2021-03-06 23:41

def parse():
    s, i = input().split()
    i = int(i) - 1
    return s, i

def match(p, s):
    for a, b in zip(p, s):
        if a != '_' and a != b:
            return False
    return True

def main():
    from itertools import product

    n, m, k = [int(t) for t in input().split()]
    P = [input() for _ in range(n)]
    S = [parse() for _ in range(m)]

    index_of = dict()
    for i, p in enumerate(P):
        index_of[p] = i

    G = [[] for _ in range(n)]
    for s, i in S:
        if not match(P[i], s):
            print(""NO"")
            return

        for mask in product(range(2), repeat=k):
            sp = ['_' if bit else c for bit, c in zip(mask, s)]
            sp = ''.join(sp)

            try:
                j = index_of[sp]
                if i != j:
                    G[i].append(j)
            except:
                pass

    tp = toposort(G)
    if tp is None:
        print(""NO"")
    else:
        print(""YES"")
        print(*[x+1 for x in tp])


def toposort(graph):
    res, found = [], [0] * len(graph)
    stack = list(range(len(graph)))
    while stack:
        node = stack.pop()
        if node < 0:
            res.append(~node)
        elif not found[node]:
            found[node] = 1
            stack.append(~node)
            stack += graph[node]

    # cycle check
    for node in res:
        if any(found[nei] for nei in graph[node]):
            return None
        found[node] = 0

    return res[::-1]

import sys, os, io
input = lambda: sys.stdin.readline().rstrip('\r\n')
stdout = io.BytesIO()
sys.stdout.write = lambda s: stdout.write(s.encode(""ascii""))

main()

os.write(1, stdout.getvalue())
",np,"bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings",1710
"
def divisors(M):
    d=[]
    i=1
    while M>=i**2:
        if M%i==0:
            d.append(i)
            if i**2!=M:
                d.append(M//i)
        i=i+1
    return d

def popcount(x):
    x = x - ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x + (x >> 4)) & 0x0f0f0f0f
    x = x + (x >> 8)
    x = x + (x >> 16)
    return x & 0x0000007f

def eratosthenes(n):
    res=[0 for i in range(n+1)]
    prime=set([])
    for i in range(2,n+1):
        if not res[i]:
            prime.add(i)
            for j in range(1,n//i+1):
                res[i*j]=1
    return prime

def factorization(n):
    res=[]
    for p in prime:
        if n%p==0:
            while n%p==0:
                n//=p
            res.append(p)
    if n!=1:
        res.append(n)
    return res

def euler_phi(n):
    res = n
    for x in range(2,n+1):
        if x ** 2 > n:
            break
        if n%x==0:
            res = res//x * (x-1)
            while n%x==0:
                n //= x
    if n!=1:
        res = res//n * (n-1)
    return res

def ind(b,n):
    res=0
    while n%b==0:
        res+=1
        n//=b
    return res

def isPrimeMR(n):
    d = n - 1
    d = d // (d & -d)
    L = [2, 3, 5, 7, 11, 13, 17]
    for a in L:
        t = d
        y = pow(a, t, n)
        if y == 1: continue
        while y != n - 1:
            y = (y * y) % n
            if y == 1 or t == n - 1: return 0
            t <<= 1
    return 1
def findFactorRho(n):
    from math import gcd
    m = 1 << n.bit_length() // 8
    for c in range(1, 99):
        f = lambda x: (x * x + c) % n
        y, r, q, g = 2, 1, 1, 1
        while g == 1:
            x = y
            for i in range(r):
                y = f(y)
            k = 0
            while k < r and g == 1:
                ys = y
                for i in range(min(m, r - k)):
                    y = f(y)
                    q = q * abs(x - y) % n
                g = gcd(q, n)
                k += m
            r <<= 1
        if g == n:
            g = 1
            while g == 1:
                ys = f(ys)
                g = gcd(abs(x - ys), n)
        if g < n:
            if isPrimeMR(g): return g
            elif isPrimeMR(n // g): return n // g
            return findFactorRho(g)
def primeFactor(n):
    i = 2
    ret = {}
    rhoFlg = 0
    while i*i <= n:
        k = 0
        while n % i == 0:
            n //= i
            k += 1
        if k: ret[i] = k
        i += 1 + i % 2
        if i == 101 and n >= 2 ** 20:
            while n > 1:
                if isPrimeMR(n):
                    ret[n], n = 1, 1
                else:
                    rhoFlg = 1
                    j = findFactorRho(n)
                    k = 0
                    while n % j == 0:
                        n //= j
                        k += 1
                    ret[j] = k

    if n > 1: ret[n] = 1
    if rhoFlg: ret = {x: ret[x] for x in sorted(ret)}
    return ret

def divisors(n):
    res = [1]
    prime = primeFactor(n)
    for p in prime:
        newres = []
        for d in res:
            for j in range(prime[p]+1):
                newres.append(d*p**j)
        res = newres
    res.sort()
    return res

def xorfactorial(num):
    if num==0:
        return 0
    elif num==1:
        return 1
    elif num==2:
        return 3
    elif num==3:
        return 0
    else:
        x=baseorder(num)
        return (2**x)*((num-2**x+1)%2)+function(num-2**x)

def xorconv(n,X,Y):
    if n==0:
        res=[(X[0]*Y[0])%mod]
        return res
    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]
    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]
    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]
    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]
    res1=xorconv(n-1,x,y)
    res2=xorconv(n-1,z,w)
    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]
    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]
    former=list(map(lambda x:x%mod,former))
    latter=list(map(lambda x:x%mod,latter))
    return former+latter

def merge_sort(A,B):
    pos_A,pos_B = 0,0
    n,m = len(A),len(B)
    res = []
    while pos_A < n and pos_B < m:
        a,b = A[pos_A],B[pos_B]
        if a < b:
            res.append(a)
            pos_A += 1
        else:
            res.append(b)
            pos_B += 1
    res += A[pos_A:]
    res += B[pos_B:]
    return res

class UnionFindVerSize():
    def __init__(self, N):
        self._parent = [n for n in range(0, N)]
        self._size = [1] * N
        self.group = N

    def find_root(self, x):
        if self._parent[x] == x: return x
        self._parent[x] = self.find_root(self._parent[x])
        stack = [x]
        while self._parent[stack[-1]]!=stack[-1]:
            stack.append(self._parent[stack[-1]])
        for v in stack:
            self._parent[v] = stack[-1]
        return self._parent[x]

    def unite(self, x, y):
        gx = self.find_root(x)
        gy = self.find_root(y)
        if gx == gy: return

        self.group -= 1

        if self._size[gx] < self._size[gy]:
            self._parent[gx] = gy
            self._size[gy] += self._size[gx]
        else:
            self._parent[gy] = gx
            self._size[gx] += self._size[gy]

    def get_size(self, x):
        return self._size[self.find_root(x)]

    def is_same_group(self, x, y):
        return self.find_root(x) == self.find_root(y)

class WeightedUnionFind():
    def __init__(self,N):
        self.parent = [i for i in range(N)]
        self.size = [1 for i in range(N)]
        self.val = [0 for i in range(N)]
        self.flag = True
        self.edge = [[] for i in range(N)]

    def dfs(self,v,pv):
        stack = [(v,pv)]
        new_parent = self.parent[pv]
        while stack:
            v,pv = stack.pop()
            self.parent[v] = new_parent
            for nv,w in self.edge[v]:
                if nv!=pv:
                    self.val[nv] = self.val[v] + w
                    stack.append((nv,v))

    def unite(self,x,y,w):
        if not self.flag:
            return
        if self.parent[x]==self.parent[y]:
            self.flag = (self.val[x] - self.val[y] == w)
            return

        if self.size[self.parent[x]]>self.size[self.parent[y]]:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[x] += self.size[y]
            self.val[y] = self.val[x] - w
            self.dfs(y,x)
        else:
            self.edge[x].append((y,-w))
            self.edge[y].append((x,w))
            self.size[y] += self.size[x]
            self.val[x] = self.val[y] + w
            self.dfs(x,y)

class Dijkstra():
    class Edge():
        def __init__(self, _to, _cost):
            self.to = _to
            self.cost = _cost

    def __init__(self, V):
        self.G = [[] for i in range(V)]
        self._E = 0
        self._V = V

    @property
    def E(self):
        return self._E

    @property
    def V(self):
        return self._V

    def add_edge(self, _from, _to, _cost):
        self.G[_from].append(self.Edge(_to, _cost))
        self._E += 1

    def shortest_path(self, s):
        import heapq
        que = []
        d = [10**15] * self.V
        d[s] = 0
        heapq.heappush(que, (0, s))

        while len(que) != 0:
            cost, v = heapq.heappop(que)
            if d[v] < cost: continue

            for i in range(len(self.G[v])):
                e = self.G[v][i]
                if d[e.to] > d[v] + e.cost:
                    d[e.to] = d[v] + e.cost
                    heapq.heappush(que, (d[e.to], e.to))
        return d

#Z[i]:length of the longest list starting from S[i] which is also a prefix of S
#O(|S|)
def Z_algorithm(s):
    N = len(s)
    Z_alg = [0]*N

    Z_alg[0] = N
    i = 1
    j = 0
    while i < N:
        while i+j < N and s[j] == s[i+j]:
            j += 1
        Z_alg[i] = j
        if j == 0:
            i += 1
            continue
        k = 1
        while i+k < N and k + Z_alg[k]<j:
            Z_alg[i+k] = Z_alg[k]
            k += 1
        i += k
        j -= k
    return Z_alg

class BIT():
    def __init__(self,n,mod=0):
        self.BIT = [0]*(n+1)
        self.num = n
        self.mod = mod

    def query(self,idx):
        res_sum = 0
        mod = self.mod
        while idx > 0:
            res_sum += self.BIT[idx]
            if mod:
                res_sum %= mod
            idx -= idx&(-idx)
        return res_sum

    #Ai += x O(logN)
    def update(self,idx,x):
        mod = self.mod
        while idx <= self.num:
            self.BIT[idx] += x
            if mod:
                self.BIT[idx] %= mod
            idx += idx&(-idx)
        return

class dancinglink():
    def __init__(self,n,debug=False):
        self.n = n
        self.debug = debug
        self._left = [i-1 for i in range(n)]
        self._right = [i+1 for i in range(n)]
        self.exist = [True for i in range(n)]

    def pop(self,k):
        if self.debug:
            assert self.exist[k]
        L = self._left[k]
        R = self._right[k]
        if L!=-1:
            if R!=self.n:
                self._right[L],self._left[R] = R,L
            else:
                self._right[L] = self.n
        elif R!=self.n:
            self._left[R] = -1
        self.exist[k] = False

    def left(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._left[res]
            if res==-1:
                break
            k -= 1
        return res

    def right(self,idx,k=1):
        if self.debug:
            assert self.exist[idx]
        res = idx
        while k:
            res = self._right[res]
            if res==self.n:
                break
            k -= 1
        return res

class SparseTable():
    def __init__(self,A,merge_func,ide_ele):
        N=len(A)
        n=N.bit_length()
        self.table=[[ide_ele for i in range(n)] for i in range(N)]
        self.merge_func=merge_func

        for i in range(N):
            self.table[i][0]=A[i]

        for j in range(1,n):
            for i in range(0,N-2**j+1):
                f=self.table[i][j-1]
                s=self.table[i+2**(j-1)][j-1]
                self.table[i][j]=self.merge_func(f,s)

    def query(self,s,t):
        b=t-s+1
        m=b.bit_length()-1
        return self.merge_func(self.table[s][m],self.table[t-2**m+1][m])

class BinaryTrie:
    class node:
        def __init__(self,val):
            self.left = None
            self.right = None
            self.max = val

    def __init__(self):
        self.root = self.node(-10**15)

    def append(self,key,val):
        pos = self.root
        for i in range(29,-1,-1):
            pos.max = max(pos.max,val)
            if key>>i & 1:
                if pos.right is None:
                    pos.right = self.node(val)
                    pos = pos.right
                else:
                    pos = pos.right
            else:
                if pos.left is None:
                    pos.left = self.node(val)
                    pos = pos.left
                else:
                    pos = pos.left
        pos.max = max(pos.max,val)

    def search(self,M,xor):
        res = -10**15
        pos = self.root
        for i in range(29,-1,-1):
            if pos is None:
                break

            if M>>i & 1:
                if xor>>i & 1:
                    if pos.right:
                        res = max(res,pos.right.max)
                    pos = pos.left
                else:
                    if pos.left:
                        res = max(res,pos.left.max)
                    pos = pos.right
            else:
                if xor>>i & 1:
                    pos = pos.right
                else:
                    pos = pos.left

        if pos:
            res = max(res,pos.max)
        return res

def solveequation(edge,ans,n,m):
    #edge=[[to,dire,id]...]
    x=[0]*m
    used=[False]*n
    for v in range(n):
        if used[v]:
            continue
        y = dfs(v)
        if y!=0:
            return False
    return x

    def dfs(v):
        used[v]=True
        r=ans[v]
        for to,dire,id in edge[v]:
            if used[to]:
                continue
            y=dfs(to)
            if dire==-1:
                x[id]=y
            else:
                x[id]=-y
            r+=y
        return r

class SegmentTree:
    def __init__(self, init_val, segfunc, ide_ele):
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        self.size = n
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        k += self.num
        self.tree[k] = x
        while k > 1:
            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])
            k >>= 1

    def query(self, l, r):
        if r==self.size:
            r = self.num

        res = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                res = self.segfunc(res, self.tree[r - 1])
            l >>= 1
            r >>= 1
        return res

    def bisect_l(self,l,r,x):
        l += self.num
        r += self.num
        Lmin = -1
        Rmin = -1
        while l<r:
            if l & 1:
                if self.tree[l] <= x and Lmin==-1:
                    Lmin = l
                l += 1
            if r & 1:
                if self.tree[r-1] <=x:
                    Rmin = r-1
            l >>= 1
            r >>= 1

        if Lmin != -1:
            pos = Lmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        elif Rmin != -1:
            pos = Rmin
            while pos<self.num:
                if self.tree[2 * pos] <=x:
                    pos = 2 * pos
                else:
                    pos = 2 * pos +1
            return pos-self.num
        else:
            return -1

import sys,random,bisect
from collections import deque,defaultdict
from heapq import heapify,heappop,heappush
from itertools import permutations
from math import gcd,log

input = lambda :sys.stdin.readline().rstrip()
mi = lambda :map(int,input().split())
li = lambda :list(mi())

N,K = mi()
S = input()
S = [ord(S[i])-ord(""a"") for i in range(N)]

pow_2 = [pow(2,i) for i in range(K)]
k = K


def cond(n):
    cnt = [0 for i in range(k)]
    v = 0
    for i in range(n):
        if not  0<= S[i] < k:
            continue
        if cnt[S[i]]==0:
            v += 1
        cnt[S[i]] += 1

    str_range = [[N for j in range(N)] for i in range(k)]
    if v==1:
        for i in range(k):
            if cnt[i]:
                str_range[i][0] = 0
    elif v==0:
        for i in range(k):
            str_range[i][0] = 0

    for i in range(n,N):
        if 0 <= S[i-n] < k:
            cnt[S[i-n]] -= 1
            if cnt[S[i-n]] == 0:
                v -= 1
        if 0 <= S[i] < k:
            cnt[S[i]] += 1
            if cnt[S[i]] == 1:
                v += 1

        if v==1:
            for j in range(k):
                if cnt[j]:
                    for l in range(i-n+1,-1,-1):
                        if str_range[j][l] == N:
                            str_range[j][l] = i - n + 1
                        else:
                            break
                    break
        elif v==0:
            for j in range(k):
                for l in range(i-n+1,-1,-1):
                    if str_range[j][l] == N:
                        str_range[j][l] = i - n + 1
                    else:
                        break

    INF = N + 1
    dp = [INF for bit in range(1<<k)]
    dp[0] = 0

    for bit in range(1<<k):
        if dp[bit]>=N:
            continue
        idx = dp[bit]
        for i in range(k):
            if not bit >> i & 1:
                nv = bit|pow_2[i]
                tmp = str_range[i][idx] + n
                dp[nv] = min(dp[nv],tmp)

    return dp[-1]!=INF

ok = 0
ng = N+1
while ng-ok>1:
    mid = (ok+ng)//2
    if cond(mid):
        ok = mid
    else:
        ng = mid

print(ok)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",16517
"import sys
input = lambda: sys.stdin.readline().rstrip()

N, K = map(int, input().split())
S = [-1 if a == ""?"" else ord(a) - 97 for a in input()]
II = {1 << i: i for i in range(20)}
def calc(mmm):
    inf = 300000
    X = [[0] * N for _ in range(K)]
    for k in range(K):
        Xk = X[k]
        mi = inf
        r = 0
        for i in range(N)[::-1]:
            if S[i] < 0 or S[i] == k:
                r += 1
            else:
                r = 0
            if r >= mmm:
                mi = min(mi, i + mmm)
            Xk[i] = mi

    Y = [0] * (1 << K)
    for i in range(1, 1 << K):
        mi = inf
        for j in range(K):
            if i >> j & 1:
                ii = i ^ (1 << j)
                if Y[ii] < N:
                    mi = min(mi, X[j][Y[ii]])
        Y[i] = mi
    return 1 if Y[-1] < inf else 0
    
l, r = 0, N // K + 1
while r - l > 1:
    m = l + r >> 1
    if calc(m):
        l = m
    else:
        r = m
print(l)

",np,"binary search,bitmasks,brute force,dp,strings,two pointers",957
"import sys
input = sys.stdin.readline

n, k = map(int, input().split())
s = input()[:-1]
left, right = 0, n
while left < right:
    mid = right - (right - left) // 2
    A = [[0] * (n + 2) for _ in range(k)]

    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1
        L = 0
        for i in range(n - 1, -1, -1):
            if s[i] == '?' or ord(s[i]) - ord('a') == c: L += 1
            else: L = 0
            A[c][i] = i + mid if L >= mid else A[c][i + 1]

    dp = [n + 1] * (1 << k)
    dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i
            dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",np,"binary search,bitmasks,brute force,dp,strings,two pointers",755
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
maxconseq = [[0 for j in range(k)] for i in range(n+1)]
for i in range(n):
    if s[i]==ord('?'):
        for j in range(k):
            maxconseq[i][j] = maxconseq[i-1][j] + 1
    else:
        j = s[i]-97
        maxconseq[i][j] = maxconseq[i-1][j] + 1
 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 
    
    for j in range(k):
        for i in range(n)[::-1]:
            if maxconseq[i][j]>=needed:
                effect[j][i-needed+1] = i+1
            effect[j][i] = min(effect[j][i], effect[j][i+1])


   
                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",1403
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
#            print(j,i,accu)            
            effect[j][i] = index


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",1313
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = effect[j][i+4-4]


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",1316
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf)


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",1342
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i+4-4],effect[j][i+3-3],inf*inf)


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",1346
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
            effect[j][i] = min(effect[j][i],inf)


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",1321
"import io,os
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
from collections import deque 

 
n, k = map(int,input().split())
s = input()

 
 
 
def judge(needed):
 
    
    inf = 2147483647
    minstate = [inf]*(1<<k)
    minstate[0] = 0
 
    effect = [[inf]*(n+1) for j in range(k)]
 

    
    for j in range(k):
        accu = 0
        index = inf
        for i in range(n)[::-1]:
            if s[i]==ord('?') or s[i]==97+j:
                accu += 1
            else:
                accu = 0

   

            if accu>=needed:
                index = i + needed
            effect[j][i] = index
#            effect[j][i] = min(effect[j][i],inf*inf+inf*inf)


   
#    print(effect)                
             

    for state in range(1,1<<k):

        minimum = minstate[state]

        for j in range(k):
            if (1<<j) & state==0: continue

            index = minstate[state^(1<<j)]
            if index<n:
                minimum = min(minimum, effect[j][index]) 



        minstate[state] = minimum 
   
 
#    print(minstate) 
 
 
 
    if minstate[-1]<=n:  return True
    return False
 
 
front = 0
rear = n//k+1
 
while front < rear:
    mid = (front+rear)//2
    flag = judge(mid)
#    print(mid,flag)
 
    if flag:  
        front = mid + 1
    else:
        rear = mid 
 
print(front-1)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",1334
"import sys;input = sys.stdin.readline;n, k = map(int, input().split());s = input()[:-1];left, right = 0, n
while left < right:
    mid = right - (right - left) // 2;A = [[0] * (n + 2) for _ in range(k)]
    for c in range(k):
        A[c][n] = A[c][n + 1] = n + 1;L = 0
        for i in range(n - 1, -1, -1):L = (L + 1 if s[i] == '?' or ord(s[i]) - ord('a') == c else 0);A[c][i] = i + mid if L >= mid else A[c][i + 1]
    dp = [n + 1] * (1 << k);dp[0] = 0
    for mask in range(1 << k):
        for i in range(k):
            if mask >> k & 1: continue
            t = mask | 1 << i;dp[t] = min(dp[t], A[i][dp[mask]])
    if dp[-1] <= n: left = mid
    else: right = mid - 1
print(left)",np,"binary search,bitmasks,brute force,dp,strings,two pointers",686
"import sys

# sys.setrecursionlimit(200005)
int1 = lambda x: int(x)-1
p2D = lambda x: print(*x, sep=""\n"")
def II(): return int(sys.stdin.readline())
def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(rows_number): return [LI() for _ in range(rows_number)]
def LI1(): return list(map(int1, sys.stdin.readline().split()))
def LLI1(rows_number): return [LI1() for _ in range(rows_number)]
def SI(): return sys.stdin.readline().rstrip()
inf = 10**16
md = 10**9+7
# md = 998244353

n, k = LI()
s = [-1 if c == ""?"" else ord(c)-97 for c in SI()]

def ok(m):
    nxt = [[n]*(n+1) for _ in range(k)]
    for j in range(k):
        cnt = 0
        ni = n
        nxtj = nxt[j]
        for i in range(n)[::-1]:
            if s[i] == -1 or s[i] == j: cnt += 1
            else: cnt = 0
            if cnt >= m: ni = i
            nxtj[i] = ni
    dp = [n+1]*(1 << k)
    dp[0] = 0
    for bit in range(1 << k):
        l = dp[bit]
        if l+m > n: continue
        for j in range(k):
            if bit >> j & 1: continue
            i = nxt[j][l]
            if i+m <= n:
                nbit = bit | 1 << j
                dp[nbit] = min(dp[nbit], i+m)
    return dp[-1] <= n

l, r = 0, n//k+1
while l+1 < r:
    m = (l+r)//2
    if ok(m): l = m
    else: r = m

print(l)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",1285
"N, K = list(map(int, input().split()))
S = input().strip()
S = [-1 if _ == '?' else ord(_) - ord('a') for _ in S]

def check(x):
    p = [[N for i in range(N+1)] for k in range(K)]

    for k in range(K):
        keep = 0
        for i in range(N-1, -1, -1):
            keep += 1
            if S[i] != -1 and S[i] != k:
                keep = 0
            p[k][i] = p[k][i+1]
            if keep >= x:
                p[k][i] = i + x - 1

    d = [N for s in range(1<<K)]
    d [0] = -1
    for s in range(1, 1<<K):
        for k in range(K):
            if (s&(1<<k)) and (d[s^(1<<k)]<N):
                d[s] = min(d[s], p[k][d[s^(1<<k)]+1])
                # print('d[%d%d]=%d'%(s//2, s%2, d[s]))
    return d[(1<<K)-1] < N
    
l, r = 0, N//K

while l < r:
    mid = (l + r + 1) // 2
    if check(mid):
        l = mid
    else:
        r = mid - 1
print(l)
",np,"binary search,bitmasks,brute force,dp,strings,two pointers",865
